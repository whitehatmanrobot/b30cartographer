e) library[id];

             if(t == null)
                 return false;
 
             if (!locales.ContainsValue(languageId))
                 languageId = defaultLanguageId;
 
             return t.ContainsKey(languageId);
         }

     } // class StringLibrary
 
 



    public class ImageProp
    {
        string titleId;
        string imageType;
        string imageFile;
        ulong  imageId;

        /* ImageLibary (constructor)
         * ------------------------------------
         * The constructor is used to validate the Images section of
         * the GCP portion of the XLAST file and to create a simply
         * mapping of image IDs to actual file+path specifications.
         *
         * The intention here is to weed out Images that may not have
         * an id specified or an actual file
         *
         * Parameters:  
         *
         *
        */
        public ImageProp(string _titleId, string _imageType, ulong _imageId, string _imageFile)
        {
            titleId   = _titleId;
            imageType = _imageType;
            imageId   = _imageId;
            imageFile = _imageFile;
        }


        public bool PropToStorage()
        {
            //    achievement:  //global/t:<titleId>/ach/0/<image id>
            //    gamertiles:   //global/t:<titleid>/tile/0/<image id>
            //    game icon:    //global/t:<titleid>/icon/0/8000
            //    mktplc icon:  //global/t:<titleid>/marketplace/0/1

            string  storagePath = "//global/t:" + titleId + "/" + imageType + "/0/" + imageId.ToString("X").ToLower();

            uint    uTitleId = UInt32.Parse(titleId, NumberStyles.HexNumber);

            try
            {
                StUtil.Write(0, 0, storagePath, uTitleId, true, imageFile);

            }
            catch (Exception e)
            {
                Console.WriteLine("StUtil.Write() generated an exception: " + e.Message);
                return false;
            }

            return true;
        }
    } // class ImageProp



    public class ImageLibrary : BaseLibrary
    {
        Hashtable   library;
        ArrayList   proplist;
        string      strTitleId;

        
        /* ImageLibary (constructor)
         * ------------------------------------
         * The constructor is used to validate the Images section of
         * the GCP portion of the XLAST file and to create a simply
         * mapping of image IDs to actual file+path specifications.
         *
         * The intention here is to weed out Images that may not have
         * an id specified or an actual file
         *
        */

        public ImageLibrary(uint titleId, Images images, Achievements achievements, GamerPictures gamerPictures, string localPath)
            : this(false,0, titleId, images, achievements, gamerPictures, localPath)
        {
        }

        public ImageLibrary(bool typeSpecified, ulong titleType, uint titleId, Images images, Achievements achievements, GamerPictures gamerPictures, string localPath) : base()
        {
            ulong      gameIconId  = (ulong) 32768;  //  0x8000 = Game Icon image ID (related to X_IMAGEID_GAME in xam.x)
            ulong      mktplIconId = (ulong) 32772;  // '0x8004 = Marketplace Icon image ID  (related to X_IMAGEID_GAME_MARKETPLACE in xam.x)

            library   = new Hashtable();
            proplist  = new ArrayList();

            strTitleId = titleId.ToString("x");

            //-----------------------------------------------------------------
            // First we need to examine each Image in the Images section and 
            // confirm that the file associated with it is actually present
            // 
            if (images.Image != null)
            {
                foreach (Image x in images.Image)
                {
                    if (!x.idSpecified)
                    {
                        errors.Add("Image " + x.friendlyName + " does not have an ID");
                        continue;
                    }

                    string  fspec  = x.Path;
                    int     delim  = fspec.LastIndexOf('\\');
                    string  name   = localPath + "\\" + ((delim<0) ? fspec.ToLower() : fspec.Substring(delim+1, fspec.Length - delim - 1).ToLower());

                    //bug 44000 - System titles are not required to supply title and marketplace images. 
                    //SPAC already verifies all paths for non-system titles.  Since only system
                    //titles can have blank image paths, and only for the Marketplace and Game Tile images,
                    //then it's ok to pass on a blank image without further verification, since only system 
                    //titles should have this property
                    //For maintenance... it's not good to have the same check in multiple places.

                    //But, in case someone wants to verify this more carefully here, this is the information
                    ///// TitleType defines whether this title is a full game, a demo, a download, etc.
                    //public enum TitleType : uint
                    //{
                    //    System                  = 0x00000000,
                    //    Full                    = 0x00000001,
                    //    Demo                    = 0x00000002,
                    //    Download                = 0x00000003,
                    //}

                    if ( fspec.Length == 0 )
                    {
                        continue;
                    }

                    if (!File.Exists(name ))
                    {
                        errors.Add("Image " + x.friendlyName + " file " + name + " was not found in " + localPath);
                        continue;
                    }
                                     
                    if (library[x.id] != null)
                    {
                        // uh oh, this Id is already in the library which means the XLAST specified the same value twice!
                        errors.Add("Image " + x.friendlyName + " id of " + x.id + " is already in use (specified twice in XLAST)" );
                        continue;
                    }

                    library.Add(x.id, name);
                }
            }

            //-----------------------------------------------------------------
            // Now, go through all the entries in the GCP that could refer to
            // these images so we can determine what the type of the image is
            // and construct the storage path accordingly
            // 
            if (library[gameIconId] != null)
            {
                proplist.Add(new ImageProp(strTitleId, "icon", gameIconId, (string)library[gameIconId]));
            }
            else
            {
                if (!typeSpecified || titleType != 0)
                {
                    errors.Add("Game icon specified an image does not exist or was not valid");
                }
            }

            if (library[mktplIconId] != null)
            {
                proplist.Add(new ImageProp(strTitleId, "marketplace", 1, (string)library[mktplIconId]));  // storage path for marketplace image uses a '1' instead of the actual image ID
            }
            else
            {
                if (!typeSpecified || titleType != 0)
                {
                    errors.Add("Marketplace icon specified an image does not exist or was not valid");
                }
            }

            if (achievements != null && achievements.Achievement != null)
            {
                foreach (XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievement x in achievements.Achievement)
                {
                    if (x.imageIdSpecified)
                    {
                        if (library[x.imageId] != null)
                        {
                            proplist.Add(new ImageProp(strTitleId, "ach", x.imageId, (string)library[x.imageId]));
                        }
                        else
                        {
                            errors.Add("Achievement " + x.friendlyName + " specified an imageId " + x.imageId + " that either does not exist or was not valid");
                        }
                    }
                    else
                    {
                        errors.Add("Achievement " + x.friendlyName + "did not specify an associated image");
                    }
                }
            }
    

            if (gamerPictures != null && gamerPictures.Picture != null)
            {
                foreach (Picture x in gamerPictures.Picture)
                {
                    if (x.idSpecified)
                    {
                        // GamerTile images are a little different:  The id attribute in the Picture element is
                        // actually the low order word of the Image id.  In order to support large and small
                        // images, we need to add 0x10000 and 0x20000 to this picture id
                        //
                        if ((x.id & 0xFFFF0000) == 0)
                        {
                            ulong imageId;
    
                            imageId = x.id | 0x10000;
                            if (library[imageId] != null)
                                proplist.Add(new ImageProp(strTitleId, "tile", imageId, (string)library[imageId]));
                            else
                                errors.Add("Gamer Picture (small)" + x.friendlyName + " specified an imageId " + imageId + " that either does not exist or was not valid");
                            
                            imageId = x.id | 0x20000;
                            if (library[imageId] != null)
                                proplist.Add(new ImageProp(strTitleId, "tile", imageId, (string)library[imageId]));
                            else
                                errors.Add("Gamer Picture (large)" + x.friendlyName + " specified an imageId " + imageId + " that either does not exist or was not valid");
                        }
                        else
                        {
                            errors.Add("Gamer Picture " + x.friendlyName + " specified an imageId " + x.id + " that had reserved bits in the high order word set");
                        }
                    
                    }
                    else
                    {
                        errors.Add("Gamer Picture " + x.friendlyName + " did not specify an associated image");
                    }
                }
            }
        } // ImageLibrary(ctor)



        public bool PropImages()
        {
            bool fOk = true;

            foreach (ImageProp x in proplist)
            {
                if (!x.PropToStorage())
                    fOk = false;
            }

            return fOk;
        }
    } // class ImageLibrary









    public class ReferenceData : BaseLibrary
    {
        public Hashtable   hdtvModes;
        public Hashtable   ratings;
        public Hashtable   genres;

        
        /* ReferenceData (constructor)
         * ------------------------------------
         * The constructor has two functions>
         * 1) to load all dynamic reference data from any online databases
         * 2) to perform all possible XLAST validation against this data
         *
         * The intention here is to weed out Images that may not have
         * an id specified or an actual file
         *
         * Parameters:  
         *
         *
        */
        public ReferenceData(ProductInformation info)  : base()
        {
            hdtvModes = new Hashtable(30);
            ratings   = new Hashtable(100);
            genres    = new Hashtable(50);
    
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;
                ws.StoredProc      = "dbo.p_svc_get_HDTVModes";
                
                WstDataReader r = ws.Execute();

                while (r.Read())
                {
                    if (r.GetValue(0) != DBNull.Value && r.GetValue(1) != DBNull.Value)
                    {
                        uint hdtvMode       = (uint)r.GetInt32(0);
                        uint hdtvSystem     = (uint)r.GetInt32(1);
                        hdtvModes.Add(hdtvMode, hdtvSystem);
                    }
                }
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;
                ws.StoredProc      = "dbo.p_svc_get_rating_systems";
                
                WstDataReader r = ws.Execute();

                while (r.Read())
                {
                    if (r.GetValue(0) != DBNull.Value && r.GetValue(1) != DBNull.Value)
                    {
                        uint ratingId       = (uint)r.GetInt32(1);
                        uint ratingSystem   = (uint)r.GetInt32(0);
                        ratings.Add(ratingId, ratingSystem);
                    }
                }
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;
                ws.StoredProc      = "dbo.p_svc_get_genres";
                
                WstDataReader r = ws.Execute();

                while (r.Read())
                {
                    if (r.GetValue(0) != DBNull.Value && r.GetValue(1) != DBNull.Value)
                    {
                        uint genreId       = (uint)r.GetInt32(0);
                        uint productTypeId = (uint)r.GetInt32(1);
                        genres.Add(genreId, productTypeId);
                    }
                }
            }


            //-----------------------------------------------------------------
            // DATA VALIDATION
            //-----------------------------------------------------------------
            if (info != null)
            {
                if (info.HdtvMode != null)
                {
                    foreach (HdtvMode x in info.HdtvMode)
                        if (!IsValidHdtvData(x.hdtvId, x.hdtvSystemId))
                            errors.Add("HdtvMode specification did not match known values: Id = " + x.hdtvId + ", System = " + x.hdtvSystemId);
                }
    
                if (info.Rating != null)
                {
                    foreach (Rating x in info.Rating)
                        if (!IsValidRatingData(x.ratingId, x.ratingSystemId))
                            errors.Add("Rating specification did not match known values: Id = " + x.ratingId + ", System = " + x.ratingSystemId);
                }
    
                if (info.Genre != null)
                {
                    foreach (Genre x in info.Genre)
                        if (!IsValidGenreData(x.genreId))
                            errors.Add("Genre specification did not match known values: Id = " + x.genreId);
                }
            }
    
        } // ReferenceData(ctor)

        bool IsValidHdtvData(uint id, uint system)
        {
            if (hdtvModes[id] != null)
                if ((uint)hdtvModes[id] == system)
                    return  true;

            return false;
        }

        bool IsValidRatingData(uint id, uint system)
        {
            if (ratings[id] != null)
                if ((uint)ratings[id] == system)
                    return  true;

            return false;
        }

        bool IsValidGenreData(uint id)
        {
            if (genres.ContainsKey(id))
                return  true;

            return false;
        }

    } // class ReferenceData


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_tools_none_12.4.56.0_none_f2ffcd927ae25598
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_tools_no-public-key_12.4.56.0_x-ww_7ee24bde
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=tools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_tools_no-public-key_12.4.56.0_x-ww_7ee24bde
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_tools_no-public-key_12.4.56.0_x-ww_7ee24bde.manifest
XP_MANIFEST_PATH=manifests\msil_tools_no-public-key_12.4.56.0_x-ww_7ee24bde.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_tools_no-public-key_12.4.56.0_x-ww_7ee24bde.cat
XP_CATALOG_PATH=manifests\msil_tools_no-public-key_12.4.56.0_x-ww_7ee24bde.cat
XP_PAYLOAD_PATH=msil_tools_no-public-key_12.4.56.0_x-ww_7ee24bde
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=tools,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\CheckReady.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient; 

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.tools.console;
using xonline.tools.framework;

//using XBOX.Tools.Framework;
//using XBOX.Utilities;
//using XBOX.Utilities.Console;

[assembly: XomAreaDefinition(XomAreaName.checkready)]

namespace xonline.common.tools
{
	/// <summary>
	/// Hopefully, this will be the last time we write a class to check this sort of stuff... 
	/// </summary>
    public class CheckReady
    {

        // since environment checks are fairly application specific,
        // anyone else who wants to use CheckReady should subclass it
        // and change the implementation of CheckReadyMain
        // Please feel free to add other checks which need to be added
        // added command line output. remove it for server uses.. 
        public static bool CheckReadyMain( NamedArgParser parsedArgs, out string results )
        {

            bool checkResult = true;

            results = "";               //printed at the end for summary of all tests
            string testResult = "";     //printed as the cumulative details of each test

            Console.WriteLine( "\nChecking if tool can read input file: " + parsedArgs[ "inputfile" ] );
            // confirm input file can be read from
            if ( ( parsedArgs[ "inputfile" ] != null ) && CheckReadFile( parsedArgs[ "inputfile" ] ) )
            {
                // everything's working!
                results += "\r\n    Tool is able to find and read the input file.";
            }
            else
            {
                // houston, we have a problem
                checkResult = false;
                // write error to result string
                results += "\r\n!!  Tool is not able to find read the input file!";
            }

            // confirm sps
            // SPS Test Connection
            Console.WriteLine( "Checking SPS Connectivity....." );
            if ( CheckSPS() )
            {
                // everything's working!
                results += "\r\n    Tool is able to connect to SPS.";
            }
            else
            {
                // houston, we have a problem... 
                results += "\r\n!!  Tool is not able to connect to SPS!";
                checkResult = false;
            }
            
            // confirm uodb
            Console.WriteLine( "Checking connectivity to Webstore UODB ....." );
            if ( CheckWebstore( ConfigUtil.UodbWebstoreApp ) )
            {
                // everything's working!
                results += "\r\n    Tool is able to connect to UODB.";
            }
            else
            {
                // houston, we have a problem... 
                results += "\r\n!!  Tool is not able to connect to UODB!";
                checkResult = false;
            }

            string connectionString = "Data Source=" +  parsedArgs[ "serialsql" ] + ";Trusted_Connection=Yes;Initial Catalog=" + parsedArgs[ "serialdb" ];
            // confirm SerialDB
            Console.WriteLine( "Checking connectivity to SerialDB ....." );
            if ( CheckDB( connectionString, ref testResult ) )
            {
                // everything's working!
                results += "\r\n    Tool is able to connect to SerialDB!";
            }
            else
            {
                // houston, we have a problem... 
                results += "\r\n!!  Tool is not able to connect to SerialDB!";
                checkResult = false;
            }
            results += testResult;

            return checkResult;

        }

	//
        public static bool ParamCheck( NamedArgParser args, string argName, bool console)
        {
            //if arg doesn't exist, return false
            if ( args[ argName ] == null )
            {
		        if ( console )
                {
                    Console.WriteLine( "==> {0} Parameter must be supplied.", argName );
                }

                Xom.Trace(XomAreaName.checkready, LogLevel.L_WARNING, "Parameter " + argName + " was null." );

                return false;
            }
            else
            {
                return true;
            }
        }

        //task: should change this to write to Auditdb, or log, or have OUT string param, not REF 
        public static bool CheckDB( string connection, ref string dbResults )
        {

            bool check = false; 

            try  
            {
                using (SqlConnection checkConn = new SqlConnection( connection ) )
                {
                    //results = "Open connection to " + connection + "\r\n";
                    checkConn.Open();
                    //results += "Connection opened\r\n";
                    SqlCommand checkCmd = checkConn.CreateCommand();
                    checkCmd.CommandType = CommandType.Text;
                    checkCmd.CommandText = "select top 1 * from sysobjects";

                    //results += "Executing command \r\n";
                    SqlDataReader checkReader = checkCmd.ExecuteReader();

                    // do we have results?
                    if ( checkReader.Read() )
                    {
                        dbResults += "Connection Successful.\r\n";
                        check = true;
                    }
                    else
                    {
                        dbResults += "Error: Returning results from connection failed.\r\n";
                        check = false;
                    }
                } //using

            } // try
            catch (Exception e)
            {   
                dbResults += "\nError: Exception occurred: \n" + e.ToString();         
                check = false;
            }

            return check;
        }


        public static bool CheckWriteFile( string filePath )
        {
            bool result = false;

            try
            {
                //Console.WriteLine("Creating log file " + logfilepath + " ...");
                // Can we write to the output file location?
                StreamWriter textFile = new StreamWriter( filePath, true, System.Text.Encoding.UTF8);
                textFile.AutoFlush = true;
                
                // write to file, just a space
                //task: is this necessary? will creating the streamwriter create the file?
                textFile.Write(" ");

                // flush
                textFile.Flush();
                textFile.Close();

                // check file existence
                if ( File.Exists( filePath ) )
                {
                    result = true;
                }

            } // try

            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.checkready, LogLevel.L_NORMAL, "An error occurred writing to the file: \r\n" + filePath + e.Message + "\r\n\r\n" + e.StackTrace  );
                result = false;
            }
            
            return result;
        } // checkwritefile

        public static bool CheckReadFile( string filePath )
        {
            
            bool result = false;

            // Can we read from file location?
            try
            {
                StreamReader textFile = new StreamReader( filePath, System.Text.Encoding.UTF8 );

                // check file existence
                if ( System.IO.File.Exists( filePath ) )
                {
                    // test read
                    int nextChar = textFile.Peek();
                    if ( nextChar == -1 )
                    {
                        // end of file
                    }
                    result = true;
                    textFile.Close();
                }

            } // try

            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.checkready, LogLevel.L_NORMAL, "An error occurred reading from the file: \r\n" + filePath + e.Message + "\r\n\r\n" + e.StackTrace  );
                result = false;
            }
            
            return result;

        } // checkwritefile

        public static bool CheckSPS( )
        {

            try
            {
                // figure out what this should be
                UserBillingInfo ubi = new UserBillingInfo();
                return ( ubi.TestSPSConnection() );
            }
            catch (Exception e)
            {
                //task: take some action here
                Console.WriteLine( "\nAn error occurred connecting to SPS." );
                Console.WriteLine( "Error was " + e.ToString() );
                return false;
            }
        }

        public static bool CheckWebstore( string webstoreApplication )
        {

            bool check = false;

            try
            {
                using (WstConnection checkConn = new WstConnection( webstoreApplication ) )
                {
                
                    checkConn.Open();
                    WstCommand checkCmd = checkConn.CreateCommand();
                    checkCmd.CommandType = CommandType.Text;

                    checkCmd.Partition = WstCommand.AnyPartition;
                
                    checkCmd.CommandText = "select top 1 * from sysobjects";

                    WstDataReader wr = checkCmd.ExecuteReader();

                    // Load voucheroffers info 
                    if ( wr.Read() )
                    {
                        check = true;
                    }
                    else
                    {
                        check = false;
                    }

                } // using

            } // try
            catch (Exception e)
            {
                //task: take some action here
                Console.WriteLine( "\nAn error occurred connecting to " + webstoreApplication );
                Console.WriteLine( "Error was " + e.ToString() );
                check = false;
            }

            return check;
        }

        //check whether the root exists and can be written to / read from
        public static bool CheckTitleVault( )
        {
            bool check = true;

            try
            {
                //get config
                string vaultPath = Config.GetSetting( Setting.titlevault_root );

                //confirm titevault_root setting is not INVALID  value != "INVALID" 
                if ( vaultPath.IndexOf( "INVALID" ) >= 0 )
                {
                    return false;
                }

                //check
                check = Directory.Exists( vaultPath );
                
                string testPath = vaultPath + "\\" + "Checkready_" + Environment.MachineName + ".txt";
                
                if ( File.Exists( testPath ) )
                {
                    File.Delete( testPath );
                }

                if ( CheckWriteFile( testPath ) )
                {
                    if ( CheckReadFile( testPath ) )
                    {
                        File.Delete( testPath );
                    }
                    else
                    {
                        check = false;
                    }
                }
                else
                {
                    check = false;
                }
           
            }
            catch
            {
                check = false;
            }
            
            return check;

        }

    } // class checkready


    //task: should have named exceptions to check for here
    //dbnotavailable exception
    //readfilenotavailable exception
    //writefilenotavailable exception
    //spsnotavailabble exception


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\cmgmtcommand.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Specialized;

namespace xonline.common.tools
{
	/// <summary>
	/// 
	/// </summary>
	public class CMgmtCommand
	{
        // Change this static member to control timeouts of command execution
        public static int TimeoutMilliseconds = 60000; // 60 seconds

        public static string RunCommand(string target, string command)
        {
            TcpClient client = new TcpClient();
            string result = null;
            
            try
            {
                client.NoDelay = true;
                client.Connect(target, 4100);

                client.ReceiveTimeout = TimeoutMilliseconds;
                client.SendTimeout = TimeoutMilliseconds;

                NetworkStream stream = client.GetStream();
                StreamReader reader = new StreamReader(stream);

                if(stream.CanWrite && stream.CanRead)
                {
                    byte[] sendBytes = Encoding.ASCII.GetBytes(command);

                    stream.Write(sendBytes, 0, sendBytes.Length);

                    //  Second line is the response text, this is what we return
                    result = reader.ReadLine();

                    result = reader.ReadLine();
                    
                }
                else
                    return null;
            }
            catch (Exception e)
            {
                //sb.Append("FAIL: CMgmtCommand - " + e.Message + "\r\n");
                result = "FAIL: " + e.Message;
            }
            finally
            {
                client.Close();
            }

            return result;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\command.cs ===
using System;
using System.IO;
using System.Data.SqlClient;
using System.Diagnostics;

namespace xonline.common.tools 
{

	public class Command
	{
		public static int RunOSqlCommand(string server, string database, string sqlfile, string workingDir, Output logger)
		{
		    string sqlParams = "-S " + server + " -i \"" + sqlfile + "\" -d " + database + " -n";

		    // Using integrated
		    sqlParams += " -E";

		    return RunCommandLine("osql.exe", sqlParams, workingDir, logger);
		}

		public static int RunSqlCommand(string server, string database, string sqlcommand)
		{
		    string connStr = "Server=" + server + ";Database=" + database;

		    // Using integrated
		    connStr += ";Integrated Security=true";

		    SqlConnection conn = new SqlConnection(connStr);
		    conn.Open();

		    SqlCommand cmd = new SqlCommand(sqlcommand, conn);

		    int hr = cmd.ExecuteNonQuery();

		    conn.Close();

		    return hr;
		    
		}

		public static SqlDataReader RunSqlQuery(string server, string database, string sqlcommand)
		{
		    string connStr = "Server=" + server + ";Database=" + database;

		    // Using integrated
		    connStr += ";Integrated Security=true";

		    SqlConnection conn = new SqlConnection(connStr);
		    conn.Open();

		    SqlCommand cmd = new SqlCommand(sqlcommand, conn);

		    return cmd.ExecuteReader();
		}

		public static int RunCommandLine(string file, string args, string workingDir, Output logger)
		{
		    Process p = new Process();
		    p.StartInfo.WorkingDirectory = workingDir;
		    p.StartInfo.FileName = file;
		    p.StartInfo.Arguments = args;
		    p.StartInfo.CreateNoWindow = true;
		    p.StartInfo.UseShellExecute = false;
		    p.StartInfo.RedirectStandardOutput = true;
		    p.StartInfo.RedirectStandardError = true;
		    p.Start();

		    string output = p.StandardOutput.ReadToEnd();
		    output += p.StandardError.ReadToEnd();

		    if (output.IndexOf("FAIL") >= 0)
		    	logger.Log(output, LogType.Error);
		    else
			logger.Log(output, LogType.Information);

		    p.WaitForExit();

		    return p.ExitCode;           
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\CommandUtility.cs ===
using System;

namespace xonline.common.tools
{
    /// <summary>
    /// A class to allow global management of verbose or terse output to the command line, as well as error output.
    /// In the future, this could be extended to intercept messages or errors and log them in some other fashion, if desired.
    /// </summary>
    public class CommandUtility
    {
        public static bool IsVerbose = true;

        /// <summary>
        /// CommandUtility provides static methods and properties only, so it should never be constructed
        /// </summary>
        private CommandUtility()
        {
        }

        /// <summary>
        /// Writes logging output, if verbose mode is enabled
        /// </summary>
        public static void WriteOutput()
        {
            //if (IsVerbose) {
                Console.WriteLine();
            //}
        }
        /// <summary>
        /// Writes logging output, if verbose mode is enabled
        /// </summary>
        public static void WriteOutput(string s)
        {
            //if (IsVerbose) {
                Console.WriteLine(s);
            //}
        }
        /// <summary>
        /// Writes logging output, if verbose mode is enabled
        /// </summary>
        public static void WriteOutput(string s1, params object[] arg)
        {
            //if (IsVerbose) {
                Console.WriteLine(s1, arg);
            //}
        }

        /// <summary>
        /// Writes logging output
        /// </summary>
        public static void WriteError()
        {
            Console.WriteLine();
        }
        /// <summary>
        /// Writes logging output
        /// </summary>
        public static void WriteError(string s)
        {
            Console.WriteLine(s);
        }
        /// <summary>
        /// Writes logging output
        /// </summary>
        public static void WriteError(string s1, params object[] arg)
        {
            Console.WriteLine(s1, arg);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\CTitleId.cs ===
using System;
using System.Text.RegularExpressions;

namespace xonline.tools.framework
{
    /// <summary>
    /// A utiltiy class to make working with title IDs simpler.
    /// Today, a title ID is a 32 bit integer.
    /// This class is immutable once constructed
    /// </summary>
    public class CTitleId
    {
        /// <summary> The title id as a 32 bit unsigned integer </summary>
        protected uint _uiTitleId;
        /// <summary>
        /// The title id as an 8 character hex string, including leading zeros,
        /// but with no "0x" prefix
        /// </summary>
        protected string _sTitleIdHexNoPrefix;

        /// <summary>
        /// Constructs a CTitleId object from a 32 bit unsigned integer value
        /// </summary>
        /// <param name="uiTitleId">
        /// The title id as a 32 bit unsigned integer
        ///.</param>
        public CTitleId(uint uiTitleId)
        {
            CtorHelper(uiTitleId);
        }

        /// <summary>
        /// Constructs a CTitleId object from a string value
        /// </summary>
        /// <param name="sTitleId">
        /// The title id as a string. Leading or trailing whitespace is ignored.
        /// if the string begins with "0x" or "0X" it will be interpreted as a hexadecimal
        /// value. Otherwise, it is interpreted as a decimal value. Only the decimal or
        /// hex digits and the hex prefix are permitted.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// sTitleId is a null reference
        /// </exception>
        /// <exception cref="FormatException">
        /// sTitleId could not be parsed as either a decimal or hexadecimal integer
        /// </exception>
        /// <exception cref="OverflowException">
        /// sTitleId represents a number smaller than 0 or larger than 0xFFFFFFFF
        /// </exception>
        private static Regex _reTitleId = new Regex("^(0x)?([0-9A-F]{8})$",
            RegexOptions.Compiled | RegexOptions.IgnoreCase );
        public CTitleId(string sTitleId)
        {
            Match Match;
            uint tid;
            
            if (sTitleId == null)
            {
                throw new ArgumentNullException("null string passed to CTitleId(string)");
            }

            try
            {
                Match = _reTitleId.Match(sTitleId);
                if (Match.Success)
                {
                    tid = Convert.ToUInt32(Match.Groups[2].Value, 16);
                }
                else
                {
                    if (sTitleId.StartsWith("-"))
                    {
                        tid = (uint)Convert.ToInt32(sTitleId, 10);
                    }
                    else
                    {
                        tid = Convert.ToUInt32(sTitleId, 10);
                    }
                }
            }
            catch
            {
                throw new ApplicationException("Invalid title id '" + sTitleId + "'");
            }
            
            CtorHelper(tid);
        }

        // need this because I don't want to duplicate logic, and it's illegal to call CTitleId(uint) from the
        // body of CTitleId(string)
        private void CtorHelper(uint uiTitleId)
        {
            _uiTitleId = uiTitleId;
            _sTitleIdHexNoPrefix = String.Format("{0,8:X8}", uiTitleId);
        }

        /// <summary>
        /// Gets the title id represented by this object as a 32 bit unsigned integer value
        /// </summary>
        public uint uiTitleId
        {
            get
            {
                return _uiTitleId;
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// that contains the title id in hex format, e.g. "0x1234ABCD"
        /// Leading zeros will be prepended such that eight hex digits
        /// are provided
        /// </summary>
        public string sTitleIdHex
        {
            get
            {
                return "0x" + _sTitleIdHexNoPrefix;
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// the contains the title id in hex format, but with no hex prefix
        /// e.g. "1234ABCD"
        /// Leading zeros will be prepended such that eight hex digits
        /// are provided
        /// </summary>
        public string sTitleIdHexNoPrefix
        {
            get
            {
                return _sTitleIdHexNoPrefix;
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// the contains the title id in decimal format e.g. "305441741"
        /// (equvalient to a hex value of 0x1234ABCD).
        /// No leading zeros will be prepended
        /// </summary>
        public string sTitleIdDecimal
        {
            get
            {
                return _uiTitleId.ToString("d");
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// that contains the title id in hex format, e.g. "0x1234ABCD"
        /// Leading zeros will be prepended such that eight hex digits
        /// are provided
        /// </summary>
        public override string ToString()
        {
            return sTitleIdHex;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\SystemCheck.cs ===
using System;
using System.Collections;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.common.tools
{

    /// <summary>
    /// Stores functionality to call health check URLS and reload front doors
    /// </summary>
    public class SystemCheck
    {
        public const int DEFAULT_RELOAD_TIMEOUT = 60000; // 60 seconds

        /// <summary>
        /// Reloads that LiveTitle needs
        /// </summary>
        /// <returns>Output from the reloading to convey it to the user</returns>
        public static string LiveTitleReload(int reloadTimeout)
        {
            StringBuilder sb = new StringBuilder();

            sb.Append( ResetFrontDoor( Interface.kdcsvc, "", "xkdc", "reload", reloadTimeout ) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.wcgeneral,   "", "wcgeneral",   "ReloadTitles", reloadTimeout ) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.wcpresence,  "", "wcpresence",  "ReloadTitles", reloadTimeout ) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.wcmessaging, "", "wcmessaging", "ReloadTitles", reloadTimeout ) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.wcalerts,    "", "wcalerts",    "ReloadTitles", reloadTimeout ) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.wcquery,     "", "wcquery",     "ReloadTitles", reloadTimeout ) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.wcsignature, "", "wcsignature", "ReloadTitles", reloadTimeout ) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.wcstats,     "", "wcstats",     "ReloadTitles", reloadTimeout ) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.wcstats,     "", "wcstats",     "ReloadLeaderboards", reloadTimeout ) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.wcstorage,   "", "wcstorage",   "ReloadTitles", reloadTimeout ) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.wcusers,     "", "wcusers",     "ReloadTitles", reloadTimeout ) );
            sb.Append( "\r\n" );
            return sb.ToString();
        }

        /// <summary>
        /// Reloads that LiveStats needs
        /// </summary>
        /// <returns>Output from the reloading to convey it to the user</returns>
        public static string LiveStatsReload(int reloadTimeout)
        {
            string results = ResetFrontDoor( Interface.xstatsfd_int, "", "xstatsfd", "ReloadDbMap", reloadTimeout ) + "\r\n";
            return results;
        }

        //task: eventually Live Match reload code should come here
        public static string LiveMatchReload(int reloadTimeout)
        {

            string results = ResetFrontDoor(Interface.xmatchfd_int, "", "xmatchfd", "reloadtitleinfo", reloadTimeout) + "\r\n";
            return results;
        }

        //task: eventually Live Content reload code should come here
        public static string LiveContentReload(int reloadTimeout)
        {
            string results = ResetFrontDoor( Interface.xmatchfd_int, "", "xmatchfd", "reload", reloadTimeout ) + "\r\n";
            return results;            
        }

        //task: eventually OfferGap / LiveOffer reload code should come here
        public static string LiveOfferReload(int reloadTimeout)
        {
            StringBuilder sb = new StringBuilder();

            sb.Append( ResetFrontDoor( Interface.xbos_int, "", "xbos", "cacheflush", reloadTimeout) );
            sb.Append( "\r\n" );
            sb.Append( ResetFrontDoor( Interface.xuacs_int, "", "xuacs", "cacheflush", reloadTimeout) );
            sb.Append( "\r\n" );
            return sb.ToString();
        }

        /// <summary>
        /// Reloads for the SystemCheck tool. Reloads all FDs affected by title deployment.
        /// </summary>
        /// <returns></returns>
        public static string ReloadAllFrontDoors(int reloadTimeout)
        {
            StringBuilder sb = new StringBuilder();

            //LiveTitle
            sb.Append( LiveTitleReload(reloadTimeout) );

            //LiveStats
            sb.Append( LiveStatsReload(reloadTimeout) );

            //LiveMatch
            sb.Append( LiveMatchReload(reloadTimeout) );

            //LiveContent
            sb.Append( LiveContentReload(reloadTimeout) );

            //LiveOffer
            sb.Append( LiveOfferReload(reloadTimeout) );

            return sb.ToString();
        }

        public static void ReloadFrontDoors(int reloadTimeout)
        {

            //Reset the appropriate front doors to make sure the settings "take"
            //interface, process, component, command, timeout

            //move the reset method from LiveTitle.cs here?
            //ResetFrontDoor( Interface.kdcsvc, "", "xkdc", "reload", reloadTimeout );
                        
            //task: reload WebCache for Xbox titles... 
            //maybe?
            //e :wcgeneral ReloadTitles
            //e :wcpresence ReloadTitles

            //No - msgtool ??
            //e :wcmessaging ReloadTitles

            //e :wcalerts ReloadTitles
            //e :wcquery ReloadTitles
            //e :wcsignature ReloadTitles

            //e :wcstats ReloadTitles
            //e :wcstats ReloadLeaderboards

            //e :wcstorage ReloadTitles
            //e :wcusers ReloadTitles

            //No- content tool 
            //exec :xbos cacheflush

            //NO - match tool 
            //exec :XMatchFD reloadtitleinfo

            //NO - stats tool 
            //e :xstatsfd reloaddbmap
        }


        //task: will probably want to move this elsewhere eventually
        public static string ResetFrontDoor( string serverInterface, string process, string component, string command, int timeout )
        {
            int result = 0;
            StringBuilder sb = new StringBuilder();

            //need to loop through each of the servers in the Virtual Interface...
            string[] serverList = Config.GetServerListByInterface( serverInterface );
            string[] responses = null;
            sb.Append( "Resetting Front Doors for " + serverInterface + ": \r\n" );
            foreach( string server in serverList )
            {
                try
                {
                    sb.Append( " Server: " + server + " Interface: " + Interface.xmgmtsrv + "\r\n");

                    // Since we are executing XMGMT commands, rather than use the caller's Interface spec,
                    // we will retrieve the IP for the xmgmtsrv Interface.  If,

                    IInterfaceInfo svrIFaceInfo = Config.GetInterface( server, Interface.xmgmtsrv );

                    if (svrIFaceInfo == null)
                    {
                        sb.Append(" WARNING: Could not retrieve xmgmtsrv interface for " + server + ", using service interface instead" + "\r\n");
                        svrIFaceInfo = Config.GetInterface(server, serverInterface);
                        sb.Append(" Trying Server: " + server + " Interface: " + serverInterface + "\r\n");
                    }

                    sb.Append(" XomAdminSession(" + svrIFaceInfo.IPAddress + ") called for Component: " + component + " with Command: " + command + "\r\n");
                    XomAdminSession xmgmt = new XomAdminSession( svrIFaceInfo.IPAddress );
                    xmgmt.SendCommand( process, component, command, timeout, out responses, out result);

                    sb.Append(" HResult: " + result.ToString("X") + "\r\n");

                    sb.Append(" Responses:\r\n");
                    foreach (String response in responses)
                    {
                        sb.Append("    " + response + "\r\n");
                    }
                }
                catch ( Exception e )
                {
                    sb.Append( "There was a serious error while reloading front doors:" );
                    sb.Append( "  Error was : " + e.Message + "\r\n" + e.StackTrace );
                }
            }

            sb.Append( "\r\n Attempted to reset all " + serverInterface.ToString() + " front doors" );

            return sb.ToString();

        }

        public static ArrayList GetHealthURLListByServer( string ServerName )
        {
            //call to config to get a list of all the servers and interfaces
            //return this as a hashtable???
            return null;

        }

        public static ArrayList GetHealthURLListByInterface( string Interface )
        {
            //call to config to get a list of all the servers and interfaces
            //return this as a hashtable???

            return null;
        }


        //task: at some point, the guts of SystemCheck should come here, and the tool will just call it
        private static void CheckHealth( )
        {
            // the amount of time we'll wait for a front door to respond to the
            // health check. Use the default compiled into this file if one
            // is not specified in the respository.
            //            int iTimeout = c_iFDTimeoutDefault;
            //            m_repository.ServiceFrontDoorTimeoutGet(ref iTimeout);
            //
            //            // get the urls we want to hit
            //            SortedList slHealthUrls = m_repository.ServiceHealthUrlGetList();
            //
            //            if (slHealthUrls.Count == 0)
            //            {
            //                //   0        1        2        3        4        5        6        7        8
            //                m_log.Console(
            //                    "Warning: No health urls provided in service.xml");
            //                return;
            //            }
            //
            //            foreach (DictionaryEntry de in slHealthUrls)
            //            {
            //                // the key of the sorted list is a string containing the friendly name of the server
            //                // the value of the sorted list a string containing the health url to hit
            //                string sFriendlyName = (string)de.Key;
            //                string sUrl = (string)de.Value;
            //
            //                AttemptHealthCheck(sFriendlyName, sUrl, iTimeout);
            //            }
        }

    } // class system check

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Output.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Collections;

using xonline.common.service;

namespace xonline.common.tools 
{
	public enum LoggingLevel
	{
		Error = 0,            
		Normal = 1,
		Verbose = 2
	};

	public enum LogType
	{
		Error = 0,
		Information = 1,
		Debug = 2
	} 

	/// <summary>
	/// Class that handles output to: {eventlog, log file, console, SQL?}
	/// 
	/// Upon creation you can set the verbosity.
	/// 
	/// Error	:= outputs only errors
	/// LoggingLevel.Verbose := outputs errors, LogType.Information, and LoggingLevel.Verbose to the logging medium
	/// LoggingLevel.Normal	:= outputs errors, and LogType.Information 	
	/// 
	/// I made this class non static so that in the future we could have multiple 
	/// instances of this class.  (example: for a tools framework).
	/// </summary>
	public class Output
	{

		private ArrayList _loggers = new ArrayList();	  

		#region Constructors
       
		/// <summary>
		/// Default logging.
		/// 
		/// Console:  Normal
		/// Log File: none
		/// EventLog: Error
		/// </summary>
		public Output(string source)
		{
			_loggers.Add(new ConsoleLogger(source, LoggingLevel.Normal));
			_loggers.Add(new EventLogger(source, LoggingLevel.Error));
		}

		/// <summary>
		/// Default logging.
		/// like above
		/// </summary>
		public Output(string source, XEvent.Id errorID, XEvent.Id successID)
		{
			_loggers.Add(new ConsoleLogger(source, LoggingLevel.Normal));
			_loggers.Add(new EventLogger(source, LoggingLevel.Error, errorID, successID));
		}

		/// <summary>
		/// Default logging.
		/// 
		/// Console:  LoggingLevel.Normal
		/// Log File: LoggingLevel.Verbose
		/// EventLog: Error
		/// </summary>
		public Output(string source, string filePath)
		{
			_loggers.Add(new ConsoleLogger(source, LoggingLevel.Normal));
			_loggers.Add(new FileLogger(source, LoggingLevel.Verbose, filePath));
			_loggers.Add(new EventLogger(source, LoggingLevel.Error));
		}

		/// <summary>
		/// Default logging.
		/// like above
		/// </summary>
		public Output(string source, string filePath, XEvent.Id errorID, XEvent.Id successID)
		{
			_loggers.Add(new ConsoleLogger(source, LoggingLevel.Normal));
			_loggers.Add(new FileLogger(source, LoggingLevel.Verbose, filePath));
			_loggers.Add(new EventLogger(source, LoggingLevel.Error, errorID, successID));
		}
		#endregion


		#region PropertyLevels
		public LoggingLevel ConsoleLogging
		{
			get
			{
				foreach(Logger l in _loggers)
				{
					if(l is ConsoleLogger)					
						return l.Level; // Invariant: assuming there is only one Console...
				}

				return LoggingLevel.Error;
			}
			set
			{
				foreach(Logger l in _loggers)
				{
					if(l is ConsoleLogger)
					{
						l.Level = value;
						return; // Invariant: assuming there is only one Console...
					}
				}
			}
		}

		public LoggingLevel EventLogging
		{
			get
			{
				foreach(Logger l in _loggers)
				{
					if(l is EventLogger)					
						return l.Level; // Invariant: assuming there is only one Console...
				}

				return LoggingLevel.Error;
			}
			set
			{
				foreach(Logger l in _loggers)
				{
					if(l is EventLogger)
					{
						l.Level = value;
						return; // Invariant: assuming there is only one Console...
					}
				}
			}
		}

		public LoggingLevel FileLogging
		{
			get
			{
				foreach(Logger l in _loggers)
				{
					if(l is FileLogger)					
						return l.Level; // Invariant: assuming there is only one Console...
				}

				return LoggingLevel.Error;
			}
			set
			{
				foreach(Logger l in _loggers)
				{
					if(l is FileLogger)
					{
						l.Level = value;
						return; // Invariant: assuming there is only one Console...
					}
				}
			}
		}
		#endregion

		public void Log(string str, LogType type)
		{
			foreach(Logger logger in _loggers)
			{
				if (logger.shouldLog(type))
					logger.Log(str, type);
			}
		}

		/// <summary>
		/// force log to everywhere
		/// </summary>
		/// <param name="str"></param>
		/// <param name="type"></param>
		public void LogAll(string str, LogType type)
		{
			foreach(Logger logger in _loggers)
			{
				logger.Log(str, type);
			}
		}
	}

	/// <summary>
	/// Abstract Logger class.  Any Logger must inherit this.
	/// 
	/// Key function is bool shouldLog(type).
	/// </summary>
	internal abstract class Logger
	{
		protected string _source = "not set";
		protected LoggingLevel _level;

		public Logger(string source, LoggingLevel level)
		{
			_source = source;
			_level = level;
		}

		public void Log(string str, LogType type)
		{
			if(shouldLog(type))
				internalLog(str, type);
		}

		public LoggingLevel Level
		{
			get
			{
				return _level;
			}
			set
			{
				_level = value;
			}
		}

		protected abstract void internalLog(string str, LogType type);

		public virtual bool shouldLog(LogType type)
		{
			if(_level == LoggingLevel.Verbose) return true;

			if(_level == LoggingLevel.Normal && type == LogType.Debug) return false;

			return true; // this is an error
		}


		protected string prependType(string str, LogType type)
		{
			string temp = "";

			if(type == LogType.Error)
				temp = "Error: ";
			else if(type == LogType.Information)
				temp = "Information: ";
			else if(type == LogType.Debug)
				temp = "Debug: ";

			return temp + str;
		}
	}

	internal class ConsoleLogger : Logger
	{
		public ConsoleLogger(string source, LoggingLevel level) : base(source, level)
		{
		}

		protected override void internalLog(string str, LogType type)
		{
			System.Console.WriteLine(prependType(str, type));
		}
	}

	internal class FileLogger : Logger
	{
		private StreamWriter _sw;
		private string _path;

		public FileLogger(string source, LoggingLevel level, string path) : base(source, level) 
		{
			_source = source;
			_level = level;
			_path = path;
	
			_sw = File.CreateText(_path);
			_sw.WriteLine(Environment.CommandLine);
		}
        
		protected override void internalLog(string str, LogType type)
		{
			_sw.WriteLine(prependType(str, type));
		}
	}


    internal class EventLogger : Logger
    {
        private EventLog _eventlog;
        private XEvent.Id _successId = XEvent.Id.GENERIC_TOOLS_SUCCESS;
        private XEvent.Id _errorId = XEvent.Id.GENERIC_TOOLS_ERROR;

        public EventLogger( string source, LoggingLevel level )
            : base( source, level )
        {
            _eventlog = new EventLog();
            _eventlog.Source = _source;
        }

        public EventLogger( string source, LoggingLevel level, XEvent.Id errorId, XEvent.Id successId )
            : base( source, level )
        {
            _errorId = errorId;
            _successId = successId;
            _eventlog = new EventLog();
            _eventlog.Source = _source;
        }

        protected override void internalLog( string str, LogType type )
        {
            if( type == LogType.Debug ) return;

            int id = 0;
            EventLogEntryType t = EventLogEntryType.Error;
            if( type == LogType.Error ) {
                unchecked {
                    id = (int) (((uint) _errorId) & 65535);
                }
            }
            else {
                unchecked {
                    id = (int) (((uint) _successId) & 65535);
                }
                t = EventLogEntryType.Information;
            }

            int start;
            int len;
            int maxIndex = str.Length - 1;

            for( start = 0; start < maxIndex; start += len ) { // event string must be < 32766 characters
                len = Math.Min( str.Length - start, xonline.common.mgmt.XomLoggingControl.MaxEventLength );
                _eventlog.WriteEntry( str.Substring( start, len ), t, id );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\OfferValues.cs ===
using System;


namespace xonline.tools.framework
{
	/// <summary>
	/// Summary description for OfferEquivalence.
	/// </summary>
	public class OfferValues
	{

        public const ulong Beta16               = 0xFFFE000080000001;
        public const ulong Beta15               = 0xFFFE000080000002;
        public const ulong Beta14               = 0xFFFE000080000003;
        public const ulong Beta13               = 0xFFFE000080000004;
        public const ulong XboxPromo16Month     = 0xFFFE000080000005;
        public const ulong XboxTest16Month      = 0xFFFE000080000006;
        public const ulong Unknown              = 0xFFFE000080000007;
        public const ulong StarterKit           = 0xFFFE000080000008;
        public const ulong GameTrial            = 0xFFFE000080000009;
        public const ulong ConsoleTrial         = 0xFFFE00008000000A;
        public const ulong MonthlyRenewal       = 0xFFFE00008000000B;
        public const ulong AnnualRenewal        = 0xFFFE00008000000C;
        public const ulong PrePaidYear          = 0xFFFE00008000000D;
        public const ulong PrePaid3Month        = 0xFFFE00008000000E;

//        public enum OfferValues 
//        {
//            Beta16,                  // 1  from beta offers used pre-launch
//            Beta15,                  // 2  from beta offers used pre-launch
//            Beta14,                  // 3  from beta offers used pre-launch
//            Beta13,                  // 4  from beta offers used pre-launch
//            XboxPromo16Month,        // 5
//            XboxTest16Month,         // 6
//            Unknown,                 // 7
//            StarterKit,              // 8  starter kit / 12 month Online Subscription
//            GameTrial,               // 9  2 month free trial which comes with Games
//            ConsoleTrial,            // A  2 month free trial which comes with Consoles
//            MonthlyRenewal,          // B  monthly renewal
//            AnnualRenewal,           // C  annual renewal
//            PrePaidYear,             // D  prepaid year card
//            PrePaid3Month            // E  three month prepaid card
//        }

//        //taken directly from JerryHook's spreadsheet
//        // removed the FFFE0000 high bits, since they don't appear to be 
//        // used in UODB
//        public static ulong[] OfferID = new ulong[11] 
//        {   
//            0,          // enums start with 1, so we'll leave this one blank...                          
//            0x80000001,	// Subscription  Xbox Beta 16 mths
//            0x80000002,	// Subscription  Xbox Beta 15 mths
//            0x80000003,	// Subscription  Xbox Beta 14 mths
//            0x80000004,	// Subscription  Xbox Beta 13 mths
//            0x80000005,	// Subscription  Xbox Promotional 16 mths
//            0x80000006,	// Subscription  Xbox Prod Test Subscription 16 mths
//            0x80000007,	// ??? 
//            0x80000008,	// Subscription  Xbox Live 12 Month Online Subscription (Starter Kit)
//            0x80000009,	// Subscription  Game Trial
//            0x8000000A,	// Subscription  Console Trial
//            0x8000000B,	// Renewal       Monthly Renewal
//            0x8000000C,	// Renewal       Yearly Renew
//            0x8000000D,	// Renewal       Yearly Prepaid
//            0x8000000E	// Renewal       3 Month Prepaid
//        };


        //task: this still doesn't seem elegant, redesign this later... 
        public static bool IsOfferPairEquivalent( ulong A, ulong B )
        {
            bool response = false;

            switch ( A )
            {
                    //we really shouldn't see these cases in production
                    //so throwing an exception is reasonable here...
                    //task: throw exception?
                case Beta16:            // 0x80000001
                case Beta15:            // 0x80000002
                case Beta14:            // 0x80000003
                case Beta13:            // 0x80000004
                    response = (
                        ( B == Beta16 ) ||
                        ( B == Beta15 ) ||
                        ( B == Beta14 ) ||
                        ( B == Beta13 ) 
                        );
                    break;

                case XboxPromo16Month:  // 0x80000005
                    response = ( B == XboxPromo16Month );
                    break;

                case XboxTest16Month:   // 0x80000006
                    response = ( B == XboxTest16Month );
                    break;

                case Unknown:           // 0x80000007
                    response = ( B == Unknown );
                    break;

                case StarterKit:     // 0x80000008
                    response = (
                                ( B == PrePaidYear ) ||
                                ( B == StarterKit )
                                );
                    break;

                case GameTrial:      // 0x80000009
                case ConsoleTrial:   // 0x8000000A
                    response = ( ( B == GameTrial ) ||
                                 ( B == ConsoleTrial )
                               );
                    break;

                case MonthlyRenewal:  // 0x8000000B
                    response = ( B == MonthlyRenewal );
                    break;

                case AnnualRenewal:   // 0x8000000C
                    response = ( B == AnnualRenewal );
                    break;

                case PrePaidYear:    // 0x8000000D
                    response = (
                                ( B == PrePaidYear ) ||
                                ( B == StarterKit )
                               );
                    break;

                case PrePaid3Month:  // 0x8000000E
                    response = ( B == PrePaid3Month );
                    break;

                default:
                    //task: throw exception 
                    break;

            } // switch

            return response;

        } // is offer pair equiv

	} //OfferEquivalence

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\SerialNumber.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Runtime.Serialization;

using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.serialnumber)]

namespace xonline.tools.framework
{
    /// <summary>
    /// So why is this a separate class, rather than just a static method somewhere else?
    /// Basically, I'm taking a guess that this will get used elsewhere than just this code,
    /// and if that's the case, it'd be handy to have it separated out, in spite of the overhead
    /// of creating and testing a separate class.
    /// There's no "Insert" method or equivalent here, since these get added to the 
    /// DB via a batch job from a text file. (if you really want one, look at the test code...)
    /// 
    /// Once add the serial number and group id to UODB, this can become part of the Voucher class... 
    /// </summary>
    public class SerialNumber
    {

        #region Properties

        private int groupID;
        public int GroupID
        {
            get
            {
                return groupID;
            }
        }

        //task: probably don't want this... 
//        private string hashString;
//        public string HashString
//        {
//            get
//            {
//                return hashString;
//            }
//        }
        private int serialNum;
        public int SerialNum
        {
            get
            {
                return serialNum;
            }
        }
        private byte[] hashBytes;
        public byte[] HashBytes
        {
            get
            {
                return (byte []) hashBytes.Clone();
            }
        }


        #endregion

		private SerialNumber()
		{

		}

        // requiring a connection string accomodates the need for this code to function
        // in a variety of contexts while balancing the desire to reduce interdependencies between
        // the caller and callee (there might be a transaction open, etc).
        public static SerialNumber Load( int requestedGroupID, int requestedSerialNum, string connection )
        {
            // SqlByte == TinyInt, why isn't there also a TinyInt?
            // SqlByte.MaxValue == 255
            if ( requestedGroupID > ( (int) SqlByte.MaxValue ) )
            {
                throw new ArgumentException("Group ID must be less than " + SqlByte.MaxValue );
            }

            SerialNumber sn = new SerialNumber();

            using (SqlConnection serialConn = new SqlConnection( connection ) )
            {
                serialConn.Open();
                SqlCommand serialCmd = serialConn.CreateCommand();
                serialCmd.CommandType = CommandType.StoredProcedure;
                serialCmd.CommandText = "p_GetHashFromSerial";

                serialCmd.Parameters.Add( "@tiGroupID", SqlDbType.TinyInt ).Value = requestedGroupID;
                serialCmd.Parameters["@tiGroupID"].Direction = ParameterDirection.Input;  
                
                serialCmd.Parameters.Add( "@iSerialNumber", SqlDbType.Int ).Value = requestedSerialNum;
                serialCmd.Parameters["@iSerialNumber"].Direction = ParameterDirection.Input;
                
                serialCmd.Parameters.Add( "@hr", SqlDbType.Int );
                serialCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                SqlDataReader serialReader = serialCmd.ExecuteReader();

                // do we have results?
                if ( serialReader.Read() )
                {
                    sn.groupID = requestedGroupID;
                    sn.serialNum = requestedSerialNum;

                    // takes 2 char to express each byte value (0x00 to 0xFF)
                    //sn.hashBytes = new byte[ Voucher.VoucherHashSize * 2 ];

                    //review: is this returning an arbitrarily big byte array??
                    sn.hashBytes = ( byte[] ) serialReader.GetSqlBinary( 0 );
                    // sn.hashString = (string) serialReader.GetValue( 0 );

                    //review: throw an exception if there are more rows?
                }
                else
                {
                    throw new SerialNumberNotFoundException();
                }
            }
            return sn;
        } // load

	} //class

    public class SerialNumberNotFoundException : Exception, ISerializable
    {
        const string message = "Requested SerialNumber not found in database.";
        public SerialNumberNotFoundException( ) :  base( message ) { }
        public SerialNumberNotFoundException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }
        
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\MsgManager.cs ===
using System;
using System.Text;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.msgmanager)]

namespace xonline.tools.framework
{
	/// <summary>
	/// Encapsulates the core functionality of Msg Tool for future use... 
	/// </summary>
    public class MsgManager
    {

        //NOTE: the calling program will need to .Init and .Close the XOM stream

        public const string     DEFAULT_LOCALE      = "default";

        public static bool AddString( uint dwStringID, ushort wLanguage, string strText )
        {
            // By default messages epxire in 90 days
            return (0 != AddString(dwStringID, 0, new ushort[1] {wLanguage}, new string[1] {strText}, 0));
        }
        
        public static uint AddString( uint dwStringID, uint titleID, ushort [] wLanguage, string [] strText, ulong expireMinutes )
        {
            StringAddRequest request = new StringAddRequest();
            StringAddResponse response = new StringAddResponse();
            request.dwTitleID = (titleID == 0) ? XOn.DASH_TITLE_ID : titleID;  // Default to the Dash title ID  (0xFFFE0000) if not specified
            request.dwStringID = dwStringID;
            request.wDefaultLanguage = 1;                           // English is always the default
            request.dtExpire = (0 == expireMinutes) ? DateTime.UtcNow.AddYears( 20 ) : DateTime.UtcNow.AddMinutes(expireMinutes);  
            request.cLangStrings = 1;                               // We do one language at a time
            request.fVetText = false;

            // Make sure our arrays match
            if (wLanguage.Length != strText.Length)
            {
                Console.WriteLine( "Arrays passed to AddString do not match! Received " + wLanguage.Length + " languages and " + strText.Length + " strings." );                
                return 0;
            }
            
            request.rgLangStrings = new LanguageString[wLanguage.Length];
            for (int i=0; i<wLanguage.Length; i++)
            {
                request.rgLangStrings[i] = new LanguageString();
                request.rgLangStrings[i].wLanguage = wLanguage[i];
                request.rgLangStrings[i].wStringSize = System.Convert.ToUInt16( strText[i].Length );
                request.rgLangStrings[i].szString = strText[i];
            }
            
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            try
            {
                XRLObject2 xrlo = response;
                
                Console.WriteLine( "String Service address " + XRLUtil.GetServiceAddress( XOService.StringService ) );

                HResult hr = XRLUtil.PostXrlRequest( XOService.StringService, "/msgserver/addstring.ashx", fakedAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: AddString - XRLUtil.PostXrlRequest returned hr = " + hr );
                    //Console.WriteLine( "Error: AddString - XRLUtil.PostXrlRequest returned hr = {0}", hr );
                    return 0;
                }                                    
            }
            catch( XrlRequestException e )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: AddString - XRLUtil.PostXrlRequest threw exception status=" +  e.StatusCode + ", Text=" + e.ToString() );
                //Console.WriteLine( "Error: AddString - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() );
                return 0;
            }

            return response.dwStringID;
            
        } // AddString

        public static bool AddUserMessage( ulong qwPUID, uint dwMessageFlags, uint dwStringID, ushort wExpiration )
        {
            // messages from the service are sent from the xbox 1 dash title id
            return AddUserMessage(new ulong[] {qwPUID}, 0xfffe0000, dwMessageFlags, dwStringID, wExpiration);
        }
        
        public static bool AddUserMessage( ulong [] qwPUIDs, uint titleID, uint dwMessageFlags, uint dwStringID, ushort wExpiration )
        {
            CUserMessage msg = new CUserMessage(
                0, // sender puid of 0, since we're the service, not an individual user
                0, // sender context of 0
                dwMessageFlags,
                titleID, 
                wExpiration,
                MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
                "LIVE" ); // sender name

            msg.AddRecipients(qwPUIDs);
            msg.AddProperty(MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, dwStringID);

            if(HResult.Failed(msg.Send()))
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: AddUserMessage - Send failed." );
                // Console.WriteLine( "Error: AddSystemMessage - Send failed." );
                return false;
            }

            return true;
        } //AddUserMessage


        public static bool AddTitleMessage( uint dwTitleID, uint dwMessageFlags, uint dwStringID, ushort wExpiration )
        {
            CSystemMessage msg = new CSystemMessage(
                dwTitleID,
                0, // qwSenderContext, 
                0, // dwRegion
                dwMessageFlags,
                wExpiration,
                MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
                "LIVE", // sender name
                DateTime.UtcNow,
                "LIVE Title" ); // max 64 character description for internal use only

            msg.AddProperty( MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, dwStringID );
            if( HResult.Failed( msg.Send() ) )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: AddTitleMessage - Send failed." );
                //Console.WriteLine( "Error: AddTitleMessage - Send failed." );
                return false;
            }                                    

            return true;
        } // AddTitleMessage


        public static bool AddSystemMessage( uint dwMessageFlags, uint dwStringID, ushort wExpiration )
        {
            CSystemMessage msg = new CSystemMessage(
                0, // dwTitleID - Title ID of zero indicates a system-wide message
                0, // qwSenderContext, 
                0, // dwRegion
                dwMessageFlags,
                wExpiration,
                MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
                "LIVE", // sender name
                DateTime.UtcNow,
                "LIVE System" ); // max 64 character description for internal use only

            msg.AddProperty( MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, dwStringID );

            if( HResult.Failed( msg.Send() ) )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: AddSystemMessage - Send failed." );
                // Console.WriteLine( "Error: AddSystemMessage - Send failed." );
                return false;
            }                                    

            return true;
        } // AddSystemMessage


        //GetString method to test if the string server has, in cache, a specific string... 
        public static bool CheckStringExists( uint stringId, uint titleId, string locale )
        {
            bool found = false;
            // code below is heavily borrowed from the Messaging front door... ;-)
            StringLookup2Request strrequest = new StringLookup2Request();

            if ( 0 == titleId )
            {
                // dash is default titleId
                strrequest.dwTitleID = XOn.DASH_TITLE_ID;
            }
            else
            {
                strrequest.dwTitleID = titleId;
            }
            strrequest.wLocaleLen = (ushort) locale.Length;
            strrequest.szLocale = locale;
            strrequest.wNumStrings = 1;
            strrequest.rgdwStringIDs = new uint[ 1 ];
            strrequest.rgdwStringIDs[ 0 ] = stringId;

            StringLookupResponse stringResponse = new StringLookupResponse();

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = stringResponse;

            //as a tool this doesn't have SGAuthInfo, so we fake it... 
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            // Call the String front door to handle the request
            HResult hr = XRLUtil.PostXrlRequest( XOService.StringService, strrequest.GetXRL(), fakedAuthData.GetBase64EncodedString(), strrequest, ref xrlo );
            if( !HResult.Failed( hr ) && 1 == stringResponse.wNumStrings && 0 != stringResponse.rgStringData[0].szString.Length )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_LOW, "String Lookup Response was " + stringResponse.wNumStrings + " strings, first was '" + stringResponse.rgStringData[0].szString.Length + "' chars long " );
                found = true;
            }
            else
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: response was " + stringResponse.wNumStrings + " strings, first was '" + stringResponse.rgStringData[0].szString.Length + "' chars long " );
                // Console.WriteLine( " response was {0} strings, first was '{1}' chars long ", stringResponse.wNumStrings, stringResponse.rgStringData[0].szString.Length );
                return false;
            }

            return found;
        }// CheckString


        //GetString method to test if the string server has, in cache, a specific string... 
        public static string GetString( ushort stringId, uint titleId, string locale )
        {
            string  data = "";
            // code below is heavily borrowed from the Messaging front door... ;-)
            StringLookup2Request strrequest = new StringLookup2Request();

            if ( 0 == titleId) 
            {
                // dash is default titleId
                strrequest.dwTitleID = XOn.DASH_TITLE_ID;
            }
            else
            {
                strrequest.dwTitleID = titleId;
            }
            strrequest.wLocaleLen = (ushort) locale.Length;
            strrequest.szLocale = locale;
            strrequest.wNumStrings = 1;
            strrequest.rgdwStringIDs = new uint[ 1 ];
            strrequest.rgdwStringIDs[ 0 ] = stringId;

            StringLookupResponse stringResponse = new StringLookupResponse();

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = stringResponse;

            //as a tool this doesn't have SGAuthInfo, so we fake it... 
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            // Call the String front door to handle the request
            HResult hr = XRLUtil.PostXrlRequest( XOService.StringService, strrequest.GetXRL(), fakedAuthData.GetBase64EncodedString(), strrequest, ref xrlo );
            if( !HResult.Failed( hr ) && 1 == stringResponse.wNumStrings && 0 != stringResponse.rgStringData[0].szString.Length )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_LOW, "String Lookup Response was " + stringResponse.wNumStrings + " strings, first was '" + stringResponse.rgStringData[0].szString.Length + "' chars long " );
                data = stringResponse.rgStringData[0].szString;
            }
            else
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: response was " + stringResponse.wNumStrings + " strings, first was '" + stringResponse.rgStringData[0].szString.Length + "' chars long " );
                // Console.WriteLine( " response was {0} strings, first was '{1}' chars long ", stringResponse.wNumStrings, stringResponse.rgStringData[0].szString.Length );
            }

            return data;
            
        } // GetString

        public static bool VerifyUsersExist(ref FindUsersData [] users)
        {
            FindUsersMsg request = new FindUsersMsg();
            FindUsersReplyMsg response = new FindUsersReplyMsg();            
            XRLObject2 xrlo = (XRLObject2) response;
            uint    current = 0;
            
            HTTPAuthData fakedAuthData = new HTTPAuthData( );
            
            request.qwUserID = 0;

            while (current < users.Length)
            {
                uint    size = Math.Min((uint)(users.Length - current), (uint)100);                
                FindUsersData [] segment = new FindUsersData[size];

                Array.Copy(users, current, segment, 0, size);

                request.cdwQueries = size;
                request.rgQueries = segment;
                
                try
                {
                    HResult hr = XRLUtil.PostXrlRequest( XOService.PresNotification, "/xpnfront/xpresence.srf", fakedAuthData.GetBase64EncodedString(), request, ref xrlo );
                    if( HResult.Failed( hr ) )
                    {
                        Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: VerifyUsersExist - XRLUtil.PostXrlRequest returned hr = {0}", hr ) );
                        Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "More info: {0}", xrlo.ToString() ) );
                        
                        return false;
                    }
                }
                catch( XrlRequestException e )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: VerifyUsersExist - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() ) );
                    
                    return false;
                }
                catch( Exception e)
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "\nThere was an error during VerifyUsers: {0}\n", e.ToString() ) );
                    
                    return false;
                }

                // Copy the results back into the source array
                Array.Copy(response.rgResults, 0, users, current, size);                

                // Advance the current segment
                current += size;                
            }
            
            return true;
        }

        //Enumerate System Messages method to see what messages are currently in effect
        public static EnumerateSystemMessagesReply EnumerateSystemMessages( uint titleID )
        {
            EnumerateSystemMessagesMsg enumRequest = new EnumerateSystemMessagesMsg();
            // if titleID = 0, then its a request for System Messages
            enumRequest.dwTitleID = titleID;

            EnumerateSystemMessagesReply enumReply = new EnumerateSystemMessagesReply();
            XRLObject2 xReply = (XRLObject2) enumReply;

            //as a tool this doesn't have SGAuthInfo, so we fake it... 
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            try
            {
                HResult hr = XRLUtil.PostXrlRequest( XOService.MessagingService, "/xpnfront/xmessaging.srf", fakedAuthData.GetBase64EncodedString(), enumRequest, ref xReply );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: EnumerateSystemMessages - XRLUtil.PostXrlRequest returned hr = {0}", hr ) );
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "More info: {0}", xReply.ToString() ) );
                    //Console.WriteLine( "Error: EnumerateSystemMessages - XRLUtil.PostXrlRequest returned hr = {0}", hr );
                    //Console.WriteLine( "More info: {0}", xReply.ToString() );
                    return null;
                }
                else
                {
                    return enumReply;
                }

            }
            catch( XrlRequestException e )
            {
                //Console.WriteLine( "Error: EnumerateSystemMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() );
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: EnumerateSystemMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() ) );
                return null;
            }
            catch( Exception e)
            {
                // Console.WriteLine( "\nThere was an error during enumsysmsg: \n", e.ToString() );
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "\nThere was an error during enumsysmsg: {0}\n", e.ToString() ) );
                return null; // "Error in EnumerateSystemMessages.";
            }


        } // EnumerateSystemMessages
        

        // Delete System / Title Messages
        public static uint DeleteSystemMessages( uint titleID, uint msgID, uint revokeFlag )
        {
            DeleteSystemMessageMsg delRequest = new DeleteSystemMessageMsg();
            delRequest.dwTitleID = titleID;
            delRequest.dwMessageID = msgID;
            // system delete and revoke are the same message, with the change of one flag.
            // 0 - delete the message from the system queue
            // 1 - delete the message from the system queue and all user queues
            delRequest.dwFlags = revokeFlag;

            DeleteSystemMessageReply delReply = new DeleteSystemMessageReply();
            XRLObject2 xrlReply = (XRLObject2)delReply;

            //as a tool this doesn't have SGAuthInfo, so we fake it... 
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            try
            {
                HResult hr = XRLUtil.PostXrlRequest( XOService.MessagingService, "/xpnfront/xmessaging.srf", fakedAuthData.GetBase64EncodedString(), delRequest, ref xrlReply );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: DeleteSystemMessages - XRLUtil.PostXrlRequest returned hr = {0}.", hr ) );
                    // Console.WriteLine( "Error: DeleteSystemMessages - XRLUtil.PostXrlRequest returned hr = {0}", hr );
                    return hr;
                }
                if( HResult.Failed( delReply.hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: DeleteSystemMessages - DeleteSystemMessageReply returned hr = {0}.", delReply.hr ) );
                    // Console.WriteLine( "Error: DeleteSystemMessages - DeleteSystemMessageReply returned hr = {0}", delReply.hr );
                    return delReply.hr;
                }
                
            }
            catch( XrlRequestException e )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: DeleteSystemMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() ) );
                //Console.WriteLine( "Error: DeleteSystemMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() );
                return HResult.E_FAIL;
            }

            Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Message ID {0} deleted successfully.", msgID ) );
            // Console.WriteLine("Message ID " + msgID.ToString() + " deleted successfully.");
            return HResult.S_OK;

        } // Delete System / Title Messages


        public static EnumerateMessagesReply EnumerateUserMessageQueue( ulong qwUserPUID )
        {

            EnumerateMessagesMsg userEnum = new EnumerateMessagesMsg();
            userEnum.qwUserID = qwUserPUID;
            EnumerateMessagesReply userEnumReply = new EnumerateMessagesReply();
            // not sure if this is the efficient way to do this... 
            XRLObject2 xrlReply = (XRLObject2) userEnumReply;

            //as a tool this doesn't have SGAuthInfo, so we fake it... 
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            try
            {
                HResult hr = XRLUtil.PostXrlRequest( XOService.MessagingService, userEnum.GetXRL(), fakedAuthData.GetBase64EncodedString(), userEnum, ref xrlReply );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: EnumUserMessages - XRLUtil.PostXrlRequest returned hr = {0}", hr ) );
                    //Console.WriteLine( "Error: EnumUserMessages - XRLUtil.PostXrlRequest returned hr = {0}", hr );
                    throw new Exception( "Enumerate User Messages request returned a failed hr = " + hr );
                }
                else
                { 
                    userEnumReply = (EnumerateMessagesReply) xrlReply;
                    return userEnumReply;
                }

            }
            catch( XrlRequestException e )
            {
//                Console.WriteLine( "Error: EnumUserMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() );
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: EnumUserMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() ) );
                throw e;
            }

        } // Enumerate User Messages


        // For user messages:
        //      Delete means RECIPIENT deletes message
        //      Revoke means SENDER deletes message 
        // Since the tool will generally specify a recipient, only DELETE will get implemented
        public static bool DeleteUserMessage( ulong userPUID, uint msgId, uint flags )
        {

            DeleteMessageMsg deleteMsg  = new DeleteMessageMsg();
            deleteMsg.qwUserID          = userPUID;                 // indicates the user (recipient)
            deleteMsg.dwMessageID       = msgId;                    // the id of the message to delete
            deleteMsg.dwFlags           = flags;                    // indicates revoke vs delete

            DeleteMessageReply deleteReply = new DeleteMessageReply();
            // not sure if this is the efficient way to do this... 
            XRLObject2 xrlReply = (XRLObject2) deleteReply;

            try
            {
                //HResult hr = XRLUtil.PostXrlRequest( XOService.MessagingService, "/xpnfront/xmessaging.srf", deleteMsg, ref xrlReply );
                HResult hr = XRLUtil.PostXrlRequest( XOService.MessagingService, "/xpnfront/xmessaging.srf", null, deleteMsg, ref xrlReply );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: DeleteUserMessage - XRLUtil.PostXrlRequest returned hr = {0}", hr ) );
                    return false;
                }
            }
            catch( XrlRequestException e )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: DeleteUserMessage - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() ) );
                return false;
            }
            Xom.Trace(XomAreaName.msgmanager, LogLevel.L_LOW, String.Format( "Message ID {0} deleted successfully.", msgId.ToString() ) );
            return true;

        } // delete user msg


        public static string FormattedUserMessageQueue( EnumerateMessagesReply msgQ )
        {
            //                Console.WriteLine("");
            //                Console.WriteLine("SenderID    SentTime               MessageID  MFlg SenderTitleID ExpireDate");
            //                
            //                foreach (MessageSummary ms in userEnumReply.rgMessages)
            //                {
            //                    Console.WriteLine("{0} \t {1} {2} {3} {4} {5}", 
            //                        ms.qwSenderID,
            //                        MsgDefs.MsgTimeToDateTime( ms.mtSentTime ),
            //                        ms.dwMessageID,
            //                        ms.dwMessageFlags,
            //                        ms.dwSenderTitleID,
            //                        MsgDefs.MsgTimeToDateTime( ms.mtSentTime ).AddMinutes((double) ms.wExpireMinutes ));
            //                }
            //                
            //                Console.WriteLine( "" );
            //                Console.WriteLine( "End Enumeration." );
            
            if ( msgQ == null )
            {
                throw new ArgumentNullException( "The EnumerateMessagesReply parameter cannot be null." );
            }

            StringBuilder output = new StringBuilder( 1024 );

            if ( msgQ.cMessages == 0 )
            {
                output.Append( "There were no messages in this user's message queue." );
            }
            else
            {
                output.Append("\nSenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate\n");
                foreach (MessageSummary ms in msgQ.rgMessages)
                {
                    output.Append( 
                        String.Format( "{0}, {1}, {2}, {3}, {4}, {5}\n", 
                        ms.qwSenderID,
                        MsgDefs.MsgTimeToDateTime( ms.mtSentTime ),
                        ms.dwMessageID,
                        ms.dwMessageFlags,
                        ms.dwSenderTitleID,
                        MsgDefs.MsgTimeToDateTime( ms.mtSentTime ).AddMinutes((double) ms.wExpireMinutes )
                        )
                        );

                } // foreach

                output.Append( "\nEnd Enumeration.\n" );

            } //else

            return output.ToString();
        }


        public static string FormattedSystemMessageQueue( EnumerateSystemMessagesReply msgQ )
        {
 
            //                Console.WriteLine("TitleID     MsgID       Sent                    ExpireDate            Description");
            //                foreach (SystemMessageSummary ms in enumReply.rgMessages)
            //                {
            //                    Console.Write("{0}  {1}  {2}  {3}  {4}",
            //                        ms.dwTitleID,
            //                        ms.dwMessageID,
            //                        ms.dtSentTime,
            //                        // An offset in minutes from the sent time
            //                        ms.dtSentTime.AddMinutes((double) ms.wExpireMinutes), 
            //                        ms.szDescription
            //                        );
            //
            //                } // foreach
            //
            //                Console.WriteLine( "" );
            //                Console.WriteLine( "End Enumeration." );


            //"There was an XRLRequest Error in EnumerateSystemMessages."
            if ( msgQ == null )
            {
                throw new ArgumentNullException( "The EnumerateMessagesReply parameter cannot be null." );
            }

            StringBuilder output = new StringBuilder( 1024 );

            if ( msgQ.cMessages == 0 )
            {
                output.Append( "There were no messages in the system message queue." );
            }
            else
            {
                output.Append("\nTitleID, MsgID, Sent, ExpireDate, Description\n");
                foreach ( SystemMessageSummary ms in msgQ.rgMessages )
                {
                    output.Append( 
                        String.Format( "{0}, {1}, {2}, {3}, {4}\n",
                        ms.dwTitleID,
                        ms.dwMessageID,
                        ms.dtSentTime,
                        // An offset in minutes from the sent time
                        ms.dtSentTime.AddMinutes((double) ms.wExpireMinutes), 
                        ms.szDescription 
                        )
                        );

                } // foreach
                output.Append( "\nEnd Enumeration.\n" );
            } //else

            return output.ToString();

        } //format system msgs


	} // class MsgManager


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\ini.cs ===
//
// Iniuration settings
//  
//  Provides global management of config settings.
// 
//  To use:
//
//      Ini.GetSetting("foo"); 
//          - returns the string value of 'foo' as specified
//            in the [global] section of the assembly's ini file, 
//            or empty string if not found.
//
//      Ini.GetSetting("mysection", "foo");
//          - same as above, but gets the setting from the 
//            specified section of the ini file.
//         
//  Ini files:
//      typical windows ini file format:
// 
//          ; this is a comment
//          [global]
//          MyFirstSetting=a value
//
//          [another section]
//          MyOtherSetting=another Value
//  
//      everything to the left of the first "=" is the name,
//      everything to the right is the value.
//
//      Note: all setting names/sections are case insensitive.
//
//  File name:
//      The ini file has the same name as the 
//      assembly this code is compiled, with the extension ".ini"
//
//  Location:
//      The same directory as the assembly is checked first.
//      If not found, the parent directory is checked.
//      If still not found, a warning event is logged, and all
//       calls to GetSetting() return an empty string.
//  
//  

using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Text;
using xonline.common.service;

namespace xonline.common.tools 
{

public class Ini
{
    private Hashtable _configSections = null;
    private bool _bChanged = false;

    public string GetSetting(string setting)
    {
        return GetSetting("global", setting);
    }
    
    /// <summary>
    ///  Adds, changes or removes a setting.  Pass in a null value
    ///  to remove a setting
    /// </summary>
    /// <param name="section"></param>
    /// <param name="setting"></param>
    /// <param name="value"></param>

    public void SetSetting(string section, string setting, string value)
    {
        if(_configSections == null)
        {
            if(value == null)
                return;

            _configSections = new Hashtable();
        }

        StringDictionary sectionSettings = (StringDictionary)_configSections[section.ToUpper()];
        if(sectionSettings == null)
        {
            if(value == null)
                return;

            sectionSettings = new StringDictionary();
            _configSections[section.ToUpper()] = sectionSettings;
        }

        if(value != null)
            sectionSettings[setting.ToUpper()] = value;
        else
            sectionSettings.Remove(setting.ToUpper());

        _bChanged = true;
    }

    public void Save(string IniPath)
    {
        StreamWriter writer = File.CreateText(IniPath);

        try
        {
            foreach(DictionaryEntry section in _configSections)
            {
                writer.WriteLine("[" + section.Key.ToString().ToUpper() + "]");

                StringDictionary sd = (StringDictionary)section.Value;

                foreach(DictionaryEntry setting in sd)
                {
                    writer.WriteLine(setting.Key.ToString().ToUpper() + "=" + setting.Value.ToString());
                }

                writer.WriteLine("");
            }
        }
        finally
        {
            writer.Close();
        }

        _bChanged = false;
    }

    public string GetSetting(string section, string setting)
    {
        StringDictionary sectionSettings;
        string val = "";
        
        if (_configSections == null)
        {
            goto Cleanup;
        }        
        
        sectionSettings = (StringDictionary)_configSections[section.ToUpper()];
        if (sectionSettings == null)
        {
            goto Cleanup;
        }
        
        val = sectionSettings[setting.ToUpper()];
        if(val == null)
            val = "";
        
Cleanup:        
        return val;
    }
    



    public Ini(string iniPath)
    {
        Init(iniPath);
    }

    public Ini()
    {
        Init(null);
    }

    private void Init(string iniPath)
    {
        StreamReader reader = null;
        string line;
        Hashtable configSections = null;
        string currentSection = "global";
        string name;
        string val;
        int n;
        
        
        if(iniPath != null)
        {
            try
            {
                if (!File.Exists(iniPath))
                {
                    return;
                }
        
                reader = File.OpenText(iniPath);
                for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                {
                    line = line.Trim();
                
                    // emtpy line
                    if (line == "")
                        continue;
                    
                    // comment
                    if (line.StartsWith(";"))
                        continue;
                
                    // new section    
                    if (line.StartsWith("["))
                    {
                    
                        n = line.IndexOf(']');
                        if (n <= 1)
                        {
                            return;
                        }
                    
                        currentSection = line.Substring(1, n-1).ToUpper();
                        continue;
                    }
                
                    line = line.Trim();
                
                    // continuation char
                
                    while (line.EndsWith("\\"))
                    {
                        // REVIEW: is this correct?
                        line = line.Substring(0, line.Length-1);
                    
                        string line2 = reader.ReadLine();
                        if (line2 == null)
                        {
                            return;
                        }
                    
                        line += line2.TrimEnd(null);
                    }
                
                
                    // name/value pair
                    n = line.IndexOf("=");
                    if (n <= 0)
                    {
                        return;
                    }
                
                    name = line.Substring(0, n).Trim().ToUpper();
                
                    if (n < line.Length-1)
                    {
                        val = line.Substring(n+1).Trim();
                    }
                    else
                    {
                        // no val specified (a=)
                        val = "";
                    }
                
                    if (configSections == null)
                    {
                        configSections = new Hashtable();
                    }
                    if (configSections[currentSection] == null)
                    {
                        configSections[currentSection] = new StringDictionary();
                    }
                
                    ((StringDictionary)(configSections[currentSection]))[name] = val;
                
                }
                _configSections = configSections;
            }
            finally
            {
                if(null != reader)
                {
                    reader.Close();
                }
            }
        }
    }
    
    public StringDictionary GetSection(string section)
    {
        return (_configSections == null ? null : (StringDictionary)_configSections[section.ToUpper()]);
    }

    public bool Changed
    {
        get
        {
            return _bChanged;
        }
    }

    public Hashtable Sections
    {
        get
        {
            return _configSections;
        }
    }
}

internal class IniUtil
{
    public static string[,] GetParams(string str)
    {
        string[] pairs = str.Split( new char[] { ';' } );
        string[] param;
        string[,] paramList = new string[pairs.Length, 2];
        char[] pairDelim = new char[] { '=' };

        for (int n = 0; n < pairs.Length; n++)
        {
            param = pairs[n].Split( pairDelim );

            if (param.Length != 2)
            {
                return null;
            }

            paramList[n,0] = param[0].ToUpper();
            paramList[n,1] = param[1];
        }

        return paramList;

    }
    
}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\TitleVault.cs ===
using System;
using System.IO;

using xonline.common.config;


namespace xonline.common.tools
{
    class TitleVault
    {

        public static void TitleVaultCopy( string titleRoot, string fromPath, string toFileName )
        {
            FileAttributes fa;

            if ( !File.Exists( fromPath ) )
            {
                throw new Exception( "Cannot Copy Non-Existent file! Path was: " + fromPath );
            }

            string destFilePath = titleRoot + "\\" + toFileName;

            if ( File.Exists( destFilePath ) )
            {
                if ( !Directory.Exists( titleRoot + "\\OLD" ) )
                {
                    //create backup directory
                    Directory.CreateDirectory( titleRoot + "\\OLD" );
                }

                string oldFileName = titleRoot + "\\OLD\\" + toFileName;

                if ( File.Exists( oldFileName ) )
                {

                    //delete old file
                    fa = File.GetAttributes( oldFileName );
                    fa &= ~(FileAttributes.ReadOnly);
                    File.SetAttributes( oldFileName, fa );
                    File.Delete( oldFileName );
                }

                //move current to old
                File.Move( destFilePath, oldFileName );

            }

            //copy new to current
            File.Copy( fromPath, destFilePath );

            //make sure it isn't read-only
            fa = File.GetAttributes( destFilePath );
            fa &= ~(FileAttributes.ReadOnly);
            File.SetAttributes( destFilePath, fa );

        }

        public static int MoveFilesToTitleVault( string xboxPath, string xscPath, string xmsPath, string xqsPath, string ltcPath, uint uiTitleID )
        {
            int fileCount = 0;
            string titleID = uiTitleID.ToString("X8");

            //write XLAST and LTC
            string titleRoot = Config.GetSetting( Setting.titlevault_root ) + "\\" + titleID;
            CommandUtility.WriteOutput( "\nMoving source files to TitleVault location:\n  " + titleRoot );

            if ( ! Directory.Exists( titleRoot ) )
            {
                Directory.CreateDirectory( titleRoot );
            }

            if ( ! Directory.Exists( titleRoot + "\\OLD" ) )
            {
                Directory.CreateDirectory( titleRoot + "\\OLD" );
            }

            TitleVaultCopy( titleRoot, xboxPath, titleID + ".xbox" );
            fileCount++;
            CommandUtility.WriteOutput("   Copied XBOX file to TitleVault." );

            TitleVaultCopy( titleRoot, ltcPath, titleID + "_LTC.xml" );
            fileCount++;
            CommandUtility.WriteOutput("   Copied LTC file to TitleVault." );

            if (xscPath != null)
            {
                TitleVaultCopy( titleRoot, xscPath, titleID + ".xsc" );
                fileCount++;
                CommandUtility.WriteOutput("   Copied XSC file to TitleVault." );
            }

            if (xmsPath != null)
            {
                TitleVaultCopy( titleRoot, xmsPath, titleID + ".xms" );
                fileCount++;
                CommandUtility.WriteOutput("   Copied XMS file to TitleVault." );
            }

            if (xqsPath != null)
            {
                TitleVaultCopy( titleRoot, xqsPath, titleID + ".xqs" );
                fileCount++;
                CommandUtility.WriteOutput("   Copied XQS file to TitleVault." );
            }

            return fileCount;
        }

        public static string GetTitleVaultRootPath( uint uiTitleID )
        {
            string titleID = uiTitleID.ToString("X8");
            return Config.GetSetting( Setting.titlevault_root ) + "\\" + titleID;
        }

        public static string GetTitleVaultXscPath( uint uiTitleId )
        {
            return Config.GetSetting( Setting.titlevault_root ) + "\\" +
                uiTitleId.ToString("X8") + "\\" +
                uiTitleId.ToString("X8") + ".xsc";
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\DeActivator.cs ===
using Microsoft.Webstore.WstClient;

using System;
using System.Collections;
using System.Data;
using System.Text;

using xonline.common.billing;
using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.deactivator)]
[assembly: XomAreaDefinition(XomAreaName.pss)]

namespace xonline.tools.framework
{
    // Why separate the decision from the action?  Doesn't this seem artificial and cumbersome?
    // The decision logic will start simple and grow more complicated in the future.
    // The goal here was to be able to isolate and test each part of this code separately: 
    //  - gathering the objects to inform the decision
    //  - make a decision based on the objects and business logic
    //  - take actions on objects in the DB
    // ==> this allows me to:
    //      Keep the .exe code very simple and easy to read
    //      Write tests for each part (gathering, deciding, acting) to confirm it's correct, independent of the other parts
    //      Reuse more of this code later

    // of course... then I go and develop tests for ProcessHash first, making it less interesting
    // to test the underlying methods... ugh.

    #region Constants and Enums

    // this enum is the RESULT of the DECISION TREE
    public enum ActionDecision 
    {
        NoAction, 
        LogForPSS, 
        DeactivateHash, 
        DeactivateHashAndAccount, 
        DeactivateHashChangeRenewalBlank, 
        DeactivateHashChangeRenewalAnnual, 
        DeactivateHashChangeRenewalMonthly,
        UnknownCase,
        MaxValue                                // This MUST be the last item in the enum
    };
    
    //task: add items to this for the UserBilling scenarios... 
    // this enum is the RESULT of the ACTION 
    public enum ProcessingResult 
    {
        VoucherDisabled,                    // the hash was successfully disabled
        VoucherUserNotDisabled,             // the hash had a user, so we didn't disable it
        VoucherNotFound,                    // the voucher's hash wasn't found
        VoucherAndUserDisabled,             // the user and hash were successfully disabled
        VoucherDisabledUserRenewalBlank,    // voucher disabled, and user set to blank
        VoucherDisabledUserRenewalAnnual,   // voucher disabled, and user renewal changed
        VoucherDisabledUserRenewalMonthly,  // voucher disabled, and user renewal changed
        LiveUserNotFound,                   // there was no corresponding Xbox Live user
        BillingUserNotFound,                // there was no corresponding account with our Billing Partner (SCG?)
        NoAction,                           // means for whatever reason, no action was taken
        LoggedForPSS,                       // logged for further investigation
        MaxValue                            // This MUST be the last item in the enum
    }

    #endregion


    /// <summary>
    /// Contains the meat of the code for the exe. Easier to test this way...
    /// </summary>
    public class DeActivator
    {

        public const string XBOX_DESCRIPTION_PREFIX = "XBX";
        public const string DeActivatorMessage = "Account Action by SubCodeMgr ";

        /// <summary>
        /// Process Hash coordinates loading, deciding and acting on this hash.  The action which 
        /// should be taken is returned.  The returned action is only taken if reportonly is false.
        /// </summary>
        /// <param name="hash">This is the hash to be processed.</param>
        /// <param name="hashonly">Boolean to determine whether to look up user accounts if present.  
        /// Hashonly --> deactivate hashes, !Hashonly --> process returns </param>
        /// <param name="reportonly">If true, no changes will be made.</param>
        public static ProcessingResult ProcessHash( byte[] hash, bool hashonly, bool reportonly, out ActionDecision actionDecision )
        {

            Voucher v;
            // ActionDecision action;
            actionDecision = ActionDecision.NoAction;

            try
            {
                // load the hash object
                v = Voucher.Load( hash );
            }
            catch (VoucherNotFoundException vnf)
            {
                //sometimes we might not find a hash, it's no big deal, log it an move on... 
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "ProcessHash: " + vnf.Message + "... Hash was: " + VoucherUtil2.HashByteToHexStr( hash ) );
                return ProcessingResult.VoucherNotFound;
            }             

            // decision logic begins here...
            // if we're touching hashes only OR the hash we found has no associated users... 
            if ( hashonly || ( v.VoucherUsage.Count == 0 ) )   
            {
                // then we have all the info to decide... 

                //task: add a try/catch here for decide or add exceptions so we can continue processing??

                //decide action - what is the proposed action to take?
                actionDecision = DecideAction( v );
                // Console.WriteLine("  ProcessHash: Decision on Voucher was " + actionDecision.ToString() );
                //take action - returns what really happened to the user
                return TakeAction( v, actionDecision, reportonly );

            }
            else  // otherwise, since we're changing users, we need more info before deciding what to do 
            {

                //only one use per voucher, or it's something for a person to fix
                if ( v.VoucherUsage.Count > 1 )
                {
                    Xom.Trace(XomAreaName.pss, LogLevel.L_ERROR, "ProcessHash: Voucher has more than one user: " + v.ToString());
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_ERROR, "ProcessHash: Voucher has more than one user: " + v.ToString() );
                    throw new Exception( "ProcessHash: Voucher has more than one user. See log for details." );
                }
            
                User2 u;
                UserBillingInfo ubi;
            
                try 
                {
                    //load user
                    u = User2.Load( ( ( VoucherUse ) v.VoucherUsage[ 0 ] ).puid );
            
                    //load user billing info
                    ubi = new UserBillingInfo( );
                    ubi.LoadBilling( u );

                }
                catch ( UserNotFoundException unfe )
                {
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_ERROR, "ProcessHash: " + unfe.ToString() + ". User was " + ( ( VoucherUse ) v.VoucherUsage[0] ).puid.ToString() );
                    return ProcessingResult.BillingUserNotFound;
                }
                catch ( UserBillingInfoNotFoundException ubinfe )
                {
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_ERROR, "ProcessHash: " + ubinfe.ToString() + ". Voucher was " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + ".  User was " + ( ( VoucherUse ) v.VoucherUsage[0] ).puid.ToString() );
                    return ProcessingResult.BillingUserNotFound;
                }
            
                //task: add a try/catch here for decide or act exceptions so we can continue processing??
                actionDecision = DecideAction( v, u, ubi );
                return TakeAction( v, u, ubi, actionDecision, reportonly );

            } // else (!hashonly)

        }


        /// <summary>
        /// Given a Voucher, decide what action should be taken if only deactivating hashes.  Use the overload
        /// of this function which also accepts user and userbillinginfo objects if /deactivateaccounts is selected.
        /// </summary>
        /// <param name="dav">DecideActionVoucher</param>
        public static ActionDecision DecideAction( Voucher dav )
        {

            // ProcessingResult.VoucherUserNotDisabled

            // if the voucher hasn't been used, then "deactivate"
            if ( dav.VoucherUsage.Count == 0 )
            {
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "ProcessHash: no uses, deactivate." );
                return ActionDecision.DeactivateHash;
            }
            else
            {
                // if hash is used, and hashonly => do nothing
                StringBuilder puids = new StringBuilder("", 80);
                foreach ( VoucherUse vu in dav.VoucherUsage )
                {
                    puids.Append( vu.ToString() );
                    puids.Append( "  " );
                }
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "ProcessHash: No Action, Voucher has " + dav.VoucherUsage.Count.ToString() + " uses. Puid List is: " + puids.ToString() );
                return ActionDecision.NoAction;
            }

        }



        /// <summary>
        /// Take the action on the Voucher specified in the ActionDecision parameter.  If reportOnly is true
        /// then no action is taken in any case, and the return value is the action which would 
        /// have been taken if reportOnly was false.
        /// ONLY USE THIS OVERLOAD for DEACTIVATING HASHES.  Do not use this overload if you want to deactivate accounts.
        /// </summary>
        /// <param name="v"></param>
        /// <param name="action"></param>
        /// <param name="reportOnly"></param>
        /// <returns></returns>
        public static ProcessingResult TakeAction( Voucher v, ActionDecision action, bool reportOnly )
        {
            // overload for handling deactivation
            //task: any bad voucher states to guard against?
            ProcessingResult result = ProcessingResult.NoAction;

            switch ( action )
            {                  
                case ActionDecision.NoAction:
                    // just log no action, the fancy footwork allows us to re-use this case for both (!reportonly && .NoAction) and for ( reportonly && * )
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeAction: No Action for voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + " || reportonly is " + reportOnly.ToString() );
                    result = ProcessingResult.NoAction;
                    break; 

                case ActionDecision.LogForPSS: 
                    // just write to PSS Log
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionwithBilling: LogForPSS. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + " || reportonly is " + reportOnly.ToString() );
                    Xom.Trace(XomAreaName.pss, LogLevel.L_LOW, "TakeActionwithBilling: LogForPSS. Voucher: " + VoucherUtil2.HashByteToHexStr(v.voucherhash) + " || reportonly is " + reportOnly.ToString());
                    break; 

                case ActionDecision.DeactivateHash: 
                    if ( reportOnly )
                    {
                        // just deactivate the unused hash
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeAction: Disable voucher " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + ". Readonly = true.");
                        result = ProcessingResult.NoAction;
                    }
                    else
                    {
                        // just deactivate the unused hash
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeAction: Disable voucher " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) );
                    
                        //disables all offers of this voucher
                        v.Disable();
                        v.Save();
                        result = ProcessingResult.VoucherDisabled;
                    }
                    break;

                case ActionDecision.DeactivateHashAndAccount:
                    // deactivate the unused hash and the associated account
                    // INVALID CASE for this method -> Invalid Action exception
                    throw new Exception("This is an invalid action in this case. There is a bug!");
                    //break;  
                
                // create other actions ???
                default:
                    // what happens if Action it isn't one of the Above?
                    // INVALID CASE for this method -> Invalid Action exception
                    throw new Exception("This is an invalid action in this case. There is a bug!");
                    //break; 

            } // end switch

            return result;
        } // take action



        /// <summary>
        /// Given a Voucher, User and UserBillingInfo decide what action should be taken
        /// </summary>
        /// <param name="v"></param>
        public static ActionDecision DecideAction( Voucher v, User2 u, UserBillingInfo ubi )
        {

            //thanks to bug 17266
            //if their account currently can't login, then we can quickly log this for PSS to deal with
            //their account status could be < 0 for a variety of reasons beyond our scope...
            // 0x8xxxxxxx denotes an error condition.  all those values are < 0 when casted as an int...
            if ( HResult.Failed( u.BillingAccountStatus ) )
            {
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: " + ActionDecision.LogForPSS + ".  Reason: User Account has an issue that prevents deactivating without further investigation." );
                return ActionDecision.LogForPSS;
            }


            //need to figure out what offer they're in and what they'll renew into...
            int baseSubscriptionIndex = -1;
            try 
            {
                baseSubscriptionIndex = ubi.GetBaseSubscriptionIndex();
            }
            catch ( UserBillingInfoSubscriptionException )
            {
                return ActionDecision.LogForPSS; 
            }

            //use the offeringguid from the subscription we found above
            //to find the bi_offer_id of this subscription (eg. 0xFFFE000080000008 for 12 Month Online Subscription for all countries)
            //in the t_offer_regions table.

            ulong currentOfferID = 0;
            ulong renewalOfferID = 0;
            ulong returnOfferID = 0;

            // now that we have the user's base subscription, we need to find out what offer 
            // they're currently in, and what offer they'll renew into
            using (WstConnection offerConn = new WstConnection( xonline.common.config.ConfigUtil.UodbWebstoreApp ) )
            {
                
                //exceptions get handled higher up
                offerConn.Open();
                WstCommand offerCmd = offerConn.CreateCommand();
                offerCmd.CommandType = CommandType.StoredProcedure;
                offerCmd.Partition = WstCommand.AnyPartition;
                
                //Look up the subscription's current OfferingID to find it's OfferID
                // offerCmd.CommandText = "select bi_offer_id from dbo.t_offer_regions with (nolock) where vc_billing_offer_id = @billing_offer_id and ti_country_id = @country_id";
                offerCmd.CommandText = "dbo.p_xbos_get_offerids_from_boid";

                offerCmd.Parameters.Add( "@billingofferid", SqlDbType.NVarChar, 36).Value = ubi.Subscriptions.Items[ baseSubscriptionIndex ].OfferingGUID;
                offerCmd.Parameters["@billingofferid"].Direction = ParameterDirection.Input;

                WstDataReader wr = offerCmd.ExecuteReader();

                if ( wr.Read() )
                {
                    //value returned by procedure is large neg, so this should get the right value... 
                    currentOfferID = (ulong) wr.GetInt64( 0 );
                    wr.Close();
                    wr = null;
                }
                else
                {
                    throw new Exception("Unable to retrieve an OfferID for the following BOID: " + ubi.Subscriptions.Items[ baseSubscriptionIndex ].OfferingGUID );
                }
                
                //Then, we lookup the subscription's RenewOfferingId in t_offer_regions to find it's offerID
                offerCmd.Parameters[ "@billingofferid" ].Value = ubi.Subscriptions.Items[ baseSubscriptionIndex ].RenewOfferingId;
                wr = offerCmd.ExecuteReader();

                if ( wr.Read() )
                {
                    renewalOfferID = (ulong) wr.GetInt64( 0 );
                    wr.Close();
                    wr = null;
                }
                else
                {
                    throw new Exception("Unable to retrieve an OfferID for the following BOID: " + ubi.Subscriptions.Items[ baseSubscriptionIndex ].RenewOfferingId );
                }

            } // using
            
            //task: remove debug code
            // Console.WriteLine("Decision: cur - 0x{0}, ren - 0x{1}", currentOfferID.ToString("X"), renewalOfferID.ToString("X") );

            //NOTE: All offers for a voucher must be equivalent, we'll take the first
            if ( v.VoucherOffers[ 0 ] != null )
            {
                returnOfferID = ( (VoucherOffer) v.VoucherOffers[ 0 ] ).offerID;
            }
            else
            {
                throw new Exception("DeActivatorDecision(v,u,ubi): Voucher had no offers");
            }

            Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: Curr " + currentOfferID.ToString("X") + ", Renew " + renewalOfferID.ToString("X") + ", Vchr/Rtn " + returnOfferID.ToString("X") );

            //Then the decision logic...
            //In short, we're trying to figure out if the subcode "value" they returned (the voucher)
            //is equal to something on their account ( renewal offer) that we can remove from their account
            //note: we cannot remove their main subscription while they have "chained" value          
            if ( OfferValues.IsOfferPairEquivalent( returnOfferID, renewalOfferID ) )
            {
                // Convert renewal to default renewal
                if ( u.CountryID == 53 ) // Japan Country ID
                {
                    //find user's default renewal
                    //go to t_offer_regions using japan countryID
                    //find the offering GUID which associate with that country and *monthly* renewal
                    // Japan:  0xFFFE00008000000B  monthly renewal
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: " + ActionDecision.DeactivateHashChangeRenewalMonthly );
                    return ActionDecision.DeactivateHashChangeRenewalMonthly;               
                }
                else
                {
                    //for every other country
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: " + ActionDecision.DeactivateHashChangeRenewalAnnual );
                    return ActionDecision.DeactivateHashChangeRenewalAnnual;
                    //find user's default renewal
                    //go to t_offer_regions using country id 
                    //find the offering GUID which associate with that country and yearly renewal
                    // All other Countries -- 0xFFFE00008000000C  Yearly Renewal
                }

            }
            else if ( OfferValues.IsOfferPairEquivalent( returnOfferID, currentOfferID ) 
                &&
                (
                OfferValues.IsOfferPairEquivalent( renewalOfferID, OfferValues.AnnualRenewal ) ||
                OfferValues.IsOfferPairEquivalent( renewalOfferID, OfferValues.MonthlyRenewal ) 
                )
                )
            {
                // cancel subscriptions 
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: " + ActionDecision.DeactivateHashAndAccount );
                return ActionDecision.DeactivateHashAndAccount;
            }
            else
            {
                // log for PSS
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: " + ActionDecision.LogForPSS );
                return ActionDecision.LogForPSS;
            }
                             

//task: delete old version of decision tree based on spec
//            //if current offer is annual or monthly renewal
//            if ( ( currentOfferID == OfferValues.AnnualRenewal ) || ( currentOfferID == OfferValues.MonthlyRenewal ) )
//            {
//                Console.WriteLine("Decision: annual or monthly");
//                omTrace( deactivator, L_LOW, "DecideAction: User's current offer is renewal - No Action. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "  User: " + u.OwnerPuid.ToString() );
//                return ActionDecision.NoAction;
//            } 
//            //if current offer is ( Starter Kit or PrePaid card ) or ( game trial or console trial ) or (prepaid 3 month)
//            else if ( 
//                ( OfferValues.IsOfferPairEquivalent( currentOfferID, OfferValues.StarterKit ) ) || 
//                ( OfferValues.IsOfferPairEquivalent( currentOfferID, OfferValues.GameTrial ) ) ||
//                ( OfferValues.IsOfferPairEquivalent( currentOfferID, OfferValues.PrePaid3Month ) )
//                )
//            {
//                //if renewal offer is annual or monthly renewal
//                if ( ( renewalOfferID == OfferValues.AnnualRenewal ) || ( renewalOfferID == OfferValues.MonthlyRenewal ) )
//                {
//                    omTrace( deactivator, L_LOW, "DecideAction: User's renewal offer is renewal - DeactivateHashAndAccount. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "  User: " + u.OwnerPuid.ToString() );
//                    return ActionDecision.DeactivateHashAndAccount;
//                }
//                    //else if renewal offer is Starter Kit or PrePaid card
//                else if ( 
//                    ( OfferValues.IsOfferPairEquivalent( renewalOfferID, OfferValues.StarterKit ) ) ||
//                    ( OfferValues.IsOfferPairEquivalent( renewalOfferID, OfferValues.PrePaid3Month ) )
//                    )
//                {
//                    //check if the value they're returning is the same offer as their renewal
//                    //iterate through voucherOffers (should be just one offer) to see if 
//                    // there is an offer of this voucher which is "StarterKit" or "PrePaid"
//                    bool sameOffer = false;
//                    foreach( VoucherOffer vo in v.VoucherOffers )
//                    {
//                        if ( OfferValues.IsOfferPairEquivalent( vo.offerID, renewalOfferID ) )
//                        {   
//                            sameOffer = true;
//                            break;
//                        }
//
//                    } //foreach
//
//                    if ( sameOffer ) 
//                    {
//                        //this retrieves the end date of the enabled Base subscription (sub which gives them the Xbox Live Service)
//                        System.DateTime endDate = System.Convert.ToDateTime( ubi.Subscriptions.Items[ baseSubscriptionIndex ].EndDate );
//                        if ( endDate >  System.DateTime.UtcNow.AddDays( 30 ) )
//                        {
//                            omTrace( deactivator, L_LOW, "DecideAction: User's end date is > 30 days - DeactivateHashChangeRenewal. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "  User: " + u.OwnerPuid.ToString() );
//                            // roughly means set renewal offering id to blank (there are country specifics)
//                            // (sps will come and clean it up later )
//                            return ActionDecision.DeactivateHashChangeRenewalBlank; 
//                        }
//                        else
//                        {
//                            if ( u.CountryID == 53 )  // Japan Country ID
//                            {
//                                //find user's default renewal
//                                //go to t_offer_regions using japan countryID
//                                //find the offering GUID which associate with that country and *monthly* renewal
//                                // Japan:  0xFFFE00008000000B  monthly renewal
//                                return ActionDecision.DeactivateHashChangeRenewalMonthly;
//                                // stick that offering GUID into the renewOfferingID
//
//                            }
//                            else if ( u.CountryID == 56 ) // Korea Country ID
//                            {
//                                // set renewOfferingID to blank
//                                omTrace( deactivator, L_LOW, "DecideAction: User's end date is > 30 days - DeactivateHashChangeRenewal. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "  User: " + u.OwnerPuid.ToString() );
//                                return ActionDecision.DeactivateHashChangeRenewalBlank; 
//                            }
//                            else
//                            {
//                                //for every other country
//                                return ActionDecision.DeactivateHashChangeRenewalAnnual;
//                                //find user's default renewal
//                                //go to t_offer_regions using country id 
//                                //find the offering GUID which associate with that country and yearly renewal
//                                // All other Countries -- 0xFFFE00008000000C  Yearly Renewal
//                                // stick that offering GUID into the renewOfferingID
//                            }
//                        } 
//                        
//                    } // sameOffer
//                    else
//                    {
//                        // log for pss
//                        return ActionDecision.LogForPSS;
//
//                    } // not same offer
//
//                }// if renewal offer prepaid
//
//            }// if current offer prepaid

//            //if we've done a good job, we never get here... 
//            Console.WriteLine("Decision: somehow getting to the end");
//            return ActionDecision.NoAction;

        } // decideaction ( with billing info )



        /// <summary>
        /// Take the action specified in the ActionDecision parameter on the Voucher, User and UserBillingInfo.  If reportOnly is true
        /// then no action is taken in any case, and the return value is the action which would 
        /// have been taken if reportOnly was false.
        /// ONLY USE THIS OVERLOAD for the DEACTIVATING ACCOUNTS option.  Do not use this overload if you *just* want to retire old hashes.
        /// </summary>
        /// <param name="v"></param>
        /// <param name="u"></param>
        /// <param name="ubi"></param>
        /// <param name="action"></param>
        /// <param name="reportonly"></param>
        /// <returns></returns>
        public static ProcessingResult TakeAction( Voucher v, User2 u, UserBillingInfo ubi, ActionDecision action, bool reportOnly )
        {
            // overload for handling returns
            ProcessingResult result = ProcessingResult.NoAction;

            switch ( action )
            {                  
                case ActionDecision.NoAction:
                    // log no action 
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: No Action. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + " OwnerPuid: " + u.OwnerPuid + " SPSAcctID: " + u.AccountID + " || reportonly is " + reportOnly.ToString() );
                    break; 

                case ActionDecision.LogForPSS: 
                    // just write to PSS Log
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: LogForPSS. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + " OwnerPuid: " + u.OwnerPuid + " SPSAcctID: " + u.AccountID + " || reportonly is " + reportOnly.ToString() );
                    Xom.Trace(XomAreaName.pss, LogLevel.L_LOW, "TakeActionBilling: LogForPSS. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + " OwnerPuid: " + u.OwnerPuid + " SPSAcctID: " + u.AccountID + " || reportonly is " + reportOnly.ToString() + "\nSPS Raw XML is: \n" + ubi.RawXML );
                    result = ProcessingResult.LoggedForPSS;
                    break; 

                case ActionDecision.DeactivateHash: 
                    // INVALID CASE for this method -> Invalid Action exception
                    throw new Exception("DeactivateHash is an invalid action in DeactivateAccounts. There is a bug!");
                    // break;

                case ActionDecision.DeactivateHashAndAccount:
                    if ( reportOnly )
                    {
                        // just deactivate the unused hash
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashAndAccount " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() + ". Readonly = true.");
                        result = ProcessingResult.NoAction;
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashAndAccount " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() );

                        // deactivate the unused hash 
                        v.Disable();
                        v.Save();

                        //... and the associated account (and subscriptions)
                        // loop through all subscriptions, doing the base subscription *last*
                        int baseSub = ubi.GetBaseSubscriptionIndex();
                        for (int iLoop = 0; iLoop < ubi.Subscriptions.Items.Length ; iLoop ++ )
                        {
                            // if it's an XBX subscription, and not the base one, cancel it!
                            if ( 
                                 ( iLoop != baseSub ) && 
                                 ( ubi.Subscriptions.Items[ iLoop ].InternalSubscriptionDescription.IndexOf( XBOX_DESCRIPTION_PREFIX, 0 ) >= 0 ) 
                                )
                            {
                                ubi.CancelSubcription( iLoop, DeActivatorMessage + " voucherHash: " + v.voucherhash );
                            }
                        }

                        ubi.CancelSubcription( baseSub, DeActivatorMessage + " voucherHash: " + v.voucherhash );

                        // confirm it worked, at least for base subscription
                        UserBillingInfo ubi2 = new UserBillingInfo();
                        ubi2.LoadBilling( u );

                        if ( ubi2.Subscriptions.Items[ baseSub ].SubscriptionStatusInfo.SubscriptionStatus != "CANCELED" )
                        {
                            // it didn't work
                            Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeAction: Error - DeactivateHashChangeRenewalAnnual FAILED - " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() + " " );
                            throw new Exception("There was a failure during ConvertSubscriptionRenewal.");
                        }

                        result = ProcessingResult.VoucherAndUserDisabled;
                    }
                    break;  

                case ActionDecision.DeactivateHashChangeRenewalAnnual:
                    if ( reportOnly )
                    {
                        // deactivate hash and change renewal offer to annual renewal
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalAnnual " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() + ". Readonly = true.");
                        result = ProcessingResult.NoAction;
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalAnnual " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() );

                        // deactivate hash and change renewal offer to annual renewal
                        v.Disable();
                        v.Save();

                        int baseSubscriptionIndex = ubi.GetBaseSubscriptionIndex();

                        //have to cast country ID, or hashtable returns de nada
                        string annualRenewalOfferID = UserBillingInfo.YearlyRenewalOfferGUID[ (int) u.CountryID ].ToString();

                        // and the change the renewal for the associated account
                        ubi.ConvertSubscriptionRenewal( annualRenewalOfferID, baseSubscriptionIndex );
                        
                        //task: confirm the setting?

                        //if we get this far without an exception, we've succeeded... 
                        result = ProcessingResult.VoucherDisabledUserRenewalAnnual;
                    }
                    break;  

                case ActionDecision.DeactivateHashChangeRenewalMonthly:
                    if ( reportOnly )
                    {
                        // just deactivate the unused hash
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalMonthly " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() + ". Readonly = true.");
                        result = ProcessingResult.NoAction;
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalMonthly " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() );

                        // deactivate the unused hash 
                        v.Disable();
                        v.Save();

                        // and change the renewal for the associated account

                        int baseSubscriptionIndex = ubi.GetBaseSubscriptionIndex();
                        //have to cast country ID, or hashtable returns de nada
                        string monthlyRenewalOfferID = UserBillingInfo.MonthlyRenewalOfferGUID[ (int) u.CountryID ].ToString();
                        ubi.ConvertSubscriptionRenewal( monthlyRenewalOfferID, baseSubscriptionIndex );

                        //task: confirm the setting?

                        result = ProcessingResult.VoucherDisabledUserRenewalMonthly;
                    }
                    break;  


                //task: should probably remove this since we won't use it for Korea... 
                case ActionDecision.DeactivateHashChangeRenewalBlank:
                    if ( reportOnly )
                    {
                        // just deactivate the unused hash
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalBlank " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() + ". Readonly = true.");
                        result = ProcessingResult.NoAction;
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalBlank " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() );

                        // deactivate the unused hash 
                        v.Disable();
                        v.Save();

                        // and change the renewal for the associated account

                        int baseSubscriptionIndex = ubi.GetBaseSubscriptionIndex();
                        string monthlyRenewalOfferID = "00000000-0000-0000-0000-000000000000";
                        ubi.ConvertSubscriptionRenewal( monthlyRenewalOfferID, baseSubscriptionIndex );

                        //task: confirm the setting?

                        result = ProcessingResult.VoucherDisabledUserRenewalBlank;
                    }
                    break;  

                //task: create other actions ???
                default:
                    // what happens if Action it isn't one of the Above?
                    //task: INVALID CASE for this method -> Invalid Action exception

                    break; 
            } // end switch

            return result;

        } // take action 



    }// deactivator

    //task: new exception for invalid action

}// namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\UserBillingInfo.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;

using Billing.PSO;

using xonline.common.billing;
using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.userbillinginfo)]
[assembly: XomAreaDefinition(XomAreaName.toolspslog)]

namespace xonline.tools.framework
{


    /// <summary>
    /// Holds information from SPS about a user and their subscriptions.
    /// Use Load to load SPS information, and use ReLoad rather than creating another object if you need
    /// to access information for multiple users.
    /// </summary>
    public class UserBillingInfo
    {

        #region Properties, Privates and Constants

        // all values are initialized in the constructor anyway, but it looks good
        protected bool spsDataLoaded = false;
        protected ulong ownerPUID;
        protected const string SPS_TEST_STRING = "Testing123";
        public static Hashtable YearlyRenewalOfferGUID = new Hashtable( 24 );
        public static Hashtable MonthlyRenewalOfferGUID = new Hashtable( 24 );

        //so that we don't have to keep looking this up once it's been looked up...
        //and I don't want to take it as an exception during load if something's weird...
        protected int baseSubscriptionIndex = -1;
        public int LiveBaseSubscriptionIndex
        {
            get
            {
                if ( spsDataLoaded )
                {
                    return baseSubscriptionIndex;
                }
                else
                {
                    throw new Exception("Cannot get LiveBaseSubscriptionIndex untill UBI.LoadBilling has completed successfully.");
                }
            }
        }


        //XML response string from SPS describing user's subscriptions
        protected string spsXML;       // the original XML from SPS

        public SubscriptionInfoSet Subscriptions;        // ... serialized nicely into a class...

        public string RawXML
        {
            get
            {
                if ( spsDataLoaded )
                {
                    return spsXML;
                }
                else
                {
                    throw new Exception("Cannot get XML till BdkLoad has completed successfully.");
                }
            }
        }


        public bool IsSPSLoaded
        {
            get
            {
                return spsDataLoaded;
            }
        }


        // this exposes the tracking guid of the last request to SPS
        protected string lastTrackingGUID = "";

        public string TrackingGUID
        {
            get
            {
                return lastTrackingGUID;
            }
        }


        #endregion

        #region CONSTRUCTORS

        //task: review whether the calling program will need to .Init and .Close the XOM stream
        public UserBillingInfo( )
        {
            // XomLoggingControl.Init();
        }


        ~UserBillingInfo( )
        {
            // XomLoggingControl.Close();
        }


        static UserBillingInfo( )
        {
            //task: fix this with a class that caches this info either from the DB or SPS

            //ANNUAL

            //after some deliberation, since this will work till Xenon ships,
            //and we'll likely need to touch this to make sure it fits Xenon billing plans,
            //the conclusion was that while this is ugly we will use it till Xenon
            YearlyRenewalOfferGUID.Add( 5,  "d38c0853-428a-4d2e-b184-20e074cf5e96" ); // AT
            YearlyRenewalOfferGUID.Add( 6,  "15663c58-9eed-4262-bb75-204154998761" ); // AU
            YearlyRenewalOfferGUID.Add( 8,  "372d5a85-d9c1-4380-99c6-8fa04f9b89a6" ); // BE
            YearlyRenewalOfferGUID.Add( 16, "d8d43036-b24a-4cc9-a1f5-ccaf2be2d257" ); // CA
            YearlyRenewalOfferGUID.Add( 18, "be556671-14b7-41b0-a378-ec71ab19f202" ); // CH
            YearlyRenewalOfferGUID.Add( 24, "2dec2aa3-5bd8-4b09-8451-c381b858f708" ); // DE
            YearlyRenewalOfferGUID.Add( 25, "d33ad0a1-00f3-4f7c-a3d0-c3ac3d46fb1e" ); // DK
            YearlyRenewalOfferGUID.Add( 31, "d48e1621-8194-406d-8a73-7d295fdd9bf5" ); // ES
            YearlyRenewalOfferGUID.Add( 32, "7a58cc29-6514-49bd-85e1-60f6655826b1" ); // FI
            YearlyRenewalOfferGUID.Add( 34, "124bce2e-3023-4e8f-bb59-81ec5159e540" ); // FR
            YearlyRenewalOfferGUID.Add( 35, "78869ae3-272d-412a-9e4d-d95234e7db4b" ); // GB
            YearlyRenewalOfferGUID.Add( 39, "1a75a520-1478-4283-b0f0-cfdda3b9851e" ); // HK
            YearlyRenewalOfferGUID.Add( 44, "d0e544bf-9887-4c35-ab7a-c6cd97f8edc9" ); // IE
            YearlyRenewalOfferGUID.Add( 50, "40aeaaef-88eb-4be7-96c0-8dfa8f07c8a0" ); // IT
            YearlyRenewalOfferGUID.Add( 53, "0d2769bc-87f4-452d-ae78-e869d0e5353e" ); // JP
            //Japan monthly renewal, for convenience
            // YearlyRenewalOfferGUID.Add( 53,  "a308b3f3-9363-4aad-9b84-cce6a830a10d" ); // JP

            //Korea is technically a "no-offer" renewal
            // YearlyRenewalOfferGUID.Add( 56,  "00000000-0000-0000-0000-000000000000" ); // KR
            YearlyRenewalOfferGUID.Add( 56, "76ef5d0c-25e6-4818-b25d-e2fbcd835c4b" ); // KR

            YearlyRenewalOfferGUID.Add( 71, "3c2a0496-aa0f-4f52-8894-f1297b40ed16" ); // MX
            YearlyRenewalOfferGUID.Add( 74, "ce1b60d7-e4eb-4602-93b5-c76ce919a1ff" ); // NL
            YearlyRenewalOfferGUID.Add( 75, "f271e08f-9770-4e5b-80b6-bdcbaaef2daa" ); // NO
            YearlyRenewalOfferGUID.Add( 76, "daa4917c-57c5-4663-b73e-b2d938c1b28d" ); // NZ
            YearlyRenewalOfferGUID.Add( 90, "ee370c59-6961-4382-a812-ff1e6f0b7cb9" ); // SE
            YearlyRenewalOfferGUID.Add( 91, "756593a9-ea20-4c49-b41a-aff91f6eb604" ); // SG
            YearlyRenewalOfferGUID.Add( 101, "5ba3c903-8ea0-4283-be95-6cd2d89e95a3" ); // TW
            YearlyRenewalOfferGUID.Add( 103, "ac47cd5a-99b5-4c0d-aa58-1e80e59be88c" ); // US

            // MONTHLY
            MonthlyRenewalOfferGUID.Add( 5,     "4ce5e6cd-3636-4edd-af32-7ca0030a8790" );
            MonthlyRenewalOfferGUID.Add( 6,     "4ca6d9f9-e007-48fe-aada-af906eddba17" );
            MonthlyRenewalOfferGUID.Add( 8,     "811313be-631e-4d65-b30f-bf8845b5fae3" );
            MonthlyRenewalOfferGUID.Add( 16,    "b6739e63-f17d-4af6-969b-3f0ee5f7bba4" );
            MonthlyRenewalOfferGUID.Add( 18,    "afce6fc3-43f1-440f-a59b-79b82e7af8e6" );
            MonthlyRenewalOfferGUID.Add( 24,    "b6ad6df0-56e9-4cc8-ad91-9e0cbadf9618" );
            MonthlyRenewalOfferGUID.Add( 25,    "418f78dc-918f-4749-aeb7-fe0cbb80126b" );
            MonthlyRenewalOfferGUID.Add( 31,    "8153ea6f-6a0d-4ca4-8085-e43ede4b5a8d" );
            MonthlyRenewalOfferGUID.Add( 32,    "e760868b-67c2-4b5e-815d-d0ab74829746" );
            MonthlyRenewalOfferGUID.Add( 34,    "8cb8c832-4089-4586-9405-b2186fba80f3" );
            MonthlyRenewalOfferGUID.Add( 35,    "072f986a-b233-43e4-94e0-d40092923373" );
            MonthlyRenewalOfferGUID.Add( 39,    "88d2f872-d0cf-4298-8eb6-2ba43beea9b8" );
            MonthlyRenewalOfferGUID.Add( 44,    "efa037a8-004d-4d73-b26c-6dc0a9c34d43" );
            MonthlyRenewalOfferGUID.Add( 50,    "1990a4f5-510f-4350-9ccd-b2bac3c43a38" );
            MonthlyRenewalOfferGUID.Add( 53,    "a308b3f3-9363-4aad-9b84-cce6a830a10d" );
            MonthlyRenewalOfferGUID.Add( 71,    "d90c4e2c-66b3-4032-aa48-76f8c6bda762" );
            MonthlyRenewalOfferGUID.Add( 74,    "5a77412a-06e7-413c-aa3a-ddf726c293fa" );
            MonthlyRenewalOfferGUID.Add( 75,    "096339fa-5898-487a-a4e5-2a197a5732e6" );
            MonthlyRenewalOfferGUID.Add( 76,    "92c9708f-d1d2-4c50-b3d8-2d96915f8cd9" );
            MonthlyRenewalOfferGUID.Add( 90,    "11016b6a-1085-43ad-bc76-c0b15b1a8ebe" );
            MonthlyRenewalOfferGUID.Add( 91,    "4dec59f9-09e7-45e7-a7fc-0215d0bdec3a" );
            MonthlyRenewalOfferGUID.Add( 101,   "9e0f68ef-b765-4bf7-9710-a75b05887515" );
            MonthlyRenewalOfferGUID.Add( 103,   "38352eb2-c6cf-4a1e-b1e5-6176973d66a9" );

        }


        #endregion

        #region Operators

        //task: improve formatting of the XML...
        public override string ToString()
        {

            return this.RawXML;
        }

        #endregion

        #region Public Instance Methods


        /// <summary>
        /// This is where we instantiate all the infrastructure to talk to SPS and test it.
        /// </summary>
        /// <returns></returns>
        public bool TestSPSConnection()
        {

            // no need to call .Init
            BillingProvider bp = new BillingProvider();
            //Console.WriteLine("\n Just before TestSPSConnection - user: " + BillingProvider.Username + " pswd " + BillingProvider.Password );

            Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_LOW, "UserBillingInfo: Calling Test SPS Connection. " );

            //let the exception bubble up..
            string response;
            bp.TestConnection( SPS_TEST_STRING, out response );
            //Console.WriteLine( "Test is: " + SPS_TEST_STRING + ", Response was: ||" + response + "||" );
            if ( response.IndexOf( SPS_TEST_STRING, 0, response.Length ) > 0 )
            {
                // all is good
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_LOW, "UserBillingInfo: Calling Test SPS Connection SUCCEED. " );
                return true;
            }
            else
            {
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_LOW, "UserBillingInfo: Calling Test SPS Connection FAILED to return test string. " );
                return false;
            }

        } // TestSPSConnection


        // fill in subscription information
        /// <summary>
        /// Loads user billing information from our billing provider (using their Billing Development Kit).
        /// </summary>
        /// <param name="PUID">Unique Live user identifier.</param>
        /// <param name="subscriptionID">Billing provider's subscription identifier.</param>
        public bool LoadBilling( User2 user )
        {

            bool loadSuccess = false;

            // no need to call .Init
            BillingProvider bp = new BillingProvider();

            uint puidHigh, csrHigh = 1;
            uint puidLow, csrLow = 1;
            string errorXML = "";
            string subscriptionXML = "";
            int subscriptionCount = 0;
            this.ownerPUID = user.OwnerPuid;

            Xom.Trace(XomAreaName.toolspslog, LogLevel.L_LOW, "UserBillingInfo.LoadBilling -> Calling SPS GetSubscriptions: puid " + user.Puid.ToString() + ", accountID " + user.AccountID);

            Int64Convert.ToUintPair( ( long ) user.Puid, out puidHigh, out puidLow);

            //task: delete if low/high info not needed.
//            StringBuilder logParams = new StringBuilder();
//            logParams.Append( "UserBillingInfo.Load: \n" );
//            logParams.Append( "  AccountID: " + user.AccountID );
//            logParams.Append( "  puidHi: " + puidHigh.ToString() + "  puidLow: " + puidLow.ToString() );
//            logParams.Append( "  CsrIDHigh: " + csrHigh.ToString() + " CsrIDLow" + csrLow.ToString() );

            try
            {
                //technically, we should have a CSR delegate ID for this, but
                //since SPS doesn't check (as long as it's 1,1), we can get away with this
                bp.GetSubscriptions(
                    (int) csrHigh,                          // int lDelegatePUIDHigh, DELEGATE = CSR or other person processing a request on behalf of a customer
                    (int) csrLow,                           // int lDelegatePUIDLow,
                    (int) puidHigh,                         // int lRequesterPUIDHigh, REQUESTOR = the person who owns this account
                    (int) puidLow,                          // int lRequesterPUIDLow
                    user.AccountID,                         // Instance of an offering purchased by a customer
                    out errorXML,
                    out subscriptionCount,
                    out subscriptionXML
                    );

                //task: remove debug code --> if hr ==  ??
//                Console.WriteLine( "ErrorXML: " + errorXML );
                loadSuccess = true;
                this.spsXML = subscriptionXML;

                // StringReaders allow us to provide a stream to XmlTextReader
                XmlTextReader xmlReader = new XmlTextReader( new StringReader( subscriptionXML ) );
                XmlSerializer serializer = new XmlSerializer( typeof( SubscriptionInfoSet ) );
                this.Subscriptions = ( SubscriptionInfoSet ) serializer.Deserialize( xmlReader );
                this.spsDataLoaded = true;
                xmlReader.Close();
            }

            //task: parse any soapexceptions - if it's "no user" throw UBINotFoundException, else rethrow
            catch (SoapException se)
            {
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "SoapException: " + se.ToString());
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - LoadBilling. SoapException: " + se.Detail.OuterXml + " User: " + user.OwnerPuid );
                throw se;
            }
            return loadSuccess;
        }


        /// <summary>
        /// Will return the index into the Items array within Subscriptions for the
        /// subscription which grants the user access to the Base Service.
        /// If the return value is -1, then the base subscription was not found for this user.
        /// </summary>
        /// <returns></returns>
        public int GetBaseSubscriptionIndex()
        {
            int index = -1;
            SubscriptionInfoSetSubscriptionInfo sub;

            //loop through all the users subscriptions looking at the enabled ones...
            for ( int iLoop = 0; iLoop < this.Subscriptions.Items.Length ; iLoop++ )
            {

                sub = this.Subscriptions.Items[ iLoop ];
                if ( sub.SubscriptionStatusInfo.SubscriptionStatus == BillingConstants.SubscriptionInfoEnabledString )
                {

                    //loop through all services for this subscription to see if one of them is the Base Subscription
                    // the "base subscription" is a subscription which is enabled and contains the "Base Service Offering"
                    // the Base Service Offering = "You Get Into Xbox Live"
                    // vs other subscriptions like a PSO Service Offer which means "You get into PSO"
                    for ( int iLoop2 = 0; iLoop2 < sub.ServiceInstanceSet.Length; iLoop2++ )
                    {

                        if ( sub.ServiceInstanceSet[ iLoop2 ].ServiceComponentId == BillingConstants.BaseServiceOfferingGUID )
                        {

                            //remember the base subscription
                            if ( index == -1 )
                            {
                                index = iLoop;
                            }
                            else
                            {
                                // PM assures me we should never see a user with multiple subscriptions with the Base service...
                                // the Exception below guarantees we'll catch the > 1 case, the exception at bottom catches the < 1 case
                                // this catches the case where there's a second Sub to the base service
                                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - GetBaseSubscription: User " + this.ownerPUID.ToString() + " has more than 1 base subscription.\n" + this.RawXML );
                                throw new Exception( "User :" + this.ownerPUID.ToString() + " has more than 1 Base subscription.  See log for details." );
                            }

                        } // if base service

                    }//for serviceinstances

                } //if enabled

            } // for subscriptions

            // if we're here and haven't found an enabled subscription with the base service... there's an issue
            if ( index == -1 )
            {
                // this catches the case where there's a second Sub to the base service
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - GetBaseSubscription: User " + this.ownerPUID.ToString() + " has no base subscription.\n" + this.RawXML );
                throw new Exception( "User no Base subscription. See log for details." );
            }

            this.baseSubscriptionIndex = index;
            return index;
        }


        /// <summary>
        /// NOTE: Deactivates the User account in SPS. To manage the user's account in UODB, use the User or User2 object...
        /// subIndex is the index of the subscription in the UserBillingInfo object which should be cancelled.
        /// </summary>
        /// <param name="subIndex">The index of the subscription in the UserBillingInfo object which should be cancelled.</param>
        /// <param name="commentText">The comment which should be added to the account to give the reason for the cancellation.</param>
        public void CancelSubcription( int subIndex, string commentText )
        {

            //guard clause
            if ( !spsDataLoaded )
            {
                throw new Exception("No operations on this object are allowed till Load is called successfully.");
            }
            if (
                ( subIndex > this.Subscriptions.Items.Length ) ||
                ( subIndex < 0 )
                )
            {
                throw new ArgumentException( "Invalid argument: the value for subIndex was invalid." );
            }

            string errorXML = "", amountCharged = "", rawSubscriptionStatusInfo = "", rawRemovedServiceInstanceSet = "";
            int removedServiceInstanceCount = 0;

            // no need to call Init, since the (int) override calls it correctly
            BillingProvider bp = new BillingProvider();
            PsoEncrypterClass encrypter = new PsoEncrypterClass();

            // the trackingGUID allows us to get the status of our request later...
            string trackingGUID = encrypter.GenerateGUID();
            this.lastTrackingGUID = trackingGUID;

            //NOTE: DO NOT set values for commenter or comment date,
            //      as these cause the call to stop working (bug in SPS)
            CommentInfo comment = new CommentInfo();
            comment.CommentCode = System.Convert.ToString( 200705 );    // CC_CONVERT_SUBSCRIPTION
            comment.CommentText = commentText;
            string commentXmlString = comment.ToXml();

            uint puidHigh, csrHigh = 1;
            uint puidLow, csrLow = 1;
            bool computeOnly = false;
            string nowString = "NOW";
            Int64Convert.ToUintPair( ( long ) this.ownerPUID, out puidHigh, out puidLow);

            StringBuilder logParams = new StringBuilder();
            logParams.Append( "\n UserBillingInfo.Deactivate: CancelSub - TrackGUID: " + trackingGUID );
            logParams.Append( "  SubID: " + this.Subscriptions.Items[ subIndex ].SubscriptionId );
            logParams.Append( "  puidHi: " + puidHigh.ToString() + "  puidLow: " + puidLow.ToString() );
            logParams.Append( "  CsrIDHi: " + csrHigh.ToString() + "  CsrIDLow: " + csrLow.ToString() );
            logParams.Append( "  Cmnt: " + commentXmlString + "  CancelDate: NOW \n");

            // Console.WriteLine( "Inside: Cancel - " + logParams.ToString() );

            Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_LOW, "UserBillingInfo - CancelSubscription. User: " + this.Subscriptions.Items[ subIndex ].FriendlyName + "  Subindex: " + subIndex.ToString() );
            Xom.Trace(XomAreaName.toolspslog, LogLevel.L_LOW, logParams.ToString());

            // Console.WriteLine( "\n past logging\n" );
            try
            {

                bp.CancelSubscription(
                    1,
                    1,
                    (int) puidHigh,
                    (int) puidLow,
                    trackingGUID,
                    computeOnly,
                    this.Subscriptions.Items[ subIndex ].SubscriptionId,
                    nowString,
                    commentXmlString,
                    out errorXML,
                    out amountCharged,
                    out rawSubscriptionStatusInfo,
                    out removedServiceInstanceCount,
                    out rawRemovedServiceInstanceSet
                    );

            }
            catch (SoapException se)
            {
                //task: log for pss, rethrow
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - CancelSubscription. SoapException: " + se.Detail.OuterXml + " User: " + this.Subscriptions.Items[0].FriendlyName + "  Subindex: " + subIndex.ToString() );
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "SoapException: " + se.ToString());
                // Console.WriteLine( "There was a SOAP exception: " + se.ToString()  );
                throw se;
            }

            //task: and then what? do I deserialize the new subscription status info?
        } // deactivate


        /// <summary>
        /// Basically a call to PurchaseOfferingEx. Maybe the code should call this directly?
        /// The only thing this encapsulates is the CSR Delegate ID values being 1,1.
        /// Return value is the SubscriptionID of the new subscription, if successful, if failed, then "".
        /// </summary>
        public string PurchaseSubscription( User2 u, string offeringGUID, string paymentInstrumentID, string shippingAddressID )
        {

            if ( !spsDataLoaded )
            {
                throw new Exception("No operations on this object are allowed till Load is called successfully.");
            }

            // no need to call Init, since the (int) override calls it correctly
            BillingProvider bp = new BillingProvider();

            // the trackingGUID allows us to get the status of our request later...
            PsoEncrypterClass encrypter = new PsoEncrypterClass();
            string trackingGUID = encrypter.GenerateGUID();
            this.lastTrackingGUID = trackingGUID;

            string resultXML = "", newSubscriptionID = "", amountChargedXML = "", addedServiceInstanceSet = "";
            int addedServiceInstances = 0;
            uint puidHigh, csrHigh = 1;
            uint puidLow, csrLow = 1;
            bool computeOnly = false;
            Int64Convert.ToUintPair( ( long ) u.Puid, out puidHigh, out puidLow);

            //no need to validate the offerGuid, since SPS will do this anyway
            try
            {
                bp.PurchaseOfferingEx(
                    (int) csrHigh,
                    (int) csrLow,
                    (int) puidHigh,
                    (int) puidLow,
                    trackingGUID,
                    computeOnly,
                    u.GamerTag,                 // SubscriptionId = friendly name = gamertag... go figure
                    u.AccountID,                // accountID
                    "",                         // baseSubscriptionID
                    offeringGUID,
                    0,                          // override amount
                    paymentInstrumentID,
                    shippingAddressID,
                    "",                         // SPS reserved - activation date
                    "",                         // SPS reserved - subscription end date
                    "",                         // referral set xml
                    "",                         // tokenID
                    "",                         // policy ID (used to purchase stuff)
                    0,                          // policy version
                    "",                         // signature date time
                    out resultXML,
                    out newSubscriptionID,
                    out amountChargedXML ,
                    out addedServiceInstances,
                    out addedServiceInstanceSet
                    );

            }
            catch (SoapException se)
            {
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - PurchaseSub. SoapException: " + se.Detail.OuterXml + " User: " + u.OwnerPuid + "  Offering: " + offeringGUID );
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "SoapException: " + se.ToString());
                Console.WriteLine( "There was a SOAP exception: " + se.ToString()  );
                throw se;
            }

            return newSubscriptionID;

        } // purchase offering


        /// <summary>
        /// Used to set the renewalOfferGUID.  This is the offer the user will renew into after their current offer's subscription reaches it's end date.
        /// It is the caller's responsibility to call AddComment and, if necessary Provision services.
        /// </summary>
        /// <param name="renewalOfferingGUID">The intended renewalOffering to change the subscription to reflect.</param>
        /// <param name="subIndex">The index of the subscription to change.</param>
        public void ConvertSubscriptionRenewal( string renewalOfferingGUID, int subIndex )
        {
            // guard clause
            if ( !spsDataLoaded )
            {
                throw new Exception("Operation is invalid till Load is successful.");
            }

            string errorXML, amountChargedXML, rawAddedServiceInstanceSet;
            string rawRemoveServiceInstanceSet;
            StringBuilder logParams = new StringBuilder();
            int removedServiceInstanceSetCount, addedServiceInstanceSetCount;

            BillingProvider bp = new BillingProvider();
            PsoEncrypterClass encrypter = new PsoEncrypterClass();
            string trackingGUID = encrypter.GenerateGUID();
            this.lastTrackingGUID = trackingGUID;

            uint puidHigh;
            uint puidLow;
            Int64Convert.ToUintPair( ( long ) this.ownerPUID, out puidHigh, out puidLow );

            logParams.Append( "UserBillingInfo.ConvertSubscriptionRenewal: ConvertSub - trackGUID: " + trackingGUID );
            logParams.Append( " FrName: " + this.Subscriptions.Items[ subIndex ].FriendlyName );
            logParams.Append( " SubID: " + this.Subscriptions.Items[ subIndex ].SubscriptionId );
            logParams.Append( " puidHi: " + puidHigh.ToString() + "  puidLow: " + puidLow.ToString() );
            logParams.Append( " RenewGUID: " + renewalOfferingGUID );

            Console.WriteLine("Parameters: \n" + logParams.ToString() );

            Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_LOW, "UserBillingInfo - ConvertSubscriptionRenewal. User: " + this.Subscriptions.Items[0].FriendlyName + "  Subindex: " + subIndex.ToString() + " renewInto " + renewalOfferingGUID );
            Xom.Trace(XomAreaName.toolspslog, LogLevel.L_LOW, logParams.ToString());

            try
            {
                bp.ConvertSubscriptionEx(
                    1,
                    1,
                    (int) puidHigh,
                    (int) puidLow,
                    trackingGUID,
                    false,
                    1,
                    0,
                    this.Subscriptions.Items[ subIndex ].FriendlyName,
                    this.Subscriptions.Items[ subIndex ].SubscriptionId,
                    renewalOfferingGUID,
                    0,                              // override - not implemented
                    "",                             // subscription end date - can be empty string
                    "",                             // ReferralSetXML - can be empty string
                    "",                             // paymentinstrumentID -- optional ?
                    "",                             // tokenID
                    "",                             // PolicyID  - can't find info on policy in the SPK
                    0,                              // PolicyVersion
                    "",                             // PolicySignatureDateTime
                    out errorXML,
                    out amountChargedXML,
                    out addedServiceInstanceSetCount,
                    out rawAddedServiceInstanceSet,
                    out removedServiceInstanceSetCount,
                    out rawRemoveServiceInstanceSet
                    );

            }
            catch(SoapException se)
            {
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - ConvertSubscriptionRenewal. SoapException: " + se.Detail.OuterXml + " User: " + this.Subscriptions.Items[0].FriendlyName + "  Subindex: " + subIndex.ToString() + " renewInto " + renewalOfferingGUID );
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "SoapException: " + se.ToString());
                throw se;
            }

        } // SetRenewalOffer



//delete this stuff once we're ready to ship... it's useful for troubleshooting during dev
                // find the error code --> log details for SPS and move on!
//                Console.WriteLine("There was a SOAP error " + se.ToString() );
//                Console.WriteLine("RAW XML\n Client FaultCode: " + SoapException.ClientFaultCode );
//                Console.WriteLine("DetailElementName " + SoapException.DetailElementName );
//                Console.WriteLine("MustUnderstandFaultCode " + SoapException.MustUnderstandFaultCode );
//                Console.WriteLine("ServerFaultCode " + SoapException.ServerFaultCode );
//                Console.WriteLine("VersionMismatchFaultCode " + SoapException.VersionMismatchFaultCode );
//                Console.WriteLine("Actor " + se.Actor );
//                Console.WriteLine("Code " + se.Code );
//                Console.WriteLine("Detail " + se.Detail.OuterXml );
//                Console.WriteLine("Message " + se.Message );
//                Console.WriteLine("Source " + se.Source );
//                Console.WriteLine("StackTrace " + se.StackTrace );
//                Console.WriteLine("TargetSite " + se.TargetSite );


        #endregion

        #region Public Static Methods

        //task: Methods in this region should really live in their own classes, they're just here for convenience

        /// <summary>
        /// Set the renewalOfferGUID
        /// </summary>
        public static string AddComment( string accountID, CommentInfo comment )
        {
            string errorXML = "";

            BillingProvider bp = new BillingProvider();

            Xom.Trace(XomAreaName.toolspslog, LogLevel.L_LOW, "UBI - AddComment " + comment.ToXml() + " for " + accountID);
            try
            {
                bp.AddComment(
                    1,
                    1,
                    accountID,
                    comment.ToXml(),
                    out errorXML
                    );
            }
            catch (SoapException se)
            {
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UBI - AddComment Exception:" + se.ToString() );
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "UBI - AddComment Exception:" + se.ToString());
            }
            return errorXML;
        }



        public static CommentInfoSet GetComments( string accountID )
        {
            string errorXML = "", commentInfoSetXml = "";
            int commentCount;
            CommentInfoSet comments = null;

            BillingProvider bp = new BillingProvider();

            Xom.Trace(XomAreaName.toolspslog, LogLevel.L_LOW, "UBI - GetComments for " + accountID);
            try
            {
                bp.GetComments(
                    1,
                    1,
                    accountID,
                    out errorXML,
                    out commentCount,
                    out commentInfoSetXml
                    );

                XmlSerializer commentSerializer = new XmlSerializer( typeof( CommentInfoSet ) );
                StringReader sr = new StringReader( commentInfoSetXml );
                comments = (CommentInfoSet) commentSerializer.Deserialize( sr );

            }
            catch (SoapException se)
            {
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UBI - GetComments Exception:" + se.ToString() );
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "UBI - GetComments Exception:" + se.ToString());
            }
            return comments;

        }



        /// <summary>
        /// To be used primarily in testing scenarios.
        /// </summary>
        /// <returns></returns>
        public static UserBillingInfo Create()
        {
            UserBillingInfo ubi = new UserBillingInfo();
            ubi.spsDataLoaded = true;
            return ubi;
        }



        #endregion

    }  // UBI class

    public class UserBillingInfoNotFoundException : Exception, ISerializable
    {
        public UserBillingInfoNotFoundException( ) :  base( "Requested user not found." ) { }
        public UserBillingInfoNotFoundException( string gamertag ) :  base( "Requested User " + gamertag + " was not found." ) { }
        public UserBillingInfoNotFoundException( ulong puid ) :  base( "Requested User with puid " + puid.ToString() + " was not found." ) { }
        public UserBillingInfoNotFoundException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }
    }

    public class UserBillingInfoSubscriptionException : Exception, ISerializable
    {
        public UserBillingInfoSubscriptionException( ) :  base( "There was an issue with this user's subscriptions." ) { }
        public UserBillingInfoSubscriptionException( ulong puid, string errorString ) :  base( "User account with puid " + puid.ToString() + " has a subscription issue: " + errorString ) { }
        public UserBillingInfoSubscriptionException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Backup1\OfferValues.cs ===
using System;


namespace xonline.tools.framework
{
	/// <summary>
	/// Summary description for OfferEquivalence.
	/// </summary>
	public class OfferValues
	{

        public const ulong Beta16               = 0xFFFE000080000001;
        public const ulong Beta15               = 0xFFFE000080000002;
        public const ulong Beta14               = 0xFFFE000080000003;
        public const ulong Beta13               = 0xFFFE000080000004;
        public const ulong XboxPromo16Month     = 0xFFFE000080000005;
        public const ulong XboxTest16Month      = 0xFFFE000080000006;
        public const ulong Unknown              = 0xFFFE000080000007;
        public const ulong StarterKit           = 0xFFFE000080000008;
        public const ulong GameTrial            = 0xFFFE000080000009;
        public const ulong ConsoleTrial         = 0xFFFE00008000000A;
        public const ulong MonthlyRenewal       = 0xFFFE00008000000B;
        public const ulong AnnualRenewal        = 0xFFFE00008000000C;
        public const ulong PrePaidYear          = 0xFFFE00008000000D;
        public const ulong PrePaid3Month        = 0xFFFE00008000000E;

//        public enum OfferValues 
//        {
//            Beta16,                  // 1  from beta offers used pre-launch
//            Beta15,                  // 2  from beta offers used pre-launch
//            Beta14,                  // 3  from beta offers used pre-launch
//            Beta13,                  // 4  from beta offers used pre-launch
//            XboxPromo16Month,        // 5
//            XboxTest16Month,         // 6
//            Unknown,                 // 7
//            StarterKit,              // 8  starter kit / 12 month Online Subscription
//            GameTrial,               // 9  2 month free trial which comes with Games
//            ConsoleTrial,            // A  2 month free trial which comes with Consoles
//            MonthlyRenewal,          // B  monthly renewal
//            AnnualRenewal,           // C  annual renewal
//            PrePaidYear,             // D  prepaid year card
//            PrePaid3Month            // E  three month prepaid card
//        }

//        //taken directly from JerryHook's spreadsheet
//        // removed the FFFE0000 high bits, since they don't appear to be 
//        // used in UODB
//        public static ulong[] OfferID = new ulong[11] 
//        {   
//            0,          // enums start with 1, so we'll leave this one blank...                          
//            0x80000001,	// Subscription  Xbox Beta 16 mths
//            0x80000002,	// Subscription  Xbox Beta 15 mths
//            0x80000003,	// Subscription  Xbox Beta 14 mths
//            0x80000004,	// Subscription  Xbox Beta 13 mths
//            0x80000005,	// Subscription  Xbox Promotional 16 mths
//            0x80000006,	// Subscription  Xbox Prod Test Subscription 16 mths
//            0x80000007,	// ??? 
//            0x80000008,	// Subscription  Xbox Live 12 Month Online Subscription (Starter Kit)
//            0x80000009,	// Subscription  Game Trial
//            0x8000000A,	// Subscription  Console Trial
//            0x8000000B,	// Renewal       Monthly Renewal
//            0x8000000C,	// Renewal       Yearly Renew
//            0x8000000D,	// Renewal       Yearly Prepaid
//            0x8000000E	// Renewal       3 Month Prepaid
//        };


        //task: this still doesn't seem elegant, redesign this later... 
        public static bool IsOfferPairEquivalent( ulong A, ulong B )
        {
            bool response = false;

            switch ( A )
            {
                    //we really shouldn't see these cases in production
                    //so throwing an exception is reasonable here...
                    //task: throw exception?
                case Beta16:            // 0x80000001
                case Beta15:            // 0x80000002
                case Beta14:            // 0x80000003
                case Beta13:            // 0x80000004
                    response = (
                        ( B == Beta16 ) ||
                        ( B == Beta15 ) ||
                        ( B == Beta14 ) ||
                        ( B == Beta13 ) 
                        );
                    break;

                case XboxPromo16Month:  // 0x80000005
                    response = ( B == XboxPromo16Month );
                    break;

                case XboxTest16Month:   // 0x80000006
                    response = ( B == XboxTest16Month );
                    break;

                case Unknown:           // 0x80000007
                    response = ( B == Unknown );
                    break;

                case StarterKit:     // 0x80000008
                    response = (
                                ( B == PrePaidYear ) ||
                                ( B == StarterKit )
                                );
                    break;

                case GameTrial:      // 0x80000009
                case ConsoleTrial:   // 0x8000000A
                    response = ( ( B == GameTrial ) ||
                                 ( B == ConsoleTrial )
                               );
                    break;

                case MonthlyRenewal:  // 0x8000000B
                    response = ( B == MonthlyRenewal );
                    break;

                case AnnualRenewal:   // 0x8000000C
                    response = ( B == AnnualRenewal );
                    break;

                case PrePaidYear:    // 0x8000000D
                    response = (
                                ( B == PrePaidYear ) ||
                                ( B == StarterKit )
                               );
                    break;

                case PrePaid3Month:  // 0x8000000E
                    response = ( B == PrePaid3Month );
                    break;

                default:
                    //task: throw exception 
                    break;

            } // switch

            return response;

        } // is offer pair equiv

	} //OfferEquivalence

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Backup1\SerialNumber.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Runtime.Serialization;

using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.serialnumber)]

namespace xonline.tools.framework
{
    /// <summary>
    /// So why is this a separate class, rather than just a static method somewhere else?
    /// Basically, I'm taking a guess that this will get used elsewhere than just this code,
    /// and if that's the case, it'd be handy to have it separated out, in spite of the overhead
    /// of creating and testing a separate class.
    /// There's no "Insert" method or equivalent here, since these get added to the 
    /// DB via a batch job from a text file. (if you really want one, look at the test code...)
    /// 
    /// Once add the serial number and group id to UODB, this can become part of the Voucher class... 
    /// </summary>
    public class SerialNumber
    {

        #region Properties

        private int groupID;
        public int GroupID
        {
            get
            {
                return groupID;
            }
        }

        //task: probably don't want this... 
//        private string hashString;
//        public string HashString
//        {
//            get
//            {
//                return hashString;
//            }
//        }
        private int serialNum;
        public int SerialNum
        {
            get
            {
                return serialNum;
            }
        }
        private byte[] hashBytes;
        public byte[] HashBytes
        {
            get
            {
                return (byte []) hashBytes.Clone();
            }
        }


        #endregion

		private SerialNumber()
		{

		}

        // requiring a connection string accomodates the need for this code to function
        // in a variety of contexts while balancing the desire to reduce interdependencies between
        // the caller and callee (there might be a transaction open, etc).
        public static SerialNumber Load( int requestedGroupID, int requestedSerialNum, string connection )
        {
            // SqlByte == TinyInt, why isn't there also a TinyInt?
            // SqlByte.MaxValue == 255
            if ( requestedGroupID > ( (int) SqlByte.MaxValue ) )
            {
                throw new ArgumentException("Group ID must be less than " + SqlByte.MaxValue );
            }

            SerialNumber sn = new SerialNumber();

            using (SqlConnection serialConn = new SqlConnection( connection ) )
            {
                serialConn.Open();
                SqlCommand serialCmd = serialConn.CreateCommand();
                serialCmd.CommandType = CommandType.StoredProcedure;
                serialCmd.CommandText = "p_GetHashFromSerial";

                serialCmd.Parameters.Add( "@tiGroupID", SqlDbType.TinyInt ).Value = requestedGroupID;
                serialCmd.Parameters["@tiGroupID"].Direction = ParameterDirection.Input;  
                
                serialCmd.Parameters.Add( "@iSerialNumber", SqlDbType.Int ).Value = requestedSerialNum;
                serialCmd.Parameters["@iSerialNumber"].Direction = ParameterDirection.Input;
                
                serialCmd.Parameters.Add( "@hr", SqlDbType.Int );
                serialCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                SqlDataReader serialReader = serialCmd.ExecuteReader();

                // do we have results?
                if ( serialReader.Read() )
                {
                    sn.groupID = requestedGroupID;
                    sn.serialNum = requestedSerialNum;

                    // takes 2 char to express each byte value (0x00 to 0xFF)
                    //sn.hashBytes = new byte[ Voucher.VoucherHashSize * 2 ];

                    //review: is this returning an arbitrarily big byte array??
                    sn.hashBytes = ( byte[] ) serialReader.GetSqlBinary( 0 );
                    // sn.hashString = (string) serialReader.GetValue( 0 );

                    //review: throw an exception if there are more rows?
                }
                else
                {
                    throw new SerialNumberNotFoundException();
                }
            }
            return sn;
        } // load

	} //class

    public class SerialNumberNotFoundException : Exception, ISerializable
    {
        const string message = "Requested SerialNumber not found in database.";
        public SerialNumberNotFoundException( ) :  base( message ) { }
        public SerialNumberNotFoundException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }
        
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Backup1\CheckReady.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;

using Microsoft.Webstore.WstClient; 

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.tools.console;
using xonline.tools.framework;

//using XBOX.Tools.Framework;
//using XBOX.Utilities;
//using XBOX.Utilities.Console;

[assembly: XomAreaDefinition(XomAreaName.checkready)]

namespace xonline.common.tools
{
	/// <summary>
	/// Hopefully, this will be the last time we write a class to check this sort of stuff... 
	/// </summary>
    public class CheckReady
    {

        // since environment checks are fairly application specific,
        // anyone else who wants to use CheckReady should subclass it
        // and change the implementation of CheckReadyMain
        // Please feel free to add other checks which need to be added
        // added command line output. remove it for server uses.. 
        public static bool CheckReadyMain( NamedArgParser parsedArgs, out string results )
        {

            bool checkResult = true;

            results = "";               //printed at the end for summary of all tests
            string testResult = "";     //printed as the cumulative details of each test

            Console.WriteLine( "\nChecking if tool can read input file: " + parsedArgs[ "inputfile" ] );
            // confirm input file can be read from
            if ( ( parsedArgs[ "inputfile" ] != null ) && CheckReadFile( parsedArgs[ "inputfile" ] ) )
            {
                // everything's working!
                results += "\r\n    Tool is able to find and read the input file.";
            }
            else
            {
                // houston, we have a problem
                checkResult = false;
                // write error to result string
                results += "\r\n!!  Tool is not able to find read the input file!";
            }

            // confirm sps
            // SPS Test Connection
            Console.WriteLine( "Checking SPS Connectivity....." );
            if ( CheckSPS() )
            {
                // everything's working!
                results += "\r\n    Tool is able to connect to SPS.";
            }
            else
            {
                // houston, we have a problem... 
                results += "\r\n!!  Tool is not able to connect to SPS!";
                checkResult = false;
            }
            
            // confirm uodb
            Console.WriteLine( "Checking connectivity to Webstore UODB ....." );
            if ( CheckWebstore( ConfigUtil.UodbWebstoreApp ) )
            {
                // everything's working!
                results += "\r\n    Tool is able to connect to UODB.";
            }
            else
            {
                // houston, we have a problem... 
                results += "\r\n!!  Tool is not able to connect to UODB!";
                checkResult = false;
            }

            string connectionString = "Data Source=" +  parsedArgs[ "serialsql" ] + ";Trusted_Connection=Yes;Initial Catalog=" + parsedArgs[ "serialdb" ];
            // confirm SerialDB
            Console.WriteLine( "Checking connectivity to SerialDB ....." );
            if ( CheckDB( connectionString, ref testResult ) )
            {
                // everything's working!
                results += "\r\n    Tool is able to connect to SerialDB!";
            }
            else
            {
                // houston, we have a problem... 
                results += "\r\n!!  Tool is not able to connect to SerialDB!";
                checkResult = false;
            }
            results += testResult;

            return checkResult;

        }

	//
        public static bool ParamCheck( NamedArgParser args, string argName, bool console)
        {
            //if arg doesn't exist, return false
            if ( args[ argName ] == null )
            {
		        if ( console )
                {
                    Console.WriteLine( "==> {0} Parameter must be supplied.", argName );
                }

                Xom.Trace(XomAreaName.checkready, LogLevel.L_WARNING, "Parameter " + argName + " was null." );

                return false;
            }
            else
            {
                return true;
            }
        }

        //task: should change this to write to Auditdb, or log, or have OUT string param, not REF 
        public static bool CheckDB( string connection, ref string dbResults )
        {

            bool check = false; 

            try  
            {
                using (SqlConnection checkConn = new SqlConnection( connection ) )
                {
                    //results = "Open connection to " + connection + "\r\n";
                    checkConn.Open();
                    //results += "Connection opened\r\n";
                    SqlCommand checkCmd = checkConn.CreateCommand();
                    checkCmd.CommandType = CommandType.Text;
                    checkCmd.CommandText = "select top 1 * from sysobjects";

                    //results += "Executing command \r\n";
                    SqlDataReader checkReader = checkCmd.ExecuteReader();

                    // do we have results?
                    if ( checkReader.Read() )
                    {
                        dbResults += "Connection Successful.\r\n";
                        check = true;
                    }
                    else
                    {
                        dbResults += "Error: Returning results from connection failed.\r\n";
                        check = false;
                    }
                } //using

            } // try
            catch (Exception e)
            {   
                dbResults += "\nError: Exception occurred: \n" + e.ToString();         
                check = false;
            }

            return check;
        }


        public static bool CheckWriteFile( string filePath )
        {
            bool result = false;

            try
            {
                //Console.WriteLine("Creating log file " + logfilepath + " ...");
                // Can we write to the output file location?
                StreamWriter textFile = new StreamWriter( filePath, true, System.Text.Encoding.UTF8);
                textFile.AutoFlush = true;
                
                // write to file, just a space
                //task: is this necessary? will creating the streamwriter create the file?
                textFile.Write(" ");

                // flush
                textFile.Flush();
                textFile.Close();

                // check file existence
                if ( File.Exists( filePath ) )
                {
                    result = true;
                }

            } // try

            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.checkready, LogLevel.L_NORMAL, "An error occurred writing to the file: \r\n" + filePath + e.Message + "\r\n\r\n" + e.StackTrace  );
                result = false;
            }
            
            return result;
        } // checkwritefile

        public static bool CheckReadFile( string filePath )
        {
            
            bool result = false;

            // Can we read from file location?
            try
            {
                StreamReader textFile = new StreamReader( filePath, System.Text.Encoding.UTF8 );

                // check file existence
                if ( System.IO.File.Exists( filePath ) )
                {
                    // test read
                    int nextChar = textFile.Peek();
                    if ( nextChar == -1 )
                    {
                        // end of file
                    }
                    result = true;
                    textFile.Close();
                }

            } // try

            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.checkready, LogLevel.L_NORMAL, "An error occurred reading from the file: \r\n" + filePath + e.Message + "\r\n\r\n" + e.StackTrace  );
                result = false;
            }
            
            return result;

        } // checkwritefile

        public static bool CheckSPS( )
        {

            try
            {
                // figure out what this should be
                UserBillingInfo ubi = new UserBillingInfo();
                return ( ubi.TestSPSConnection() );
            }
            catch (Exception e)
            {
                //task: take some action here
                Console.WriteLine( "\nAn error occurred connecting to SPS." );
                Console.WriteLine( "Error was " + e.ToString() );
                return false;
            }
        }

        public static bool CheckWebstore( string webstoreApplication )
        {

            bool check = false;

            try
            {
                using (WstConnection checkConn = new WstConnection( webstoreApplication ) )
                {
                
                    checkConn.Open();
                    WstCommand checkCmd = checkConn.CreateCommand();
                    checkCmd.CommandType = CommandType.Text;

                    checkCmd.Partition = WstCommand.AnyPartition;
                
                    checkCmd.CommandText = "select top 1 * from sysobjects";

                    WstDataReader wr = checkCmd.ExecuteReader();

                    // Load voucheroffers info 
                    if ( wr.Read() )
                    {
                        check = true;
                    }
                    else
                    {
                        check = false;
                    }

                } // using

            } // try
            catch (Exception e)
            {
                //task: take some action here
                Console.WriteLine( "\nAn error occurred connecting to " + webstoreApplication );
                Console.WriteLine( "Error was " + e.ToString() );
                check = false;
            }

            return check;
        }

        //check whether the root exists and can be written to / read from
        public static bool CheckTitleVault( )
        {
            bool check = true;

            try
            {
                //get config
                string vaultPath = Config.GetSetting( Setting.titlevault_root );

                //confirm titevault_root setting is not INVALID  value != "INVALID" 
                if ( vaultPath.IndexOf( "INVALID" ) >= 0 )
                {
                    return false;
                }

                //check
                check = Directory.Exists( vaultPath );
                
                string testPath = vaultPath + "\\" + "Checkready_" + Environment.MachineName + ".txt";
                
                if ( File.Exists( testPath ) )
                {
                    File.Delete( testPath );
                }

                if ( CheckWriteFile( testPath ) )
                {
                    if ( CheckReadFile( testPath ) )
                    {
                        File.Delete( testPath );
                    }
                    else
                    {
                        check = false;
                    }
                }
                else
                {
                    check = false;
                }
           
            }
            catch
            {
                check = false;
            }
            
            return check;

        }

    } // class checkready


    //task: should have named exceptions to check for here
    //dbnotavailable exception
    //readfilenotavailable exception
    //writefilenotavailable exception
    //spsnotavailabble exception


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Voucher.cs ===
using Microsoft.Webstore.WstClient;
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.sql.webstore;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.voucher)]

namespace xonline.tools.framework
{

    /// <summary>
    /// Voucher a very simple object-oriented layer over the Voucher-related UODB procedures.
    /// This class should be used to work with a single voucher at a time.
    /// This does not use or inherit from CVoucher, since that class is sealed,
    /// and doesn't use WS3.0 managed client directly.  Using it would make WSREADERLib
    /// a requirement for this tool.
    /// I did, however, make extensive use of the already-written code.
    ///
    /// NOTE: currently, in UODB, there are Vouchers associated with multiple offers.
    /// This was done during the beta so that the same subscription codes could support
    /// either the 15-month, 14-month (etc) time spans, depending on when you joined the beta.
    /// The idea was for them all to expire on the same month (1 year from 11/15/2002)
    /// even though folks might start at different times.  Offers were set up with the appropriate
    /// dates so that the appropriate offer would be used during each month.
    /// This should NOT be the case going forward, as most Vouchers will only be associated
    /// with one offerid.
    ///
    /// Glossary note:
    /// SHA1Hash( SubscriptionCode ) = hash = voucher
    ///

    /// </summary>
    public class Voucher
    {

        #region Private / Protected variables

        protected byte[]    hashBytes;
        protected int       voLoadCount;                // number of vos loaded - to make sure nobody deletes a VO until that's supported
        protected int       vuLoadCount;                // number of vus loaded - to make sure nobody deletes a VU until that's supported

        public ArrayList    VoucherOffers;
        public ArrayList    VoucherUsage;

        #endregion

        #region Constructors

        // create a new voucher

        /// <summary>
        /// Create a new Voucher object from a Subscription Code
        /// </summary>
        /// <param name="SubCode"></param>
        private Voucher( string SubCode )
        {
            this.hashBytes = VoucherUtil2.SubcodeStringToHashByte( SubCode );
        }

        /// <summary>
        /// Create a new Voucher from a byte array representing the hash of the Subscription code.
        /// </summary>
        /// <param name="hash"></param>
        private Voucher( byte[] hash )
        {

            if ( hash.Length == VoucherHashSize )
            {
                hashBytes = new byte[VoucherHashSize];
                hash.CopyTo( hashBytes, 0 );
            }
            else
                throw new ArgumentException("Byte[] passed in is not of size {0}.", System.Convert.ToString(VoucherHashSize) );
        }

        #endregion

        #region Properties

        /// <summary>
        /// Get a copy of the internal byte array. NOT a reference.
        /// </summary>
        public byte[] voucherhash
        {
            //review: do I need a separate private variable?
            get
            {
                //review: use the clone method here?
                byte [] hb = new byte[ VoucherHashSize ];
                hashBytes.CopyTo( hb, 0 );
                return hb;
            }
        }

        #endregion

        #region Operators

        // yeah, this is a bit much for dev purposes, but
        // it will make my unit test code much simpler... :-)
        public static bool operator == (Voucher a, Voucher b)
        {

            Console.WriteLine("Voucher a - l={0}, hash: {1}, voC: {2}, vuC: {3}", a.hashBytes.Length, VoucherUtil2.HashByteToHexStr( a.hashBytes ), a.VoucherOffers.Count, a.VoucherUsage.Count );
            Console.WriteLine("Voucher b - l={0}, hash: {1}, voC: {2}, vuC: {3}", b.hashBytes.Length, VoucherUtil2.HashByteToHexStr( b.hashBytes ), b.VoucherOffers.Count, b.VoucherUsage.Count );

            //short cut the process if possible...
            if (
                ( a.hashBytes.Length != b.hashBytes.Length ) ||
                ( a.VoucherOffers.Count != b.VoucherOffers.Count ) ||
                ( a.VoucherUsage.Count != b.VoucherUsage.Count )
                )
            {
                return false;
            }

            // compare the hash
            //task: is the fastest way to do this?  couldn't I compare the number they mean??
            //USE: VoucherUtil2.HashByteToHexStr
            int i;
            for (i=0; ( i < a.hashBytes.Length ) ; i++)
            {
                if ( a.hashBytes[ i ] != b.hashBytes[ i ] )

                {
                    return false;
                }
            }

            // if we checked to the end, then they were equal, otherwise we just got to the end of one array... ;-)
            if ( ! ( i == a.hashBytes.Length ) )
            {
                return false;
            }

            // compare the offers associated with the Voucher
            // since these should only have 1 offer... I can cheat for now
            // and just use the clause of the if above
            //task: come back and make this right...
            //task: check all offers and uses for equality ( now that I have == for VO and VU )
            //--> but I need some way to sort them first...
            // ArrayList.Sort --> how does it work.

            // check how many before you attempt to access one!!
            if ( ( a.VoucherOffers.Count != 0 ) && ( b.VoucherOffers.Count != 0 ) )
            {
                if ( ( (VoucherOffer) a.VoucherOffers[0] ).offerID !=
                    ( (VoucherOffer) b.VoucherOffers[0] ).offerID )
                {
                    return false;
                }
            }

            //task: compare the uses of these Vouchers in == operator
            // same cheat here as in above comment... ;-)
            if ( ( a.VoucherUsage.Count != 0 ) && ( b.VoucherUsage.Count != 0 ) )
            {
                if ( ( (VoucherUse) a.VoucherUsage[0] ).puid !=
                     ( (VoucherUse) b.VoucherUsage[0] ).puid )
                {
                    return false;
                }
            }

            // if we get this far, then they must be equal
            return true;

        }

        // Evidently, if you override the ==, you have override !=
        public static bool operator != (Voucher a, Voucher b)
        {
            return !(a == b);
        }

        public override bool Equals( object b )
        {
            if ( b is Voucher )
                return ( this == ( Voucher ) b );
            else
                return false;
        }

        // and... as it turns out, you also have to override the
        // GetHashCode method.  This way a HashTable can be used to store your class.
        // Basically, you need to be able to determine whether two things are equal,
        // and evidently they do this partially via a hash. :-\
        /// <summary>
        /// Returns a value for use by the HashTable class.
        /// </summary>
        public override int GetHashCode()
        {
            //task: this will need to incorporate the VO and VU lists somehow, but that's future
            return  this.hashBytes.GetHashCode();
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder( 50 );

            sb.Append( "Hash: " + VoucherUtil2.HashByteToHexStr( this.hashBytes ) );
            sb.Append( " \n VoucherOffers: \n" );

            foreach ( VoucherOffer vo in this.VoucherOffers )
            {
                sb.Append( ( (VoucherOffer) vo).ToString() + "\n");
            }
            sb.Append( "\n VoucherUsage: \n" );
            foreach ( VoucherUse vu in this.VoucherUsage )
            {
                sb.Append( ( ( VoucherUse ) vu).ToString() + "\n");
            }

            return sb.ToString();

        }



        #endregion

        #region Constants

        //NOTE: This tool depends on values in uodb..t_voucher_status
        // active = 0 ; disabled = 1
        //task: I could just load these into a hashtable in a static constructor...
        public const int        VoucherAllOffersHex                     = -1;
        public const string     VoucherStatusActiveString               = "Active";
        public const byte       VoucherStatusActiveByte                 = 0;
        public const string     VoucherStatusDisabledString             = "Disabled";
        public const byte       VoucherStatusDisabledByte               = 1;
        public const byte       VoucherHashSize                         = 20;
        public const byte       SubscriptionCodeWithDashesStringLen     = 29;
        public const byte       SubscriptionCodeWithNoDashesStringLen   = 25;


        #endregion

        #region Public Static Methods

        // task: Should we have a way to load just the usage information if we delete the voucher-offer?
        // task: better question - will we ever delete vouchers other than in tests?

        // Load a single voucher object
        public static Voucher Load( byte[] hashBytes )
        {

            if (
                ( hashBytes == null ) ||
                ( hashBytes.Length != VoucherHashSize )
                )
            {
                throw new ArgumentException("Invalid hash byte array argument");
            }

            Voucher v = new Voucher( hashBytes );
            v.VoucherOffers = new ArrayList();
            v.VoucherUsage = new ArrayList();

            // if it's not there, caller will get an Exception
            LoadFromUODB( ref v );

            return v;

        }
        public static void VerifyOfferExistence(ulong offerId)
        {
                 using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    // Data is partitioned by offer id
                    ws.Partition = WstCommand.AnyPartition;
                    ws.StoredProc = "dbo.p_verify_offer_exists";
                    ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                    ws.AddParameter("@bi_offer_id", offerId);
                    uint hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        throw new DataException("Voucher data was NOT saved successfully, no rows affected. hr = " + hr.ToString() );
                    }
                }
       }
        public static Voucher Load( string subCodeString )
        {

            if (
                ( subCodeString == null ) ||
                ( ( subCodeString.Length != SubscriptionCodeWithDashesStringLen ) && ( subCodeString.Length != SubscriptionCodeWithNoDashesStringLen ) )
                )
                throw new ArgumentException("Invalid subscription code argument.");

            byte[] hashbytes = VoucherUtil2.SubcodeStringToHashByte( subCodeString );

            return Voucher.Load( hashbytes );

        }


        public static Voucher Create( byte[] hashBytes )
        {
            //task: throw exception for bad arguments here in guard clause
            Voucher v = new Voucher( hashBytes );
            v.VoucherOffers = new ArrayList();
            v.VoucherUsage = new ArrayList();

            return v;
        }

        public static Voucher Create( string hashString )
        {
            Voucher v = new Voucher( hashString );
            v.VoucherOffers = new ArrayList();
            v.VoucherUsage = new ArrayList();

            return v;
        }


        //task: create with the offer parameters built in... ;-)

        // retrieve by sub code string?

        //task: static Delete a voucher
        // don't need to load it only to delete it
        // will I ever use this ??
        //        public static DeleteFromUODB( hash, offerid )

        //task: static Disable a voucher
        // don't need to load it only to disable it
        // will I ever use this ??
        //        public static Disable( hash )


        #endregion

        #region Public Instance Methods

        // while having separate Insert/save methods would give us flexibility in the future
        // in case the insert / update cases are different, they're not right now, so
        // just check the values and save them ...
        // This is why I've kept the SaveToUODB method protected and separate.

        // Update object in database
        public void Save()
        {
            // call protected Save
            SaveToUODB();
        }


        /// <summary>
        /// Disable all offers of this Voucher.
        /// Disabling just one VoucherOffer is available by changing a VO.
        /// Consumers are responsible for Saving to make the change persistent.
        /// </summary>
        public void Disable()
        {

            for (int i = 0; i < this.VoucherOffers.Count; i++ )
            {
                // set each VoucherOffer to disabled
                ( (VoucherOffer) this.VoucherOffers[ i ] ).status = VoucherStatusDisabledByte;
            }

//            foreach (VoucherOffer vof in this.VoucherOffers )
//            {
//                Console.WriteLine("Disable: {0}: {1}", vof.offerID, vof.status );
//            }

        }


         /// <summary>
        /// Delete this Voucher and all it's offers.
        /// Neither the deletion of individual offers nor uses is not supported.
        /// </summary>
        public void Delete()
        {
            // just call the delete procedure with "all offers"
            // connect to UODB to get Voucher info
            using (WstConnection voucherConn = new WstConnection( ConfigUtil.TokendbWebstoreApp ) )
            {

                WstCommand voucherCmd;

                // no try here so exceptions get handled higher up
                voucherConn.Open();
                voucherCmd = voucherConn.CreateCommand();
                voucherCmd.CommandType = CommandType.StoredProcedure;
                voucherCmd.Partition = WSClient.GetHashPartition(this.hashBytes, ConfigUtil.UodbWebstoreApp);
                voucherCmd.CommandText = "p_svc_delete_voucher";

                voucherCmd.Parameters.Add( "@bin_voucher_hash", SqlDbType.Binary, 20).Value = this.hashBytes;
                voucherCmd.Parameters["@bin_voucher_hash"].Direction = ParameterDirection.Input;

                // VoucherAllOffersHex == -1 == all voucher-offers with this hash...
                voucherCmd.Parameters.Add( "@bi_offer_id", SqlDbType.BigInt).Value = VoucherAllOffersHex;
                voucherCmd.Parameters["@bi_offer_id"].Direction = ParameterDirection.Input;

                voucherCmd.ExecuteNonQuery();
            }

            //task: should I check to make sure it's gone? what if there's a failure?
            //task: what if the voucher doesn't exist?

        }


        // For those of us too lazy to write it out, here's a one stop shop
        /// <summary>
        /// An easy way to add an offer to a voucher instance.
        /// </summary>
        public void AddOffer( ulong offerID, int useCount, byte status )
        {

            VoucherOffer vo = new VoucherOffer();
            vo.offerID = offerID;
            vo.status = status;
            vo.useCount = useCount;
            this.VoucherOffers.Add( vo );

        }


        // For those of us too lazy to write it out, here's a one stop shop
        /// <summary>
        /// An easy way to add a usage to a voucher instance.
        /// </summary>
        public void AddUse( ulong userPUID, DateTime useDate )
        {

            //task: check for duplicates?
            VoucherUse vu = new VoucherUse();
            vu.puid = userPUID;
            vu.whenUsed = useDate;

            // connect to UODB to get Voucher info
            using (WstConnection voucherConn = new WstConnection( xonline.common.config.ConfigUtil.UodbWebstoreApp ) )
            {

                // no try here so exceptions get handled higher up
                voucherConn.Open();
                WstCommand voucherCmd = voucherConn.CreateCommand();
                voucherCmd.CommandType = CommandType.StoredProcedure;

                voucherCmd.CommandText = "p_xuacs_use_voucher";
                voucherCmd.Partition = WSClient.GetHashPartition(this.hashBytes, ConfigUtil.UodbWebstoreApp);

                voucherCmd.Parameters.Add( "@bin_voucher_hash", SqlDbType.Binary, 20).Value = this.hashBytes;
                voucherCmd.Parameters["@bin_voucher_hash"].Direction = ParameterDirection.Input;

                voucherCmd.Parameters.Add( "@bi_user_puid", SqlDbType.BigInt).Value = vu.puid;
                voucherCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Input;

                //interesting hash, but this is the same hash calc used by XUAC...
                voucherCmd.Parameters.Add( "@si_hash_bucket", SqlDbType.BigInt).Value = WSClient.GetHashPartition(this.hashBytes, ConfigUtil.UodbWebstoreApp);
                voucherCmd.Parameters["@si_hash_bucket"].Direction = ParameterDirection.Input;

                voucherCmd.Parameters.Add( "@hr", SqlDbType.BigInt );
                voucherCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                voucherCmd.ExecuteNonQuery();

                if ( 0 != (int) voucherCmd.Parameters["@hr"].Value )
                {
                    throw new DataException( "Voucher Use was not saved successfully, hr = " + voucherCmd.Parameters["@hr"].Value.ToString() + ".  Some causes are Voucher is invalid or voucher was already used." );
                }

            } // using


            // only add it to the parent object if we are successful in saving to UODB
            this.VoucherUsage.Add( vu );
            this.vuLoadCount++;
        }


        #endregion

        #region Protected Methods

        protected static void LoadFromUODB( ref Voucher v )
        {
            bool loaded = false;

            //task: change hardcoded "UODB" to a configuration setting, or
            // connect to UODB to get Voucher info
            using (WstConnection voucherConn = new WstConnection( xonline.common.config.ConfigUtil.UodbWebstoreApp ) )
            {

                //exceptions get handled higher up
                voucherConn.Open();
                WstCommand voucherCmd = voucherConn.CreateCommand();
                voucherCmd.CommandType = CommandType.StoredProcedure;

                voucherCmd.Partition = WSClient.GetHashPartition( v.hashBytes, ConfigUtil.UodbWebstoreApp );

                voucherCmd.CommandText = "p_svc_get_voucher_info";

                voucherCmd.Parameters.Add( "@bin_voucher_hash", SqlDbType.Binary, 20).Value = v.hashBytes;
                voucherCmd.Parameters["@bin_voucher_hash"].Direction = ParameterDirection.Input;

                WstDataReader wr = voucherCmd.ExecuteReader();

                // Load voucheroffers info
                while ( wr.Read() )
                {
                    loaded = true;
                    VoucherOffer vo = new VoucherOffer();

                    vo.offerID = (ulong)( wr.GetInt64( 0 ) );
                    vo.useCount = wr.GetInt32( 1 );

                    // why would anyone go through the trouble of returning a string
                    // when a perfectly unambiguous number is in the DB, and could have been used as-is?
                    switch ( wr.GetString( 2 ) )
                    {
                        case "Active" :
                            vo.status = 0;
                            break;
                        case "Disabled" :
                            vo.status = 1;
                            break;
                        default:
                            throw new Exception( "Invalid Voucher Status returned from p_svc_get_voucher_info " );
                    }

                    v.VoucherOffers.Add( vo );

                    // Console.WriteLine(vo.ToString());
                }

                // Load voucher users... only available if voucher has been used
                if( wr.NextResult() )
                {
                    while ( wr.Read() )
                    {
                        VoucherUse vu = new VoucherUse();

                        vu.puid = (ulong)( wr.GetInt64(0) );
                        vu.whenUsed = System.Convert.ToDateTime( wr.GetDateTime( 1 ) );

                        v.VoucherUsage.Add( vu );
                    }
                }

                // to make sure these don't get "edited" in a bad way
                v.voLoadCount = v.VoucherOffers.Count;
                v.vuLoadCount = v.VoucherUsage.Count;
            }

            if ( ! loaded )
                throw new VoucherNotFoundException();
        }

        protected void SaveToUODB()
        {

            // must have at least one offer. usages can be 0, but offers cannot.
            if ( this.VoucherOffers.Count == 0 )
            {
                throw new Exception( "A Voucher must have VoucherOffers before it can be stored." );
            }

            // it's ok to add one, we can handle that, we don't yet support deletion
            if ( this.VoucherOffers.Count < this.voLoadCount )
            {
                throw new Exception( "There are fewer offerIDs associated with this Voucher compared to when it was loaded.  Deleting offers from Voucher is not supported." );
            }
            //adding uses outside of the method is not supported...
            if    ( this.VoucherUsage.Count != this.vuLoadCount )
            {
                throw new Exception( "The number of Uses associated with this Voucher have changed.  Changing the VoucherUsage collection directly is not supported." );
            }

            // connect to UODB to get Voucher info
            using (WstConnection voucherConn = new WstConnection( xonline.common.config.ConfigUtil.TokendbWebstoreApp ) )
            {

                //review: need to have a transaction here???

                // no try here so exceptions get handled higher up
                voucherConn.Open();
                WstCommand voucherCmd = voucherConn.CreateCommand();
                voucherCmd.CommandType = CommandType.StoredProcedure;

                voucherCmd.CommandText = "p_svc_add_voucher";
                voucherCmd.Partition = WSClient.GetHashPartition( this.hashBytes, ConfigUtil.UodbWebstoreApp );

                int rows = 0;
                //all have the same hash, just different offers
                foreach ( VoucherOffer vo in this.VoucherOffers )
                {
                    VerifyOfferExistence(vo.offerID);
                    voucherCmd.Parameters.Add( "@bin_voucher_hash", SqlDbType.Binary, 20).Value = this.hashBytes;
                    voucherCmd.Parameters["@bin_voucher_hash"].Direction = ParameterDirection.Input;

                    voucherCmd.Parameters.Add( "@bi_offer_id", SqlDbType.BigInt).Value = (long) vo.offerID;
                    voucherCmd.Parameters["@bi_offer_id"].Direction = ParameterDirection.Input;

                    voucherCmd.Parameters.Add( "@i_use_count", SqlDbType.Int).Value = vo.useCount;
                    voucherCmd.Parameters["@i_use_count"].Direction = ParameterDirection.Input;

                    //interesting hash, but this is the same hash calc used by XUAC...
                    voucherCmd.Parameters.Add( "@si_hash_bucket", SqlDbType.BigInt).Value = WSClient.GetHashPartition( this.hashBytes, ConfigUtil.UodbWebstoreApp );
                    voucherCmd.Parameters["@si_hash_bucket"].Direction = ParameterDirection.Input;

                    voucherCmd.Parameters.Add( "@i_voucher_status_id", SqlDbType.Int).Value = vo.status;
                    voucherCmd.Parameters["@i_voucher_status_id"].Direction = ParameterDirection.Input;

                    voucherCmd.Parameters.Add( "@hr", SqlDbType.BigInt );
                    voucherCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                    rows = voucherCmd.ExecuteNonQuery();

                    //review: check if this exception type makes sense, and why doesn't XOFF_E_INVALID_OFFER_ID work?
                    // XOFF_E_INVALID_OFFER_ID = 0x80153003
//                    if ( (ulong) voucherCmd.Parameters["@hr"] == 2148872195)
//                        throw new DataException( "One or more OfferIDs are invalid!" );
                    if ( rows == 0 )
                        throw new DataException("Voucher data was NOT saved successfully, no rows affected. hr = " + voucherCmd.Parameters["@hr"].ToString() );

                    voucherCmd.Parameters.Clear();
                }

            } // using


        } // save to UODB

        #endregion


    } // voucher

    public class VoucherNotFoundException : Exception, ISerializable
    {
        const string message = "Requested Voucher not found in database.";
        public VoucherNotFoundException( ) :  base( message ) { }
        public VoucherNotFoundException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }

    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\VoucherUtil2.cs ===
using System;
using System.Security.Cryptography;
using System.Text;

//using xonline.common.mgmt;
using xonline.common.billing;

namespace xonline.tools.framework
{
    /// <summary>
    /// VoucherUtil contains utility functions for changing between different representations
    /// of the Subscription code and it's hash.
    /// A subscription code (aka "subcode") when encoded and SHA1 hashed, becomes a "hash".
    /// The hash can be represented as a string, or as an array of hex bytes.
    /// 
    /// Before I do my final checkin, I'll find out where to put the tests and 
    /// then I'm going to move this code to the existing VoucherUtil class.
    /// 
    /// </summary>
    public class VoucherUtil2: VoucherUtil
    {
            
        // this is the hashed value of "1111111111111111111111111"
        //
        static byte[] fakeHash = new byte[] { 0x46,0x0D,0x1A,0xBD,0x93,0x38,0x33,0xBA,0xD5,0x4F,0x47,0xBC,0x83,0xB0,0x42,0x26,0xE9,0xC9,0x62,0x23 };


        // empty cctor
        static VoucherUtil2 () {}
        
        /// <summary>
        /// Converts a byte array to a string of hex digits using a StringBuilder
        /// </summary>
        /// <param name="bHash"></param>
        /// <returns></returns>
        public static string HashByteToHexStr( byte [] bHash )
        {
            StringBuilder sb = new StringBuilder("");

            if ( bHash == null) { return ""; }

            for (int j = 0; j < bHash.Length; j++)
                // "X2" means 2 char hex ??
                sb.Append( bHash[j].ToString( "X2" ) );

            return sb.ToString();
        }


        //task: what is a key? name this better!
        // I suspect a key is the subcode without the dashes... 
        public static byte[] SubcodeStringToHashByte( string subcode )
        {

            //legacy behavior which needs to be maintained... 
            if (subcode == null)
            {
                // no voucher specified, fake it
                return fakeHash;
            }

            subcode = subcode.ToUpper();
            SHA1CryptoServiceProvider sha = new SHA1CryptoServiceProvider();
            UnicodeEncoding enc = new UnicodeEncoding();
            byte[] hashBytes;
        
            if ( (subcode.Length == 25) && (subcode[5] != '-') )
            {
                // insert dashes (thank you .net)
                subcode = subcode.Insert( 20, "-" );
                subcode = subcode.Insert( 15, "-" );
                subcode = subcode.Insert( 10, "-" );
                subcode = subcode.Insert( 5,  "-" );
            }

            //task: at some point this could use regex... 
            //at this point it should be exactly 29 characters
            //  wwwww-wwwww-wwwww-wwwww-wwwww
            if ( 
                ( subcode.Length != 29 ) ||
                ( subcode[ 23 ] != '-' ) ||
                ( subcode[ 17 ] != '-' ) ||
                ( subcode[ 11 ] != '-' ) || 
                ( subcode[  5 ] != '-' )  
                )
            {
                throw new ArgumentException("Invalid subscription code provided: " + subcode );
            }
               
            // extra null is again, thanks to .net
            byte [] hashb = sha.ComputeHash( enc.GetBytes( subcode + "\0" ) );
            hashBytes = enc.GetBytes( subcode + "\0" );
            return sha.ComputeHash( hashBytes );

        }

        public static byte[] HashBytesStringToHashByte( string hashstring )
        {
            //first, check whether it's even appropriate to try to convert this string... 
            if ( hashstring == null )
                throw new ArgumentException( "Null strings are invalid for conversion." );

            if ( hashstring == "" )
                throw new ArgumentException( "Empty strings are invalid for conversion." );

            //each byte = 2 chars, so string should be 2x of VoucherHashSize
            if ( hashstring.Length < ( Voucher.VoucherHashSize * 2) )
                throw new ArgumentException( "String supplied is too short for conversion." );

            if ( hashstring.Length > ( Voucher.VoucherHashSize * 2 ) )
                throw new ArgumentException( "String supplied is too long for conversion." );

            //regex would be good here for [0-9][a-z]
            byte[] hb = new byte[ Voucher.VoucherHashSize ];
            for ( int iLoop=0; iLoop < ( Voucher.VoucherHashSize ); iLoop++ )
            {
                try
                {
                    hb[iLoop] = Convert.ToByte( hashstring.Substring( ( iLoop * 2 ), 2 ), 16 );
                }
                catch (FormatException)
                {
                    throw new ArgumentException( "String contains non-Hex characters" );
                }
            }
            
            return hb;
        }

        //task: when does this get used?
        // when is a subscription code a ulong ???, or what is the "key" ?? 
        public static byte[] SubCodeToHashByte( ulong sub )
        {
            byte[] keyBytes;
            SHA1CryptoServiceProvider sha = new SHA1CryptoServiceProvider();
            UnicodeEncoding enc = new UnicodeEncoding();

            // extra null is to be compatible with .net way of doing things. 
            keyBytes = enc.GetBytes( sub + "\0" );
        
            return sha.ComputeHash( keyBytes );

        }

    } // voucher util

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\VoucherHelpers.cs ===
using System;
using System.Text;


namespace xonline.tools.framework
{


    /// <summary>
    /// Stores repeating information about a voucher's offers.
    /// </summary>
    public class VoucherOffer
    {
        // this is the "thing" this voucher gets you, offerID is same across all regions (Offer Guids are not)
        public ulong    offerID;
        // how many uses are allowed for this voucheroffer?
        public int      useCount;
        // active or disabled?
        public byte     status;

        public VoucherOffer()  {}

        public static bool operator == ( VoucherOffer a, VoucherOffer b )
        {
            if (
                ( a.offerID == b.offerID ) &&
                ( a.useCount == b.useCount ) &&
                ( a.status == b.status )
                )
                return true;
            else
                return false;
        }


        public static bool operator != ( VoucherOffer a, VoucherOffer b )
        {
            return ! ( a == b );
        }


        public override bool Equals( object obj )
        {
            if ( ! ( obj is VoucherOffer ) )
                return false;
                    
            if ( this == ( VoucherOffer ) obj )
                return true;
            else
                return false;
        }


        public override int GetHashCode()
        {
            return this.offerID.GetHashCode();
        }


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder(50);

            sb.Append( " offer: " + offerID.ToString() );
            sb.Append( " uses: " + useCount.ToString() );
            sb.Append( " status: " + status.ToString() );

            return sb.ToString();

        }


    }

        /// <summary>
        /// Information about a single usage of a voucher.
        /// </summary>
    public class VoucherUse
    {
        public      ulong       puid;
        public      DateTime    whenUsed;

        public VoucherUse()  {}

        public static bool operator == ( VoucherUse a, VoucherUse b )
        {
            if (
                ( a.puid == b.puid ) &&
                ( a.whenUsed == b.whenUsed )
                )
                return true;
            else
                return false;
        }

        public static bool operator != ( VoucherUse a, VoucherUse b )
        {
            return ! ( a == b );
        }

        public override bool Equals(object obj)
        {
            if ( ! ( obj is VoucherUse ) )
                return false;
                    
            if ( this == ( VoucherUse ) obj )
                return true;
            else
                return false;
        }

        public override int GetHashCode()
        {
            return this.puid.GetHashCode();
        }

        public override string ToString()
        {

            StringBuilder sb = new StringBuilder();
            
            sb.Append( " puid :" + this.puid.ToString() );
            sb.Append( " dateused: " + this.whenUsed.ToString() );

            return sb.ToString();

        }


    }
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Backup1\VoucherUtil2.cs ===
using System;
using System.Security.Cryptography;
using System.Text;

//using xonline.common.mgmt;
using xonline.common.billing;

namespace xonline.tools.framework
{
    /// <summary>
    /// VoucherUtil contains utility functions for changing between different representations
    /// of the Subscription code and it's hash.
    /// A subscription code (aka "subcode") when encoded and SHA1 hashed, becomes a "hash".
    /// The hash can be represented as a string, or as an array of hex bytes.
    /// 
    /// Before I do my final checkin, I'll find out where to put the tests and 
    /// then I'm going to move this code to the existing VoucherUtil class.
    /// 
    /// </summary>
    public class VoucherUtil2: VoucherUtil
    {
            
        // this is the hashed value of "1111111111111111111111111"
        //
        static byte[] fakeHash = new byte[] { 0x46,0x0D,0x1A,0xBD,0x93,0x38,0x33,0xBA,0xD5,0x4F,0x47,0xBC,0x83,0xB0,0x42,0x26,0xE9,0xC9,0x62,0x23 };


        // empty cctor
        static VoucherUtil2 () {}
        
        /// <summary>
        /// Converts a byte array to a string of hex digits using a StringBuilder
        /// </summary>
        /// <param name="bHash"></param>
        /// <returns></returns>
        public static string HashByteToHexStr( byte [] bHash )
        {
            StringBuilder sb = new StringBuilder("");

            if ( bHash == null) { return ""; }

            for (int j = 0; j < bHash.Length; j++)
                // "X2" means 2 char hex ??
                sb.Append( bHash[j].ToString( "X2" ) );

            return sb.ToString();
        }


        //task: what is a key? name this better!
        // I suspect a key is the subcode without the dashes... 
        public static byte[] SubcodeStringToHashByte( string subcode )
        {

            //legacy behavior which needs to be maintained... 
            if (subcode == null)
            {
                // no voucher specified, fake it
                return fakeHash;
            }

            subcode = subcode.ToUpper();
            SHA1CryptoServiceProvider sha = new SHA1CryptoServiceProvider();
            UnicodeEncoding enc = new UnicodeEncoding();
            byte[] hashBytes;
        
            if ( (subcode.Length == 25) && (subcode[5] != '-') )
            {
                // insert dashes (thank you .net)
                subcode = subcode.Insert( 20, "-" );
                subcode = subcode.Insert( 15, "-" );
                subcode = subcode.Insert( 10, "-" );
                subcode = subcode.Insert( 5,  "-" );
            }

            //task: at some point this could use regex... 
            //at this point it should be exactly 29 characters
            //  wwwww-wwwww-wwwww-wwwww-wwwww
            if ( 
                ( subcode.Length != 29 ) ||
                ( subcode[ 23 ] != '-' ) ||
                ( subcode[ 17 ] != '-' ) ||
                ( subcode[ 11 ] != '-' ) || 
                ( subcode[  5 ] != '-' )  
                )
            {
                throw new ArgumentException("Invalid subscription code provided: " + subcode );
            }
               
            // extra null is again, thanks to .net
            byte [] hashb = sha.ComputeHash( enc.GetBytes( subcode + "\0" ) );
            hashBytes = enc.GetBytes( subcode + "\0" );
            return sha.ComputeHash( hashBytes );

        }

        public static byte[] HashBytesStringToHashByte( string hashstring )
        {
            //first, check whether it's even appropriate to try to convert this string... 
            if ( hashstring == null )
                throw new ArgumentException( "Null strings are invalid for conversion." );

            if ( hashstring == "" )
                throw new ArgumentException( "Empty strings are invalid for conversion." );

            //each byte = 2 chars, so string should be 2x of VoucherHashSize
            if ( hashstring.Length < ( Voucher.VoucherHashSize * 2) )
                throw new ArgumentException( "String supplied is too short for conversion." );

            if ( hashstring.Length > ( Voucher.VoucherHashSize * 2 ) )
                throw new ArgumentException( "String supplied is too long for conversion." );

            //regex would be good here for [0-9][a-z]
            byte[] hb = new byte[ Voucher.VoucherHashSize ];
            for ( int iLoop=0; iLoop < ( Voucher.VoucherHashSize ); iLoop++ )
            {
                try
                {
                    hb[iLoop] = Convert.ToByte( hashstring.Substring( ( iLoop * 2 ), 2 ), 16 );
                }
                catch (FormatException)
                {
                    throw new ArgumentException( "String contains non-Hex characters" );
                }
            }
            
            return hb;
        }

        //task: when does this get used?
        // when is a subscription code a ulong ???, or what is the "key" ?? 
        public static byte[] SubCodeToHashByte( ulong sub )
        {
            byte[] keyBytes;
            SHA1CryptoServiceProvider sha = new SHA1CryptoServiceProvider();
            UnicodeEncoding enc = new UnicodeEncoding();

            // extra null is to be compatible with .net way of doing things. 
            keyBytes = enc.GetBytes( sub + "\0" );
        
            return sha.ComputeHash( keyBytes );

        }

    } // voucher util

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\User2.cs ===
using Microsoft.Webstore.WstClient;

using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Runtime.Serialization;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

[assembly: XomAreaDefinition(XomAreaName.user2)]

namespace xonline.tools.framework
{

    public class User2
    {

        // Why was it necessary to write a second User class?
        // 1. The current User class uses the WSReader shim, not the Webstore managed client
        // 2. Most of the code was copy-n-paste from User (with mods for Webstore 3.0 mgd client)
        // 3. Doing this allows Voucher and User to have similar semantics (Load, Create, Save, Delete, etc)
        // 4. New object is self-contained, not requiring ref WS connections to be passed in for some methods
        // 5. This new object doesn't require half the tree to be included...

        #region Private Variables

        protected ulong     puid;
        protected ulong     ownerPuid;
        protected ulong     userPassportPuid;
        protected ulong     ownerPassportPuid;
        protected byte      accountType;
        protected byte      allowXboxLogin;
        protected ulong     machinePuid;

        protected byte      countryID;
        protected int       languageID;
        protected int       cultureID;

    //billing info
        protected string    accountID;
        protected string    paymentInfoID;

        protected string    gamerTag;
        protected DateTime  birthdate;

        protected byte      ticketFlags;
        protected DateTime  accountResumeDate;
        protected int       suspensionLength;
        protected DateTime  voiceResumeDate;
        protected int       voiceBanLength;
        protected byte      nameChangeRequired;

        protected DateTime  acceptedTermsOfServiceDate;
        protected DateTime  resetDate;
        protected uint      billingAccountStatus;
//        protected int       accountStatusID;

        protected byte[]    billingPIN;

        protected int       parentalControlGroupID;
        protected byte      msOptIn;
        protected byte      partnerOptIn;

        protected int       tierID;
        protected byte      downgraded;

//        protected short     userFlags;

        protected DateTime  lastActivity;
        protected DateTime  lastWebActivity;
        protected DateTime  lastChangeDate;

        //task: if this isn't set anywhere, is it useful at all??
        protected bool      isNew = true;

        protected byte      hasMusicnetAccount;

        #endregion

        #region Constructors

        // so change in plans...
        // the public constructor will be for when you need to create a new user
        // accessing existing users will occur via the Load method,
        // since it makes sense to "load them from UODB"

//        //task: confirm constructor can only be called ONCE per instance
//        private User2( string Gamertag )
//        {
//            //task: other checks for gamertag validity before assigning?
//            if ( Gamertag.Length <= 16 )
//            {
//                this.gamerTag = Gamertag;
//                this.puid = 0;
//                this.isNew = true;
//            }
//            else
//            {
//                throw new Exception( "Invalid Gamertag Length." );
//            }
//        }

        //used internally in the Create/Load functions
        //this is to get folks used to the structure we'll use after ObjectSpaces ships,
        //and potentially to make sure certain operations occur in Create/Load scenarios.
        private User2( )
        {
            //task: is there something else to do here?
            this.isNew = true;
        }


        //    public User( ulong PUID )
        //    {
        //        //task: other checks for numeric validity?
        //        //task: what happens if a constructor takes an exception?
        //        if ( 0 != PUID)
        //        {
        //            this.puid = PUID;
        //            gamerTag = "";
        //        }
        //        else
        //        {
        //            throw new Exception( "Invalid PUID." );
        //        }
        //    }

        #endregion

        #region Public Property Accessors
        public ulong Puid
        {
            get { return puid; }
            set { puid = value; }
        }

        public ulong OwnerPuid
        {
            get { return ownerPuid; }
            set { ownerPuid = value; }
        }

        public ulong MachinePuid
        {
            get { return machinePuid; }
            set { machinePuid = value; }
        }

        public string GamerTag
        {
            get { return gamerTag; }
            set { gamerTag = value; }
        }

        public byte CountryID
        {
            get { return countryID; }
            set { countryID = value; }
        }

        public string AccountID
        {
            get { return accountID; }
            set { accountID = value; }
        }

        public string PaymentInfoID
        {
            get { return paymentInfoID; }
            set { paymentInfoID = value; }
        }

        public uint BillingAccountStatus
        {
            get { return billingAccountStatus; }
            set { billingAccountStatus = value; }
        }

        public DateTime Birthdate
        {
            get { return birthdate; }
            set { birthdate = value; }
        }

//        public int AccountStatusID
//        {
//            get { return accountStatusID; }
//
//            // this field is constrained to zero in v1 UODB. cannot be set.
//        }

        public byte TicketFlags
        {
            get { return ticketFlags; }
            set { ticketFlags = value; }
        }

//        public short UserFlags
//        {
//            get { return userFlags; }
//            set { userFlags = value; }
//        }

        public byte[] BillingPIN
        {
            get { return billingPIN; }
            set { billingPIN = value; }
        }

        public DateTime AccountResumeDate
        {
            get { return accountResumeDate; }
            set { accountResumeDate = value; }
        }

        public int SuspensionLength
        {
            get { return suspensionLength; }
            set { suspensionLength = value; }
        }

        public DateTime VoiceResumeDate
        {
            get { return voiceResumeDate; }
            set { voiceResumeDate = value; }
        }

        public int VoiceBanLength
        {
            get { return voiceBanLength; }
            set { voiceBanLength = value; }
        }


        public byte NameChangeRequired
        {
            get { return nameChangeRequired; }
            set { nameChangeRequired = value; }
        }

        public DateTime AcceptedTermsOfServiceDate
        {
            get { return acceptedTermsOfServiceDate; }
            set { acceptedTermsOfServiceDate = value; }
        }

        public DateTime ResetDate
        {
            get { return resetDate; }
            set { resetDate = value; }
        }

        public string BillingPMN
        {
            get { return gamerTag.Replace(' ', '_'); }
        }


        public string BillingOwnerPMN
        {
            get
            {
                if( puid == ownerPuid)
                {
                    return gamerTag.Replace(' ', '_');
                }
                else
                {
                    return gamerTag.Replace(' ', '_') + ".Owner";
                }
            }
        }

        #endregion

        #region Operators

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder( 100 );

            sb.Append( "User: " + this.GamerTag + " puid: " + this.puid.ToString() + " owner: " + this.ownerPuid.ToString() );
            sb.Append( "\n  ppUser: " + this.userPassportPuid.ToString() + " ppOwner: " + this.ownerPassportPuid.ToString() );
            sb.Append( "\n  Cty: " + this.countryID.ToString() + " bday: " + this.birthdate.ToString() );
            sb.Append( "\n  billAccID: " + this.accountID  + " payinfo: " + this.paymentInfoID );
            sb.Append( "\n  tktFlags: " + this.ticketFlags.ToString() );
            sb.Append( "\n  acctRes: " + this.accountResumeDate.ToString() + " suspLen: " + this.suspensionLength.ToString() );
            sb.Append( "\n  voiceRes: " + this.voiceResumeDate.ToString() + " vBanLen: " + this.VoiceBanLength.ToString() );
            sb.Append( "\n  nameChg: " + this.nameChangeRequired.ToString() + " accptTOS: " + this.acceptedTermsOfServiceDate.ToString() );
            sb.Append( "\n  rstDate: " + this.resetDate.ToString() + " billngAcctStatus: " + this.billingAccountStatus.ToString() + "  pin: " + this.billingPIN.ToString() );

            return sb.ToString();
        }


        #endregion

        #region Public Static Methods

        public static User2 Load( string gamerTag )
        {

            User2 u = null;

            // connect to UODB to get User info
            //task: what if gamertag is a machine in t_user_names???  XONLINE_E_PUID_IS_MACHINE
            using ( WstConnection userConn = new WstConnection( xonline.common.config.ConfigUtil.UodbWebstoreApp ) )
            {

                WstCommand userCmd;
                userConn.Open();

                userCmd = userConn.CreateCommand();
                //note: the service LOWERCASES the string before hashing..
                userCmd.Partition = WSClient.GetHashPartition( gamerTag, ConfigUtil.UodbWebstoreApp );
                userCmd.CommandType = CommandType.StoredProcedure;
                userCmd.CommandText = "p_xuacs_get_user_acct_by_name";

                userCmd.Parameters.Add( "@vc_gamertag", SqlDbType.NVarChar, 16).Value = gamerTag;
                userCmd.Parameters["@vc_gamertag"].Direction = ParameterDirection.Input;

                userCmd.Parameters.Add( "@bi_user_puid", SqlDbType.BigInt);
                userCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@hr", SqlDbType.BigInt);
                userCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                userCmd.ExecuteNonQuery();

                //just for debugging
                //Console.WriteLine("GT Load: GT {0}, ptn {1}, puid {2}, hr {3}", gamerTag, userCmd.Partition, userCmd.Parameters["@bi_user_puid"].Value, userCmd.Parameters["@hr"].Value );

                if ( 0 != (int) userCmd.Parameters["@hr"].Value )
                {
                    throw new UserNotFoundException( gamerTag );
                }

                //Now that we have the PUID ...
                u = User2.Load( System.Convert.ToUInt64( userCmd.Parameters["@bi_user_puid"].Value ) );

            } // using

            //review: should this be inside the Using stmt?
            return u;

        } // LoadFromGamertag


        public static User2 Load( ulong PUID )
        {

            //task: confirm this will reuse connections
            // connect to UODB to get User info
            // having it's own object allows it to avoid issues with caller
            //  and since we use connection pooling, using an existing connection already happens

            User2 u = null;

            using ( WstConnection userConn = new WstConnection(ConfigUtil.UodbWebstoreApp) )
            {

                WstCommand userCmd;
                userConn.Open();
                userCmd = userConn.CreateCommand();
                userCmd.CommandType = CommandType.StoredProcedure;
                //go straight for the PUID...
                userCmd.CommandText = "dbo.p_xuacs_get_user_acct";

                //this is essentially the way it's done in the original...
                userCmd.Partition = WSClient.GetHashPartition( PUID, ConfigUtil.UodbWebstoreApp );

                // INPUT PARAMETERS
                userCmd.Parameters.Add( "@bi_user_puid", SqlDbType.BigInt ).Value = PUID;
                userCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Input;

                // RETURN PARAMETER
                userCmd.Parameters.Add( "@hr", SqlDbType.Int );
                userCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                // OUTPUT PARAMETERS
                userCmd.Parameters.Add( "@bi_owner_puid", SqlDbType.BigInt );
                userCmd.Parameters["@bi_owner_puid"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@bi_user_passport_puid", SqlDbType.BigInt );
                userCmd.Parameters["@bi_user_passport_puid"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@bi_owner_passport_puid", SqlDbType.BigInt );
                userCmd.Parameters["@bi_owner_passport_puid"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@ti_account_type", SqlDbType.TinyInt );
                userCmd.Parameters["@ti_account_type"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@f_allow_xbox1_logon", SqlDbType.TinyInt );
                userCmd.Parameters["@f_allow_xbox1_logon"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@bi_machine_puid", SqlDbType.BigInt );
                userCmd.Parameters["@bi_machine_puid"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@ti_country_id", SqlDbType.TinyInt );
                userCmd.Parameters["@ti_country_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_language_id", SqlDbType.Int );
                userCmd.Parameters["@i_language_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_culture_id", SqlDbType.Int );
                userCmd.Parameters["@i_culture_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@vc_billing_account_id", SqlDbType.NVarChar, 255 );
                userCmd.Parameters["@vc_billing_account_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@vc_billing_payinfo_id", SqlDbType.NVarChar, 255 );
                userCmd.Parameters["@vc_billing_payinfo_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@vc_gamertag", SqlDbType.NVarChar, 16 );
                userCmd.Parameters["@vc_gamertag"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_birthdate", SqlDbType.DateTime );
                userCmd.Parameters["@dt_birthdate"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@si_ticket_flags", SqlDbType.SmallInt );
                userCmd.Parameters["@si_ticket_flags"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_acct_resume_date", SqlDbType.DateTime );
                userCmd.Parameters["@dt_acct_resume_date"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_suspension_length", SqlDbType.Int );
                userCmd.Parameters["@i_suspension_length"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_voice_resume_date", SqlDbType.DateTime );
                userCmd.Parameters["@dt_voice_resume_date"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_voice_ban_length", SqlDbType.Int );
                userCmd.Parameters["@i_voice_ban_length"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@ti_name_change_required", SqlDbType.TinyInt );
                userCmd.Parameters["@ti_name_change_required"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_accepted_tos", SqlDbType.DateTime );
                userCmd.Parameters["@dt_accepted_tos"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_reset_date", SqlDbType.DateTime );
                userCmd.Parameters["@dt_reset_date"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_billing_account_status", SqlDbType.Int );
                userCmd.Parameters["@i_billing_account_status"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@bin_acct_pin", SqlDbType.Binary, 4 );
                userCmd.Parameters["@bin_acct_pin"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_parental_control_group_id", SqlDbType.Int );
                userCmd.Parameters["@i_parental_control_group_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@f_ms_opt_in", SqlDbType.TinyInt );
                userCmd.Parameters["@f_ms_opt_in"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@f_partner_opt_in", SqlDbType.TinyInt );
                userCmd.Parameters["@f_partner_opt_in"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_change_datetime", SqlDbType.DateTime );
                userCmd.Parameters["@dt_change_datetime"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_tier_id", SqlDbType.Int );
                userCmd.Parameters["@i_tier_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@f_downgraded", SqlDbType.TinyInt );
                userCmd.Parameters["@f_downgraded"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_last_activity", SqlDbType.DateTime );
                userCmd.Parameters["@dt_last_activity"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_last_web_activity", SqlDbType.DateTime );
                userCmd.Parameters["@dt_last_web_activity"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@f_has_musicnet_account", SqlDbType.TinyInt );
                userCmd.Parameters["@f_has_musicnet_account"].Direction = ParameterDirection.Output;

                foreach( SqlParameter sp in userCmd.Parameters )
                {
                    Console.WriteLine( "Name: " + sp.ParameterName.PadRight(20) + "  Type: " + sp.SqlDbType.ToString().PadRight(10) );
                    //+ "  Value: " + sp.Value.ToString().PadRight(16)
                }


                // Go get the info, finally!
                userCmd.ExecuteNonQuery();

                //just for debugging
                //Console.WriteLine("PUID Load: PUID {0}, ptn {1}, hr {2}", PUID, userCmd.Partition, userCmd.Parameters["@hr"].Value );

                if ( (int) userCmd.Parameters["@hr"].Value != HResult.S_OK )
                {
                    throw new UserNotFoundException( PUID );
                }

                u = new User2();
                u.puid = PUID;
                u.ownerPuid = System.Convert.ToUInt64( userCmd.Parameters["@bi_owner_puid"].Value );
                u.userPassportPuid = System.Convert.ToUInt64( userCmd.Parameters["@bi_user_passport_puid"].Value );
                u.ownerPassportPuid = System.Convert.ToUInt64( userCmd.Parameters["@bi_owner_passport_puid"].Value );
                u.accountType = ( byte ) userCmd.Parameters["@ti_account_type"].Value;
                u.allowXboxLogin = ( byte ) userCmd.Parameters["@f_allow_xbox1_logon"].Value;
                u.machinePuid =  System.Convert.ToUInt64( userCmd.Parameters["@bi_machine_puid"].Value );
                u.countryID = ( byte ) userCmd.Parameters["@ti_country_id"].Value;
                u.languageID = ( int ) userCmd.Parameters["@i_language_id"].Value;
                u.cultureID = ( int ) userCmd.Parameters["@i_culture_id"].Value;
                u.accountID = ( string ) userCmd.Parameters["@vc_billing_account_id"].Value;
                u.paymentInfoID = ( string ) userCmd.Parameters["@vc_billing_payinfo_id"].Value;
                u.gamerTag  = ( string ) userCmd.Parameters["@vc_gamertag"].Value;
                u.birthdate = ( DateTime ) userCmd.Parameters["@dt_birthdate"].Value;
                u.accountResumeDate = ( DateTime ) userCmd.Parameters["@dt_acct_resume_date"].Value;
                u.suspensionLength  = ( int ) userCmd.Parameters["@i_suspension_length"].Value;
                u.voiceResumeDate   = ( DateTime ) userCmd.Parameters["@dt_voice_resume_date"].Value;
                u.voiceBanLength = ( int ) userCmd.Parameters["@i_voice_ban_length"].Value;
                u.nameChangeRequired = ( byte ) userCmd.Parameters["@ti_name_change_required"].Value;
                u.acceptedTermsOfServiceDate = ( DateTime ) userCmd.Parameters["@dt_accepted_tos"].Value;
                u.resetDate = ( DateTime ) userCmd.Parameters["@dt_reset_date"].Value;
                //note: an int being held as an object needs to get casted to an int first, then to a uint
                //      using System.Convert will cause an exception if there's a 0 or < 0 value in the int.
                u.billingAccountStatus = ( uint ) (int) userCmd.Parameters["@i_billing_account_status"].Value;
                u.billingPIN = ( byte [] ) userCmd.Parameters["@bin_acct_pin"].Value;
                u.parentalControlGroupID = ( int ) userCmd.Parameters["@i_parental_control_group_id"].Value;
                u.msOptIn = ( byte ) userCmd.Parameters["@f_ms_opt_in"].Value;
                u.partnerOptIn = ( byte ) userCmd.Parameters["@f_partner_opt_in"].Value;
                u.lastChangeDate = ( System.DateTime ) userCmd.Parameters["@dt_change_datetime"].Value;
                u.tierID = ( int ) userCmd.Parameters["@i_tier_id"].Value;
                u.downgraded = ( byte ) userCmd.Parameters["@f_downgraded"].Value;
                u.lastActivity = ( DateTime ) userCmd.Parameters["@dt_last_activity"].Value;
                u.lastWebActivity = ( DateTime ) userCmd.Parameters["@dt_last_web_activity"].Value;
                u.hasMusicnetAccount = ( byte) userCmd.Parameters["@f_has_musicnet_account"].Value;
            }   // using

            // just for debugging
            // Console.WriteLine("PUID Load: PUID {0}, owner {1}, gt {2}", u.Puid, u.OwnerPuid, u.GamerTag );
            return u;

        } // LoadFromPUID


        public static User2 Create()
        {
            //create a new user and return it
            //task: in the future, this will take a puid and gamertag, and reserve the name on user creation...

            User2 u = new User2();
            return u;

        }


        #endregion

        #region Public Instance Methods


        /// <summary>
        /// Update an existing User object in UODB.
        /// </summary>
        public void Save( )
        {
            if ( this.isNew )
            {
                //task: legacy item -- what the hell is NYI ??
                throw new Exception("NYI");
            }

            WstConnection userConn = new WstConnection(xonline.common.config.ConfigUtil.UodbWebstoreApp);
            WstCommand userCmd;
            userConn.Open();
            userCmd = userConn.CreateCommand();
            userCmd.CommandType = CommandType.StoredProcedure;

            //task: what about assigning the user puid?
            userCmd.CommandText = "p_xuacs_set_user_acct";

            // Return Value FROM the procedure
            userCmd.Parameters.Add( "@hr", SqlDbType.Int );
            userCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

            // Input parameters TO the Procedure
            userCmd.Parameters.Add( "@bi_user_puid", SqlDbType.BigInt ).Value = this.puid;
            userCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@bi_owner_puid ", SqlDbType.BigInt ).Value = this.ownerPuid;
            userCmd.Parameters["@bi_owner_puid"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@bi_user_passport_puid", SqlDbType.BigInt ).Value = this.userPassportPuid;
            userCmd.Parameters["@bi_user_passport_puid"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@bi_owner_passport_puid", SqlDbType.BigInt ).Value = this.ownerPassportPuid;
            userCmd.Parameters["@bi_owner_passport_puid"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@ti_account_type", SqlDbType.TinyInt ).Value = this.accountType;
            userCmd.Parameters["@ti_account_type"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@f_allow_xbox1_logon", SqlDbType.TinyInt ).Value = this.allowXboxLogin;
            userCmd.Parameters["@f_allow_xbox1_logon"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@ti_country_id", SqlDbType.TinyInt ).Value = this.countryID;
            userCmd.Parameters["@ti_country_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_language_id", SqlDbType.Int ).Value = this.languageID;
            userCmd.Parameters["@i_language_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_culture_id", SqlDbType.Int ).Value = this.cultureID;
            userCmd.Parameters["@i_culture_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@vc_billing_account_id", SqlDbType.NVarChar, 255 ).Value = this.accountID;
            userCmd.Parameters["@vc_billing_account_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@vc_billing_payinfo_id", SqlDbType.NVarChar, 255 ).Value = this.paymentInfoID;
            userCmd.Parameters["@vc_billing_payinfo_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@vc_gamertag", SqlDbType.NVarChar, 16 ).Value = this.gamerTag ;
            userCmd.Parameters["@vc_gamertag"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_birthdate", SqlDbType.DateTime ).Value = this.birthdate;
            userCmd.Parameters["@dt_birthdate"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@si_ticket_flags", SqlDbType.SmallInt ).Value = this.ticketFlags;
            userCmd.Parameters["@si_ticket_flags"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_acct_resume_date", SqlDbType.DateTime ).Value = this.accountResumeDate;
            userCmd.Parameters["@dt_acct_resume_date"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_suspension_length", SqlDbType.Int ).Value = this.suspensionLength;
            userCmd.Parameters["@i_suspension_length"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_voice_resume_date", SqlDbType.DateTime ).Value = this.voiceResumeDate;
            userCmd.Parameters["@dt_voice_resume_date"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_voice_ban_length", SqlDbType.Int ).Value = this.voiceBanLength;
            userCmd.Parameters["@i_voice_ban_length"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@ti_name_change_required", SqlDbType.TinyInt ).Value = this.nameChangeRequired;
            userCmd.Parameters["@ti_name_change_required"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_accepted_tos", SqlDbType.DateTime ).Value = this.acceptedTermsOfServiceDate;
            userCmd.Parameters["@dt_accepted_tos"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_reset_date", SqlDbType.DateTime ).Value = this.resetDate;
            userCmd.Parameters["@dt_reset_date"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_billing_account_status", SqlDbType.Int ).Value = this.billingAccountStatus;
            userCmd.Parameters["@i_billing_account_status"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@bin_acct_pin", SqlDbType.Binary, 4 ).Value = this.billingPIN;
            userCmd.Parameters["@bin_acct_pin"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_parental_control_group_id", SqlDbType.Int ).Value = this.parentalControlGroupID;
            userCmd.Parameters["@i_parental_control_group_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@f_ms_opt_in", SqlDbType.TinyInt ).Value = this.msOptIn;
            userCmd.Parameters["@f_ms_opt_in"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@f_partner_opt_in", SqlDbType.TinyInt ).Value = this.partnerOptIn;
            userCmd.Parameters["@f_partner_opt_in"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@f_downgraded", SqlDbType.TinyInt ).Value = this.downgraded;
            userCmd.Parameters["@f_downgraded"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_change_datetime ", SqlDbType.DateTime ).Value = System.DateTime.UtcNow;
            userCmd.Parameters["@dt_change_datetime"].Direction = ParameterDirection.Input;

            userCmd.ExecuteNonQuery();

            if ( (int) userCmd.Parameters["@hr"].Value != HResult.S_OK )
            {
                throw new Exception("Error saving " + puid + " in UODB! " + userCmd.Parameters["@hr"].ToString());
            }
        }



        #endregion

        #region BoneYard

        // contains partially implemented, but not needed methods and legacy code snippets

        //        /// <summary>
        //        /// Retrieves an existing user from UODB by Gamertag
        //        /// </summary>
        //        /// <param name="puid"></param>
        //        /// <returns name="User"></returns>
        //        public static User2 Load( string gamertag )
        //        {
        //            User2 u = new User2( gamertag );
        //            try
        //            {
        //                u.LoadFromGamertag();
        //                u.isNew = false;
        //            }
        //            catch (Exception e)
        //            {
        //                throw new Exception("No user information available.");
        //            }
        //
        //            return u;
        //        } // load
        //
        //        /// <summary>
        //        /// Retrieves an existing user from UODB by PUID
        //        /// </summary>
        //        /// <param name="puid"></param>
        //        /// <returns name="User"></returns>
        //        public static User2 Load( ulong loadPuid )
        //        {
        //            User2 u = new User2( );
        //            u.puid = loadPuid;
        //            try
        //            {
        //                u.LoadFromPUID();
        //                u.isNew = false;
        //            }
        //            catch (Exception e)
        //            {
        //                throw new Exception("No user information available.");
        //            }
        //
        //            return u;
        //
        //        } // load


        //    public UserBillingInfo GetBillingInfo(string SPSUrl)
        //    {
        //        //task: what information will we get from SPS?
        //        //task: how will that information be stored
        //
        //    }


        //task: implement this when needed
        //    public void CreateUser( ulong offerID, string serviceInstanceId )
        //    {
        //        SaveWithSubscription( offerID, serviceInstanceId );
        //    }

        //task: implement this only when needed
//        public void SaveWithSubscription( ulong offerID, string serviceInstanceId )
//        {
//
//            throw new Exception("This Method is not implemented yet!");
//
//            //task: figure out why there is a debug.assert here
//            if ( ! this.isNew )
//            {
//                //task: what the hell is NYI ??
//                throw new Exception("NYI");
//            }
//            // Debug.Assert( isNew == true );       // updating existing users with this not supported
//
//            WstConnection userConn = new WstConnection("UODB");
//            WstCommand userCmd;
//
//            try
//            {
//                userConn.Open();
//                userCmd = userConn.CreateCommand();
//                userCmd.CommandType = CommandType.StoredProcedure;
//
//                //go straight for the PUID...
//                userCmd.CommandText = "p_xuacs_add_user_with_sub";
//
//                // Return Value
//                userCmd.Parameters.Add( "@hr", SqlDbType.Int );
//                userCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;
//
//                // INPUT PARAMETERS TO THE PROCEDURE
//                userCmd.Parameters.Add( "@bi_user_puid", SqlDbType.BigInt ).Value = this.puid;
//                userCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@bi_owner_puid ", SqlDbType.BigInt ).Value = this.ownerPuid;
//                userCmd.Parameters["@bi_owner_puid"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@bi_machine_puid ", SqlDbType.BigInt ).Value = this.machinePuid;
//                userCmd.Parameters["@bi_machine_puid"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@ti_country_id", SqlDbType.TinyInt ).Value = this.countryId;
//                userCmd.Parameters["@ti_country_id"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@vc_billing_account_id", SqlDbType.NVarChar, 255 ).Value = this.accountId;
//                userCmd.Parameters["@vc_billing_account_id"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@vc_billing_payinfo_id", SqlDbType.NVarChar, 255 ).Value = this.paymentInfoId;
//                userCmd.Parameters["@vc_billing_payinfo_id"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@vc_gamertag", SqlDbType.NVarChar, 16 ).Value = this.gamerTag ;
//                userCmd.Parameters["@vc_gamertag"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_birthdate", SqlDbType.DateTime ).Value = this.birthdate;
//                userCmd.Parameters["@dt_birthdate"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@i_acct_status_id", SqlDbType.Int ).Value = this.accountStatusId;
//                userCmd.Parameters["@i_acct_status_id"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@si_ticket_flags", SqlDbType.SmallInt ).Value = this.ticketFlags;
//                userCmd.Parameters["@si_ticket_flags"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@si_user_flags", SqlDbType.SmallInt ).Value = this.userFlags;
//                userCmd.Parameters["@si_user_flags"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_acct_resume_date", SqlDbType.DateTime ).Value = this.accountResumeDate;
//                userCmd.Parameters["@dt_acct_resume_date"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@i_suspension_length", SqlDbType.Int ).Value = this.suspensionLength;
//                userCmd.Parameters["@i_suspension_length"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_voice_resume_date", SqlDbType.DateTime ).Value = this.voiceResumeDate;
//                userCmd.Parameters["@dt_voice_resume_date"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@i_voice_ban_length", SqlDbType.Int ).Value = this.voiceBanLength;
//                userCmd.Parameters["@i_voice_ban_length"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@ti_name_change_required", SqlDbType.TinyInt ).Value = this.nameChangeRequired;
//                userCmd.Parameters["@ti_name_change_required"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_accepted_tos", SqlDbType.DateTime ).Value = this.acceptedTOSDate;
//                userCmd.Parameters["@dt_accepted_tos"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_reset_date", SqlDbType.DateTime ).Value = this.resetDate;
//                userCmd.Parameters["@dt_reset_date"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@i_billing_account_status", SqlDbType.Int ).Value = this.billingAccountStatus;
//                userCmd.Parameters["@i_billing_account_status"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@bin_acct_pin", SqlDbType.Binary, 4 ).Value = this.billingPIN;
//                userCmd.Parameters["@bin_acct_pin"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@bi_offer_id", SqlDbType.BigInt ).Value = offerID;
//                userCmd.Parameters["@bi_offer_id"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@vc_service_instance_id", SqlDbType.NVarChar, 36 ).Value = serviceInstanceId;
//                userCmd.Parameters["@bi_offer_id"].Direction = ParameterDirection.Input;
//
//                //task: confirm this should keep the old behavior of setting this to 0
//                userCmd.Parameters.Add( "@ti_accept_msspam", SqlDbType.TinyInt ).Value = 0;
//                userCmd.Parameters["@ti_accept_msspam"].Direction = ParameterDirection.Input;
//
//                //task: confirm this should keep the old behavior of setting this to 0
//                userCmd.Parameters.Add( "@ti_accept_partnerspam", SqlDbType.TinyInt ).Value = 0;
//                userCmd.Parameters["@ti_accept_partnerspam"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_change_datetime ", SqlDbType.DateTime ).Value = System.DateTime.UtcNow;
//                userCmd.Parameters["@dt_change_datetime"].Direction = ParameterDirection.Input;
//
//                //task: make sure this is right!!
//                // hash value returned is correct
//                // puid -> long
//                //
//                userCmd.Parameters.Add( "@si_hash_bucket", SqlDbType.Int ).Value = WstHash.GetHash( ( long ) this.puid, userConn.LogicalPartitions );
//                userCmd.Parameters["@si_hash_bucket"].Direction = ParameterDirection.Input;
//
//                userCmd.ExecuteNonQuery();
//
//            }// try
//            catch (Exception e)
//            {
//                //task: do something
//            }
//
//            // now we can .Save this if we need to
//            this.isNew = false;
//
//        } // SaveWithSubscription
//


//        public void ResetPassword()
//        {
//            throw new Exception("This Method is not implemented yet!");
//
//            //task: what is the NYI exception???
//            if ( isNew == true )
//            {
//                throw new Exception( "NYI" );
//            }
//
//            byte[] rawKey;
//            byte[] encKey;
//            byte[] iv;
//            byte[] SPPA;
//            byte[] PPA;
//
//            // generate a new key.
//            KEKCryptoMgr.GenerateNewKey( out iv, out encKey, out rawKey );
//
//            // generate new PPA data
//            KEKCryptoMgr.GenPPAforDBWrp( gamerTag, (byte[])rawKey.Clone(), out SPPA, out PPA );
//
//            ResetPassword(encKey, iv, SPPA, PPA);
//
//        }


//        public void ResetPassword(byte[] key, byte[] iv, byte[] SPPA, byte[] PPA)
//        {
//            throw new Exception("This Method is not implemented yet!");
//
//            if ( isNew == true )
//            {
//                throw new Exception("NYI");
//            }
//
//            WstConnection resetConn = new WstConnection("UODB");
//            WstCommand resetCmd;
//
//            try
//            {
//                resetConn.Open();
//                resetCmd = resetConn.CreateCommand();
//                resetCmd.CommandType = CommandType.StoredProcedure;
//
//                //go straight for the PUID...
//                resetCmd.CommandText = "p_xuacs_set_reset_key";
//
//                // Return Value
//                resetCmd.Parameters.Add( "@hr", SqlDbType.Int );
//                resetCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;
//
//                // INPUT PARAMETERS TO THE PROCEDURE
//                resetCmd.Parameters.Add( "@gamertag", SqlDbType.NVarChar, 100 ).Value = this.gamerTag ;
//                resetCmd.Parameters["@gamertag"].Direction = ParameterDirection.Input;
//
//                // @key binary(16),
//                resetCmd.Parameters.Add( "@key", SqlDbType.Binary, 16 ).Value = key;
//                resetCmd.Parameters["@key"].Direction = ParameterDirection.Input;
//
//                resetCmd.Parameters.Add( "@iv", SqlDbType.NVarChar, 16 ).Value =  iv;
//                resetCmd.Parameters["@iv"].Direction = ParameterDirection.Input;
//
//                resetCmd.Parameters.Add( "@i_kek_version", SqlDbType.Int ).Value = KEKCryptoMgr.GetKeyVersion();
//                resetCmd.Parameters["@i_kek_version"].Direction = ParameterDirection.Input;
//
//                resetCmd.Parameters.Add( "@bin_SPPA", SqlDbType.Binary, 20 ).Value =  SPPA;
//                resetCmd.Parameters["@bin_SPPA"].Direction = ParameterDirection.Input;
//
//                resetCmd.Parameters.Add( "@bin_PPA", SqlDbType.Binary, 8 ).Value =  PPA;
//                resetCmd.Parameters["@bin_PPA"].Direction = ParameterDirection.Input;
//
//                resetCmd.ExecuteNonQuery();
//
//                // the SP should return zero on OK, nonzero on failure
//                if( ( int ) resetCmd.Parameters["@hr"].Value != HResult.S_OK )
//                {
//                    //task: int -> uint conversion ???
//                    throw new XRLException( ( uint ) resetCmd.Parameters["@hr"].Value , XEvent.Id.COMMON_CODE_207, "Error setting key for user " + this.puid.ToString() + " ." );
//                }
//
//                // Having updated the key, now update the object with the key reset time.
//                // basically, if the caller saves this user, this will get updated
//                //task: check if this is critical -- if it is, the we need a transaction
//                resetDate = DateTime.UtcNow;
//                // this.Save();
//
//            } // try
//            catch (Exception e)
//            {
//                //task: do something here!
//            }
//
//        } // reset password

        #endregion

    } // class User

    public class UserNotFoundException : Exception, ISerializable
    {
        const string message = "Requested user not found in database.";
        public UserNotFoundException( ) :  base( message ) { }
        public UserNotFoundException( string gamertag ) :  base( "Requested User " + gamertag + " was not found in database." ) { }
        public UserNotFoundException( ulong puid ) :  base( "Requested User with puid " + puid.ToString() + " was not found in database." ) { }
        public UserNotFoundException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }

    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Backup1\UserBillingInfo.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;

using Billing.PSO;

using xonline.common.billing;
using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.userbillinginfo)]
[assembly: XomAreaDefinition(XomAreaName.toolspslog)]

namespace xonline.tools.framework
{


    /// <summary>
    /// Holds information from SPS about a user and their subscriptions.
    /// Use Load to load SPS information, and use ReLoad rather than creating another object if you need
    /// to access information for multiple users.
    /// </summary>
    public class UserBillingInfo
    {

        #region Properties, Privates and Constants

        // all values are initialized in the constructor anyway, but it looks good
        protected bool spsDataLoaded = false;
        protected ulong ownerPUID;
        protected const string SPS_TEST_STRING = "Testing123";
        public static Hashtable YearlyRenewalOfferGUID = new Hashtable( 24 );
        public static Hashtable MonthlyRenewalOfferGUID = new Hashtable( 24 );

        //so that we don't have to keep looking this up once it's been looked up...
        //and I don't want to take it as an exception during load if something's weird...
        protected int baseSubscriptionIndex = -1;
        public int LiveBaseSubscriptionIndex
        {
            get
            {
                if ( spsDataLoaded )
                {
                    return baseSubscriptionIndex;
                }
                else
                {
                    throw new Exception("Cannot get LiveBaseSubscriptionIndex untill UBI.LoadBilling has completed successfully.");
                }
            }
        }


        //XML response string from SPS describing user's subscriptions
        protected string spsXML;       // the original XML from SPS

        public SubscriptionInfoSet Subscriptions;        // ... serialized nicely into a class...

        public string RawXML
        {
            get
            {
                if ( spsDataLoaded )
                {
                    return spsXML;
                }
                else
                {
                    throw new Exception("Cannot get XML till BdkLoad has completed successfully.");
                }
            }
        }


        public bool IsSPSLoaded
        {
            get
            {
                return spsDataLoaded;
            }
        }


        // this exposes the tracking guid of the last request to SPS
        protected string lastTrackingGUID = "";

        public string TrackingGUID
        {
            get
            {
                return lastTrackingGUID;
            }
        }


        #endregion

        #region CONSTRUCTORS

        //task: review whether the calling program will need to .Init and .Close the XOM stream
        public UserBillingInfo( )
        {
            // XomLoggingControl.Init();
        }


        ~UserBillingInfo( )
        {
            // XomLoggingControl.Close();
        }


        static UserBillingInfo( )
        {
            //task: fix this with a class that caches this info either from the DB or SPS

            //ANNUAL

            //after some deliberation, since this will work till Xenon ships,
            //and we'll likely need to touch this to make sure it fits Xenon billing plans,
            //the conclusion was that while this is ugly we will use it till Xenon
            YearlyRenewalOfferGUID.Add( 5,  "d38c0853-428a-4d2e-b184-20e074cf5e96" ); // AT
            YearlyRenewalOfferGUID.Add( 6,  "15663c58-9eed-4262-bb75-204154998761" ); // AU
            YearlyRenewalOfferGUID.Add( 8,  "372d5a85-d9c1-4380-99c6-8fa04f9b89a6" ); // BE
            YearlyRenewalOfferGUID.Add( 16, "d8d43036-b24a-4cc9-a1f5-ccaf2be2d257" ); // CA
            YearlyRenewalOfferGUID.Add( 18, "be556671-14b7-41b0-a378-ec71ab19f202" ); // CH
            YearlyRenewalOfferGUID.Add( 24, "2dec2aa3-5bd8-4b09-8451-c381b858f708" ); // DE
            YearlyRenewalOfferGUID.Add( 25, "d33ad0a1-00f3-4f7c-a3d0-c3ac3d46fb1e" ); // DK
            YearlyRenewalOfferGUID.Add( 31, "d48e1621-8194-406d-8a73-7d295fdd9bf5" ); // ES
            YearlyRenewalOfferGUID.Add( 32, "7a58cc29-6514-49bd-85e1-60f6655826b1" ); // FI
            YearlyRenewalOfferGUID.Add( 34, "124bce2e-3023-4e8f-bb59-81ec5159e540" ); // FR
            YearlyRenewalOfferGUID.Add( 35, "78869ae3-272d-412a-9e4d-d95234e7db4b" ); // GB
            YearlyRenewalOfferGUID.Add( 39, "1a75a520-1478-4283-b0f0-cfdda3b9851e" ); // HK
            YearlyRenewalOfferGUID.Add( 44, "d0e544bf-9887-4c35-ab7a-c6cd97f8edc9" ); // IE
            YearlyRenewalOfferGUID.Add( 50, "40aeaaef-88eb-4be7-96c0-8dfa8f07c8a0" ); // IT
            YearlyRenewalOfferGUID.Add( 53, "0d2769bc-87f4-452d-ae78-e869d0e5353e" ); // JP
            //Japan monthly renewal, for convenience
            // YearlyRenewalOfferGUID.Add( 53,  "a308b3f3-9363-4aad-9b84-cce6a830a10d" ); // JP

            //Korea is technically a "no-offer" renewal
            // YearlyRenewalOfferGUID.Add( 56,  "00000000-0000-0000-0000-000000000000" ); // KR
            YearlyRenewalOfferGUID.Add( 56, "76ef5d0c-25e6-4818-b25d-e2fbcd835c4b" ); // KR

            YearlyRenewalOfferGUID.Add( 71, "3c2a0496-aa0f-4f52-8894-f1297b40ed16" ); // MX
            YearlyRenewalOfferGUID.Add( 74, "ce1b60d7-e4eb-4602-93b5-c76ce919a1ff" ); // NL
            YearlyRenewalOfferGUID.Add( 75, "f271e08f-9770-4e5b-80b6-bdcbaaef2daa" ); // NO
            YearlyRenewalOfferGUID.Add( 76, "daa4917c-57c5-4663-b73e-b2d938c1b28d" ); // NZ
            YearlyRenewalOfferGUID.Add( 90, "ee370c59-6961-4382-a812-ff1e6f0b7cb9" ); // SE
            YearlyRenewalOfferGUID.Add( 91, "756593a9-ea20-4c49-b41a-aff91f6eb604" ); // SG
            YearlyRenewalOfferGUID.Add( 101, "5ba3c903-8ea0-4283-be95-6cd2d89e95a3" ); // TW
            YearlyRenewalOfferGUID.Add( 103, "ac47cd5a-99b5-4c0d-aa58-1e80e59be88c" ); // US

            // MONTHLY
            MonthlyRenewalOfferGUID.Add( 5,     "4ce5e6cd-3636-4edd-af32-7ca0030a8790" );
            MonthlyRenewalOfferGUID.Add( 6,     "4ca6d9f9-e007-48fe-aada-af906eddba17" );
            MonthlyRenewalOfferGUID.Add( 8,     "811313be-631e-4d65-b30f-bf8845b5fae3" );
            MonthlyRenewalOfferGUID.Add( 16,    "b6739e63-f17d-4af6-969b-3f0ee5f7bba4" );
            MonthlyRenewalOfferGUID.Add( 18,    "afce6fc3-43f1-440f-a59b-79b82e7af8e6" );
            MonthlyRenewalOfferGUID.Add( 24,    "b6ad6df0-56e9-4cc8-ad91-9e0cbadf9618" );
            MonthlyRenewalOfferGUID.Add( 25,    "418f78dc-918f-4749-aeb7-fe0cbb80126b" );
            MonthlyRenewalOfferGUID.Add( 31,    "8153ea6f-6a0d-4ca4-8085-e43ede4b5a8d" );
            MonthlyRenewalOfferGUID.Add( 32,    "e760868b-67c2-4b5e-815d-d0ab74829746" );
            MonthlyRenewalOfferGUID.Add( 34,    "8cb8c832-4089-4586-9405-b2186fba80f3" );
            MonthlyRenewalOfferGUID.Add( 35,    "072f986a-b233-43e4-94e0-d40092923373" );
            MonthlyRenewalOfferGUID.Add( 39,    "88d2f872-d0cf-4298-8eb6-2ba43beea9b8" );
            MonthlyRenewalOfferGUID.Add( 44,    "efa037a8-004d-4d73-b26c-6dc0a9c34d43" );
            MonthlyRenewalOfferGUID.Add( 50,    "1990a4f5-510f-4350-9ccd-b2bac3c43a38" );
            MonthlyRenewalOfferGUID.Add( 53,    "a308b3f3-9363-4aad-9b84-cce6a830a10d" );
            MonthlyRenewalOfferGUID.Add( 71,    "d90c4e2c-66b3-4032-aa48-76f8c6bda762" );
            MonthlyRenewalOfferGUID.Add( 74,    "5a77412a-06e7-413c-aa3a-ddf726c293fa" );
            MonthlyRenewalOfferGUID.Add( 75,    "096339fa-5898-487a-a4e5-2a197a5732e6" );
            MonthlyRenewalOfferGUID.Add( 76,    "92c9708f-d1d2-4c50-b3d8-2d96915f8cd9" );
            MonthlyRenewalOfferGUID.Add( 90,    "11016b6a-1085-43ad-bc76-c0b15b1a8ebe" );
            MonthlyRenewalOfferGUID.Add( 91,    "4dec59f9-09e7-45e7-a7fc-0215d0bdec3a" );
            MonthlyRenewalOfferGUID.Add( 101,   "9e0f68ef-b765-4bf7-9710-a75b05887515" );
            MonthlyRenewalOfferGUID.Add( 103,   "38352eb2-c6cf-4a1e-b1e5-6176973d66a9" );

        }


        #endregion

        #region Operators

        //task: improve formatting of the XML...
        public override string ToString()
        {

            return this.RawXML;
        }

        #endregion

        #region Public Instance Methods


        /// <summary>
        /// This is where we instantiate all the infrastructure to talk to SPS and test it.
        /// </summary>
        /// <returns></returns>
        public bool TestSPSConnection()
        {

            // no need to call .Init
            BillingProvider bp = new BillingProvider();
            //Console.WriteLine("\n Just before TestSPSConnection - user: " + BillingProvider.Username + " pswd " + BillingProvider.Password );

            Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_LOW, "UserBillingInfo: Calling Test SPS Connection. " );

            //let the exception bubble up..
            string response;
            bp.TestConnection( SPS_TEST_STRING, out response );
            //Console.WriteLine( "Test is: " + SPS_TEST_STRING + ", Response was: ||" + response + "||" );
            if ( response.IndexOf( SPS_TEST_STRING, 0, response.Length ) > 0 )
            {
                // all is good
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_LOW, "UserBillingInfo: Calling Test SPS Connection SUCCEED. " );
                return true;
            }
            else
            {
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_LOW, "UserBillingInfo: Calling Test SPS Connection FAILED to return test string. " );
                return false;
            }

        } // TestSPSConnection


        // fill in subscription information
        /// <summary>
        /// Loads user billing information from our billing provider (using their Billing Development Kit).
        /// </summary>
        /// <param name="PUID">Unique Live user identifier.</param>
        /// <param name="subscriptionID">Billing provider's subscription identifier.</param>
        public bool LoadBilling( User2 user )
        {

            bool loadSuccess = false;

            // no need to call .Init
            BillingProvider bp = new BillingProvider();

            uint puidHigh, csrHigh = 1;
            uint puidLow, csrLow = 1;
            string errorXML = "";
            string subscriptionXML = "";
            int subscriptionCount = 0;
            this.ownerPUID = user.OwnerPuid;

            Xom.Trace(XomAreaName.toolspslog, LogLevel.L_LOW, "UserBillingInfo.LoadBilling -> Calling SPS GetSubscriptions: puid " + user.Puid.ToString() + ", accountID " + user.AccountID);

            Int64Convert.ToUintPair( ( long ) user.Puid, out puidHigh, out puidLow);

            //task: delete if low/high info not needed.
//            StringBuilder logParams = new StringBuilder();
//            logParams.Append( "UserBillingInfo.Load: \n" );
//            logParams.Append( "  AccountID: " + user.AccountID );
//            logParams.Append( "  puidHi: " + puidHigh.ToString() + "  puidLow: " + puidLow.ToString() );
//            logParams.Append( "  CsrIDHigh: " + csrHigh.ToString() + " CsrIDLow" + csrLow.ToString() );

            try
            {
                //technically, we should have a CSR delegate ID for this, but
                //since SPS doesn't check (as long as it's 1,1), we can get away with this
                bp.GetSubscriptions(
                    (int) csrHigh,                          // int lDelegatePUIDHigh, DELEGATE = CSR or other person processing a request on behalf of a customer
                    (int) csrLow,                           // int lDelegatePUIDLow,
                    (int) puidHigh,                         // int lRequesterPUIDHigh, REQUESTOR = the person who owns this account
                    (int) puidLow,                          // int lRequesterPUIDLow
                    user.AccountID,                         // Instance of an offering purchased by a customer
                    out errorXML,
                    out subscriptionCount,
                    out subscriptionXML
                    );

                //task: remove debug code --> if hr ==  ??
//                Console.WriteLine( "ErrorXML: " + errorXML );
                loadSuccess = true;
                this.spsXML = subscriptionXML;

                // StringReaders allow us to provide a stream to XmlTextReader
                XmlTextReader xmlReader = new XmlTextReader( new StringReader( subscriptionXML ) );
                XmlSerializer serializer = new XmlSerializer( typeof( SubscriptionInfoSet ) );
                this.Subscriptions = ( SubscriptionInfoSet ) serializer.Deserialize( xmlReader );
                this.spsDataLoaded = true;
                xmlReader.Close();
            }

            //task: parse any soapexceptions - if it's "no user" throw UBINotFoundException, else rethrow
            catch (SoapException se)
            {
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "SoapException: " + se.ToString());
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - LoadBilling. SoapException: " + se.Detail.OuterXml + " User: " + user.OwnerPuid );
                throw se;
            }
            return loadSuccess;
        }


        /// <summary>
        /// Will return the index into the Items array within Subscriptions for the
        /// subscription which grants the user access to the Base Service.
        /// If the return value is -1, then the base subscription was not found for this user.
        /// </summary>
        /// <returns></returns>
        public int GetBaseSubscriptionIndex()
        {
            int index = -1;
            SubscriptionInfoSetSubscriptionInfo sub;

            //loop through all the users subscriptions looking at the enabled ones...
            for ( int iLoop = 0; iLoop < this.Subscriptions.Items.Length ; iLoop++ )
            {

                sub = this.Subscriptions.Items[ iLoop ];
                if ( sub.SubscriptionStatusInfo.SubscriptionStatus == BillingConstants.SubscriptionInfoEnabledString )
                {

                    //loop through all services for this subscription to see if one of them is the Base Subscription
                    // the "base subscription" is a subscription which is enabled and contains the "Base Service Offering"
                    // the Base Service Offering = "You Get Into Xbox Live"
                    // vs other subscriptions like a PSO Service Offer which means "You get into PSO"
                    for ( int iLoop2 = 0; iLoop2 < sub.ServiceInstanceSet.Length; iLoop2++ )
                    {

                        if ( sub.ServiceInstanceSet[ iLoop2 ].ServiceComponentId == BillingConstants.BaseServiceOfferingGUID )
                        {

                            //remember the base subscription
                            if ( index == -1 )
                            {
                                index = iLoop;
                            }
                            else
                            {
                                // PM assures me we should never see a user with multiple subscriptions with the Base service...
                                // the Exception below guarantees we'll catch the > 1 case, the exception at bottom catches the < 1 case
                                // this catches the case where there's a second Sub to the base service
                                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - GetBaseSubscription: User " + this.ownerPUID.ToString() + " has more than 1 base subscription.\n" + this.RawXML );
                                throw new Exception( "User :" + this.ownerPUID.ToString() + " has more than 1 Base subscription.  See log for details." );
                            }

                        } // if base service

                    }//for serviceinstances

                } //if enabled

            } // for subscriptions

            // if we're here and haven't found an enabled subscription with the base service... there's an issue
            if ( index == -1 )
            {
                // this catches the case where there's a second Sub to the base service
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - GetBaseSubscription: User " + this.ownerPUID.ToString() + " has no base subscription.\n" + this.RawXML );
                throw new Exception( "User no Base subscription. See log for details." );
            }

            this.baseSubscriptionIndex = index;
            return index;
        }


        /// <summary>
        /// NOTE: Deactivates the User account in SPS. To manage the user's account in UODB, use the User or User2 object...
        /// subIndex is the index of the subscription in the UserBillingInfo object which should be cancelled.
        /// </summary>
        /// <param name="subIndex">The index of the subscription in the UserBillingInfo object which should be cancelled.</param>
        /// <param name="commentText">The comment which should be added to the account to give the reason for the cancellation.</param>
        public void CancelSubcription( int subIndex, string commentText )
        {

            //guard clause
            if ( !spsDataLoaded )
            {
                throw new Exception("No operations on this object are allowed till Load is called successfully.");
            }
            if (
                ( subIndex > this.Subscriptions.Items.Length ) ||
                ( subIndex < 0 )
                )
            {
                throw new ArgumentException( "Invalid argument: the value for subIndex was invalid." );
            }

            string errorXML = "", amountCharged = "", rawSubscriptionStatusInfo = "", rawRemovedServiceInstanceSet = "";
            int removedServiceInstanceCount = 0;

            // no need to call Init, since the (int) override calls it correctly
            BillingProvider bp = new BillingProvider();
            PsoEncrypterClass encrypter = new PsoEncrypterClass();

            // the trackingGUID allows us to get the status of our request later...
            string trackingGUID = encrypter.GenerateGUID();
            this.lastTrackingGUID = trackingGUID;

            //NOTE: DO NOT set values for commenter or comment date,
            //      as these cause the call to stop working (bug in SPS)
            CommentInfo comment = new CommentInfo();
            comment.CommentCode = System.Convert.ToString( 200705 );    // CC_CONVERT_SUBSCRIPTION
            comment.CommentText = commentText;
            string commentXmlString = comment.ToXml();

            uint puidHigh, csrHigh = 1;
            uint puidLow, csrLow = 1;
            bool computeOnly = false;
            string nowString = "NOW";
            Int64Convert.ToUintPair( ( long ) this.ownerPUID, out puidHigh, out puidLow);

            StringBuilder logParams = new StringBuilder();
            logParams.Append( "\n UserBillingInfo.Deactivate: CancelSub - TrackGUID: " + trackingGUID );
            logParams.Append( "  SubID: " + this.Subscriptions.Items[ subIndex ].SubscriptionId );
            logParams.Append( "  puidHi: " + puidHigh.ToString() + "  puidLow: " + puidLow.ToString() );
            logParams.Append( "  CsrIDHi: " + csrHigh.ToString() + "  CsrIDLow: " + csrLow.ToString() );
            logParams.Append( "  Cmnt: " + commentXmlString + "  CancelDate: NOW \n");

            // Console.WriteLine( "Inside: Cancel - " + logParams.ToString() );

            Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_LOW, "UserBillingInfo - CancelSubscription. User: " + this.Subscriptions.Items[ subIndex ].FriendlyName + "  Subindex: " + subIndex.ToString() );
            Xom.Trace(XomAreaName.toolspslog, LogLevel.L_LOW, logParams.ToString());

            // Console.WriteLine( "\n past logging\n" );
            try
            {

                bp.CancelSubscription(
                    1,
                    1,
                    (int) puidHigh,
                    (int) puidLow,
                    trackingGUID,
                    computeOnly,
                    this.Subscriptions.Items[ subIndex ].SubscriptionId,
                    nowString,
                    commentXmlString,
                    out errorXML,
                    out amountCharged,
                    out rawSubscriptionStatusInfo,
                    out removedServiceInstanceCount,
                    out rawRemovedServiceInstanceSet
                    );

            }
            catch (SoapException se)
            {
                //task: log for pss, rethrow
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - CancelSubscription. SoapException: " + se.Detail.OuterXml + " User: " + this.Subscriptions.Items[0].FriendlyName + "  Subindex: " + subIndex.ToString() );
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "SoapException: " + se.ToString());
                // Console.WriteLine( "There was a SOAP exception: " + se.ToString()  );
                throw se;
            }

            //task: and then what? do I deserialize the new subscription status info?
        } // deactivate


        /// <summary>
        /// Basically a call to PurchaseOfferingEx. Maybe the code should call this directly?
        /// The only thing this encapsulates is the CSR Delegate ID values being 1,1.
        /// Return value is the SubscriptionID of the new subscription, if successful, if failed, then "".
        /// </summary>
        public string PurchaseSubscription( User2 u, string offeringGUID, string paymentInstrumentID, string shippingAddressID )
        {

            if ( !spsDataLoaded )
            {
                throw new Exception("No operations on this object are allowed till Load is called successfully.");
            }

            // no need to call Init, since the (int) override calls it correctly
            BillingProvider bp = new BillingProvider();

            // the trackingGUID allows us to get the status of our request later...
            PsoEncrypterClass encrypter = new PsoEncrypterClass();
            string trackingGUID = encrypter.GenerateGUID();
            this.lastTrackingGUID = trackingGUID;

            string resultXML = "", newSubscriptionID = "", amountChargedXML = "", addedServiceInstanceSet = "";
            int addedServiceInstances = 0;
            uint puidHigh, csrHigh = 1;
            uint puidLow, csrLow = 1;
            bool computeOnly = false;
            Int64Convert.ToUintPair( ( long ) u.Puid, out puidHigh, out puidLow);

            //no need to validate the offerGuid, since SPS will do this anyway
            try
            {
                bp.PurchaseOfferingEx(
                    (int) csrHigh,
                    (int) csrLow,
                    (int) puidHigh,
                    (int) puidLow,
                    trackingGUID,
                    computeOnly,
                    u.GamerTag,                 // SubscriptionId = friendly name = gamertag... go figure
                    u.AccountID,                // accountID
                    "",                         // baseSubscriptionID
                    offeringGUID,
                    0,                          // override amount
                    paymentInstrumentID,
                    shippingAddressID,
                    "",                         // SPS reserved - activation date
                    "",                         // SPS reserved - subscription end date
                    "",                         // referral set xml
                    "",                         // tokenID
                    "",                         // policy ID (used to purchase stuff)
                    0,                          // policy version
                    "",                         // signature date time
                    out resultXML,
                    out newSubscriptionID,
                    out amountChargedXML ,
                    out addedServiceInstances,
                    out addedServiceInstanceSet
                    );

            }
            catch (SoapException se)
            {
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - PurchaseSub. SoapException: " + se.Detail.OuterXml + " User: " + u.OwnerPuid + "  Offering: " + offeringGUID );
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "SoapException: " + se.ToString());
                Console.WriteLine( "There was a SOAP exception: " + se.ToString()  );
                throw se;
            }

            return newSubscriptionID;

        } // purchase offering


        /// <summary>
        /// Used to set the renewalOfferGUID.  This is the offer the user will renew into after their current offer's subscription reaches it's end date.
        /// It is the caller's responsibility to call AddComment and, if necessary Provision services.
        /// </summary>
        /// <param name="renewalOfferingGUID">The intended renewalOffering to change the subscription to reflect.</param>
        /// <param name="subIndex">The index of the subscription to change.</param>
        public void ConvertSubscriptionRenewal( string renewalOfferingGUID, int subIndex )
        {
            // guard clause
            if ( !spsDataLoaded )
            {
                throw new Exception("Operation is invalid till Load is successful.");
            }

            string errorXML, amountChargedXML, rawAddedServiceInstanceSet;
            string rawRemoveServiceInstanceSet;
            StringBuilder logParams = new StringBuilder();
            int removedServiceInstanceSetCount, addedServiceInstanceSetCount;

            BillingProvider bp = new BillingProvider();
            PsoEncrypterClass encrypter = new PsoEncrypterClass();
            string trackingGUID = encrypter.GenerateGUID();
            this.lastTrackingGUID = trackingGUID;

            uint puidHigh;
            uint puidLow;
            Int64Convert.ToUintPair( ( long ) this.ownerPUID, out puidHigh, out puidLow );

            logParams.Append( "UserBillingInfo.ConvertSubscriptionRenewal: ConvertSub - trackGUID: " + trackingGUID );
            logParams.Append( " FrName: " + this.Subscriptions.Items[ subIndex ].FriendlyName );
            logParams.Append( " SubID: " + this.Subscriptions.Items[ subIndex ].SubscriptionId );
            logParams.Append( " puidHi: " + puidHigh.ToString() + "  puidLow: " + puidLow.ToString() );
            logParams.Append( " RenewGUID: " + renewalOfferingGUID );

            Console.WriteLine("Parameters: \n" + logParams.ToString() );

            Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_LOW, "UserBillingInfo - ConvertSubscriptionRenewal. User: " + this.Subscriptions.Items[0].FriendlyName + "  Subindex: " + subIndex.ToString() + " renewInto " + renewalOfferingGUID );
            Xom.Trace(XomAreaName.toolspslog, LogLevel.L_LOW, logParams.ToString());

            try
            {
                bp.ConvertSubscriptionEx(
                    1,
                    1,
                    (int) puidHigh,
                    (int) puidLow,
                    trackingGUID,
                    false,
                    1,
                    0,
                    this.Subscriptions.Items[ subIndex ].FriendlyName,
                    this.Subscriptions.Items[ subIndex ].SubscriptionId,
                    renewalOfferingGUID,
                    0,                              // override - not implemented
                    "",                             // subscription end date - can be empty string
                    "",                             // ReferralSetXML - can be empty string
                    "",                             // paymentinstrumentID -- optional ?
                    "",                             // tokenID
                    "",                             // PolicyID  - can't find info on policy in the SPK
                    0,                              // PolicyVersion
                    "",                             // PolicySignatureDateTime
                    out errorXML,
                    out amountChargedXML,
                    out addedServiceInstanceSetCount,
                    out rawAddedServiceInstanceSet,
                    out removedServiceInstanceSetCount,
                    out rawRemoveServiceInstanceSet
                    );

            }
            catch(SoapException se)
            {
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UserBillingInfo - ConvertSubscriptionRenewal. SoapException: " + se.Detail.OuterXml + " User: " + this.Subscriptions.Items[0].FriendlyName + "  Subindex: " + subIndex.ToString() + " renewInto " + renewalOfferingGUID );
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "SoapException: " + se.ToString());
                throw se;
            }

        } // SetRenewalOffer



//delete this stuff once we're ready to ship... it's useful for troubleshooting during dev
                // find the error code --> log details for SPS and move on!
//                Console.WriteLine("There was a SOAP error " + se.ToString() );
//                Console.WriteLine("RAW XML\n Client FaultCode: " + SoapException.ClientFaultCode );
//                Console.WriteLine("DetailElementName " + SoapException.DetailElementName );
//                Console.WriteLine("MustUnderstandFaultCode " + SoapException.MustUnderstandFaultCode );
//                Console.WriteLine("ServerFaultCode " + SoapException.ServerFaultCode );
//                Console.WriteLine("VersionMismatchFaultCode " + SoapException.VersionMismatchFaultCode );
//                Console.WriteLine("Actor " + se.Actor );
//                Console.WriteLine("Code " + se.Code );
//                Console.WriteLine("Detail " + se.Detail.OuterXml );
//                Console.WriteLine("Message " + se.Message );
//                Console.WriteLine("Source " + se.Source );
//                Console.WriteLine("StackTrace " + se.StackTrace );
//                Console.WriteLine("TargetSite " + se.TargetSite );


        #endregion

        #region Public Static Methods

        //task: Methods in this region should really live in their own classes, they're just here for convenience

        /// <summary>
        /// Set the renewalOfferGUID
        /// </summary>
        public static string AddComment( string accountID, CommentInfo comment )
        {
            string errorXML = "";

            BillingProvider bp = new BillingProvider();

            Xom.Trace(XomAreaName.toolspslog, LogLevel.L_LOW, "UBI - AddComment " + comment.ToXml() + " for " + accountID);
            try
            {
                bp.AddComment(
                    1,
                    1,
                    accountID,
                    comment.ToXml(),
                    out errorXML
                    );
            }
            catch (SoapException se)
            {
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UBI - AddComment Exception:" + se.ToString() );
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "UBI - AddComment Exception:" + se.ToString());
            }
            return errorXML;
        }



        public static CommentInfoSet GetComments( string accountID )
        {
            string errorXML = "", commentInfoSetXml = "";
            int commentCount;
            CommentInfoSet comments = null;

            BillingProvider bp = new BillingProvider();

            Xom.Trace(XomAreaName.toolspslog, LogLevel.L_LOW, "UBI - GetComments for " + accountID);
            try
            {
                bp.GetComments(
                    1,
                    1,
                    accountID,
                    out errorXML,
                    out commentCount,
                    out commentInfoSetXml
                    );

                XmlSerializer commentSerializer = new XmlSerializer( typeof( CommentInfoSet ) );
                StringReader sr = new StringReader( commentInfoSetXml );
                comments = (CommentInfoSet) commentSerializer.Deserialize( sr );

            }
            catch (SoapException se)
            {
                Xom.Trace(XomAreaName.userbillinginfo, LogLevel.L_HIGH, "UBI - GetComments Exception:" + se.ToString() );
                Xom.Trace(XomAreaName.toolspslog, LogLevel.L_HIGH, "UBI - GetComments Exception:" + se.ToString());
            }
            return comments;

        }



        /// <summary>
        /// To be used primarily in testing scenarios.
        /// </summary>
        /// <returns></returns>
        public static UserBillingInfo Create()
        {
            UserBillingInfo ubi = new UserBillingInfo();
            ubi.spsDataLoaded = true;
            return ubi;
        }



        #endregion

    }  // UBI class

    public class UserBillingInfoNotFoundException : Exception, ISerializable
    {
        public UserBillingInfoNotFoundException( ) :  base( "Requested user not found." ) { }
        public UserBillingInfoNotFoundException( string gamertag ) :  base( "Requested User " + gamertag + " was not found." ) { }
        public UserBillingInfoNotFoundException( ulong puid ) :  base( "Requested User with puid " + puid.ToString() + " was not found." ) { }
        public UserBillingInfoNotFoundException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }
    }

    public class UserBillingInfoSubscriptionException : Exception, ISerializable
    {
        public UserBillingInfoSubscriptionException( ) :  base( "There was an issue with this user's subscriptions." ) { }
        public UserBillingInfoSubscriptionException( ulong puid, string errorString ) :  base( "User account with puid " + puid.ToString() + " has a subscription issue: " + errorString ) { }
        public UserBillingInfoSubscriptionException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__tools_3_none_12.4.56.0_none_55dc267bf2026240
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_tools_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6.manifest
XP_MANIFEST_PATH=manifests\x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6.cat
XP_CATALOG_PATH=manifests\x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6.cat
XP_PAYLOAD_PATH=x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_tools_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Backup1\DeActivator.cs ===
using Microsoft.Webstore.WstClient;

using System;
using System.Collections;
using System.Data;
using System.Text;

using xonline.common.billing;
using xonline.common.mgmt;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.deactivator)]
[assembly: XomAreaDefinition(XomAreaName.pss)]

namespace xonline.tools.framework
{
    // Why separate the decision from the action?  Doesn't this seem artificial and cumbersome?
    // The decision logic will start simple and grow more complicated in the future.
    // The goal here was to be able to isolate and test each part of this code separately: 
    //  - gathering the objects to inform the decision
    //  - make a decision based on the objects and business logic
    //  - take actions on objects in the DB
    // ==> this allows me to:
    //      Keep the .exe code very simple and easy to read
    //      Write tests for each part (gathering, deciding, acting) to confirm it's correct, independent of the other parts
    //      Reuse more of this code later

    // of course... then I go and develop tests for ProcessHash first, making it less interesting
    // to test the underlying methods... ugh.

    #region Constants and Enums

    // this enum is the RESULT of the DECISION TREE
    public enum ActionDecision 
    {
        NoAction, 
        LogForPSS, 
        DeactivateHash, 
        DeactivateHashAndAccount, 
        DeactivateHashChangeRenewalBlank, 
        DeactivateHashChangeRenewalAnnual, 
        DeactivateHashChangeRenewalMonthly,
        UnknownCase,
        MaxValue                                // This MUST be the last item in the enum
    };
    
    //task: add items to this for the UserBilling scenarios... 
    // this enum is the RESULT of the ACTION 
    public enum ProcessingResult 
    {
        VoucherDisabled,                    // the hash was successfully disabled
        VoucherUserNotDisabled,             // the hash had a user, so we didn't disable it
        VoucherNotFound,                    // the voucher's hash wasn't found
        VoucherAndUserDisabled,             // the user and hash were successfully disabled
        VoucherDisabledUserRenewalBlank,    // voucher disabled, and user set to blank
        VoucherDisabledUserRenewalAnnual,   // voucher disabled, and user renewal changed
        VoucherDisabledUserRenewalMonthly,  // voucher disabled, and user renewal changed
        LiveUserNotFound,                   // there was no corresponding Xbox Live user
        BillingUserNotFound,                // there was no corresponding account with our Billing Partner (SCG?)
        NoAction,                           // means for whatever reason, no action was taken
        LoggedForPSS,                       // logged for further investigation
        MaxValue                            // This MUST be the last item in the enum
    }

    #endregion


    /// <summary>
    /// Contains the meat of the code for the exe. Easier to test this way...
    /// </summary>
    public class DeActivator
    {

        public const string XBOX_DESCRIPTION_PREFIX = "XBX";
        public const string DeActivatorMessage = "Account Action by SubCodeMgr ";

        /// <summary>
        /// Process Hash coordinates loading, deciding and acting on this hash.  The action which 
        /// should be taken is returned.  The returned action is only taken if reportonly is false.
        /// </summary>
        /// <param name="hash">This is the hash to be processed.</param>
        /// <param name="hashonly">Boolean to determine whether to look up user accounts if present.  
        /// Hashonly --> deactivate hashes, !Hashonly --> process returns </param>
        /// <param name="reportonly">If true, no changes will be made.</param>
        public static ProcessingResult ProcessHash( byte[] hash, bool hashonly, bool reportonly, out ActionDecision actionDecision )
        {

            Voucher v;
            // ActionDecision action;
            actionDecision = ActionDecision.NoAction;

            try
            {
                // load the hash object
                v = Voucher.Load( hash );
            }
            catch (VoucherNotFoundException vnf)
            {
                //sometimes we might not find a hash, it's no big deal, log it an move on... 
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "ProcessHash: " + vnf.Message + "... Hash was: " + VoucherUtil2.HashByteToHexStr( hash ) );
                return ProcessingResult.VoucherNotFound;
            }             

            // decision logic begins here...
            // if we're touching hashes only OR the hash we found has no associated users... 
            if ( hashonly || ( v.VoucherUsage.Count == 0 ) )   
            {
                // then we have all the info to decide... 

                //task: add a try/catch here for decide or add exceptions so we can continue processing??

                //decide action - what is the proposed action to take?
                actionDecision = DecideAction( v );
                // Console.WriteLine("  ProcessHash: Decision on Voucher was " + actionDecision.ToString() );
                //take action - returns what really happened to the user
                return TakeAction( v, actionDecision, reportonly );

            }
            else  // otherwise, since we're changing users, we need more info before deciding what to do 
            {

                //only one use per voucher, or it's something for a person to fix
                if ( v.VoucherUsage.Count > 1 )
                {
                    Xom.Trace(XomAreaName.pss, LogLevel.L_ERROR, "ProcessHash: Voucher has more than one user: " + v.ToString());
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_ERROR, "ProcessHash: Voucher has more than one user: " + v.ToString() );
                    throw new Exception( "ProcessHash: Voucher has more than one user. See log for details." );
                }
            
                User2 u;
                UserBillingInfo ubi;
            
                try 
                {
                    //load user
                    u = User2.Load( ( ( VoucherUse ) v.VoucherUsage[ 0 ] ).puid );
            
                    //load user billing info
                    ubi = new UserBillingInfo( );
                    ubi.LoadBilling( u );

                }
                catch ( UserNotFoundException unfe )
                {
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_ERROR, "ProcessHash: " + unfe.ToString() + ". User was " + ( ( VoucherUse ) v.VoucherUsage[0] ).puid.ToString() );
                    return ProcessingResult.BillingUserNotFound;
                }
                catch ( UserBillingInfoNotFoundException ubinfe )
                {
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_ERROR, "ProcessHash: " + ubinfe.ToString() + ". Voucher was " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + ".  User was " + ( ( VoucherUse ) v.VoucherUsage[0] ).puid.ToString() );
                    return ProcessingResult.BillingUserNotFound;
                }
            
                //task: add a try/catch here for decide or act exceptions so we can continue processing??
                actionDecision = DecideAction( v, u, ubi );
                return TakeAction( v, u, ubi, actionDecision, reportonly );

            } // else (!hashonly)

        }


        /// <summary>
        /// Given a Voucher, decide what action should be taken if only deactivating hashes.  Use the overload
        /// of this function which also accepts user and userbillinginfo objects if /deactivateaccounts is selected.
        /// </summary>
        /// <param name="dav">DecideActionVoucher</param>
        public static ActionDecision DecideAction( Voucher dav )
        {

            // ProcessingResult.VoucherUserNotDisabled

            // if the voucher hasn't been used, then "deactivate"
            if ( dav.VoucherUsage.Count == 0 )
            {
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "ProcessHash: no uses, deactivate." );
                return ActionDecision.DeactivateHash;
            }
            else
            {
                // if hash is used, and hashonly => do nothing
                StringBuilder puids = new StringBuilder("", 80);
                foreach ( VoucherUse vu in dav.VoucherUsage )
                {
                    puids.Append( vu.ToString() );
                    puids.Append( "  " );
                }
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "ProcessHash: No Action, Voucher has " + dav.VoucherUsage.Count.ToString() + " uses. Puid List is: " + puids.ToString() );
                return ActionDecision.NoAction;
            }

        }



        /// <summary>
        /// Take the action on the Voucher specified in the ActionDecision parameter.  If reportOnly is true
        /// then no action is taken in any case, and the return value is the action which would 
        /// have been taken if reportOnly was false.
        /// ONLY USE THIS OVERLOAD for DEACTIVATING HASHES.  Do not use this overload if you want to deactivate accounts.
        /// </summary>
        /// <param name="v"></param>
        /// <param name="action"></param>
        /// <param name="reportOnly"></param>
        /// <returns></returns>
        public static ProcessingResult TakeAction( Voucher v, ActionDecision action, bool reportOnly )
        {
            // overload for handling deactivation
            //task: any bad voucher states to guard against?
            ProcessingResult result = ProcessingResult.NoAction;

            switch ( action )
            {                  
                case ActionDecision.NoAction:
                    // just log no action, the fancy footwork allows us to re-use this case for both (!reportonly && .NoAction) and for ( reportonly && * )
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeAction: No Action for voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + " || reportonly is " + reportOnly.ToString() );
                    result = ProcessingResult.NoAction;
                    break; 

                case ActionDecision.LogForPSS: 
                    // just write to PSS Log
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionwithBilling: LogForPSS. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + " || reportonly is " + reportOnly.ToString() );
                    Xom.Trace(XomAreaName.pss, LogLevel.L_LOW, "TakeActionwithBilling: LogForPSS. Voucher: " + VoucherUtil2.HashByteToHexStr(v.voucherhash) + " || reportonly is " + reportOnly.ToString());
                    break; 

                case ActionDecision.DeactivateHash: 
                    if ( reportOnly )
                    {
                        // just deactivate the unused hash
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeAction: Disable voucher " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + ". Readonly = true.");
                        result = ProcessingResult.NoAction;
                    }
                    else
                    {
                        // just deactivate the unused hash
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeAction: Disable voucher " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) );
                    
                        //disables all offers of this voucher
                        v.Disable();
                        v.Save();
                        result = ProcessingResult.VoucherDisabled;
                    }
                    break;

                case ActionDecision.DeactivateHashAndAccount:
                    // deactivate the unused hash and the associated account
                    // INVALID CASE for this method -> Invalid Action exception
                    throw new Exception("This is an invalid action in this case. There is a bug!");
                    //break;  
                
                // create other actions ???
                default:
                    // what happens if Action it isn't one of the Above?
                    // INVALID CASE for this method -> Invalid Action exception
                    throw new Exception("This is an invalid action in this case. There is a bug!");
                    //break; 

            } // end switch

            return result;
        } // take action



        /// <summary>
        /// Given a Voucher, User and UserBillingInfo decide what action should be taken
        /// </summary>
        /// <param name="v"></param>
        public static ActionDecision DecideAction( Voucher v, User2 u, UserBillingInfo ubi )
        {

            //thanks to bug 17266
            //if their account currently can't login, then we can quickly log this for PSS to deal with
            //their account status could be < 0 for a variety of reasons beyond our scope...
            // 0x8xxxxxxx denotes an error condition.  all those values are < 0 when casted as an int...
            if ( HResult.Failed( u.BillingAccountStatus ) )
            {
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: " + ActionDecision.LogForPSS + ".  Reason: User Account has an issue that prevents deactivating without further investigation." );
                return ActionDecision.LogForPSS;
            }


            //need to figure out what offer they're in and what they'll renew into...
            int baseSubscriptionIndex = -1;
            try 
            {
                baseSubscriptionIndex = ubi.GetBaseSubscriptionIndex();
            }
            catch ( UserBillingInfoSubscriptionException )
            {
                return ActionDecision.LogForPSS; 
            }

            //use the offeringguid from the subscription we found above
            //to find the bi_offer_id of this subscription (eg. 0xFFFE000080000008 for 12 Month Online Subscription for all countries)
            //in the t_offer_regions table.

            ulong currentOfferID = 0;
            ulong renewalOfferID = 0;
            ulong returnOfferID = 0;

            // now that we have the user's base subscription, we need to find out what offer 
            // they're currently in, and what offer they'll renew into
            using (WstConnection offerConn = new WstConnection( xonline.common.config.ConfigUtil.UodbWebstoreApp ) )
            {
                
                //exceptions get handled higher up
                offerConn.Open();
                WstCommand offerCmd = offerConn.CreateCommand();
                offerCmd.CommandType = CommandType.StoredProcedure;
                offerCmd.Partition = WstCommand.AnyPartition;
                
                //Look up the subscription's current OfferingID to find it's OfferID
                // offerCmd.CommandText = "select bi_offer_id from dbo.t_offer_regions with (nolock) where vc_billing_offer_id = @billing_offer_id and ti_country_id = @country_id";
                offerCmd.CommandText = "dbo.p_xbos_get_offerids_from_boid";

                offerCmd.Parameters.Add( "@billingofferid", SqlDbType.NVarChar, 36).Value = ubi.Subscriptions.Items[ baseSubscriptionIndex ].OfferingGUID;
                offerCmd.Parameters["@billingofferid"].Direction = ParameterDirection.Input;

                WstDataReader wr = offerCmd.ExecuteReader();

                if ( wr.Read() )
                {
                    //value returned by procedure is large neg, so this should get the right value... 
                    currentOfferID = (ulong) wr.GetInt64( 0 );
                    wr.Close();
                    wr = null;
                }
                else
                {
                    throw new Exception("Unable to retrieve an OfferID for the following BOID: " + ubi.Subscriptions.Items[ baseSubscriptionIndex ].OfferingGUID );
                }
                
                //Then, we lookup the subscription's RenewOfferingId in t_offer_regions to find it's offerID
                offerCmd.Parameters[ "@billingofferid" ].Value = ubi.Subscriptions.Items[ baseSubscriptionIndex ].RenewOfferingId;
                wr = offerCmd.ExecuteReader();

                if ( wr.Read() )
                {
                    renewalOfferID = (ulong) wr.GetInt64( 0 );
                    wr.Close();
                    wr = null;
                }
                else
                {
                    throw new Exception("Unable to retrieve an OfferID for the following BOID: " + ubi.Subscriptions.Items[ baseSubscriptionIndex ].RenewOfferingId );
                }

            } // using
            
            //task: remove debug code
            // Console.WriteLine("Decision: cur - 0x{0}, ren - 0x{1}", currentOfferID.ToString("X"), renewalOfferID.ToString("X") );

            //NOTE: All offers for a voucher must be equivalent, we'll take the first
            if ( v.VoucherOffers[ 0 ] != null )
            {
                returnOfferID = ( (VoucherOffer) v.VoucherOffers[ 0 ] ).offerID;
            }
            else
            {
                throw new Exception("DeActivatorDecision(v,u,ubi): Voucher had no offers");
            }

            Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: Curr " + currentOfferID.ToString("X") + ", Renew " + renewalOfferID.ToString("X") + ", Vchr/Rtn " + returnOfferID.ToString("X") );

            //Then the decision logic...
            //In short, we're trying to figure out if the subcode "value" they returned (the voucher)
            //is equal to something on their account ( renewal offer) that we can remove from their account
            //note: we cannot remove their main subscription while they have "chained" value          
            if ( OfferValues.IsOfferPairEquivalent( returnOfferID, renewalOfferID ) )
            {
                // Convert renewal to default renewal
                if ( u.CountryID == 53 ) // Japan Country ID
                {
                    //find user's default renewal
                    //go to t_offer_regions using japan countryID
                    //find the offering GUID which associate with that country and *monthly* renewal
                    // Japan:  0xFFFE00008000000B  monthly renewal
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: " + ActionDecision.DeactivateHashChangeRenewalMonthly );
                    return ActionDecision.DeactivateHashChangeRenewalMonthly;               
                }
                else
                {
                    //for every other country
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: " + ActionDecision.DeactivateHashChangeRenewalAnnual );
                    return ActionDecision.DeactivateHashChangeRenewalAnnual;
                    //find user's default renewal
                    //go to t_offer_regions using country id 
                    //find the offering GUID which associate with that country and yearly renewal
                    // All other Countries -- 0xFFFE00008000000C  Yearly Renewal
                }

            }
            else if ( OfferValues.IsOfferPairEquivalent( returnOfferID, currentOfferID ) 
                &&
                (
                OfferValues.IsOfferPairEquivalent( renewalOfferID, OfferValues.AnnualRenewal ) ||
                OfferValues.IsOfferPairEquivalent( renewalOfferID, OfferValues.MonthlyRenewal ) 
                )
                )
            {
                // cancel subscriptions 
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: " + ActionDecision.DeactivateHashAndAccount );
                return ActionDecision.DeactivateHashAndAccount;
            }
            else
            {
                // log for PSS
                Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "Decide: " + ActionDecision.LogForPSS );
                return ActionDecision.LogForPSS;
            }
                             

//task: delete old version of decision tree based on spec
//            //if current offer is annual or monthly renewal
//            if ( ( currentOfferID == OfferValues.AnnualRenewal ) || ( currentOfferID == OfferValues.MonthlyRenewal ) )
//            {
//                Console.WriteLine("Decision: annual or monthly");
//                omTrace( deactivator, L_LOW, "DecideAction: User's current offer is renewal - No Action. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "  User: " + u.OwnerPuid.ToString() );
//                return ActionDecision.NoAction;
//            } 
//            //if current offer is ( Starter Kit or PrePaid card ) or ( game trial or console trial ) or (prepaid 3 month)
//            else if ( 
//                ( OfferValues.IsOfferPairEquivalent( currentOfferID, OfferValues.StarterKit ) ) || 
//                ( OfferValues.IsOfferPairEquivalent( currentOfferID, OfferValues.GameTrial ) ) ||
//                ( OfferValues.IsOfferPairEquivalent( currentOfferID, OfferValues.PrePaid3Month ) )
//                )
//            {
//                //if renewal offer is annual or monthly renewal
//                if ( ( renewalOfferID == OfferValues.AnnualRenewal ) || ( renewalOfferID == OfferValues.MonthlyRenewal ) )
//                {
//                    omTrace( deactivator, L_LOW, "DecideAction: User's renewal offer is renewal - DeactivateHashAndAccount. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "  User: " + u.OwnerPuid.ToString() );
//                    return ActionDecision.DeactivateHashAndAccount;
//                }
//                    //else if renewal offer is Starter Kit or PrePaid card
//                else if ( 
//                    ( OfferValues.IsOfferPairEquivalent( renewalOfferID, OfferValues.StarterKit ) ) ||
//                    ( OfferValues.IsOfferPairEquivalent( renewalOfferID, OfferValues.PrePaid3Month ) )
//                    )
//                {
//                    //check if the value they're returning is the same offer as their renewal
//                    //iterate through voucherOffers (should be just one offer) to see if 
//                    // there is an offer of this voucher which is "StarterKit" or "PrePaid"
//                    bool sameOffer = false;
//                    foreach( VoucherOffer vo in v.VoucherOffers )
//                    {
//                        if ( OfferValues.IsOfferPairEquivalent( vo.offerID, renewalOfferID ) )
//                        {   
//                            sameOffer = true;
//                            break;
//                        }
//
//                    } //foreach
//
//                    if ( sameOffer ) 
//                    {
//                        //this retrieves the end date of the enabled Base subscription (sub which gives them the Xbox Live Service)
//                        System.DateTime endDate = System.Convert.ToDateTime( ubi.Subscriptions.Items[ baseSubscriptionIndex ].EndDate );
//                        if ( endDate >  System.DateTime.UtcNow.AddDays( 30 ) )
//                        {
//                            omTrace( deactivator, L_LOW, "DecideAction: User's end date is > 30 days - DeactivateHashChangeRenewal. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "  User: " + u.OwnerPuid.ToString() );
//                            // roughly means set renewal offering id to blank (there are country specifics)
//                            // (sps will come and clean it up later )
//                            return ActionDecision.DeactivateHashChangeRenewalBlank; 
//                        }
//                        else
//                        {
//                            if ( u.CountryID == 53 )  // Japan Country ID
//                            {
//                                //find user's default renewal
//                                //go to t_offer_regions using japan countryID
//                                //find the offering GUID which associate with that country and *monthly* renewal
//                                // Japan:  0xFFFE00008000000B  monthly renewal
//                                return ActionDecision.DeactivateHashChangeRenewalMonthly;
//                                // stick that offering GUID into the renewOfferingID
//
//                            }
//                            else if ( u.CountryID == 56 ) // Korea Country ID
//                            {
//                                // set renewOfferingID to blank
//                                omTrace( deactivator, L_LOW, "DecideAction: User's end date is > 30 days - DeactivateHashChangeRenewal. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "  User: " + u.OwnerPuid.ToString() );
//                                return ActionDecision.DeactivateHashChangeRenewalBlank; 
//                            }
//                            else
//                            {
//                                //for every other country
//                                return ActionDecision.DeactivateHashChangeRenewalAnnual;
//                                //find user's default renewal
//                                //go to t_offer_regions using country id 
//                                //find the offering GUID which associate with that country and yearly renewal
//                                // All other Countries -- 0xFFFE00008000000C  Yearly Renewal
//                                // stick that offering GUID into the renewOfferingID
//                            }
//                        } 
//                        
//                    } // sameOffer
//                    else
//                    {
//                        // log for pss
//                        return ActionDecision.LogForPSS;
//
//                    } // not same offer
//
//                }// if renewal offer prepaid
//
//            }// if current offer prepaid

//            //if we've done a good job, we never get here... 
//            Console.WriteLine("Decision: somehow getting to the end");
//            return ActionDecision.NoAction;

        } // decideaction ( with billing info )



        /// <summary>
        /// Take the action specified in the ActionDecision parameter on the Voucher, User and UserBillingInfo.  If reportOnly is true
        /// then no action is taken in any case, and the return value is the action which would 
        /// have been taken if reportOnly was false.
        /// ONLY USE THIS OVERLOAD for the DEACTIVATING ACCOUNTS option.  Do not use this overload if you *just* want to retire old hashes.
        /// </summary>
        /// <param name="v"></param>
        /// <param name="u"></param>
        /// <param name="ubi"></param>
        /// <param name="action"></param>
        /// <param name="reportonly"></param>
        /// <returns></returns>
        public static ProcessingResult TakeAction( Voucher v, User2 u, UserBillingInfo ubi, ActionDecision action, bool reportOnly )
        {
            // overload for handling returns
            ProcessingResult result = ProcessingResult.NoAction;

            switch ( action )
            {                  
                case ActionDecision.NoAction:
                    // log no action 
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: No Action. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + " OwnerPuid: " + u.OwnerPuid + " SPSAcctID: " + u.AccountID + " || reportonly is " + reportOnly.ToString() );
                    break; 

                case ActionDecision.LogForPSS: 
                    // just write to PSS Log
                    Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: LogForPSS. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + " OwnerPuid: " + u.OwnerPuid + " SPSAcctID: " + u.AccountID + " || reportonly is " + reportOnly.ToString() );
                    Xom.Trace(XomAreaName.pss, LogLevel.L_LOW, "TakeActionBilling: LogForPSS. Voucher: " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + " OwnerPuid: " + u.OwnerPuid + " SPSAcctID: " + u.AccountID + " || reportonly is " + reportOnly.ToString() + "\nSPS Raw XML is: \n" + ubi.RawXML );
                    result = ProcessingResult.LoggedForPSS;
                    break; 

                case ActionDecision.DeactivateHash: 
                    // INVALID CASE for this method -> Invalid Action exception
                    throw new Exception("DeactivateHash is an invalid action in DeactivateAccounts. There is a bug!");
                    // break;

                case ActionDecision.DeactivateHashAndAccount:
                    if ( reportOnly )
                    {
                        // just deactivate the unused hash
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashAndAccount " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() + ". Readonly = true.");
                        result = ProcessingResult.NoAction;
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashAndAccount " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() );

                        // deactivate the unused hash 
                        v.Disable();
                        v.Save();

                        //... and the associated account (and subscriptions)
                        // loop through all subscriptions, doing the base subscription *last*
                        int baseSub = ubi.GetBaseSubscriptionIndex();
                        for (int iLoop = 0; iLoop < ubi.Subscriptions.Items.Length ; iLoop ++ )
                        {
                            // if it's an XBX subscription, and not the base one, cancel it!
                            if ( 
                                 ( iLoop != baseSub ) && 
                                 ( ubi.Subscriptions.Items[ iLoop ].InternalSubscriptionDescription.IndexOf( XBOX_DESCRIPTION_PREFIX, 0 ) >= 0 ) 
                                )
                            {
                                ubi.CancelSubcription( iLoop, DeActivatorMessage + " voucherHash: " + v.voucherhash );
                            }
                        }

                        ubi.CancelSubcription( baseSub, DeActivatorMessage + " voucherHash: " + v.voucherhash );

                        // confirm it worked, at least for base subscription
                        UserBillingInfo ubi2 = new UserBillingInfo();
                        ubi2.LoadBilling( u );

                        if ( ubi2.Subscriptions.Items[ baseSub ].SubscriptionStatusInfo.SubscriptionStatus != "CANCELED" )
                        {
                            // it didn't work
                            Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeAction: Error - DeactivateHashChangeRenewalAnnual FAILED - " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() + " " );
                            throw new Exception("There was a failure during ConvertSubscriptionRenewal.");
                        }

                        result = ProcessingResult.VoucherAndUserDisabled;
                    }
                    break;  

                case ActionDecision.DeactivateHashChangeRenewalAnnual:
                    if ( reportOnly )
                    {
                        // deactivate hash and change renewal offer to annual renewal
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalAnnual " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() + ". Readonly = true.");
                        result = ProcessingResult.NoAction;
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalAnnual " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() );

                        // deactivate hash and change renewal offer to annual renewal
                        v.Disable();
                        v.Save();

                        int baseSubscriptionIndex = ubi.GetBaseSubscriptionIndex();

                        //have to cast country ID, or hashtable returns de nada
                        string annualRenewalOfferID = UserBillingInfo.YearlyRenewalOfferGUID[ (int) u.CountryID ].ToString();

                        // and the change the renewal for the associated account
                        ubi.ConvertSubscriptionRenewal( annualRenewalOfferID, baseSubscriptionIndex );
                        
                        //task: confirm the setting?

                        //if we get this far without an exception, we've succeeded... 
                        result = ProcessingResult.VoucherDisabledUserRenewalAnnual;
                    }
                    break;  

                case ActionDecision.DeactivateHashChangeRenewalMonthly:
                    if ( reportOnly )
                    {
                        // just deactivate the unused hash
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalMonthly " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() + ". Readonly = true.");
                        result = ProcessingResult.NoAction;
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalMonthly " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() );

                        // deactivate the unused hash 
                        v.Disable();
                        v.Save();

                        // and change the renewal for the associated account

                        int baseSubscriptionIndex = ubi.GetBaseSubscriptionIndex();
                        //have to cast country ID, or hashtable returns de nada
                        string monthlyRenewalOfferID = UserBillingInfo.MonthlyRenewalOfferGUID[ (int) u.CountryID ].ToString();
                        ubi.ConvertSubscriptionRenewal( monthlyRenewalOfferID, baseSubscriptionIndex );

                        //task: confirm the setting?

                        result = ProcessingResult.VoucherDisabledUserRenewalMonthly;
                    }
                    break;  


                //task: should probably remove this since we won't use it for Korea... 
                case ActionDecision.DeactivateHashChangeRenewalBlank:
                    if ( reportOnly )
                    {
                        // just deactivate the unused hash
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalBlank " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() + ". Readonly = true.");
                        result = ProcessingResult.NoAction;
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.deactivator, LogLevel.L_LOW, "TakeActionBilling: DeactivateHashChangeRenewalBlank " + VoucherUtil2.HashByteToHexStr( v.voucherhash ) + "User: " + u.OwnerPuid.ToString() );

                        // deactivate the unused hash 
                        v.Disable();
                        v.Save();

                        // and change the renewal for the associated account

                        int baseSubscriptionIndex = ubi.GetBaseSubscriptionIndex();
                        string monthlyRenewalOfferID = "00000000-0000-0000-0000-000000000000";
                        ubi.ConvertSubscriptionRenewal( monthlyRenewalOfferID, baseSubscriptionIndex );

                        //task: confirm the setting?

                        result = ProcessingResult.VoucherDisabledUserRenewalBlank;
                    }
                    break;  

                //task: create other actions ???
                default:
                    // what happens if Action it isn't one of the Above?
                    //task: INVALID CASE for this method -> Invalid Action exception

                    break; 
            } // end switch

            return result;

        } // take action 



    }// deactivator

    //task: new exception for invalid action

}// namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Backup1\MsgManager.cs ===
using System;
using System.Text;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.msgmanager)]

namespace xonline.tools.framework
{
	/// <summary>
	/// Encapsulates the core functionality of Msg Tool for future use... 
	/// </summary>
    public class MsgManager
    {

        //NOTE: the calling program will need to .Init and .Close the XOM stream

        public const string     DEFAULT_LOCALE      = "default";

        public static bool AddString( uint dwStringID, ushort wLanguage, string strText )
        {
            // By default messages epxire in 90 days
            return (0 != AddString(dwStringID, 0, new ushort[1] {wLanguage}, new string[1] {strText}, 0));
        }
        
        public static uint AddString( uint dwStringID, uint titleID, ushort [] wLanguage, string [] strText, ulong expireMinutes )
        {
            StringAddRequest request = new StringAddRequest();
            StringAddResponse response = new StringAddResponse();
            request.dwTitleID = (titleID == 0) ? XOn.DASH_TITLE_ID : titleID;  // Default to the Dash title ID  (0xFFFE0000) if not specified
            request.dwStringID = dwStringID;
            request.wDefaultLanguage = 1;                           // English is always the default
            request.dtExpire = (0 == expireMinutes) ? DateTime.UtcNow.AddYears( 20 ) : DateTime.UtcNow.AddMinutes(expireMinutes);  
            request.cLangStrings = 1;                               // We do one language at a time
            request.fVetText = false;

            // Make sure our arrays match
            if (wLanguage.Length != strText.Length)
            {
                Console.WriteLine( "Arrays passed to AddString do not match! Received " + wLanguage.Length + " languages and " + strText.Length + " strings." );                
                return 0;
            }
            
            request.rgLangStrings = new LanguageString[wLanguage.Length];
            for (int i=0; i<wLanguage.Length; i++)
            {
                request.rgLangStrings[i] = new LanguageString();
                request.rgLangStrings[i].wLanguage = wLanguage[i];
                request.rgLangStrings[i].wStringSize = System.Convert.ToUInt16( strText[i].Length );
                request.rgLangStrings[i].szString = strText[i];
            }
            
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            try
            {
                XRLObject2 xrlo = response;
                
                Console.WriteLine( "String Service address " + XRLUtil.GetServiceAddress( XOService.StringService ) );

                HResult hr = XRLUtil.PostXrlRequest( XOService.StringService, "/msgserver/addstring.ashx", fakedAuthData.GetBase64EncodedString(), request, ref xrlo );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: AddString - XRLUtil.PostXrlRequest returned hr = " + hr );
                    //Console.WriteLine( "Error: AddString - XRLUtil.PostXrlRequest returned hr = {0}", hr );
                    return 0;
                }                                    
            }
            catch( XrlRequestException e )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: AddString - XRLUtil.PostXrlRequest threw exception status=" +  e.StatusCode + ", Text=" + e.ToString() );
                //Console.WriteLine( "Error: AddString - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() );
                return 0;
            }

            return response.dwStringID;
            
        } // AddString

        public static bool AddUserMessage( ulong qwPUID, uint dwMessageFlags, uint dwStringID, ushort wExpiration )
        {
            // messages from the service are sent from the xbox 1 dash title id
            return AddUserMessage(new ulong[] {qwPUID}, 0xfffe0000, dwMessageFlags, dwStringID, wExpiration);
        }
        
        public static bool AddUserMessage( ulong [] qwPUIDs, uint titleID, uint dwMessageFlags, uint dwStringID, ushort wExpiration )
        {
            CUserMessage msg = new CUserMessage(
                0, // sender puid of 0, since we're the service, not an individual user
                0, // sender context of 0
                dwMessageFlags,
                titleID, 
                wExpiration,
                MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
                "LIVE" ); // sender name

            msg.AddRecipients(qwPUIDs);
            msg.AddProperty(MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, dwStringID);

            if(HResult.Failed(msg.Send()))
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: AddUserMessage - Send failed." );
                // Console.WriteLine( "Error: AddSystemMessage - Send failed." );
                return false;
            }

            return true;
        } //AddUserMessage


        public static bool AddTitleMessage( uint dwTitleID, uint dwMessageFlags, uint dwStringID, ushort wExpiration )
        {
            CSystemMessage msg = new CSystemMessage(
                dwTitleID,
                0, // qwSenderContext, 
                0, // dwRegion
                dwMessageFlags,
                wExpiration,
                MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
                "LIVE", // sender name
                DateTime.UtcNow,
                "LIVE Title" ); // max 64 character description for internal use only

            msg.AddProperty( MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, dwStringID );
            if( HResult.Failed( msg.Send() ) )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: AddTitleMessage - Send failed." );
                //Console.WriteLine( "Error: AddTitleMessage - Send failed." );
                return false;
            }                                    

            return true;
        } // AddTitleMessage


        public static bool AddSystemMessage( uint dwMessageFlags, uint dwStringID, ushort wExpiration )
        {
            CSystemMessage msg = new CSystemMessage(
                0, // dwTitleID - Title ID of zero indicates a system-wide message
                0, // qwSenderContext, 
                0, // dwRegion
                dwMessageFlags,
                wExpiration,
                MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
                "LIVE", // sender name
                DateTime.UtcNow,
                "LIVE System" ); // max 64 character description for internal use only

            msg.AddProperty( MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, dwStringID );

            if( HResult.Failed( msg.Send() ) )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: AddSystemMessage - Send failed." );
                // Console.WriteLine( "Error: AddSystemMessage - Send failed." );
                return false;
            }                                    

            return true;
        } // AddSystemMessage


        //GetString method to test if the string server has, in cache, a specific string... 
        public static bool CheckStringExists( uint stringId, uint titleId, string locale )
        {
            bool found = false;
            // code below is heavily borrowed from the Messaging front door... ;-)
            StringLookup2Request strrequest = new StringLookup2Request();

            if ( 0 == titleId )
            {
                // dash is default titleId
                strrequest.dwTitleID = XOn.DASH_TITLE_ID;
            }
            else
            {
                strrequest.dwTitleID = titleId;
            }
            strrequest.wLocaleLen = (ushort) locale.Length;
            strrequest.szLocale = locale;
            strrequest.wNumStrings = 1;
            strrequest.rgdwStringIDs = new uint[ 1 ];
            strrequest.rgdwStringIDs[ 0 ] = stringId;

            StringLookupResponse stringResponse = new StringLookupResponse();

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = stringResponse;

            //as a tool this doesn't have SGAuthInfo, so we fake it... 
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            // Call the String front door to handle the request
            HResult hr = XRLUtil.PostXrlRequest( XOService.StringService, strrequest.GetXRL(), fakedAuthData.GetBase64EncodedString(), strrequest, ref xrlo );
            if( !HResult.Failed( hr ) && 1 == stringResponse.wNumStrings && 0 != stringResponse.rgStringData[0].szString.Length )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_LOW, "String Lookup Response was " + stringResponse.wNumStrings + " strings, first was '" + stringResponse.rgStringData[0].szString.Length + "' chars long " );
                found = true;
            }
            else
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: response was " + stringResponse.wNumStrings + " strings, first was '" + stringResponse.rgStringData[0].szString.Length + "' chars long " );
                // Console.WriteLine( " response was {0} strings, first was '{1}' chars long ", stringResponse.wNumStrings, stringResponse.rgStringData[0].szString.Length );
                return false;
            }

            return found;
        }// CheckString


        //GetString method to test if the string server has, in cache, a specific string... 
        public static string GetString( ushort stringId, uint titleId, string locale )
        {
            string  data = "";
            // code below is heavily borrowed from the Messaging front door... ;-)
            StringLookup2Request strrequest = new StringLookup2Request();

            if ( 0 == titleId) 
            {
                // dash is default titleId
                strrequest.dwTitleID = XOn.DASH_TITLE_ID;
            }
            else
            {
                strrequest.dwTitleID = titleId;
            }
            strrequest.wLocaleLen = (ushort) locale.Length;
            strrequest.szLocale = locale;
            strrequest.wNumStrings = 1;
            strrequest.rgdwStringIDs = new uint[ 1 ];
            strrequest.rgdwStringIDs[ 0 ] = stringId;

            StringLookupResponse stringResponse = new StringLookupResponse();

            // For some reason PostXrlRequest won't accept a type that inherits from XRLObject2 for the response
            XRLObject2 xrlo = stringResponse;

            //as a tool this doesn't have SGAuthInfo, so we fake it... 
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            // Call the String front door to handle the request
            HResult hr = XRLUtil.PostXrlRequest( XOService.StringService, strrequest.GetXRL(), fakedAuthData.GetBase64EncodedString(), strrequest, ref xrlo );
            if( !HResult.Failed( hr ) && 1 == stringResponse.wNumStrings && 0 != stringResponse.rgStringData[0].szString.Length )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_LOW, "String Lookup Response was " + stringResponse.wNumStrings + " strings, first was '" + stringResponse.rgStringData[0].szString.Length + "' chars long " );
                data = stringResponse.rgStringData[0].szString;
            }
            else
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, "Error: response was " + stringResponse.wNumStrings + " strings, first was '" + stringResponse.rgStringData[0].szString.Length + "' chars long " );
                // Console.WriteLine( " response was {0} strings, first was '{1}' chars long ", stringResponse.wNumStrings, stringResponse.rgStringData[0].szString.Length );
            }

            return data;
            
        } // GetString

        public static bool VerifyUsersExist(ref FindUsersData [] users)
        {
            FindUsersMsg request = new FindUsersMsg();
            FindUsersReplyMsg response = new FindUsersReplyMsg();            
            XRLObject2 xrlo = (XRLObject2) response;
            uint    current = 0;
            
            HTTPAuthData fakedAuthData = new HTTPAuthData( );
            
            request.qwUserID = 0;

            while (current < users.Length)
            {
                uint    size = Math.Min((uint)(users.Length - current), (uint)100);                
                FindUsersData [] segment = new FindUsersData[size];

                Array.Copy(users, current, segment, 0, size);

                request.cdwQueries = size;
                request.rgQueries = segment;
                
                try
                {
                    HResult hr = XRLUtil.PostXrlRequest( XOService.PresNotification, "/xpnfront/xpresence.srf", fakedAuthData.GetBase64EncodedString(), request, ref xrlo );
                    if( HResult.Failed( hr ) )
                    {
                        Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: VerifyUsersExist - XRLUtil.PostXrlRequest returned hr = {0}", hr ) );
                        Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "More info: {0}", xrlo.ToString() ) );
                        
                        return false;
                    }
                }
                catch( XrlRequestException e )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: VerifyUsersExist - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() ) );
                    
                    return false;
                }
                catch( Exception e)
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "\nThere was an error during VerifyUsers: {0}\n", e.ToString() ) );
                    
                    return false;
                }

                // Copy the results back into the source array
                Array.Copy(response.rgResults, 0, users, current, size);                

                // Advance the current segment
                current += size;                
            }
            
            return true;
        }

        //Enumerate System Messages method to see what messages are currently in effect
        public static EnumerateSystemMessagesReply EnumerateSystemMessages( uint titleID )
        {
            EnumerateSystemMessagesMsg enumRequest = new EnumerateSystemMessagesMsg();
            // if titleID = 0, then its a request for System Messages
            enumRequest.dwTitleID = titleID;

            EnumerateSystemMessagesReply enumReply = new EnumerateSystemMessagesReply();
            XRLObject2 xReply = (XRLObject2) enumReply;

            //as a tool this doesn't have SGAuthInfo, so we fake it... 
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            try
            {
                HResult hr = XRLUtil.PostXrlRequest( XOService.MessagingService, "/xpnfront/xmessaging.srf", fakedAuthData.GetBase64EncodedString(), enumRequest, ref xReply );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: EnumerateSystemMessages - XRLUtil.PostXrlRequest returned hr = {0}", hr ) );
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "More info: {0}", xReply.ToString() ) );
                    //Console.WriteLine( "Error: EnumerateSystemMessages - XRLUtil.PostXrlRequest returned hr = {0}", hr );
                    //Console.WriteLine( "More info: {0}", xReply.ToString() );
                    return null;
                }
                else
                {
                    return enumReply;
                }

            }
            catch( XrlRequestException e )
            {
                //Console.WriteLine( "Error: EnumerateSystemMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() );
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: EnumerateSystemMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() ) );
                return null;
            }
            catch( Exception e)
            {
                // Console.WriteLine( "\nThere was an error during enumsysmsg: \n", e.ToString() );
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "\nThere was an error during enumsysmsg: {0}\n", e.ToString() ) );
                return null; // "Error in EnumerateSystemMessages.";
            }


        } // EnumerateSystemMessages
        

        // Delete System / Title Messages
        public static uint DeleteSystemMessages( uint titleID, uint msgID, uint revokeFlag )
        {
            DeleteSystemMessageMsg delRequest = new DeleteSystemMessageMsg();
            delRequest.dwTitleID = titleID;
            delRequest.dwMessageID = msgID;
            // system delete and revoke are the same message, with the change of one flag.
            // 0 - delete the message from the system queue
            // 1 - delete the message from the system queue and all user queues
            delRequest.dwFlags = revokeFlag;

            DeleteSystemMessageReply delReply = new DeleteSystemMessageReply();
            XRLObject2 xrlReply = (XRLObject2)delReply;

            //as a tool this doesn't have SGAuthInfo, so we fake it... 
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            try
            {
                HResult hr = XRLUtil.PostXrlRequest( XOService.MessagingService, "/xpnfront/xmessaging.srf", fakedAuthData.GetBase64EncodedString(), delRequest, ref xrlReply );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: DeleteSystemMessages - XRLUtil.PostXrlRequest returned hr = {0}.", hr ) );
                    // Console.WriteLine( "Error: DeleteSystemMessages - XRLUtil.PostXrlRequest returned hr = {0}", hr );
                    return hr;
                }
                if( HResult.Failed( delReply.hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: DeleteSystemMessages - DeleteSystemMessageReply returned hr = {0}.", delReply.hr ) );
                    // Console.WriteLine( "Error: DeleteSystemMessages - DeleteSystemMessageReply returned hr = {0}", delReply.hr );
                    return delReply.hr;
                }
                
            }
            catch( XrlRequestException e )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: DeleteSystemMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() ) );
                //Console.WriteLine( "Error: DeleteSystemMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() );
                return HResult.E_FAIL;
            }

            Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Message ID {0} deleted successfully.", msgID ) );
            // Console.WriteLine("Message ID " + msgID.ToString() + " deleted successfully.");
            return HResult.S_OK;

        } // Delete System / Title Messages


        public static EnumerateMessagesReply EnumerateUserMessageQueue( ulong qwUserPUID )
        {

            EnumerateMessagesMsg userEnum = new EnumerateMessagesMsg();
            userEnum.qwUserID = qwUserPUID;
            EnumerateMessagesReply userEnumReply = new EnumerateMessagesReply();
            // not sure if this is the efficient way to do this... 
            XRLObject2 xrlReply = (XRLObject2) userEnumReply;

            //as a tool this doesn't have SGAuthInfo, so we fake it... 
            HTTPAuthData fakedAuthData = new HTTPAuthData( );

            try
            {
                HResult hr = XRLUtil.PostXrlRequest( XOService.MessagingService, userEnum.GetXRL(), fakedAuthData.GetBase64EncodedString(), userEnum, ref xrlReply );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: EnumUserMessages - XRLUtil.PostXrlRequest returned hr = {0}", hr ) );
                    //Console.WriteLine( "Error: EnumUserMessages - XRLUtil.PostXrlRequest returned hr = {0}", hr );
                    throw new Exception( "Enumerate User Messages request returned a failed hr = " + hr );
                }
                else
                { 
                    userEnumReply = (EnumerateMessagesReply) xrlReply;
                    return userEnumReply;
                }

            }
            catch( XrlRequestException e )
            {
//                Console.WriteLine( "Error: EnumUserMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() );
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: EnumUserMessages - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() ) );
                throw e;
            }

        } // Enumerate User Messages


        // For user messages:
        //      Delete means RECIPIENT deletes message
        //      Revoke means SENDER deletes message 
        // Since the tool will generally specify a recipient, only DELETE will get implemented
        public static bool DeleteUserMessage( ulong userPUID, uint msgId, uint flags )
        {

            DeleteMessageMsg deleteMsg  = new DeleteMessageMsg();
            deleteMsg.qwUserID          = userPUID;                 // indicates the user (recipient)
            deleteMsg.dwMessageID       = msgId;                    // the id of the message to delete
            deleteMsg.dwFlags           = flags;                    // indicates revoke vs delete

            DeleteMessageReply deleteReply = new DeleteMessageReply();
            // not sure if this is the efficient way to do this... 
            XRLObject2 xrlReply = (XRLObject2) deleteReply;

            try
            {
                //HResult hr = XRLUtil.PostXrlRequest( XOService.MessagingService, "/xpnfront/xmessaging.srf", deleteMsg, ref xrlReply );
                HResult hr = XRLUtil.PostXrlRequest( XOService.MessagingService, "/xpnfront/xmessaging.srf", null, deleteMsg, ref xrlReply );
                if( HResult.Failed( hr ) )
                {
                    Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: DeleteUserMessage - XRLUtil.PostXrlRequest returned hr = {0}", hr ) );
                    return false;
                }
            }
            catch( XrlRequestException e )
            {
                Xom.Trace(XomAreaName.msgmanager, LogLevel.L_ERROR, String.Format( "Error: DeleteUserMessage - XRLUtil.PostXrlRequest threw exception status={0}, Text={1}.", e.StatusCode, e.ToString() ) );
                return false;
            }
            Xom.Trace(XomAreaName.msgmanager, LogLevel.L_LOW, String.Format( "Message ID {0} deleted successfully.", msgId.ToString() ) );
            return true;

        } // delete user msg


        public static string FormattedUserMessageQueue( EnumerateMessagesReply msgQ )
        {
            //                Console.WriteLine("");
            //                Console.WriteLine("SenderID    SentTime               MessageID  MFlg SenderTitleID ExpireDate");
            //                
            //                foreach (MessageSummary ms in userEnumReply.rgMessages)
            //                {
            //                    Console.WriteLine("{0} \t {1} {2} {3} {4} {5}", 
            //                        ms.qwSenderID,
            //                        MsgDefs.MsgTimeToDateTime( ms.mtSentTime ),
            //                        ms.dwMessageID,
            //                        ms.dwMessageFlags,
            //                        ms.dwSenderTitleID,
            //                        MsgDefs.MsgTimeToDateTime( ms.mtSentTime ).AddMinutes((double) ms.wExpireMinutes ));
            //                }
            //                
            //                Console.WriteLine( "" );
            //                Console.WriteLine( "End Enumeration." );
            
            if ( msgQ == null )
            {
                throw new ArgumentNullException( "The EnumerateMessagesReply parameter cannot be null." );
            }

            StringBuilder output = new StringBuilder( 1024 );

            if ( msgQ.cMessages == 0 )
            {
                output.Append( "There were no messages in this user's message queue." );
            }
            else
            {
                output.Append("\nSenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate\n");
                foreach (MessageSummary ms in msgQ.rgMessages)
                {
                    output.Append( 
                        String.Format( "{0}, {1}, {2}, {3}, {4}, {5}\n", 
                        ms.qwSenderID,
                        MsgDefs.MsgTimeToDateTime( ms.mtSentTime ),
                        ms.dwMessageID,
                        ms.dwMessageFlags,
                        ms.dwSenderTitleID,
                        MsgDefs.MsgTimeToDateTime( ms.mtSentTime ).AddMinutes((double) ms.wExpireMinutes )
                        )
                        );

                } // foreach

                output.Append( "\nEnd Enumeration.\n" );

            } //else

            return output.ToString();
        }


        public static string FormattedSystemMessageQueue( EnumerateSystemMessagesReply msgQ )
        {
 
            //                Console.WriteLine("TitleID     MsgID       Sent                    ExpireDate            Description");
            //                foreach (SystemMessageSummary ms in enumReply.rgMessages)
            //                {
            //                    Console.Write("{0}  {1}  {2}  {3}  {4}",
            //                        ms.dwTitleID,
            //                        ms.dwMessageID,
            //                        ms.dtSentTime,
            //                        // An offset in minutes from the sent time
            //                        ms.dtSentTime.AddMinutes((double) ms.wExpireMinutes), 
            //                        ms.szDescription
            //                        );
            //
            //                } // foreach
            //
            //                Console.WriteLine( "" );
            //                Console.WriteLine( "End Enumeration." );


            //"There was an XRLRequest Error in EnumerateSystemMessages."
            if ( msgQ == null )
            {
                throw new ArgumentNullException( "The EnumerateMessagesReply parameter cannot be null." );
            }

            StringBuilder output = new StringBuilder( 1024 );

            if ( msgQ.cMessages == 0 )
            {
                output.Append( "There were no messages in the system message queue." );
            }
            else
            {
                output.Append("\nTitleID, MsgID, Sent, ExpireDate, Description\n");
                foreach ( SystemMessageSummary ms in msgQ.rgMessages )
                {
                    output.Append( 
                        String.Format( "{0}, {1}, {2}, {3}, {4}\n",
                        ms.dwTitleID,
                        ms.dwMessageID,
                        ms.dtSentTime,
                        // An offset in minutes from the sent time
                        ms.dtSentTime.AddMinutes((double) ms.wExpireMinutes), 
                        ms.szDescription 
                        )
                        );

                } // foreach
                output.Append( "\nEnd Enumeration.\n" );
            } //else

            return output.ToString();

        } //format system msgs


	} // class MsgManager


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Backup1\User2.cs ===
using Microsoft.Webstore.WstClient;

using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Runtime.Serialization;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

[assembly: XomAreaDefinition(XomAreaName.user2)]

namespace xonline.tools.framework
{

    public class User2
    {

        // Why was it necessary to write a second User class?
        // 1. The current User class uses the WSReader shim, not the Webstore managed client
        // 2. Most of the code was copy-n-paste from User (with mods for Webstore 3.0 mgd client)
        // 3. Doing this allows Voucher and User to have similar semantics (Load, Create, Save, Delete, etc)
        // 4. New object is self-contained, not requiring ref WS connections to be passed in for some methods
        // 5. This new object doesn't require half the tree to be included...

        #region Private Variables

        protected ulong     puid;
        protected ulong     ownerPuid;
        protected ulong     userPassportPuid;
        protected ulong     ownerPassportPuid;
        protected byte      accountType;
        protected byte      allowXboxLogin;
        protected ulong     machinePuid;

        protected byte      countryID;
        protected int       languageID;
        protected int       cultureID;

    //billing info
        protected string    accountID;
        protected string    paymentInfoID;

        protected string    gamerTag;
        protected DateTime  birthdate;

        protected byte      ticketFlags;
        protected DateTime  accountResumeDate;
        protected int       suspensionLength;
        protected DateTime  voiceResumeDate;
        protected int       voiceBanLength;
        protected byte      nameChangeRequired;

        protected DateTime  acceptedTermsOfServiceDate;
        protected DateTime  resetDate;
        protected uint      billingAccountStatus;
//        protected int       accountStatusID;

        protected byte[]    billingPIN;

        protected int       parentalControlGroupID;
        protected byte      msOptIn;
        protected byte      partnerOptIn;

        protected int       tierID;
        protected byte      downgraded;

//        protected short     userFlags;

        protected DateTime  lastActivity;
        protected DateTime  lastWebActivity;
        protected DateTime  lastChangeDate;

        //task: if this isn't set anywhere, is it useful at all??
        protected bool      isNew = true;

        protected byte      hasMusicnetAccount;

        #endregion

        #region Constructors

        // so change in plans...
        // the public constructor will be for when you need to create a new user
        // accessing existing users will occur via the Load method,
        // since it makes sense to "load them from UODB"

//        //task: confirm constructor can only be called ONCE per instance
//        private User2( string Gamertag )
//        {
//            //task: other checks for gamertag validity before assigning?
//            if ( Gamertag.Length <= 16 )
//            {
//                this.gamerTag = Gamertag;
//                this.puid = 0;
//                this.isNew = true;
//            }
//            else
//            {
//                throw new Exception( "Invalid Gamertag Length." );
//            }
//        }

        //used internally in the Create/Load functions
        //this is to get folks used to the structure we'll use after ObjectSpaces ships,
        //and potentially to make sure certain operations occur in Create/Load scenarios.
        private User2( )
        {
            //task: is there something else to do here?
            this.isNew = true;
        }


        //    public User( ulong PUID )
        //    {
        //        //task: other checks for numeric validity?
        //        //task: what happens if a constructor takes an exception?
        //        if ( 0 != PUID)
        //        {
        //            this.puid = PUID;
        //            gamerTag = "";
        //        }
        //        else
        //        {
        //            throw new Exception( "Invalid PUID." );
        //        }
        //    }

        #endregion

        #region Public Property Accessors
        public ulong Puid
        {
            get { return puid; }
            set { puid = value; }
        }

        public ulong OwnerPuid
        {
            get { return ownerPuid; }
            set { ownerPuid = value; }
        }

        public ulong MachinePuid
        {
            get { return machinePuid; }
            set { machinePuid = value; }
        }

        public string GamerTag
        {
            get { return gamerTag; }
            set { gamerTag = value; }
        }

        public byte CountryID
        {
            get { return countryID; }
            set { countryID = value; }
        }

        public string AccountID
        {
            get { return accountID; }
            set { accountID = value; }
        }

        public string PaymentInfoID
        {
            get { return paymentInfoID; }
            set { paymentInfoID = value; }
        }

        public uint BillingAccountStatus
        {
            get { return billingAccountStatus; }
            set { billingAccountStatus = value; }
        }

        public DateTime Birthdate
        {
            get { return birthdate; }
            set { birthdate = value; }
        }

//        public int AccountStatusID
//        {
//            get { return accountStatusID; }
//
//            // this field is constrained to zero in v1 UODB. cannot be set.
//        }

        public byte TicketFlags
        {
            get { return ticketFlags; }
            set { ticketFlags = value; }
        }

//        public short UserFlags
//        {
//            get { return userFlags; }
//            set { userFlags = value; }
//        }

        public byte[] BillingPIN
        {
            get { return billingPIN; }
            set { billingPIN = value; }
        }

        public DateTime AccountResumeDate
        {
            get { return accountResumeDate; }
            set { accountResumeDate = value; }
        }

        public int SuspensionLength
        {
            get { return suspensionLength; }
            set { suspensionLength = value; }
        }

        public DateTime VoiceResumeDate
        {
            get { return voiceResumeDate; }
            set { voiceResumeDate = value; }
        }

        public int VoiceBanLength
        {
            get { return voiceBanLength; }
            set { voiceBanLength = value; }
        }


        public byte NameChangeRequired
        {
            get { return nameChangeRequired; }
            set { nameChangeRequired = value; }
        }

        public DateTime AcceptedTermsOfServiceDate
        {
            get { return acceptedTermsOfServiceDate; }
            set { acceptedTermsOfServiceDate = value; }
        }

        public DateTime ResetDate
        {
            get { return resetDate; }
            set { resetDate = value; }
        }

        public string BillingPMN
        {
            get { return gamerTag.Replace(' ', '_'); }
        }


        public string BillingOwnerPMN
        {
            get
            {
                if( puid == ownerPuid)
                {
                    return gamerTag.Replace(' ', '_');
                }
                else
                {
                    return gamerTag.Replace(' ', '_') + ".Owner";
                }
            }
        }

        #endregion

        #region Operators

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder( 100 );

            sb.Append( "User: " + this.GamerTag + " puid: " + this.puid.ToString() + " owner: " + this.ownerPuid.ToString() );
            sb.Append( "\n  ppUser: " + this.userPassportPuid.ToString() + " ppOwner: " + this.ownerPassportPuid.ToString() );
            sb.Append( "\n  Cty: " + this.countryID.ToString() + " bday: " + this.birthdate.ToString() );
            sb.Append( "\n  billAccID: " + this.accountID  + " payinfo: " + this.paymentInfoID );
            sb.Append( "\n  tktFlags: " + this.ticketFlags.ToString() );
            sb.Append( "\n  acctRes: " + this.accountResumeDate.ToString() + " suspLen: " + this.suspensionLength.ToString() );
            sb.Append( "\n  voiceRes: " + this.voiceResumeDate.ToString() + " vBanLen: " + this.VoiceBanLength.ToString() );
            sb.Append( "\n  nameChg: " + this.nameChangeRequired.ToString() + " accptTOS: " + this.acceptedTermsOfServiceDate.ToString() );
            sb.Append( "\n  rstDate: " + this.resetDate.ToString() + " billngAcctStatus: " + this.billingAccountStatus.ToString() + "  pin: " + this.billingPIN.ToString() );

            return sb.ToString();
        }


        #endregion

        #region Public Static Methods

        public static User2 Load( string gamerTag )
        {

            User2 u = null;

            // connect to UODB to get User info
            //task: what if gamertag is a machine in t_user_names???  XONLINE_E_PUID_IS_MACHINE
            using ( WstConnection userConn = new WstConnection( xonline.common.config.ConfigUtil.UodbWebstoreApp ) )
            {

                WstCommand userCmd;
                userConn.Open();

                userCmd = userConn.CreateCommand();
                //note: the service LOWERCASES the string before hashing..
                userCmd.Partition = WSClient.GetHashPartition( gamerTag, ConfigUtil.UodbWebstoreApp );
                userCmd.CommandType = CommandType.StoredProcedure;
                userCmd.CommandText = "p_xuacs_get_user_acct_by_name";

                userCmd.Parameters.Add( "@vc_gamertag", SqlDbType.NVarChar, 16).Value = gamerTag;
                userCmd.Parameters["@vc_gamertag"].Direction = ParameterDirection.Input;

                userCmd.Parameters.Add( "@bi_user_puid", SqlDbType.BigInt);
                userCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@hr", SqlDbType.BigInt);
                userCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                userCmd.ExecuteNonQuery();

                //just for debugging
                //Console.WriteLine("GT Load: GT {0}, ptn {1}, puid {2}, hr {3}", gamerTag, userCmd.Partition, userCmd.Parameters["@bi_user_puid"].Value, userCmd.Parameters["@hr"].Value );

                if ( 0 != (int) userCmd.Parameters["@hr"].Value )
                {
                    throw new UserNotFoundException( gamerTag );
                }

                //Now that we have the PUID ...
                u = User2.Load( System.Convert.ToUInt64( userCmd.Parameters["@bi_user_puid"].Value ) );

            } // using

            //review: should this be inside the Using stmt?
            return u;

        } // LoadFromGamertag


        public static User2 Load( ulong PUID )
        {

            //task: confirm this will reuse connections
            // connect to UODB to get User info
            // having it's own object allows it to avoid issues with caller
            //  and since we use connection pooling, using an existing connection already happens

            User2 u = null;

            using ( WstConnection userConn = new WstConnection(ConfigUtil.UodbWebstoreApp) )
            {

                WstCommand userCmd;
                userConn.Open();
                userCmd = userConn.CreateCommand();
                userCmd.CommandType = CommandType.StoredProcedure;
                //go straight for the PUID...
                userCmd.CommandText = "dbo.p_xuacs_get_user_acct";

                //this is essentially the way it's done in the original...
                userCmd.Partition = WSClient.GetHashPartition( PUID, ConfigUtil.UodbWebstoreApp );

                // INPUT PARAMETERS
                userCmd.Parameters.Add( "@bi_user_puid", SqlDbType.BigInt ).Value = PUID;
                userCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Input;

                // RETURN PARAMETER
                userCmd.Parameters.Add( "@hr", SqlDbType.Int );
                userCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                // OUTPUT PARAMETERS
                userCmd.Parameters.Add( "@bi_owner_puid", SqlDbType.BigInt );
                userCmd.Parameters["@bi_owner_puid"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@bi_user_passport_puid", SqlDbType.BigInt );
                userCmd.Parameters["@bi_user_passport_puid"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@bi_owner_passport_puid", SqlDbType.BigInt );
                userCmd.Parameters["@bi_owner_passport_puid"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@ti_account_type", SqlDbType.TinyInt );
                userCmd.Parameters["@ti_account_type"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@f_allow_xbox1_logon", SqlDbType.TinyInt );
                userCmd.Parameters["@f_allow_xbox1_logon"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@bi_machine_puid", SqlDbType.BigInt );
                userCmd.Parameters["@bi_machine_puid"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@ti_country_id", SqlDbType.TinyInt );
                userCmd.Parameters["@ti_country_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_language_id", SqlDbType.Int );
                userCmd.Parameters["@i_language_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_culture_id", SqlDbType.Int );
                userCmd.Parameters["@i_culture_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@vc_billing_account_id", SqlDbType.NVarChar, 255 );
                userCmd.Parameters["@vc_billing_account_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@vc_billing_payinfo_id", SqlDbType.NVarChar, 255 );
                userCmd.Parameters["@vc_billing_payinfo_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@vc_gamertag", SqlDbType.NVarChar, 16 );
                userCmd.Parameters["@vc_gamertag"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_birthdate", SqlDbType.DateTime );
                userCmd.Parameters["@dt_birthdate"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@si_ticket_flags", SqlDbType.SmallInt );
                userCmd.Parameters["@si_ticket_flags"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_acct_resume_date", SqlDbType.DateTime );
                userCmd.Parameters["@dt_acct_resume_date"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_suspension_length", SqlDbType.Int );
                userCmd.Parameters["@i_suspension_length"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_voice_resume_date", SqlDbType.DateTime );
                userCmd.Parameters["@dt_voice_resume_date"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_voice_ban_length", SqlDbType.Int );
                userCmd.Parameters["@i_voice_ban_length"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@ti_name_change_required", SqlDbType.TinyInt );
                userCmd.Parameters["@ti_name_change_required"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_accepted_tos", SqlDbType.DateTime );
                userCmd.Parameters["@dt_accepted_tos"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_reset_date", SqlDbType.DateTime );
                userCmd.Parameters["@dt_reset_date"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_billing_account_status", SqlDbType.Int );
                userCmd.Parameters["@i_billing_account_status"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@bin_acct_pin", SqlDbType.Binary, 4 );
                userCmd.Parameters["@bin_acct_pin"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_parental_control_group_id", SqlDbType.Int );
                userCmd.Parameters["@i_parental_control_group_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@f_ms_opt_in", SqlDbType.TinyInt );
                userCmd.Parameters["@f_ms_opt_in"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@f_partner_opt_in", SqlDbType.TinyInt );
                userCmd.Parameters["@f_partner_opt_in"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_change_datetime", SqlDbType.DateTime );
                userCmd.Parameters["@dt_change_datetime"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@i_tier_id", SqlDbType.Int );
                userCmd.Parameters["@i_tier_id"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@f_downgraded", SqlDbType.TinyInt );
                userCmd.Parameters["@f_downgraded"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_last_activity", SqlDbType.DateTime );
                userCmd.Parameters["@dt_last_activity"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@dt_last_web_activity", SqlDbType.DateTime );
                userCmd.Parameters["@dt_last_web_activity"].Direction = ParameterDirection.Output;

                userCmd.Parameters.Add( "@f_has_musicnet_account", SqlDbType.TinyInt );
                userCmd.Parameters["@f_has_musicnet_account"].Direction = ParameterDirection.Output;

                foreach( SqlParameter sp in userCmd.Parameters )
                {
                    Console.WriteLine( "Name: " + sp.ParameterName.PadRight(20) + "  Type: " + sp.SqlDbType.ToString().PadRight(10) );
                    //+ "  Value: " + sp.Value.ToString().PadRight(16)
                }


                // Go get the info, finally!
                userCmd.ExecuteNonQuery();

                //just for debugging
                //Console.WriteLine("PUID Load: PUID {0}, ptn {1}, hr {2}", PUID, userCmd.Partition, userCmd.Parameters["@hr"].Value );

                if ( (int) userCmd.Parameters["@hr"].Value != HResult.S_OK )
                {
                    throw new UserNotFoundException( PUID );
                }

                u = new User2();
                u.puid = PUID;
                u.ownerPuid = System.Convert.ToUInt64( userCmd.Parameters["@bi_owner_puid"].Value );
                u.userPassportPuid = System.Convert.ToUInt64( userCmd.Parameters["@bi_user_passport_puid"].Value );
                u.ownerPassportPuid = System.Convert.ToUInt64( userCmd.Parameters["@bi_owner_passport_puid"].Value );
                u.accountType = ( byte ) userCmd.Parameters["@ti_account_type"].Value;
                u.allowXboxLogin = ( byte ) userCmd.Parameters["@f_allow_xbox1_logon"].Value;
                u.machinePuid =  System.Convert.ToUInt64( userCmd.Parameters["@bi_machine_puid"].Value );
                u.countryID = ( byte ) userCmd.Parameters["@ti_country_id"].Value;
                u.languageID = ( int ) userCmd.Parameters["@i_language_id"].Value;
                u.cultureID = ( int ) userCmd.Parameters["@i_culture_id"].Value;
                u.accountID = ( string ) userCmd.Parameters["@vc_billing_account_id"].Value;
                u.paymentInfoID = ( string ) userCmd.Parameters["@vc_billing_payinfo_id"].Value;
                u.gamerTag  = ( string ) userCmd.Parameters["@vc_gamertag"].Value;
                u.birthdate = ( DateTime ) userCmd.Parameters["@dt_birthdate"].Value;
                u.accountResumeDate = ( DateTime ) userCmd.Parameters["@dt_acct_resume_date"].Value;
                u.suspensionLength  = ( int ) userCmd.Parameters["@i_suspension_length"].Value;
                u.voiceResumeDate   = ( DateTime ) userCmd.Parameters["@dt_voice_resume_date"].Value;
                u.voiceBanLength = ( int ) userCmd.Parameters["@i_voice_ban_length"].Value;
                u.nameChangeRequired = ( byte ) userCmd.Parameters["@ti_name_change_required"].Value;
                u.acceptedTermsOfServiceDate = ( DateTime ) userCmd.Parameters["@dt_accepted_tos"].Value;
                u.resetDate = ( DateTime ) userCmd.Parameters["@dt_reset_date"].Value;
                //note: an int being held as an object needs to get casted to an int first, then to a uint
                //      using System.Convert will cause an exception if there's a 0 or < 0 value in the int.
                u.billingAccountStatus = ( uint ) (int) userCmd.Parameters["@i_billing_account_status"].Value;
                u.billingPIN = ( byte [] ) userCmd.Parameters["@bin_acct_pin"].Value;
                u.parentalControlGroupID = ( int ) userCmd.Parameters["@i_parental_control_group_id"].Value;
                u.msOptIn = ( byte ) userCmd.Parameters["@f_ms_opt_in"].Value;
                u.partnerOptIn = ( byte ) userCmd.Parameters["@f_partner_opt_in"].Value;
                u.lastChangeDate = ( System.DateTime ) userCmd.Parameters["@dt_change_datetime"].Value;
                u.tierID = ( int ) userCmd.Parameters["@i_tier_id"].Value;
                u.downgraded = ( byte ) userCmd.Parameters["@f_downgraded"].Value;
                u.lastActivity = ( DateTime ) userCmd.Parameters["@dt_last_activity"].Value;
                u.lastWebActivity = ( DateTime ) userCmd.Parameters["@dt_last_web_activity"].Value;
                u.hasMusicnetAccount = ( byte) userCmd.Parameters["@f_has_musicnet_account"].Value;
            }   // using

            // just for debugging
            // Console.WriteLine("PUID Load: PUID {0}, owner {1}, gt {2}", u.Puid, u.OwnerPuid, u.GamerTag );
            return u;

        } // LoadFromPUID


        public static User2 Create()
        {
            //create a new user and return it
            //task: in the future, this will take a puid and gamertag, and reserve the name on user creation...

            User2 u = new User2();
            return u;

        }


        #endregion

        #region Public Instance Methods


        /// <summary>
        /// Update an existing User object in UODB.
        /// </summary>
        public void Save( )
        {
            if ( this.isNew )
            {
                //task: legacy item -- what the hell is NYI ??
                throw new Exception("NYI");
            }

            WstConnection userConn = new WstConnection(xonline.common.config.ConfigUtil.UodbWebstoreApp);
            WstCommand userCmd;
            userConn.Open();
            userCmd = userConn.CreateCommand();
            userCmd.CommandType = CommandType.StoredProcedure;

            //task: what about assigning the user puid?
            userCmd.CommandText = "p_xuacs_set_user_acct";

            // Return Value FROM the procedure
            userCmd.Parameters.Add( "@hr", SqlDbType.Int );
            userCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

            // Input parameters TO the Procedure
            userCmd.Parameters.Add( "@bi_user_puid", SqlDbType.BigInt ).Value = this.puid;
            userCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@bi_owner_puid ", SqlDbType.BigInt ).Value = this.ownerPuid;
            userCmd.Parameters["@bi_owner_puid"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@bi_user_passport_puid", SqlDbType.BigInt ).Value = this.userPassportPuid;
            userCmd.Parameters["@bi_user_passport_puid"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@bi_owner_passport_puid", SqlDbType.BigInt ).Value = this.ownerPassportPuid;
            userCmd.Parameters["@bi_owner_passport_puid"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@ti_account_type", SqlDbType.TinyInt ).Value = this.accountType;
            userCmd.Parameters["@ti_account_type"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@f_allow_xbox1_logon", SqlDbType.TinyInt ).Value = this.allowXboxLogin;
            userCmd.Parameters["@f_allow_xbox1_logon"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@ti_country_id", SqlDbType.TinyInt ).Value = this.countryID;
            userCmd.Parameters["@ti_country_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_language_id", SqlDbType.Int ).Value = this.languageID;
            userCmd.Parameters["@i_language_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_culture_id", SqlDbType.Int ).Value = this.cultureID;
            userCmd.Parameters["@i_culture_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@vc_billing_account_id", SqlDbType.NVarChar, 255 ).Value = this.accountID;
            userCmd.Parameters["@vc_billing_account_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@vc_billing_payinfo_id", SqlDbType.NVarChar, 255 ).Value = this.paymentInfoID;
            userCmd.Parameters["@vc_billing_payinfo_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@vc_gamertag", SqlDbType.NVarChar, 16 ).Value = this.gamerTag ;
            userCmd.Parameters["@vc_gamertag"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_birthdate", SqlDbType.DateTime ).Value = this.birthdate;
            userCmd.Parameters["@dt_birthdate"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@si_ticket_flags", SqlDbType.SmallInt ).Value = this.ticketFlags;
            userCmd.Parameters["@si_ticket_flags"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_acct_resume_date", SqlDbType.DateTime ).Value = this.accountResumeDate;
            userCmd.Parameters["@dt_acct_resume_date"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_suspension_length", SqlDbType.Int ).Value = this.suspensionLength;
            userCmd.Parameters["@i_suspension_length"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_voice_resume_date", SqlDbType.DateTime ).Value = this.voiceResumeDate;
            userCmd.Parameters["@dt_voice_resume_date"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_voice_ban_length", SqlDbType.Int ).Value = this.voiceBanLength;
            userCmd.Parameters["@i_voice_ban_length"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@ti_name_change_required", SqlDbType.TinyInt ).Value = this.nameChangeRequired;
            userCmd.Parameters["@ti_name_change_required"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_accepted_tos", SqlDbType.DateTime ).Value = this.acceptedTermsOfServiceDate;
            userCmd.Parameters["@dt_accepted_tos"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_reset_date", SqlDbType.DateTime ).Value = this.resetDate;
            userCmd.Parameters["@dt_reset_date"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_billing_account_status", SqlDbType.Int ).Value = this.billingAccountStatus;
            userCmd.Parameters["@i_billing_account_status"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@bin_acct_pin", SqlDbType.Binary, 4 ).Value = this.billingPIN;
            userCmd.Parameters["@bin_acct_pin"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@i_parental_control_group_id", SqlDbType.Int ).Value = this.parentalControlGroupID;
            userCmd.Parameters["@i_parental_control_group_id"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@f_ms_opt_in", SqlDbType.TinyInt ).Value = this.msOptIn;
            userCmd.Parameters["@f_ms_opt_in"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@f_partner_opt_in", SqlDbType.TinyInt ).Value = this.partnerOptIn;
            userCmd.Parameters["@f_partner_opt_in"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@f_downgraded", SqlDbType.TinyInt ).Value = this.downgraded;
            userCmd.Parameters["@f_downgraded"].Direction = ParameterDirection.Input;

            userCmd.Parameters.Add( "@dt_change_datetime ", SqlDbType.DateTime ).Value = System.DateTime.UtcNow;
            userCmd.Parameters["@dt_change_datetime"].Direction = ParameterDirection.Input;

            userCmd.ExecuteNonQuery();

            if ( (int) userCmd.Parameters["@hr"].Value != HResult.S_OK )
            {
                throw new Exception("Error saving " + puid + " in UODB! " + userCmd.Parameters["@hr"].ToString());
            }
        }



        #endregion

        #region BoneYard

        // contains partially implemented, but not needed methods and legacy code snippets

        //        /// <summary>
        //        /// Retrieves an existing user from UODB by Gamertag
        //        /// </summary>
        //        /// <param name="puid"></param>
        //        /// <returns name="User"></returns>
        //        public static User2 Load( string gamertag )
        //        {
        //            User2 u = new User2( gamertag );
        //            try
        //            {
        //                u.LoadFromGamertag();
        //                u.isNew = false;
        //            }
        //            catch (Exception e)
        //            {
        //                throw new Exception("No user information available.");
        //            }
        //
        //            return u;
        //        } // load
        //
        //        /// <summary>
        //        /// Retrieves an existing user from UODB by PUID
        //        /// </summary>
        //        /// <param name="puid"></param>
        //        /// <returns name="User"></returns>
        //        public static User2 Load( ulong loadPuid )
        //        {
        //            User2 u = new User2( );
        //            u.puid = loadPuid;
        //            try
        //            {
        //                u.LoadFromPUID();
        //                u.isNew = false;
        //            }
        //            catch (Exception e)
        //            {
        //                throw new Exception("No user information available.");
        //            }
        //
        //            return u;
        //
        //        } // load


        //    public UserBillingInfo GetBillingInfo(string SPSUrl)
        //    {
        //        //task: what information will we get from SPS?
        //        //task: how will that information be stored
        //
        //    }


        //task: implement this when needed
        //    public void CreateUser( ulong offerID, string serviceInstanceId )
        //    {
        //        SaveWithSubscription( offerID, serviceInstanceId );
        //    }

        //task: implement this only when needed
//        public void SaveWithSubscription( ulong offerID, string serviceInstanceId )
//        {
//
//            throw new Exception("This Method is not implemented yet!");
//
//            //task: figure out why there is a debug.assert here
//            if ( ! this.isNew )
//            {
//                //task: what the hell is NYI ??
//                throw new Exception("NYI");
//            }
//            // Debug.Assert( isNew == true );       // updating existing users with this not supported
//
//            WstConnection userConn = new WstConnection("UODB");
//            WstCommand userCmd;
//
//            try
//            {
//                userConn.Open();
//                userCmd = userConn.CreateCommand();
//                userCmd.CommandType = CommandType.StoredProcedure;
//
//                //go straight for the PUID...
//                userCmd.CommandText = "p_xuacs_add_user_with_sub";
//
//                // Return Value
//                userCmd.Parameters.Add( "@hr", SqlDbType.Int );
//                userCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;
//
//                // INPUT PARAMETERS TO THE PROCEDURE
//                userCmd.Parameters.Add( "@bi_user_puid", SqlDbType.BigInt ).Value = this.puid;
//                userCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@bi_owner_puid ", SqlDbType.BigInt ).Value = this.ownerPuid;
//                userCmd.Parameters["@bi_owner_puid"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@bi_machine_puid ", SqlDbType.BigInt ).Value = this.machinePuid;
//                userCmd.Parameters["@bi_machine_puid"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@ti_country_id", SqlDbType.TinyInt ).Value = this.countryId;
//                userCmd.Parameters["@ti_country_id"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@vc_billing_account_id", SqlDbType.NVarChar, 255 ).Value = this.accountId;
//                userCmd.Parameters["@vc_billing_account_id"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@vc_billing_payinfo_id", SqlDbType.NVarChar, 255 ).Value = this.paymentInfoId;
//                userCmd.Parameters["@vc_billing_payinfo_id"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@vc_gamertag", SqlDbType.NVarChar, 16 ).Value = this.gamerTag ;
//                userCmd.Parameters["@vc_gamertag"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_birthdate", SqlDbType.DateTime ).Value = this.birthdate;
//                userCmd.Parameters["@dt_birthdate"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@i_acct_status_id", SqlDbType.Int ).Value = this.accountStatusId;
//                userCmd.Parameters["@i_acct_status_id"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@si_ticket_flags", SqlDbType.SmallInt ).Value = this.ticketFlags;
//                userCmd.Parameters["@si_ticket_flags"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@si_user_flags", SqlDbType.SmallInt ).Value = this.userFlags;
//                userCmd.Parameters["@si_user_flags"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_acct_resume_date", SqlDbType.DateTime ).Value = this.accountResumeDate;
//                userCmd.Parameters["@dt_acct_resume_date"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@i_suspension_length", SqlDbType.Int ).Value = this.suspensionLength;
//                userCmd.Parameters["@i_suspension_length"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_voice_resume_date", SqlDbType.DateTime ).Value = this.voiceResumeDate;
//                userCmd.Parameters["@dt_voice_resume_date"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@i_voice_ban_length", SqlDbType.Int ).Value = this.voiceBanLength;
//                userCmd.Parameters["@i_voice_ban_length"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@ti_name_change_required", SqlDbType.TinyInt ).Value = this.nameChangeRequired;
//                userCmd.Parameters["@ti_name_change_required"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_accepted_tos", SqlDbType.DateTime ).Value = this.acceptedTOSDate;
//                userCmd.Parameters["@dt_accepted_tos"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_reset_date", SqlDbType.DateTime ).Value = this.resetDate;
//                userCmd.Parameters["@dt_reset_date"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@i_billing_account_status", SqlDbType.Int ).Value = this.billingAccountStatus;
//                userCmd.Parameters["@i_billing_account_status"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@bin_acct_pin", SqlDbType.Binary, 4 ).Value = this.billingPIN;
//                userCmd.Parameters["@bin_acct_pin"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@bi_offer_id", SqlDbType.BigInt ).Value = offerID;
//                userCmd.Parameters["@bi_offer_id"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@vc_service_instance_id", SqlDbType.NVarChar, 36 ).Value = serviceInstanceId;
//                userCmd.Parameters["@bi_offer_id"].Direction = ParameterDirection.Input;
//
//                //task: confirm this should keep the old behavior of setting this to 0
//                userCmd.Parameters.Add( "@ti_accept_msspam", SqlDbType.TinyInt ).Value = 0;
//                userCmd.Parameters["@ti_accept_msspam"].Direction = ParameterDirection.Input;
//
//                //task: confirm this should keep the old behavior of setting this to 0
//                userCmd.Parameters.Add( "@ti_accept_partnerspam", SqlDbType.TinyInt ).Value = 0;
//                userCmd.Parameters["@ti_accept_partnerspam"].Direction = ParameterDirection.Input;
//
//                userCmd.Parameters.Add( "@dt_change_datetime ", SqlDbType.DateTime ).Value = System.DateTime.UtcNow;
//                userCmd.Parameters["@dt_change_datetime"].Direction = ParameterDirection.Input;
//
//                //task: make sure this is right!!
//                // hash value returned is correct
//                // puid -> long
//                //
//                userCmd.Parameters.Add( "@si_hash_bucket", SqlDbType.Int ).Value = WstHash.GetHash( ( long ) this.puid, userConn.LogicalPartitions );
//                userCmd.Parameters["@si_hash_bucket"].Direction = ParameterDirection.Input;
//
//                userCmd.ExecuteNonQuery();
//
//            }// try
//            catch (Exception e)
//            {
//                //task: do something
//            }
//
//            // now we can .Save this if we need to
//            this.isNew = false;
//
//        } // SaveWithSubscription
//


//        public void ResetPassword()
//        {
//            throw new Exception("This Method is not implemented yet!");
//
//            //task: what is the NYI exception???
//            if ( isNew == true )
//            {
//                throw new Exception( "NYI" );
//            }
//
//            byte[] rawKey;
//            byte[] encKey;
//            byte[] iv;
//            byte[] SPPA;
//            byte[] PPA;
//
//            // generate a new key.
//            KEKCryptoMgr.GenerateNewKey( out iv, out encKey, out rawKey );
//
//            // generate new PPA data
//            KEKCryptoMgr.GenPPAforDBWrp( gamerTag, (byte[])rawKey.Clone(), out SPPA, out PPA );
//
//            ResetPassword(encKey, iv, SPPA, PPA);
//
//        }


//        public void ResetPassword(byte[] key, byte[] iv, byte[] SPPA, byte[] PPA)
//        {
//            throw new Exception("This Method is not implemented yet!");
//
//            if ( isNew == true )
//            {
//                throw new Exception("NYI");
//            }
//
//            WstConnection resetConn = new WstConnection("UODB");
//            WstCommand resetCmd;
//
//            try
//            {
//                resetConn.Open();
//                resetCmd = resetConn.CreateCommand();
//                resetCmd.CommandType = CommandType.StoredProcedure;
//
//                //go straight for the PUID...
//                resetCmd.CommandText = "p_xuacs_set_reset_key";
//
//                // Return Value
//                resetCmd.Parameters.Add( "@hr", SqlDbType.Int );
//                resetCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;
//
//                // INPUT PARAMETERS TO THE PROCEDURE
//                resetCmd.Parameters.Add( "@gamertag", SqlDbType.NVarChar, 100 ).Value = this.gamerTag ;
//                resetCmd.Parameters["@gamertag"].Direction = ParameterDirection.Input;
//
//                // @key binary(16),
//                resetCmd.Parameters.Add( "@key", SqlDbType.Binary, 16 ).Value = key;
//                resetCmd.Parameters["@key"].Direction = ParameterDirection.Input;
//
//                resetCmd.Parameters.Add( "@iv", SqlDbType.NVarChar, 16 ).Value =  iv;
//                resetCmd.Parameters["@iv"].Direction = ParameterDirection.Input;
//
//                resetCmd.Parameters.Add( "@i_kek_version", SqlDbType.Int ).Value = KEKCryptoMgr.GetKeyVersion();
//                resetCmd.Parameters["@i_kek_version"].Direction = ParameterDirection.Input;
//
//                resetCmd.Parameters.Add( "@bin_SPPA", SqlDbType.Binary, 20 ).Value =  SPPA;
//                resetCmd.Parameters["@bin_SPPA"].Direction = ParameterDirection.Input;
//
//                resetCmd.Parameters.Add( "@bin_PPA", SqlDbType.Binary, 8 ).Value =  PPA;
//                resetCmd.Parameters["@bin_PPA"].Direction = ParameterDirection.Input;
//
//                resetCmd.ExecuteNonQuery();
//
//                // the SP should return zero on OK, nonzero on failure
//                if( ( int ) resetCmd.Parameters["@hr"].Value != HResult.S_OK )
//                {
//                    //task: int -> uint conversion ???
//                    throw new XRLException( ( uint ) resetCmd.Parameters["@hr"].Value , XEvent.Id.COMMON_CODE_207, "Error setting key for user " + this.puid.ToString() + " ." );
//                }
//
//                // Having updated the key, now update the object with the key reset time.
//                // basically, if the caller saves this user, this will get updated
//                //task: check if this is critical -- if it is, the we need a transaction
//                resetDate = DateTime.UtcNow;
//                // this.Save();
//
//            } // try
//            catch (Exception e)
//            {
//                //task: do something here!
//            }
//
//        } // reset password

        #endregion

    } // class User

    public class UserNotFoundException : Exception, ISerializable
    {
        const string message = "Requested user not found in database.";
        public UserNotFoundException( ) :  base( message ) { }
        public UserNotFoundException( string gamertag ) :  base( "Requested User " + gamertag + " was not found in database." ) { }
        public UserNotFoundException( ulong puid ) :  base( "Requested User with puid " + puid.ToString() + " was not found in database." ) { }
        public UserNotFoundException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }

    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Backup1\VoucherHelpers.cs ===
using System;
using System.Text;


namespace xonline.tools.framework
{


    /// <summary>
    /// Stores repeating information about a voucher's offers.
    /// </summary>
    public class VoucherOffer
    {
        // this is the "thing" this voucher gets you, offerID is same across all regions (Offer Guids are not)
        public ulong    offerID;
        // how many uses are allowed for this voucheroffer?
        public int      useCount;
        // active or disabled?
        public byte     status;

        public VoucherOffer()  {}

        public static bool operator == ( VoucherOffer a, VoucherOffer b )
        {
            if (
                ( a.offerID == b.offerID ) &&
                ( a.useCount == b.useCount ) &&
                ( a.status == b.status )
                )
                return true;
            else
                return false;
        }


        public static bool operator != ( VoucherOffer a, VoucherOffer b )
        {
            return ! ( a == b );
        }


        public override bool Equals( object obj )
        {
            if ( ! ( obj is VoucherOffer ) )
                return false;
                    
            if ( this == ( VoucherOffer ) obj )
                return true;
            else
                return false;
        }


        public override int GetHashCode()
        {
            return this.offerID.GetHashCode();
        }


        public override string ToString()
        {
            StringBuilder sb = new StringBuilder(50);

            sb.Append( " offer: " + offerID.ToString() );
            sb.Append( " uses: " + useCount.ToString() );
            sb.Append( " status: " + status.ToString() );

            return sb.ToString();

        }


    }

        /// <summary>
        /// Information about a single usage of a voucher.
        /// </summary>
    public class VoucherUse
    {
        public      ulong       puid;
        public      DateTime    whenUsed;

        public VoucherUse()  {}

        public static bool operator == ( VoucherUse a, VoucherUse b )
        {
            if (
                ( a.puid == b.puid ) &&
                ( a.whenUsed == b.whenUsed )
                )
                return true;
            else
                return false;
        }

        public static bool operator != ( VoucherUse a, VoucherUse b )
        {
            return ! ( a == b );
        }

        public override bool Equals(object obj)
        {
            if ( ! ( obj is VoucherUse ) )
                return false;
                    
            if ( this == ( VoucherUse ) obj )
                return true;
            else
                return false;
        }

        public override int GetHashCode()
        {
            return this.puid.GetHashCode();
        }

        public override string ToString()
        {

            StringBuilder sb = new StringBuilder();
            
            sb.Append( " puid :" + this.puid.ToString() );
            sb.Append( " dateused: " + this.whenUsed.ToString() );

            return sb.ToString();

        }


    }
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\toolsmgmt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__tools_3_none_12.4.56.0_none_55dc267bf2026240
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_tools_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6.manifest
XP_MANIFEST_PATH=manifests\x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6.cat
XP_CATALOG_PATH=manifests\x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6.cat
XP_PAYLOAD_PATH=x86__tools_3_no-public-key_12.4.56.0_x-ww_59a644c6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_tools_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\toolsmgmt\DBTypes.cs ===
namespace xonline.server.webcache.toolsmgmt.common
{
	enum JobState
	{
		Created = 0,
		Pending = 10,
		Download = 20,
		Running = 21,
		Canceled = 30,
		Completed = 31,
		Failed = 32
	}

	enum JobPriority
	{
		Normal = 0,
		Urgent = 10
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\tools\tools\Backup1\Voucher.cs ===
using Microsoft.Webstore.WstClient;
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.Serialization;
using System.Text;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.sql.webstore;
using xonline.common.service;

[assembly: XomAreaDefinition(XomAreaName.voucher)]

namespace xonline.tools.framework
{

    /// <summary>
    /// Voucher a very simple object-oriented layer over the Voucher-related UODB procedures.
    /// This class should be used to work with a single voucher at a time.
    /// This does not use or inherit from CVoucher, since that class is sealed,
    /// and doesn't use WS3.0 managed client directly.  Using it would make WSREADERLib
    /// a requirement for this tool.
    /// I did, however, make extensive use of the already-written code.
    ///
    /// NOTE: currently, in UODB, there are Vouchers associated with multiple offers.
    /// This was done during the beta so that the same subscription codes could support
    /// either the 15-month, 14-month (etc) time spans, depending on when you joined the beta.
    /// The idea was for them all to expire on the same month (1 year from 11/15/2002)
    /// even though folks might start at different times.  Offers were set up with the appropriate
    /// dates so that the appropriate offer would be used during each month.
    /// This should NOT be the case going forward, as most Vouchers will only be associated
    /// with one offerid.
    ///
    /// Glossary note:
    /// SHA1Hash( SubscriptionCode ) = hash = voucher
    ///

    /// </summary>
    public class Voucher
    {

        #region Private / Protected variables

        protected byte[]    hashBytes;
        protected int       voLoadCount;                // number of vos loaded - to make sure nobody deletes a VO until that's supported
        protected int       vuLoadCount;                // number of vus loaded - to make sure nobody deletes a VU until that's supported

        public ArrayList    VoucherOffers;
        public ArrayList    VoucherUsage;

        #endregion

        #region Constructors

        // create a new voucher

        /// <summary>
        /// Create a new Voucher object from a Subscription Code
        /// </summary>
        /// <param name="SubCode"></param>
        private Voucher( string SubCode )
        {
            this.hashBytes = VoucherUtil2.SubcodeStringToHashByte( SubCode );
        }

        /// <summary>
        /// Create a new Voucher from a byte array representing the hash of the Subscription code.
        /// </summary>
        /// <param name="hash"></param>
        private Voucher( byte[] hash )
        {

            if ( hash.Length == VoucherHashSize )
            {
                hashBytes = new byte[VoucherHashSize];
                hash.CopyTo( hashBytes, 0 );
            }
            else
                throw new ArgumentException("Byte[] passed in is not of size {0}.", System.Convert.ToString(VoucherHashSize) );
        }

        #endregion

        #region Properties

        /// <summary>
        /// Get a copy of the internal byte array. NOT a reference.
        /// </summary>
        public byte[] voucherhash
        {
            //review: do I need a separate private variable?
            get
            {
                //review: use the clone method here?
                byte [] hb = new byte[ VoucherHashSize ];
                hashBytes.CopyTo( hb, 0 );
                return hb;
            }
        }

        #endregion

        #region Operators

        // yeah, this is a bit much for dev purposes, but
        // it will make my unit test code much simpler... :-)
        public static bool operator == (Voucher a, Voucher b)
        {

            Console.WriteLine("Voucher a - l={0}, hash: {1}, voC: {2}, vuC: {3}", a.hashBytes.Length, VoucherUtil2.HashByteToHexStr( a.hashBytes ), a.VoucherOffers.Count, a.VoucherUsage.Count );
            Console.WriteLine("Voucher b - l={0}, hash: {1}, voC: {2}, vuC: {3}", b.hashBytes.Length, VoucherUtil2.HashByteToHexStr( b.hashBytes ), b.VoucherOffers.Count, b.VoucherUsage.Count );

            //short cut the process if possible...
            if (
                ( a.hashBytes.Length != b.hashBytes.Length ) ||
                ( a.VoucherOffers.Count != b.VoucherOffers.Count ) ||
                ( a.VoucherUsage.Count != b.VoucherUsage.Count )
                )
            {
                return false;
            }

            // compare the hash
            //task: is the fastest way to do this?  couldn't I compare the number they mean??
            //USE: VoucherUtil2.HashByteToHexStr
            int i;
            for (i=0; ( i < a.hashBytes.Length ) ; i++)
            {
                if ( a.hashBytes[ i ] != b.hashBytes[ i ] )

                {
                    return false;
                }
            }

            // if we checked to the end, then they were equal, otherwise we just got to the end of one array... ;-)
            if ( ! ( i == a.hashBytes.Length ) )
            {
                return false;
            }

            // compare the offers associated with the Voucher
            // since these should only have 1 offer... I can cheat for now
            // and just use the clause of the if above
            //task: come back and make this right...
            //task: check all offers and uses for equality ( now that I have == for VO and VU )
            //--> but I need some way to sort them first...
            // ArrayList.Sort --> how does it work.

            // check how many before you attempt to access one!!
            if ( ( a.VoucherOffers.Count != 0 ) && ( b.VoucherOffers.Count != 0 ) )
            {
                if ( ( (VoucherOffer) a.VoucherOffers[0] ).offerID !=
                    ( (VoucherOffer) b.VoucherOffers[0] ).offerID )
                {
                    return false;
                }
            }

            //task: compare the uses of these Vouchers in == operator
            // same cheat here as in above comment... ;-)
            if ( ( a.VoucherUsage.Count != 0 ) && ( b.VoucherUsage.Count != 0 ) )
            {
                if ( ( (VoucherUse) a.VoucherUsage[0] ).puid !=
                     ( (VoucherUse) b.VoucherUsage[0] ).puid )
                {
                    return false;
                }
            }

            // if we get this far, then they must be equal
            return true;

        }

        // Evidently, if you override the ==, you have override !=
        public static bool operator != (Voucher a, Voucher b)
        {
            return !(a == b);
        }

        public override bool Equals( object b )
        {
            if ( b is Voucher )
                return ( this == ( Voucher ) b );
            else
                return false;
        }

        // and... as it turns out, you also have to override the
        // GetHashCode method.  This way a HashTable can be used to store your class.
        // Basically, you need to be able to determine whether two things are equal,
        // and evidently they do this partially via a hash. :-\
        /// <summary>
        /// Returns a value for use by the HashTable class.
        /// </summary>
        public override int GetHashCode()
        {
            //task: this will need to incorporate the VO and VU lists somehow, but that's future
            return  this.hashBytes.GetHashCode();
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder( 50 );

            sb.Append( "Hash: " + VoucherUtil2.HashByteToHexStr( this.hashBytes ) );
            sb.Append( " \n VoucherOffers: \n" );

            foreach ( VoucherOffer vo in this.VoucherOffers )
            {
                sb.Append( ( (VoucherOffer) vo).ToString() + "\n");
            }
            sb.Append( "\n VoucherUsage: \n" );
            foreach ( VoucherUse vu in this.VoucherUsage )
            {
                sb.Append( ( ( VoucherUse ) vu).ToString() + "\n");
            }

            return sb.ToString();

        }



        #endregion

        #region Constants

        //NOTE: This tool depends on values in uodb..t_voucher_status
        // active = 0 ; disabled = 1
        //task: I could just load these into a hashtable in a static constructor...
        public const int        VoucherAllOffersHex                     = -1;
        public const string     VoucherStatusActiveString               = "Active";
        public const byte       VoucherStatusActiveByte                 = 0;
        public const string     VoucherStatusDisabledString             = "Disabled";
        public const byte       VoucherStatusDisabledByte               = 1;
        public const byte       VoucherHashSize                         = 20;
        public const byte       SubscriptionCodeWithDashesStringLen     = 29;
        public const byte       SubscriptionCodeWithNoDashesStringLen   = 25;


        #endregion

        #region Public Static Methods

        // task: Should we have a way to load just the usage information if we delete the voucher-offer?
        // task: better question - will we ever delete vouchers other than in tests?

        // Load a single voucher object
        public static Voucher Load( byte[] hashBytes )
        {

            if (
                ( hashBytes == null ) ||
                ( hashBytes.Length != VoucherHashSize )
                )
            {
                throw new ArgumentException("Invalid hash byte array argument");
            }

            Voucher v = new Voucher( hashBytes );
            v.VoucherOffers = new ArrayList();
            v.VoucherUsage = new ArrayList();

            // if it's not there, caller will get an Exception
            LoadFromUODB( ref v );

            return v;

        }
        public static void VerifyOfferExistence(ulong offerId)
        {
                 using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    // Data is partitioned by offer id
                    ws.Partition = WstCommand.AnyPartition;
                    ws.StoredProc = "dbo.p_verify_offer_exists";
                    ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                    ws.AddParameter("@bi_offer_id", offerId);
                    uint hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        throw new DataException("Voucher data was NOT saved successfully, no rows affected. hr = " + hr.ToString() );
                    }
                }
       }
        public static Voucher Load( string subCodeString )
        {

            if (
                ( subCodeString == null ) ||
                ( ( subCodeString.Length != SubscriptionCodeWithDashesStringLen ) && ( subCodeString.Length != SubscriptionCodeWithNoDashesStringLen ) )
                )
                throw new ArgumentException("Invalid subscription code argument.");

            byte[] hashbytes = VoucherUtil2.SubcodeStringToHashByte( subCodeString );

            return Voucher.Load( hashbytes );

        }


        public static Voucher Create( byte[] hashBytes )
        {
            //task: throw exception for bad arguments here in guard clause
            Voucher v = new Voucher( hashBytes );
            v.VoucherOffers = new ArrayList();
            v.VoucherUsage = new ArrayList();

            return v;
        }

        public static Voucher Create( string hashString )
        {
            Voucher v = new Voucher( hashString );
            v.VoucherOffers = new ArrayList();
            v.VoucherUsage = new ArrayList();

            return v;
        }


        //task: create with the offer parameters built in... ;-)

        // retrieve by sub code string?

        //task: static Delete a voucher
        // don't need to load it only to delete it
        // will I ever use this ??
        //        public static DeleteFromUODB( hash, offerid )

        //task: static Disable a voucher
        // don't need to load it only to disable it
        // will I ever use this ??
        //        public static Disable( hash )


        #endregion

        #region Public Instance Methods

        // while having separate Insert/save methods would give us flexibility in the future
        // in case the insert / update cases are different, they're not right now, so
        // just check the values and save them ...
        // This is why I've kept the SaveToUODB method protected and separate.

        // Update object in database
        public void Save()
        {
            // call protected Save
            SaveToUODB();
        }


        /// <summary>
        /// Disable all offers of this Voucher.
        /// Disabling just one VoucherOffer is available by changing a VO.
        /// Consumers are responsible for Saving to make the change persistent.
        /// </summary>
        public void Disable()
        {

            for (int i = 0; i < this.VoucherOffers.Count; i++ )
            {
                // set each VoucherOffer to disabled
                ( (VoucherOffer) this.VoucherOffers[ i ] ).status = VoucherStatusDisabledByte;
            }

//            foreach (VoucherOffer vof in this.VoucherOffers )
//            {
//                Console.WriteLine("Disable: {0}: {1}", vof.offerID, vof.status );
//            }

        }


         /// <summary>
        /// Delete this Voucher and all it's offers.
        /// Neither the deletion of individual offers nor uses is not supported.
        /// </summary>
        public void Delete()
        {
            // just call the delete procedure with "all offers"
            // connect to UODB to get Voucher info
            using (WstConnection voucherConn = new WstConnection( ConfigUtil.TokendbWebstoreApp ) )
            {

                WstCommand voucherCmd;

                // no try here so exceptions get handled higher up
                voucherConn.Open();
                voucherCmd = voucherConn.CreateCommand();
                voucherCmd.CommandType = CommandType.StoredProcedure;
                voucherCmd.Partition = WSClient.GetHashPartition(this.hashBytes, ConfigUtil.UodbWebstoreApp);
                voucherCmd.CommandText = "p_svc_delete_voucher";

                voucherCmd.Parameters.Add( "@bin_voucher_hash", SqlDbType.Binary, 20).Value = this.hashBytes;
                voucherCmd.Parameters["@bin_voucher_hash"].Direction = ParameterDirection.Input;

                // VoucherAllOffersHex == -1 == all voucher-offers with this hash...
                voucherCmd.Parameters.Add( "@bi_offer_id", SqlDbType.BigInt).Value = VoucherAllOffersHex;
                voucherCmd.Parameters["@bi_offer_id"].Direction = ParameterDirection.Input;

                voucherCmd.ExecuteNonQuery();
            }

            //task: should I check to make sure it's gone? what if there's a failure?
            //task: what if the voucher doesn't exist?

        }


        // For those of us too lazy to write it out, here's a one stop shop
        /// <summary>
        /// An easy way to add an offer to a voucher instance.
        /// </summary>
        public void AddOffer( ulong offerID, int useCount, byte status )
        {

            VoucherOffer vo = new VoucherOffer();
            vo.offerID = offerID;
            vo.status = status;
            vo.useCount = useCount;
            this.VoucherOffers.Add( vo );

        }


        // For those of us too lazy to write it out, here's a one stop shop
        /// <summary>
        /// An easy way to add a usage to a voucher instance.
        /// </summary>
        public void AddUse( ulong userPUID, DateTime useDate )
        {

            //task: check for duplicates?
            VoucherUse vu = new VoucherUse();
            vu.puid = userPUID;
            vu.whenUsed = useDate;

            // connect to UODB to get Voucher info
            using (WstConnection voucherConn = new WstConnection( xonline.common.config.ConfigUtil.UodbWebstoreApp ) )
            {

                // no try here so exceptions get handled higher up
                voucherConn.Open();
                WstCommand voucherCmd = voucherConn.CreateCommand();
                voucherCmd.CommandType = CommandType.StoredProcedure;

                voucherCmd.CommandText = "p_xuacs_use_voucher";
                voucherCmd.Partition = WSClient.GetHashPartition(this.hashBytes, ConfigUtil.UodbWebstoreApp);

                voucherCmd.Parameters.Add( "@bin_voucher_hash", SqlDbType.Binary, 20).Value = this.hashBytes;
                voucherCmd.Parameters["@bin_voucher_hash"].Direction = ParameterDirection.Input;

                voucherCmd.Parameters.Add( "@bi_user_puid", SqlDbType.BigInt).Value = vu.puid;
                voucherCmd.Parameters["@bi_user_puid"].Direction = ParameterDirection.Input;

                //interesting hash, but this is the same hash calc used by XUAC...
                voucherCmd.Parameters.Add( "@si_hash_bucket", SqlDbType.BigInt).Value = WSClient.GetHashPartition(this.hashBytes, ConfigUtil.UodbWebstoreApp);
                voucherCmd.Parameters["@si_hash_bucket"].Direction = ParameterDirection.Input;

                voucherCmd.Parameters.Add( "@hr", SqlDbType.BigInt );
                voucherCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                voucherCmd.ExecuteNonQuery();

                if ( 0 != (int) voucherCmd.Parameters["@hr"].Value )
                {
                    throw new DataException( "Voucher Use was not saved successfully, hr = " + voucherCmd.Parameters["@hr"].Value.ToString() + ".  Some causes are Voucher is invalid or voucher was already used." );
                }

            } // using


            // only add it to the parent object if we are successful in saving to UODB
            this.VoucherUsage.Add( vu );
            this.vuLoadCount++;
        }


        #endregion

        #region Protected Methods

        protected static void LoadFromUODB( ref Voucher v )
        {
            bool loaded = false;

            //task: change hardcoded "UODB" to a configuration setting, or
            // connect to UODB to get Voucher info
            using (WstConnection voucherConn = new WstConnection( xonline.common.config.ConfigUtil.UodbWebstoreApp ) )
            {

                //exceptions get handled higher up
                voucherConn.Open();
                WstCommand voucherCmd = voucherConn.CreateCommand();
                voucherCmd.CommandType = CommandType.StoredProcedure;

                voucherCmd.Partition = WSClient.GetHashPartition( v.hashBytes, ConfigUtil.UodbWebstoreApp );

                voucherCmd.CommandText = "p_svc_get_voucher_info";

                voucherCmd.Parameters.Add( "@bin_voucher_hash", SqlDbType.Binary, 20).Value = v.hashBytes;
                voucherCmd.Parameters["@bin_voucher_hash"].Direction = ParameterDirection.Input;

                WstDataReader wr = voucherCmd.ExecuteReader();

                // Load voucheroffers info
                while ( wr.Read() )
                {
                    loaded = true;
                    VoucherOffer vo = new VoucherOffer();

                    vo.offerID = (ulong)( wr.GetInt64( 0 ) );
                    vo.useCount = wr.GetInt32( 1 );

                    // why would anyone go through the trouble of returning a string
                    // when a perfectly unambiguous number is in the DB, and could have been used as-is?
                    switch ( wr.GetString( 2 ) )
                    {
                        case "Active" :
                            vo.status = 0;
                            break;
                        case "Disabled" :
                            vo.status = 1;
                            break;
                        default:
                            throw new Exception( "Invalid Voucher Status returned from p_svc_get_voucher_info " );
                    }

                    v.VoucherOffers.Add( vo );

                    // Console.WriteLine(vo.ToString());
                }

                // Load voucher users... only available if voucher has been used
                if( wr.NextResult() )
                {
                    while ( wr.Read() )
                    {
                        VoucherUse vu = new VoucherUse();

                        vu.puid = (ulong)( wr.GetInt64(0) );
                        vu.whenUsed = System.Convert.ToDateTime( wr.GetDateTime( 1 ) );

                        v.VoucherUsage.Add( vu );
                    }
                }

                // to make sure these don't get "edited" in a bad way
                v.voLoadCount = v.VoucherOffers.Count;
                v.vuLoadCount = v.VoucherUsage.Count;
            }

            if ( ! loaded )
                throw new VoucherNotFoundException();
        }

        protected void SaveToUODB()
        {

            // must have at least one offer. usages can be 0, but offers cannot.
            if ( this.VoucherOffers.Count == 0 )
            {
                throw new Exception( "A Voucher must have VoucherOffers before it can be stored." );
            }

            // it's ok to add one, we can handle that, we don't yet support deletion
            if ( this.VoucherOffers.Count < this.voLoadCount )
            {
                throw new Exception( "There are fewer offerIDs associated with this Voucher compared to when it was loaded.  Deleting offers from Voucher is not supported." );
            }
            //adding uses outside of the method is not supported...
            if    ( this.VoucherUsage.Count != this.vuLoadCount )
            {
                throw new Exception( "The number of Uses associated with this Voucher have changed.  Changing the VoucherUsage collection directly is not supported." );
            }

            // connect to UODB to get Voucher info
            using (WstConnection voucherConn = new WstConnection( xonline.common.config.ConfigUtil.TokendbWebstoreApp ) )
            {

                //review: need to have a transaction here???

                // no try here so exceptions get handled higher up
                voucherConn.Open();
                WstCommand voucherCmd = voucherConn.CreateCommand();
                voucherCmd.CommandType = CommandType.StoredProcedure;

                voucherCmd.CommandText = "p_svc_add_voucher";
                voucherCmd.Partition = WSClient.GetHashPartition( this.hashBytes, ConfigUtil.UodbWebstoreApp );

                int rows = 0;
                //all have the same hash, just different offers
                foreach ( VoucherOffer vo in this.VoucherOffers )
                {
                    VerifyOfferExistence(vo.offerID);
                    voucherCmd.Parameters.Add( "@bin_voucher_hash", SqlDbType.Binary, 20).Value = this.hashBytes;
                    voucherCmd.Parameters["@bin_voucher_hash"].Direction = ParameterDirection.Input;

                    voucherCmd.Parameters.Add( "@bi_offer_id", SqlDbType.BigInt).Value = (long) vo.offerID;
                    voucherCmd.Parameters["@bi_offer_id"].Direction = ParameterDirection.Input;

                    voucherCmd.Parameters.Add( "@i_use_count", SqlDbType.Int).Value = vo.useCount;
                    voucherCmd.Parameters["@i_use_count"].Direction = ParameterDirection.Input;

                    //interesting hash, but this is the same hash calc used by XUAC...
                    voucherCmd.Parameters.Add( "@si_hash_bucket", SqlDbType.BigInt).Value = WSClient.GetHashPartition( this.hashBytes, ConfigUtil.UodbWebstoreApp );
                    voucherCmd.Parameters["@si_hash_bucket"].Direction = ParameterDirection.Input;

                    voucherCmd.Parameters.Add( "@i_voucher_status_id", SqlDbType.Int).Value = vo.status;
                    voucherCmd.Parameters["@i_voucher_status_id"].Direction = ParameterDirection.Input;

                    voucherCmd.Parameters.Add( "@hr", SqlDbType.BigInt );
                    voucherCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                    rows = voucherCmd.ExecuteNonQuery();

                    //review: check if this exception type makes sense, and why doesn't XOFF_E_INVALID_OFFER_ID work?
                    // XOFF_E_INVALID_OFFER_ID = 0x80153003
//                    if ( (ulong) voucherCmd.Parameters["@hr"] == 2148872195)
//                        throw new DataException( "One or more OfferIDs are invalid!" );
                    if ( rows == 0 )
                        throw new DataException("Voucher data was NOT saved successfully, no rows affected. hr = " + voucherCmd.Parameters["@hr"].ToString() );

                    voucherCmd.Parameters.Clear();
                }

            } // using


        } // save to UODB

        #endregion


    } // voucher

    public class VoucherNotFoundException : Exception, ISerializable
    {
        const string message = "Requested Voucher not found in database.";
        public VoucherNotFoundException( ) :  base( message ) { }
        public VoucherNotFoundException( SerializationInfo info, StreamingContext context ) :  base( info, context ) { }

    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\toolsmgmt\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil__toolsmgmt_2_none_12.4.56.0_none_8110ec3e61f60221
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_toolsmgmt_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53.manifest
XP_MANIFEST_PATH=manifests\msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53.cat
XP_CATALOG_PATH=manifests\msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53.cat
XP_PAYLOAD_PATH=msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_toolsmgmt_2,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\uimaputil\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\toolsmgmt\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil__toolsmgmt_2_none_12.4.56.0_none_8110ec3e61f60221
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_toolsmgmt_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53.manifest
XP_MANIFEST_PATH=manifests\msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53.cat
XP_CATALOG_PATH=manifests\msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53.cat
XP_PAYLOAD_PATH=msil__toolsmgmt_2_no-public-key_12.4.56.0_x-ww_9c07ce53
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_toolsmgmt_2,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\toolsmgmt\ToolsDButil.cs ===
namespace xonline.server.webcache.toolsmgmt.common
{
    using System;
    using System.Data;
    using System.Data.SqlClient;

    public enum ErrorLevel
    {
        /// <summary>
        /// Information message.
        /// </summary>
        Info = 0,
        
        /// <summary>
        /// Non-critical message
        /// </summary>
        Warning = 1,

        /// <summary>
        /// Failure message
        /// </summary>
        Error = 2
    }

    public partial class ToolsDB
    {
        /// <summary>
        /// Log a message to the job log.
        /// </summary>
        /// <param name="jobId">JobId of the job that needs to log, or 0 if logging the service</param>
        /// <param name="level">Level of importance</param>
        /// <param name="message">Formatted message to log.</param>
        /// <param name="args">format parameters, if any.</param>
        public void p_toolsmgmt_job_writelog(long jobId, ErrorLevel level, string message, params object[] args)
        {
            string logline;

            logline = string.Format(message, args);
            p_toolsmgmt_job_writelog(jobId, (int)level, logline);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\uimaputil\BigEndianWriter.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;

namespace xonline.common.uimaputil
{
    // This class modeled after BinaryWriter, but forces output in BigEndian byte order
    // NOTE: 
    //    - No byteOrderMark or Preamble is supported for Unicode String/Character output
    //    - The class intentionally makes sure not preamble byte is written out
    //    - Strings will be written out null-terminated
    //    - Character Arrays will have null-terminating char written, even if not supplied
    //    - All Chars/Strings are outputted in Unicode

    public class BigEndianWriter : BinaryWriter
    {
        private static bool fIsLittleEndian = true;

        static BigEndianWriter()
        {
            fIsLittleEndian = BitConverter.IsLittleEndian;
        }

        public BigEndianWriter() : base()
        {
        }

        public BigEndianWriter(Stream stream) : base(stream)
        {
        }

        public BigEndianWriter(Stream stream, Encoding encoding) : base(stream, encoding)
        {
        }

        public override void Write(decimal value)
        {
            if( fIsLittleEndian )
            {
                value = IPAddress.HostToNetworkOrder((long)value); 
            }
            base.Write(value);
        }
        
        public override void Write(short value)
        {
            if( fIsLittleEndian )
            {
                value = IPAddress.HostToNetworkOrder(value); 
            }
            base.Write(value);
        }
        
        public override void Write(int value)
        {
            if( fIsLittleEndian )
            {
                value = IPAddress.HostToNetworkOrder(value); 
            }
            base.Write(value);
        }

        public override void Write(long value)
        {
            if( fIsLittleEndian )
            {
                value = IPAddress.HostToNetworkOrder(value); 
            }
            base.Write(value);
        }

        public override void Write(ushort value)
        {
            if( fIsLittleEndian )
            {
                value = (ushort)IPAddress.HostToNetworkOrder((short) value); 
            }

            base.Write(value);
        }
        
        public override void Write(uint value)
        {
            if( fIsLittleEndian )
            {
                value = (uint)IPAddress.HostToNetworkOrder((int) value); 
            }

            base.Write(value);
        }

        public override void Write(ulong value)
        {
            if( fIsLittleEndian )
            {
                value = (ulong)IPAddress.HostToNetworkOrder((long) value); 
            }

            base.Write(value);
        }

        public override void Write(char value)
        {
            short sValue = (short)value;

            if( fIsLittleEndian )
            {
                sValue = IPAddress.HostToNetworkOrder(sValue); 
            }

            base.Write(sValue);
        }

        public override void Write(char [] value)
        {
            if(fIsLittleEndian)
            {
                base.Write(Encoding.BigEndianUnicode.GetBytes(value)); 
            }
            else
            {
                base.Write(Encoding.Unicode.GetBytes(value)); 
            }

            // Ensure null-terminated
            if((short)value[value.Length-1] != 0x00)
                base.Write((short)0x00);
        }

        public override void Write(char [] value, int index, int count)
        {
            int ending = (value.Length-1 < index + count ? value.Length-1 : index + count);

            if(fIsLittleEndian)
            {
                base.Write(Encoding.BigEndianUnicode.GetBytes(value, index, count)); 
            }
            else
            {
                base.Write(Encoding.Unicode.GetBytes(value, index, count)); 
            }

            // Ensure null-terminated
            if((short)value[ending] != 0x00)
                base.Write((short)0x00);
        }

        public override void Write(string value)
        {
            if(fIsLittleEndian)
            {
                base.Write(Encoding.BigEndianUnicode.GetBytes(value)); 
            }
            else
            {
                base.Write(Encoding.Unicode.GetBytes(value)); 
            }

            // Ensure null-terminated
            base.Write((short)0x00);
        }

        // Not Supported for conversion purposes
        public override void Write(double value)
        {
            if( fIsLittleEndian )
            {
                throw new ArgumentException("BigEndian conversion of type " + value.GetType().ToString() + " not supported."); 
            }
            else
            {
                base.Write(value);
            }
        }

        // Not Supported for conversion purposes
        public override void Write(float value)
        {
            if( fIsLittleEndian )
            {
                throw new ArgumentException("BigEndian conversion of type " + value.GetType().ToString() + " not supported."); 
            }
            else
            {
                base.Write(value);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\uimaputil\SelListVet.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

using xonline.common.offer;
using xonline.common.tools.console;
using xonline.common.uimaputil;

namespace xonline.common.uimaputil
{
    internal class SelListNode
    {
        private uint _selListId;        
        private ArrayList _childNodes; 
        private ArrayList _parentNodes;  
        private int _depthLevel;

        public SelListNode(uint selListId, SelListNode parentNode)
        {
            _selListId = selListId;
            _depthLevel = -1;
            _childNodes = new ArrayList();
            _parentNodes = new ArrayList();

            if (parentNode != null)
            {
                if(!_parentNodes.Contains(parentNode))
                {
                    //tell child about parent
                    _parentNodes.Add(parentNode);
                }

                if(!parentNode.ChildNodes.Contains(this))
                {
                    //tell parent about child
                    parentNode.ChildNodes.Add(this);
                }
            }
        }

        public uint SelListId
        {
            get {return _selListId;}
        }

        public int DepthLevel
        {
            get {return _depthLevel;}
            set {_depthLevel = value;}
        }

        public int NumChildren
        {
            get {return _childNodes.Count;}
        }

        public int NumParents
        {
            get {return _parentNodes.Count;}
        }

        public ArrayList ChildNodes
        {
            get {return _childNodes;}
        }

        public ArrayList ParentNodes
        {
            get {return _parentNodes;}
        }

        public void ParentNodeAdd(SelListNode value)
        {
            if (value != null)
            {
                if(!_parentNodes.Contains(value))
                {
                    //tell child about parent
                    _parentNodes.Add(value);
                }
          
                if(!value.ChildNodes.Contains(this))
                {
                    //tell parent about child
                    value.ChildNodes.Add(this);
                }
            }
        }

        private static Stack _stackNodes; 
        internal static bool VetSelListTree(Hashtable ht, out uint badSelListId)
        {
            bool ret = true;
            badSelListId = 0;
            SelListNode root = null;
            int rootCount = 0;

            if(_stackNodes == null)
            {
                _stackNodes = new Stack();
            }
            else
            {
                _stackNodes.Clear();
            }

            // Vet for risky tree structures
            foreach(DictionaryEntry dE in ht)
            {
                SelListNode node = (SelListNode)dE.Value; 
                if (node.NumParents == 0)
                {
                    uint tmpId = 0;
                    root = node;
                    rootCount++;

                    tmpId = SetNodeDepth(root, 0);

                    // any value other than Zero is the badSelListId that caused a loop
                    if(tmpId != 0)
                    {
                        badSelListId = tmpId;
                        ret = false;
                    }
                }
            }

            if(rootCount > 1)
            {
                Console.WriteLine("WARNING: Multiple Root Elements found!!!");
            }
    
            return ret;
        }

        internal static uint SetNodeDepth(SelListNode node, int depth)
        {
            uint ret = 0;

            // If this node is in the Stack, then we've looped
            if(_stackNodes.Contains(node))
            {
                return node.SelListId;
            }

            node.DepthLevel = depth;
            _stackNodes.Push(node);
            foreach(SelListNode childNode in node.ChildNodes)
            {
                ret = SetNodeDepth(childNode, depth+1);

                // any value other than Zero is the badSelListId that caused a loop
                if(ret != 0)
                    break;
            }
            _stackNodes.Pop();

            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\uimaputil\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__uimaputil_1_none_12.4.56.0_none_1cab4a7da6ead823
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_uimaputil_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93.manifest
XP_MANIFEST_PATH=manifests\x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93.cat
XP_CATALOG_PATH=manifests\x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93.cat
XP_PAYLOAD_PATH=x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_uimaputil_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\uimaputil\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__uimaputil_1_none_12.4.56.0_none_1cab4a7da6ead823
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_uimaputil_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93.manifest
XP_MANIFEST_PATH=manifests\x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93.cat
XP_CATALOG_PATH=manifests\x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93.cat
XP_PAYLOAD_PATH=x86__uimaputil_1_no-public-key_12.4.56.0_x-ww_26eede93
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_uimaputil_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\toolsmgmt\ToolsDB.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.server.webcache.toolsmgmt.common {
    using System;
    using System.Data;
    using System.Data.SqlClient;
    
    
    public partial class ToolsDB {
        
        protected string m_connectionstring;
        
        public ToolsDB(string server, string database) {
            m_connectionstring = String.Format("Data Source={0};Initial Catalog={1};Integrated Security=True", server, database);
        }
        
        public ToolsDB(string connectionstring) {
            this.m_connectionstring = connectionstring;
        }
        
        /// <summary>
        /// Specifies a parameter to the tool called by the action
        /// </summary>
        /// <param name="uid_action_id">Action Identifier</param>
        /// <param name="vc_name">Parameter name</param>
        /// <param name="vc_value">Parameter value</param>
        /// <remarks>
        /// If the parameter name is null, then the parameter is a value.  If the parameter value is null, then the
        /// parameter is flag.
        /// </remarks>
        /// <returns>This stored procedure returns 0 if it is successful, and throws a SQL exception on failure</returns>
        public int p_toolsmgmt_action_addparam(System.Guid uid_action_id, string vc_name, string vc_value) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_action_addparam";
            command.Connection.Open();

            // Define uid_action_id
            SqlParameter prm_uid_action_id = new SqlParameter("@uid_action_id", SqlDbType.UniqueIdentifier, 16);
            prm_uid_action_id.Direction = ParameterDirection.Input;
            prm_uid_action_id.Value = uid_action_id;
            command.Parameters.Add(prm_uid_action_id);

            // Define vc_name
            SqlParameter prm_vc_name = new SqlParameter("@vc_name", SqlDbType.VarChar, 256);
            prm_vc_name.Direction = ParameterDirection.Input;
            prm_vc_name.Value = vc_name;
            command.Parameters.Add(prm_vc_name);

            // Define vc_value
            SqlParameter prm_vc_value = new SqlParameter("@vc_value", SqlDbType.VarChar, 1024);
            prm_vc_value.Direction = ParameterDirection.Input;
            prm_vc_value.Value = vc_value;
            command.Parameters.Add(prm_vc_value);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>Marks the given action as complete</summary>
        /// <param name="uid_action_id">action id to mark as complete</param>
        /// <param name="i_return_code">action return code, -1 indicates failure</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_action_complete(System.Guid uid_action_id, int i_returncode) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_action_complete";
            command.Connection.Open();

            // Define uid_action_id
            SqlParameter prm_uid_action_id = new SqlParameter("@uid_action_id", SqlDbType.UniqueIdentifier, 16);
            prm_uid_action_id.Direction = ParameterDirection.Input;
            prm_uid_action_id.Value = uid_action_id;
            command.Parameters.Add(prm_uid_action_id);

            // Define i_returncode
            SqlParameter prm_i_returncode = new SqlParameter("@i_returncode", SqlDbType.Int, 4);
            prm_i_returncode.Direction = ParameterDirection.Input;
            prm_i_returncode.Value = i_returncode;
            command.Parameters.Add(prm_i_returncode);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Creates a new action, and associates it with the specified bi_job_id.
        /// </summary>
        /// <param name="uid_action_id"> ActionId of the newly created action </param>
        /// <param name="i_rank"> Rank of the newly created action </param>
        /// <param name="bi_job_id"> Job Id to create this action in </param>
        /// <param name="vc_toolname"> Filename/path to the tool to run </param>
        /// <returns>Returns 0 on success, and 1 on failure</returns>
        public int p_toolsmgmt_action_create(out System.Guid uid_action_id, out int i_rank, long bi_job_id, string vc_toolname) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_action_create";
            command.Connection.Open();

            // Define uid_action_id
            SqlParameter prm_uid_action_id = new SqlParameter("@uid_action_id", SqlDbType.UniqueIdentifier, 16);
            prm_uid_action_id.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_uid_action_id);

            // Define i_rank
            SqlParameter prm_i_rank = new SqlParameter("@i_rank", SqlDbType.Int, 4);
            prm_i_rank.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_i_rank);

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define vc_toolname
            SqlParameter prm_vc_toolname = new SqlParameter("@vc_toolname", SqlDbType.VarChar, 256);
            prm_vc_toolname.Direction = ParameterDirection.Input;
            prm_vc_toolname.Value = vc_toolname;
            command.Parameters.Add(prm_vc_toolname);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results
            if ((prm_uid_action_id.Value == null)) {
                uid_action_id = ((System.Guid)(prm_uid_action_id.Value));
            }
            else {
                uid_action_id = ((System.Guid)(prm_uid_action_id.Value));
            }
            if ((prm_i_rank.Value == null)) {
                i_rank = ((int)(prm_i_rank.Value));
            }
            else {
                i_rank = ((int)(prm_i_rank.Value));
            }

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>Gets the ActionId for a given rank and job</summary>
        /// <param name="uid_action_id">ActionId for the specified job and rank</param>
        /// <param name="bi_job_id">JobId</param>
        /// <param name="i_rank">rank</param>
        /// <returns>0</returns>
        public int p_toolsmgmt_action_getid(out System.Guid uid_action_id, long bi_job_id, int i_rank) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_action_getid";
            command.Connection.Open();

            // Define uid_action_id
            SqlParameter prm_uid_action_id = new SqlParameter("@uid_action_id", SqlDbType.UniqueIdentifier, 16);
            prm_uid_action_id.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_uid_action_id);

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define i_rank
            SqlParameter prm_i_rank = new SqlParameter("@i_rank", SqlDbType.Int, 4);
            prm_i_rank.Direction = ParameterDirection.Input;
            prm_i_rank.Value = i_rank;
            command.Parameters.Add(prm_i_rank);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results
            if ((prm_uid_action_id.Value == null)) {
                uid_action_id = ((System.Guid)(prm_uid_action_id.Value));
            }
            else {
                uid_action_id = ((System.Guid)(prm_uid_action_id.Value));
            }

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>Gets the output for all streams for a given action</summary>
        /// <param name="bi_job_id">Job Id of the job that owns the action</param>
        /// <param name="i_rank">Rank of the action to query</param>
        /// <executetype>Reader</executetype>
        public int p_toolsmgmt_action_getoutput(out SqlDataReader sqlDataReader, long bi_job_id, int i_rank) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_action_getoutput";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define i_rank
            SqlParameter prm_i_rank = new SqlParameter("@i_rank", SqlDbType.Int, 4);
            prm_i_rank.Direction = ParameterDirection.Input;
            prm_i_rank.Value = i_rank;
            command.Parameters.Add(prm_i_rank);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            sqlDataReader = command.ExecuteReader(CommandBehavior.CloseConnection);

            // Collect the results

            return sqlDataReader.RecordsAffected;
        }
        
        /// <summary>Get the parameters associated with a given action</summary>
        /// <param name="uid_action_id">action to get parameters for</param>
        /// <executetype>Reader</executetype>
        public int p_toolsmgmt_action_getparams(out SqlDataReader sqlDataReader, System.Guid uid_action_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_action_getparams";
            command.Connection.Open();

            // Define uid_action_id
            SqlParameter prm_uid_action_id = new SqlParameter("@uid_action_id", SqlDbType.UniqueIdentifier, 16);
            prm_uid_action_id.Direction = ParameterDirection.Input;
            prm_uid_action_id.Value = uid_action_id;
            command.Parameters.Add(prm_uid_action_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            sqlDataReader = command.ExecuteReader(CommandBehavior.CloseConnection);

            // Collect the results

            return sqlDataReader.RecordsAffected;
        }
        
        /// <summary>Get the current status of a given action</summary>
        /// <param name="vc_state">the state of the action</param>
        /// <param name="i_returncode">the returncode of the tool, if the action is complete</param>
        /// <param name="bi_job_id">Job Id of the job that owns the action</param>
        /// <param name="i_rank">Rank of the action to query</param>
        /// <returns>0 on success, 1 if the action wasn't found.</returns>
        public int p_toolsmgmt_action_getstatus(out int i_state, out int i_returncode, long bi_job_id, int i_rank) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_action_getstatus";
            command.Connection.Open();

            // Define i_state
            SqlParameter prm_i_state = new SqlParameter("@i_state", SqlDbType.Int, 4);
            prm_i_state.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_i_state);

            // Define i_returncode
            SqlParameter prm_i_returncode = new SqlParameter("@i_returncode", SqlDbType.Int, 4);
            prm_i_returncode.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_i_returncode);

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define i_rank
            SqlParameter prm_i_rank = new SqlParameter("@i_rank", SqlDbType.Int, 4);
            prm_i_rank.Direction = ParameterDirection.Input;
            prm_i_rank.Value = i_rank;
            command.Parameters.Add(prm_i_rank);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results
            if ((prm_i_state.Value == null)) {
                i_state = ((int)(prm_i_state.Value));
            }
            else {
                i_state = ((int)(prm_i_state.Value));
            }
            if ((prm_i_returncode.Value == null)) {
                i_returncode = ((int)(prm_i_returncode.Value));
            }
            else {
                i_returncode = ((int)(prm_i_returncode.Value));
            }

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>Stores the command line passed to the process</summary>
        /// <param name="uid_action_id">ActionId to set the arguments for</param>
        /// <param name="vc_arguments">Command line arguments</param>
        /// <returns>0</returns>
        public int p_toolsmgmt_action_setarguments(System.Guid uid_action_id, string vc_arguments) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_action_setarguments";
            command.Connection.Open();

            // Define uid_action_id
            SqlParameter prm_uid_action_id = new SqlParameter("@uid_action_id", SqlDbType.UniqueIdentifier, 16);
            prm_uid_action_id.Direction = ParameterDirection.Input;
            prm_uid_action_id.Value = uid_action_id;
            command.Parameters.Add(prm_uid_action_id);

            // Define vc_arguments
            SqlParameter prm_vc_arguments = new SqlParameter("@vc_arguments", SqlDbType.VarChar, 1024);
            prm_vc_arguments.Direction = ParameterDirection.Input;
            prm_vc_arguments.Value = vc_arguments;
            command.Parameters.Add(prm_vc_arguments);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>Marks the given action as complete</summary>
        /// <param name="uid_action_id">action id to mark as complete</param>
        /// <param name="i_return_code">action return code, -1 indicates failure</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_action_start(System.Guid uid_action_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_action_start";
            command.Connection.Open();

            // Define uid_action_id
            SqlParameter prm_uid_action_id = new SqlParameter("@uid_action_id", SqlDbType.UniqueIdentifier, 16);
            prm_uid_action_id.Direction = ParameterDirection.Input;
            prm_uid_action_id.Value = uid_action_id;
            command.Parameters.Add(prm_uid_action_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>Write action output to the specified stream</summary>
        /// <param name="uid_action_id">ActionId of the action to associate the output with.</param>
        /// <param name="i_stream">Output stream id. 0-LOG 1-STDOUT 2-STDERR</param>
        /// <param name="vc_output">Output to add to the output log</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_action_writeoutput(System.Guid uid_action_id, int i_stream, string vc_output) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_action_writeoutput";
            command.Connection.Open();

            // Define uid_action_id
            SqlParameter prm_uid_action_id = new SqlParameter("@uid_action_id", SqlDbType.UniqueIdentifier, 16);
            prm_uid_action_id.Direction = ParameterDirection.Input;
            prm_uid_action_id.Value = uid_action_id;
            command.Parameters.Add(prm_uid_action_id);

            // Define i_stream
            SqlParameter prm_i_stream = new SqlParameter("@i_stream", SqlDbType.Int, 4);
            prm_i_stream.Direction = ParameterDirection.Input;
            prm_i_stream.Value = i_stream;
            command.Parameters.Add(prm_i_stream);

            // Define vc_output
            SqlParameter prm_vc_output = new SqlParameter("@vc_output", SqlDbType.VarChar, 3500);
            prm_vc_output.Direction = ParameterDirection.Input;
            prm_vc_output.Value = vc_output;
            command.Parameters.Add(prm_vc_output);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Adds a set of files that the job should expect to copy to the working directory
        /// </summary>
        /// <param name="bi_job_id">jobId to add files to</param>
        /// <param name="vc_filename">name of the file, or fileset specified using wildcards</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_job_addfile(long bi_job_id, string vc_filename) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_addfile";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define vc_filename
            SqlParameter prm_vc_filename = new SqlParameter("@vc_filename", SqlDbType.VarChar, 256);
            prm_vc_filename.Direction = ParameterDirection.Input;
            prm_vc_filename.Value = vc_filename;
            command.Parameters.Add(prm_vc_filename);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Attempts to cancel a job after it has been "executed"
        /// </summary>
        /// <param name="bi_job_id">jobId of the job to cancel</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_job_cancel(long bi_job_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_cancel";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>Marks the given job id as complete</summary>
        /// <param name="bi_job_id">job id to mark as complete</param>
        /// <param name="i_state">completion state (32, 30, 31)</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_job_complete(long bi_job_id, int i_state) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_complete";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define i_state
            SqlParameter prm_i_state = new SqlParameter("@i_state", SqlDbType.Int, 4);
            prm_i_state.Direction = ParameterDirection.Input;
            prm_i_state.Value = i_state;
            command.Parameters.Add(prm_i_state);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Creates a job in the ToolsDB
        /// </summary>
        /// <param name="bi_job_id">the job id of the job created</param>
        /// <param name="vc_description">Description of the job created</param>
        /// <param name="i_priority">Job priority</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_job_create(out long bi_job_id, int i_priority, int i_titleid, int i_worktype, string vc_description) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_create";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_bi_job_id);

            // Define i_priority
            SqlParameter prm_i_priority = new SqlParameter("@i_priority", SqlDbType.Int, 4);
            prm_i_priority.Direction = ParameterDirection.Input;
            prm_i_priority.Value = i_priority;
            command.Parameters.Add(prm_i_priority);

            // Define i_titleid
            SqlParameter prm_i_titleid = new SqlParameter("@i_titleid", SqlDbType.Int, 4);
            prm_i_titleid.Direction = ParameterDirection.Input;
            prm_i_titleid.Value = i_titleid;
            command.Parameters.Add(prm_i_titleid);

            // Define i_worktype
            SqlParameter prm_i_worktype = new SqlParameter("@i_worktype", SqlDbType.Int, 4);
            prm_i_worktype.Direction = ParameterDirection.Input;
            prm_i_worktype.Value = i_worktype;
            command.Parameters.Add(prm_i_worktype);

            // Define vc_description
            SqlParameter prm_vc_description = new SqlParameter("@vc_description", SqlDbType.VarChar, 256);
            prm_vc_description.Direction = ParameterDirection.Input;
            prm_vc_description.Value = vc_description;
            command.Parameters.Add(prm_vc_description);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results
            if ((prm_bi_job_id.Value == null)) {
                bi_job_id = ((long)(prm_bi_job_id.Value));
            }
            else {
                bi_job_id = ((long)(prm_bi_job_id.Value));
            }

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Adds the specified job id to the job queue
        /// </summary>
        /// <param name="bi_job_id">Job Id to add to the job queue</param>
        /// <returns> 0 on success, 1 on failure </returns>
        public int p_toolsmgmt_job_execute(long bi_job_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_execute";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>Get the files associated with a given job id</summary>
        /// <param name="bi_job_id">job id to get files for</param>
        /// <executetype>Reader</executetype>
        public int p_toolsmgmt_job_getfiles(out SqlDataReader sqlDataReader, long bi_job_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_getfiles";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            sqlDataReader = command.ExecuteReader(CommandBehavior.CloseConnection);

            // Collect the results

            return sqlDataReader.RecordsAffected;
        }
        
        public int p_toolsmgmt_job_getinfo(out int i_worktype, out int i_titleid, long bi_job_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_getinfo";
            command.Connection.Open();

            // Define i_worktype
            SqlParameter prm_i_worktype = new SqlParameter("@i_worktype", SqlDbType.Int, 4);
            prm_i_worktype.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_i_worktype);

            // Define i_titleid
            SqlParameter prm_i_titleid = new SqlParameter("@i_titleid", SqlDbType.Int, 4);
            prm_i_titleid.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_i_titleid);

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results
            if ((prm_i_worktype.Value == null)) {
                i_worktype = ((int)(prm_i_worktype.Value));
            }
            else {
                i_worktype = ((int)(prm_i_worktype.Value));
            }
            if ((prm_i_titleid.Value == null)) {
                i_titleid = ((int)(prm_i_titleid.Value));
            }
            else {
                i_titleid = ((int)(prm_i_titleid.Value));
            }

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>Gets the logs for a given job.</summary>
        /// <executetype>Reader</executetype>
        /// <param name="bi_job_id">Job Id to get the log for</param>
        public int p_toolsmgmt_job_getlog(out SqlDataReader sqlDataReader, long bi_job_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_getlog";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            sqlDataReader = command.ExecuteReader(CommandBehavior.CloseConnection);

            // Collect the results

            return sqlDataReader.RecordsAffected;
        }
        
        /// <summary> Gets a job from the job queue </summary>
        /// <param name="@bi_job_id"> The next job id, if one exists </param>
        /// <param name="@vc_owner"> The name of the entity taking ownership of the job </param>
        /// <returns>
        /// 0  there was a job to retrieve
        /// 1  there were no jobs to retrieve
        /// </returns>
        public int p_toolsmgmt_job_getnext(out long bi_job_id, out int i_worktype, string vc_owner) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_getnext";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_bi_job_id);

            // Define i_worktype
            SqlParameter prm_i_worktype = new SqlParameter("@i_worktype", SqlDbType.Int, 4);
            prm_i_worktype.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_i_worktype);

            // Define vc_owner
            SqlParameter prm_vc_owner = new SqlParameter("@vc_owner", SqlDbType.VarChar, 50);
            prm_vc_owner.Direction = ParameterDirection.Input;
            prm_vc_owner.Value = vc_owner;
            command.Parameters.Add(prm_vc_owner);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results
            if ((prm_bi_job_id.Value == null)) {
                bi_job_id = ((long)(prm_bi_job_id.Value));
            }
            else {
                bi_job_id = ((long)(prm_bi_job_id.Value));
            }
            if ((prm_i_worktype.Value == null)) {
                i_worktype = ((int)(prm_i_worktype.Value));
            }
            else {
                i_worktype = ((int)(prm_i_worktype.Value));
            }

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Gets the next un-executed action associated with a job
        /// </summary>
        /// <param name="uid_action_id">Action ID of the next action</param>
        /// <param name="bi_job_id">Job ID to get the next action for</param>
        /// <returns>
        /// Returns the current state of the job: 31,
        /// 30, or 21
        /// </returns>
        public int p_toolsmgmt_job_getnextaction(out System.Guid uid_action_id, out string vc_toolname, long bi_job_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_getnextaction";
            command.Connection.Open();

            // Define uid_action_id
            SqlParameter prm_uid_action_id = new SqlParameter("@uid_action_id", SqlDbType.UniqueIdentifier, 16);
            prm_uid_action_id.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_uid_action_id);

            // Define vc_toolname
            SqlParameter prm_vc_toolname = new SqlParameter("@vc_toolname", SqlDbType.VarChar, 256);
            prm_vc_toolname.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_vc_toolname);

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results
            if ((prm_uid_action_id.Value == null)) {
                uid_action_id = ((System.Guid)(prm_uid_action_id.Value));
            }
            else {
                uid_action_id = ((System.Guid)(prm_uid_action_id.Value));
            }
            if ((prm_vc_toolname.Value == null)) {
                vc_toolname = "\"\"";
            }
            else {
                vc_toolname = ((string)(prm_vc_toolname.Value));
            }

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>Gets the output for a given job.</summary>
        /// <executetype>Reader</executetype>
        /// <param name="bi_job_id">Job Id to get the log for</param>
        public int p_toolsmgmt_job_getoutput(out SqlDataReader sqlDataReader, long bi_job_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_getoutput";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            sqlDataReader = command.ExecuteReader(CommandBehavior.CloseConnection);

            // Collect the results

            return sqlDataReader.RecordsAffected;
        }
        
        public int p_toolsmgmt_job_getstatus(out int i_state, long bi_job_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_getstatus";
            command.Connection.Open();

            // Define i_state
            SqlParameter prm_i_state = new SqlParameter("@i_state", SqlDbType.Int, 4);
            prm_i_state.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_i_state);

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results
            if ((prm_i_state.Value == null)) {
                i_state = ((int)(prm_i_state.Value));
            }
            else {
                i_state = ((int)(prm_i_state.Value));
            }

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Sets the upload path for a given job
        /// </summary>
        /// <param name="bi_job_id">jobId of the job to get the upload path for</param>
        /// <param name="vc_uploadroot">upload root for this job</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_job_getuploadpath(out string vc_uploadpath, long bi_job_id) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_getuploadpath";
            command.Connection.Open();

            // Define vc_uploadpath
            SqlParameter prm_vc_uploadpath = new SqlParameter("@vc_uploadpath", SqlDbType.VarChar, 256);
            prm_vc_uploadpath.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_vc_uploadpath);

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results
            if ((prm_vc_uploadpath.Value == null)) {
                vc_uploadpath = "\"\"";
            }
            else {
                vc_uploadpath = ((string)(prm_vc_uploadpath.Value));
            }

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Write a line to the job log
        /// </summary>
        /// <param name="bi_job_id">jobId to log to</param>
        /// <param name="vc_logline">line to write to the log</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_job_setstate(long bi_job_id, int i_state, string vc_logline) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_setstate";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define i_state
            SqlParameter prm_i_state = new SqlParameter("@i_state", SqlDbType.Int, 4);
            prm_i_state.Direction = ParameterDirection.Input;
            prm_i_state.Value = i_state;
            command.Parameters.Add(prm_i_state);

            // Define vc_logline
            SqlParameter prm_vc_logline = new SqlParameter("@vc_logline", SqlDbType.VarChar, 2048);
            prm_vc_logline.Direction = ParameterDirection.Input;
            prm_vc_logline.Value = vc_logline;
            command.Parameters.Add(prm_vc_logline);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Sets the upload path for a given job
        /// </summary>
        /// <param name="bi_job_id">jobId of the job to set the upload path for</param>
        /// <param name="vc_uploadroot">upload root for this job</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_job_setuploadpath(long bi_job_id, string vc_uploadpath) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_setuploadpath";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define vc_uploadpath
            SqlParameter prm_vc_uploadpath = new SqlParameter("@vc_uploadpath", SqlDbType.VarChar, 256);
            prm_vc_uploadpath.Direction = ParameterDirection.Input;
            prm_vc_uploadpath.Value = vc_uploadpath;
            command.Parameters.Add(prm_vc_uploadpath);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Write a line to the job log
        /// </summary>
        /// <param name="bi_job_id">jobId to log to</param>
        /// <param name="vc_logline">line to write to the log</param>
        /// <param name="i_level">0-Info, 1-Warning, 2-Error</param>
        /// <returns>nothing</returns>
        public int p_toolsmgmt_job_writelog(long bi_job_id, int i_level, string vc_logline) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_job_writelog";
            command.Connection.Open();

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define i_level
            SqlParameter prm_i_level = new SqlParameter("@i_level", SqlDbType.Int, 4);
            prm_i_level.Direction = ParameterDirection.Input;
            prm_i_level.Value = i_level;
            command.Parameters.Add(prm_i_level);

            // Define vc_logline
            SqlParameter prm_vc_logline = new SqlParameter("@vc_logline", SqlDbType.VarChar, 2048);
            prm_vc_logline.Direction = ParameterDirection.Input;
            prm_vc_logline.Value = vc_logline;
            command.Parameters.Add(prm_vc_logline);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
        
        /// <summary>
        /// Creates a new action, and associates it with the specified bi_job_id.
        /// </summary>
        /// <param name="uid_action_id"> ActionId of the newly created action </param>
        /// <param name="i_rank"> Rank of the newly created action </param>
        /// <param name="bi_job_id"> Job Id to create this action in </param>
        /// <param name="vc_toolname"> Filename/path to the tool to run </param>
        /// <returns>Returns 0 on success, and 1 on failure</returns>
        public int p_toolsmgmt_step_create(out System.Guid uid_action_id, out int i_rank, long bi_job_id, string vc_toolname) {
            // Initialize the SqlCommand
            SqlCommand command = new SqlCommand();
            command.Connection = new SqlConnection(m_connectionstring);
            command.CommandType = CommandType.StoredProcedure;
            command.CommandText = "p_toolsmgmt_step_create";
            command.Connection.Open();

            // Define uid_action_id
            SqlParameter prm_uid_action_id = new SqlParameter("@uid_action_id", SqlDbType.UniqueIdentifier, 16);
            prm_uid_action_id.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_uid_action_id);

            // Define i_rank
            SqlParameter prm_i_rank = new SqlParameter("@i_rank", SqlDbType.Int, 4);
            prm_i_rank.Direction = ParameterDirection.Output;
            command.Parameters.Add(prm_i_rank);

            // Define bi_job_id
            SqlParameter prm_bi_job_id = new SqlParameter("@bi_job_id", SqlDbType.BigInt, 8);
            prm_bi_job_id.Direction = ParameterDirection.Input;
            prm_bi_job_id.Value = bi_job_id;
            command.Parameters.Add(prm_bi_job_id);

            // Define vc_toolname
            SqlParameter prm_vc_toolname = new SqlParameter("@vc_toolname", SqlDbType.VarChar, 256);
            prm_vc_toolname.Direction = ParameterDirection.Input;
            prm_vc_toolname.Value = vc_toolname;
            command.Parameters.Add(prm_vc_toolname);

            // Define a SqlParameter to get the return value
            SqlParameter prm_return = new SqlParameter("@RETURN_VALUE", SqlDbType.Int, 4);
            prm_return.Direction = ParameterDirection.ReturnValue;
            command.Parameters.Add(prm_return);

            // Execute
            command.ExecuteNonQuery();

            // Collect the results
            if ((prm_uid_action_id.Value == null)) {
                uid_action_id = ((System.Guid)(prm_uid_action_id.Value));
            }
            else {
                uid_action_id = ((System.Guid)(prm_uid_action_id.Value));
            }
            if ((prm_i_rank.Value == null)) {
                i_rank = ((int)(prm_i_rank.Value));
            }
            else {
                i_rank = ((int)(prm_i_rank.Value));
            }

            command.Connection.Close();

            return ((int)(prm_return.Value));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\uimaputil\UIMapManager.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

using xonline.common.offer;
using xonline.common.tools.console;
using xonline.common.uimaputil;

namespace xonline.common.uimaputil
{
    public class UIMapManager
    {
        static UIMapManager()
        {
            _selectionListInfoIDs = new Hashtable();

            _selectionListNodes = new Hashtable();

            _languageStrings = new Hashtable[9];
            
            for (int i = 0; i < 9; i++)
            {
                _languageStrings[i] = new Hashtable();
            }
        }

        // this Hashtable stores main SelectionListInfo IDS for a scene
        private static Hashtable _selectionListInfoIDs = null;

        // this Hashtable stores all SelectionList Info/Entry nodes
        private static Hashtable _selectionListNodes = null;

        internal static Hashtable SelectionListNodes
        {
            get {return _selectionListNodes;}
        }

        // this Hashtable stores what SelectionListInfo IDS
        private static Hashtable [] _languageStrings = null;

        // defaults for enum values in XSD
        private static OfferType _offerTypeDefault = OfferType.AllContent;
        private static PaymentType _paymentTypeDefault = PaymentType.NoTokens;

        // These map to #define statements in xenon\private\xam\livecommon\selectionlist.h
        private static readonly uint XONLINE_UIMAP_STOREFRONT_ID    = 1000;
        private static readonly uint XONLINE_UIMAP_LIVEARCADE_ID    = 2000;
        private static readonly uint XONLINE_UIMAP_GAMERTILES_ID    = 3000;
        private static readonly uint XONLINE_UIMAP_GAMES_ID         = 4000;
        private static readonly uint XONLINE_UIMAP_GAMEVIDEOS_ID    = 4200;
        private static readonly uint XONLINE_UIMAP_ENTERTAINMENT_ID = 5000;
       

        // These map to XONLINE_UIMAP_ENTRY_TYPE enum on xenon\private\xam\livecommon\selectionlist.h
        public enum SelectionListTypeEnum : uint 
        {
            SelectionList         = 1,
            TitleList             = 2,
            GenreList             = 3,
            ContentList           = 4,
            FeaturedDownloads     = 5,
            AccountLink           = 6,
            HUDEntryPoint         = 7,
            MediaMarketplaceLink  = 8,
        } 

        // These map to XSHOWMARKETPLACEUI_ENTRYPOINTS and XSHOWMARKETPLACEUI_PRIVATE_ENTRYPOINTS enums in the client tree
        public enum HUDEntryPointTypeEnum : uint 
        {
            ContentList             = 0,
            ContentItem             = 1,
            MembershipList          = 2,
            MembershipItem          = 3,
            AddPoints               = 4,
            PrepaidCode             = 5,
            FNC                     = 6,
            GamertagPurchase        = 7,
            SignupCreditcard        = 8,
            SignupParentCreditcard  = 9,
            ActiveDownloads         = 10,
        } 

        [Flags]
        public enum XeEnumerateTitlesByFilterRequestFlags : ushort
        {
            QueryForNew             = 0x0001,
            QueryForPlayed          = 0x0002,
        }

        [Flags]
        public enum XeContentEnumerateRequestFlags : byte
        {
            UserPlayedGameFilter        = 0x01,
            UserHasPurchasedFilter      = 0x02,
            NewContentOnlyFilter        = 0x04,
        }

        public static uint MapOfferType(OfferType offerType)
        {
            switch (offerType)
            {
                case OfferType.Subscription:
                    return (uint) OfferingTypeEnum.Subscription;

                case OfferType.GameContent:
                    return (uint) OfferingTypeEnum.Content;

                case OfferType.Renewal:
                    return (uint) OfferingTypeEnum.Renewal;

                case OfferType.PointsBundle:
                    return (uint) OfferingTypeEnum.PointsBundle;

                case OfferType.GamertagChange:
                    return (uint) OfferingTypeEnum.GamertagChange;

                case OfferType.GameDemo:
                    return (uint) OfferingTypeEnum.GameDemo;

                case OfferType.GameTrailer:
                    return (uint) OfferingTypeEnum.GameTrailer;

                case OfferType.Theme:
                    return (uint) OfferingTypeEnum.Theme;

                case OfferType.Gameplay:
                    return (uint) OfferingTypeEnum.Gameplay;

                case OfferType.FullGame:
                    return (uint) OfferingTypeEnum.FullGame;

                case OfferType.PromoPoints:
                    return (uint) OfferingTypeEnum.PromoPoints;

                case OfferType.Tile:
                    return (uint) OfferingTypeEnum.Tile;

                case OfferType.Trial:
                    return (uint) OfferingTypeEnum.Trial;

                case OfferType.Arcade:
                    return (uint) OfferingTypeEnum.Arcade;

                case OfferType.Video:
                    return (uint) OfferingTypeEnum.Video;

                case OfferType.AllContent:
                    return (uint) OfferingTypeEnum.AllContent;

                case OfferType.All:
                    return (uint) OfferingTypeEnum.All;
            }

            throw new Exception("invalid contentOfferType: " + offerType);
        }
        
        public static uint MapPaymentType(PaymentType paymentType)
        {
            switch (paymentType)
            {
                case PaymentType.CreditCard:
                    return (uint) PaymentTypeEnum.CreditCard;

                case PaymentType.TokenOrVoucher:
                    return (uint) PaymentTypeEnum.Token;

                case PaymentType.Points:
                    return (uint) PaymentTypeEnum.Points;

                case PaymentType.All:
                    return (uint) PaymentTypeEnum.All;

                case PaymentType.NoTokens:
                    return (uint) PaymentTypeEnum.NoTokens;
            }

            throw new Exception("invalid paymentType: " + paymentType);
        }

        public static ushort MapSelectionListType(SelectionListType selectionListType)
        {
            switch (selectionListType)
            {
                case SelectionListType.SelectionList:
                    return (ushort) SelectionListTypeEnum.SelectionList;

                case SelectionListType.TitleList:
                    return (ushort) SelectionListTypeEnum.TitleList;

                case SelectionListType.GenreList:
                    return (ushort) SelectionListTypeEnum.GenreList;

                case SelectionListType.ContentList:
                    return (ushort) SelectionListTypeEnum.ContentList;

                case SelectionListType.FeaturedDownloads:
                    return (ushort) SelectionListTypeEnum.FeaturedDownloads;

                case SelectionListType.AccountLink:
                    return (ushort) SelectionListTypeEnum.AccountLink;

                case SelectionListType.HUDEntryPoint:
                    return (ushort) SelectionListTypeEnum.HUDEntryPoint;

                case SelectionListType.MediaMarketplaceLink:
                    return (ushort) SelectionListTypeEnum.MediaMarketplaceLink;
            }

            throw new Exception("invalid selectionListType: " + selectionListType);
        }

        public static uint MapHUDEntryPointType(HUDEntryPointType hudEntryPointType)
        {
            switch (hudEntryPointType)
            {
                case HUDEntryPointType.ContentList:
                    return (uint) HUDEntryPointTypeEnum.ContentList;

                case HUDEntryPointType.ContentItem:
                    return (uint) HUDEntryPointTypeEnum.ContentItem;

                case HUDEntryPointType.MembershipList:
                    return (uint) HUDEntryPointTypeEnum.MembershipList;

                case HUDEntryPointType.MembershipItem:
                    return (uint) HUDEntryPointTypeEnum.MembershipItem;

                case HUDEntryPointType.AddPoints:
                    return (uint) HUDEntryPointTypeEnum.AddPoints;

                case HUDEntryPointType.PrepaidCode:
                    return (uint) HUDEntryPointTypeEnum.PrepaidCode;

                case HUDEntryPointType.GamertagPurchase:
                    return (uint) HUDEntryPointTypeEnum.GamertagPurchase;

                case HUDEntryPointType.ActiveDownloads:
                    return (uint) HUDEntryPointTypeEnum.ActiveDownloads;
            }

            throw new Exception("invalid hudEntryPointType: " + hudEntryPointType);
        }

        public static void SerializeUIMap(SelectionListInfoArray slia, LanguageType lt, BigEndianWriter bew)
        {
            // Current file order/format is:
            //
            //(Header)
            // DWORD				            DWORD dwNumSelectListInfos = N1		        1 object
            // DWORD				            DWORD dwTotalNumSelectionListEntries = N2		
            //(Info #1)
            // DWORD					        DWORD dwSelectionListId		                1 object
            // BYTE					            BYTE bBannerType		
            // WCHAR (Array)(times up to 60)   WCHAR wszSceneTitle[60]		
            // DWORD				            DWORD dwNumSelectionListEntries	 = N3	
            //(Entries * N3)
            // WORD					            WORD wEntryType		                        N3 objects(s)
            // BYTE					            BYTE bIconId		
            // WCHAR (Array)(times up to 60)	WCHAR wszLabel[60]		
            // UNION					        SELECTION_LIST_DATA data		
            //(Infos#2)
            // DWORD					        DWORD dwSelectionListId		                1 object
            // BYTE					            BYTE bBannerType		
            // WCHAR (Array)(times up to 60)   WCHAR wszSceneTitle[60]		
            // DWORD				            DWORD dwNumSelectionListEntries	 = N4	
            //(Entries * N4)
            // WORD					            WORD wEntryType		                        N4 objects(s)
            // BYTE					            BYTE bIconId		
            // WCHAR (Array)(times up to 60)	WCHAR wszLabel[60]		
            // UNION					        SELECTION_LIST_DATA data	
	        // [...]
            //(Info #N1)
            // DWORD					        DWORD dwSelectionListId		                1 object
            // BYTE					            BYTE bBannerType		
            // WCHAR (Array)(times up to 60)   WCHAR wszSceneTitle[60]		
            // DWORD				            DWORD dwNumSelectionListEntries	 = N5	
            //(Entries * N5)
            // WORD					            WORD wEntryType		                        N5 objects(s)
            // BYTE					            BYTE bIconId		
            // WCHAR (Array)(times up to 60)	WCHAR wszLabel[60]		
            // UNION					        SELECTION_LIST_DATA data	


            // Write the one-and-only SELECTION_LIST_INFO_ARRAY object data
            SerializeUIMapHeader(slia, bew);

            // Write the SELECTION_LIST_INFO object(s) data
            foreach(SelectionListInfo sli in slia.selectionListInfoCollection)
            {
                SerializeUIMapInfo(sli, lt, bew);

                // NOTE 3/7/06: Changed order of data in the file to match what Console was expecting...
                foreach(SelectionListEntry sle in sli.selectionListEntryCollection)
                {
                    SerializeUIMapEntry(sle, lt, bew);
                }
            }

//          NOTE 3/7/06: Changed order of data in the file to match what Console was expecting...
//            
//            // Write the SELECTION_LIST_ENTRY object(s) data
//            foreach(SelectionListInfo sli in slia.selectionListInfoCollection)
//            {
//                foreach(SelectionListEntry sle in sli.selectionListEntryCollection)
//                {
//                    SerializeUIMapEntry(sle, lt, bew);
//                }
//            }
        }

        public static void PreProcessUIMap(SelectionListInfoArray slia, bool skipVet)
        {
            LanguageType lt = LanguageType.ENGLISH;
            _offerTypeDefault = slia.OfferTypeDefault;
            _paymentTypeDefault = slia.PaymentTypeDefault;
            uint badSelListId = 0;

            LoadSelListTree(slia);
            if(!skipVet && !SelListNode.VetSelListTree(SelectionListNodes, out badSelListId))
                throw new Exception("Loops detected in the SelectionListInfo-Tree for SelectionListID: " + badSelListId.ToString());

            // Preload all langauge strings for quick access later
            foreach(LanguageLabels lls in slia.languageLabelsCollection)
            {
                lt = lls.languageType;

                foreach(LanguageLabel ll in lls.languageLabelCollection)
                {
                    // Make sure there aren't dupes
                    if(_languageStrings[(int)lt].Contains(ll.stringID))
                        throw new Exception("Multiple LanguageLabels using the same " + lt.ToString() + " StringID: " + ll.stringID.ToString());

                    if(ll.Value == null || ll.Value.Length < 1 )
                        throw new Exception("LanguageLabel using empty String for " + lt.ToString() + " StringID: " + ll.stringID.ToString());

                    _languageStrings[(int)lt][ll.stringID] = ll.Value;
                }
            }

            // Make sure the 'Master' IDs are present
            if(!_selectionListInfoIDs.Contains(XONLINE_UIMAP_STOREFRONT_ID))
                throw new Exception("Missing required SelectionListID for DASH: XONLINE_UIMAP_STOREFRONT_ID(" + XONLINE_UIMAP_STOREFRONT_ID.ToString() + ")");

            if(!_selectionListInfoIDs.Contains(XONLINE_UIMAP_LIVEARCADE_ID))
                throw new Exception("Missing required SelectionListID for DASH: XONLINE_UIMAP_LIVEARCADE_ID(" + XONLINE_UIMAP_LIVEARCADE_ID.ToString() + ")");

            if(!_selectionListInfoIDs.Contains(XONLINE_UIMAP_GAMERTILES_ID))
                throw new Exception("Missing required SelectionListID for DASH: XONLINE_UIMAP_GAMERTILES_ID(" + XONLINE_UIMAP_GAMERTILES_ID.ToString() + ")");

            if(!_selectionListInfoIDs.Contains(XONLINE_UIMAP_GAMES_ID))
                throw new Exception("Missing required SelectionListID for DASH: XONLINE_UIMAP_GAMES_ID(" + XONLINE_UIMAP_GAMES_ID.ToString() + ")");
            
            if(!_selectionListInfoIDs.Contains(XONLINE_UIMAP_GAMEVIDEOS_ID))
                throw new Exception("Missing required SelectionListID for DASH: XONLINE_UIMAP_GAMEVIDEOS_ID(" + XONLINE_UIMAP_GAMEVIDEOS_ID.ToString() + ")");
            
            if(!_selectionListInfoIDs.Contains(XONLINE_UIMAP_ENTERTAINMENT_ID))
                throw new Exception("Missing required SelectionListID for DASH: XONLINE_UIMAP_ENTERTAINMENT_ID(" + XONLINE_UIMAP_ENTERTAINMENT_ID.ToString() + ")");
            

        }

        private static void SerializeUIMapHeader(SelectionListInfoArray slia, BigEndianWriter bew)
        {
            //(Header)
            // DWORD dwNumSelectListInfos
            // DWORD dwTotalNumSelectionListEntries

            uint uiTotalInfos = 0;
            uint uiTotalEntries = 0;

            uiTotalInfos = (uint)slia.selectionListInfoCollection.Count;

            foreach(SelectionListInfo sli in slia.selectionListInfoCollection)
            {
                uiTotalEntries += (uint)sli.selectionListEntryCollection.Count;
            }

            // Write the one-and-only SELECTION_LIST_INFO_ARRAY object data
            bew.Write(uiTotalInfos);
            bew.Write(uiTotalEntries);
        }

        private static void SerializeUIMapInfo(SelectionListInfo sli, LanguageType lt, BigEndianWriter bew)
        {
            // DWORD dwSelectionListId		                
            // BYTE bBannerType		
            // WCHAR wszSceneTitle[60]		
            // DWORD dwNumSelectionListEntries		

            // Write the SELECTION_LIST_INFO object(s) data
            bew.Write((uint)sli.selectionListID);
            bew.Write((byte)sli.bannerType);

            if(!_languageStrings[(int)lt].Contains(sli.sceneTitleID))
                throw new Exception("Missing String for StringID " + sli.sceneTitleID.ToString() + " for language " + lt.ToString());

            bew.Write((string)_languageStrings[(int)lt][sli.sceneTitleID]);

            bew.Write((uint)sli.selectionListEntryCollection.Count);
        }

        private static void SerializeUIMapEntry(SelectionListEntry sle, LanguageType lt, BigEndianWriter bew)
        {
            // WORD wEntryType		                        
            // BYTE bIconId		
            // WCHAR wszLabel[60]		
            // SELECTION_LIST_DATA data		

            // Write the SELECTION_LIST_ENTRY object(s) data
            bew.Write((ushort)MapSelectionListType(sle.entryType));
            bew.Write((byte)sle.iconID);

            if(!_languageStrings[(int)lt].Contains(sle.labelID))
                throw new Exception("Missing String for StringID " + sle.labelID.ToString() + " for language " + lt.ToString());

            bew.Write((string)_languageStrings[(int)lt][sle.labelID]);

            switch(MapSelectionListType(sle.entryType))
            {
                case (ushort)SelectionListTypeEnum.SelectionList:
                {
                    if(!_selectionListInfoIDs.Contains(sle.selectionListTypeData.selectionListID))
                        throw new Exception("Non-existant SelectionListID " + sle.selectionListTypeData.selectionListID.ToString() + " used for a SelectionListEntry");

                    bew.Write((uint)sle.selectionListTypeData.selectionListID);
                }
                    break;
                case (ushort)SelectionListTypeEnum.TitleList:
                {
//                    DWORD dwGenreId;
//                    DWORD dwOfferType;
//                    WORD wRequestFlags;
//                    WCHAR wszNextSceneTitle[60];

                    bew.Write((uint)sle.titleListTypeData.genreID);
                    bew.Write((uint)GetOfferType(sle.titleListTypeData.offerTypeCollection));
                    bew.Write((ushort)GetRequestFlags(sle.titleListTypeData));

                    if(!_languageStrings[(int)lt].Contains(sle.titleListTypeData.nextSceneTitleID))
                        throw new Exception("Missing String for StringID " + sle.titleListTypeData.nextSceneTitleID.ToString() + " for language " + lt.ToString());

                    bew.Write((string)_languageStrings[(int)lt][sle.titleListTypeData.nextSceneTitleID]);
                }
                    break;
                case (ushort)SelectionListTypeEnum.GenreList:
                {
//                    DWORD dwParentGenreId;
//                    DWORD dwOfferType;
//                    WCHAR wszNextSceneTitle[60];

                    bew.Write((uint)sle.genreListTypeData.parentGenreID);
                    bew.Write((uint)GetOfferType(sle.genreListTypeData.offerTypeCollection));

                    if(!_languageStrings[(int)lt].Contains(sle.genreListTypeData.nextSceneTitleID))
                        throw new Exception("Missing String for StringID " + sle.genreListTypeData.nextSceneTitleID.ToString() + " for language " + lt.ToString());

                    bew.Write((string)_languageStrings[(int)lt][sle.genreListTypeData.nextSceneTitleID]);
                }
                    break;
                case (ushort)SelectionListTypeEnum.ContentList:
                {
//                    DWORD dwTitleId;			
//                    DWORD dwBitFilter;
//                    DWORD dwGenreId;			
//                    DWORD dwOfferType;
//                    DWORD dwPaymentType;		
//                    BYTE bRequestFlags;
//                    WCHAR wszNextSceneTitle[60];

                    bew.Write((uint)ParseUint(sle.contentListTypeData.titleID));
                    bew.Write((uint)ParseUint(sle.contentListTypeData.bitFilter));
                    bew.Write((uint)sle.contentListTypeData.genreID);
                    bew.Write((uint)GetOfferType(sle.contentListTypeData.offerTypeCollection));
                    bew.Write((uint)GetPaymentType(sle.contentListTypeData.paymentTypeCollection));
                    bew.Write((byte)GetRequestFlags(sle.contentListTypeData));

                    if(!_languageStrings[(int)lt].Contains(sle.contentListTypeData.nextSceneTitleID))
                        throw new Exception("Missing String for StringID " + sle.contentListTypeData.nextSceneTitleID.ToString() + " for language " + lt.ToString());

                    bew.Write((string)_languageStrings[(int)lt][sle.contentListTypeData.nextSceneTitleID]);
                }
                    break;

                case (ushort)SelectionListTypeEnum.FeaturedDownloads:  // nothing to write
                case (ushort)SelectionListTypeEnum.AccountLink:        // nothing to write
                    break;
                
                case (ushort)SelectionListTypeEnum.HUDEntryPoint:
                {
//                    DWORD dwEntryPoint;
//                    ULONGLONG qwOfferId;
//                    DWORD dwOfferType;
//                    DWORD dwContentCategories;
//                    DWORD dwTitleId;  
                    bew.Write((uint)MapHUDEntryPointType(sle.hudEntryPointTypeData.entryPointType));
                    bew.Write((ulong)ParseUlong(sle.hudEntryPointTypeData.offerID));
                    bew.Write((uint)GetOfferType(sle.hudEntryPointTypeData.offerTypeCollection));
                    bew.Write((uint)ParseUint(sle.hudEntryPointTypeData.contentCategories));
                    bew.Write((uint)ParseUint(sle.hudEntryPointTypeData.titleID));
                }
                    break;
                
                default:
                    break;
            }
        }

        private static uint GetOfferType(offerTypeCollection otc)
        {
            uint ote = 0;

            if(otc.Count < 1)
            {
                ote = MapOfferType(_offerTypeDefault);
            }
            else
            {
                foreach(OfferType ot in otc)
                {
                    ote |= MapOfferType(ot);
                }
            }
            
            return ote;
        }

        private static uint GetPaymentType(paymentTypeCollection ptc)
        {
            uint pte = 0;

            if(ptc.Count < 1)
            {
                pte = MapPaymentType(_paymentTypeDefault);
            }
            else
            {
                foreach(PaymentType pt in ptc)
                {
                    pte |= MapPaymentType(pt);
                }
            }

            return pte;
        }

        private static ushort GetRequestFlags(TitleListTypeData tltd)
        {
            XeEnumerateTitlesByFilterRequestFlags uRequestFlags = 0;

            if(tltd.@new)
                uRequestFlags |= XeEnumerateTitlesByFilterRequestFlags.QueryForNew;
            if(tltd.played)
                uRequestFlags |= XeEnumerateTitlesByFilterRequestFlags.QueryForPlayed;
            
            return (ushort)uRequestFlags;
        }

        private static byte GetRequestFlags(ContentListTypeData cltd)
        {
            XeContentEnumerateRequestFlags uRequestFlags = 0;

            if(cltd.@new)
                uRequestFlags |= XeContentEnumerateRequestFlags.NewContentOnlyFilter;
            if(cltd.played)
                uRequestFlags |= XeContentEnumerateRequestFlags.UserPlayedGameFilter;
            if(cltd.purchased)
                uRequestFlags |= XeContentEnumerateRequestFlags.UserHasPurchasedFilter;
            
            return (byte)uRequestFlags;
        }

        // Taken from common\offerutil\OfferManager
        public static ulong ParseUlong(string s)
        {
            s = s.Trim().ToUpper();
            
            ulong u;
            
            if (s.Length > 1 && s[0] == '0' && s[1] == 'X')
                u = UInt64.Parse(s.Substring(2), NumberStyles.HexNumber);
            else
            {
                try
                {
                    u = (ulong) Int64.Parse(s);
                }
                catch (FormatException)
                {
                    u = UInt64.Parse(s, NumberStyles.HexNumber);
                }
            }

            return u;
        }

        // Taken from common\offerutil\OfferManager
        public static uint ParseUint(string s)
        {
            s = s.Trim().ToUpper();
            
            uint i;
            
            if (s.Length > 1 && s[0] == '0' && s[1] == 'X')
                i = UInt32.Parse(s.Substring(2), NumberStyles.HexNumber);
            else
            {
                try
                {
                    i = (uint) Int32.Parse(s);
                }
                catch (FormatException)
                {
                    i = UInt32.Parse(s, NumberStyles.HexNumber);
                }
            }

            return i;
        }

        private static void LoadSelListTree(SelectionListInfoArray slia)
        {
            // Keep track of each outer scene's SelectionListID, so that inner entries can be verified against them
            foreach(SelectionListInfo sli in slia.selectionListInfoCollection)
            {
                uint parentSelListId = sli.selectionListID;
                SelListNode parentNode = null;

                // remember main / scene IDs
                _selectionListInfoIDs[parentSelListId] = parentSelListId;

                // if we don't have this node, make it
                if(!_selectionListNodes.ContainsKey(parentSelListId))
                {
                    _selectionListNodes[parentSelListId] = new SelListNode(parentSelListId, null);
                }

                parentNode = (SelListNode)_selectionListNodes[parentSelListId];

                // NOTE: Changed order of data in the file to match what Console was expecting...
                foreach(SelectionListEntry sle in sli.selectionListEntryCollection)
                {
                    // only selectionlist types matter
                    if(sle.entryType == SelectionListType.SelectionList)
                    {
                        uint childSelListId = sle.selectionListTypeData.selectionListID;
                        SelListNode childNode = null;

                        if(!_selectionListNodes.ContainsKey(childSelListId))
                        {
                            _selectionListNodes[childSelListId] = new SelListNode(childSelListId, parentNode);
                        }

                        childNode = (SelListNode)_selectionListNodes[childSelListId];
                        childNode.ParentNodeAdd(parentNode);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\velocity\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\velocity\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\velocity\AccelerationInterop.cs ===
using System;
using System.Text;
using System.Runtime.InteropServices;
using System.Threading;
using xonline.common.config;
    
namespace xonline.common.service
{
    [ComVisible(true)]
    [GuidAttribute("fd803f81-643d-4d56-af39-3feae0dbcc1a")]
    [ClassInterfaceAttribute(ClassInterfaceType.None)]
    public class AccelerationInteropImpl : IVelocity
    {
        private static int _numInterops = 0;

        private static Acceleration m_accel = null;

        static AccelerationInteropImpl()
        {
            m_accel = new Acceleration(Interface.NotificationCache);
        }

        public AccelerationInteropImpl()
        {
            if (Interlocked.Increment(ref _numInterops) == 1)
            {
                // singleton init code here.
            }
        }

        ~AccelerationInteropImpl()
        {
            try
            {
                // Only if this is the first COM object being closed should this be called.
                if (Interlocked.Decrement(ref _numInterops) == 0)
                {
                    // singleton destructor code here.
                }
            }
            catch(Exception)
            {
                // This is usually called during garbage collection. If a exception is thrown 
                // here, there will be nothing to catch it. This is not a big deal for 
                // ASP.NET applications but it's catastrophic for native applications.
            }
        }

        public void Init()
        {
        }

        public void Init(string[] rgsServers, ushort[] wPorts, bool fRoutingClient, bool fLocalCache, string sCacheName)
        {
        }

        public void Put(string sKey, byte[] rgbValue)
        {
            byte[] rgbKey = Encoding.ASCII.GetBytes(sKey);
            m_accel.SetData(rgbKey, rgbValue, 0, 0);
        }

        public byte[] Get(string sKey)
        {
            byte[] rgbValue;
            byte[] rgbKey = Encoding.ASCII.GetBytes(sKey);
            m_accel.Query(rgbKey, out rgbValue);
            return rgbValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\velocity\IVelocity.cs ===
using System;
using System.Text;
using System.Runtime.InteropServices;
using System.Threading;
using Microsoft.Data.Caching;

namespace xonline.common.service
{
    [ComVisible(true)]
    [Guid("466c0a67-d27b-47c4-8f45-4d916b0eb2bb")]
    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IVelocity
    {
        void Init();
        void Init(string[] rgsServers, ushort[] wPorts, bool fRoutingClient, bool fLocalCache, string sCacheName);

        void Put(string sKey, byte[] rgbValue);
        byte[] Get(string sKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\uimaputil\UIMapSchema.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.1
// Schema file: UIMap.xsd
// Creation Date: 3/24/2006 2:02:32 PM
//--------------------------------------------------------------

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace xonline.common.uimaputil
{

	public struct Declarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/uimap";
	}

	[Serializable]
	public enum LanguageType
	{
		[XmlEnum(Name="ENGLISH")] ENGLISH,
		[XmlEnum(Name="JAPANESE")] JAPANESE,
		[XmlEnum(Name="GERMAN")] GERMAN,
		[XmlEnum(Name="FRENCH")] FRENCH,
		[XmlEnum(Name="SPANISH")] SPANISH,
		[XmlEnum(Name="ITALIAN")] ITALIAN,
		[XmlEnum(Name="KOREAN")] KOREAN,
		[XmlEnum(Name="TCHINESE")] TCHINESE,
		[XmlEnum(Name="PORTUGUESE")] PORTUGUESE
	}

	[Serializable]
	public enum HUDEntryPointType
	{
		[XmlEnum(Name="ContentList")] ContentList,
		[XmlEnum(Name="ContentItem")] ContentItem,
		[XmlEnum(Name="MembershipList")] MembershipList,
		[XmlEnum(Name="MembershipItem")] MembershipItem,
		[XmlEnum(Name="AddPoints")] AddPoints,
		[XmlEnum(Name="PrepaidCode")] PrepaidCode,
		[XmlEnum(Name="GamertagPurchase")] GamertagPurchase,
		[XmlEnum(Name="ActiveDownloads")] ActiveDownloads
	}

	[Serializable]
	public enum PaymentType
	{
		[XmlEnum(Name="CreditCard")] CreditCard,
		[XmlEnum(Name="TokenOrVoucher")] TokenOrVoucher,
		[XmlEnum(Name="Points")] Points,
		[XmlEnum(Name="All")] All,
		[XmlEnum(Name="NoTokens")] NoTokens
	}

	[Serializable]
	public enum OfferType
	{
		[XmlEnum(Name="Subscription")] Subscription,
		[XmlEnum(Name="GameContent")] GameContent,
		[XmlEnum(Name="Renewal")] Renewal,
		[XmlEnum(Name="PointsBundle")] PointsBundle,
		[XmlEnum(Name="GamertagChange")] GamertagChange,
		[XmlEnum(Name="GameDemo")] GameDemo,
		[XmlEnum(Name="GameTrailer")] GameTrailer,
		[XmlEnum(Name="Theme")] Theme,
		[XmlEnum(Name="Gameplay")] Gameplay,
		[XmlEnum(Name="FullGame")] FullGame,
		[XmlEnum(Name="PromoPoints")] PromoPoints,
		[XmlEnum(Name="Tile")] Tile,
		[XmlEnum(Name="Trial")] Trial,
		[XmlEnum(Name="Arcade")] Arcade,
		[XmlEnum(Name="Video")] Video,
		[XmlEnum(Name="AllContent")] AllContent,
		[XmlEnum(Name="All")] All
	}

	[Serializable]
	public enum SelectionListType
	{
		[XmlEnum(Name="SelectionList")] SelectionList,
		[XmlEnum(Name="TitleList")] TitleList,
		[XmlEnum(Name="GenreList")] GenreList,
		[XmlEnum(Name="ContentList")] ContentList,
		[XmlEnum(Name="FeaturedDownloads")] FeaturedDownloads,
		[XmlEnum(Name="AccountLink")] AccountLink,
		[XmlEnum(Name="HUDEntryPoint")] HUDEntryPoint,
		[XmlEnum(Name="MediaMarketplaceLink")] MediaMarketplaceLink
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SelectionListInfoCollection : ArrayList
	{
		public xonline.common.uimaputil.SelectionListInfo Add(xonline.common.uimaputil.SelectionListInfo obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.uimaputil.SelectionListInfo Add()
		{
			return Add(new xonline.common.uimaputil.SelectionListInfo());
		}

		public void Insert(int index, xonline.common.uimaputil.SelectionListInfo obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.uimaputil.SelectionListInfo obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.uimaputil.SelectionListInfo this[int index]
		{
			get { return (xonline.common.uimaputil.SelectionListInfo) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class paymentTypeCollection : ArrayList
	{
		public xonline.common.uimaputil.PaymentType Add(xonline.common.uimaputil.PaymentType obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.uimaputil.PaymentType Add()
		{
			return Add(new xonline.common.uimaputil.PaymentType());
		}

		public void Insert(int index, xonline.common.uimaputil.PaymentType obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.uimaputil.PaymentType obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.uimaputil.PaymentType this[int index]
		{
			get { return (xonline.common.uimaputil.PaymentType) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class offerTypeCollection : ArrayList
	{
		public xonline.common.uimaputil.OfferType Add(xonline.common.uimaputil.OfferType obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.uimaputil.OfferType Add()
		{
			return Add(new xonline.common.uimaputil.OfferType());
		}

		public void Insert(int index, xonline.common.uimaputil.OfferType obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.uimaputil.OfferType obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.uimaputil.OfferType this[int index]
		{
			get { return (xonline.common.uimaputil.OfferType) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LanguageLabelCollection : ArrayList
	{
		public xonline.common.uimaputil.LanguageLabel Add(xonline.common.uimaputil.LanguageLabel obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.uimaputil.LanguageLabel Add()
		{
			return Add(new xonline.common.uimaputil.LanguageLabel());
		}

		public void Insert(int index, xonline.common.uimaputil.LanguageLabel obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.uimaputil.LanguageLabel obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.uimaputil.LanguageLabel this[int index]
		{
			get { return (xonline.common.uimaputil.LanguageLabel) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SelectionListEntryCollection : ArrayList
	{
		public xonline.common.uimaputil.SelectionListEntry Add(xonline.common.uimaputil.SelectionListEntry obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.uimaputil.SelectionListEntry Add()
		{
			return Add(new xonline.common.uimaputil.SelectionListEntry());
		}

		public void Insert(int index, xonline.common.uimaputil.SelectionListEntry obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.uimaputil.SelectionListEntry obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.uimaputil.SelectionListEntry this[int index]
		{
			get { return (xonline.common.uimaputil.SelectionListEntry) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LanguageLabelsCollection : ArrayList
	{
		public xonline.common.uimaputil.LanguageLabels Add(xonline.common.uimaputil.LanguageLabels obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.uimaputil.LanguageLabels Add()
		{
			return Add(new xonline.common.uimaputil.LanguageLabels());
		}

		public void Insert(int index, xonline.common.uimaputil.LanguageLabels obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.uimaputil.LanguageLabels obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.uimaputil.LanguageLabels this[int index]
		{
			get { return (xonline.common.uimaputil.LanguageLabels) base[index]; }
			set { base[index] = value; }
		}
	}



	[XmlType(TypeName="LanguageLabel",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LanguageLabel
	{

		[XmlAttribute(AttributeName="stringID",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __stringID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIDSpecified;
		
		[XmlIgnore]
		public uint stringID
		{ 
			get { return __stringID; }
			set { __stringID = value; __stringIDSpecified = true; }
		}

		[XmlText(DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Value;
		
		[XmlIgnore]
		public string Value
		{ 
			get { return __Value; }
			set { __Value = value; }
		}

		public LanguageLabel()
		{
			__stringIDSpecified = true;
		}
	}


	[XmlType(TypeName="SelectionListInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SelectionListInfo
	{

		[XmlAttribute(AttributeName="sceneTitleID",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __sceneTitleID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __sceneTitleIDSpecified;
		
		[XmlIgnore]
		public uint sceneTitleID
		{ 
			get { return __sceneTitleID; }
			set { __sceneTitleID = value; __sceneTitleIDSpecified = true; }
		}

		[XmlElement(ElementName="selectionListID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __selectionListID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __selectionListIDSpecified;
		
		[XmlIgnore]
		public uint selectionListID
		{ 
			get { return __selectionListID; }
			set { __selectionListID = value; __selectionListIDSpecified = true; }
		}

		[XmlElement(ElementName="bannerType",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedByte",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __bannerType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __bannerTypeSpecified;
		
		[XmlIgnore]
		public byte bannerType
		{ 
			get { return __bannerType; }
			set { __bannerType = value; __bannerTypeSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.SelectionListEntry),ElementName="selectionListEntry",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SelectionListEntryCollection __selectionListEntryCollection;
		
		[XmlIgnore]
		public SelectionListEntryCollection selectionListEntryCollection
		{
			get
			{
				if (__selectionListEntryCollection == null) __selectionListEntryCollection = new SelectionListEntryCollection();
				return __selectionListEntryCollection;
			}
			set {__selectionListEntryCollection = value;}
		}

		public SelectionListInfo()
		{
			__sceneTitleIDSpecified = true;
			__selectionListIDSpecified = true;
			__bannerTypeSpecified = true;
		}
	}


	[XmlType(TypeName="ContentListTypeData",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContentListTypeData
	{

		[XmlAttribute(AttributeName="nextSceneTitleID",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextSceneTitleID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextSceneTitleIDSpecified;
		
		[XmlIgnore]
		public uint nextSceneTitleID
		{ 
			get { return __nextSceneTitleID; }
			set { __nextSceneTitleID = value; __nextSceneTitleIDSpecified = true; }
		}

		[XmlElement(ElementName="titleID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleID;
		
		[XmlIgnore]
		public string titleID
		{ 
			get { return __titleID; }
			set { __titleID = value; }
		}

		[XmlElement(ElementName="bitFilter",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __bitFilter;
		
		[XmlIgnore]
		public string bitFilter
		{ 
			get { return __bitFilter; }
			set { __bitFilter = value; }
		}

		[XmlElement(ElementName="genreID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __genreID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __genreIDSpecified;
		
		[XmlIgnore]
		public uint genreID
		{ 
			get { return __genreID; }
			set { __genreID = value; __genreIDSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.OfferType),ElementName="offerType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public offerTypeCollection __offerTypeCollection;
		
		[XmlIgnore]
		public offerTypeCollection offerTypeCollection
		{
			get
			{
				if (__offerTypeCollection == null) __offerTypeCollection = new offerTypeCollection();
				return __offerTypeCollection;
			}
			set {__offerTypeCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.PaymentType),ElementName="paymentType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public paymentTypeCollection __paymentTypeCollection;
		
		[XmlIgnore]
		public paymentTypeCollection paymentTypeCollection
		{
			get
			{
				if (__paymentTypeCollection == null) __paymentTypeCollection = new paymentTypeCollection();
				return __paymentTypeCollection;
			}
			set {__paymentTypeCollection = value;}
		}

		[XmlElement(ElementName="new",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __new;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __newSpecified;
		
		[XmlIgnore]
		public bool @new
		{ 
			get { return __new; }
			set { __new = value; __newSpecified = true; }
		}

		[XmlElement(ElementName="played",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __played;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __playedSpecified;
		
		[XmlIgnore]
		public bool played
		{ 
			get { return __played; }
			set { __played = value; __playedSpecified = true; }
		}

		[XmlElement(ElementName="purchased",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __purchased;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __purchasedSpecified;
		
		[XmlIgnore]
		public bool purchased
		{ 
			get { return __purchased; }
			set { __purchased = value; __purchasedSpecified = true; }
		}

		public ContentListTypeData()
		{
			__nextSceneTitleIDSpecified = true;
			titleID = "0";
			bitFilter = "0xFFFFFFFF";
			genreID = 0;
			@new = false;
			played = false;
			purchased = false;
		}
	}


	[XmlType(TypeName="SelectionListEntry",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SelectionListEntry
	{

		[XmlAttribute(AttributeName="labelID",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __labelID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __labelIDSpecified;
		
		[XmlIgnore]
		public uint labelID
		{ 
			get { return __labelID; }
			set { __labelID = value; __labelIDSpecified = true; }
		}

		[XmlElement(ElementName="entryType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.uimaputil.SelectionListType __entryType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __entryTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.uimaputil.SelectionListType entryType
		{ 
			get { return __entryType; }
			set { __entryType = value; __entryTypeSpecified = true; }
		}

		[XmlElement(ElementName="iconID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedByte",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __iconID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __iconIDSpecified;
		
		[XmlIgnore]
		public byte iconID
		{ 
			get { return __iconID; }
			set { __iconID = value; __iconIDSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.SelectionListTypeData),ElementName="selectionListTypeData",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.uimaputil.SelectionListTypeData __selectionListTypeData;
		
		[XmlIgnore]
		public xonline.common.uimaputil.SelectionListTypeData selectionListTypeData
		{
			get
			{
				if (__selectionListTypeData == null) __selectionListTypeData = new xonline.common.uimaputil.SelectionListTypeData();		
				return __selectionListTypeData;
			}
			set {__selectionListTypeData = value;}
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.TitleListTypeData),ElementName="titleListTypeData",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.uimaputil.TitleListTypeData __titleListTypeData;
		
		[XmlIgnore]
		public xonline.common.uimaputil.TitleListTypeData titleListTypeData
		{
			get
			{
				if (__titleListTypeData == null) __titleListTypeData = new xonline.common.uimaputil.TitleListTypeData();		
				return __titleListTypeData;
			}
			set {__titleListTypeData = value;}
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.GenreListTypeData),ElementName="genreListTypeData",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.uimaputil.GenreListTypeData __genreListTypeData;
		
		[XmlIgnore]
		public xonline.common.uimaputil.GenreListTypeData genreListTypeData
		{
			get
			{
				if (__genreListTypeData == null) __genreListTypeData = new xonline.common.uimaputil.GenreListTypeData();		
				return __genreListTypeData;
			}
			set {__genreListTypeData = value;}
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.ContentListTypeData),ElementName="contentListTypeData",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.uimaputil.ContentListTypeData __contentListTypeData;
		
		[XmlIgnore]
		public xonline.common.uimaputil.ContentListTypeData contentListTypeData
		{
			get
			{
				if (__contentListTypeData == null) __contentListTypeData = new xonline.common.uimaputil.ContentListTypeData();		
				return __contentListTypeData;
			}
			set {__contentListTypeData = value;}
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.HUDEntryPointTypeData),ElementName="hudEntryPointTypeData",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.uimaputil.HUDEntryPointTypeData __hudEntryPointTypeData;
		
		[XmlIgnore]
		public xonline.common.uimaputil.HUDEntryPointTypeData hudEntryPointTypeData
		{
			get
			{
				if (__hudEntryPointTypeData == null) __hudEntryPointTypeData = new xonline.common.uimaputil.HUDEntryPointTypeData();		
				return __hudEntryPointTypeData;
			}
			set {__hudEntryPointTypeData = value;}
		}

		public SelectionListEntry()
		{
			__labelIDSpecified = true;
			__entryTypeSpecified = true;
			iconID = 0;
		}
	}


	[XmlType(TypeName="HUDEntryPointTypeData",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class HUDEntryPointTypeData
	{

		[XmlElement(ElementName="entryPointType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.uimaputil.HUDEntryPointType __entryPointType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __entryPointTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.uimaputil.HUDEntryPointType entryPointType
		{ 
			get { return __entryPointType; }
			set { __entryPointType = value; __entryPointTypeSpecified = true; }
		}

		[XmlElement(ElementName="offerID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __offerID;
		
		[XmlIgnore]
		public string offerID
		{ 
			get { return __offerID; }
			set { __offerID = value; }
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.OfferType),ElementName="offerType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public offerTypeCollection __offerTypeCollection;
		
		[XmlIgnore]
		public offerTypeCollection offerTypeCollection
		{
			get
			{
				if (__offerTypeCollection == null) __offerTypeCollection = new offerTypeCollection();
				return __offerTypeCollection;
			}
			set {__offerTypeCollection = value;}
		}

		[XmlElement(ElementName="contentCategories",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __contentCategories;
		
		[XmlIgnore]
		public string contentCategories
		{ 
			get { return __contentCategories; }
			set { __contentCategories = value; }
		}

		[XmlElement(ElementName="titleID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleID;
		
		[XmlIgnore]
		public string titleID
		{ 
			get { return __titleID; }
			set { __titleID = value; }
		}

		public HUDEntryPointTypeData()
		{
			__entryPointTypeSpecified = true;
			offerID = "0";
			contentCategories = "0xFFFFFFFF";
			titleID = "0";
		}
	}


	[XmlType(TypeName="GenreListTypeData",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GenreListTypeData
	{

		[XmlAttribute(AttributeName="nextSceneTitleID",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextSceneTitleID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextSceneTitleIDSpecified;
		
		[XmlIgnore]
		public uint nextSceneTitleID
		{ 
			get { return __nextSceneTitleID; }
			set { __nextSceneTitleID = value; __nextSceneTitleIDSpecified = true; }
		}

		[XmlElement(ElementName="parentGenreID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __parentGenreID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __parentGenreIDSpecified;
		
		[XmlIgnore]
		public uint parentGenreID
		{ 
			get { return __parentGenreID; }
			set { __parentGenreID = value; __parentGenreIDSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.OfferType),ElementName="offerType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public offerTypeCollection __offerTypeCollection;
		
		[XmlIgnore]
		public offerTypeCollection offerTypeCollection
		{
			get
			{
				if (__offerTypeCollection == null) __offerTypeCollection = new offerTypeCollection();
				return __offerTypeCollection;
			}
			set {__offerTypeCollection = value;}
		}

		public GenreListTypeData()
		{
			__nextSceneTitleIDSpecified = true;
			__parentGenreIDSpecified = true;
		}
	}


	[XmlType(TypeName="TitleListTypeData",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class TitleListTypeData
	{

		[XmlAttribute(AttributeName="nextSceneTitleID",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextSceneTitleID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextSceneTitleIDSpecified;
		
		[XmlIgnore]
		public uint nextSceneTitleID
		{ 
			get { return __nextSceneTitleID; }
			set { __nextSceneTitleID = value; __nextSceneTitleIDSpecified = true; }
		}

		[XmlElement(ElementName="genreID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __genreID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __genreIDSpecified;
		
		[XmlIgnore]
		public uint genreID
		{ 
			get { return __genreID; }
			set { __genreID = value; __genreIDSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.OfferType),ElementName="offerType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public offerTypeCollection __offerTypeCollection;
		
		[XmlIgnore]
		public offerTypeCollection offerTypeCollection
		{
			get
			{
				if (__offerTypeCollection == null) __offerTypeCollection = new offerTypeCollection();
				return __offerTypeCollection;
			}
			set {__offerTypeCollection = value;}
		}

		[XmlElement(ElementName="new",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __new;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __newSpecified;
		
		[XmlIgnore]
		public bool @new
		{ 
			get { return __new; }
			set { __new = value; __newSpecified = true; }
		}

		[XmlElement(ElementName="played",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __played;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __playedSpecified;
		
		[XmlIgnore]
		public bool played
		{ 
			get { return __played; }
			set { __played = value; __playedSpecified = true; }
		}

		public TitleListTypeData()
		{
			__nextSceneTitleIDSpecified = true;
			genreID = 0;
			@new = false;
			played = false;
		}
	}


	[XmlType(TypeName="SelectionListTypeData",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SelectionListTypeData
	{

		[XmlElement(ElementName="selectionListID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __selectionListID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __selectionListIDSpecified;
		
		[XmlIgnore]
		public uint selectionListID
		{ 
			get { return __selectionListID; }
			set { __selectionListID = value; __selectionListIDSpecified = true; }
		}

		public SelectionListTypeData()
		{
			__selectionListIDSpecified = true;
		}
	}


	[XmlType(TypeName="LanguageLabels",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LanguageLabels
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return languageLabelCollection.GetEnumerator();
		}

		public xonline.common.uimaputil.LanguageLabel Add(xonline.common.uimaputil.LanguageLabel obj)
		{
			return languageLabelCollection.Add(obj);
		}

		[XmlIgnore]
		public xonline.common.uimaputil.LanguageLabel this[int index]
		{
			get { return (xonline.common.uimaputil.LanguageLabel) languageLabelCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return languageLabelCollection.Count; }
        }

        public void Clear()
		{
            languageLabelCollection.Clear();
        }

		public xonline.common.uimaputil.LanguageLabel Remove(int index) 
		{ 
            xonline.common.uimaputil.LanguageLabel obj = languageLabelCollection[index];
            languageLabelCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            languageLabelCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="languageType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.uimaputil.LanguageType __languageType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __languageTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.uimaputil.LanguageType languageType
		{ 
			get { return __languageType; }
			set { __languageType = value; __languageTypeSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.LanguageLabel),ElementName="languageLabel",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LanguageLabelCollection __languageLabelCollection;
		
		[XmlIgnore]
		public LanguageLabelCollection languageLabelCollection
		{
			get
			{
				if (__languageLabelCollection == null) __languageLabelCollection = new LanguageLabelCollection();
				return __languageLabelCollection;
			}
			set {__languageLabelCollection = value;}
		}

		public LanguageLabels()
		{
		}
	}


	[XmlRoot(ElementName="SelectionListInfoArray",Namespace=Declarations.SchemaVersion,IsNullable=false),Serializable]
	public class SelectionListInfoArray
	{

		[XmlElement(Type=typeof(xonline.common.uimaputil.SelectionListInfo),ElementName="selectionListInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SelectionListInfoCollection __selectionListInfoCollection;
		
		[XmlIgnore]
		public SelectionListInfoCollection selectionListInfoCollection
		{
			get
			{
				if (__selectionListInfoCollection == null) __selectionListInfoCollection = new SelectionListInfoCollection();
				return __selectionListInfoCollection;
			}
			set {__selectionListInfoCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.uimaputil.LanguageLabels),ElementName="languageLabels",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LanguageLabelsCollection __languageLabelsCollection;
		
		[XmlIgnore]
		public LanguageLabelsCollection languageLabelsCollection
		{
			get
			{
				if (__languageLabelsCollection == null) __languageLabelsCollection = new LanguageLabelsCollection();
				return __languageLabelsCollection;
			}
			set {__languageLabelsCollection = value;}
		}

		[XmlElement(ElementName="OfferTypeDefault",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.uimaputil.OfferType __OfferTypeDefault;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __OfferTypeDefaultSpecified;
		
		[XmlIgnore]
		public xonline.common.uimaputil.OfferType OfferTypeDefault
		{ 
			get { return __OfferTypeDefault; }
			set { __OfferTypeDefault = value; __OfferTypeDefaultSpecified = true; }
		}

		[XmlElement(ElementName="PaymentTypeDefault",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.uimaputil.PaymentType __PaymentTypeDefault;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __PaymentTypeDefaultSpecified;
		
		[XmlIgnore]
		public xonline.common.uimaputil.PaymentType PaymentTypeDefault
		{ 
			get { return __PaymentTypeDefault; }
			set { __PaymentTypeDefault = value; __PaymentTypeDefaultSpecified = true; }
		}

		public SelectionListInfoArray()
		{
			OfferTypeDefault = xonline.common.uimaputil.OfferType.AllContent;
			PaymentTypeDefault = xonline.common.uimaputil.PaymentType.NoTokens;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\velocity\VelocityInterop.cs ===
using System;
using System.Text;
using System.Runtime.InteropServices;
using System.Threading;
using Microsoft.Data.Caching;

namespace xonline.common.service
{
    [ComVisible(true)]
    [GuidAttribute("1462085b-f6e2-41c1-9d95-f41a2a5594f1")]
    [ClassInterfaceAttribute(ClassInterfaceType.None)]
    public class VelocityInteropImpl : IVelocity
    {
        private static int _numInterops = 0;

        private DataCacheFactory m_factory = null;
        private DataCache m_cache = null;

        public VelocityInteropImpl()
        {
            if (Interlocked.Increment(ref _numInterops) == 1)
            {
                // singleton init code here.
            }
        }

        ~VelocityInteropImpl()
        {
            try
            {
                // Only if this is the first COM object being closed should this be called.
                if (Interlocked.Decrement(ref _numInterops) == 0)
                {
                    // singleton destructor code here.
                }
            }
            catch(Exception)
            {
                // This is usually called during garbage collection. If a exception is thrown 
                // here, there will be nothing to catch it. This is not a big deal for 
                // ASP.NET applications but it's catastrophic for native applications.
            }
        }

        public void Init()
        {
            m_factory = new DataCacheFactory();
            m_cache = m_factory.GetDefaultCache();
        }

        public void Init(string[] rgsServers, ushort[] wPorts, bool fRoutingClient, bool fLocalCache, string sCacheName)
        {
            DataCacheServerEndpoint[] rgEndpoints = new DataCacheServerEndpoint[rgsServers.Length];
            for (int iServer = 0; iServer < rgsServers.Length; iServer++)
            {
                rgEndpoints[iServer] = new DataCacheServerEndpoint(rgsServers[iServer], wPorts[iServer], "DistributedCacheService");
            }
            
            m_factory = new DataCacheFactory(rgEndpoints, fRoutingClient, fLocalCache);
            m_cache = m_factory.GetCache(sCacheName);
        }

        public void Put(string sKey, byte[] rgbValue)
        {
            m_cache.Put(sKey, rgbValue);
        }

        public byte[] Get(string sKey)
        {
            return (byte[])m_cache.Get(sKey);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by wsreader.rc
//
#define IDS_PROJNAME                    100
#define IDR_WSDATAREADER                101
#define IDR_WSRESULTSET                 102
#define IDR_WSParameters                103
#define IDR_WSSession                   104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A3E6B8D4_538C_46DB_AD4D_0FF07F63B755__INCLUDED_)
#define AFX_STDAFX_H__A3E6B8D4_538C_46DB_AD4D_0FF07F63B755__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlsafe.h>

#include <oledberr.h>
#include "wststore.h"


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A3E6B8D4_538C_46DB_AD4D_0FF07F63B755__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\WSDataReader.h ===
// WSDataReader.h : Declaration of the CWSDataReader

#ifndef __WSDATAREADER_H_
#define __WSDATAREADER_H_

#include "resource.h"       // main symbols
#include "wsparameters.h"
#include "wsresultset.h"
#include "wssession.h"

/////////////////////////////////////////////////////////////////////////////
// CWSDataReader
class ATL_NO_VTABLE CWSDataReader : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CWSDataReader, &CLSID_WSDataReader>,
    public ISupportErrorInfo,
    public IDispatchImpl<IWSDataReader, &IID_IWSDataReader, &LIBID_WSREADERLib>
{
public:

    CWSDataReader()
    {
    }

    HRESULT FinalConstruct();
    void    FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_WSDATAREADER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWSDataReader)
    COM_INTERFACE_ENTRY(IWSDataReader)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

public:

    STDMETHOD(Initialize)(BSTR bstrAppName);
    STDMETHOD(DeInitialize)();

    STDMETHOD(Execute)(LONG cmdType, LONG lHash, BSTR bstrCmd, IWSParameters* pParameters, IWSResultset** ppiResultset);
    STDMETHOD(ExecuteReturnRowset)(LONG cmdType, LONG lHash, BSTR bstrCmd, IWSParameters* pParameters, IWSResultset** ppiResultset);
    STDMETHOD(ExecuteNonQuery)(LONG cmdType, LONG lHash, BSTR bstrCmd, IWSParameters* pParameters);
    STDMETHOD(GetSession)(LONG cmdType, LONG lHash, IWSSession** ppiSession);

    STDMETHOD(GetPartitionFromInt32)(LONG lValue, LONG* lPartition);
    STDMETHOD(GetPartitionFromInt64)(LONGLONG qwValue, LONG* lPartition);
    STDMETHOD(GetPartitionFromString)(BSTR bstrValue, LONG* lPartition);
    STDMETHOD(get_PartitionCount)(LONG* pValue);
    STDMETHOD(SetPartitionMode)(WSREADER_PARTITION_MODE mode);
    STDMETHOD(GetPhysicalFromLogical)(LONG lLogical, LONG* plPhysical);
    STDMETHOD(get_LogicalPartitionCount)(LONG* pValue);
    STDMETHOD(get_PhysicalPartitionCount)(LONG* pValue);

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWSDataReader
protected:
    CComPtr<IWSTStore>      m_piWSTStore;
    CComPtr<IWSTCommand>    m_piCommand;
    CComPtr<IWSTHash>       m_piHash;
    CComPtr<IWSTPartition>  m_piPartition;

    LONG                    m_lPartitions;
    bool                    m_bInitialized;

protected:
    void    ReportError(HRESULT hr, LPCTSTR pszMsg);
    void    ReportError(HRESULT hr);


public:
    STDMETHOD(InitializeEx)(BSTR bstrAppName, BOOL fSequentialAccess);
};

#endif //__WSDATAREADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\WSParameters.h ===
// WSParameters.h : Declaration of the CWSParameters

#pragma once
#include "resource.h"       // main symbols
#include "wsreader.h"
#include "WSDataReader.h"


// CWSParameters

class ATL_NO_VTABLE CWSParameters : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWSParameters, &CLSID_WSParameters>,
	public ISupportErrorInfo,
	public IDispatchImpl<IWSParameters, &IID_IWSParameters, &LIBID_WSREADERLib, /*wMajor =*/ 1, /*wMinor =*/ 0>
{
public:
	CWSParameters()
	{
		m_cAllocParams	= 0;
		m_CmdInfo.cbParam = 0;
		m_CmdInfo.nParams = 0;
		m_CmdInfo.pParam  = NULL;
		m_CmdInfo.rgParams = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_WSParameters)


BEGIN_COM_MAP(CWSParameters)
	COM_INTERFACE_ENTRY(IWSParameters)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()


	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct();
	void FinalRelease();

public:
// IWSParameters
    STDMETHOD(AddByte)(LONG lDirection, BYTE bValue);
    STDMETHOD(AddInt16)(LONG lDirection, SHORT siValue);
	STDMETHOD(AddInt32)(LONG lDirection, LONG lValue);
	STDMETHOD(AddInt64)(LONG lDirection, LONGLONG qwValue);
	STDMETHOD(AddDate)(LONG lDirection, DATE dtValue);
	STDMETHOD(AddString)(LONG lDirection, BSTR bstrValue, ULONG ulMaxLen);
	STDMETHOD(AddByteArray)(LONG lDirection, SAFEARRAY* psaValue, ULONG ulMaxLen);

	STDMETHOD(GetByte)(ULONG ulOrdinal, BYTE* pbValue);
	STDMETHOD(GetInt16)(ULONG ulOrdinal, SHORT* psiValue);
	STDMETHOD(GetInt32)(ULONG ulOrdinal, LONG* plValue);
	STDMETHOD(GetInt64)(ULONG ulOrdinal, LONGLONG* pqwValue);
	STDMETHOD(GetDate)(ULONG ulOrdinal, DATE* pdtValue);
	STDMETHOD(GetString)(ULONG ulOrdinal, BSTR* pbstrValue);
    STDMETHOD(GetByteArray)(ULONG ulOrdinal, SAFEARRAY** psaBytes);
	STDMETHOD(IsDBNull)(ULONG ulOrdinal, VARIANT_BOOL* bIsNull);
    STDMETHOD(CleanUp)(void);

    STDMETHOD(get_CmdInfo)(BYTE** ppCmdInfo);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);


private:
	WSTCOMMANDINFO	m_CmdInfo;
   	LONG	        m_cAllocParams;

#ifdef DEBUG
    DWORD           m_dwThreadId;
#endif

	HRESULT	AddParam(LONG lParamIO, LONG lParamType, LONG paramSize, LPVOID pvParamValue, LONG lParamValueSize = -1);
	HRESULT ValidateGetParamArgs(ULONG ulOrdinal, LPVOID pvValue, VARIANT_BOOL* pbIsNull);

	void	ReportError(HRESULT hr, LPCTSTR pszMsg);
	void	ReportError(HRESULT hr);

};

OBJECT_ENTRY_AUTO(__uuidof(WSParameters), CWSParameters)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\wsrdefs.h ===
// wsrdefs.h : #defines for wsrreader

#pragma once



// 
// values to use when the column / parameter comes back null
//
#define NUMERIC_NULL_VALUE	0
#define STRING_NULL_VALUE	L""
#define DATE_NULL_VALUE		0		// 12/31/1899

#define DW_ALIGN(x)                   ((x) + 3 & ~ 3)

//
// Starting buffer sizes.  When these are exceeded, 
//	memory is Realloc'd with each additional item.
//  Therefore, the optimial size is one that covers
//	most cases w/o wasting too much memory.
//
#define INITIAL_PARAM_BUF_SIZE			512
#define INITIAL_PARAM_ALLOC_COUNT		5

// assumed to be dword aligned..
#define INITIAL_PARAM_NAME_BUF_SIZE		12 * INITIAL_PARAM_ALLOC_COUNT




//
// error codes
//

#define WSR_E_NOTINITIALIZED		MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 1701)

#define WSR_E_NOCURRENTROW			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 1702)

#define WSR_E_COLUMNOUTOFRANGE		MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 1703)

#define WSR_E_TYPEMISMATCH			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 1704)

#define WSR_E_ORDINALOUTOFRANGE		MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 1705)

#define WSR_E_NAMENOTFOUND			MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 1706)

#define WSR_E_WRONG_THREAD          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 1707)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\wsreader.cpp ===
// wsreader.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f wsreaderps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "wsreader.h"

#include "wsreader_i.c"
#include "WSDataReader.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WSDataReader, CWSDataReader)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WSREADERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\WSParameters.cpp ===
////////////////////////////////////////////////////////////////
// WSParameters.cpp 
//
// ABSTRACT: 
//  Implementation of CWSParameters class.    This class
//  collects and builds the parameter list to be passed
//  to WSDataReader::Execute().    After execution, the
//  parameters are filled with any return values/output 
//  paraemters as specified by the stored proc called.
//
// HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK 
//  although this object's threading model is marked as
//  'Both', it should be treated as apartment threaded. 
//  It's marked as supporting both so that Execute() can
//  efficiently access m_CmdInfo w/o marshalling.  I'm sure
//  there's an easier way -- email slamb if you have 
//  suggestions. :) 
// HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK 
//
////////////////////////////////////////////////////////////////



#include "stdafx.h"
#include "wsrdefs.h"
#include "WSParameters.h"


#ifdef DEBUG
#define ENSURE_APARTMENT_ACCESS() \
    if(GetCurrentThreadId() != m_dwThreadId) { \
        ATLTRACE("Mismatched Thread IDS!  %d\n", GetCurrentThreadId()); \
        ReportError(WSR_E_WRONG_THREAD); \
        return WSR_E_WRONG_THREAD; \
    } \

#else
#define ENSURE_APARTMENT_ACCESS()
#endif


////////////////////////////////////////////////////////////////
// CWSParameters::AddByte
//
//      Adds a parameter to the next call to Execute.
//
//  Parameters
//      lDriection          one of the following:
//                          DBPARAM_INPUT = 1
//                          DBPARAM_OUTPUT = 2
//      bValue              Parameter value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::AddByte(LONG lDirection, BYTE bValue)
{
    ENSURE_APARTMENT_ACCESS();
    return AddParam(lDirection, DBTYPE_UI1, sizeof(BYTE), &bValue);
}


////////////////////////////////////////////////////////////////
// CWSParameters::AddInt16
//
//      Adds a parameter to the next call to Execute.
//
//  Parameters
//      lDriection          one of the following:
//                          DBPARAM_INPUT = 1
//                          DBPARAM_OUTPUT = 2
//      siValue             Parameter value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::AddInt16(LONG lDirection, SHORT siValue)
{
    ENSURE_APARTMENT_ACCESS();
    return AddParam(lDirection, DBTYPE_I2, sizeof(SHORT), &siValue);
}

////////////////////////////////////////////////////////////////
// CWSParameters::AddInt32
//
//      Adds a parameter to the next call to Execute.
//
//  Parameters
//      lDriection          one of the following:
//                          DBPARAM_INPUT = 1
//                          DBPARAM_OUTPUT = 2
//      lValue              Parameter value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::AddInt32(LONG lDirection, LONG lValue)
{
    ENSURE_APARTMENT_ACCESS();
    return AddParam(lDirection, DBTYPE_I4, sizeof(LONG), &lValue);
}


////////////////////////////////////////////////////////////////
// CWSParameters::AddInt64
//
//      Adds a parameter to the next call to Execute.
//
//  Parameters
//      lDriection          one of the following:
//                          DBPARAM_INPUT = 1
//                          DBPARAM_OUTPUT = 2
//      qwValue             Parameter value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::AddInt64(LONG lDirection, LONGLONG qwValue)
{
    ENSURE_APARTMENT_ACCESS();
    return AddParam(lDirection, DBTYPE_I8, sizeof(LONGLONG), &qwValue);
}

////////////////////////////////////////////////////////////////
// CWSParameters::AddDate
//
//      Adds a parameter to the next call to Execute.
//
//  Parameters
//      lDriection          one of the following:
//                          DBPARAM_INPUT = 1
//                          DBPARAM_OUTPUT = 2
//      dtValue             Parameter value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::AddDate(LONG lDirection, DATE dtValue)
{
    ENSURE_APARTMENT_ACCESS();
    return AddParam(lDirection, DBTYPE_DATE, sizeof(DATE), &dtValue);
}

////////////////////////////////////////////////////////////////
// CWSParameters::AddString
//
//      Adds a parameter to the next call to Execute.
//
//  Parameters
//      lDriection          one of the following:
//                          DBPARAM_INPUT = 1
//                          DBPARAM_OUTPUT = 2
//      bstrValue           Parameter value.
//      ulMaxLen            Max length, used for the buffer
//                          in output values.   Either
//                          bstrValue and/or ulMaxLen must be
//                          specified.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::AddString(LONG lDirection, BSTR bstrValue, ULONG ulMaxLen)
{
    ENSURE_APARTMENT_ACCESS();

    LONG cbValue = 0;
    if (bstrValue != NULL)
    {
        cbValue = SysStringLen(bstrValue) * sizeof(WCHAR);
    }

    if (ulMaxLen == 0)
    {
        if (bstrValue == NULL && lDirection == 2)
        {
            ReportError(E_INVALIDARG, L"bstrValue must be non-null and/or ulMaxLen must be non-zero for output Parameters");
            return E_INVALIDARG;
        }

        ulMaxLen = SysStringLen(bstrValue);
    }

    // allow for terminating null in string
    return AddParam(lDirection, DBTYPE_WSTR, (ulMaxLen + 1) * sizeof(WCHAR), bstrValue, cbValue);
}


////////////////////////////////////////////////////////////////
// CWSParameters::AddByteArray
//
//      Adds a parameter to the next call to Execute.
//
//  Parameters
//      lDriection          one of the following:
//                          DBPARAM_INPUT = 1
//                          DBPARAM_OUTPUT = 2
//      bstrValue           Parameter value.
//      ulMaxLen            Max length, used for the buffer
//                          in output values.   Either
//                          bstrValue and/or ulMaxLen must be
//                          specified.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::AddByteArray(LONG lDirection, SAFEARRAY* psaValue, ULONG ulMaxLen)
{
    ENSURE_APARTMENT_ACCESS();

    LONG cbValue = 0;

    if (ulMaxLen == 0)
    {
        if (psaValue == NULL)
        {
            if (lDirection == 2)
            {
                ReportError(E_INVALIDARG, L"psaValue must be non-null and/or ulMaxLen must be non-zero for output Parameters");
                return E_INVALIDARG;
            }
        }
        else
        {
            if (SafeArrayGetDim(psaValue) > 1)
            {
                ReportError(E_INVALIDARG, L"Only one-dimension arrays supported!");
                return E_INVALIDARG;
            }

            SafeArrayGetUBound(psaValue, 1, (LONG*)&ulMaxLen);
            ulMaxLen++;
        }
    }

    if (psaValue != NULL)
    {
        SafeArrayGetUBound(psaValue, 1, (LONG*)&cbValue);
        cbValue++;
    }

    return AddParam(lDirection, DBTYPE_BYTES, ulMaxLen, (psaValue ? psaValue->pvData : NULL), cbValue);
}

////////////////////////////////////////////////////////////////
// CWSParameters::GetByte
//
//      Retrives the given parameter value.
//
//  Parameters
//      ulOrdinal           the 0-based ordinal of the
//                          parameter.
//      psiValue            Pointer to a buffer to be filled
//                          with the param value.vs
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::GetByte(ULONG ulOrdinal, BYTE* pbValue)
{
    HRESULT hr = S_OK;
    WSTCOMMANDPARAM* pParam;
    VARIANT_BOOL bIsNull;
    
    ENSURE_APARTMENT_ACCESS();

    hr = ValidateGetParamArgs(ulOrdinal, pbValue, &bIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    if (bIsNull)
    {
        *pbValue = NUMERIC_NULL_VALUE;
        goto Cleanup;
    }

    pParam = &m_CmdInfo.rgParams[ulOrdinal];
    switch(pParam->paramType)
    {
    case DBTYPE_UI1:
        *pbValue = *((PBYTE)m_CmdInfo.pParam + pParam->paramOffset);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}



////////////////////////////////////////////////////////////////
// CWSParameters::GetInt16
//
//      Retrives the given parameter value.
//
//  Parameters
//      ulOrdinal           the 0-based ordinal of the
//                          parameter.
//      psiValue            Pointer to a buffer to be filled
//                          with the param value.vs
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::GetInt16(ULONG ulOrdinal, SHORT* psiValue)
{
    HRESULT hr = S_OK;
    WSTCOMMANDPARAM* pParam;
    VARIANT_BOOL bIsNull;
    
    ENSURE_APARTMENT_ACCESS();

    hr = ValidateGetParamArgs(ulOrdinal, psiValue, &bIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    if (bIsNull)
    {
        *psiValue = NUMERIC_NULL_VALUE;
        goto Cleanup;
    }

    pParam = &m_CmdInfo.rgParams[ulOrdinal];
    switch(pParam->paramType)
    {
    case DBTYPE_I2:
        *psiValue = *(PSHORT)((PBYTE)m_CmdInfo.pParam + pParam->paramOffset);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}


////////////////////////////////////////////////////////////////
// CWSParameters::GetInt32
//
//      Retrives the given parameter value.
//
//  Parameters
//      ulOrdinal           the 0-based ordinal of the
//                          parameter.
//      plValue             Pointer to a buffer to be filled
//                          with the param value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::GetInt32(ULONG ulOrdinal, LONG* plValue)
{
    HRESULT hr = S_OK;
    WSTCOMMANDPARAM* pParam;
    VARIANT_BOOL bIsNull;

    ENSURE_APARTMENT_ACCESS();
    
    hr = ValidateGetParamArgs(ulOrdinal, plValue, &bIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    if (bIsNull)
    {
        *plValue = NUMERIC_NULL_VALUE;
        goto Cleanup;
    }

    pParam = &m_CmdInfo.rgParams[ulOrdinal];
    ATLASSERT(pParam != NULL);

    switch(pParam->paramType)
    {
    case DBTYPE_I2:
        *plValue = *(PSHORT)((PBYTE)m_CmdInfo.pParam + pParam->paramOffset);
        break;

    case DBTYPE_I4:
        *plValue = *(PLONG)((PBYTE)m_CmdInfo.pParam + pParam->paramOffset);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSParameters::GetInt64
//
//      Retrives the given parameter value.
//
//  Parameters
//      ulOrdinal           the 0-based ordinal of the
//                          parameter.
//      pqwValue            Pointer to a buffer to be filled
//                          with the param value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::GetInt64(ULONG ulOrdinal, LONGLONG* pqwValue)
{
    HRESULT hr = S_OK;
    WSTCOMMANDPARAM* pParam;
    VARIANT_BOOL bIsNull;
    
    ENSURE_APARTMENT_ACCESS();

    hr = ValidateGetParamArgs(ulOrdinal, pqwValue, &bIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    if (bIsNull)
    {
        *pqwValue = NUMERIC_NULL_VALUE;
        goto Cleanup;
    }

    pParam = &m_CmdInfo.rgParams[ulOrdinal];
    ATLASSERT(pParam != NULL);

    switch(pParam->paramType)
    {
    case DBTYPE_I2:
        *pqwValue = *(PSHORT)((PBYTE)m_CmdInfo.pParam + pParam->paramOffset);
        break;

    case DBTYPE_I4:
        *pqwValue = *(PLONG)((PBYTE)m_CmdInfo.pParam + pParam->paramOffset);
        break;

    case DBTYPE_I8:
        *pqwValue = *(PLONGLONG)((PBYTE)m_CmdInfo.pParam + pParam->paramOffset);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSParameters::GetDate
//
//      Retrives the given parameter value.
//
//  Parameters
//      ulOrdinal           the 0-based ordinal of the
//                          parameter.
//      pdtValue            Pointer to a buffer to be filled
//                          with the param value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::GetDate(ULONG ulOrdinal, DATE* pdtValue)
{
    HRESULT hr = S_OK;
    WSTCOMMANDPARAM* pParam;
    VARIANT_BOOL bIsNull;

    ENSURE_APARTMENT_ACCESS();

    hr = ValidateGetParamArgs(ulOrdinal, pdtValue, &bIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    if (bIsNull)
    {
        *pdtValue = DATE_NULL_VALUE;
        goto Cleanup;
    }

    pParam = &m_CmdInfo.rgParams[ulOrdinal];
    switch(pParam->paramType)
    {
    case DBTYPE_DATE:
        *pdtValue = *(DATE*)((PBYTE)m_CmdInfo.pParam + pParam->paramOffset);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}


////////////////////////////////////////////////////////////////
// CWSParameters::GetString
//
//      Retrives the given parameter value.
//
//  Parameters
//      ulOrdinal           the 0-based ordinal of the
//                          parameter.
//      psiValue            Pointer to a buffer to be filled
//                          with the param value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::GetString(ULONG ulOrdinal, BSTR* pbstrValue)
{
    HRESULT hr = S_OK;
    WSTCOMMANDPARAM* pParam;
    VARIANT_BOOL bIsNull;

    ENSURE_APARTMENT_ACCESS();

    hr = ValidateGetParamArgs(ulOrdinal, pbstrValue, &bIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    if (bIsNull)
    {
        *pbstrValue = SysAllocString(STRING_NULL_VALUE);
        goto Cleanup;
    }


    pParam = &m_CmdInfo.rgParams[ulOrdinal];
    switch(pParam->paramType)
    {
    case DBTYPE_WSTR:
        *pbstrValue = W2BSTR((OLECHAR*)((PBYTE)m_CmdInfo.pParam + pParam->paramOffset));
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}



////////////////////////////////////////////////////////////////
// CWSParameters::GetByteArray
//
//      Retrives the given parameter value.
//
//  Parameters
//      ulOrdinal           the 0-based ordinal of the
//                          parameter.
//      psaValue            Pointer to a buffer to be filled
//                          with the param value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::GetByteArray(ULONG ulOrdinal, SAFEARRAY** ppsaValue)
{
    HRESULT hr = S_OK;
    WSTCOMMANDPARAM* pParam;
    VARIANT_BOOL bIsNull;
    //CComSafeArray<BYTE> *psa = NULL;
    SAFEARRAY* psa = NULL;

    ENSURE_APARTMENT_ACCESS();

    hr = ValidateGetParamArgs(ulOrdinal, ppsaValue, &bIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    if (bIsNull)
    {
        *ppsaValue = NULL;
        goto Cleanup;
    }

        
    pParam = &m_CmdInfo.rgParams[ulOrdinal];
    switch(pParam->paramType)
    {
    case DBTYPE_BYTES:
        psa = SafeArrayCreateVector(VT_UI1, 0, pParam->paramSize);
        CopyMemory(psa->pvData, ((PBYTE)m_CmdInfo.pParam + pParam->paramOffset), pParam->paramSize);
        *ppsaValue = psa;
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSParameters::IsDBNull
//
//      Checks the given parameter for null value.
//
//  Parameters
//      ulOrdinal           the 0-based ordinal of the
//                          parameter.
//      bIsNull             Pointer to a buffer to be filled
//                          with result.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::IsDBNull(ULONG ulOrdinal, VARIANT_BOOL* bIsNull)
{
    HRESULT hr = S_OK;
    
    ENSURE_APARTMENT_ACCESS();

    if (!bIsNull)
    {
        hr = E_POINTER;
        ReportError(hr);
        goto Cleanup;
    }

    if ((LONG)ulOrdinal >= m_CmdInfo.nParams)
    {
        hr = WSR_E_ORDINALOUTOFRANGE;
        ReportError(hr);
        goto Cleanup;
    }

    if (*(PLONG)((PBYTE)m_CmdInfo.pParam + m_CmdInfo.rgParams[ulOrdinal].paramStatusOffset) == DBSTATUS_S_ISNULL)
    {
        *bIsNull = VARIANT_TRUE;
    }
    else
    {
        *bIsNull = VARIANT_FALSE;
    }

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSParameters::get_CmdInfo
//
//      Returns a pointer (in the form of a com-friendly PBYTE)
//      to the commandinfo struct.   
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::get_CmdInfo(BYTE** ppCmdInfo)
{
    HRESULT hr = S_OK;

    ENSURE_APARTMENT_ACCESS();

    if (!ppCmdInfo)
    {
        hr = E_POINTER;
        ReportError(hr);
        goto Cleanup;
    }

    *ppCmdInfo = (BYTE*)&m_CmdInfo;

Cleanup:
    return hr;
}



STDMETHODIMP CWSParameters::InterfaceSupportsErrorInfo(REFIID riid)
{
    ENSURE_APARTMENT_ACCESS();
    
    static const IID* arr[] = 
    {
        &IID_IWSParameters
    };

    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


////////////////////////////////////////////////////////////////
// CWSParameters::FinalConstruct
//
//      handles initialization stuff.
////////////////////////////////////////////////////////////////
HRESULT CWSParameters::FinalConstruct()
{
#ifdef DEBUG
    m_dwThreadId = GetCurrentThreadId();
#endif

    return S_OK;
}


////////////////////////////////////////////////////////////////
// CWSParameters::FinalRelease
//
//      handles cleanup stuff.
////////////////////////////////////////////////////////////////
void CWSParameters::FinalRelease()
{
    if (m_CmdInfo.rgParams)
    {
        CoTaskMemFree(m_CmdInfo.rgParams);
        m_CmdInfo.rgParams = NULL;
    }
    
    if (m_CmdInfo.pParam)
    {
        CoTaskMemFree(m_CmdInfo.pParam);
        m_CmdInfo.pParam  = NULL;
    }

    m_CmdInfo.cbParam = 0;
    m_CmdInfo.nParams = 0;
}

////////////////////////////////////////////////////////////////
// CWSParameters::CleanUp
//
//      Clean up param set and allows reuse of object..
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSParameters::CleanUp(void)
{
    if (m_CmdInfo.rgParams)
    {
        CoTaskMemFree(m_CmdInfo.rgParams);
        m_CmdInfo.rgParams = NULL;
    }
    
    if (m_CmdInfo.pParam)
    {
        CoTaskMemFree(m_CmdInfo.pParam);
        m_CmdInfo.pParam  = NULL;
    }

    m_CmdInfo.cbParam = 0;
    m_CmdInfo.nParams = 0;

    return S_OK;
}


////////////////////////////////////////////////////////////////
//
//                      Private Methods
//
////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////
// CWSParameters::Add
//
//      Adds the given parameter info to the current list
//      of parameters to be passed to the next call to 
//      Execute.   
//      NOTE: Both parameter data and strings
//          are stored in contigious memory blocks. 
////////////////////////////////////////////////////////////////
HRESULT CWSParameters::AddParam(
    LONG lParamIO, 
    LONG lParamType,
    LONG lParamSize,
    LPVOID  pvParamValue,
    LONG lParamValueSize /*= -1*/
    )
{
    HRESULT hr = S_OK;
    WSTCOMMANDPARAM* pParam;
    LONG lOffset;


    m_CmdInfo.nParams++;

    //
    // make sure there are enough params allocated
    //
    if (m_CmdInfo.rgParams == NULL)
    {
        // start out with the default # of params
        m_cAllocParams = INITIAL_PARAM_ALLOC_COUNT;
        m_CmdInfo.rgParams = (WSTCOMMANDPARAM*)CoTaskMemAlloc(
                sizeof(WSTCOMMANDPARAM) * m_cAllocParams);

        if (!m_CmdInfo.rgParams)
        {
            hr = E_OUTOFMEMORY;
            ReportError(hr);
            goto Cleanup;
        }
    }
    else if (m_CmdInfo.nParams > m_cAllocParams)
    {
        // used up available params, so grow by one
        m_cAllocParams++;
        m_CmdInfo.rgParams = (WSTCOMMANDPARAM*)CoTaskMemRealloc(
                m_CmdInfo.rgParams, sizeof(WSTCOMMANDPARAM) * m_cAllocParams);

        if (!m_CmdInfo.rgParams)
        {
            hr = E_OUTOFMEMORY;
            ReportError(hr);
            goto Cleanup;
        }
    }


    //
    // initialize offset
    //
    lOffset = 0;
    if (m_CmdInfo.nParams > 1)
    {
        // calculate the offset from the previous param
        pParam = &m_CmdInfo.rgParams[m_CmdInfo.nParams - 2];
        //lOffset = DW_ALIGN(pParam->paramOffset + pParam->paramSize);
        lOffset = pParam->paramStatusOffset + sizeof(LONG);
    }

    //
    // initialize param 
    //
    pParam = &m_CmdInfo.rgParams[m_CmdInfo.nParams - 1];
    pParam->nOrdinal    = m_CmdInfo.nParams;
    pParam->paramIO     = lParamIO;
    pParam->paramOffset = lOffset;
    pParam->paramSize   = lParamSize;
    pParam->paramType   = lParamType;
    pParam->paramName   = NULL;
    pParam->paramStatusOffset = DW_ALIGN(lOffset + lParamSize);

    //
    // make sure there's enough space for param data
    //
    if ((LONG)(DW_ALIGN(lOffset + lParamSize) + sizeof(LONG)) > m_CmdInfo.cbParam)
    {
        if (!m_CmdInfo.pParam)
        {
            m_CmdInfo.cbParam = INITIAL_PARAM_BUF_SIZE;
            m_CmdInfo.pParam = CoTaskMemAlloc(m_CmdInfo.cbParam);
        }
        else
        {
            m_CmdInfo.cbParam = DW_ALIGN(lOffset + lParamSize) + sizeof(LONG);
            m_CmdInfo.pParam = CoTaskMemRealloc(m_CmdInfo.pParam, m_CmdInfo.cbParam);
        }

        if (!m_CmdInfo.pParam)
        {
            hr = E_OUTOFMEMORY;
            ReportError(hr);
            goto Cleanup;
        }
    }

    //
    // copy param value
    //
    ZeroMemory((PBYTE)m_CmdInfo.pParam + lOffset, lParamSize);
    
    if (lParamValueSize == -1 || lParamValueSize > lParamSize)
    {
        lParamValueSize = lParamSize;
    }

    if (pvParamValue && lParamValueSize > 0)
    {
        CopyMemory((PBYTE)m_CmdInfo.pParam + lOffset, pvParamValue, lParamValueSize);
    }
    
    // initialize status value
    *((PLONG)((PBYTE)m_CmdInfo.pParam + pParam->paramStatusOffset)) = DBSTATUS_S_OK;


Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSParameters::ValidateGetParamArgs
//
//      Does the checks common to all
//      'Get*' functions.
////////////////////////////////////////////////////////////////
HRESULT CWSParameters::ValidateGetParamArgs(ULONG ulOrdinal, LPVOID pvValue, VARIANT_BOOL* pbIsNull)
{
    HRESULT hr = S_OK;

    if (!pvValue || !pbIsNull)
    {
        hr = E_POINTER;
        ReportError(hr);
        goto Cleanup;
    }
    
    if ((LONG)ulOrdinal >= m_CmdInfo.nParams)
    {
        hr = WSR_E_ORDINALOUTOFRANGE;
        ReportError(hr);
        goto Cleanup;
    }

    hr = IsDBNull(ulOrdinal, pbIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }


Cleanup:
    return hr;
}



void CWSParameters::ReportError(HRESULT hr)
{
    TCHAR szMsgBuf[512];
    
    switch(hr)
    {
    case WSR_E_NOTINITIALIZED:
        ReportError(hr, L"WSDataReader::Initialize must be called before any other methods can be executed.");
        break;

    case WSR_E_NOCURRENTROW:
        ReportError(hr, L"The reader is past the end of the recordset.");
        break;

    case WSR_E_ORDINALOUTOFRANGE:
        ReportError(hr, L"The specified oridinal is out of range of valid columns (or Parameters).");
        break;

    case WSR_E_TYPEMISMATCH:
        ReportError(hr, L"The underlying data type does not match the requested type.");
        break;

    case WSR_E_NAMENOTFOUND:
        ReportError(hr, L"Specified name not found.");
        break;

    case WSR_E_WRONG_THREAD:
        ReportError(hr, L"Object should only be used on the thread it was created on!");
        break;

    case WST_E_CONNECTIONTIMEOUT:
        ReportError(hr, L"Webstore error: A connection timedout occured.");
        break;

    case WST_E_NOCONNECTIONAVAIL:
        ReportError(hr, L"Webstore error: No connections are available.");
        break;

    case WST_E_MARKEDOFFLINE:
        ReportError(hr, L"Webstore error: The requested database is marked as offline.");
        break;

    case WST_E_MARKEDREADONLY:
        ReportError(hr, L"Webstore error: The requested database is marked as read-only.");
        break;

    case WST_E_SERVERNOTREGISTERED:
        ReportError(hr, L"Webstore error: The specified server is not registered.");
        break;

    case WST_E_APPLICATIONNOTEXIST:
        ReportError(hr, L"Webstore error: The specified application does not exist.");
        break;

    case WST_E_TRANCOUNTEXIST:
        ReportError(hr, L"Webstore error: Webstore returned WST_E_TRANCOUNTEXIST.");
        break;

    case WST_E_ADMINCONSOLENOTEXIST:
        ReportError(hr, L"Webstore error: The admin console does not exist.");
        break;
            
    default:
        // If there's a message associated with this error, report that
        if (::FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL, hr,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) szMsgBuf, 512, NULL) 
                != 0)
        {
            ReportError(hr, (LPCTSTR)szMsgBuf);
        }

        // Not an error we recgonize.   If it was another
        // interface that reported the  error, leave it to them
        // to SetErrorInfo().  Otherwise the client can 
        // use their own generic message.

        break;

    }

}

void CWSParameters::ReportError(HRESULT hr, LPCTSTR pszMsg)
{
    AtlReportError(CLSID_WSDataReader, (LPCTSTR) pszMsg, IID_IWSDataReader, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\WSDataReader.cpp ===
////////////////////////////////////////////////////////////////
// WSDataReader.cpp 
//
// ABSTRACT: 
//  Implementation of CWSDataReader class.    This class 
//  exposes webstore and OLEDB implementations as a single,
//  unified, simple interface.   It provides a read-only,
//  forward only view of one or more recordsets. 
//  The primary usage is for executing stored procedures 
//  against a webstore cluster.  It was originally 
//  designed to enable webstore usage via managed code, 
//  however it should work just as well through C/C++,
//  VB, VBScript, javascript, java, perl, etc.   Isn't COM cool? :)
//
// USAGE:
//  The IWSDataReader interface generally follows the same design
//  as the System.Data.IDataReader interface defined in the .NET SDK.
//
// SAMPLE CODE:
//      reader.Initialize("myApp");
//      rs = reader.Execute(0, 0, "p_myproc");
//      while (rs.Read()) {
//          Console.WriteLine(rs.GetInt32(0));
//      }
//      reader.DeInitialize();
//
// **** IMPORTANT ****
//      1.  Ordinals are 0 based.   (the first column is 0, 2nd is 1, etc)
//      2.  Columns and params that are returned as NULL get a default value.   
//          This is 0 for integers, empty strings ('') for strings, 
//          12/30/1899 for dates, and NULL for byte arrays.      
//          The client can check for true null via a call to the IsDBNull method.
//      3.  Parameters are used with the syntax, "{ call ? = p_my_proc(?) }". 
//      4.  Question marks represent the sequential order params are added,
//          i.e. with the sytax example, the first call to AddParam* would be
//          the return value, the second call would the first procedure paramater.
//      5.  Parameter names are optional.
//      6.  Output parameters (and return values) can be accessed via the GetParam*
//          methods, with the ordinal of the parameter.  parameter ordinals
//          are assigned sequentially (starting with 0) in the order added.  
//      7.  If a query returns any recordsets, Ouput parameters and return values 
//          are not updated until NextRecordset() returns false.
//      8.  Stored proc return values can only be of type Int32.
//
//
// HISTORY:
//      08/23/01    slamb       Created
//      08/25/01    slamb       Added paratition detection
//      09/04/01    slamb       Added param support
//      12/10/01    slamb       Added binary data support
//
////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wsrdefs.h"
#include "Wsreader.h"
#include "wststore_i.c"
#include "wststoreidl_i.c"
#include "WSDataReader.h"


////////////////////////////////////////////////////////////////
// CWSDataReader::Initialize
//
//      Initalizes webstore.   Must be called before any other 
//      operations can take place.
//
//  Parameters
//      bstrAppName         Application name to connect to.
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::Initialize(BSTR bstrAppName)
{
    HRESULT hr = S_OK;

    if (m_bInitialized)
    {
        hr = DB_E_ALREADYINITIALIZED;
        ReportError(hr, L"WSDataReader is already initialized");
        goto Cleanup;
    }

    if (!m_piWSTStore)
    {
        // create the store
        hr = m_piWSTStore.CoCreateInstance(CLSID_WSTStore, 0, CLSCTX_SERVER);
        if(FAILED(hr))
        {
            ReportError(hr);
            goto Cleanup;
        }
    }

    // init the store
    hr = m_piWSTStore->Initialize(bstrAppName);
    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }
    
    // get the partition count
    if (m_piHash != NULL)
    {
        m_piHash.Release();
        m_piHash = NULL;
    }
    hr = m_piWSTStore->QueryInterface(&m_piHash);
    if (FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }
    m_piHash->GetCount((PLONG)&m_lPartitions);

    // get the command interface
    if (m_piCommand != NULL)
    {
        m_piCommand.Release();
        m_piCommand = NULL;
    }
    hr = m_piWSTStore->QueryInterface(&m_piCommand);
    if (FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

    // Get the partition interface
    if (m_piPartition != NULL)
    {
        m_piPartition.Release();
        m_piPartition = NULL;
    }
    hr = m_piWSTStore->QueryInterface(&m_piPartition);
    if (FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

    m_bInitialized = true;
    hr = S_OK;

Cleanup:
    if(FAILED(hr))
    {
        m_bInitialized = false;
        m_piCommand.Release();
        m_piWSTStore.Release();

        m_piCommand = NULL;
        m_piWSTStore = NULL;
    }
    
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSDataReader::InitializeEx
//
//      Initalizes webstore with extra features.   
//      Must be called before any other operations can 
//      take place.
//
//  Parameters
//      bstrAppName         Application name to connect to.
//      fSequentialAccess   Flag to signal sequential access.
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::InitializeEx(BSTR bstrAppName, BOOL fSequentialAccess )
{
    HRESULT hr = S_OK;
    CComPtr<IWSTProperties> piWSTProp;
    DBPROP DBProp;
    DBPROPSET DBPropSet;


    // initialize the data reader object.
    hr = Initialize( bstrAppName );
    if ( FAILED(hr) )
    {
        goto Cleanup;
    }

    // check if we want sequential access.
    if ( fSequentialAccess )
    {
        // Set the sequential access property
        hr = m_piWSTStore->QueryInterface(&piWSTProp);
        if (FAILED(hr))
        {
            ReportError(hr);
            goto Cleanup;
        }

        // set the property struct for sequential access.
        VariantInit(&DBProp.vValue);
        DBProp.dwPropertyID       = DBPROP_ACCESSORDER;
        DBProp.dwOptions          = DBPROPOPTIONS_REQUIRED;
        DBProp.dwStatus           = 0;
        DBProp.colid              = DB_NULLID;
        DBProp.vValue.vt          = VT_I4;
        V_I4(&DBProp.vValue)      = DBPROPVAL_AO_SEQUENTIAL;

        DBPropSet.rgProperties    = &DBProp;
        DBPropSet.guidPropertySet = DBPROPSET_ROWSET;
        DBPropSet.cProperties     = 1;
    
        hr = piWSTProp->SetProperties(
            IID_ICommandProperties,
            1,
            &DBPropSet);
        if (FAILED(hr))
        {
            ReportError(hr);
            goto Cleanup;
        }
    }

Cleanup:
    return hr;
}

STDMETHODIMP CWSDataReader::DeInitialize()
{
    if (m_bInitialized)
    {
        m_piWSTStore->DeInitialize();
        m_bInitialized = false;

    }

    return S_OK;
}


////////////////////////////////////////////////////////////////
// CWSParameters::FinalConstruct
//
//      handles initialization stuff.
////////////////////////////////////////////////////////////////
HRESULT CWSDataReader::FinalConstruct()
{
    m_piWSTStore    = NULL;
    m_piCommand     = NULL;
    m_piHash        = NULL;

    m_lPartitions   = 0;
    m_bInitialized  = false;

    return S_OK;
}


////////////////////////////////////////////////////////////////
// CWSParameters::FinalRelease
//
//      handles cleanup stuff.
////////////////////////////////////////////////////////////////
void CWSDataReader::FinalRelease()
{
    if (m_bInitialized)
    {
        m_piWSTStore->DeInitialize();
        m_bInitialized = false;

    }

    m_piCommand.Release();
    m_piWSTStore.Release();
    m_piHash.Release();

    m_piCommand = NULL;
    m_piWSTStore = NULL;
    m_piHash = NULL;
}

////////////////////////////////////////////////////////////////
// CWSDataReader::Execute
//
//      Executes SQL commands.
//
//  Parameters
//      cmdType         one of WSTCOMMANDTYPE, as defined in 
//                      wststoreidl.idl
//      lHash           the partition to execute the command against.
//                      can be retrieved from one of the
//                      GetPartition* APIs, or ANY_PARTITION (-2), or
//                      ALL_DATABASES (-1).
//      bstrCmd         the SQL command to execute.
//      pParamters      Parameters to use with the execution.   can be NULL.
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::Execute(LONG cmdType, LONG lHash, BSTR bstrCmd, IWSParameters* pParameters, IWSResultset** ppiResultset)
{
    HRESULT                     hr          = S_OK;
    CComPtr<IMultipleResults>   piMultiResults = NULL;
    CComObject<CWSResultset>*   pResultset  = NULL;
    WSTCOMMANDINFO*             pCmdInfo    = NULL;
    
    if (!m_bInitialized || m_piCommand == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"Execute() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }


    if (pParameters != NULL)
    {
        PBYTE pbyCmdInfo;

        hr = pParameters->get_CmdInfo(&pbyCmdInfo);
        if (FAILED(hr))
        {
            ReportError(hr);
            goto Cleanup;
        }

        pCmdInfo = (WSTCOMMANDINFO*)pbyCmdInfo;
    }

    // execute the command
    //
    hr = m_piCommand->Execute((WSTCOMMANDTYPE)cmdType, 
                        lHash,
                        bstrCmd,
                        pCmdInfo,
                        (IUnknown**)&piMultiResults,
                        NULL,
                        DBGUID_DEFAULT,
                        (lHash == ALL_DATABASES ? IID_IRowset : IID_IMultipleResults));

    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    } 

    // give the results back in the form of a WSResultset
    //
    hr = CComObject<CWSResultset>::CreateInstance(&pResultset);
    if (FAILED(hr))
    {
        ReportError(hr, L"Failed to create instance of IWSResultset");
        goto Cleanup;
    }
    pResultset->AddRef();

    hr = pResultset->InitFromMultiResults( piMultiResults );
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    pResultset->AddRef();
    *ppiResultset = pResultset;


Cleanup:
    if ( NULL != pResultset )
    {
        pResultset->Release();
    }
    return hr;
}


////////////////////////////////////////////////////////////////
// CWSDataReader::ExecuteReturnRowset
//
//      Executes SQL commands, returning only a single rowset if any.
//
//  Parameters
//      cmdType         one of WSTCOMMANDTYPE, as defined in 
//                      wststoreidl.idl
//      lHash           the partition to execute the command against.
//                      can be retrieved from one of the
//                      GetPartition* APIs, or ANY_PARTITION (-2).
//                      ALL_DATABASES (-1) is not allowed since that 
//                      always returns IMultipleResults.
//      bstrCmd         the SQL command to execute.
//      pParamters      Parameters to use with the execution.   can be NULL.
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::ExecuteReturnRowset(LONG cmdType, LONG lHash, BSTR bstrCmd, IWSParameters* pParameters, IWSResultset** ppiResultset)
{
    HRESULT                     hr          = S_OK;
    CComPtr<IRowset>            piRowset    = NULL;
    CComObject<CWSResultset>*   pResultset  = NULL;
    WSTCOMMANDINFO*             pCmdInfo    = NULL;
    
    if (!m_bInitialized || m_piCommand == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"Execute() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }

    if( lHash == ALL_DATABASES )
    {
        hr = E_INVALIDARG;
        ReportError(hr, L"ExecuteReturnRowset() - lHash cannot be ALL_DATABASES.");
        goto Cleanup;
    }

    if (pParameters != NULL)
    {
        PBYTE pbyCmdInfo;

        hr = pParameters->get_CmdInfo(&pbyCmdInfo);
        if (FAILED(hr))
        {
            ReportError(hr);
            goto Cleanup;
        }

        pCmdInfo = (WSTCOMMANDINFO*)pbyCmdInfo;
    }

    // execute the command
    //
    hr = m_piCommand->Execute((WSTCOMMANDTYPE)cmdType, 
                        lHash,
                        bstrCmd,
                        pCmdInfo,
                        (IUnknown**)&piRowset,
                        NULL,
                        DBGUID_DEFAULT,
                        IID_IRowset);

    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    } 

    // give the results back in the form of a WSResultset
    //
    hr = CComObject<CWSResultset>::CreateInstance(&pResultset);
    if (FAILED(hr))
    {
        ReportError(hr, L"Failed to create instance of IWSResultset");
        goto Cleanup;
    }
    pResultset->AddRef();

    hr = pResultset->InitFromRowset( piRowset );
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    pResultset->AddRef();
    *ppiResultset = pResultset;


Cleanup:
    if ( NULL != pResultset )
    {
        pResultset->Release();
    }
    return hr;
}


////////////////////////////////////////////////////////////////
// CWSDataReader::ExecuteNonQuery
//
//      Executes SQL commands without returning a recordset.
//
//  Parameters
//      cmdType         one of WSTCOMMANDTYPE, as defined in 
//                      wststoreidl.idl
//      lHash           the partition to execute the command against.
//                      can be retrieved from one of the
//                      GetPartition* APIs, or ANY_PARTITION (-2), or
//                      ALL_DATABASES (-1).
//      bstrCmd         the SQL command to execute.
//      pParamters      Parameters to use with the execution.   can be NULL.
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::ExecuteNonQuery(LONG cmdType, LONG lHash, BSTR bstrCmd, IWSParameters* pParameters)
{
    HRESULT                     hr          = S_OK;
    CComPtr<IMultipleResults>   piMultiResults = NULL;
    WSTCOMMANDINFO*             pCmdInfo    = NULL;
    
    if (!m_bInitialized || m_piCommand == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"Execute() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }


    if (pParameters != NULL)
    {
        PBYTE pbyCmdInfo;

        hr = pParameters->get_CmdInfo(&pbyCmdInfo);
        if (FAILED(hr))
        {
            ReportError(hr);
            goto Cleanup;
        }

        pCmdInfo = (WSTCOMMANDINFO*)pbyCmdInfo;
    }


    // execute the command
    //
    hr = m_piCommand->Execute((WSTCOMMANDTYPE)cmdType, 
                        lHash,
                        bstrCmd,
                        pCmdInfo,
                        (IUnknown**)&piMultiResults,
                        NULL,
                        DBGUID_DEFAULT,
                        IID_IRowset);

    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    } 


Cleanup:
    return hr;
}

STDMETHODIMP CWSDataReader::GetSession(LONG cmdType, LONG lHash, IWSSession** ppiSession)
{
    HRESULT hr = S_OK;
    CComPtr<IWSTSession>      piWSTSession = NULL;
    CComObject<CWSSession>*   pSession  = NULL;

    if (!m_bInitialized || m_piCommand == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"GetSession() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }

    hr = m_piCommand->GetSession((WSTCOMMANDTYPE)cmdType, 
                                  lHash,
                                  &piWSTSession);

    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    } 

    // give the results back in the form of a WSSession
    //
    hr = CComObject<CWSSession>::CreateInstance(&pSession);
    if (FAILED(hr))
    {
        ReportError(hr, L"Failed to create instance of IWSSession");
        goto Cleanup;
    }
    pSession->AddRef();

    hr = pSession->Init(piWSTSession);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    pSession->AddRef();
    *ppiSession = pSession;


Cleanup:
    if ( pSession )
    {
        pSession->Release();
    }
    return hr;

}

////////////////////////////////////////////////////////////////
// CWSDataReader::GetPartitionFromInt32
//
//      Determines a partition based on the given 32-bit value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::GetPartitionFromInt32(LONG lValue, LONG* plPartition)
{
    HRESULT hr = S_OK;

    if (!plPartition)
    {
        hr = E_POINTER;
        ReportError(hr);
        goto Cleanup;
    }

    if (!m_bInitialized)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr);
        goto Cleanup;
    }

    if (m_lPartitions == 0)
    {
        hr = E_UNEXPECTED;
        ReportError(hr);
        goto Cleanup;
    }

    *plPartition = lValue % m_lPartitions;

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSDataReader::GetPartitionFromInt64
//
//      Determines a partition based on the given 64-bit value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::GetPartitionFromInt64(LONGLONG qwValue, LONG* plPartition)
{
    HRESULT hr = S_OK;
    LARGE_INTEGER li;
    
    if (!plPartition)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!m_bInitialized)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"Execute() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }

    if (m_piHash == NULL)
    {
        hr = E_UNEXPECTED;
        ReportError(hr);
        goto Cleanup;
    }
    
    li.QuadPart = qwValue;

    hr = m_piHash->HashLARGEINTEGER(li, plPartition);
    if (FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

Cleanup:
    return hr;
}


////////////////////////////////////////////////////////////////
// CWSDataReader::GetPartitionFromString
//
//      Determines a partition based on the given string value.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::GetPartitionFromString(BSTR bstrValue, LONG* plPartition)
{
    HRESULT hr = S_OK;

    if (!plPartition)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!m_bInitialized)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"Execute() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }

    hr = m_piHash->HashBSTR(bstrValue, plPartition);
    if (FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSDataReader::get_PartitionCount
//
//      Returns the number of partitions on the current datastore.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::get_PartitionCount(LONG* plValue)
{
    HRESULT hr = S_OK;

    if (!plValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!m_bInitialized)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"Execute() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }

    *plValue = m_lPartitions;
    
Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSDataReader::SetPartitionMode
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::SetPartitionMode(WSREADER_PARTITION_MODE mode)
{
    WSTPARTITIONMODE wstmode;
    HRESULT hr = S_OK;

    if (!m_bInitialized || m_piPartition == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"SetPartitionMode() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }

    if(mode == WSREADER_PARTITION_MODE_LOGICAL)
    {
        wstmode = LOGICAL_MODE;
    }
    else if(mode == WSREADER_PARTITION_MODE_PHYSICAL)
    {
        wstmode = PHYSICAL_MODE;
    }
    else
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = m_piPartition->SetMode(wstmode);
    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

Cleanup:
    
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSDataReader::SetPartitionMode
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::GetPhysicalFromLogical(LONG lLogical, LONG* plPhysical)
{
    HRESULT hr = S_OK;

    if (!m_bInitialized || m_piPartition == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"GetPhysicalFromLogical() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }

    hr = m_piPartition->GetPhysicalFromLogical(lLogical, plPhysical);
    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

Cleanup:

    return hr;
}

////////////////////////////////////////////////////////////////
// CWSDataReader::get_PartitionCount
//
//      Returns the number of partitions on the current datastore.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::get_LogicalPartitionCount(LONG* plValue)
{
    HRESULT hr = S_OK;

    if (!plValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (m_piPartition == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"get_LogicalPartitionCount() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }

    hr = m_piPartition->GetLogicalCount(plValue);
    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }
    
Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSDataReader::get_PartitionCount
//
//      Returns the number of partitions on the current datastore.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSDataReader::get_PhysicalPartitionCount(LONG* plValue)
{
    HRESULT hr = S_OK;

    if (!plValue)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (m_piPartition == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"get_LogicalPartitionCount() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }

    hr = m_piPartition->GetPhysicalCount(plValue);
    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }
    
Cleanup:
    return hr;
}

//
// ISupportErrorInfo
//
STDMETHODIMP CWSDataReader::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IWSDataReader
    };

    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}



////////////////////////////////////////////////////////////////
//
//                      Private Methods
//
////////////////////////////////////////////////////////////////

void CWSDataReader::ReportError(HRESULT hr)
{
    TCHAR szMsgBuf[512];
    
    switch(hr)
    {
    case WSR_E_NOTINITIALIZED:
        ReportError(hr, L"WSDataReader::Initialize must be called before any other methods can be executed.");
        break;

    case WSR_E_NOCURRENTROW:
        ReportError(hr, L"The reader is past the end of the recordset.");
        break;

    case WSR_E_ORDINALOUTOFRANGE:
        ReportError(hr, L"The specified oridinal is out of range of valid columns (or Parameters).");
        break;

    case WSR_E_TYPEMISMATCH:
        ReportError(hr, L"The underlying data type does not match the requested type.");
        break;

    case WSR_E_NAMENOTFOUND:
        ReportError(hr, L"Specified name not found.");
        break;

    case WST_E_CONNECTIONTIMEOUT:
        ReportError(hr, L"Webstore error: A connection timedout occured.");
        break;

    case WST_E_NOCONNECTIONAVAIL:
        ReportError(hr, L"Webstore error: No connections are available.");
        break;

    case WST_E_MARKEDOFFLINE:
        ReportError(hr, L"Webstore error: The requested database is marked as offline.");
        break;

    case WST_E_MARKEDREADONLY:
        ReportError(hr, L"Webstore error: The requested database is marked as read-only.");
        break;

    case WST_E_SERVERNOTREGISTERED:
        ReportError(hr, L"Webstore error: The specified server is not registered.");
        break;

    case WST_E_APPLICATIONNOTEXIST:
        ReportError(hr, L"Webstore error: The specified application does not exist.");
        break;

    case WST_E_TRANCOUNTEXIST:
        ReportError(hr, L"Webstore error: Webstore returned WST_E_TRANCOUNTEXIST.");
        break;

    case WST_E_ADMINCONSOLENOTEXIST:
        ReportError(hr, L"Webstore error: The admin console does not exist.");
        break;
            
    default:
        // If there's a message associated with this error, report that
        if (::FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL, hr,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) szMsgBuf, 512, NULL) 
                != 0)
        {
            ReportError(hr, (LPCTSTR)szMsgBuf);
        }

        // Not an error we recgonize.   If it was another
        // interface that reported the  error, leave it to them
        // to SetErrorInfo().  Otherwise the client can 
        // use their own generic message.

        break;

    }

}

void CWSDataReader::ReportError(HRESULT hr, LPCTSTR pszMsg)
{
    AtlReportError(CLSID_WSDataReader, (LPCTSTR) pszMsg, IID_IWSDataReader, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\WSResultset.cpp ===
#include "stdafx.h"
#include "wsrdefs.h"
#include "WSResultset.h"


////////////////////////////////////////////////////////////////
// CWSResultset::InitFromMultiResults
//
//      Initializes a resultset with the results from an
//      OLEDB (or webstore) query using IMultipleResults.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::InitFromMultiResults(IMultipleResults *piResultset)
{
    HRESULT         hr          = S_OK;
    VARIANT_BOOL    bRecords    = VARIANT_FALSE;

    if (m_fInitialized)
    {
        hr = E_UNEXPECTED;
        ReportError(hr);
        goto Cleanup;
    }

    if (!piResultset) 
    {
        hr = E_POINTER;
        ReportError(hr);
        goto Cleanup;
    }
    
    m_piMultiResults = piResultset;

    // move to the first resultset.
    hr = NextResult(&bRecords);
    if (FAILED(hr))
    {
        ReleaseExistingMultiResults();
        // already reported
        goto Cleanup;
    }

    m_fInitialized = TRUE;

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSResultset::InitFromRowset
//
//      Initializes a resultset with the results from an
//      OLEDB (or webstore) query using IRowset.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::InitFromRowset(IRowset *piResultset)
{
    HRESULT         hr          = S_OK;

    if (m_fInitialized)
    {
        hr = E_UNEXPECTED;
        ReportError(hr);
        goto Cleanup;
    }

    // NOTE: It is perfectly acceptable for piResultset to be NULL, 
    // this just means that Execute returned no rows.  The caller
    // will discover this when they call CWSResultset::Read().
    
    m_piRowset = piResultset;

    if( m_piRowset != NULL )
    {
        hr = UpdateColumnBindings();
        if (FAILED(hr))
        {
            ReleaseExistingMultiResults();
            // error reported by UpdateBindings()
            goto Cleanup;
        }
    }

    m_fInitialized = TRUE;

Cleanup:
    return hr;
}


////////////////////////////////////////////////////////////////
// CWSDataReader::Read
//
//      Retrieves the next row from the current resultset.
//      Returns false when reading past the end of the 
//      results.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::Read(VARIANT_BOOL* pbResults)
{
    HRESULT                 hr          = S_OK;
    HROW*                   phRow       = NULL;
    ULONG                   iCol        = 0;
    ULONG                   cRowsObtained = 0;
    
    if (NULL == pbResults) 
    {
        hr = E_POINTER;
        ReportError(hr);
        goto Cleanup;
    }

    *pbResults = VARIANT_FALSE;

    if (m_piRowset == NULL)
    {
        // no rows to read from
        goto Cleanup;
    }
    
    //
    // advance to the next row
    //
    hr = m_piRowset->GetNextRows(DB_NULL_HCHAPTER, 0, 1, &cRowsObtained, &phRow);
    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

    if (hr == DB_S_ENDOFROWSET)
    {
        // all done
        goto Cleanup;
    }

    //
    // get the data for the next row
    //
    hr = m_piRowset->GetData(*phRow, m_hAccessor, m_pvRowData);
    if (FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

    //
    // release the row (but keep the data)
    // 
    hr = m_piRowset->ReleaseRows(1, phRow, 0, NULL, NULL);
    if (FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

    *pbResults = VARIANT_TRUE;

Cleanup:
    if ( NULL != phRow )
    {
        CoTaskMemFree(phRow);
        phRow = NULL;
    }
    
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSDataReader::NextResult
//
//      Advances the reader to the next resultset, 
//      when reading the results of a batch of SQL statments.
//      NOTE: this skips until the next ROWSET!   It will
//          ignorre any 'records affected' reports.  
//          
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::NextResult(VARIANT_BOOL* pbResults)
{
    HRESULT hr = S_OK;
    
    if (NULL == pbResults)
    {
        hr = E_POINTER;
        ReportError(hr);
        goto Cleanup;
    }

    *pbResults = VARIANT_FALSE;

    if (m_piMultiResults == NULL) 
    {
        // There are several possibilities.  We may have been called prior to this object
        // being initialized, or we may have been initialized with an IRowset instead of 
        // an IMultipleResults.  It is legitimate to get initialized with an IRowset of
        // NULL when there are no results.
        //
        // We will just return VARIANT_FALSE from this method to indicate no more results.
        hr = S_OK;
        goto Cleanup;
    }
    
    ReleaseExistingResultset();
    
    do
    {
        hr = m_piMultiResults->GetResult(NULL, 0, IID_IRowset, NULL, (IUnknown**) &m_piRowset);
        if (FAILED(hr))
        {
            ReportError(hr);
            goto Cleanup;
        }

        if (hr == DB_S_NORESULT)
        {
            // no results
            hr = S_OK;
            goto Cleanup;
        }
    }
    while (m_piRowset == NULL);

    hr = UpdateColumnBindings();
    if (FAILED(hr))
    {
        // error reported by UpdateBindings()
        goto Cleanup;

    }

    *pbResults = VARIANT_TRUE;

Cleanup:    
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSResultset::GetByte
//
//      Retrives an unsigned 8-bit int value from the given
//      0-based column ordinal.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::GetByte(ULONG ulOrdinal, BYTE* pbValue)
{
    HRESULT hr = S_OK;
    DBBINDING* pBinding;
    VARIANT_BOOL vbIsNull;

    hr = ValidateFetchState(ulOrdinal, pbValue);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    pBinding = &(m_pBindings[ulOrdinal]);

    //
    // check for null value
    //
    vbIsNull = VARIANT_FALSE;
    hr = IsDBNull(ulOrdinal, &vbIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    if (vbIsNull == VARIANT_TRUE)
    {
        *pbValue = NUMERIC_NULL_VALUE;
        goto Cleanup;
    }


    //
    // not null, get the actual value
    //
    switch(pBinding->wType)
    {
    case DBTYPE_UI1:
        *pbValue = *((PBYTE)m_pvRowData + pBinding->obValue);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}



////////////////////////////////////////////////////////////////
// CWSResultset::GetInt16
//
//      Retrives a 16-bit int value from the given
//      0-based column ordinal.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::GetInt16(ULONG ulOrdinal, SHORT* psiValue)
{
    HRESULT hr = S_OK;
    DBBINDING* pBinding;
    VARIANT_BOOL vbIsNull;

    hr = ValidateFetchState(ulOrdinal, psiValue);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    pBinding = &(m_pBindings[ulOrdinal]);

    //
    // check for null value
    //
    vbIsNull = VARIANT_FALSE;
    hr = IsDBNull(ulOrdinal, &vbIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    if (vbIsNull == VARIANT_TRUE)
    {
        *psiValue = NUMERIC_NULL_VALUE;
        goto Cleanup;
    }


    //
    // not null, get the actual value
    //
    switch(pBinding->wType)
    {
    case DBTYPE_I2:
        *psiValue = *(PSHORT)(m_pvRowData + pBinding->obValue);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}


////////////////////////////////////////////////////////////////
// CWSResultset::GetInt32
//
//      Retrives a 32-bit int value from the given
//      0-based column ordinal.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::GetInt32(ULONG ulOrdinal, LONG* plValue)
{
    HRESULT hr = S_OK;
    DBBINDING* pBinding;
    VARIANT_BOOL vbIsNull;

    hr = ValidateFetchState(ulOrdinal, plValue);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    pBinding = &(m_pBindings[ulOrdinal]);

    //
    // check for null value
    //
    vbIsNull = VARIANT_FALSE;
    hr = IsDBNull(ulOrdinal, &vbIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    if (vbIsNull == VARIANT_TRUE)
    {
        *plValue = NUMERIC_NULL_VALUE;
        goto Cleanup;
    }


    //
    // not null, get the actual value
    //
    switch(pBinding->wType)
    {
    case DBTYPE_I4:
        *plValue = *(PLONG)(m_pvRowData + pBinding->obValue);
        break;

    case DBTYPE_I2:
        *plValue = *(PSHORT)(m_pvRowData + pBinding->obValue);
        break;

    case DBTYPE_UI1:
        *plValue = *(PBYTE)(m_pvRowData + pBinding->obValue);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSResultset::GetInt64
//
//      Retrives a 64-bit int value from the given
//      0-based column ordinal.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::GetInt64(ULONG ulOrdinal, LONGLONG* pqwValue)
{
    HRESULT hr = S_OK;
    DBBINDING* pBinding;
    VARIANT_BOOL vbIsNull;

    hr = ValidateFetchState(ulOrdinal, pqwValue);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    //
    // check for null value
    //
    vbIsNull = VARIANT_FALSE;
    hr = IsDBNull(ulOrdinal, &vbIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    if (vbIsNull == VARIANT_TRUE)
    {
        *pqwValue = NUMERIC_NULL_VALUE;
        goto Cleanup;
    }


    pBinding = &(m_pBindings[ulOrdinal]);
    switch(pBinding->wType)
    {
    case DBTYPE_I8:
        *pqwValue = *(PLONGLONG)(m_pvRowData + pBinding->obValue);
        break;

    case DBTYPE_I4:
        *pqwValue = *(PLONG)(m_pvRowData + pBinding->obValue);
        break;

    case DBTYPE_I2:
        *pqwValue = *(PSHORT)(m_pvRowData + pBinding->obValue);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSResultset::GetFloat
//
//      Retrives a 4 byte decimal float value
//      0-based column ordinal.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::GetFloat(ULONG ulOrdinal, FLOAT* pfltValue)
{
    HRESULT hr = S_OK;
    DBBINDING* pBinding;
    VARIANT_BOOL vbIsNull;

    hr = ValidateFetchState(ulOrdinal, pfltValue);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    pBinding = &(m_pBindings[ulOrdinal]);

    //
    // check for null value
    //
    vbIsNull = VARIANT_FALSE;
    hr = IsDBNull(ulOrdinal, &vbIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    if (vbIsNull == VARIANT_TRUE)
    {
        *pfltValue = NUMERIC_NULL_VALUE;
        goto Cleanup;
    }


    //
    // not null, get the actual value
    //
    switch(pBinding->wType)
    {
    case DBTYPE_R4:
        *pfltValue = *(PFLOAT)(m_pvRowData + pBinding->obValue);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSResultset::GetString
//
//      Retrives a string value from the given
//      0-based column ordinal.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::GetString(ULONG ulOrdinal, BSTR* pbstrValue)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    DBBINDING* pBinding;
    VARIANT_BOOL vbIsNull;

    hr = ValidateFetchState(ulOrdinal, pbstrValue);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    pBinding = &(m_pBindings[ulOrdinal]);

    //
    // check for null value
    //
    vbIsNull = VARIANT_FALSE;
    hr = IsDBNull(ulOrdinal, &vbIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    if (vbIsNull == VARIANT_TRUE)
    {
        *pbstrValue = SysAllocString(STRING_NULL_VALUE);
        goto Cleanup;
    }


    // NOTE: no support for embedded NULLs
    switch(pBinding->wType)
    {
    case DBTYPE_STR:
        *pbstrValue = A2BSTR((LPCSTR)(m_pvRowData + pBinding->obValue));
        break;

    case DBTYPE_WSTR:
        *pbstrValue = W2BSTR((OLECHAR*)(m_pvRowData + pBinding->obValue));
        break;
    
    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSResultset::GetDate
//
//      Retrives a date value from the given
//      0-based column ordinal.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::GetDate(ULONG ulOrdinal, DATE* pdtValue)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    DBBINDING* pBinding;
    VARIANT_BOOL vbIsNull;

    hr = ValidateFetchState(ulOrdinal, pdtValue);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    pBinding = &(m_pBindings[ulOrdinal]);

    //
    // check for null value
    //
    vbIsNull = VARIANT_FALSE;
    hr = IsDBNull(ulOrdinal, &vbIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    if (vbIsNull == VARIANT_TRUE)
    {
        *pdtValue = DATE_NULL_VALUE;
        goto Cleanup;
    }

    switch(pBinding->wType)
    {
    case DBTYPE_DATE:
        *pdtValue = *(DATE*)(m_pvRowData + pBinding->obValue);
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSResultset::GetByteArray
//
//      Retrives an array of bytes from the given
//      0-based column ordinal.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::GetByteArray(ULONG ulOrdinal, SAFEARRAY** psaValue)
{
    HRESULT hr = S_OK;
    DBBINDING* pBinding;
    VARIANT_BOOL vbIsNull;
    CComSafeArray<BYTE> *psa = NULL;
    DWORD dwLen;

    hr = ValidateFetchState(ulOrdinal, psaValue);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    pBinding = &(m_pBindings[ulOrdinal]);

    //
    // check for null value
    //
    vbIsNull = VARIANT_FALSE;
    hr = IsDBNull(ulOrdinal, &vbIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    if (vbIsNull == VARIANT_TRUE)
    {
        // TODO: anything here
        //*psaValue = BYTEARRAY_NULL_VALUE;
        goto Cleanup;
    }

    dwLen = *(DWORD*)(m_pvRowData + pBinding->obLength);

    switch(pBinding->wType)
    {
    case DBTYPE_BYTES:
        psa = new CComSafeArray<BYTE>(dwLen);
        CopyMemory(psa->m_psa->pvData, (m_pvRowData + pBinding->obValue), dwLen);
        *psaValue = psa->Detach();
        delete psa;
        psa = NULL;
        break;

    default:
        hr = WSR_E_TYPEMISMATCH;
        ReportError(hr);
        break;
    }

Cleanup:
    if (FAILED(hr))
    {
        if (psa != NULL)
        {
            psa->Destroy();
            delete psa;
        }
    }

    return hr;
}




////////////////////////////////////////////////////////////////
// CWSResultset::IsDBNull
//
//      Checks for a null value in the given 0-based 
//      column ordinal.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::IsDBNull(ULONG ulOrdinal, VARIANT_BOOL* pbIsNull)
{
    HRESULT hr = S_OK;
    DBSTATUS dwStatus;
    DBBINDING* pBinding;

    hr = ValidateFetchState(ulOrdinal, pbIsNull);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }
    
    pBinding = &(m_pBindings[ulOrdinal]);
    dwStatus = *(PDWORD)(m_pvRowData + pBinding->obStatus);
    
    if (dwStatus == DBSTATUS_S_ISNULL)
    {
        *pbIsNull = VARIANT_TRUE;
    }
    else
    {
        *pbIsNull = VARIANT_FALSE;
    }

Cleanup:
    return hr;
}

HRESULT CWSResultset::FinalConstruct()
{
    m_piMultiResults = NULL;
    m_piRowset      = NULL;
    m_piAccessor    = NULL;
    m_hAccessor     = NULL;
    m_cbRowData     = 0;
    m_pvRowData     = NULL;
    m_pszColNames   = NULL;
    m_ulColCount    = 0;
    m_pBindings     = NULL;
    m_pColumnInfo   = NULL;

    return S_OK;
}

void CWSResultset::FinalRelease() 
{
    // NOTE: This will call ReleaseExistingResultset and ReleaseExistingColumnBindings.
    ReleaseExistingMultiResults();
}


////////////////////////////////////////////////////////////////
// CWSResultset::GetOrdinal
//
//      Gets the ordinal corrisponding to the given
//      column name.
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSResultset::GetOrdinal(BSTR bstrColumnName, ULONG* pulOrdinal)
{
    HRESULT hr = S_OK;
    CComBSTR bstrName;

    bstrName.Attach(bstrColumnName);

    if (!bstrColumnName || !pulOrdinal)
    {
        hr = E_POINTER;
        ReportError(hr);
        goto Cleanup;
    }

    hr = WSR_E_NAMENOTFOUND;
    for (ULONG i = 0; i < m_ulColCount; i++)
    {
        if (bstrName == m_pColumnInfo[i].pwszName)
        {
            *pulOrdinal = i;
            hr = S_OK;
            break;
        }
    }
    
Cleanup:
    bstrName.Detach();
    return hr;
}


////////////////////////////////////////////////////////////////
//
//                      Private Methods
//
////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////
// CWSResultset::ValidateFetchState
//
//      Makes sure everything that needs to be done
//      before returning acutal column data has
//      indeed been done.
////////////////////////////////////////////////////////////////
HRESULT CWSResultset::ValidateFetchState(ULONG ulOrdinal, LPVOID pValue)
{
    HRESULT hr = S_OK;

    if (pValue == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (m_pvRowData == NULL || m_pBindings == NULL)
    {
        hr = WSR_E_NOCURRENTROW;
        ReportError(hr);
        goto Cleanup;
    }

    if (ulOrdinal >= m_ulColCount) 
    {
        hr = WSR_E_ORDINALOUTOFRANGE;
        ReportError(hr);
        goto Cleanup;
    }

    

Cleanup:
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSResultset::UpdateColumnBindings
//
//      Updates the column and binding information for
//      the current rowset.
////////////////////////////////////////////////////////////////
HRESULT CWSResultset::UpdateColumnBindings()
{
    HRESULT                 hr              = S_OK;
    CComPtr<IColumnsInfo>   piColumnsInfo   = NULL;
    DBCOUNTITEM             cRowsObtained   = 0;
    DBBYTEOFFSET            ulNextOffset    = 0;

    // this needs to exist if there's binding info to set..
    ATLASSERT(m_piRowset);

    ReleaseExistingColumnBindings();

    //
    // Get Column Info
    //
    hr = m_piRowset->QueryInterface(&piColumnsInfo);
    if (FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

    hr = piColumnsInfo->GetColumnInfo(&m_ulColCount, &m_pColumnInfo, &m_pszColNames);
    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

    //
    // create the bindings
    //
    m_pBindings = (DBBINDING*)CoTaskMemAlloc(m_ulColCount * sizeof(DBBINDING));
    if (m_pBindings == NULL)
    {
        hr = E_OUTOFMEMORY;
        ReportError(hr);
        goto Cleanup;
    }

    for (ULONG iCol = 0; iCol < m_ulColCount; iCol++)
    {
        SetBinding(&m_pBindings[iCol],
                   &m_pColumnInfo[iCol],
                   &ulNextOffset);

    }

    // 
    // create the accessor
    //
    hr = m_piRowset->QueryInterface(&m_piAccessor);
    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

    // can/should DBACCESSOR_OPTIMIZED be passed here as well?
    hr = m_piAccessor->CreateAccessor(DBACCESSOR_ROWDATA, m_ulColCount, m_pBindings, 0, &m_hAccessor, NULL);
    if (FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    }

    
    // make sure the row buffer is big enough
    //
    if (m_cbRowData < ulNextOffset)
    {
        CoTaskMemFree(m_pvRowData);
        
        m_cbRowData = ulNextOffset;
        m_pvRowData = (PBYTE)CoTaskMemAlloc(m_cbRowData);
        if (!m_pvRowData)
        {
            hr = E_OUTOFMEMORY;
            ReportError(hr);
            goto Cleanup;
        }
    }

Cleanup:
    if (piColumnsInfo)
    {
        // .Release will call Release on the internal pointer if it is non-NULL and set it to NULL
        piColumnsInfo.Release();
    }

    return hr;
}

////////////////////////////////////////////////////////////////
// CWSResultset::SetBinding
//
//      Initializes a DBBINDING with the given settings
//      and a few defaults, updating the next offset in the
//      process.
////////////////////////////////////////////////////////////////

/*
 DBBINDING      rgBinding[1] = {
      1,                            // Column 1
      0,                            // Offset to data
      0,                            // Ignore length field
      sizeof(IUnknown *),           // Offset to status field
      NULL,                         // No type info
      &ObjectStruct,                // Object structure
      NULL,                         // Ignore binding extensions
      DBPART_VALUE|DBPART_STATUS,   // Bind value and status
      DBMEMOWNER_CLIENTOWNED,       // Consumer owned memory
      DBPARAMIO_NOTPARAM,           // Not a parameter
      0,                            // Ignore size of data
      0,                            // Reserved
      DBTYPE_IUNKNOWN,              // Type DBTYPE_IUNKNOWN
      0,                            // Precision not applicable
      0                             // Scale not applicable
   } ;
*/

void CWSResultset::SetBinding(
    DBBINDING*      pBinding,
    DBCOLUMNINFO*   pColInfo,
    DBBYTEOFFSET*   pobNextOffset)
{
    DBTYPE wType = pColInfo->wType;
    DBLENGTH cbMaxLen = pColInfo->ulColumnSize;
    DWORD cbValueLen = cbMaxLen;
    DBOBJECT* pObject = NULL;

    if (wType == DBTYPE_STR || wType == DBTYPE_WSTR)
    {
        // add room for a null character
        cbMaxLen++;
        
        if (wType == DBTYPE_WSTR)
        {
            // wide chars are twice as big
            cbMaxLen *= 2;
        }
    }

    if (wType == DBTYPE_DBDATE || wType == DBTYPE_DBTIMESTAMP)
    {
        // tell the driver to coierce to DATE
        wType = DBTYPE_DATE;
    }

    if (pColInfo->dwFlags & DBCOLUMNFLAGS_ISLONG)
    {
        // blob
        cbMaxLen = sizeof(IUnknown*);
        wType = DBTYPE_IUNKNOWN;
        
        pObject = (DBOBJECT*)CoTaskMemAlloc(sizeof(DBOBJECT));
        pObject->dwFlags = STGM_READ;
        pObject->iid = IID_ISequentialStream;
    }
        

    // make sure we stay aligned
    cbMaxLen = DW_ALIGN(cbMaxLen);

    pBinding->iOrdinal   = pColInfo->iOrdinal;
    pBinding->obLength   = *pobNextOffset;
    pBinding->obStatus   = *pobNextOffset + sizeof(DBLENGTH);
    pBinding->obValue    = *pobNextOffset + sizeof(DBLENGTH) + sizeof(DBSTATUS);
    pBinding->pTypeInfo  = NULL;
    pBinding->pObject    = pObject;
    pBinding->pBindExt   = NULL;
    pBinding->dwPart     = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
    pBinding->dwMemOwner = DBMEMOWNER_CLIENTOWNED;
    pBinding->eParamIO   = DBPARAMIO_NOTPARAM;
    pBinding->cbMaxLen   = cbMaxLen;
    pBinding->dwFlags    = 0;
    pBinding->wType      = wType;
    pBinding->bPrecision = 0;
    pBinding->bScale     = 0;

    *pobNextOffset += (sizeof(DBLENGTH) + sizeof(DBSTATUS) + cbMaxLen);
    ATLASSERT(*pobNextOffset % sizeof(DWORD) == 0);
}




////////////////////////////////////////////////////////////////
// CWSResultset::ReleaseExistingColumnBindings
//
//      Releases and cleans up the current row.  
//      SHould be called before updating m_piResultset
////////////////////////////////////////////////////////////////
void CWSResultset::ReleaseExistingColumnBindings()
{

    if (m_pszColNames)
    {
        CoTaskMemFree(m_pszColNames);
        m_pszColNames = NULL;
    }

    if (m_pColumnInfo)
    {
        CoTaskMemFree(m_pColumnInfo);
        m_pColumnInfo = NULL;
    }

    if (m_pBindings)
    {
        CoTaskMemFree(m_pBindings);
        m_pBindings = NULL;
    }



    if (m_piAccessor)
    {
        if (m_hAccessor)
        {
            m_piAccessor->ReleaseAccessor(m_hAccessor, NULL);
            m_hAccessor  = NULL;
        }

        m_piAccessor.Release();
        m_piAccessor = NULL;
    }

    m_ulColCount = 0;

}

////////////////////////////////////////////////////////////////
// CWSResultset::ReleaseExistingResultset
//
//      Releases and cleans up the current results.  
//      SHould be called before updating m_piResultset.
////////////////////////////////////////////////////////////////
void CWSResultset::ReleaseExistingResultset()
{
    ReleaseExistingColumnBindings();


    if (m_piRowset)
    {
        m_piRowset.Release();
        m_piRowset = NULL;
    }

}


////////////////////////////////////////////////////////////////
// CWSResultset::ReleaseExistingMultiResults
//
//      Releases and cleans up all existing resultsets.  
//      SHould be called before exeucting a new command.
////////////////////////////////////////////////////////////////
void CWSResultset::ReleaseExistingMultiResults()
{
    ReleaseExistingResultset();
    
    if (m_pvRowData)
    {
        CoTaskMemFree(m_pvRowData);
        m_pvRowData = NULL;
        m_cbRowData = NULL;
    }

    if (m_piMultiResults)
    {
        m_piMultiResults.Release();
        m_piMultiResults = NULL;
    }
}




//
// ISupportErrorInfo
//
STDMETHODIMP CWSResultset::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IWSResultset
    };

    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


void CWSResultset::ReportError(HRESULT hr)
{
    TCHAR szMsgBuf[512];
    
    switch(hr)
    {
    case WSR_E_NOTINITIALIZED:
        ReportError(hr, L"WSDataReader::Initialize must be called before any other methods can be executed.");
        break;

    case WSR_E_NOCURRENTROW:
        ReportError(hr, L"The reader is past the end of the recordset.");
        break;

    case WSR_E_ORDINALOUTOFRANGE:
        ReportError(hr, L"The specified oridinal is out of range of valid columns (or Parameters).");
        break;

    case WSR_E_TYPEMISMATCH:
        ReportError(hr, L"The underlying data type does not match the requested type.");
        break;

    case WSR_E_NAMENOTFOUND:
        ReportError(hr, L"Specified name not found.");
        break;

    case WST_E_CONNECTIONTIMEOUT:
        ReportError(hr, L"Webstore error: A connection timedout occured.");
        break;

    case WST_E_NOCONNECTIONAVAIL:
        ReportError(hr, L"Webstore error: No connections are available.");
        break;

    case WST_E_MARKEDOFFLINE:
        ReportError(hr, L"Webstore error: The requested database is marked as offline.");
        break;

    case WST_E_MARKEDREADONLY:
        ReportError(hr, L"Webstore error: The requested database is marked as read-only.");
        break;

    case WST_E_SERVERNOTREGISTERED:
        ReportError(hr, L"Webstore error: The specified server is not registered.");
        break;

    case WST_E_APPLICATIONNOTEXIST:
        ReportError(hr, L"Webstore error: The specified application does not exist.");
        break;

    case WST_E_TRANCOUNTEXIST:
        ReportError(hr, L"Webstore error: Webstore returned WST_E_TRANCOUNTEXIST.");
        break;

    case WST_E_ADMINCONSOLENOTEXIST:
        ReportError(hr, L"Webstore error: The admin console does not exist.");
        break;
            
    default:
        // If there's a message associated with this error, report that
        if (::FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL, hr,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) szMsgBuf, 512, NULL) 
                != 0)
        {
            ReportError(hr, (LPCTSTR)szMsgBuf);
        }

        // Not an error we recgonize.   If it was another
        // interface that reported the  error, leave it to them
        // to SetErrorInfo().  Otherwise the client can 
        // use their own generic message.

        break;

    }

}

void CWSResultset::ReportError(HRESULT hr, LPCTSTR pszMsg)
{
    AtlReportError(CLSID_WSDataReader, (LPCTSTR) pszMsg, IID_IWSDataReader, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\WSResultset.h ===
// WSResultset.h : Declaration of the CWSResultset

#pragma once
#include "resource.h"       // main symbols

#include "wsreader.h"
#include "WSResultset.h"

// CWSResultset

class ATL_NO_VTABLE CWSResultset : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWSResultset, &CLSID_WSResultset>,
    public ISupportErrorInfo,
    public IDispatchImpl<IWSResultset, &IID_IWSResultset, &LIBID_WSREADERLib, /*wMajor =*/ 1, /*wMinor =*/ 0>
{
public:
    CWSResultset() : m_fInitialized(FALSE)
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_WSRESULTSET)


BEGIN_COM_MAP(CWSResultset)
    COM_INTERFACE_ENTRY(IWSResultset)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    HRESULT FinalConstruct();
    void FinalRelease();

    STDMETHOD(InitFromMultiResults)(IMultipleResults *piResults);
    STDMETHOD(InitFromRowset)(IRowset *piResults);

    STDMETHOD(Read)(VARIANT_BOOL* pbResults);
    STDMETHOD(NextResult)(VARIANT_BOOL* pbResults);

    STDMETHOD(GetByte)(ULONG ulOrdinal, BYTE* pbVal);
    STDMETHOD(GetInt16)(ULONG ulOrdinal, SHORT* siVal);
    STDMETHOD(GetInt32)(ULONG ulOrdinal, LONG* plValue);
    STDMETHOD(GetFloat)(ULONG ulOrdinal, FLOAT* pfltValue);
    STDMETHOD(GetInt64)(ULONG ulOrdinal, LONGLONG* pqwValue);
    STDMETHOD(GetString)(ULONG ulOrdinal, BSTR* pbstrValue);
    STDMETHOD(GetDate)(ULONG ulOrdinal, DATE* pdtValue);
    STDMETHOD(GetByteArray)(ULONG ulOrdinal, SAFEARRAY** psaValue);
    
    STDMETHOD(IsDBNull)(ULONG ulOrdinal, VARIANT_BOOL* pbIsNull);
    STDMETHOD(GetOrdinal)(BSTR bstrColumnName, ULONG* pulOrdinal);


protected:
    CComPtr<IMultipleResults>   m_piMultiResults;
    CComPtr<IRowset>            m_piRowset;
    CComPtr<IAccessor>          m_piAccessor;

    BOOL                    m_fInitialized;
    bool                    m_bStaleParams;
    HACCESSOR               m_hAccessor;
    ULONG                   m_cbRowData;
    PBYTE                   m_pvRowData;
    OLECHAR*                m_pszColNames;
    ULONG                   m_ulColCount;
    DBBINDING*              m_pBindings;
    DBCOLUMNINFO*           m_pColumnInfo;
    
    HRESULT ValidateFetchState(ULONG ulOrdinal, LPVOID pValue);
    HRESULT UpdateColumnBindings();
    void    SetBinding(DBBINDING* pBinding, DBCOLUMNINFO* pColInfo, DBBYTEOFFSET* pobNextOffset);
    void    ReleaseExistingColumnBindings();
    void    ReleaseExistingResultset();
    void    ReleaseExistingMultiResults();

    void    ReportError(HRESULT hr, LPCTSTR pszMsg);
    void    ReportError(HRESULT hr);

};

OBJECT_ENTRY_AUTO(__uuidof(WSResultset), CWSResultset)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\WSSession.h ===
// WSSession.h : Declaration of the CWSSession

#ifndef __WSSESSION_H_
#define __WSSESSION_H_

#include "resource.h"       // main symbols
#include "wsparameters.h"
#include "wsresultset.h"

// CWSSession

class ATL_NO_VTABLE CWSSession : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWSSession, &CLSID_WSSession>,
    public ISupportErrorInfo,
    public IDispatchImpl<IWSSession, &IID_IWSSession, &LIBID_WSREADERLib, /*wMajor =*/ 1, /*wMinor =*/ 0>
{
public:
    CWSSession()
    {
        m_piSession = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_WSSession)


BEGIN_COM_MAP(CWSSession)
    COM_INTERFACE_ENTRY(IWSSession)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

public:
    
    STDMETHOD(Execute)(BSTR bstrCmd, IWSParameters* pParameters, IWSResultset** ppiResultset);
    STDMETHOD(ExecuteReturnRowset)(BSTR bstrCmd, IWSParameters* pParameters, IWSResultset** ppiResultset);
    STDMETHOD(ExecuteNonQuery)(BSTR bstrCmd, IWSParameters* pParameters);

    STDMETHOD(BeginTransaction)();
    STDMETHOD(RollbackTransaction)();
    STDMETHOD(CommitTransaction)();

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    HRESULT FinalConstruct();
    
    void FinalRelease(); 

    STDMETHOD(Init)(IWSTSession *piWSTSession);
    
protected:
    CComPtr<IWSTSession>        m_piSession;

protected:
    void    ReportError(HRESULT hr, LPCTSTR pszMsg);
    void    ReportError(HRESULT hr);

#ifdef DEBUG
    DWORD           m_dwThreadId;
#endif


};

OBJECT_ENTRY_AUTO(__uuidof(WSSession), CWSSession)

#endif //__WSSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\WSSession.cpp ===
#include "stdafx.h"
#include "wsrdefs.h"
#include "WSSession.h"

#ifdef DEBUG
#define ENSURE_APARTMENT_ACCESS() \
    if(GetCurrentThreadId() != m_dwThreadId) { \
        ATLTRACE("Mismatched Thread IDS!  %d\n", GetCurrentThreadId()); \
        ReportError(WSR_E_WRONG_THREAD); \
        return WSR_E_WRONG_THREAD; \
    } \

#else
#define ENSURE_APARTMENT_ACCESS()
#endif

////////////////////////////////////////////////////////////////
// CWSSession::FinalConstruct
//
//      handles initialization stuff.
////////////////////////////////////////////////////////////////
HRESULT CWSSession::FinalConstruct()
{
#ifdef DEBUG
    m_dwThreadId = GetCurrentThreadId();
#endif

    return S_OK;
}

////////////////////////////////////////////////////////////////
// CWSSession::FinalRelease
//
//      handles cleanup stuff.
////////////////////////////////////////////////////////////////
void CWSSession::FinalRelease()
{

    m_piSession.Release();
    
    m_piSession = NULL;
}

STDMETHODIMP CWSSession::Init(IWSTSession *piWSTSession)
{
    HRESULT         hr          = S_OK;

    ENSURE_APARTMENT_ACCESS();

    if (!piWSTSession) 
    {
        hr = E_POINTER;
        ReportError(hr);
        goto Cleanup;
    }

    if (m_piSession != NULL)
    {
        hr = E_UNEXPECTED;
        ReportError(hr);
        goto Cleanup;
    }
    
    m_piSession = piWSTSession;

Cleanup:
    return hr;

}

//
// ISupportErrorInfo
//
STDMETHODIMP CWSSession::InterfaceSupportsErrorInfo(REFIID riid)
{
    ENSURE_APARTMENT_ACCESS();

    static const IID* arr[] = 
    {
        &IID_IWSSession
    };

    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


////////////////////////////////////////////////////////////////
// CWSSession::Execute
//
//      Executes SQL commands.
//
//  Parameters
//      bstrCmd         the SQL command to execute.
//      pParamters      Parameters to use with the execution.   can be NULL.
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSSession::Execute(BSTR bstrCmd, IWSParameters* pParameters, IWSResultset** ppiResultset)
{
    HRESULT                     hr          = S_OK;
    CComPtr<IMultipleResults>   piMultiResults = NULL;
    CComObject<CWSResultset>*   pResultset  = NULL;
    WSTCOMMANDINFO*             pCmdInfo    = NULL;
    
    ENSURE_APARTMENT_ACCESS();

    if (m_piSession == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"Execute() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }


    if (pParameters != NULL)
    {
        PBYTE pbyCmdInfo;

        hr = pParameters->get_CmdInfo(&pbyCmdInfo);
        if (FAILED(hr))
        {
            ReportError(hr);
            goto Cleanup;
        }

        pCmdInfo = (WSTCOMMANDINFO*)pbyCmdInfo;
    }


    // execute the session
    //
    hr = m_piSession->Execute( bstrCmd,
                               pCmdInfo,
                               (IUnknown**)&piMultiResults,
                               NULL,
                               DBGUID_DEFAULT,
                               IID_IMultipleResults);

    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    } 

    // give the results back in the form of a WSResultset
    //
    hr = CComObject<CWSResultset>::CreateInstance(&pResultset);
    if (FAILED(hr))
    {
        ReportError(hr, L"Failed to create instance of IWSResultset");
        goto Cleanup;
    }
    pResultset->AddRef();
    
    hr = pResultset->InitFromMultiResults(piMultiResults);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    pResultset->AddRef();
    *ppiResultset = pResultset;


Cleanup:
    if ( pResultset )
    {
        pResultset->Release();
    }
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSSession::ExecuteReturnRowset
//
//      Executes SQL commands, internally using IRowset to work around webstore
//      bugs with IMultipleResults.
//
//  Parameters
//      bstrCmd         the SQL command to execute.
//      pParamters      Parameters to use with the execution.   can be NULL.
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSSession::ExecuteReturnRowset(BSTR bstrCmd, IWSParameters* pParameters, IWSResultset** ppiResultset)
{
    HRESULT                     hr          = S_OK;
    CComPtr<IRowset>            piRowset    = NULL;
    CComObject<CWSResultset>*   pResultset  = NULL;
    WSTCOMMANDINFO*             pCmdInfo    = NULL;
    
    ENSURE_APARTMENT_ACCESS();

    if (m_piSession == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"Execute() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }


    if (pParameters != NULL)
    {
        PBYTE pbyCmdInfo;

        hr = pParameters->get_CmdInfo(&pbyCmdInfo);
        if (FAILED(hr))
        {
            ReportError(hr);
            goto Cleanup;
        }

        pCmdInfo = (WSTCOMMANDINFO*)pbyCmdInfo;
    }


    // execute the session
    //
    hr = m_piSession->Execute( bstrCmd,
                               pCmdInfo,
                               (IUnknown**)&piRowset,
                               NULL,
                               DBGUID_DEFAULT,
                               IID_IRowset);

    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    } 

    // give the results back in the form of a WSResultset
    //
    hr = CComObject<CWSResultset>::CreateInstance(&pResultset);
    if (FAILED(hr))
    {
        ReportError(hr, L"Failed to create instance of IWSResultset");
        goto Cleanup;
    }
    pResultset->AddRef();
    
    hr = pResultset->InitFromRowset(piRowset);
    if (FAILED(hr))
    {
        // already reported
        goto Cleanup;
    }

    pResultset->AddRef();
    *ppiResultset = pResultset;


Cleanup:
    if ( pResultset )
    {
        pResultset->Release();
    }
    return hr;
}

////////////////////////////////////////////////////////////////
// CWSSession::ExecuteNonQuery
//
//      Executes SQL commands without returning a recordset.
//
//  Parameters
//      bstrCmd         the SQL command to execute.
//      pParamters      Parameters to use with the execution.   can be NULL.
//
////////////////////////////////////////////////////////////////
STDMETHODIMP CWSSession::ExecuteNonQuery(BSTR bstrCmd, IWSParameters* pParameters)
{
    HRESULT                     hr          = S_OK;
    CComPtr<IMultipleResults>   piMultiResults = NULL;
    WSTCOMMANDINFO*             pCmdInfo    = NULL;
    
    ENSURE_APARTMENT_ACCESS();

    if (m_piSession == NULL)
    {
        hr = WSR_E_NOTINITIALIZED;
        ReportError(hr, L"Execute() called before Initialize().   Initialize() must be successfully executed, first.");
        goto Cleanup;
    }


    if (pParameters != NULL)
    {
        PBYTE pbyCmdInfo;

        hr = pParameters->get_CmdInfo(&pbyCmdInfo);
        if (FAILED(hr))
        {
            ReportError(hr);
            goto Cleanup;
        }

        pCmdInfo = (WSTCOMMANDINFO*)pbyCmdInfo;
    }


    // execute the command
    //
    hr = m_piSession->Execute(
                        bstrCmd,
                        pCmdInfo,
                        (IUnknown**)&piMultiResults,
                        NULL,
                        DBGUID_DEFAULT,
                        IID_IRowset);

    if(FAILED(hr))
    {
        ReportError(hr);
        goto Cleanup;
    } 


Cleanup:
    return hr;
}

STDMETHODIMP CWSSession::BeginTransaction()
{
    HRESULT hr = S_OK;
    
    ENSURE_APARTMENT_ACCESS();

    hr = ExecuteNonQuery(CComBSTR(L"begin tran"), NULL);
    
    return (hr);
}

STDMETHODIMP CWSSession::RollbackTransaction()
{
    HRESULT hr = S_OK;
    
    ENSURE_APARTMENT_ACCESS();

    hr = ExecuteNonQuery(CComBSTR(L"rollback tran"), NULL);

    return (hr);
}

STDMETHODIMP CWSSession::CommitTransaction()
{
    HRESULT hr = S_OK;
    
    ENSURE_APARTMENT_ACCESS();

    hr = ExecuteNonQuery(CComBSTR(L"commit tran"), NULL);

    return (hr);
}

////////////////////////////////////////////////////////////////
//
//                      Private Methods
//
////////////////////////////////////////////////////////////////

void CWSSession::ReportError(HRESULT hr)
{
    TCHAR szMsgBuf[512];
    
    switch(hr)
    {
    case WSR_E_NOTINITIALIZED:
        ReportError(hr, L"WSSession::Initialize must be called before any other methods can be executed.");
        break;

    case WSR_E_NOCURRENTROW:
        ReportError(hr, L"The reader is past the end of the recordset.");
        break;

    case WSR_E_ORDINALOUTOFRANGE:
        ReportError(hr, L"The specified oridinal is out of range of valid columns (or Parameters).");
        break;

    case WSR_E_TYPEMISMATCH:
        ReportError(hr, L"The underlying data type does not match the requested type.");
        break;

    case WSR_E_NAMENOTFOUND:
        ReportError(hr, L"Specified name not found.");
        break;

    case WST_E_CONNECTIONTIMEOUT:
        ReportError(hr, L"Webstore error: A connection timedout occured.");
        break;

    case WST_E_NOCONNECTIONAVAIL:
        ReportError(hr, L"Webstore error: No connections are available.");
        break;

    case WST_E_MARKEDOFFLINE:
        ReportError(hr, L"Webstore error: The requested database is marked as offline.");
        break;

    case WST_E_MARKEDREADONLY:
        ReportError(hr, L"Webstore error: The requested database is marked as read-only.");
        break;

    case WST_E_SERVERNOTREGISTERED:
        ReportError(hr, L"Webstore error: The specified server is not registered.");
        break;

    case WST_E_APPLICATIONNOTEXIST:
        ReportError(hr, L"Webstore error: The specified application does not exist.");
        break;

    case WST_E_TRANCOUNTEXIST:
        ReportError(hr, L"Webstore error: Webstore returned WST_E_TRANCOUNTEXIST.");
        break;

    case WST_E_ADMINCONSOLENOTEXIST:
        ReportError(hr, L"Webstore error: The admin console does not exist.");
        break;
            
    default:
        // If there's a message associated with this error, report that
        if (::FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL, hr,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) szMsgBuf, 512, NULL) 
                != 0)
        {
            ReportError(hr, (LPCTSTR)szMsgBuf);
        }

        // Not an error we recgonize.   If it was another
        // interface that reported the  error, leave it to them
        // to SetErrorInfo().  Otherwise the client can 
        // use their own generic message.

        break;

    }

}

void CWSSession::ReportError(HRESULT hr, LPCTSTR pszMsg)
{
    AtlReportError(CLSID_WSSession, (LPCTSTR) pszMsg, IID_IWSSession, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\obj\i386\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( wsreader )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( wsreader ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\objd\i386\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( wsreader )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( wsreader ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\obj\i386\wsreader_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for wsreader.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IWSResultset,0x037DCCE2,0x9C0F,0x4035,0xAF,0x4E,0x02,0x88,0x4A,0xB8,0xA0,0x4A);


MIDL_DEFINE_GUID(IID, IID_IWSParameters,0xA3C38387,0x72DF,0x4359,0x8B,0xA8,0x41,0x5B,0x5E,0x98,0xA6,0x07);


MIDL_DEFINE_GUID(IID, IID_IWSSession,0x4742e047,0xc949,0x4b75,0x8b,0x3c,0xde,0x17,0x03,0x98,0x6e,0xc7);


MIDL_DEFINE_GUID(IID, IID_IWSDataReader,0x7FCE9E4B,0x5626,0x4A60,0xBA,0xD4,0x4D,0x69,0x0C,0xD5,0x42,0xDC);


MIDL_DEFINE_GUID(IID, LIBID_WSREADERLib,0x17A7FCD0,0x8295,0x4750,0x9C,0xD0,0x42,0x34,0x3F,0xC1,0xBF,0x31);


MIDL_DEFINE_GUID(CLSID, CLSID_WSDataReader,0x4C05B710,0x2756,0x4B5F,0xBD,0xCD,0x7A,0xF3,0x53,0x77,0x94,0x80);


MIDL_DEFINE_GUID(CLSID, CLSID_WSSession,0xf7aab024,0xfa4a,0x4563,0x9b,0xe0,0x2a,0xfe,0x86,0x21,0x89,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_WSResultset,0x5A400301,0x0B11,0x42DC,0xA9,0x42,0xCA,0xB5,0x73,0x96,0x96,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_WSParameters,0x98CF8B00,0x2EB5,0x4221,0xA5,0x99,0x3B,0x4C,0x15,0x6F,0x80,0x41);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_wsreader_none_12.4.56.0_none_80958b262781479b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsreader
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775.manifest
XP_MANIFEST_PATH=manifests\x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775.cat
XP_CATALOG_PATH=manifests\x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775.cat
XP_PAYLOAD_PATH=x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsreader,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\obj\i386\wsreader.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for wsreader.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wsreader_h__
#define __wsreader_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWSResultset_FWD_DEFINED__
#define __IWSResultset_FWD_DEFINED__
typedef interface IWSResultset IWSResultset;
#endif 	/* __IWSResultset_FWD_DEFINED__ */


#ifndef __IWSParameters_FWD_DEFINED__
#define __IWSParameters_FWD_DEFINED__
typedef interface IWSParameters IWSParameters;
#endif 	/* __IWSParameters_FWD_DEFINED__ */


#ifndef __IWSSession_FWD_DEFINED__
#define __IWSSession_FWD_DEFINED__
typedef interface IWSSession IWSSession;
#endif 	/* __IWSSession_FWD_DEFINED__ */


#ifndef __IWSDataReader_FWD_DEFINED__
#define __IWSDataReader_FWD_DEFINED__
typedef interface IWSDataReader IWSDataReader;
#endif 	/* __IWSDataReader_FWD_DEFINED__ */


#ifndef __WSDataReader_FWD_DEFINED__
#define __WSDataReader_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSDataReader WSDataReader;
#else
typedef struct WSDataReader WSDataReader;
#endif /* __cplusplus */

#endif 	/* __WSDataReader_FWD_DEFINED__ */


#ifndef __WSSession_FWD_DEFINED__
#define __WSSession_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSSession WSSession;
#else
typedef struct WSSession WSSession;
#endif /* __cplusplus */

#endif 	/* __WSSession_FWD_DEFINED__ */


#ifndef __WSResultset_FWD_DEFINED__
#define __WSResultset_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSResultset WSResultset;
#else
typedef struct WSResultset WSResultset;
#endif /* __cplusplus */

#endif 	/* __WSResultset_FWD_DEFINED__ */


#ifndef __WSParameters_FWD_DEFINED__
#define __WSParameters_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSParameters WSParameters;
#else
typedef struct WSParameters WSParameters;
#endif /* __cplusplus */

#endif 	/* __WSParameters_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wsreader_0000_0000 */
/* [local] */ 

typedef 
enum tagWSREADER_PARTITION_MODE
    {	WSREADER_PARTITION_MODE_LOGICAL	= 0,
	WSREADER_PARTITION_MODE_PHYSICAL	= ( WSREADER_PARTITION_MODE_LOGICAL + 1 ) 
    } 	WSREADER_PARTITION_MODE;



extern RPC_IF_HANDLE __MIDL_itf_wsreader_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsreader_0000_0000_v0_0_s_ifspec;

#ifndef __IWSResultset_INTERFACE_DEFINED__
#define __IWSResultset_INTERFACE_DEFINED__

/* interface IWSResultset */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWSResultset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("037DCCE2-9C0F-4035-AF4E-02884AB8A04A")
    IWSResultset : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [retval][out] */ VARIANT_BOOL *pbResults) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NextResult( 
            /* [retval][out] */ VARIANT_BOOL *pbResults) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetByte( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BYTE *pbiVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt16( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SHORT *psiVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt32( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONG *plValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFloat( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ FLOAT *pfltValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt64( 
            ULONG ulOrdinal,
            /* [retval][out] */ LONGLONG *pqwValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BSTR *pbstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDate( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ DATE *pdtValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetByteArray( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SAFEARRAY * *rgpbValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsDBNull( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ VARIANT_BOOL *pbIsNull) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetOrdinal( 
            /* [in] */ BSTR bstrColumnName,
            /* [retval][out] */ ULONG *pulOrdinal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSResultsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSResultset * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSResultset * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSResultset * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWSResultset * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWSResultset * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWSResultset * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWSResultset * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IWSResultset * This,
            /* [retval][out] */ VARIANT_BOOL *pbResults);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NextResult )( 
            IWSResultset * This,
            /* [retval][out] */ VARIANT_BOOL *pbResults);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetByte )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BYTE *pbiVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt16 )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SHORT *psiVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt32 )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONG *plValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetFloat )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ FLOAT *pfltValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt64 )( 
            IWSResultset * This,
            ULONG ulOrdinal,
            /* [retval][out] */ LONGLONG *pqwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDate )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ DATE *pdtValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetByteArray )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SAFEARRAY * *rgpbValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsDBNull )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ VARIANT_BOOL *pbIsNull);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetOrdinal )( 
            IWSResultset * This,
            /* [in] */ BSTR bstrColumnName,
            /* [retval][out] */ ULONG *pulOrdinal);
        
        END_INTERFACE
    } IWSResultsetVtbl;

    interface IWSResultset
    {
        CONST_VTBL struct IWSResultsetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSResultset_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSResultset_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSResultset_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSResultset_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWSResultset_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWSResultset_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWSResultset_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWSResultset_Read(This,pbResults)	\
    ( (This)->lpVtbl -> Read(This,pbResults) ) 

#define IWSResultset_NextResult(This,pbResults)	\
    ( (This)->lpVtbl -> NextResult(This,pbResults) ) 

#define IWSResultset_GetByte(This,ulOrdinal,pbiVal)	\
    ( (This)->lpVtbl -> GetByte(This,ulOrdinal,pbiVal) ) 

#define IWSResultset_GetInt16(This,ulOrdinal,psiVal)	\
    ( (This)->lpVtbl -> GetInt16(This,ulOrdinal,psiVal) ) 

#define IWSResultset_GetInt32(This,ulOrdinal,plValue)	\
    ( (This)->lpVtbl -> GetInt32(This,ulOrdinal,plValue) ) 

#define IWSResultset_GetFloat(This,ulOrdinal,pfltValue)	\
    ( (This)->lpVtbl -> GetFloat(This,ulOrdinal,pfltValue) ) 

#define IWSResultset_GetInt64(This,ulOrdinal,pqwValue)	\
    ( (This)->lpVtbl -> GetInt64(This,ulOrdinal,pqwValue) ) 

#define IWSResultset_GetString(This,ulOrdinal,pbstrValue)	\
    ( (This)->lpVtbl -> GetString(This,ulOrdinal,pbstrValue) ) 

#define IWSResultset_GetDate(This,ulOrdinal,pdtValue)	\
    ( (This)->lpVtbl -> GetDate(This,ulOrdinal,pdtValue) ) 

#define IWSResultset_GetByteArray(This,ulOrdinal,rgpbValue)	\
    ( (This)->lpVtbl -> GetByteArray(This,ulOrdinal,rgpbValue) ) 

#define IWSResultset_IsDBNull(This,ulOrdinal,pbIsNull)	\
    ( (This)->lpVtbl -> IsDBNull(This,ulOrdinal,pbIsNull) ) 

#define IWSResultset_GetOrdinal(This,bstrColumnName,pulOrdinal)	\
    ( (This)->lpVtbl -> GetOrdinal(This,bstrColumnName,pulOrdinal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSResultset_INTERFACE_DEFINED__ */


#ifndef __IWSParameters_INTERFACE_DEFINED__
#define __IWSParameters_INTERFACE_DEFINED__

/* interface IWSParameters */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWSParameters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3C38387-72DF-4359-8BA8-415B5E98A607")
    IWSParameters : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddByte( 
            /* [in] */ LONG lDirection,
            /* [in] */ BYTE bValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddInt16( 
            /* [in] */ LONG lDirection,
            /* [in] */ SHORT siValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddInt32( 
            /* [in] */ LONG lDirection,
            /* [in] */ LONG lValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddInt64( 
            /* [in] */ LONG lDirection,
            /* [in] */ LONGLONG qwValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddDate( 
            /* [in] */ LONG lDirection,
            /* [in] */ DATE dtValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddString( 
            /* [in] */ LONG lDirection,
            /* [in] */ BSTR bstrValue,
            /* [in] */ ULONG ulMaxLen) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddByteArray( 
            /* [in] */ LONG lDirection,
            /* [in] */ SAFEARRAY * psaValue,
            /* [in] */ ULONG ulMaxLen) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetByte( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BYTE *pbValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt16( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SHORT *psiValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt32( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONG *plValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt64( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONGLONG *pqwValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDate( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ DATE *pdtValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BSTR *pbstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetByteArray( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SAFEARRAY * *psaValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsDBNull( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ VARIANT_BOOL *bIsNull) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_CmdInfo( 
            /* [retval][out] */ BYTE **ppbyCmdInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CleanUp( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSParametersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSParameters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSParameters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSParameters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWSParameters * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWSParameters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWSParameters * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWSParameters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddByte )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ BYTE bValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddInt16 )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ SHORT siValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddInt32 )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ LONG lValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddInt64 )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ LONGLONG qwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddDate )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ DATE dtValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddString )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ BSTR bstrValue,
            /* [in] */ ULONG ulMaxLen);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddByteArray )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ SAFEARRAY * psaValue,
            /* [in] */ ULONG ulMaxLen);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetByte )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BYTE *pbValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt16 )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SHORT *psiValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt32 )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONG *plValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt64 )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONGLONG *pqwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDate )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ DATE *pdtValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetByteArray )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SAFEARRAY * *psaValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsDBNull )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ VARIANT_BOOL *bIsNull);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_CmdInfo )( 
            IWSParameters * This,
            /* [retval][out] */ BYTE **ppbyCmdInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CleanUp )( 
            IWSParameters * This);
        
        END_INTERFACE
    } IWSParametersVtbl;

    interface IWSParameters
    {
        CONST_VTBL struct IWSParametersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSParameters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSParameters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSParameters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSParameters_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWSParameters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWSParameters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWSParameters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWSParameters_AddByte(This,lDirection,bValue)	\
    ( (This)->lpVtbl -> AddByte(This,lDirection,bValue) ) 

#define IWSParameters_AddInt16(This,lDirection,siValue)	\
    ( (This)->lpVtbl -> AddInt16(This,lDirection,siValue) ) 

#define IWSParameters_AddInt32(This,lDirection,lValue)	\
    ( (This)->lpVtbl -> AddInt32(This,lDirection,lValue) ) 

#define IWSParameters_AddInt64(This,lDirection,qwValue)	\
    ( (This)->lpVtbl -> AddInt64(This,lDirection,qwValue) ) 

#define IWSParameters_AddDate(This,lDirection,dtValue)	\
    ( (This)->lpVtbl -> AddDate(This,lDirection,dtValue) ) 

#define IWSParameters_AddString(This,lDirection,bstrValue,ulMaxLen)	\
    ( (This)->lpVtbl -> AddString(This,lDirection,bstrValue,ulMaxLen) ) 

#define IWSParameters_AddByteArray(This,lDirection,psaValue,ulMaxLen)	\
    ( (This)->lpVtbl -> AddByteArray(This,lDirection,psaValue,ulMaxLen) ) 

#define IWSParameters_GetByte(This,ulOrdinal,pbValue)	\
    ( (This)->lpVtbl -> GetByte(This,ulOrdinal,pbValue) ) 

#define IWSParameters_GetInt16(This,ulOrdinal,psiValue)	\
    ( (This)->lpVtbl -> GetInt16(This,ulOrdinal,psiValue) ) 

#define IWSParameters_GetInt32(This,ulOrdinal,plValue)	\
    ( (This)->lpVtbl -> GetInt32(This,ulOrdinal,plValue) ) 

#define IWSParameters_GetInt64(This,ulOrdinal,pqwValue)	\
    ( (This)->lpVtbl -> GetInt64(This,ulOrdinal,pqwValue) ) 

#define IWSParameters_GetDate(This,ulOrdinal,pdtValue)	\
    ( (This)->lpVtbl -> GetDate(This,ulOrdinal,pdtValue) ) 

#define IWSParameters_GetString(This,ulOrdinal,pbstrValue)	\
    ( (This)->lpVtbl -> GetString(This,ulOrdinal,pbstrValue) ) 

#define IWSParameters_GetByteArray(This,ulOrdinal,psaValue)	\
    ( (This)->lpVtbl -> GetByteArray(This,ulOrdinal,psaValue) ) 

#define IWSParameters_IsDBNull(This,ulOrdinal,bIsNull)	\
    ( (This)->lpVtbl -> IsDBNull(This,ulOrdinal,bIsNull) ) 

#define IWSParameters_get_CmdInfo(This,ppbyCmdInfo)	\
    ( (This)->lpVtbl -> get_CmdInfo(This,ppbyCmdInfo) ) 

#define IWSParameters_CleanUp(This)	\
    ( (This)->lpVtbl -> CleanUp(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSParameters_INTERFACE_DEFINED__ */


#ifndef __IWSSession_INTERFACE_DEFINED__
#define __IWSSession_INTERFACE_DEFINED__

/* interface IWSSession */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWSSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4742e047-c949-4b75-8b3c-de1703986ec7")
    IWSSession : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteNonQuery( 
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BeginTransaction( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RollbackTransaction( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CommitTransaction( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteReturnRowset( 
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWSSession * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWSSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWSSession * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWSSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IWSSession * This,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteNonQuery )( 
            IWSSession * This,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IWSSession * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RollbackTransaction )( 
            IWSSession * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CommitTransaction )( 
            IWSSession * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteReturnRowset )( 
            IWSSession * This,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset);
        
        END_INTERFACE
    } IWSSessionVtbl;

    interface IWSSession
    {
        CONST_VTBL struct IWSSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSSession_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWSSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWSSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWSSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWSSession_Execute(This,bstrCmd,pParameters,ppiResultset)	\
    ( (This)->lpVtbl -> Execute(This,bstrCmd,pParameters,ppiResultset) ) 

#define IWSSession_ExecuteNonQuery(This,bstrCmd,pParameters)	\
    ( (This)->lpVtbl -> ExecuteNonQuery(This,bstrCmd,pParameters) ) 

#define IWSSession_BeginTransaction(This)	\
    ( (This)->lpVtbl -> BeginTransaction(This) ) 

#define IWSSession_RollbackTransaction(This)	\
    ( (This)->lpVtbl -> RollbackTransaction(This) ) 

#define IWSSession_CommitTransaction(This)	\
    ( (This)->lpVtbl -> CommitTransaction(This) ) 

#define IWSSession_ExecuteReturnRowset(This,bstrCmd,pParameters,ppiResultset)	\
    ( (This)->lpVtbl -> ExecuteReturnRowset(This,bstrCmd,pParameters,ppiResultset) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSSession_INTERFACE_DEFINED__ */


#ifndef __IWSDataReader_INTERFACE_DEFINED__
#define __IWSDataReader_INTERFACE_DEFINED__

/* interface IWSDataReader */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWSDataReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FCE9E4B-5626-4A60-BAD4-4D690CD542DC")
    IWSDataReader : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ BSTR bstrAppName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteNonQuery( 
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSession( 
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [retval][out] */ IWSSession **ppiSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionFromInt32( 
            /* [in] */ LONG lValue,
            /* [retval][out] */ LONG *lPartition) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionFromInt64( 
            /* [in] */ LONGLONG qwValue,
            /* [retval][out] */ LONG *lPartition) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionFromString( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ LONG *lPartition) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartitionCount( 
            /* [retval][out] */ LONG *plValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeInitialize( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteReturnRowset( 
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeEx( 
            /* [in] */ BSTR bstrAppName,
            /* [in] */ BOOL fSequentialAccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPartitionMode( 
            /* [in] */ WSREADER_PARTITION_MODE mode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPhysicalFromLogical( 
            /* [in] */ LONG lLogical,
            /* [out] */ LONG *plPhysical) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LogicalPartitionCount( 
            /* [retval][out] */ LONG *plValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhysicalPartitionCount( 
            /* [retval][out] */ LONG *plValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDataReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDataReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDataReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDataReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWSDataReader * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWSDataReader * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWSDataReader * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWSDataReader * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IWSDataReader * This,
            /* [in] */ BSTR bstrAppName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IWSDataReader * This,
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteNonQuery )( 
            IWSDataReader * This,
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IWSDataReader * This,
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [retval][out] */ IWSSession **ppiSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFromInt32 )( 
            IWSDataReader * This,
            /* [in] */ LONG lValue,
            /* [retval][out] */ LONG *lPartition);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFromInt64 )( 
            IWSDataReader * This,
            /* [in] */ LONGLONG qwValue,
            /* [retval][out] */ LONG *lPartition);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFromString )( 
            IWSDataReader * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ LONG *lPartition);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartitionCount )( 
            IWSDataReader * This,
            /* [retval][out] */ LONG *plValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeInitialize )( 
            IWSDataReader * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteReturnRowset )( 
            IWSDataReader * This,
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InitializeEx )( 
            IWSDataReader * This,
            /* [in] */ BSTR bstrAppName,
            /* [in] */ BOOL fSequentialAccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetPartitionMode )( 
            IWSDataReader * This,
            /* [in] */ WSREADER_PARTITION_MODE mode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPhysicalFromLogical )( 
            IWSDataReader * This,
            /* [in] */ LONG lLogical,
            /* [out] */ LONG *plPhysical);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogicalPartitionCount )( 
            IWSDataReader * This,
            /* [retval][out] */ LONG *plValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PhysicalPartitionCount )( 
            IWSDataReader * This,
            /* [retval][out] */ LONG *plValue);
        
        END_INTERFACE
    } IWSDataReaderVtbl;

    interface IWSDataReader
    {
        CONST_VTBL struct IWSDataReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDataReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDataReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDataReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDataReader_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWSDataReader_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWSDataReader_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWSDataReader_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWSDataReader_Initialize(This,bstrAppName)	\
    ( (This)->lpVtbl -> Initialize(This,bstrAppName) ) 

#define IWSDataReader_Execute(This,cmdType,lHash,bstrCmd,pParameters,ppiResultset)	\
    ( (This)->lpVtbl -> Execute(This,cmdType,lHash,bstrCmd,pParameters,ppiResultset) ) 

#define IWSDataReader_ExecuteNonQuery(This,cmdType,lHash,bstrCmd,pParameters)	\
    ( (This)->lpVtbl -> ExecuteNonQuery(This,cmdType,lHash,bstrCmd,pParameters) ) 

#define IWSDataReader_GetSession(This,cmdType,lHash,ppiSession)	\
    ( (This)->lpVtbl -> GetSession(This,cmdType,lHash,ppiSession) ) 

#define IWSDataReader_GetPartitionFromInt32(This,lValue,lPartition)	\
    ( (This)->lpVtbl -> GetPartitionFromInt32(This,lValue,lPartition) ) 

#define IWSDataReader_GetPartitionFromInt64(This,qwValue,lPartition)	\
    ( (This)->lpVtbl -> GetPartitionFromInt64(This,qwValue,lPartition) ) 

#define IWSDataReader_GetPartitionFromString(This,bstrValue,lPartition)	\
    ( (This)->lpVtbl -> GetPartitionFromString(This,bstrValue,lPartition) ) 

#define IWSDataReader_get_PartitionCount(This,plValue)	\
    ( (This)->lpVtbl -> get_PartitionCount(This,plValue) ) 

#define IWSDataReader_DeInitialize(This)	\
    ( (This)->lpVtbl -> DeInitialize(This) ) 

#define IWSDataReader_ExecuteReturnRowset(This,cmdType,lHash,bstrCmd,pParameters,ppiResultset)	\
    ( (This)->lpVtbl -> ExecuteReturnRowset(This,cmdType,lHash,bstrCmd,pParameters,ppiResultset) ) 

#define IWSDataReader_InitializeEx(This,bstrAppName,fSequentialAccess)	\
    ( (This)->lpVtbl -> InitializeEx(This,bstrAppName,fSequentialAccess) ) 

#define IWSDataReader_SetPartitionMode(This,mode)	\
    ( (This)->lpVtbl -> SetPartitionMode(This,mode) ) 

#define IWSDataReader_GetPhysicalFromLogical(This,lLogical,plPhysical)	\
    ( (This)->lpVtbl -> GetPhysicalFromLogical(This,lLogical,plPhysical) ) 

#define IWSDataReader_get_LogicalPartitionCount(This,plValue)	\
    ( (This)->lpVtbl -> get_LogicalPartitionCount(This,plValue) ) 

#define IWSDataReader_get_PhysicalPartitionCount(This,plValue)	\
    ( (This)->lpVtbl -> get_PhysicalPartitionCount(This,plValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDataReader_INTERFACE_DEFINED__ */



#ifndef __WSREADERLib_LIBRARY_DEFINED__
#define __WSREADERLib_LIBRARY_DEFINED__

/* library WSREADERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WSREADERLib;

EXTERN_C const CLSID CLSID_WSDataReader;

#ifdef __cplusplus

class DECLSPEC_UUID("4C05B710-2756-4B5F-BDCD-7AF353779480")
WSDataReader;
#endif

EXTERN_C const CLSID CLSID_WSSession;

#ifdef __cplusplus

class DECLSPEC_UUID("f7aab024-fa4a-4563-9be0-2afe86218969")
WSSession;
#endif

EXTERN_C const CLSID CLSID_WSResultset;

#ifdef __cplusplus

class DECLSPEC_UUID("5A400301-0B11-42DC-A942-CAB57396966B")
WSResultset;
#endif

EXTERN_C const CLSID CLSID_WSParameters;

#ifdef __cplusplus

class DECLSPEC_UUID("98CF8B00-2EB5-4221-A599-3B4C156F8041")
WSParameters;
#endif
#endif /* __WSREADERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\obj\i386\wsreader_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for wsreader.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "wsreader.h"

#define TYPE_FORMAT_STRING_SIZE   1337                              
#define PROC_FORMAT_STRING_SIZE   2029                              
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _wsreader_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } wsreader_MIDL_TYPE_FORMAT_STRING;

typedef struct _wsreader_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } wsreader_MIDL_PROC_FORMAT_STRING;

typedef struct _wsreader_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } wsreader_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const wsreader_MIDL_TYPE_FORMAT_STRING wsreader__MIDL_TypeFormatString;
extern const wsreader_MIDL_PROC_FORMAT_STRING wsreader__MIDL_ProcFormatString;
extern const wsreader_MIDL_EXPR_FORMAT_STRING wsreader__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IWSResultset_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IWSResultset_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IWSParameters_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IWSParameters_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IWSSession_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IWSSession_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IWSDataReader_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IWSDataReader_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const wsreader_MIDL_PROC_FORMAT_STRING wsreader__MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Read */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x22 ),	/* 34 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 16 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbResults */

/* 24 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NextResult */

/* 36 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
/* 44 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x22 ),	/* 34 */
/* 50 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 52 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbResults */

/* 60 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 64 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetByte */

/* 72 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0x9 ),	/* 9 */
/* 80 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 82 */	NdrFcShort( 0x8 ),	/* 8 */
/* 84 */	NdrFcShort( 0x21 ),	/* 33 */
/* 86 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 88 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 96 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 98 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbiVal */

/* 102 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 106 */	0x1,		/* FC_BYTE */
			0x0,		/* 0 */

	/* Return value */

/* 108 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 110 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 112 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInt16 */

/* 114 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 116 */	NdrFcLong( 0x0 ),	/* 0 */
/* 120 */	NdrFcShort( 0xa ),	/* 10 */
/* 122 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	NdrFcShort( 0x22 ),	/* 34 */
/* 128 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 130 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 138 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 140 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psiVal */

/* 144 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 146 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 148 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 150 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 152 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPartitionFromInt32 */


	/* Procedure GetInt32 */

/* 156 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 158 */	NdrFcLong( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0xb ),	/* 11 */
/* 164 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 166 */	NdrFcShort( 0x8 ),	/* 8 */
/* 168 */	NdrFcShort( 0x24 ),	/* 36 */
/* 170 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 172 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 178 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lValue */


	/* Parameter ulOrdinal */

/* 180 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 182 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lPartition */


	/* Parameter plValue */

/* 186 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 188 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 190 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 194 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFloat */

/* 198 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 200 */	NdrFcLong( 0x0 ),	/* 0 */
/* 204 */	NdrFcShort( 0xc ),	/* 12 */
/* 206 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	NdrFcShort( 0x24 ),	/* 36 */
/* 212 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 214 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 216 */	NdrFcShort( 0x0 ),	/* 0 */
/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 222 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 224 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pfltValue */

/* 228 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 230 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 232 */	0xa,		/* FC_FLOAT */
			0x0,		/* 0 */

	/* Return value */

/* 234 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 236 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 238 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInt64 */

/* 240 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 242 */	NdrFcLong( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0xd ),	/* 13 */
/* 248 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 250 */	NdrFcShort( 0x8 ),	/* 8 */
/* 252 */	NdrFcShort( 0x2c ),	/* 44 */
/* 254 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 256 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 264 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 266 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 268 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pqwValue */

/* 270 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 272 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 274 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 276 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 278 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetString */

/* 282 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 284 */	NdrFcLong( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0xe ),	/* 14 */
/* 290 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 296 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 298 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 300 */	NdrFcShort( 0x1 ),	/* 1 */
/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 306 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 308 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrValue */

/* 312 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 314 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 316 */	NdrFcShort( 0x3e ),	/* Type Offset=62 */

	/* Return value */

/* 318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDate */

/* 324 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 326 */	NdrFcLong( 0x0 ),	/* 0 */
/* 330 */	NdrFcShort( 0xf ),	/* 15 */
/* 332 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 334 */	NdrFcShort( 0x8 ),	/* 8 */
/* 336 */	NdrFcShort( 0x2c ),	/* 44 */
/* 338 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 340 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 350 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdtValue */

/* 354 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 356 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 358 */	0xc,		/* FC_DOUBLE */
			0x0,		/* 0 */

	/* Return value */

/* 360 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 362 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetByteArray */

/* 366 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 368 */	NdrFcLong( 0x0 ),	/* 0 */
/* 372 */	NdrFcShort( 0x10 ),	/* 16 */
/* 374 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 376 */	NdrFcShort( 0x8 ),	/* 8 */
/* 378 */	NdrFcShort( 0x8 ),	/* 8 */
/* 380 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 382 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 384 */	NdrFcShort( 0x1f ),	/* 31 */
/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 390 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 392 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpbValue */

/* 396 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 398 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 400 */	NdrFcShort( 0x4cc ),	/* Type Offset=1228 */

	/* Return value */

/* 402 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 404 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 406 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsDBNull */

/* 408 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 410 */	NdrFcLong( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x11 ),	/* 17 */
/* 416 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 418 */	NdrFcShort( 0x8 ),	/* 8 */
/* 420 */	NdrFcShort( 0x22 ),	/* 34 */
/* 422 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 424 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 426 */	NdrFcShort( 0x0 ),	/* 0 */
/* 428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 430 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 432 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 434 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 436 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbIsNull */

/* 438 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 440 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 442 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 446 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOrdinal */

/* 450 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x12 ),	/* 18 */
/* 458 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 462 */	NdrFcShort( 0x24 ),	/* 36 */
/* 464 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 466 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 470 */	NdrFcShort( 0x1 ),	/* 1 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrColumnName */

/* 474 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 476 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 478 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pulOrdinal */

/* 480 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 482 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 486 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 488 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddByte */

/* 492 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 494 */	NdrFcLong( 0x0 ),	/* 0 */
/* 498 */	NdrFcShort( 0x7 ),	/* 7 */
/* 500 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 502 */	NdrFcShort( 0xd ),	/* 13 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 508 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 516 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 518 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 520 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bValue */

/* 522 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 524 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 526 */	0x1,		/* FC_BYTE */
			0x0,		/* 0 */

	/* Return value */

/* 528 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 530 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 532 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddInt16 */

/* 534 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 536 */	NdrFcLong( 0x0 ),	/* 0 */
/* 540 */	NdrFcShort( 0x8 ),	/* 8 */
/* 542 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 544 */	NdrFcShort( 0xe ),	/* 14 */
/* 546 */	NdrFcShort( 0x8 ),	/* 8 */
/* 548 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 550 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 552 */	NdrFcShort( 0x0 ),	/* 0 */
/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
/* 556 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 558 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 560 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter siValue */

/* 564 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 566 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 568 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 570 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 572 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddInt32 */

/* 576 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 578 */	NdrFcLong( 0x0 ),	/* 0 */
/* 582 */	NdrFcShort( 0x9 ),	/* 9 */
/* 584 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 586 */	NdrFcShort( 0x10 ),	/* 16 */
/* 588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 590 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 592 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 598 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 600 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 602 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 604 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lValue */

/* 606 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 608 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 610 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 612 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 614 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 616 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddInt64 */

/* 618 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 620 */	NdrFcLong( 0x0 ),	/* 0 */
/* 624 */	NdrFcShort( 0xa ),	/* 10 */
/* 626 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 628 */	NdrFcShort( 0x18 ),	/* 24 */
/* 630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 632 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 634 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 636 */	NdrFcShort( 0x0 ),	/* 0 */
/* 638 */	NdrFcShort( 0x0 ),	/* 0 */
/* 640 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 642 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 644 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter qwValue */

/* 648 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 650 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 652 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 654 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 656 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 658 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddDate */

/* 660 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 662 */	NdrFcLong( 0x0 ),	/* 0 */
/* 666 */	NdrFcShort( 0xb ),	/* 11 */
/* 668 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 670 */	NdrFcShort( 0x18 ),	/* 24 */
/* 672 */	NdrFcShort( 0x8 ),	/* 8 */
/* 674 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 676 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 678 */	NdrFcShort( 0x0 ),	/* 0 */
/* 680 */	NdrFcShort( 0x0 ),	/* 0 */
/* 682 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 684 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 686 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 688 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dtValue */

/* 690 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 692 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 694 */	0xc,		/* FC_DOUBLE */
			0x0,		/* 0 */

	/* Return value */

/* 696 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 698 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 700 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddString */

/* 702 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 704 */	NdrFcLong( 0x0 ),	/* 0 */
/* 708 */	NdrFcShort( 0xc ),	/* 12 */
/* 710 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 712 */	NdrFcShort( 0x10 ),	/* 16 */
/* 714 */	NdrFcShort( 0x8 ),	/* 8 */
/* 716 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 718 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x6 ),	/* 6 */
/* 724 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 726 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 728 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bstrValue */

/* 732 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 734 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 736 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter ulMaxLen */

/* 738 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 740 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 742 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 744 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 746 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 748 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddByteArray */

/* 750 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 752 */	NdrFcLong( 0x0 ),	/* 0 */
/* 756 */	NdrFcShort( 0xd ),	/* 13 */
/* 758 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 760 */	NdrFcShort( 0x10 ),	/* 16 */
/* 762 */	NdrFcShort( 0x8 ),	/* 8 */
/* 764 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 766 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 768 */	NdrFcShort( 0x0 ),	/* 0 */
/* 770 */	NdrFcShort( 0x24 ),	/* 36 */
/* 772 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 774 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 776 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 778 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psaValue */

/* 780 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 782 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 784 */	NdrFcShort( 0x4ec ),	/* Type Offset=1260 */

	/* Parameter ulMaxLen */

/* 786 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 788 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 790 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 792 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 794 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetByte */

/* 798 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 800 */	NdrFcLong( 0x0 ),	/* 0 */
/* 804 */	NdrFcShort( 0xe ),	/* 14 */
/* 806 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 808 */	NdrFcShort( 0x8 ),	/* 8 */
/* 810 */	NdrFcShort( 0x21 ),	/* 33 */
/* 812 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 814 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 818 */	NdrFcShort( 0x0 ),	/* 0 */
/* 820 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 822 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 824 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 826 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbValue */

/* 828 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 830 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 832 */	0x1,		/* FC_BYTE */
			0x0,		/* 0 */

	/* Return value */

/* 834 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 836 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 838 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInt16 */

/* 840 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 842 */	NdrFcLong( 0x0 ),	/* 0 */
/* 846 */	NdrFcShort( 0xf ),	/* 15 */
/* 848 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 850 */	NdrFcShort( 0x8 ),	/* 8 */
/* 852 */	NdrFcShort( 0x22 ),	/* 34 */
/* 854 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 856 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 862 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 864 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 866 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psiValue */

/* 870 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 872 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 874 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 876 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 878 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 880 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInt32 */

/* 882 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 884 */	NdrFcLong( 0x0 ),	/* 0 */
/* 888 */	NdrFcShort( 0x10 ),	/* 16 */
/* 890 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 894 */	NdrFcShort( 0x24 ),	/* 36 */
/* 896 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 898 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 900 */	NdrFcShort( 0x0 ),	/* 0 */
/* 902 */	NdrFcShort( 0x0 ),	/* 0 */
/* 904 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 906 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 908 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 910 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter plValue */

/* 912 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 914 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 920 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInt64 */

/* 924 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 926 */	NdrFcLong( 0x0 ),	/* 0 */
/* 930 */	NdrFcShort( 0x11 ),	/* 17 */
/* 932 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 934 */	NdrFcShort( 0x8 ),	/* 8 */
/* 936 */	NdrFcShort( 0x2c ),	/* 44 */
/* 938 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 940 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 942 */	NdrFcShort( 0x0 ),	/* 0 */
/* 944 */	NdrFcShort( 0x0 ),	/* 0 */
/* 946 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 948 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 950 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 952 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pqwValue */

/* 954 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 956 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 958 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 960 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 962 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 964 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDate */

/* 966 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 968 */	NdrFcLong( 0x0 ),	/* 0 */
/* 972 */	NdrFcShort( 0x12 ),	/* 18 */
/* 974 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 976 */	NdrFcShort( 0x8 ),	/* 8 */
/* 978 */	NdrFcShort( 0x2c ),	/* 44 */
/* 980 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 982 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0x0 ),	/* 0 */
/* 988 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 990 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 992 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 994 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdtValue */

/* 996 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 998 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1000 */	0xc,		/* FC_DOUBLE */
			0x0,		/* 0 */

	/* Return value */

/* 1002 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1004 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1006 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetString */

/* 1008 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1010 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1014 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1016 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1018 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1020 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1022 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1024 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 1026 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1028 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1030 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 1032 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1034 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1036 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrValue */

/* 1038 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1040 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1042 */	NdrFcShort( 0x3e ),	/* Type Offset=62 */

	/* Return value */

/* 1044 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1046 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1048 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetByteArray */

/* 1050 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1052 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1056 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1058 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1060 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1062 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1064 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1066 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 1068 */	NdrFcShort( 0x29 ),	/* 41 */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 1074 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1076 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1078 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psaValue */

/* 1080 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1082 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1084 */	NdrFcShort( 0x4cc ),	/* Type Offset=1228 */

	/* Return value */

/* 1086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1088 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsDBNull */

/* 1092 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1098 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1100 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1104 */	NdrFcShort( 0x22 ),	/* 34 */
/* 1106 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 1108 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1114 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 1116 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1118 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1120 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bIsNull */

/* 1122 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1124 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1126 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 1128 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1130 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_CmdInfo */

/* 1134 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1136 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1140 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1142 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1146 */	NdrFcShort( 0x35 ),	/* 53 */
/* 1148 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1150 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1154 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1156 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppbyCmdInfo */

/* 1158 */	NdrFcShort( 0x2012 ),	/* Flags:  must free, out, srv alloc size=8 */
/* 1160 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1162 */	NdrFcShort( 0x4f6 ),	/* Type Offset=1270 */

	/* Return value */

/* 1164 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1166 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1168 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CleanUp */

/* 1170 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1172 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1176 */	NdrFcShort( 0x17 ),	/* 23 */
/* 1178 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1180 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1182 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1184 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1186 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1192 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1194 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1196 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Execute */

/* 1200 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1202 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1206 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1208 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1212 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1214 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1216 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1220 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1222 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrCmd */

/* 1224 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1226 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1228 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1230 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1232 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1234 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Parameter ppiResultset */

/* 1236 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1238 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1240 */	NdrFcShort( 0x50c ),	/* Type Offset=1292 */

	/* Return value */

/* 1242 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1244 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExecuteNonQuery */

/* 1248 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1250 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1254 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1256 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1262 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1264 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1268 */	NdrFcShort( 0xa ),	/* 10 */
/* 1270 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrCmd */

/* 1272 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1274 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1276 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1278 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1280 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1282 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Return value */

/* 1284 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1286 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1288 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BeginTransaction */

/* 1290 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1292 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1296 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1298 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1304 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1306 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1312 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1314 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1316 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1318 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RollbackTransaction */

/* 1320 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1322 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1326 */	NdrFcShort( 0xa ),	/* 10 */
/* 1328 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1332 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1334 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1336 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1340 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1342 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1344 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1346 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1348 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CommitTransaction */

/* 1350 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1352 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1356 */	NdrFcShort( 0xb ),	/* 11 */
/* 1358 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1360 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1362 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1364 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1366 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1368 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1372 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1374 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1376 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExecuteReturnRowset */

/* 1380 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1382 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1386 */	NdrFcShort( 0xc ),	/* 12 */
/* 1388 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1392 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1394 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1396 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1400 */	NdrFcShort( 0xa ),	/* 10 */
/* 1402 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrCmd */

/* 1404 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1406 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1408 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1410 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1412 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1414 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Parameter ppiResultset */

/* 1416 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1418 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1420 */	NdrFcShort( 0x50c ),	/* Type Offset=1292 */

	/* Return value */

/* 1422 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1424 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Initialize */

/* 1428 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1430 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1434 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1436 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1440 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1442 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 1444 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1446 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1448 */	NdrFcShort( 0xa ),	/* 10 */
/* 1450 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrAppName */

/* 1452 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1454 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1456 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 1458 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1460 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1462 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Execute */

/* 1464 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1466 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1472 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1474 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1476 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1478 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1480 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1484 */	NdrFcShort( 0xa ),	/* 10 */
/* 1486 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cmdType */

/* 1488 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1490 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1492 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lHash */

/* 1494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1496 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bstrCmd */

/* 1500 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1502 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1504 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1506 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1508 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1510 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Parameter ppiResultset */

/* 1512 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1514 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1516 */	NdrFcShort( 0x50c ),	/* Type Offset=1292 */

	/* Return value */

/* 1518 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1520 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1522 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExecuteNonQuery */

/* 1524 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1526 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1530 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1532 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1534 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1536 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1538 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1540 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1542 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1544 */	NdrFcShort( 0xa ),	/* 10 */
/* 1546 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cmdType */

/* 1548 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1550 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1552 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lHash */

/* 1554 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1556 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bstrCmd */

/* 1560 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1562 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1564 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1566 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1568 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1570 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Return value */

/* 1572 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1574 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1576 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSession */

/* 1578 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1580 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1584 */	NdrFcShort( 0xa ),	/* 10 */
/* 1586 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1588 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1590 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1592 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 1594 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1598 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1600 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cmdType */

/* 1602 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1604 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1606 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lHash */

/* 1608 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1610 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppiSession */

/* 1614 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1616 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1618 */	NdrFcShort( 0x522 ),	/* Type Offset=1314 */

	/* Return value */

/* 1620 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1622 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1624 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPartitionFromInt64 */

/* 1626 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1628 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1632 */	NdrFcShort( 0xc ),	/* 12 */
/* 1634 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1636 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1638 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1640 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 1642 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1648 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter qwValue */

/* 1650 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1652 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1654 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter lPartition */

/* 1656 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1658 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1660 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1662 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1664 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPartitionFromString */

/* 1668 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1670 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1674 */	NdrFcShort( 0xd ),	/* 13 */
/* 1676 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1678 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1680 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1682 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1684 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1688 */	NdrFcShort( 0xa ),	/* 10 */
/* 1690 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrValue */

/* 1692 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1694 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1696 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter lPartition */

/* 1698 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1700 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1702 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1704 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1706 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1708 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_PartitionCount */

/* 1710 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1712 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1716 */	NdrFcShort( 0xe ),	/* 14 */
/* 1718 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1722 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1724 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1726 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1732 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plValue */

/* 1734 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1736 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1738 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1740 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1742 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1744 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DeInitialize */

/* 1746 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1748 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1752 */	NdrFcShort( 0xf ),	/* 15 */
/* 1754 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1758 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1760 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1762 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1764 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1768 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1770 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1772 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1774 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExecuteReturnRowset */

/* 1776 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1778 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1782 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1784 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1786 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1788 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1790 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1792 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1796 */	NdrFcShort( 0xa ),	/* 10 */
/* 1798 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cmdType */

/* 1800 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1802 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1804 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lHash */

/* 1806 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1808 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bstrCmd */

/* 1812 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1814 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1816 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1818 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1820 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1822 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Parameter ppiResultset */

/* 1824 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1826 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1828 */	NdrFcShort( 0x50c ),	/* Type Offset=1292 */

	/* Return value */

/* 1830 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1832 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1834 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure InitializeEx */

/* 1836 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1838 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1842 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1844 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1846 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1848 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1850 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1852 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1854 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1856 */	NdrFcShort( 0xa ),	/* 10 */
/* 1858 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrAppName */

/* 1860 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1862 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1864 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter fSequentialAccess */

/* 1866 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1868 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1872 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1874 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1876 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetPartitionMode */

/* 1878 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1880 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1884 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1886 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1888 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1890 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1892 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1894 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1896 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1898 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1900 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter mode */

/* 1902 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1904 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1906 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 1908 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1910 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1912 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPhysicalFromLogical */

/* 1914 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1916 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1920 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1922 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1924 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1926 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1928 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 1930 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1934 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1936 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lLogical */

/* 1938 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1940 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1942 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter plPhysical */

/* 1944 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1946 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1948 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1950 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1952 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1954 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_LogicalPartitionCount */

/* 1956 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1958 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1962 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1964 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1966 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1968 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1970 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1972 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1974 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1976 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1978 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plValue */

/* 1980 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1982 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1984 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1986 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1988 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1990 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_PhysicalPartitionCount */

/* 1992 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1994 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1998 */	NdrFcShort( 0x15 ),	/* 21 */
/* 2000 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2004 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2006 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2008 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 2010 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2014 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plValue */

/* 2016 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2018 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2022 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2024 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2026 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const wsreader_MIDL_TYPE_FORMAT_STRING wsreader__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/*  4 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/*  8 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 10 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 12 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 14 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 16 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 18 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 20 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 22 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 24 */	NdrFcShort( 0x26 ),	/* Offset= 38 (62) */
/* 26 */	
			0x13, 0x0,	/* FC_OP */
/* 28 */	NdrFcShort( 0x18 ),	/* Offset= 24 (52) */
/* 30 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 32 */	NdrFcShort( 0x2 ),	/* 2 */
/* 34 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 36 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 38 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 40 */	0x0 , 
			0x0,		/* 0 */
/* 42 */	NdrFcLong( 0x0 ),	/* 0 */
/* 46 */	NdrFcLong( 0x0 ),	/* 0 */
/* 50 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 52 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (30) */
/* 58 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 60 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 62 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
/* 66 */	NdrFcShort( 0x4 ),	/* 4 */
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
/* 70 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (26) */
/* 72 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 74 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 76 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 78 */	NdrFcShort( 0x47e ),	/* Offset= 1150 (1228) */
/* 80 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 82 */	NdrFcShort( 0x2 ),	/* Offset= 2 (84) */
/* 84 */	
			0x13, 0x0,	/* FC_OP */
/* 86 */	NdrFcShort( 0x464 ),	/* Offset= 1124 (1210) */
/* 88 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 90 */	NdrFcShort( 0x18 ),	/* 24 */
/* 92 */	NdrFcShort( 0xa ),	/* 10 */
/* 94 */	NdrFcLong( 0x8 ),	/* 8 */
/* 98 */	NdrFcShort( 0x64 ),	/* Offset= 100 (198) */
/* 100 */	NdrFcLong( 0xd ),	/* 13 */
/* 104 */	NdrFcShort( 0xae ),	/* Offset= 174 (278) */
/* 106 */	NdrFcLong( 0x9 ),	/* 9 */
/* 110 */	NdrFcShort( 0xf4 ),	/* Offset= 244 (354) */
/* 112 */	NdrFcLong( 0xc ),	/* 12 */
/* 116 */	NdrFcShort( 0x30c ),	/* Offset= 780 (896) */
/* 118 */	NdrFcLong( 0x24 ),	/* 36 */
/* 122 */	NdrFcShort( 0x340 ),	/* Offset= 832 (954) */
/* 124 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 128 */	NdrFcShort( 0x35c ),	/* Offset= 860 (988) */
/* 130 */	NdrFcLong( 0x10 ),	/* 16 */
/* 134 */	NdrFcShort( 0x380 ),	/* Offset= 896 (1030) */
/* 136 */	NdrFcLong( 0x2 ),	/* 2 */
/* 140 */	NdrFcShort( 0x3a4 ),	/* Offset= 932 (1072) */
/* 142 */	NdrFcLong( 0x3 ),	/* 3 */
/* 146 */	NdrFcShort( 0x3c8 ),	/* Offset= 968 (1114) */
/* 148 */	NdrFcLong( 0x14 ),	/* 20 */
/* 152 */	NdrFcShort( 0x3ec ),	/* Offset= 1004 (1156) */
/* 154 */	NdrFcShort( 0xffff ),	/* Offset= -1 (153) */
/* 156 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 158 */	NdrFcShort( 0x4 ),	/* 4 */
/* 160 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 166 */	0x0 , 
			0x0,		/* 0 */
/* 168 */	NdrFcLong( 0x0 ),	/* 0 */
/* 172 */	NdrFcLong( 0x0 ),	/* 0 */
/* 176 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 178 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 180 */	NdrFcShort( 0x4 ),	/* 4 */
/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
/* 184 */	NdrFcShort( 0x1 ),	/* 1 */
/* 186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	0x13, 0x0,	/* FC_OP */
/* 192 */	NdrFcShort( 0xff74 ),	/* Offset= -140 (52) */
/* 194 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 196 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 198 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 200 */	NdrFcShort( 0x8 ),	/* 8 */
/* 202 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 204 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 206 */	NdrFcShort( 0x4 ),	/* 4 */
/* 208 */	NdrFcShort( 0x4 ),	/* 4 */
/* 210 */	0x11, 0x0,	/* FC_RP */
/* 212 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (156) */
/* 214 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 216 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 218 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 220 */	NdrFcLong( 0x0 ),	/* 0 */
/* 224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 228 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 230 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 232 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 234 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 236 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 244 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 246 */	0x0 , 
			0x0,		/* 0 */
/* 248 */	NdrFcLong( 0x0 ),	/* 0 */
/* 252 */	NdrFcLong( 0x0 ),	/* 0 */
/* 256 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 260 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 262 */	0x0 , 
			0x0,		/* 0 */
/* 264 */	NdrFcLong( 0x0 ),	/* 0 */
/* 268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 272 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 274 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (218) */
/* 276 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 278 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 280 */	NdrFcShort( 0x8 ),	/* 8 */
/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
/* 284 */	NdrFcShort( 0x6 ),	/* Offset= 6 (290) */
/* 286 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 288 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 290 */	
			0x11, 0x0,	/* FC_RP */
/* 292 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (236) */
/* 294 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 296 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
/* 304 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 306 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 308 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 310 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 312 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 316 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 318 */	NdrFcShort( 0x0 ),	/* 0 */
/* 320 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 322 */	0x0 , 
			0x0,		/* 0 */
/* 324 */	NdrFcLong( 0x0 ),	/* 0 */
/* 328 */	NdrFcLong( 0x0 ),	/* 0 */
/* 332 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 336 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 338 */	0x0 , 
			0x0,		/* 0 */
/* 340 */	NdrFcLong( 0x0 ),	/* 0 */
/* 344 */	NdrFcLong( 0x0 ),	/* 0 */
/* 348 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 350 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (294) */
/* 352 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 354 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 356 */	NdrFcShort( 0x8 ),	/* 8 */
/* 358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x6 ),	/* Offset= 6 (366) */
/* 362 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 364 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 366 */	
			0x11, 0x0,	/* FC_RP */
/* 368 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (312) */
/* 370 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 372 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 374 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 376 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 378 */	0x0 , 
			0x0,		/* 0 */
/* 380 */	NdrFcLong( 0x0 ),	/* 0 */
/* 384 */	NdrFcLong( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x2 ),	/* Offset= 2 (390) */
/* 390 */	NdrFcShort( 0x10 ),	/* 16 */
/* 392 */	NdrFcShort( 0x2f ),	/* 47 */
/* 394 */	NdrFcLong( 0x14 ),	/* 20 */
/* 398 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 400 */	NdrFcLong( 0x3 ),	/* 3 */
/* 404 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 406 */	NdrFcLong( 0x11 ),	/* 17 */
/* 410 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 412 */	NdrFcLong( 0x2 ),	/* 2 */
/* 416 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 418 */	NdrFcLong( 0x4 ),	/* 4 */
/* 422 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 424 */	NdrFcLong( 0x5 ),	/* 5 */
/* 428 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 430 */	NdrFcLong( 0xb ),	/* 11 */
/* 434 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 436 */	NdrFcLong( 0xa ),	/* 10 */
/* 440 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 442 */	NdrFcLong( 0x6 ),	/* 6 */
/* 446 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (678) */
/* 448 */	NdrFcLong( 0x7 ),	/* 7 */
/* 452 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 454 */	NdrFcLong( 0x8 ),	/* 8 */
/* 458 */	NdrFcShort( 0xfe50 ),	/* Offset= -432 (26) */
/* 460 */	NdrFcLong( 0xd ),	/* 13 */
/* 464 */	NdrFcShort( 0xff0a ),	/* Offset= -246 (218) */
/* 466 */	NdrFcLong( 0x9 ),	/* 9 */
/* 470 */	NdrFcShort( 0xff50 ),	/* Offset= -176 (294) */
/* 472 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 476 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (684) */
/* 478 */	NdrFcLong( 0x24 ),	/* 36 */
/* 482 */	NdrFcShort( 0xd2 ),	/* Offset= 210 (692) */
/* 484 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 488 */	NdrFcShort( 0xcc ),	/* Offset= 204 (692) */
/* 490 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 494 */	NdrFcShort( 0x106 ),	/* Offset= 262 (756) */
/* 496 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 500 */	NdrFcShort( 0x104 ),	/* Offset= 260 (760) */
/* 502 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 506 */	NdrFcShort( 0x102 ),	/* Offset= 258 (764) */
/* 508 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 512 */	NdrFcShort( 0x100 ),	/* Offset= 256 (768) */
/* 514 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 518 */	NdrFcShort( 0xfe ),	/* Offset= 254 (772) */
/* 520 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 524 */	NdrFcShort( 0xfc ),	/* Offset= 252 (776) */
/* 526 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 530 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (760) */
/* 532 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 536 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (764) */
/* 538 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 542 */	NdrFcShort( 0xee ),	/* Offset= 238 (780) */
/* 544 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 548 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (776) */
/* 550 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 554 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (784) */
/* 556 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 560 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (788) */
/* 562 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 566 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (792) */
/* 568 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 572 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (796) */
/* 574 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 578 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (808) */
/* 580 */	NdrFcLong( 0x10 ),	/* 16 */
/* 584 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 586 */	NdrFcLong( 0x12 ),	/* 18 */
/* 590 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 592 */	NdrFcLong( 0x13 ),	/* 19 */
/* 596 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 598 */	NdrFcLong( 0x15 ),	/* 21 */
/* 602 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 604 */	NdrFcLong( 0x16 ),	/* 22 */
/* 608 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 610 */	NdrFcLong( 0x17 ),	/* 23 */
/* 614 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 616 */	NdrFcLong( 0xe ),	/* 14 */
/* 620 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (816) */
/* 622 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 626 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (826) */
/* 628 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 632 */	NdrFcShort( 0xc6 ),	/* Offset= 198 (830) */
/* 634 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 638 */	NdrFcShort( 0x7a ),	/* Offset= 122 (760) */
/* 640 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 644 */	NdrFcShort( 0x78 ),	/* Offset= 120 (764) */
/* 646 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 650 */	NdrFcShort( 0x76 ),	/* Offset= 118 (768) */
/* 652 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 656 */	NdrFcShort( 0x6c ),	/* Offset= 108 (764) */
/* 658 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 662 */	NdrFcShort( 0x66 ),	/* Offset= 102 (764) */
/* 664 */	NdrFcLong( 0x0 ),	/* 0 */
/* 668 */	NdrFcShort( 0x0 ),	/* Offset= 0 (668) */
/* 670 */	NdrFcLong( 0x1 ),	/* 1 */
/* 674 */	NdrFcShort( 0x0 ),	/* Offset= 0 (674) */
/* 676 */	NdrFcShort( 0xffff ),	/* Offset= -1 (675) */
/* 678 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 680 */	NdrFcShort( 0x8 ),	/* 8 */
/* 682 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 684 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 686 */	NdrFcShort( 0x2 ),	/* Offset= 2 (688) */
/* 688 */	
			0x13, 0x0,	/* FC_OP */
/* 690 */	NdrFcShort( 0x208 ),	/* Offset= 520 (1210) */
/* 692 */	
			0x13, 0x0,	/* FC_OP */
/* 694 */	NdrFcShort( 0x2a ),	/* Offset= 42 (736) */
/* 696 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 698 */	NdrFcLong( 0x2f ),	/* 47 */
/* 702 */	NdrFcShort( 0x0 ),	/* 0 */
/* 704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 706 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 708 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 710 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 712 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 714 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 716 */	NdrFcShort( 0x1 ),	/* 1 */
/* 718 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 720 */	NdrFcShort( 0x4 ),	/* 4 */
/* 722 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 724 */	0x0 , 
			0x0,		/* 0 */
/* 726 */	NdrFcLong( 0x0 ),	/* 0 */
/* 730 */	NdrFcLong( 0x0 ),	/* 0 */
/* 734 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 736 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 738 */	NdrFcShort( 0x10 ),	/* 16 */
/* 740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 742 */	NdrFcShort( 0xa ),	/* Offset= 10 (752) */
/* 744 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 746 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 748 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (696) */
/* 750 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 752 */	
			0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 754 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (714) */
/* 756 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 758 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 760 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 762 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 764 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 766 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 768 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 770 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 772 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 774 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 776 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 778 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 780 */	
			0x13, 0x0,	/* FC_OP */
/* 782 */	NdrFcShort( 0xff98 ),	/* Offset= -104 (678) */
/* 784 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 786 */	NdrFcShort( 0xfd08 ),	/* Offset= -760 (26) */
/* 788 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 790 */	NdrFcShort( 0xfdc4 ),	/* Offset= -572 (218) */
/* 792 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 794 */	NdrFcShort( 0xfe0c ),	/* Offset= -500 (294) */
/* 796 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 798 */	NdrFcShort( 0x2 ),	/* Offset= 2 (800) */
/* 800 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 802 */	NdrFcShort( 0x2 ),	/* Offset= 2 (804) */
/* 804 */	
			0x13, 0x0,	/* FC_OP */
/* 806 */	NdrFcShort( 0x194 ),	/* Offset= 404 (1210) */
/* 808 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 810 */	NdrFcShort( 0x2 ),	/* Offset= 2 (812) */
/* 812 */	
			0x13, 0x0,	/* FC_OP */
/* 814 */	NdrFcShort( 0x14 ),	/* Offset= 20 (834) */
/* 816 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 818 */	NdrFcShort( 0x10 ),	/* 16 */
/* 820 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 822 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 824 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 826 */	
			0x13, 0x0,	/* FC_OP */
/* 828 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (816) */
/* 830 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 832 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 834 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 836 */	NdrFcShort( 0x20 ),	/* 32 */
/* 838 */	NdrFcShort( 0x0 ),	/* 0 */
/* 840 */	NdrFcShort( 0x0 ),	/* Offset= 0 (840) */
/* 842 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 844 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 846 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 848 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 850 */	NdrFcShort( 0xfe20 ),	/* Offset= -480 (370) */
/* 852 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 854 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 856 */	NdrFcShort( 0x4 ),	/* 4 */
/* 858 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 862 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 864 */	0x0 , 
			0x0,		/* 0 */
/* 866 */	NdrFcLong( 0x0 ),	/* 0 */
/* 870 */	NdrFcLong( 0x0 ),	/* 0 */
/* 874 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 876 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 878 */	NdrFcShort( 0x4 ),	/* 4 */
/* 880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 882 */	NdrFcShort( 0x1 ),	/* 1 */
/* 884 */	NdrFcShort( 0x0 ),	/* 0 */
/* 886 */	NdrFcShort( 0x0 ),	/* 0 */
/* 888 */	0x13, 0x0,	/* FC_OP */
/* 890 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (834) */
/* 892 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 894 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 896 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 898 */	NdrFcShort( 0x8 ),	/* 8 */
/* 900 */	NdrFcShort( 0x0 ),	/* 0 */
/* 902 */	NdrFcShort( 0x6 ),	/* Offset= 6 (908) */
/* 904 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 906 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 908 */	
			0x11, 0x0,	/* FC_RP */
/* 910 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (854) */
/* 912 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 914 */	NdrFcShort( 0x4 ),	/* 4 */
/* 916 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 920 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 922 */	0x0 , 
			0x0,		/* 0 */
/* 924 */	NdrFcLong( 0x0 ),	/* 0 */
/* 928 */	NdrFcLong( 0x0 ),	/* 0 */
/* 932 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 934 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 936 */	NdrFcShort( 0x4 ),	/* 4 */
/* 938 */	NdrFcShort( 0x0 ),	/* 0 */
/* 940 */	NdrFcShort( 0x1 ),	/* 1 */
/* 942 */	NdrFcShort( 0x0 ),	/* 0 */
/* 944 */	NdrFcShort( 0x0 ),	/* 0 */
/* 946 */	0x13, 0x0,	/* FC_OP */
/* 948 */	NdrFcShort( 0xff2c ),	/* Offset= -212 (736) */
/* 950 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 952 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 954 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 956 */	NdrFcShort( 0x8 ),	/* 8 */
/* 958 */	NdrFcShort( 0x0 ),	/* 0 */
/* 960 */	NdrFcShort( 0x6 ),	/* Offset= 6 (966) */
/* 962 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 964 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 966 */	
			0x11, 0x0,	/* FC_RP */
/* 968 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (912) */
/* 970 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 972 */	NdrFcShort( 0x8 ),	/* 8 */
/* 974 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 976 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 978 */	NdrFcShort( 0x10 ),	/* 16 */
/* 980 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 982 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 984 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (970) */
			0x5b,		/* FC_END */
/* 988 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 990 */	NdrFcShort( 0x18 ),	/* 24 */
/* 992 */	NdrFcShort( 0x0 ),	/* 0 */
/* 994 */	NdrFcShort( 0xa ),	/* Offset= 10 (1004) */
/* 996 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 998 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1000 */	NdrFcShort( 0xffe8 ),	/* Offset= -24 (976) */
/* 1002 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1004 */	
			0x11, 0x0,	/* FC_RP */
/* 1006 */	NdrFcShort( 0xfcfe ),	/* Offset= -770 (236) */
/* 1008 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1010 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1012 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1014 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1016 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1018 */	0x0 , 
			0x0,		/* 0 */
/* 1020 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1028 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1030 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1032 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1034 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1036 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1038 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1040 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1042 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1044 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1008) */
/* 1046 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1048 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1050 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1052 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1054 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1056 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1058 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1060 */	0x0 , 
			0x0,		/* 0 */
/* 1062 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1066 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1070 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1072 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1074 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1076 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1078 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1080 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1082 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1084 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1086 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1050) */
/* 1088 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1090 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1092 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1094 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1096 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1100 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1102 */	0x0 , 
			0x0,		/* 0 */
/* 1104 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1112 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1114 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1118 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1120 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1122 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1124 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1126 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1128 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1092) */
/* 1130 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1132 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1134 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1136 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1138 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1142 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1144 */	0x0 , 
			0x0,		/* 0 */
/* 1146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1150 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1154 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1156 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1158 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1160 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1162 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1164 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1166 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1168 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1170 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1134) */
/* 1172 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1174 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1176 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1178 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1180 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1182 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1184 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1186 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1188 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1190 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 1192 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1194 */	0x0 , 
			0x0,		/* 0 */
/* 1196 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1200 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1204 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1206 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (1176) */
/* 1208 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1210 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1212 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1214 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (1184) */
/* 1216 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1216) */
/* 1218 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1220 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1222 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1224 */	NdrFcShort( 0xfb90 ),	/* Offset= -1136 (88) */
/* 1226 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1228 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1230 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1232 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1236 */	NdrFcShort( 0xfb7c ),	/* Offset= -1156 (80) */
/* 1238 */	
			0x12, 0x0,	/* FC_UP */
/* 1240 */	NdrFcShort( 0xfb5c ),	/* Offset= -1188 (52) */
/* 1242 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1246 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (1238) */
/* 1252 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1254 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1256) */
/* 1256 */	
			0x12, 0x0,	/* FC_UP */
/* 1258 */	NdrFcShort( 0xffd0 ),	/* Offset= -48 (1210) */
/* 1260 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1262 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1264 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1268 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (1252) */
/* 1270 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1272 */	NdrFcShort( 0xfdfc ),	/* Offset= -516 (756) */
/* 1274 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1276 */	NdrFcLong( 0xa3c38387 ),	/* -1547467897 */
/* 1280 */	NdrFcShort( 0x72df ),	/* 29407 */
/* 1282 */	NdrFcShort( 0x4359 ),	/* 17241 */
/* 1284 */	0x8b,		/* 139 */
			0xa8,		/* 168 */
/* 1286 */	0x41,		/* 65 */
			0x5b,		/* 91 */
/* 1288 */	0x5e,		/* 94 */
			0x98,		/* 152 */
/* 1290 */	0xa6,		/* 166 */
			0x7,		/* 7 */
/* 1292 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1294 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1296) */
/* 1296 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1298 */	NdrFcLong( 0x37dcce2 ),	/* 58576098 */
/* 1302 */	NdrFcShort( 0x9c0f ),	/* -25585 */
/* 1304 */	NdrFcShort( 0x4035 ),	/* 16437 */
/* 1306 */	0xaf,		/* 175 */
			0x4e,		/* 78 */
/* 1308 */	0x2,		/* 2 */
			0x88,		/* 136 */
/* 1310 */	0x4a,		/* 74 */
			0xb8,		/* 184 */
/* 1312 */	0xa0,		/* 160 */
			0x4a,		/* 74 */
/* 1314 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1316 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1318) */
/* 1318 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1320 */	NdrFcLong( 0x4742e047 ),	/* 1195565127 */
/* 1324 */	NdrFcShort( 0xc949 ),	/* -14007 */
/* 1326 */	NdrFcShort( 0x4b75 ),	/* 19317 */
/* 1328 */	0x8b,		/* 139 */
			0x3c,		/* 60 */
/* 1330 */	0xde,		/* 222 */
			0x17,		/* 23 */
/* 1332 */	0x3,		/* 3 */
			0x98,		/* 152 */
/* 1334 */	0x6e,		/* 110 */
			0xc7,		/* 199 */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            }

        };



/* Standard interface: __MIDL_itf_wsreader_0000_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IWSResultset, ver. 0.0,
   GUID={0x037DCCE2,0x9C0F,0x4035,{0xAF,0x4E,0x02,0x88,0x4A,0xB8,0xA0,0x4A}} */

#pragma code_seg(".orpc")
static const unsigned short IWSResultset_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    36,
    72,
    114,
    156,
    198,
    240,
    282,
    324,
    366,
    408,
    450
    };

static const MIDL_STUBLESS_PROXY_INFO IWSResultset_ProxyInfo =
    {
    &Object_StubDesc,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSResultset_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IWSResultset_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSResultset_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(19) _IWSResultsetProxyVtbl = 
{
    &IWSResultset_ProxyInfo,
    &IID_IWSResultset,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::Read */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::NextResult */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetByte */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetInt16 */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetInt32 */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetFloat */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetInt64 */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetString */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetDate */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetByteArray */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::IsDBNull */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetOrdinal */
};


static const PRPC_STUB_FUNCTION IWSResultset_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IWSResultsetStubVtbl =
{
    &IID_IWSResultset,
    &IWSResultset_ServerInfo,
    19,
    &IWSResultset_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: IWSParameters, ver. 0.0,
   GUID={0xA3C38387,0x72DF,0x4359,{0x8B,0xA8,0x41,0x5B,0x5E,0x98,0xA6,0x07}} */

#pragma code_seg(".orpc")
static const unsigned short IWSParameters_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    492,
    534,
    576,
    618,
    660,
    702,
    750,
    798,
    840,
    882,
    924,
    966,
    1008,
    1050,
    1092,
    1134,
    1170
    };

static const MIDL_STUBLESS_PROXY_INFO IWSParameters_ProxyInfo =
    {
    &Object_StubDesc,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSParameters_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IWSParameters_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSParameters_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(24) _IWSParametersProxyVtbl = 
{
    &IWSParameters_ProxyInfo,
    &IID_IWSParameters,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddByte */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddInt16 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddInt32 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddInt64 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddDate */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddString */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddByteArray */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetByte */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetInt16 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetInt32 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetInt64 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetDate */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetString */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetByteArray */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::IsDBNull */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::get_CmdInfo */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::CleanUp */
};


static const PRPC_STUB_FUNCTION IWSParameters_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IWSParametersStubVtbl =
{
    &IID_IWSParameters,
    &IWSParameters_ServerInfo,
    24,
    &IWSParameters_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: IWSSession, ver. 0.0,
   GUID={0x4742e047,0xc949,0x4b75,{0x8b,0x3c,0xde,0x17,0x03,0x98,0x6e,0xc7}} */

#pragma code_seg(".orpc")
static const unsigned short IWSSession_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    1200,
    1248,
    1290,
    1320,
    1350,
    1380
    };

static const MIDL_STUBLESS_PROXY_INFO IWSSession_ProxyInfo =
    {
    &Object_StubDesc,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSSession_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IWSSession_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSSession_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _IWSSessionProxyVtbl = 
{
    &IWSSession_ProxyInfo,
    &IID_IWSSession,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IWSSession::Execute */ ,
    (void *) (INT_PTR) -1 /* IWSSession::ExecuteNonQuery */ ,
    (void *) (INT_PTR) -1 /* IWSSession::BeginTransaction */ ,
    (void *) (INT_PTR) -1 /* IWSSession::RollbackTransaction */ ,
    (void *) (INT_PTR) -1 /* IWSSession::CommitTransaction */ ,
    (void *) (INT_PTR) -1 /* IWSSession::ExecuteReturnRowset */
};


static const PRPC_STUB_FUNCTION IWSSession_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IWSSessionStubVtbl =
{
    &IID_IWSSession,
    &IWSSession_ServerInfo,
    13,
    &IWSSession_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: IWSDataReader, ver. 0.0,
   GUID={0x7FCE9E4B,0x5626,0x4A60,{0xBA,0xD4,0x4D,0x69,0x0C,0xD5,0x42,0xDC}} */

#pragma code_seg(".orpc")
static const unsigned short IWSDataReader_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    1428,
    1464,
    1524,
    1578,
    156,
    1626,
    1668,
    1710,
    1746,
    1776,
    1836,
    1878,
    1914,
    1956,
    1992
    };

static const MIDL_STUBLESS_PROXY_INFO IWSDataReader_ProxyInfo =
    {
    &Object_StubDesc,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSDataReader_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IWSDataReader_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSDataReader_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(22) _IWSDataReaderProxyVtbl = 
{
    &IWSDataReader_ProxyInfo,
    &IID_IWSDataReader,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::Initialize */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::Execute */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::ExecuteNonQuery */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::GetSession */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::GetPartitionFromInt32 */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::GetPartitionFromInt64 */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::GetPartitionFromString */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::get_PartitionCount */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::DeInitialize */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::ExecuteReturnRowset */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::InitializeEx */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::SetPartitionMode */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::GetPhysicalFromLogical */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::get_LogicalPartitionCount */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::get_PhysicalPartitionCount */
};


static const PRPC_STUB_FUNCTION IWSDataReader_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IWSDataReaderStubVtbl =
{
    &IID_IWSDataReader,
    &IWSDataReader_ServerInfo,
    22,
    &IWSDataReader_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    wsreader__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x70001f4, /* MIDL Version 7.0.500 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * _wsreader_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IWSSessionProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IWSDataReaderProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IWSParametersProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IWSResultsetProxyVtbl,
    0
};

const CInterfaceStubVtbl * _wsreader_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IWSSessionStubVtbl,
    ( CInterfaceStubVtbl *) &_IWSDataReaderStubVtbl,
    ( CInterfaceStubVtbl *) &_IWSParametersStubVtbl,
    ( CInterfaceStubVtbl *) &_IWSResultsetStubVtbl,
    0
};

PCInterfaceName const _wsreader_InterfaceNamesList[] = 
{
    "IWSSession",
    "IWSDataReader",
    "IWSParameters",
    "IWSResultset",
    0
};

const IID *  _wsreader_BaseIIDList[] = 
{
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    0
};


#define _wsreader_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _wsreader, pIID, n)

int __stdcall _wsreader_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _wsreader, 4, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _wsreader, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _wsreader, 4, *pIndex )
    
}

const ExtendedProxyFileInfo wsreader_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _wsreader_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _wsreader_StubVtblList,
    (const PCInterfaceName * ) & _wsreader_InterfaceNamesList,
    (const IID ** ) & _wsreader_BaseIIDList,
    & _wsreader_IID_Lookup, 
    4,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_wsreader_none_12.4.56.0_none_80958b262781479b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wsreader
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775.manifest
XP_MANIFEST_PATH=manifests\x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775.cat
XP_CATALOG_PATH=manifests\x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775.cat
XP_PAYLOAD_PATH=x86_wsreader_no-public-key_12.4.56.0_x-ww_ee2f2775
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wsreader,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\objd\i386\wsreader_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for wsreader.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IWSResultset,0x037DCCE2,0x9C0F,0x4035,0xAF,0x4E,0x02,0x88,0x4A,0xB8,0xA0,0x4A);


MIDL_DEFINE_GUID(IID, IID_IWSParameters,0xA3C38387,0x72DF,0x4359,0x8B,0xA8,0x41,0x5B,0x5E,0x98,0xA6,0x07);


MIDL_DEFINE_GUID(IID, IID_IWSSession,0x4742e047,0xc949,0x4b75,0x8b,0x3c,0xde,0x17,0x03,0x98,0x6e,0xc7);


MIDL_DEFINE_GUID(IID, IID_IWSDataReader,0x7FCE9E4B,0x5626,0x4A60,0xBA,0xD4,0x4D,0x69,0x0C,0xD5,0x42,0xDC);


MIDL_DEFINE_GUID(IID, LIBID_WSREADERLib,0x17A7FCD0,0x8295,0x4750,0x9C,0xD0,0x42,0x34,0x3F,0xC1,0xBF,0x31);


MIDL_DEFINE_GUID(CLSID, CLSID_WSDataReader,0x4C05B710,0x2756,0x4B5F,0xBD,0xCD,0x7A,0xF3,0x53,0x77,0x94,0x80);


MIDL_DEFINE_GUID(CLSID, CLSID_WSSession,0xf7aab024,0xfa4a,0x4563,0x9b,0xe0,0x2a,0xfe,0x86,0x21,0x89,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_WSResultset,0x5A400301,0x0B11,0x42DC,0xA9,0x42,0xCA,0xB5,0x73,0x96,0x96,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_WSParameters,0x98CF8B00,0x2EB5,0x4221,0xA5,0x99,0x3B,0x4C,0x15,0x6F,0x80,0x41);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\objd\i386\wsreader.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for wsreader.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wsreader_h__
#define __wsreader_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWSResultset_FWD_DEFINED__
#define __IWSResultset_FWD_DEFINED__
typedef interface IWSResultset IWSResultset;
#endif 	/* __IWSResultset_FWD_DEFINED__ */


#ifndef __IWSParameters_FWD_DEFINED__
#define __IWSParameters_FWD_DEFINED__
typedef interface IWSParameters IWSParameters;
#endif 	/* __IWSParameters_FWD_DEFINED__ */


#ifndef __IWSSession_FWD_DEFINED__
#define __IWSSession_FWD_DEFINED__
typedef interface IWSSession IWSSession;
#endif 	/* __IWSSession_FWD_DEFINED__ */


#ifndef __IWSDataReader_FWD_DEFINED__
#define __IWSDataReader_FWD_DEFINED__
typedef interface IWSDataReader IWSDataReader;
#endif 	/* __IWSDataReader_FWD_DEFINED__ */


#ifndef __WSDataReader_FWD_DEFINED__
#define __WSDataReader_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSDataReader WSDataReader;
#else
typedef struct WSDataReader WSDataReader;
#endif /* __cplusplus */

#endif 	/* __WSDataReader_FWD_DEFINED__ */


#ifndef __WSSession_FWD_DEFINED__
#define __WSSession_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSSession WSSession;
#else
typedef struct WSSession WSSession;
#endif /* __cplusplus */

#endif 	/* __WSSession_FWD_DEFINED__ */


#ifndef __WSResultset_FWD_DEFINED__
#define __WSResultset_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSResultset WSResultset;
#else
typedef struct WSResultset WSResultset;
#endif /* __cplusplus */

#endif 	/* __WSResultset_FWD_DEFINED__ */


#ifndef __WSParameters_FWD_DEFINED__
#define __WSParameters_FWD_DEFINED__

#ifdef __cplusplus
typedef class WSParameters WSParameters;
#else
typedef struct WSParameters WSParameters;
#endif /* __cplusplus */

#endif 	/* __WSParameters_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wsreader_0000_0000 */
/* [local] */ 

typedef 
enum tagWSREADER_PARTITION_MODE
    {	WSREADER_PARTITION_MODE_LOGICAL	= 0,
	WSREADER_PARTITION_MODE_PHYSICAL	= ( WSREADER_PARTITION_MODE_LOGICAL + 1 ) 
    } 	WSREADER_PARTITION_MODE;



extern RPC_IF_HANDLE __MIDL_itf_wsreader_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wsreader_0000_0000_v0_0_s_ifspec;

#ifndef __IWSResultset_INTERFACE_DEFINED__
#define __IWSResultset_INTERFACE_DEFINED__

/* interface IWSResultset */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWSResultset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("037DCCE2-9C0F-4035-AF4E-02884AB8A04A")
    IWSResultset : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Read( 
            /* [retval][out] */ VARIANT_BOOL *pbResults) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NextResult( 
            /* [retval][out] */ VARIANT_BOOL *pbResults) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetByte( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BYTE *pbiVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt16( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SHORT *psiVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt32( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONG *plValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFloat( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ FLOAT *pfltValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt64( 
            ULONG ulOrdinal,
            /* [retval][out] */ LONGLONG *pqwValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BSTR *pbstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDate( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ DATE *pdtValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetByteArray( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SAFEARRAY * *rgpbValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsDBNull( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ VARIANT_BOOL *pbIsNull) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetOrdinal( 
            /* [in] */ BSTR bstrColumnName,
            /* [retval][out] */ ULONG *pulOrdinal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSResultsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSResultset * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSResultset * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSResultset * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWSResultset * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWSResultset * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWSResultset * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWSResultset * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IWSResultset * This,
            /* [retval][out] */ VARIANT_BOOL *pbResults);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NextResult )( 
            IWSResultset * This,
            /* [retval][out] */ VARIANT_BOOL *pbResults);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetByte )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BYTE *pbiVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt16 )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SHORT *psiVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt32 )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONG *plValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetFloat )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ FLOAT *pfltValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt64 )( 
            IWSResultset * This,
            ULONG ulOrdinal,
            /* [retval][out] */ LONGLONG *pqwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDate )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ DATE *pdtValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetByteArray )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SAFEARRAY * *rgpbValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsDBNull )( 
            IWSResultset * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ VARIANT_BOOL *pbIsNull);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetOrdinal )( 
            IWSResultset * This,
            /* [in] */ BSTR bstrColumnName,
            /* [retval][out] */ ULONG *pulOrdinal);
        
        END_INTERFACE
    } IWSResultsetVtbl;

    interface IWSResultset
    {
        CONST_VTBL struct IWSResultsetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSResultset_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSResultset_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSResultset_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSResultset_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWSResultset_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWSResultset_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWSResultset_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWSResultset_Read(This,pbResults)	\
    ( (This)->lpVtbl -> Read(This,pbResults) ) 

#define IWSResultset_NextResult(This,pbResults)	\
    ( (This)->lpVtbl -> NextResult(This,pbResults) ) 

#define IWSResultset_GetByte(This,ulOrdinal,pbiVal)	\
    ( (This)->lpVtbl -> GetByte(This,ulOrdinal,pbiVal) ) 

#define IWSResultset_GetInt16(This,ulOrdinal,psiVal)	\
    ( (This)->lpVtbl -> GetInt16(This,ulOrdinal,psiVal) ) 

#define IWSResultset_GetInt32(This,ulOrdinal,plValue)	\
    ( (This)->lpVtbl -> GetInt32(This,ulOrdinal,plValue) ) 

#define IWSResultset_GetFloat(This,ulOrdinal,pfltValue)	\
    ( (This)->lpVtbl -> GetFloat(This,ulOrdinal,pfltValue) ) 

#define IWSResultset_GetInt64(This,ulOrdinal,pqwValue)	\
    ( (This)->lpVtbl -> GetInt64(This,ulOrdinal,pqwValue) ) 

#define IWSResultset_GetString(This,ulOrdinal,pbstrValue)	\
    ( (This)->lpVtbl -> GetString(This,ulOrdinal,pbstrValue) ) 

#define IWSResultset_GetDate(This,ulOrdinal,pdtValue)	\
    ( (This)->lpVtbl -> GetDate(This,ulOrdinal,pdtValue) ) 

#define IWSResultset_GetByteArray(This,ulOrdinal,rgpbValue)	\
    ( (This)->lpVtbl -> GetByteArray(This,ulOrdinal,rgpbValue) ) 

#define IWSResultset_IsDBNull(This,ulOrdinal,pbIsNull)	\
    ( (This)->lpVtbl -> IsDBNull(This,ulOrdinal,pbIsNull) ) 

#define IWSResultset_GetOrdinal(This,bstrColumnName,pulOrdinal)	\
    ( (This)->lpVtbl -> GetOrdinal(This,bstrColumnName,pulOrdinal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSResultset_INTERFACE_DEFINED__ */


#ifndef __IWSParameters_INTERFACE_DEFINED__
#define __IWSParameters_INTERFACE_DEFINED__

/* interface IWSParameters */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWSParameters;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3C38387-72DF-4359-8BA8-415B5E98A607")
    IWSParameters : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddByte( 
            /* [in] */ LONG lDirection,
            /* [in] */ BYTE bValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddInt16( 
            /* [in] */ LONG lDirection,
            /* [in] */ SHORT siValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddInt32( 
            /* [in] */ LONG lDirection,
            /* [in] */ LONG lValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddInt64( 
            /* [in] */ LONG lDirection,
            /* [in] */ LONGLONG qwValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddDate( 
            /* [in] */ LONG lDirection,
            /* [in] */ DATE dtValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddString( 
            /* [in] */ LONG lDirection,
            /* [in] */ BSTR bstrValue,
            /* [in] */ ULONG ulMaxLen) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddByteArray( 
            /* [in] */ LONG lDirection,
            /* [in] */ SAFEARRAY * psaValue,
            /* [in] */ ULONG ulMaxLen) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetByte( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BYTE *pbValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt16( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SHORT *psiValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt32( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONG *plValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInt64( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONGLONG *pqwValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDate( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ DATE *pdtValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BSTR *pbstrValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetByteArray( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SAFEARRAY * *psaValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsDBNull( 
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ VARIANT_BOOL *bIsNull) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_CmdInfo( 
            /* [retval][out] */ BYTE **ppbyCmdInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CleanUp( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSParametersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSParameters * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSParameters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSParameters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWSParameters * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWSParameters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWSParameters * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWSParameters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddByte )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ BYTE bValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddInt16 )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ SHORT siValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddInt32 )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ LONG lValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddInt64 )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ LONGLONG qwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddDate )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ DATE dtValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddString )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ BSTR bstrValue,
            /* [in] */ ULONG ulMaxLen);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddByteArray )( 
            IWSParameters * This,
            /* [in] */ LONG lDirection,
            /* [in] */ SAFEARRAY * psaValue,
            /* [in] */ ULONG ulMaxLen);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetByte )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BYTE *pbValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt16 )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SHORT *psiValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt32 )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONG *plValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInt64 )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ LONGLONG *pqwValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDate )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ DATE *pdtValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ BSTR *pbstrValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetByteArray )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ SAFEARRAY * *psaValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsDBNull )( 
            IWSParameters * This,
            /* [in] */ ULONG ulOrdinal,
            /* [retval][out] */ VARIANT_BOOL *bIsNull);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_CmdInfo )( 
            IWSParameters * This,
            /* [retval][out] */ BYTE **ppbyCmdInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CleanUp )( 
            IWSParameters * This);
        
        END_INTERFACE
    } IWSParametersVtbl;

    interface IWSParameters
    {
        CONST_VTBL struct IWSParametersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSParameters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSParameters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSParameters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSParameters_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWSParameters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWSParameters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWSParameters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWSParameters_AddByte(This,lDirection,bValue)	\
    ( (This)->lpVtbl -> AddByte(This,lDirection,bValue) ) 

#define IWSParameters_AddInt16(This,lDirection,siValue)	\
    ( (This)->lpVtbl -> AddInt16(This,lDirection,siValue) ) 

#define IWSParameters_AddInt32(This,lDirection,lValue)	\
    ( (This)->lpVtbl -> AddInt32(This,lDirection,lValue) ) 

#define IWSParameters_AddInt64(This,lDirection,qwValue)	\
    ( (This)->lpVtbl -> AddInt64(This,lDirection,qwValue) ) 

#define IWSParameters_AddDate(This,lDirection,dtValue)	\
    ( (This)->lpVtbl -> AddDate(This,lDirection,dtValue) ) 

#define IWSParameters_AddString(This,lDirection,bstrValue,ulMaxLen)	\
    ( (This)->lpVtbl -> AddString(This,lDirection,bstrValue,ulMaxLen) ) 

#define IWSParameters_AddByteArray(This,lDirection,psaValue,ulMaxLen)	\
    ( (This)->lpVtbl -> AddByteArray(This,lDirection,psaValue,ulMaxLen) ) 

#define IWSParameters_GetByte(This,ulOrdinal,pbValue)	\
    ( (This)->lpVtbl -> GetByte(This,ulOrdinal,pbValue) ) 

#define IWSParameters_GetInt16(This,ulOrdinal,psiValue)	\
    ( (This)->lpVtbl -> GetInt16(This,ulOrdinal,psiValue) ) 

#define IWSParameters_GetInt32(This,ulOrdinal,plValue)	\
    ( (This)->lpVtbl -> GetInt32(This,ulOrdinal,plValue) ) 

#define IWSParameters_GetInt64(This,ulOrdinal,pqwValue)	\
    ( (This)->lpVtbl -> GetInt64(This,ulOrdinal,pqwValue) ) 

#define IWSParameters_GetDate(This,ulOrdinal,pdtValue)	\
    ( (This)->lpVtbl -> GetDate(This,ulOrdinal,pdtValue) ) 

#define IWSParameters_GetString(This,ulOrdinal,pbstrValue)	\
    ( (This)->lpVtbl -> GetString(This,ulOrdinal,pbstrValue) ) 

#define IWSParameters_GetByteArray(This,ulOrdinal,psaValue)	\
    ( (This)->lpVtbl -> GetByteArray(This,ulOrdinal,psaValue) ) 

#define IWSParameters_IsDBNull(This,ulOrdinal,bIsNull)	\
    ( (This)->lpVtbl -> IsDBNull(This,ulOrdinal,bIsNull) ) 

#define IWSParameters_get_CmdInfo(This,ppbyCmdInfo)	\
    ( (This)->lpVtbl -> get_CmdInfo(This,ppbyCmdInfo) ) 

#define IWSParameters_CleanUp(This)	\
    ( (This)->lpVtbl -> CleanUp(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSParameters_INTERFACE_DEFINED__ */


#ifndef __IWSSession_INTERFACE_DEFINED__
#define __IWSSession_INTERFACE_DEFINED__

/* interface IWSSession */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IWSSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4742e047-c949-4b75-8b3c-de1703986ec7")
    IWSSession : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteNonQuery( 
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BeginTransaction( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RollbackTransaction( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CommitTransaction( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteReturnRowset( 
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWSSession * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWSSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWSSession * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWSSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IWSSession * This,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteNonQuery )( 
            IWSSession * This,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IWSSession * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RollbackTransaction )( 
            IWSSession * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CommitTransaction )( 
            IWSSession * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteReturnRowset )( 
            IWSSession * This,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset);
        
        END_INTERFACE
    } IWSSessionVtbl;

    interface IWSSession
    {
        CONST_VTBL struct IWSSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSSession_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWSSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWSSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWSSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWSSession_Execute(This,bstrCmd,pParameters,ppiResultset)	\
    ( (This)->lpVtbl -> Execute(This,bstrCmd,pParameters,ppiResultset) ) 

#define IWSSession_ExecuteNonQuery(This,bstrCmd,pParameters)	\
    ( (This)->lpVtbl -> ExecuteNonQuery(This,bstrCmd,pParameters) ) 

#define IWSSession_BeginTransaction(This)	\
    ( (This)->lpVtbl -> BeginTransaction(This) ) 

#define IWSSession_RollbackTransaction(This)	\
    ( (This)->lpVtbl -> RollbackTransaction(This) ) 

#define IWSSession_CommitTransaction(This)	\
    ( (This)->lpVtbl -> CommitTransaction(This) ) 

#define IWSSession_ExecuteReturnRowset(This,bstrCmd,pParameters,ppiResultset)	\
    ( (This)->lpVtbl -> ExecuteReturnRowset(This,bstrCmd,pParameters,ppiResultset) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSSession_INTERFACE_DEFINED__ */


#ifndef __IWSDataReader_INTERFACE_DEFINED__
#define __IWSDataReader_INTERFACE_DEFINED__

/* interface IWSDataReader */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWSDataReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FCE9E4B-5626-4A60-BAD4-4D690CD542DC")
    IWSDataReader : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ BSTR bstrAppName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteNonQuery( 
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSession( 
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [retval][out] */ IWSSession **ppiSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionFromInt32( 
            /* [in] */ LONG lValue,
            /* [retval][out] */ LONG *lPartition) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionFromInt64( 
            /* [in] */ LONGLONG qwValue,
            /* [retval][out] */ LONG *lPartition) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPartitionFromString( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ LONG *lPartition) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PartitionCount( 
            /* [retval][out] */ LONG *plValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeInitialize( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExecuteReturnRowset( 
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeEx( 
            /* [in] */ BSTR bstrAppName,
            /* [in] */ BOOL fSequentialAccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPartitionMode( 
            /* [in] */ WSREADER_PARTITION_MODE mode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPhysicalFromLogical( 
            /* [in] */ LONG lLogical,
            /* [out] */ LONG *plPhysical) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LogicalPartitionCount( 
            /* [retval][out] */ LONG *plValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhysicalPartitionCount( 
            /* [retval][out] */ LONG *plValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWSDataReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWSDataReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWSDataReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWSDataReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWSDataReader * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWSDataReader * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWSDataReader * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWSDataReader * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IWSDataReader * This,
            /* [in] */ BSTR bstrAppName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IWSDataReader * This,
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteNonQuery )( 
            IWSDataReader * This,
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IWSDataReader * This,
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [retval][out] */ IWSSession **ppiSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFromInt32 )( 
            IWSDataReader * This,
            /* [in] */ LONG lValue,
            /* [retval][out] */ LONG *lPartition);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFromInt64 )( 
            IWSDataReader * This,
            /* [in] */ LONGLONG qwValue,
            /* [retval][out] */ LONG *lPartition);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPartitionFromString )( 
            IWSDataReader * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ LONG *lPartition);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PartitionCount )( 
            IWSDataReader * This,
            /* [retval][out] */ LONG *plValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeInitialize )( 
            IWSDataReader * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ExecuteReturnRowset )( 
            IWSDataReader * This,
            /* [in] */ LONG cmdType,
            /* [in] */ LONG lHash,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ IWSParameters *pParameters,
            /* [retval][out] */ IWSResultset **ppiResultset);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InitializeEx )( 
            IWSDataReader * This,
            /* [in] */ BSTR bstrAppName,
            /* [in] */ BOOL fSequentialAccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetPartitionMode )( 
            IWSDataReader * This,
            /* [in] */ WSREADER_PARTITION_MODE mode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPhysicalFromLogical )( 
            IWSDataReader * This,
            /* [in] */ LONG lLogical,
            /* [out] */ LONG *plPhysical);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogicalPartitionCount )( 
            IWSDataReader * This,
            /* [retval][out] */ LONG *plValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PhysicalPartitionCount )( 
            IWSDataReader * This,
            /* [retval][out] */ LONG *plValue);
        
        END_INTERFACE
    } IWSDataReaderVtbl;

    interface IWSDataReader
    {
        CONST_VTBL struct IWSDataReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWSDataReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWSDataReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWSDataReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWSDataReader_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWSDataReader_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWSDataReader_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWSDataReader_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWSDataReader_Initialize(This,bstrAppName)	\
    ( (This)->lpVtbl -> Initialize(This,bstrAppName) ) 

#define IWSDataReader_Execute(This,cmdType,lHash,bstrCmd,pParameters,ppiResultset)	\
    ( (This)->lpVtbl -> Execute(This,cmdType,lHash,bstrCmd,pParameters,ppiResultset) ) 

#define IWSDataReader_ExecuteNonQuery(This,cmdType,lHash,bstrCmd,pParameters)	\
    ( (This)->lpVtbl -> ExecuteNonQuery(This,cmdType,lHash,bstrCmd,pParameters) ) 

#define IWSDataReader_GetSession(This,cmdType,lHash,ppiSession)	\
    ( (This)->lpVtbl -> GetSession(This,cmdType,lHash,ppiSession) ) 

#define IWSDataReader_GetPartitionFromInt32(This,lValue,lPartition)	\
    ( (This)->lpVtbl -> GetPartitionFromInt32(This,lValue,lPartition) ) 

#define IWSDataReader_GetPartitionFromInt64(This,qwValue,lPartition)	\
    ( (This)->lpVtbl -> GetPartitionFromInt64(This,qwValue,lPartition) ) 

#define IWSDataReader_GetPartitionFromString(This,bstrValue,lPartition)	\
    ( (This)->lpVtbl -> GetPartitionFromString(This,bstrValue,lPartition) ) 

#define IWSDataReader_get_PartitionCount(This,plValue)	\
    ( (This)->lpVtbl -> get_PartitionCount(This,plValue) ) 

#define IWSDataReader_DeInitialize(This)	\
    ( (This)->lpVtbl -> DeInitialize(This) ) 

#define IWSDataReader_ExecuteReturnRowset(This,cmdType,lHash,bstrCmd,pParameters,ppiResultset)	\
    ( (This)->lpVtbl -> ExecuteReturnRowset(This,cmdType,lHash,bstrCmd,pParameters,ppiResultset) ) 

#define IWSDataReader_InitializeEx(This,bstrAppName,fSequentialAccess)	\
    ( (This)->lpVtbl -> InitializeEx(This,bstrAppName,fSequentialAccess) ) 

#define IWSDataReader_SetPartitionMode(This,mode)	\
    ( (This)->lpVtbl -> SetPartitionMode(This,mode) ) 

#define IWSDataReader_GetPhysicalFromLogical(This,lLogical,plPhysical)	\
    ( (This)->lpVtbl -> GetPhysicalFromLogical(This,lLogical,plPhysical) ) 

#define IWSDataReader_get_LogicalPartitionCount(This,plValue)	\
    ( (This)->lpVtbl -> get_LogicalPartitionCount(This,plValue) ) 

#define IWSDataReader_get_PhysicalPartitionCount(This,plValue)	\
    ( (This)->lpVtbl -> get_PhysicalPartitionCount(This,plValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWSDataReader_INTERFACE_DEFINED__ */



#ifndef __WSREADERLib_LIBRARY_DEFINED__
#define __WSREADERLib_LIBRARY_DEFINED__

/* library WSREADERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WSREADERLib;

EXTERN_C const CLSID CLSID_WSDataReader;

#ifdef __cplusplus

class DECLSPEC_UUID("4C05B710-2756-4B5F-BDCD-7AF353779480")
WSDataReader;
#endif

EXTERN_C const CLSID CLSID_WSSession;

#ifdef __cplusplus

class DECLSPEC_UUID("f7aab024-fa4a-4563-9be0-2afe86218969")
WSSession;
#endif

EXTERN_C const CLSID CLSID_WSResultset;

#ifdef __cplusplus

class DECLSPEC_UUID("5A400301-0B11-42DC-A942-CAB57396966B")
WSResultset;
#endif

EXTERN_C const CLSID CLSID_WSParameters;

#ifdef __cplusplus

class DECLSPEC_UUID("98CF8B00-2EB5-4221-A599-3B4C156F8041")
WSParameters;
#endif
#endif /* __WSREADERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\objd\i386\wsreader_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for wsreader.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "wsreader.h"

#define TYPE_FORMAT_STRING_SIZE   1337                              
#define PROC_FORMAT_STRING_SIZE   2029                              
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _wsreader_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } wsreader_MIDL_TYPE_FORMAT_STRING;

typedef struct _wsreader_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } wsreader_MIDL_PROC_FORMAT_STRING;

typedef struct _wsreader_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } wsreader_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const wsreader_MIDL_TYPE_FORMAT_STRING wsreader__MIDL_TypeFormatString;
extern const wsreader_MIDL_PROC_FORMAT_STRING wsreader__MIDL_ProcFormatString;
extern const wsreader_MIDL_EXPR_FORMAT_STRING wsreader__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IWSResultset_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IWSResultset_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IWSParameters_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IWSParameters_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IWSSession_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IWSSession_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IWSDataReader_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IWSDataReader_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const wsreader_MIDL_PROC_FORMAT_STRING wsreader__MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Read */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x22 ),	/* 34 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 16 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbResults */

/* 24 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NextResult */

/* 36 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
/* 44 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x22 ),	/* 34 */
/* 50 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 52 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbResults */

/* 60 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 64 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetByte */

/* 72 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0x9 ),	/* 9 */
/* 80 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 82 */	NdrFcShort( 0x8 ),	/* 8 */
/* 84 */	NdrFcShort( 0x21 ),	/* 33 */
/* 86 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 88 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 96 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 98 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbiVal */

/* 102 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 106 */	0x1,		/* FC_BYTE */
			0x0,		/* 0 */

	/* Return value */

/* 108 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 110 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 112 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInt16 */

/* 114 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 116 */	NdrFcLong( 0x0 ),	/* 0 */
/* 120 */	NdrFcShort( 0xa ),	/* 10 */
/* 122 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	NdrFcShort( 0x22 ),	/* 34 */
/* 128 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 130 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 138 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 140 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psiVal */

/* 144 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 146 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 148 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 150 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 152 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPartitionFromInt32 */


	/* Procedure GetInt32 */

/* 156 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 158 */	NdrFcLong( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0xb ),	/* 11 */
/* 164 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 166 */	NdrFcShort( 0x8 ),	/* 8 */
/* 168 */	NdrFcShort( 0x24 ),	/* 36 */
/* 170 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 172 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 178 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lValue */


	/* Parameter ulOrdinal */

/* 180 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 182 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lPartition */


	/* Parameter plValue */

/* 186 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 188 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 190 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 194 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFloat */

/* 198 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 200 */	NdrFcLong( 0x0 ),	/* 0 */
/* 204 */	NdrFcShort( 0xc ),	/* 12 */
/* 206 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	NdrFcShort( 0x24 ),	/* 36 */
/* 212 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 214 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 216 */	NdrFcShort( 0x0 ),	/* 0 */
/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 222 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 224 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pfltValue */

/* 228 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 230 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 232 */	0xa,		/* FC_FLOAT */
			0x0,		/* 0 */

	/* Return value */

/* 234 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 236 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 238 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInt64 */

/* 240 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 242 */	NdrFcLong( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0xd ),	/* 13 */
/* 248 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 250 */	NdrFcShort( 0x8 ),	/* 8 */
/* 252 */	NdrFcShort( 0x2c ),	/* 44 */
/* 254 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 256 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 264 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 266 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 268 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pqwValue */

/* 270 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 272 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 274 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 276 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 278 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetString */

/* 282 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 284 */	NdrFcLong( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0xe ),	/* 14 */
/* 290 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 296 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 298 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 300 */	NdrFcShort( 0x1 ),	/* 1 */
/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 306 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 308 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrValue */

/* 312 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 314 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 316 */	NdrFcShort( 0x3e ),	/* Type Offset=62 */

	/* Return value */

/* 318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDate */

/* 324 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 326 */	NdrFcLong( 0x0 ),	/* 0 */
/* 330 */	NdrFcShort( 0xf ),	/* 15 */
/* 332 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 334 */	NdrFcShort( 0x8 ),	/* 8 */
/* 336 */	NdrFcShort( 0x2c ),	/* 44 */
/* 338 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 340 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 350 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdtValue */

/* 354 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 356 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 358 */	0xc,		/* FC_DOUBLE */
			0x0,		/* 0 */

	/* Return value */

/* 360 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 362 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetByteArray */

/* 366 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 368 */	NdrFcLong( 0x0 ),	/* 0 */
/* 372 */	NdrFcShort( 0x10 ),	/* 16 */
/* 374 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 376 */	NdrFcShort( 0x8 ),	/* 8 */
/* 378 */	NdrFcShort( 0x8 ),	/* 8 */
/* 380 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 382 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 384 */	NdrFcShort( 0x1f ),	/* 31 */
/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 390 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 392 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpbValue */

/* 396 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 398 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 400 */	NdrFcShort( 0x4cc ),	/* Type Offset=1228 */

	/* Return value */

/* 402 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 404 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 406 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsDBNull */

/* 408 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 410 */	NdrFcLong( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x11 ),	/* 17 */
/* 416 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 418 */	NdrFcShort( 0x8 ),	/* 8 */
/* 420 */	NdrFcShort( 0x22 ),	/* 34 */
/* 422 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 424 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 426 */	NdrFcShort( 0x0 ),	/* 0 */
/* 428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 430 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 432 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 434 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 436 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbIsNull */

/* 438 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 440 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 442 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 446 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOrdinal */

/* 450 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x12 ),	/* 18 */
/* 458 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 462 */	NdrFcShort( 0x24 ),	/* 36 */
/* 464 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 466 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 470 */	NdrFcShort( 0x1 ),	/* 1 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrColumnName */

/* 474 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 476 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 478 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pulOrdinal */

/* 480 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 482 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 486 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 488 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddByte */

/* 492 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 494 */	NdrFcLong( 0x0 ),	/* 0 */
/* 498 */	NdrFcShort( 0x7 ),	/* 7 */
/* 500 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 502 */	NdrFcShort( 0xd ),	/* 13 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 508 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 516 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 518 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 520 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bValue */

/* 522 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 524 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 526 */	0x1,		/* FC_BYTE */
			0x0,		/* 0 */

	/* Return value */

/* 528 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 530 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 532 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddInt16 */

/* 534 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 536 */	NdrFcLong( 0x0 ),	/* 0 */
/* 540 */	NdrFcShort( 0x8 ),	/* 8 */
/* 542 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 544 */	NdrFcShort( 0xe ),	/* 14 */
/* 546 */	NdrFcShort( 0x8 ),	/* 8 */
/* 548 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 550 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 552 */	NdrFcShort( 0x0 ),	/* 0 */
/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
/* 556 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 558 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 560 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter siValue */

/* 564 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 566 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 568 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 570 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 572 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddInt32 */

/* 576 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 578 */	NdrFcLong( 0x0 ),	/* 0 */
/* 582 */	NdrFcShort( 0x9 ),	/* 9 */
/* 584 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 586 */	NdrFcShort( 0x10 ),	/* 16 */
/* 588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 590 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 592 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 598 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 600 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 602 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 604 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lValue */

/* 606 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 608 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 610 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 612 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 614 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 616 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddInt64 */

/* 618 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 620 */	NdrFcLong( 0x0 ),	/* 0 */
/* 624 */	NdrFcShort( 0xa ),	/* 10 */
/* 626 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 628 */	NdrFcShort( 0x18 ),	/* 24 */
/* 630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 632 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 634 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 636 */	NdrFcShort( 0x0 ),	/* 0 */
/* 638 */	NdrFcShort( 0x0 ),	/* 0 */
/* 640 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 642 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 644 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter qwValue */

/* 648 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 650 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 652 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 654 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 656 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 658 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddDate */

/* 660 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 662 */	NdrFcLong( 0x0 ),	/* 0 */
/* 666 */	NdrFcShort( 0xb ),	/* 11 */
/* 668 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 670 */	NdrFcShort( 0x18 ),	/* 24 */
/* 672 */	NdrFcShort( 0x8 ),	/* 8 */
/* 674 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 676 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 678 */	NdrFcShort( 0x0 ),	/* 0 */
/* 680 */	NdrFcShort( 0x0 ),	/* 0 */
/* 682 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 684 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 686 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 688 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dtValue */

/* 690 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 692 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 694 */	0xc,		/* FC_DOUBLE */
			0x0,		/* 0 */

	/* Return value */

/* 696 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 698 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 700 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddString */

/* 702 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 704 */	NdrFcLong( 0x0 ),	/* 0 */
/* 708 */	NdrFcShort( 0xc ),	/* 12 */
/* 710 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 712 */	NdrFcShort( 0x10 ),	/* 16 */
/* 714 */	NdrFcShort( 0x8 ),	/* 8 */
/* 716 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 718 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x6 ),	/* 6 */
/* 724 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 726 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 728 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bstrValue */

/* 732 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 734 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 736 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter ulMaxLen */

/* 738 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 740 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 742 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 744 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 746 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 748 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddByteArray */

/* 750 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 752 */	NdrFcLong( 0x0 ),	/* 0 */
/* 756 */	NdrFcShort( 0xd ),	/* 13 */
/* 758 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 760 */	NdrFcShort( 0x10 ),	/* 16 */
/* 762 */	NdrFcShort( 0x8 ),	/* 8 */
/* 764 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 766 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 768 */	NdrFcShort( 0x0 ),	/* 0 */
/* 770 */	NdrFcShort( 0x24 ),	/* 36 */
/* 772 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lDirection */

/* 774 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 776 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 778 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psaValue */

/* 780 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 782 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 784 */	NdrFcShort( 0x4ec ),	/* Type Offset=1260 */

	/* Parameter ulMaxLen */

/* 786 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 788 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 790 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 792 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 794 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetByte */

/* 798 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 800 */	NdrFcLong( 0x0 ),	/* 0 */
/* 804 */	NdrFcShort( 0xe ),	/* 14 */
/* 806 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 808 */	NdrFcShort( 0x8 ),	/* 8 */
/* 810 */	NdrFcShort( 0x21 ),	/* 33 */
/* 812 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 814 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 818 */	NdrFcShort( 0x0 ),	/* 0 */
/* 820 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 822 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 824 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 826 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbValue */

/* 828 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 830 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 832 */	0x1,		/* FC_BYTE */
			0x0,		/* 0 */

	/* Return value */

/* 834 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 836 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 838 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInt16 */

/* 840 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 842 */	NdrFcLong( 0x0 ),	/* 0 */
/* 846 */	NdrFcShort( 0xf ),	/* 15 */
/* 848 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 850 */	NdrFcShort( 0x8 ),	/* 8 */
/* 852 */	NdrFcShort( 0x22 ),	/* 34 */
/* 854 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 856 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 862 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 864 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 866 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psiValue */

/* 870 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 872 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 874 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 876 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 878 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 880 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInt32 */

/* 882 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 884 */	NdrFcLong( 0x0 ),	/* 0 */
/* 888 */	NdrFcShort( 0x10 ),	/* 16 */
/* 890 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 894 */	NdrFcShort( 0x24 ),	/* 36 */
/* 896 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 898 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 900 */	NdrFcShort( 0x0 ),	/* 0 */
/* 902 */	NdrFcShort( 0x0 ),	/* 0 */
/* 904 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 906 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 908 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 910 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter plValue */

/* 912 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 914 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 920 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInt64 */

/* 924 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 926 */	NdrFcLong( 0x0 ),	/* 0 */
/* 930 */	NdrFcShort( 0x11 ),	/* 17 */
/* 932 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 934 */	NdrFcShort( 0x8 ),	/* 8 */
/* 936 */	NdrFcShort( 0x2c ),	/* 44 */
/* 938 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 940 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 942 */	NdrFcShort( 0x0 ),	/* 0 */
/* 944 */	NdrFcShort( 0x0 ),	/* 0 */
/* 946 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 948 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 950 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 952 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pqwValue */

/* 954 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 956 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 958 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 960 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 962 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 964 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDate */

/* 966 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 968 */	NdrFcLong( 0x0 ),	/* 0 */
/* 972 */	NdrFcShort( 0x12 ),	/* 18 */
/* 974 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 976 */	NdrFcShort( 0x8 ),	/* 8 */
/* 978 */	NdrFcShort( 0x2c ),	/* 44 */
/* 980 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 982 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0x0 ),	/* 0 */
/* 988 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 990 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 992 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 994 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdtValue */

/* 996 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 998 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1000 */	0xc,		/* FC_DOUBLE */
			0x0,		/* 0 */

	/* Return value */

/* 1002 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1004 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1006 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetString */

/* 1008 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1010 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1014 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1016 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1018 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1020 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1022 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1024 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 1026 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1028 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1030 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 1032 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1034 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1036 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrValue */

/* 1038 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1040 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1042 */	NdrFcShort( 0x3e ),	/* Type Offset=62 */

	/* Return value */

/* 1044 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1046 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1048 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetByteArray */

/* 1050 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1052 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1056 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1058 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1060 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1062 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1064 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1066 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 1068 */	NdrFcShort( 0x29 ),	/* 41 */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 1074 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1076 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1078 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psaValue */

/* 1080 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1082 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1084 */	NdrFcShort( 0x4cc ),	/* Type Offset=1228 */

	/* Return value */

/* 1086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1088 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsDBNull */

/* 1092 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1098 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1100 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1104 */	NdrFcShort( 0x22 ),	/* 34 */
/* 1106 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 1108 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1114 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulOrdinal */

/* 1116 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1118 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1120 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bIsNull */

/* 1122 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1124 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1126 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 1128 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1130 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_CmdInfo */

/* 1134 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1136 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1140 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1142 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1146 */	NdrFcShort( 0x35 ),	/* 53 */
/* 1148 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1150 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1154 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1156 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppbyCmdInfo */

/* 1158 */	NdrFcShort( 0x2012 ),	/* Flags:  must free, out, srv alloc size=8 */
/* 1160 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1162 */	NdrFcShort( 0x4f6 ),	/* Type Offset=1270 */

	/* Return value */

/* 1164 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1166 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1168 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CleanUp */

/* 1170 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1172 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1176 */	NdrFcShort( 0x17 ),	/* 23 */
/* 1178 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1180 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1182 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1184 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1186 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1192 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1194 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1196 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Execute */

/* 1200 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1202 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1206 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1208 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1212 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1214 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1216 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1220 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1222 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrCmd */

/* 1224 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1226 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1228 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1230 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1232 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1234 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Parameter ppiResultset */

/* 1236 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1238 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1240 */	NdrFcShort( 0x50c ),	/* Type Offset=1292 */

	/* Return value */

/* 1242 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1244 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExecuteNonQuery */

/* 1248 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1250 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1254 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1256 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1262 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1264 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1268 */	NdrFcShort( 0xa ),	/* 10 */
/* 1270 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrCmd */

/* 1272 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1274 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1276 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1278 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1280 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1282 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Return value */

/* 1284 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1286 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1288 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BeginTransaction */

/* 1290 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1292 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1296 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1298 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1304 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1306 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1312 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1314 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1316 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1318 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RollbackTransaction */

/* 1320 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1322 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1326 */	NdrFcShort( 0xa ),	/* 10 */
/* 1328 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1332 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1334 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1336 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1340 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1342 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1344 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1346 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1348 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CommitTransaction */

/* 1350 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1352 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1356 */	NdrFcShort( 0xb ),	/* 11 */
/* 1358 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1360 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1362 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1364 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1366 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1368 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1372 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1374 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1376 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExecuteReturnRowset */

/* 1380 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1382 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1386 */	NdrFcShort( 0xc ),	/* 12 */
/* 1388 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1392 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1394 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1396 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1400 */	NdrFcShort( 0xa ),	/* 10 */
/* 1402 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrCmd */

/* 1404 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1406 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1408 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1410 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1412 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1414 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Parameter ppiResultset */

/* 1416 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1418 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1420 */	NdrFcShort( 0x50c ),	/* Type Offset=1292 */

	/* Return value */

/* 1422 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1424 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Initialize */

/* 1428 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1430 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1434 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1436 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1440 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1442 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 1444 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1446 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1448 */	NdrFcShort( 0xa ),	/* 10 */
/* 1450 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrAppName */

/* 1452 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1454 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1456 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Return value */

/* 1458 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1460 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1462 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Execute */

/* 1464 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1466 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1472 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1474 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1476 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1478 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1480 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1484 */	NdrFcShort( 0xa ),	/* 10 */
/* 1486 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cmdType */

/* 1488 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1490 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1492 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lHash */

/* 1494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1496 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bstrCmd */

/* 1500 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1502 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1504 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1506 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1508 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1510 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Parameter ppiResultset */

/* 1512 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1514 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1516 */	NdrFcShort( 0x50c ),	/* Type Offset=1292 */

	/* Return value */

/* 1518 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1520 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1522 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExecuteNonQuery */

/* 1524 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1526 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1530 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1532 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1534 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1536 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1538 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1540 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1542 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1544 */	NdrFcShort( 0xa ),	/* 10 */
/* 1546 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cmdType */

/* 1548 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1550 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1552 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lHash */

/* 1554 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1556 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bstrCmd */

/* 1560 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1562 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1564 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1566 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1568 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1570 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Return value */

/* 1572 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1574 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1576 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSession */

/* 1578 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1580 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1584 */	NdrFcShort( 0xa ),	/* 10 */
/* 1586 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1588 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1590 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1592 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 1594 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1598 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1600 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cmdType */

/* 1602 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1604 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1606 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lHash */

/* 1608 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1610 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppiSession */

/* 1614 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1616 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1618 */	NdrFcShort( 0x522 ),	/* Type Offset=1314 */

	/* Return value */

/* 1620 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1622 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1624 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPartitionFromInt64 */

/* 1626 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1628 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1632 */	NdrFcShort( 0xc ),	/* 12 */
/* 1634 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1636 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1638 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1640 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 1642 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1648 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter qwValue */

/* 1650 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1652 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1654 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter lPartition */

/* 1656 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1658 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1660 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1662 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1664 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPartitionFromString */

/* 1668 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1670 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1674 */	NdrFcShort( 0xd ),	/* 13 */
/* 1676 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1678 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1680 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1682 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1684 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1688 */	NdrFcShort( 0xa ),	/* 10 */
/* 1690 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrValue */

/* 1692 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1694 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1696 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter lPartition */

/* 1698 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1700 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1702 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1704 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1706 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1708 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_PartitionCount */

/* 1710 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1712 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1716 */	NdrFcShort( 0xe ),	/* 14 */
/* 1718 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1722 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1724 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1726 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1732 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plValue */

/* 1734 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1736 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1738 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1740 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1742 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1744 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DeInitialize */

/* 1746 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1748 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1752 */	NdrFcShort( 0xf ),	/* 15 */
/* 1754 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1758 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1760 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 1762 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1764 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1768 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 1770 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1772 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1774 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ExecuteReturnRowset */

/* 1776 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1778 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1782 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1784 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1786 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1788 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1790 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1792 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1796 */	NdrFcShort( 0xa ),	/* 10 */
/* 1798 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cmdType */

/* 1800 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1802 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1804 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lHash */

/* 1806 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1808 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bstrCmd */

/* 1812 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1814 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1816 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter pParameters */

/* 1818 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1820 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1822 */	NdrFcShort( 0x4fa ),	/* Type Offset=1274 */

	/* Parameter ppiResultset */

/* 1824 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1826 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1828 */	NdrFcShort( 0x50c ),	/* Type Offset=1292 */

	/* Return value */

/* 1830 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1832 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1834 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure InitializeEx */

/* 1836 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1838 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1842 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1844 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1846 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1848 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1850 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1852 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 1854 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1856 */	NdrFcShort( 0xa ),	/* 10 */
/* 1858 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrAppName */

/* 1860 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1862 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1864 */	NdrFcShort( 0x4da ),	/* Type Offset=1242 */

	/* Parameter fSequentialAccess */

/* 1866 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1868 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1872 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1874 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1876 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetPartitionMode */

/* 1878 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1880 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1884 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1886 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1888 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1890 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1892 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1894 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1896 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1898 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1900 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter mode */

/* 1902 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1904 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1906 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 1908 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1910 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1912 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPhysicalFromLogical */

/* 1914 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1916 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1920 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1922 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1924 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1926 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1928 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x3,		/* 3 */
/* 1930 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1934 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1936 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter lLogical */

/* 1938 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1940 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1942 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter plPhysical */

/* 1944 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1946 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1948 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1950 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1952 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1954 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_LogicalPartitionCount */

/* 1956 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1958 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1962 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1964 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1966 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1968 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1970 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 1972 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 1974 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1976 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1978 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plValue */

/* 1980 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1982 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1984 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1986 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1988 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1990 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure get_PhysicalPartitionCount */

/* 1992 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1994 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1998 */	NdrFcShort( 0x15 ),	/* 21 */
/* 2000 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2004 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2006 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 2008 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 2010 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2014 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter plValue */

/* 2016 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2018 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2022 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2024 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2026 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const wsreader_MIDL_TYPE_FORMAT_STRING wsreader__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/*  4 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/*  8 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 10 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 12 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 14 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 16 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 18 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 20 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 22 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 24 */	NdrFcShort( 0x26 ),	/* Offset= 38 (62) */
/* 26 */	
			0x13, 0x0,	/* FC_OP */
/* 28 */	NdrFcShort( 0x18 ),	/* Offset= 24 (52) */
/* 30 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 32 */	NdrFcShort( 0x2 ),	/* 2 */
/* 34 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 36 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 38 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 40 */	0x0 , 
			0x0,		/* 0 */
/* 42 */	NdrFcLong( 0x0 ),	/* 0 */
/* 46 */	NdrFcLong( 0x0 ),	/* 0 */
/* 50 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 52 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (30) */
/* 58 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 60 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 62 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */
/* 66 */	NdrFcShort( 0x4 ),	/* 4 */
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
/* 70 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (26) */
/* 72 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 74 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 76 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 78 */	NdrFcShort( 0x47e ),	/* Offset= 1150 (1228) */
/* 80 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 82 */	NdrFcShort( 0x2 ),	/* Offset= 2 (84) */
/* 84 */	
			0x13, 0x0,	/* FC_OP */
/* 86 */	NdrFcShort( 0x464 ),	/* Offset= 1124 (1210) */
/* 88 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 90 */	NdrFcShort( 0x18 ),	/* 24 */
/* 92 */	NdrFcShort( 0xa ),	/* 10 */
/* 94 */	NdrFcLong( 0x8 ),	/* 8 */
/* 98 */	NdrFcShort( 0x64 ),	/* Offset= 100 (198) */
/* 100 */	NdrFcLong( 0xd ),	/* 13 */
/* 104 */	NdrFcShort( 0xae ),	/* Offset= 174 (278) */
/* 106 */	NdrFcLong( 0x9 ),	/* 9 */
/* 110 */	NdrFcShort( 0xf4 ),	/* Offset= 244 (354) */
/* 112 */	NdrFcLong( 0xc ),	/* 12 */
/* 116 */	NdrFcShort( 0x30c ),	/* Offset= 780 (896) */
/* 118 */	NdrFcLong( 0x24 ),	/* 36 */
/* 122 */	NdrFcShort( 0x340 ),	/* Offset= 832 (954) */
/* 124 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 128 */	NdrFcShort( 0x35c ),	/* Offset= 860 (988) */
/* 130 */	NdrFcLong( 0x10 ),	/* 16 */
/* 134 */	NdrFcShort( 0x380 ),	/* Offset= 896 (1030) */
/* 136 */	NdrFcLong( 0x2 ),	/* 2 */
/* 140 */	NdrFcShort( 0x3a4 ),	/* Offset= 932 (1072) */
/* 142 */	NdrFcLong( 0x3 ),	/* 3 */
/* 146 */	NdrFcShort( 0x3c8 ),	/* Offset= 968 (1114) */
/* 148 */	NdrFcLong( 0x14 ),	/* 20 */
/* 152 */	NdrFcShort( 0x3ec ),	/* Offset= 1004 (1156) */
/* 154 */	NdrFcShort( 0xffff ),	/* Offset= -1 (153) */
/* 156 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 158 */	NdrFcShort( 0x4 ),	/* 4 */
/* 160 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 166 */	0x0 , 
			0x0,		/* 0 */
/* 168 */	NdrFcLong( 0x0 ),	/* 0 */
/* 172 */	NdrFcLong( 0x0 ),	/* 0 */
/* 176 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 178 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 180 */	NdrFcShort( 0x4 ),	/* 4 */
/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
/* 184 */	NdrFcShort( 0x1 ),	/* 1 */
/* 186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	0x13, 0x0,	/* FC_OP */
/* 192 */	NdrFcShort( 0xff74 ),	/* Offset= -140 (52) */
/* 194 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 196 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 198 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 200 */	NdrFcShort( 0x8 ),	/* 8 */
/* 202 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 204 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 206 */	NdrFcShort( 0x4 ),	/* 4 */
/* 208 */	NdrFcShort( 0x4 ),	/* 4 */
/* 210 */	0x11, 0x0,	/* FC_RP */
/* 212 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (156) */
/* 214 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 216 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 218 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 220 */	NdrFcLong( 0x0 ),	/* 0 */
/* 224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 228 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 230 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 232 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 234 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 236 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 244 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 246 */	0x0 , 
			0x0,		/* 0 */
/* 248 */	NdrFcLong( 0x0 ),	/* 0 */
/* 252 */	NdrFcLong( 0x0 ),	/* 0 */
/* 256 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 260 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 262 */	0x0 , 
			0x0,		/* 0 */
/* 264 */	NdrFcLong( 0x0 ),	/* 0 */
/* 268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 272 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 274 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (218) */
/* 276 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 278 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 280 */	NdrFcShort( 0x8 ),	/* 8 */
/* 282 */	NdrFcShort( 0x0 ),	/* 0 */
/* 284 */	NdrFcShort( 0x6 ),	/* Offset= 6 (290) */
/* 286 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 288 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 290 */	
			0x11, 0x0,	/* FC_RP */
/* 292 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (236) */
/* 294 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 296 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
/* 304 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 306 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 308 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 310 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 312 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 316 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 318 */	NdrFcShort( 0x0 ),	/* 0 */
/* 320 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 322 */	0x0 , 
			0x0,		/* 0 */
/* 324 */	NdrFcLong( 0x0 ),	/* 0 */
/* 328 */	NdrFcLong( 0x0 ),	/* 0 */
/* 332 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 336 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 338 */	0x0 , 
			0x0,		/* 0 */
/* 340 */	NdrFcLong( 0x0 ),	/* 0 */
/* 344 */	NdrFcLong( 0x0 ),	/* 0 */
/* 348 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 350 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (294) */
/* 352 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 354 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 356 */	NdrFcShort( 0x8 ),	/* 8 */
/* 358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x6 ),	/* Offset= 6 (366) */
/* 362 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 364 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 366 */	
			0x11, 0x0,	/* FC_RP */
/* 368 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (312) */
/* 370 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 372 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 374 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 376 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 378 */	0x0 , 
			0x0,		/* 0 */
/* 380 */	NdrFcLong( 0x0 ),	/* 0 */
/* 384 */	NdrFcLong( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x2 ),	/* Offset= 2 (390) */
/* 390 */	NdrFcShort( 0x10 ),	/* 16 */
/* 392 */	NdrFcShort( 0x2f ),	/* 47 */
/* 394 */	NdrFcLong( 0x14 ),	/* 20 */
/* 398 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 400 */	NdrFcLong( 0x3 ),	/* 3 */
/* 404 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 406 */	NdrFcLong( 0x11 ),	/* 17 */
/* 410 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 412 */	NdrFcLong( 0x2 ),	/* 2 */
/* 416 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 418 */	NdrFcLong( 0x4 ),	/* 4 */
/* 422 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 424 */	NdrFcLong( 0x5 ),	/* 5 */
/* 428 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 430 */	NdrFcLong( 0xb ),	/* 11 */
/* 434 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 436 */	NdrFcLong( 0xa ),	/* 10 */
/* 440 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 442 */	NdrFcLong( 0x6 ),	/* 6 */
/* 446 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (678) */
/* 448 */	NdrFcLong( 0x7 ),	/* 7 */
/* 452 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 454 */	NdrFcLong( 0x8 ),	/* 8 */
/* 458 */	NdrFcShort( 0xfe50 ),	/* Offset= -432 (26) */
/* 460 */	NdrFcLong( 0xd ),	/* 13 */
/* 464 */	NdrFcShort( 0xff0a ),	/* Offset= -246 (218) */
/* 466 */	NdrFcLong( 0x9 ),	/* 9 */
/* 470 */	NdrFcShort( 0xff50 ),	/* Offset= -176 (294) */
/* 472 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 476 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (684) */
/* 478 */	NdrFcLong( 0x24 ),	/* 36 */
/* 482 */	NdrFcShort( 0xd2 ),	/* Offset= 210 (692) */
/* 484 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 488 */	NdrFcShort( 0xcc ),	/* Offset= 204 (692) */
/* 490 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 494 */	NdrFcShort( 0x106 ),	/* Offset= 262 (756) */
/* 496 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 500 */	NdrFcShort( 0x104 ),	/* Offset= 260 (760) */
/* 502 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 506 */	NdrFcShort( 0x102 ),	/* Offset= 258 (764) */
/* 508 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 512 */	NdrFcShort( 0x100 ),	/* Offset= 256 (768) */
/* 514 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 518 */	NdrFcShort( 0xfe ),	/* Offset= 254 (772) */
/* 520 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 524 */	NdrFcShort( 0xfc ),	/* Offset= 252 (776) */
/* 526 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 530 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (760) */
/* 532 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 536 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (764) */
/* 538 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 542 */	NdrFcShort( 0xee ),	/* Offset= 238 (780) */
/* 544 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 548 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (776) */
/* 550 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 554 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (784) */
/* 556 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 560 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (788) */
/* 562 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 566 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (792) */
/* 568 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 572 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (796) */
/* 574 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 578 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (808) */
/* 580 */	NdrFcLong( 0x10 ),	/* 16 */
/* 584 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 586 */	NdrFcLong( 0x12 ),	/* 18 */
/* 590 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 592 */	NdrFcLong( 0x13 ),	/* 19 */
/* 596 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 598 */	NdrFcLong( 0x15 ),	/* 21 */
/* 602 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 604 */	NdrFcLong( 0x16 ),	/* 22 */
/* 608 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 610 */	NdrFcLong( 0x17 ),	/* 23 */
/* 614 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 616 */	NdrFcLong( 0xe ),	/* 14 */
/* 620 */	NdrFcShort( 0xc4 ),	/* Offset= 196 (816) */
/* 622 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 626 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (826) */
/* 628 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 632 */	NdrFcShort( 0xc6 ),	/* Offset= 198 (830) */
/* 634 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 638 */	NdrFcShort( 0x7a ),	/* Offset= 122 (760) */
/* 640 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 644 */	NdrFcShort( 0x78 ),	/* Offset= 120 (764) */
/* 646 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 650 */	NdrFcShort( 0x76 ),	/* Offset= 118 (768) */
/* 652 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 656 */	NdrFcShort( 0x6c ),	/* Offset= 108 (764) */
/* 658 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 662 */	NdrFcShort( 0x66 ),	/* Offset= 102 (764) */
/* 664 */	NdrFcLong( 0x0 ),	/* 0 */
/* 668 */	NdrFcShort( 0x0 ),	/* Offset= 0 (668) */
/* 670 */	NdrFcLong( 0x1 ),	/* 1 */
/* 674 */	NdrFcShort( 0x0 ),	/* Offset= 0 (674) */
/* 676 */	NdrFcShort( 0xffff ),	/* Offset= -1 (675) */
/* 678 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 680 */	NdrFcShort( 0x8 ),	/* 8 */
/* 682 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 684 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 686 */	NdrFcShort( 0x2 ),	/* Offset= 2 (688) */
/* 688 */	
			0x13, 0x0,	/* FC_OP */
/* 690 */	NdrFcShort( 0x208 ),	/* Offset= 520 (1210) */
/* 692 */	
			0x13, 0x0,	/* FC_OP */
/* 694 */	NdrFcShort( 0x2a ),	/* Offset= 42 (736) */
/* 696 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 698 */	NdrFcLong( 0x2f ),	/* 47 */
/* 702 */	NdrFcShort( 0x0 ),	/* 0 */
/* 704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 706 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 708 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 710 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 712 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 714 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 716 */	NdrFcShort( 0x1 ),	/* 1 */
/* 718 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 720 */	NdrFcShort( 0x4 ),	/* 4 */
/* 722 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 724 */	0x0 , 
			0x0,		/* 0 */
/* 726 */	NdrFcLong( 0x0 ),	/* 0 */
/* 730 */	NdrFcLong( 0x0 ),	/* 0 */
/* 734 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 736 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 738 */	NdrFcShort( 0x10 ),	/* 16 */
/* 740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 742 */	NdrFcShort( 0xa ),	/* Offset= 10 (752) */
/* 744 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 746 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 748 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (696) */
/* 750 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 752 */	
			0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 754 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (714) */
/* 756 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 758 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 760 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 762 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 764 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 766 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 768 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 770 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 772 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 774 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 776 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 778 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 780 */	
			0x13, 0x0,	/* FC_OP */
/* 782 */	NdrFcShort( 0xff98 ),	/* Offset= -104 (678) */
/* 784 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 786 */	NdrFcShort( 0xfd08 ),	/* Offset= -760 (26) */
/* 788 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 790 */	NdrFcShort( 0xfdc4 ),	/* Offset= -572 (218) */
/* 792 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 794 */	NdrFcShort( 0xfe0c ),	/* Offset= -500 (294) */
/* 796 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 798 */	NdrFcShort( 0x2 ),	/* Offset= 2 (800) */
/* 800 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 802 */	NdrFcShort( 0x2 ),	/* Offset= 2 (804) */
/* 804 */	
			0x13, 0x0,	/* FC_OP */
/* 806 */	NdrFcShort( 0x194 ),	/* Offset= 404 (1210) */
/* 808 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 810 */	NdrFcShort( 0x2 ),	/* Offset= 2 (812) */
/* 812 */	
			0x13, 0x0,	/* FC_OP */
/* 814 */	NdrFcShort( 0x14 ),	/* Offset= 20 (834) */
/* 816 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 818 */	NdrFcShort( 0x10 ),	/* 16 */
/* 820 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 822 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 824 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 826 */	
			0x13, 0x0,	/* FC_OP */
/* 828 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (816) */
/* 830 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 832 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 834 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 836 */	NdrFcShort( 0x20 ),	/* 32 */
/* 838 */	NdrFcShort( 0x0 ),	/* 0 */
/* 840 */	NdrFcShort( 0x0 ),	/* Offset= 0 (840) */
/* 842 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 844 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 846 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 848 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 850 */	NdrFcShort( 0xfe20 ),	/* Offset= -480 (370) */
/* 852 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 854 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 856 */	NdrFcShort( 0x4 ),	/* 4 */
/* 858 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 862 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 864 */	0x0 , 
			0x0,		/* 0 */
/* 866 */	NdrFcLong( 0x0 ),	/* 0 */
/* 870 */	NdrFcLong( 0x0 ),	/* 0 */
/* 874 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 876 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 878 */	NdrFcShort( 0x4 ),	/* 4 */
/* 880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 882 */	NdrFcShort( 0x1 ),	/* 1 */
/* 884 */	NdrFcShort( 0x0 ),	/* 0 */
/* 886 */	NdrFcShort( 0x0 ),	/* 0 */
/* 888 */	0x13, 0x0,	/* FC_OP */
/* 890 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (834) */
/* 892 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 894 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 896 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 898 */	NdrFcShort( 0x8 ),	/* 8 */
/* 900 */	NdrFcShort( 0x0 ),	/* 0 */
/* 902 */	NdrFcShort( 0x6 ),	/* Offset= 6 (908) */
/* 904 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 906 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 908 */	
			0x11, 0x0,	/* FC_RP */
/* 910 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (854) */
/* 912 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 914 */	NdrFcShort( 0x4 ),	/* 4 */
/* 916 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 920 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 922 */	0x0 , 
			0x0,		/* 0 */
/* 924 */	NdrFcLong( 0x0 ),	/* 0 */
/* 928 */	NdrFcLong( 0x0 ),	/* 0 */
/* 932 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 934 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 936 */	NdrFcShort( 0x4 ),	/* 4 */
/* 938 */	NdrFcShort( 0x0 ),	/* 0 */
/* 940 */	NdrFcShort( 0x1 ),	/* 1 */
/* 942 */	NdrFcShort( 0x0 ),	/* 0 */
/* 944 */	NdrFcShort( 0x0 ),	/* 0 */
/* 946 */	0x13, 0x0,	/* FC_OP */
/* 948 */	NdrFcShort( 0xff2c ),	/* Offset= -212 (736) */
/* 950 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 952 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 954 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 956 */	NdrFcShort( 0x8 ),	/* 8 */
/* 958 */	NdrFcShort( 0x0 ),	/* 0 */
/* 960 */	NdrFcShort( 0x6 ),	/* Offset= 6 (966) */
/* 962 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 964 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 966 */	
			0x11, 0x0,	/* FC_RP */
/* 968 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (912) */
/* 970 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 972 */	NdrFcShort( 0x8 ),	/* 8 */
/* 974 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 976 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 978 */	NdrFcShort( 0x10 ),	/* 16 */
/* 980 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 982 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 984 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (970) */
			0x5b,		/* FC_END */
/* 988 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 990 */	NdrFcShort( 0x18 ),	/* 24 */
/* 992 */	NdrFcShort( 0x0 ),	/* 0 */
/* 994 */	NdrFcShort( 0xa ),	/* Offset= 10 (1004) */
/* 996 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 998 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1000 */	NdrFcShort( 0xffe8 ),	/* Offset= -24 (976) */
/* 1002 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1004 */	
			0x11, 0x0,	/* FC_RP */
/* 1006 */	NdrFcShort( 0xfcfe ),	/* Offset= -770 (236) */
/* 1008 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1010 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1012 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1014 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1016 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1018 */	0x0 , 
			0x0,		/* 0 */
/* 1020 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1028 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1030 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1032 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1034 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1036 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1038 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1040 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1042 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1044 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1008) */
/* 1046 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1048 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1050 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1052 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1054 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1056 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1058 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1060 */	0x0 , 
			0x0,		/* 0 */
/* 1062 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1066 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1070 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1072 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1074 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1076 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1078 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1080 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1082 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1084 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1086 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1050) */
/* 1088 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1090 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1092 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1094 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1096 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1098 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1100 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1102 */	0x0 , 
			0x0,		/* 0 */
/* 1104 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1112 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1114 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1118 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1120 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1122 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1124 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1126 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1128 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1092) */
/* 1130 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1132 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1134 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1136 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1138 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1142 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1144 */	0x0 , 
			0x0,		/* 0 */
/* 1146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1150 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1154 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1156 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1158 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1160 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1162 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1164 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1166 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1168 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1170 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1134) */
/* 1172 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1174 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1176 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1178 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1180 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1182 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1184 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1186 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1188 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1190 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 1192 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1194 */	0x0 , 
			0x0,		/* 0 */
/* 1196 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1200 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1204 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1206 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (1176) */
/* 1208 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1210 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1212 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1214 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (1184) */
/* 1216 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1216) */
/* 1218 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1220 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1222 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1224 */	NdrFcShort( 0xfb90 ),	/* Offset= -1136 (88) */
/* 1226 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1228 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1230 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1232 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1236 */	NdrFcShort( 0xfb7c ),	/* Offset= -1156 (80) */
/* 1238 */	
			0x12, 0x0,	/* FC_UP */
/* 1240 */	NdrFcShort( 0xfb5c ),	/* Offset= -1188 (52) */
/* 1242 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1246 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (1238) */
/* 1252 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1254 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1256) */
/* 1256 */	
			0x12, 0x0,	/* FC_UP */
/* 1258 */	NdrFcShort( 0xffd0 ),	/* Offset= -48 (1210) */
/* 1260 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1262 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1264 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1268 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (1252) */
/* 1270 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1272 */	NdrFcShort( 0xfdfc ),	/* Offset= -516 (756) */
/* 1274 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1276 */	NdrFcLong( 0xa3c38387 ),	/* -1547467897 */
/* 1280 */	NdrFcShort( 0x72df ),	/* 29407 */
/* 1282 */	NdrFcShort( 0x4359 ),	/* 17241 */
/* 1284 */	0x8b,		/* 139 */
			0xa8,		/* 168 */
/* 1286 */	0x41,		/* 65 */
			0x5b,		/* 91 */
/* 1288 */	0x5e,		/* 94 */
			0x98,		/* 152 */
/* 1290 */	0xa6,		/* 166 */
			0x7,		/* 7 */
/* 1292 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1294 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1296) */
/* 1296 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1298 */	NdrFcLong( 0x37dcce2 ),	/* 58576098 */
/* 1302 */	NdrFcShort( 0x9c0f ),	/* -25585 */
/* 1304 */	NdrFcShort( 0x4035 ),	/* 16437 */
/* 1306 */	0xaf,		/* 175 */
			0x4e,		/* 78 */
/* 1308 */	0x2,		/* 2 */
			0x88,		/* 136 */
/* 1310 */	0x4a,		/* 74 */
			0xb8,		/* 184 */
/* 1312 */	0xa0,		/* 160 */
			0x4a,		/* 74 */
/* 1314 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1316 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1318) */
/* 1318 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1320 */	NdrFcLong( 0x4742e047 ),	/* 1195565127 */
/* 1324 */	NdrFcShort( 0xc949 ),	/* -14007 */
/* 1326 */	NdrFcShort( 0x4b75 ),	/* 19317 */
/* 1328 */	0x8b,		/* 139 */
			0x3c,		/* 60 */
/* 1330 */	0xde,		/* 222 */
			0x17,		/* 23 */
/* 1332 */	0x3,		/* 3 */
			0x98,		/* 152 */
/* 1334 */	0x6e,		/* 110 */
			0xc7,		/* 199 */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            }

        };



/* Standard interface: __MIDL_itf_wsreader_0000_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IWSResultset, ver. 0.0,
   GUID={0x037DCCE2,0x9C0F,0x4035,{0xAF,0x4E,0x02,0x88,0x4A,0xB8,0xA0,0x4A}} */

#pragma code_seg(".orpc")
static const unsigned short IWSResultset_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    36,
    72,
    114,
    156,
    198,
    240,
    282,
    324,
    366,
    408,
    450
    };

static const MIDL_STUBLESS_PROXY_INFO IWSResultset_ProxyInfo =
    {
    &Object_StubDesc,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSResultset_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IWSResultset_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSResultset_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(19) _IWSResultsetProxyVtbl = 
{
    &IWSResultset_ProxyInfo,
    &IID_IWSResultset,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::Read */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::NextResult */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetByte */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetInt16 */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetInt32 */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetFloat */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetInt64 */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetString */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetDate */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetByteArray */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::IsDBNull */ ,
    (void *) (INT_PTR) -1 /* IWSResultset::GetOrdinal */
};


static const PRPC_STUB_FUNCTION IWSResultset_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IWSResultsetStubVtbl =
{
    &IID_IWSResultset,
    &IWSResultset_ServerInfo,
    19,
    &IWSResultset_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: IWSParameters, ver. 0.0,
   GUID={0xA3C38387,0x72DF,0x4359,{0x8B,0xA8,0x41,0x5B,0x5E,0x98,0xA6,0x07}} */

#pragma code_seg(".orpc")
static const unsigned short IWSParameters_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    492,
    534,
    576,
    618,
    660,
    702,
    750,
    798,
    840,
    882,
    924,
    966,
    1008,
    1050,
    1092,
    1134,
    1170
    };

static const MIDL_STUBLESS_PROXY_INFO IWSParameters_ProxyInfo =
    {
    &Object_StubDesc,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSParameters_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IWSParameters_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSParameters_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(24) _IWSParametersProxyVtbl = 
{
    &IWSParameters_ProxyInfo,
    &IID_IWSParameters,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddByte */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddInt16 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddInt32 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddInt64 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddDate */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddString */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::AddByteArray */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetByte */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetInt16 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetInt32 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetInt64 */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetDate */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetString */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::GetByteArray */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::IsDBNull */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::get_CmdInfo */ ,
    (void *) (INT_PTR) -1 /* IWSParameters::CleanUp */
};


static const PRPC_STUB_FUNCTION IWSParameters_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IWSParametersStubVtbl =
{
    &IID_IWSParameters,
    &IWSParameters_ServerInfo,
    24,
    &IWSParameters_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: IWSSession, ver. 0.0,
   GUID={0x4742e047,0xc949,0x4b75,{0x8b,0x3c,0xde,0x17,0x03,0x98,0x6e,0xc7}} */

#pragma code_seg(".orpc")
static const unsigned short IWSSession_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    1200,
    1248,
    1290,
    1320,
    1350,
    1380
    };

static const MIDL_STUBLESS_PROXY_INFO IWSSession_ProxyInfo =
    {
    &Object_StubDesc,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSSession_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IWSSession_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSSession_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _IWSSessionProxyVtbl = 
{
    &IWSSession_ProxyInfo,
    &IID_IWSSession,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IWSSession::Execute */ ,
    (void *) (INT_PTR) -1 /* IWSSession::ExecuteNonQuery */ ,
    (void *) (INT_PTR) -1 /* IWSSession::BeginTransaction */ ,
    (void *) (INT_PTR) -1 /* IWSSession::RollbackTransaction */ ,
    (void *) (INT_PTR) -1 /* IWSSession::CommitTransaction */ ,
    (void *) (INT_PTR) -1 /* IWSSession::ExecuteReturnRowset */
};


static const PRPC_STUB_FUNCTION IWSSession_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IWSSessionStubVtbl =
{
    &IID_IWSSession,
    &IWSSession_ServerInfo,
    13,
    &IWSSession_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: IWSDataReader, ver. 0.0,
   GUID={0x7FCE9E4B,0x5626,0x4A60,{0xBA,0xD4,0x4D,0x69,0x0C,0xD5,0x42,0xDC}} */

#pragma code_seg(".orpc")
static const unsigned short IWSDataReader_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    1428,
    1464,
    1524,
    1578,
    156,
    1626,
    1668,
    1710,
    1746,
    1776,
    1836,
    1878,
    1914,
    1956,
    1992
    };

static const MIDL_STUBLESS_PROXY_INFO IWSDataReader_ProxyInfo =
    {
    &Object_StubDesc,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSDataReader_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IWSDataReader_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    wsreader__MIDL_ProcFormatString.Format,
    &IWSDataReader_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(22) _IWSDataReaderProxyVtbl = 
{
    &IWSDataReader_ProxyInfo,
    &IID_IWSDataReader,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::Initialize */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::Execute */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::ExecuteNonQuery */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::GetSession */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::GetPartitionFromInt32 */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::GetPartitionFromInt64 */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::GetPartitionFromString */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::get_PartitionCount */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::DeInitialize */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::ExecuteReturnRowset */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::InitializeEx */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::SetPartitionMode */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::GetPhysicalFromLogical */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::get_LogicalPartitionCount */ ,
    (void *) (INT_PTR) -1 /* IWSDataReader::get_PhysicalPartitionCount */
};


static const PRPC_STUB_FUNCTION IWSDataReader_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IWSDataReaderStubVtbl =
{
    &IID_IWSDataReader,
    &IWSDataReader_ServerInfo,
    22,
    &IWSDataReader_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    wsreader__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x70001f4, /* MIDL Version 7.0.500 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * _wsreader_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IWSSessionProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IWSDataReaderProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IWSParametersProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IWSResultsetProxyVtbl,
    0
};

const CInterfaceStubVtbl * _wsreader_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IWSSessionStubVtbl,
    ( CInterfaceStubVtbl *) &_IWSDataReaderStubVtbl,
    ( CInterfaceStubVtbl *) &_IWSParametersStubVtbl,
    ( CInterfaceStubVtbl *) &_IWSResultsetStubVtbl,
    0
};

PCInterfaceName const _wsreader_InterfaceNamesList[] = 
{
    "IWSSession",
    "IWSDataReader",
    "IWSParameters",
    "IWSResultset",
    0
};

const IID *  _wsreader_BaseIIDList[] = 
{
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    &IID_IDispatch,
    0
};


#define _wsreader_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _wsreader, pIID, n)

int __stdcall _wsreader_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _wsreader, 4, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _wsreader, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _wsreader, 4, *pIndex )
    
}

const ExtendedProxyFileInfo wsreader_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _wsreader_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _wsreader_StubVtblList,
    (const PCInterfaceName * ) & _wsreader_InterfaceNamesList,
    (const IID ** ) & _wsreader_BaseIIDList,
    & _wsreader_IID_Lookup, 
    4,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxcom\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\test\ctest\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wsread.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxcom\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\test\ctest\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma once

#include <windows.h>
#include <stdio.h>

#import "wsreader.tlb"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxcom\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\test\ctest\wsread.cpp ===
// wsread.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

enum DBPARAMIOENUM
    {	DBPARAMIO_NOTPARAM	= 0,
	DBPARAMIO_INPUT	= 0x1,
	DBPARAMIO_OUTPUT	= 0x2
    };

typedef 
enum tagWSTCOMMANDTYPE
    {	WRITE_DBTYPE	= 1,
	READ_DBTYPE	= 2,
	WRITEONLY_COMMANDTYPE	= WRITE_DBTYPE,
	PRIMARYONLY_COMMANDTYPE	= WRITEONLY_COMMANDTYPE,
	READTHENWRITE_COMMANDTYPE	= READ_DBTYPE,
	SECONDARYTHENPRIMARY_COMMANDTYPE	= READTHENWRITE_COMMANDTYPE,
	READONLY_COMMANDTYPE	= 3,
	SECONDARYONLY_COMMANDTYPE	= READONLY_COMMANDTYPE,
	WRITETHENREAD_COMMANDTYPE	= 4,
	PRIMARYTHENSECONDARY_COMMANDTYPE	= WRITETHENREAD_COMMANDTYPE,
	READORWRITE_COMMANDTYPE	= 5,
	PRIMARYORSECONDARY_COMMANDTYPE	= READORWRITE_COMMANDTYPE,
	ALLDATABASES_COMMANDTYPE	= 6
    } 	WSTCOMMANDTYPE;


int __cdecl main(int argc, char* argv[])
{
	if( FAILED( CoInitialize( NULL ) ) )
	{
		printf( "CoInitialize failed\n" );
		return -1;
	}

	WSREADERLib::IWSDataReaderPtr spWSReader;

	spWSReader.CreateInstance( __uuidof( WSREADERLib::WSDataReader ) );
	if( NULL == spWSReader )
	{
		printf( "Failed to create wsreader\n");
		return -1;
	}

	spWSReader->Initialize( L"uodb" );
	
	DWORD dw = 10000;
	while( dw-- )
	{
		WSREADERLib::IWSParametersPtr spWSParams;

		spWSParams.CreateInstance( __uuidof( WSREADERLib::WSParameters ) );
		if( NULL == spWSParams )
		{
			printf( "Failed to create wsparams\n");
			return -1;
		}

		spWSParams->AddInt32( DBPARAMIO_OUTPUT, 0 );
		spWSParams->AddInt64( DBPARAMIO_INPUT, 2772528520599712 );
		spWSParams->AddInt32( DBPARAMIO_INPUT, 1 );

		LONG lHash = spWSReader->GetPartitionFromInt64( 2772528520599712 );

		WSREADERLib::IWSResultsetPtr spResults = 
			spWSReader->Execute( WRITEONLY_COMMANDTYPE, lHash, L"{ ? = call p_msg_get_queued_msgs (?, ?) }", spWSParams );

		while( VARIANT_TRUE == spResults->Read() )
		{
			SHORT sQueueType = (SHORT)spResults->GetInt32( 0 );
			ULONG ulStringId = spResults->GetInt32( 1 );
		}

		spResults.Release();
		spWSParams.Release();
	}

	spWSReader.Release();

	CoUninitialize();

	return 0;
}

/*

namespace XBOX.Online
{
    public class MsgServer
    {
        static void Main(string[] args)
        {
            for( int i = 0; i < 10000; i++ )
            {
                ProcessQueueRequest();
            }
        }

        //-----------------------------------------------------
        // ProcessQueueRequest
        //
        //  
        //  
        //  
        static void ProcessQueueRequest()
        {

            // we need to make separate calls to xprofile due to the fact that webstore
            // is partitioning the users.  Also of note, we are getting back the system-wide
            // and per-title queues for each user because we are tracking player view histories
            // and each user may have already seen (or not) certain messages.  We will need to
            // build a full list by parsing through each response ... sigh.
            WSClient ws;
            ws = new WSClient("uodb", CmdType.WRITEONLY_COMMANDTYPE);
            ws.StoredProc = "p_msg_get_queued_msgs";

            // brute force enumerate to reduce parsing dynamic input request logic
            // if the PUID is 0, then no user on that slot
            ProcessUserQueue(ws);
        }

        //-----------------------------------------------------
        // ProcessUserQueue
        //
        //  
        //  
        //  
        static void ProcessUserQueue(WSClient ws)
        {
            short sQueueType;
            ulong ulStringId;
            WSREADERLib.WSResultset rs;
            uint hr = HResult.S_OK;
            ulong ulPUID = 0;
             
            ws.ClearParameters();
            ws.AddParameter(ParamType.RETVAL, 0);
            ulPUID = 2772528520599712;
            ws.SetHashVal(ulPUID);
            ws.AddParameter(ulPUID);
            ws.AddParameter(1); // ulTitleID

            // execute the query
            rs = ws.Execute();

            // process the returned row sets
            while (rs.Read())
            {
                sQueueType = (short) rs.GetInt32(0);
                ulStringId = (ulong) rs.GetInt32(1);

            }

            // check hresult from stored procedure exec.  Checked at end due to the way OLEDB
            // handles filling in return values
            hr = (uint)ws.GetIntParameter(0);
            if (HResult.Failed(hr)) 
            {
            }
            return;             
        }

    }
}   // end namespace

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxutil\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxcom\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.common.xboxcom_none_12.4.56.0_none_8fe75f25f0bc3863
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.common.xboxcom
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1.cat
XP_CATALOG_PATH=manifests\msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1.cat
XP_PAYLOAD_PATH=msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.common.xboxcom,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxcom\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.common.xboxcom_none_12.4.56.0_none_8fe75f25f0bc3863
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.common.xboxcom
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1.cat
XP_CATALOG_PATH=manifests\msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1.cat
XP_PAYLOAD_PATH=msil_xonline.common.xboxcom_no-public-key_12.4.56.0_x-ww_dbd048d1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.common.xboxcom,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\wsreader\test\dvt\Class1.cs ===
using System;
using System.Diagnostics;

using xonline.common.config;

namespace xonline.common.wsreader.test.dvt
{
    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    class Class1
    {
        static void Main(string[] args)
        {
            WSREADERLib.WSDataReader reader;

            reader = new WSREADERLib.WSDataReader();

            Output("Initializing");
            reader.Initialize(ConfigUtil.UodbWebstoreApp);

            /*RecordsetTest(reader);
            ParameterTest(reader);*/

            SessionTest(reader);
        }

        static void SessionTest(WSREADERLib.WSDataReader reader)
        {
            WSREADERLib.WSResultset rs1;
            WSREADERLib.WSParameters p1;

            WSREADERLib.WSResultset rs2;
            WSREADERLib.WSParameters p2;

            WSREADERLib.WSSession session;

            Output("***** Running Session Test *****");

            try
            {
                Output("Creating sesssion");
                session = reader.GetSession(2, 0);


                session.BeginTransaction();


    /*
     *      exec p_svc_insert_offer
     *             0x00000100,
     *             0x00000101,
     *             0,
     *             0,
     *             10477078,
     *             650,
     *             0x886B7B41E3D6434840E29184DE7CB8DD,
     *             0xffffffff,
     *             1,
     *             0,
     *             '3/1/2002',
     *             '2/28/2003',
     *             'Sample Content'
     */

                Output("Adding params");
                p1 = new WSREADERLib.WSParametersClass();


                p1.AddInt32(2, 0);
                p1.AddInt32(1, 1234);
                p1.AddInt32(1, 20);
                p1.AddInt32(1, 0);
                p1.AddByte(1, 0);
                p1.AddInt32(1, 10477078);
                p1.AddInt32(1, 650);
                p1.AddByteArray(1, new byte[] { 0x88, 0x6B, 0x7B, 0x41, 0xE3, 0xD6, 0x43, 0x48, 0x40, 0xE2, 0x91, 0x84, 0xDE, 0x7C, 0xB8, 0xDD }, 16);
                p1.AddInt32(1, 0x00000000);
                p1.AddInt32(1, 1);
                p1.AddInt32(1, 0);
                p1.AddDate(1, new System.DateTime(2002, 3, 1));
                p1.AddDate(1, new System.DateTime(2003, 2, 28));
                p1.AddString(1, "Sample Content", 3000);

                Output("Executing '{ ? = CALL dbo.p_svc_insert_offers(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }'");

                session.ExecuteNonQuery( "{ ? = CALL dbo.p_svc_insert_offers(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }", p1);
                //rs = session.Execute( "{ ? = CALL dbo.p_test_reader_session(?, ?) }", p);

                Output("Adding params");
                p2 = new WSREADERLib.WSParametersClass();


                p2.AddInt32(2, 0);
                p2.AddInt32(1, 1234);
                p2.AddInt32(1, 21);
                p2.AddInt32(1, 0);
                p2.AddByte(1, 0);
                p2.AddInt32(1, 10477078);
                p2.AddInt32(1, 650);
                p2.AddByteArray(1, new byte[] { 0x88, 0x6B, 0x7B, 0x41, 0xE3, 0xD6, 0x43, 0x48, 0x40, 0xE2, 0x91, 0x84, 0xDE, 0x7C, 0xB8, 0xDD }, 16);
                p2.AddInt32(1, 0x00000000);
                p2.AddInt32(1, 1);
                p2.AddInt32(1, 0);
                p2.AddDate(1, new System.DateTime(2002, 3, 1));
                p2.AddDate(1, new System.DateTime(2003, 2, 28));
                p2.AddString(1, "Sample Content", 150);

                Output("Executing '{ ? = CALL dbo.p_svc_insert_offers(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }'");

                rs2 = session.Execute( "{ ? = CALL dbo.p_svc_insert_offers(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }", p2);
                //rs = session.Execute( "{ ? = CALL dbo.p_test_reader_session(?, ?) }", p);


                session.CommitTransaction();

            }
            catch(Exception e)
            {
                Output("EXCEPTION: " + e.ToString());
            }
        }

        static void RecordsetTest(WSREADERLib.WSDataReader reader)
        {
            WSREADERLib.WSResultset rs;
            WSREADERLib.WSParameters p;

            Output("***** Running Recordset Test *****");

            try
            {

                Output("Adding params");
                p = new WSREADERLib.WSParametersClass();


                p.AddInt32(2, 0);
                p.AddByteArray(1, new byte[] { 1, 2, 3, 4, 5 }, 5);
                p.AddInt32(2, 123);

                Output("Executing '{ ? = CALL dbo.p_test_reader(?, ?) }'");

                rs = reader.Execute(2, 0, "{ ? = CALL dbo.p_test_reader(?, ?) }", p);

                //reader.Execute(2, 0, "{ CALL dbo.p_test_reader }");

                //Output("Value of param 0: " + reader.GetParamValueInt32(0));

                while (rs.Read())
                {
                    Output("Read another line");
                    //Output("Value of GetInt16(0): " + rs.GetInt16(0));
                    Output("Value of GetInt32(GetOrdinal('i')): " + rs.GetInt32(rs.GetOrdinal("i")));
                    //Output("Value of GetInt64(0): " + rs.GetInt64(0));

                    Output("Value of GetInt32(1): " + rs.GetInt32(1));
                    Output("Value of GetInt64(1): " + rs.GetInt32(1));
                    try
                    {
                        Output("Value of GetInt16(1) *should fail*: " + rs.GetInt16(1));
                        Output("  ERROR: DIDIN'T FAIL!");
                    }
                    catch(Exception e2) { Output("Exception (good!): " + e2.ToString()); }

                    Output("Value of GetInt64(2): " + String.Format("{0:x}", rs.GetInt64(2)));

                    Output("Value of GetString(5): '" + rs.GetString(5) + "'");
                    Output("Value of GetString(6): '" + rs.GetString(6) + "'");
                    Output("Value of GetString(7): '" + rs.GetString(7) + "'");

                    Output("Value of GetDate(8): " + rs.GetDate(8));
                    Output("Value of GetDate(9): " + rs.GetDate(9));

                    byte[] bytes = rs.GetByteArray(10);
                    if (bytes == null)
                    {
                        Output("Val of GetByteArray(10): null");

                    }
                    else
                    {
                        Output("# of bytes returned by GetByteArray(10): " + bytes.Length);
                        Output("   bytes[1]: " + bytes[1]);

                    }

                    Output("partition of GetInt32(1): " + reader.GetPartitionFromInt32(rs.GetInt32(1)));
                    //Output("partition of GetInt64(0): " + reader.GetPartitionFromInt64(rs.GetInt64(0)));
                    Output("partition of GetPartitionFromString(6): " + reader.GetPartitionFromString(rs.GetString(6)));





                }

                Output("rs.NextResult: " + rs.NextResult());

                Output("Value of param 0: " + p.GetInt32(0));
                //Output("Value of param 1: " + p.GetInt32(1));

            }
            catch(Exception e)
            {
                Output("EXCEPTION: " + e.ToString());
            }
        }

        static void ParameterTest(WSREADERLib.WSDataReader reader)
        {
            WSREADERLib.WSParameters p;

            try
            {

                Output("Adding params");
                p = new WSREADERLib.WSParametersClass();

                p.AddInt32(2, 0);

                p.AddByteArray(1, new byte[] { 1, 2, 3, 4, 5 }, 5);
                p.AddString(1, "foobar", 99);
                p.AddString(1, ":(", 0);
                p.AddInt16(2, 0);
                p.AddInt32(2, 123);
                p.AddInt64(2, 0);

                p.AddDate(2, new DateTime(2001, 7, 10));
                p.AddString(2, "", 255);
                p.AddString(2, "XBox XBox XBox", 255);

                p.AddByteArray(2, null, 4000);


                Output("Executing '{ ? = CALL dbo.p_test_reader_params (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }'");

                reader.ExecuteNonQuery(2, 0, "{ ? = CALL dbo.p_test_reader_params (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }", p);

                Output("Value of param 0: " + p.GetInt32(0));
                Output("Value of param 2: " + p.GetString(2));
                Output("Value of param 3: " + p.GetString(3));
                Output("Value of param 4: " + p.GetInt16(4));
                Output("Value of param 5: " + p.GetInt32(5));
                Output("Value of param 6: " + p.GetInt64(6));
                Output("Value of param 7: " + p.GetDate(7));
                Output("Value of param 8: " + p.GetString(8));
                Output("Value of param 9: " + p.GetString(9));

                byte[] by = p.GetByteArray(10);
                Output("Length of param 10: " +by.Length);
                Output(" param10[0] = " + by[0] + " [1]=" + by[1]);



            }
            catch(Exception e)
            {
                Output("EXCEPTION: " + e.ToString());
            }
        }

        static void Output(string str)
        {
            Console.WriteLine(str);
            Trace.WriteLine(str);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxcom\dll\LivecacheProtocol.cs ===
using System;
using System.Text;
using System.Collections;
using System.Reflection;
using System.Diagnostics;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.sql.sqlclient;

[assembly: XomAreaDefinition(XomAreaName.livecachetrace)]

    
namespace xonline.common.xboxcom
{
    //
    // common utility used by both livecache server and client
    //

    public class LivecacheConst
    {
        public const string TargetXrl = "/Livecache/lcreq.ashx";
        public const string LcserviceIdHeader = "LC-ServiceId";
        public const string LcDependHeader = "LC-Depends";
        public const string LcUpdateHeader = "LC-Updates";
        public const string LcHourlyQuotaHeader = "LC-Hourly";

        public const int SN_CacheInvalidate = 9901;
        public const int SN_LoadData = 9902;
        public const int SN_SaveData = 9903;
        public const int SN_ClearData = 9904;

        // A LiveCache ServiceId is a UINT32 arranged like so:
        // 0x00ccssss
        // where "cc" is the 8 bit ClientType and "ssss" is the 16 bit BaseServiceId.
        // Also see LivecacheUtil.cs and LivecacheClientType.cs for the client-side 
        // implementation of this.

        public const int LcBaseServiceIdMask   = 0x0000FFFF;
        public const int LcClientTypeMask      = 0x00FF0000;  // 1 byte for service type
        public const int LcClientTypeShift     = 16;

        public const int LcClientType_XboxCom  = 0;
        public const int LcClientType_Zune     = 1;
        public const int LcClientType_XNA      = 2;
        public const int LcClientType_WGX      = 3;
        public const int LcClientType_LIVEn    = 4;
    }

    public class LivecacheKey
    {
        public string Value
        {
            get
            {
                return _keyString;
            }
        }
        protected string _keyString;

        public override int GetHashCode()
        {
            return _keyString.GetHashCode();
        }
        
        // provide a protected constructor to allow derrived classes to
        // build LivecacheKeys with additional information
        protected LivecacheKey()
        {
        }

        //
        // generate cache key from request arguments.
        //
        // currently, requests are considered same if they have the same userId,
        // livecache service id, and post data (request object).
        //
        // postData is base64 encoded for easy diagnosing
        //
        public LivecacheKey( 
            int lcserviceId,
            ulong userId,
            byte[] postData
            )
        {
            _keyString = string.Format("{0:d}|{1:x}|{2}",
                lcserviceId,
                userId,
                Convert.ToBase64String(postData));
        }

        public static int QueryServiceId(string keyString)
        {
            return int.Parse(keyString.Split('|')[0]);
        }
    }

    public class LivecacheLoadDataRequest : XRLObject2
    {
        public uint KeyLength;
        [WireInfo(SizeParam="KeyLength")]
        public string Key;
    }

    public class LivecacheSaveDataRequest : XRLObject2
    {
        public uint SecondsToCache;

        public uint KeyLength;
        [WireInfo(SizeParam="KeyLength")]
        public string Key;

        public uint ValueLength;
        [WireInfo(SizeParam="ValueLength")]
        public byte[] Value;
    }

    public class LivecacheClearDataRequest : XRLObject2
    {
        public uint KeyLength;
        [WireInfo(SizeParam="KeyLength")]
        public string Key;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxutil\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xboxutil_3_none_12.4.56.0_none_0f61aaa11bc4101a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xboxutil_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e.manifest
XP_MANIFEST_PATH=manifests\x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e.cat
XP_CATALOG_PATH=manifests\x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e.cat
XP_PAYLOAD_PATH=x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xboxutil_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxutil\xboxutil.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Xml.XPath;

using xonline.common.config;
using xonline.common.livetitleconfig;
using xonline.common.mgmt;
using xonline.common.leaderboard;
using xonline.tools.framework;
using xonline.common.tools;

namespace xonline.common.xboxutil
{

    public class XboxUtil
    {
        public const string XBOX_SCHEMA_VERSION = "XBOX";
        public const string TITLE_NAME_FRIENDLY_NAME = "X_STRINGID_TITLENAME";

        /// <summary>
        /// Returns the translations as an XmlNodeList for the localized title name strings for the xbox1 title.
        /// </summary>
        /// <param name="xboxXml">Path of the xbox1 configuration XML file</param>
        /// <returns>XmlNodeList containing the translations</returns>
        public static XboxConfigurationLocalizedString GetTitleNameLocalizedString(
            xonline.common.xboxutil.XboxConfiguration xboxCfg)
        {
            string TitleNameString = TITLE_NAME_FRIENDLY_NAME;
            XboxConfigurationLocalizedString localizedString = null;
            foreach (XboxConfigurationLocalizedString ls in xboxCfg.LocalizedStrings)
            {
                if (ls.friendlyName == TitleNameString)
                {
                    localizedString = ls;
                    break;
                }
            }
            return localizedString;
        }

        public static string ToXml(XboxConfiguration XboxCfg)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(XboxConfiguration));
            StringWriter sw = new StringWriter();
            serializer.Serialize(sw, XboxCfg);
            return sw.ToString();
        }

        public static XboxConfiguration FromXml(string xboxXml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xboxXml));
            XmlSerializer serializer = new XmlSerializer(typeof(XboxConfiguration));
            XboxConfiguration XboxCfg = (XboxConfiguration)serializer.Deserialize(xmlReader);
            return XboxCfg;
        }

        public static void PutXboxConfig(uint titleID, string xboxString)
        {

            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();
                SqlCommand cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;

                //confirm that title doesn't already exist in NPDB
                cmd.CommandText = "dbo.p_game_save_config";

                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleID;
                cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                cmd.Parameters.Add("@xml_config", SqlDbType.NText).Value = xboxString;
                cmd.Parameters["@xml_config"].Direction = ParameterDirection.Input;

                //task: hardcoded for now, will need to change once XLAST has the schema version.
                cmd.Parameters.Add("@vc_xdk_version", SqlDbType.VarChar, 50).Value = XBOX_SCHEMA_VERSION;
                cmd.Parameters["@vc_xdk_version"].Direction = ParameterDirection.Input;

                cmd.Parameters.Add("@hr", SqlDbType.Int);
                cmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                SqlDataReader reader = cmd.ExecuteReader();

                reader.Close();
                conn.Close();
            }

        }

        public static bool CheckXboxConfig()
        {
            /*// Check GameConfig
            XboxCfg.GameConfig.titleId;
            // Check WebdbInfo
            XboxCfg.WebdbInfo;
            // Check Bounty
            XboxCfg.Bounty;
            // Check LocalizedStrings
            XboxCfg.LocalizedStrings;
            // Check ProductInformation
            XboxCfg.ProductInformation;


            if ( !CheckRating( ltc ) )
            {
            validXlast = false;
            }

            if ( !CheckLeaderBoards( ltc ) )
            {
            validXlast = false;
            }

            if ( !CheckBounty() )
            {
            validXlast = false;
            }
            return validXlast;*/
            return true;
        }

        //confirm rating elements conform to rating info in npdb
        public static bool CheckRating(LiveTitleConfig ltc)
        {

            //task: What checks should really be here?
            //            int rsid = 0;
            //            int rating = 0;
            //            try 
            //            {
            //                rsid = Convert.ToInt32( argParser[ "rsid" ] );
            //                rating = Convert.ToInt32( argParser[ "rating" ] );
            //            }
            //                //review: is there a more elegant way to do this?
            //            catch ( ArithmeticException )
            //            {
            //                Console.WriteLine( "Either the rating system ID or rating is unable to be converted to an integer." );
            //                return -1;
            //            }

            //            int esrb = 0;
            //            try 
            //            {
            //                esrb = Convert.ToInt32( argParser[ "esrb" ] );
            //
            //            }
            //                //review: is there a more elegant way to do this?
            //            catch ( ArithmeticException )
            //            {
            //                Console.WriteLine( "The esrb argument is unable to be converted to an integer." );
            //                return -1;
            //            }

            return true;
        }


        public static bool CheckBounty()
        {

            //            bool bounty;
            //            if (
            //                ( null != argParser[ "bountyflag" ] ) &&
            //                 (
            //                    ( "Y" == argParser[ "bountyflag" ] ) ||
            //                    ( "N" == argParser[ "bountyflag" ] )
            //                  )
            //                )
            //            {
            //                bounty = ( argParser[ "bountyflag" ] == "Y" );
            //                Console.WriteLine("bounty is " + bounty );
            //            }
            //            else
            //            {
            //                Usage();
            //                Console.WriteLine( "\n\r===> Incorrect Bounty Setting: Bounty must be Y or N!" );
            //                return 0;
            //            }

            return true;
        }

        //task: should this be here?
        //confirm leaderboards don't exceed LTC limits, and that XLAST and LTC contain same lbid's
        /*public static bool CheckLeaderBoards( LiveTitleConfig ltc )
        {
            int lbCount = 0;
            GameConfigProject gcp = xlsp.GameConfigProject;

            //IF there's stats, check consistency between XLAST and LTC
            if ( 
                ( gcp.StatsViews != null ) &&
                ( gcp.StatsViews.StatsView != null )
                )
            {
                lbCount += gcp.StatsViews.StatsView.Length;
            }

            //skill leaderboards count toward max as well
            if (
                ( gcp.GameModes != null ) &&
                ( gcp.GameModes.GameMode != null )
                )
            {
                lbCount += gcp.GameModes.GameMode.Length;
            }

            if ( lbCount > ltc.StatsMaxLeaderboards )
            {
                //task: NO CONSOLE OUTPUT HERE!!!
                Console.WriteLine( "The Xlast document contains more leaderboards than the LiveTitleConfig " );
                Console.WriteLine( " document allows.  Please reduce leaderboards in Xlast or increase MaxStatsLeaderboards in LTC." );
                return false;
            }

            return true;

        }  // checklb
        */

        /// <summary>
        /// Validate the XBOX XML against the schema
        /// </summary>
        /// <param name="xboxXml"></param>
        /// <param name="schemaXml"></param>
        /// <returns></returns>
        public static bool ValidateXboxConfigXML(string xboxXml, string schemaXml)
        {
            StringReader schemaStream = new StringReader(schemaXml);
            StringReader xmlStream = new StringReader(xboxXml);

            XmlReaderSettings xmlReaderSettings;
            XmlTextReader schemaReader;

            schemaReader = new XmlTextReader(schemaStream);
            xmlReaderSettings = new XmlReaderSettings();

            xmlReaderSettings.Schemas.Add("", schemaReader);
            xmlReaderSettings.ValidationType = ValidationType.Schema;
            XmlReader xmlReader = XmlReader.Create(xmlStream, xmlReaderSettings);

            bool validXml = false;
            try
            {
                while (xmlReader.Read()) ;
                validXml = true;
            }
            catch (Exception e)
            {
                throw new Exception("INVALID XBOX Xml document. Exception: " + e.ToString());
            }
            return validXml;
        }



    } // XboxUtil class

    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class XboxConfiguration
    {
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public XboxConfigurationGameConfig GameConfig;

        /// <remarks/>
        [System.Xml.Serialization.XmlArrayAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        [System.Xml.Serialization.XmlArrayItemAttribute("LocalizedString", Form = System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable = false)]
        public XboxConfigurationLocalizedString[] LocalizedStrings;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public bool Bounty;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public XboxConfigurationWebdbInfo WebdbInfo;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public XboxConfigurationProductInformation ProductInformation;
    }

    /// <remarks/>
    public class XboxConfigurationGameConfig
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string version;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string titleId;

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool titleIdSpecified;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string titleName;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string projectVersion;
    }

    /// <remarks/>
    public class XboxConfigurationProductInformationPublisher
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;
    }

    /// <remarks/>
    public class XboxConfigurationProductInformation
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public XboxConfigurationProductInformationPublisher Publisher;
    }

    /// <remarks/>
    public class XboxConfigurationWebdbInfo
    {

        /// <remarks/>
        //[System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer")]
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string ESRB;

        /// <remarks/>
        //[System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified, DataType="integer")]
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string ClusterID;

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(Form = System.Xml.Schema.XmlSchemaForm.Unqualified)]
        public string DefaultLocale;
    }

    /// <remarks/>
    public class XboxConfigurationLocalizedStringTranslation
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string locale;

        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string Value;
    }

    /// <remarks/>
    public class XboxConfigurationLocalizedString
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Translation", Form = System.Xml.Schema.XmlSchemaForm.Unqualified, IsNullable = true)]
        public XboxConfigurationLocalizedStringTranslation[] Translation;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string id;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "", IsNullable = false)]
    public class NewDataSet
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("XboxConfiguration")]
        public XboxConfiguration[] Items;
    }



} // xonline.common.xboxutil namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxutil\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xboxutil_3_none_12.4.56.0_none_0f61aaa11bc4101a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xboxutil_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e.manifest
XP_MANIFEST_PATH=manifests\x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e.cat
XP_CATALOG_PATH=manifests\x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e.cat
XP_PAYLOAD_PATH=x86__xboxutil_3_no-public-key_12.4.56.0_x-ww_4f485f5e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xboxutil_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xcryptoproxy\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xcryptoproxy\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xcryptoproxy\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xcryptoproxy\proxy\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xboxutil\xboxchecker.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Xml.XPath;
using System.Text;

using xonline.common.config;
using xonline.common.livetitleconfig;
using xonline.common.mgmt;


namespace xonline.common.xboxutil
{

    class XboxChecker
    {


        //            Console.WriteLine( "    <name>              - The name of the title (use quotes, limited to XXX unicode characters" );
        //            Console.WriteLine( "    <ClientTitleID>     - The title ID you want to configure (e.g. hexadecimal number 0xfffed000 )" );
        //            Console.WriteLine( "    <LiveTitleID>       - an alternate Title ID ***FIX THIS " );
        //            Console.WriteLine( "    <bountyflag>        - Is this title eligible for bounty payments (Y/N)" );
        //            Console.WriteLine( "    <esrb>              - " );
        //            Console.WriteLine( "    <rsid>              - rating system id (e.g. \"PIC\", \"ESRB\", etc.) " );
        //            Console.WriteLine( "    <rating>            - rating within the rating system" );
        //            Console.WriteLine( "    <clusterid>         - WebCache clusterID" );
        //            Console.WriteLine( "    <PCDBlocale>        - Locale ????  for PCDB (e.g. 1033 or \"en-us\" *** FIX THIS " );
        //            Console.WriteLine( "    <LiveLocale>        - Locale string (e.g. \"en-us\" " );


        //task: where do parameters get checked? *** In the new XBOXCheck class...  (e.g. name < 128, esrb foreign key, etc??)
        public static bool CheckXboxConfig( string xboxXml, string ltcXml, ref StringBuilder validationInfo )
        {
            bool validXlast = true;
            LiveTitleConfig ltc = null; 

            try 
            {
                ltc = LiveTitleConfig.FromXml( ltcXml );

            }
            catch
            {
                return false;
            }

            //task: seems like there should be a more elegant way to write this... 
            //task: should all check functions return an out string?

            if ( !CheckRating( ltc ) )
            {
                validXlast = false;
                validationInfo.Append( "\n-- CheckRating Has Failed." );
            }
            
            if ( !CheckLeaderBoards( ltc ) )
            {
                validXlast = false;
                validationInfo.Append( "\n-- The XSC document contains more leaderboards than the LiveTitleConfig " );
                validationInfo.Append( "\n-- document allows.  Please reduce leaderboards in XSC or increase MaxStatsLeaderboards in LTC." );
            }

            if ( !CheckBounty() )
            {
                validXlast = false;
                validationInfo.Append( "\n-- CheckBounty Has Failed." );
            }


            return validXlast;

        }


        //confirm rating elements conform to rating info in npdb
        public static bool CheckRating( LiveTitleConfig ltc )
        {

            //task: What checks should really be here?
//            int rsid = 0;
//            int rating = 0;
//            try 
//            {
//                rsid = Convert.ToInt32( argParser[ "rsid" ] );
//                rating = Convert.ToInt32( argParser[ "rating" ] );
//            }
//                //review: is there a more elegant way to do this?
//            catch ( ArithmeticException )
//            {
//                Console.WriteLine( "Either the rating system ID or rating is unable to be converted to an integer." );
//                return -1;
//            }

//            int esrb = 0;
//            try 
//            {
//                esrb = Convert.ToInt32( argParser[ "esrb" ] );
//
//            }
//                //review: is there a more elegant way to do this?
//            catch ( ArithmeticException )
//            {
//                Console.WriteLine( "The esrb argument is unable to be converted to an integer." );
//                return -1;
//            }

            return true;
        }


        public static bool CheckBounty()
        {

            //            bool bounty;
            //            if (
            //                ( null != argParser[ "bountyflag" ] ) &&
            //                 (
            //                    ( "Y" == argParser[ "bountyflag" ] ) ||
            //                    ( "N" == argParser[ "bountyflag" ] )
            //                  )
            //                )
            //            {
            //                bounty = ( argParser[ "bountyflag" ] == "Y" );
            //                Console.WriteLine("bounty is " + bounty );
            //            }
            //            else
            //            {
            //                Usage();
            //                Console.WriteLine( "\n\r===> Incorrect Bounty Setting: Bounty must be Y or N!" );
            //                return 0;
            //            }

            return true;
        }

        //task: should this be here?
        //confirm leaderboards don't exceed LTC limits, and that XLAST and LTC contain same lbid's
        public static bool CheckLeaderBoards( LiveTitleConfig ltc )
        {
            //IF there's stats, check consistency between XSC and LTC

            if (ltc.LeaderboardConfigs != null) //null means that there were no leaderboards - that is how the current code is now - It is ok for a title to have 0 leaderboard
            {
                if ( ltc.LeaderboardConfigs.Length > ltc.StatsMaxLeaderboards )
                {
                    //task: NO CONSOLE OUTPUT HERE!!!
                    Console.WriteLine( "The XSC document contains more leaderboards than the LiveTitleConfig " );
                    Console.WriteLine( " document allows.  Please reduce leaderboards in XSC or increase MaxStatsLeaderboards in LTC." );
                    return false;
                }
            }
            else
            {
                Console.WriteLine(String.Format("Warning --- Title ID {0} Has No LeaderBoards", ltc.TitleID));
            }

            return true;

        }  // checklb

    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xcache\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

!if !defined(PASS2ONLY)
$(O)\XCache.tlb : $(O)\XCache.dll.
    echo Build_Status Generating $@ from $(O)\XCache.dll
    -del $(O)\$@
    copy ..\..\config\dll\$(O)\XblConfig.dll $(O)\XblConfig.dll
    tlbexp.exe $(O)\XCache.dll /out:$@
    del $(O)\XblConfig.dll
    if not exist $@ echo NMAKE : T1013: 'TLBEXP' Unable to locate $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xcryptoproxy\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xcryptoproxy_none_12.4.56.0_none_53056f6f1aebb6be
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xcryptoproxy
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978.manifest
XP_MANIFEST_PATH=manifests\msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978.cat
XP_CATALOG_PATH=manifests\msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978.cat
XP_PAYLOAD_PATH=msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xcryptoproxy,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xcryptoproxy\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xcryptoproxy_none_12.4.56.0_none_53056f6f1aebb6be
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xcryptoproxy
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978.manifest
XP_MANIFEST_PATH=manifests\msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978.cat
XP_CATALOG_PATH=manifests\msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978.cat
XP_PAYLOAD_PATH=msil_xcryptoproxy_no-public-key_12.4.56.0_x-ww_5da6e978
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xcryptoproxy,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xcryptoproxy\proxy\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xcryptoproxy_4_none_12.4.56.0_none_c2cf4e425b448491
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xcryptoproxy_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df.manifest
XP_MANIFEST_PATH=manifests\x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df.cat
XP_CATALOG_PATH=manifests\x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df.cat
XP_PAYLOAD_PATH=x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xcryptoproxy_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xcryptoproxy\proxy\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xcryptoproxy_4_none_12.4.56.0_none_c2cf4e425b448491
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xcryptoproxy_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df.manifest
XP_MANIFEST_PATH=manifests\x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df.cat
XP_CATALOG_PATH=manifests\x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df.cat
XP_PAYLOAD_PATH=x86__xcryptoproxy_4_no-public-key_12.4.56.0_x-ww_48a4b3df
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xcryptoproxy_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xcryptoproxy\proxy\XCryptoProxy.cs ===
using System;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;

namespace xonline.common.xcrypto
{

    public enum EContainerClasses : uint
    {
        Drm = 1,
        Asset = 2,
        XMacs = 3,
        XMacsTest = 4,
        Token = 5,
    }

    public enum XCryptoKeyType : uint
    {
        Production = 1,
        Test = 2,
    }

    public static class KeyTypeSettingsUtil
    {
        static KeyTypeSettingsUtil()
        {
            Config.SettingChange += OnSettingChange;
        }

        private static void OnSettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            // We don't need to do much here, since we always poll the queue.
            // But if we don't have a callback, we won't get the dynamic setting
            // changes.
        }

        public static bool UseNCipher { get { return Config.GetBoolSetting(Setting.xcrypto_useNCipher); } }
        public static bool UseTestKey { get { return Config.GetBoolSetting(Setting.xcrypto_useTestKey); } }
        public static bool UseXMacsKey { get { return Config.GetBoolSetting(Setting.kdcsvc_xmacs_use_xcrypto); } }
    }

    public static class CryptoKeyProxy
    {
        public static void Sign(EContainerClasses containerClass, byte[] sha1, byte[] sig, out UInt32 sigLen)
        {
            uint hr = HResult.S_OK;

            // Build the request to send to xcrypto.
            XCryptoSignRequest request = new XCryptoSignRequest();
            request.containerClass = (uint)containerClass;
            request.sha1 = new XCryptoData(sha1, sha1.Length);

            // Call accross to xcrypto.
            XCryptoSignResponse response = new XCryptoSignResponse();
            XRLObject2 xrlo = response;
            hr = XRLUtil.PostXrlRequest(VirtualInterface.xcrypto_int, request.Xrl, request, ref xrlo);

            // Do some error checking on the response.
            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.XCRYPTO_PROXY_FAILED, "Proxy call to Sign failed.");
            }

            if (response.sig.dataLength > sig.Length)
            {
                throw new XRLException(HResult.E_OUTOFMEMORY, XEvent.Id.XCRYPTO_PROXY_BUFFER_TOO_SMALL,
                    String.Format("Signature buffer too short--it's {0} bytes but needs {1} bytes.", sig.Length, response.sig.dataLength));
            }

            // Hand off the signature.
            response.sig.data.CopyTo(sig, 0);
            sigLen = response.sig.dataLength;
        }

        public static bool VerifySignature(EContainerClasses containerClass, byte[] sha1, byte[] sig)
        {
            uint hr = HResult.S_OK;

            // Build the request to send to xcrypto.
            XCryptoVerifySignatureRequest request = new XCryptoVerifySignatureRequest();
            request.containerClass = (uint)containerClass;
            request.sha1 = new XCryptoData(sha1, sha1.Length);
            request.sig = new XCryptoData(sig, sig.Length);

            // Call accross to xcrypto.
            XCryptoVerifySignatureResponse response = new XCryptoVerifySignatureResponse();
            XRLObject2 xrlo = response;
            hr = XRLUtil.PostXrlRequest(VirtualInterface.xcrypto_int, request.Xrl, request, ref xrlo);

            // Do some error checking on the response.
            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.XCRYPTO_PROXY_FAILED, "Proxy call to VerifySignature failed.");
            }

            return response.verified;
        }

        //
        // Verifies that a binary blob is encrypted with a specfic console's Primary 
        // Activation Key.
        // 
        public static bool VerifyConsolePak(UInt64 consoleId, byte[] unencrypted, byte[] encrypted)
        {
            CheckArrayArgumentSize(unencrypted, XCryptoVerifyConsolePakRequest.DATA_SIZE, "unencrypted");
            CheckArrayArgumentSize(encrypted, XCryptoVerifyConsolePakRequest.DATA_SIZE, "encrypted");

            uint hr = HResult.S_OK;

            // Build the request to send to xcrypto.
            XCryptoVerifyConsolePakRequest request = new XCryptoVerifyConsolePakRequest();
            request.consoleId = consoleId;
            request.clear = new XCryptoData(unencrypted, unencrypted.Length);
            request.pakEncrypted = new XCryptoData(encrypted, encrypted.Length);

            // Call accross to xcrypto.
            XCryptoVerifyConsolePakResponse response = new XCryptoVerifyConsolePakResponse();
            XRLObject2 xrlo = response;
            hr = XRLUtil.PostXrlRequest(VirtualInterface.xcrypto_int, request.Xrl, request, ref xrlo);

            return true;
        }

        //
        // Decrypts a binary blob.
        //
        // I know this is a change in signature style from the other methods in this file, but
        // it's better and in fairness, I own the file:).
        public static byte[] Decrypt(EContainerClasses containerClass, byte[] cipher)
        {
            uint hr = HResult.S_OK;

            // Build the request to send to xcrypto.
            XCryptoDecryptRequest request = new XCryptoDecryptRequest();
            request.containerClass = (uint)containerClass;
            request.cipher = new XCryptoData(cipher, cipher.Length);

            // Call accross to xcrypto.
            XCryptoDecryptResponse response = new XCryptoDecryptResponse();
            XRLObject2 xrlo = response;
            hr = XRLUtil.PostXrlRequest(VirtualInterface.xcrypto_int, request.Xrl, request, ref xrlo);

            // Do some error checking on the response.
            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.XCRYPTO_PROXY_FAILED, "Proxy call to Decrypt failed.");
            }

            // We can return the clear-text version directly instead of copying it out somewhere.
            // This is easier and has the minor advantage that we don't then have a copy of the
            // secure data to zero out.
            return response.clear.data;
        }


        //
        // Determines if the container class would use a production or test key.
        // This should be a call over to the xcrypto fd
        public static XCryptoKeyType QueryKeyType(EContainerClasses containerClass)
        {
            return KeyTypeSettingsUtil.UseNCipher && !KeyTypeSettingsUtil.UseTestKey ? XCryptoKeyType.Production : XCryptoKeyType.Test;
        }

        private static void CheckArrayArgumentSize(byte[] array, int size, string arrayName)
        {
            if (array.Length != size)
            {
                throw new ArgumentException(String.Format("{0}.Length is {1} but must be {2}",
                    arrayName, array.Length, size), arrayName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\asyncfile.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

  asyncfile.cpp

Abstract:

  Async file class implementation.
  
--*/

#include "stdafx.h"


CAsyncFile::CAsyncFile()
{
    m_pIOCP = NULL;
    m_hFile = INVALID_HANDLE_VALUE;
    m_dwBytesPerSector = 0;
    m_pBuffer = NULL;
    m_cbBufferSize = 0;
    m_cbBufferStart = 0;
    m_cbBufferEnd = 0;
    m_cbPreviousBufferEnd = 0;
    m_fWritting = FALSE;
    m_liFileOffset.QuadPart = 0;
    m_pSectorBuffer = NULL;
    m_fWritePartialSector = false;
    m_fDiskWriteError = FALSE;
}

CAsyncFile::~CAsyncFile()
{
    SAFE_RELEASE(m_pIOCP);

    if(m_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }

    if(m_pBuffer != NULL)
    {
        VirtualFree(m_pBuffer, 0, MEM_RELEASE);
        m_pBuffer = NULL;
    }
}

HRESULT CAsyncFile::Init(
    LPCWSTR pwszFile,
    CCompletionPort* pIOCP,
    DWORD dwBufferSize
)
{
    HRESULT hr = S_OK;

    //
    // Create the file
    //

    m_hFile = CreateFileW(pwszFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, 
        CREATE_NEW, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | 
        FILE_FLAG_NO_BUFFERING, NULL);

    if(INVALID_HANDLE_VALUE == m_hFile)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto lDone;
    }

    //
    // Attach file to i/o completion port
    //

    m_pIOCP = pIOCP;
    m_pIOCP->AddRef();

    GOTO_LDONE_IF_FAILED_HR(
        m_pIOCP->Attach(m_hFile, 0) );

    m_AsyncContext.Init((CCompletionHandler*)this);

    //
    // To use unbuffered I/O, we need to manipulate blocks of memory that are
    // sector aligned so we need to know the size of disk's sector. We can get 
    // that information using the win32 API GetDiskFreeSpace.
    //

    WCHAR wszDrive[64];
    _wsplitpath(pwszFile, wszDrive, NULL, NULL, NULL);

    if(iswalpha(wszDrive[0]))
    {
        // Good. Add the backslash to the drive letter to make it usable by the
        // GetDiskFreeSpace API.
        
        wszDrive[2] = L'\\';
        wszDrive[3] = L'\0';
    }
    else
    {
        // The prefix doesn't start with a drive letter. Maybe it's an UNC path.
        // That's a bummer because we're going to have to use the C: drive as 
        // our model.

        wcscpy(wszDrive, L"C:\\");
    }

    DWORD dwSectorsPerCluster;
    DWORD dwNumberOfFreeClusters;
    DWORD dwTotalNumberOfClusters;

    GOTO_LDONE_IF(
        GetDiskFreeSpaceW(wszDrive, 
            &dwSectorsPerCluster,
            &m_dwBytesPerSector,
            &dwNumberOfFreeClusters,
            &dwTotalNumberOfClusters) == 0,
        HRESULT_FROM_WIN32(GetLastError()) );

    //
    // Now allocate the buffer. Adjust dwBufferSize to be a multiple of the disk 
    // sector size.
    //

    m_cbBufferSize = (dwBufferSize / m_dwBytesPerSector) * m_dwBytesPerSector;

    if(m_cbBufferSize == 0)
    {
        //
        // We need at enough space to store one sector
        //

        m_cbBufferSize += m_dwBytesPerSector;
    }

    //
    // Allocate the buffer. Reserve an extra sector for the sector buffer.
    //

    GOTO_LDONE_IF_FAILED_ALLOC(
        m_pBuffer = (BYTE*) VirtualAlloc(NULL, m_cbBufferSize + m_dwBytesPerSector, MEM_COMMIT, 
        PAGE_READWRITE) );

    m_pSectorBuffer = m_pBuffer + m_cbBufferSize;

lDone:

    return hr;
}

HRESULT CAsyncFile::Write(
    BYTE* pbBuffer,
    DWORD cbBuffer
)
{
    HRESULT hr = S_OK;
    
    //************************************************************************ 
    // This is the only part of the process that is serialized. 
    // TODO: Check what the contention behavior is like.
    //***********************************************************************

    m_WriteAccessLock.WriteLock();

    for(;;)
    {
        DWORD cbSpaceLeft;

        if(m_cbBufferStart <= m_cbBufferEnd)
        {
            cbSpaceLeft = m_cbBufferSize - (m_cbBufferEnd - m_cbBufferStart);
        }
        else
        {
            cbSpaceLeft = m_cbBufferStart - m_cbBufferEnd;
        }

        if(cbSpaceLeft <= cbBuffer)
        {
            // Don't have enough space left in the buffer. Let's spin until
            // we do.
            if ( m_fDiskWriteError )
            {
                hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
                break;
            }
            Sleep(10);
            continue;
            
        }

        // We have enough space. Copy data to our write buffer. If the end 
        // pointer is ready to wrap around, we have to split the operation in
        // two.

        DWORD cbWrite1 = __min(m_cbBufferSize - m_cbBufferEnd, cbBuffer);
        DWORD cbWrite2 = cbBuffer - cbWrite1;
        
        memcpy(m_pBuffer + m_cbBufferEnd, pbBuffer, cbWrite1);

        if(cbWrite2 != 0)
        {
            memcpy(m_pBuffer, pbBuffer + cbWrite1, cbWrite2);
        }

        //
        // Adjust end pointer
        //

        m_cbBufferEnd = (m_cbBufferEnd + cbBuffer) % m_cbBufferSize;

        break;
    }
        
    m_WriteAccessLock.WriteUnlock();

    //
    // Now, keep the async write stuff going, if it's not already.
    //

    GOTO_LDONE_IF_FAILED_HR(
        KeepThingsMoving() );

lDone:
    
    return hr;
}

HRESULT CAsyncFile::KeepThingsMoving()
{
    HRESULT hr = S_OK;

    if(m_cbPreviousBufferEnd != m_cbBufferEnd)
    {
        if(InterlockedCompareExchange((LONG*)&m_fWritting, TRUE, FALSE) == FALSE)
        {
            GOTO_LDONE_IF_FAILED_HR(
                StartAsyncWriteOperation() );
        }
    }

lDone:

    if(FAILED(hr))
    {
        InterlockedExchange((LONG*)&m_fWritting, FALSE);
    }

    return hr;
}

HRESULT CAsyncFile::StartAsyncWriteOperation()
{
    HRESULT hr = S_OK;
    
    //
    // Because we're doing the async/unbuffered thing, we need to always start
    // writting at the beginning of a sector. That means that we're only going
    // to move m_cbBufferStart in sector size steps. That also means that we
    // may end up writting the same information more than once on disk but 
    // it's not a good thing to cache log information in memory anyways.
    // So let's get started. Calculate the amount of data we're going to write.
    //

    DWORD cbBufferEnd = m_cbBufferEnd;
    DWORD cbToWrite;
    
    if(m_cbBufferStart <= m_cbBufferEnd)
    {
        cbToWrite = cbBufferEnd - m_cbBufferStart;
    }
    else
    {
        cbToWrite = m_cbBufferSize - m_cbBufferStart;
    }

    DWORD cbToWriteSectorAligned = (cbToWrite / m_dwBytesPerSector) * 
        m_dwBytesPerSector;

    if(cbToWriteSectorAligned > 0)
    {
        m_fWritePartialSector = false;

        //
        // Good, we have enough stuff in the buffer to fit at least one sector.
        // We'll write as much as we can.
        //

        ZeroMemory((OVERLAPPED*)&m_AsyncContext, sizeof(OVERLAPPED));
        m_AsyncContext.Offset = m_liFileOffset.LowPart;
        m_AsyncContext.OffsetHigh = m_liFileOffset.HighPart;

        AddRef();

        BOOL fSucceeded = WriteFile(m_hFile, m_pBuffer + m_cbBufferStart, 
            cbToWriteSectorAligned, NULL, (OVERLAPPED*) &m_AsyncContext);

        if(!fSucceeded)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            if(HRESULT_FROM_WIN32(ERROR_IO_PENDING) != hr)
            {                
                m_fDiskWriteError = TRUE;
                XomNtEvent( XEVENT_COMMON_CONFIG_287, "[CAsyncFile::StartAsyncWriteOperation]  "
                    "WriteFile(2) failed, hr = 0x%08x", hr );

                Release();

                goto lDone;
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    else
    {
        m_fWritePartialSector = true;

        //
        // There is not enough data to fit a sector. So here's what we're going
        // to do: We're going to copy whatever data is left into a separate 
        // sector size buffer and pad the remaining bytes with spaces. We're 
        // going to send that buffer instead.
        //

        memcpy(m_pSectorBuffer, m_pBuffer + m_cbBufferStart, cbToWrite);
        memset(m_pSectorBuffer + cbToWrite, ' ', m_dwBytesPerSector - cbToWrite);

        ZeroMemory((OVERLAPPED*)&m_AsyncContext, sizeof(OVERLAPPED));
        m_AsyncContext.Offset = m_liFileOffset.LowPart;
        m_AsyncContext.OffsetHigh = m_liFileOffset.HighPart;

        AddRef();

        BOOL fSucceeded = WriteFile(m_hFile, m_pSectorBuffer, 
            m_dwBytesPerSector, NULL, (OVERLAPPED*) &m_AsyncContext);

        if(!fSucceeded)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            if(HRESULT_FROM_WIN32(ERROR_IO_PENDING) != hr)
            {
                m_fDiskWriteError = TRUE;

                XomNtEvent( XEVENT_COMMON_CONFIG_288, "[CAsyncFile::StartAsyncWriteOperation]  "
                    "WriteFile(2) failed, hr = 0x%08x", hr );

                Release();

                goto lDone;
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    // Mark that we don't have anything else to write if...
    if( (m_cbBufferStart <= m_cbBufferEnd &&
        cbToWrite - cbToWriteSectorAligned == 0) // We've written everything there was to write
        || cbToWriteSectorAligned == 0 // We've just written a partial sector
    )
    {
        InterlockedExchange((LONG*)&m_cbPreviousBufferEnd, (LONG)cbBufferEnd);
    }

    // The write operation will happen asynchronously and we can't mess with
    // that area of the buffer while it is happening. Therefore we're only going
    // to update the buffer variables in the i/o completion routine.
    
lDone:

    return hr;
    
}

void CAsyncFile::OnIoCompletion( 
    DWORD dwError, 
    DWORD cbTransferred, 
    ULONG_PTR ulpKey,
    CCompletionContext *pCtx )
{
    if(dwError != NO_ERROR)
    {
        XomNtEvent( XEVENT_MGMT_CRITICAL_ERROR, "[CAsyncFile::OnIoCompletion]  "
                    "WriteFile failed, hr = 0x%08x", HRESULT_FROM_WIN32(dwError) );
        goto lDone;
    }

    //
    // Write operation has completed. Update the buffer and file variables. 
    // Let's start with m_cbBufferStart. Remember that we can only move the
    // pointer in sector size steps. Therefore we're only going to update 
    // anything if we've written full sectors.
    //

    if(!m_fWritePartialSector)
    {
        InterlockedExchange((LONG*)&m_cbBufferStart, 
            (LONG)(m_cbBufferStart + cbTransferred) % m_cbBufferSize);

        m_liFileOffset.QuadPart += cbTransferred;
    }

lDone:

    //
    // If no error happened, keep things moving.
    //

    if(dwError == NO_ERROR)
    {
        InterlockedExchange((LONG*)&m_fWritting, (LONG)FALSE);
        KeepThingsMoving();
    }
    else
    {
        m_fDiskWriteError = TRUE;
    }


    Release();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\curmod.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

  currmod.h

Abstract:

  Declares CGetCurrentModuleName

--*/

#pragma once

/*******************************************************************************

  CGetCurrentModuleName

  Util class that uses all sort of dirty tricks to figure out the name of 
  the current *module*

******************************************************************************/

class CGetCurrentModuleName
{
public:
    
    typedef BOOL (WINAPI *LPENUMPROCESSMODULES)(
        HANDLE hProcess,
        HMODULE *lphModule,
        DWORD cb,
        LPDWORD lpcbNeeded);

    typedef BOOL (WINAPI *LPGETMODULEINFORMATION)(
        HANDLE hProcess,
        HMODULE hModule,
        LPMODULEINFO lpmodinfo,
        DWORD cb);

    CGetCurrentModuleName();

    ~CGetCurrentModuleName();

    LPCSTR GetModuleName();

    HMODULE GetModuleHandle()
    {
        LazyInit();
        return m_hModule;
    }

protected:

    void Init();

    void LazyInit();

    static void Dummy();

    CHAR m_szModuleName[256];

    HMODULE m_hModule;

    CRITICAL_SECTION m_cs;

    BOOL m_bInit;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\curmod.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

  currmod.h

Abstract:

  Defines CGetCurrentModuleName

--*/

#include "stdafx.h"


/*******************************************************************************

  CGetCurrentModuleName::CGetCurrentModuleName

  constructor

******************************************************************************/

CGetCurrentModuleName::CGetCurrentModuleName()
{
    m_bInit = FALSE;

    m_szModuleName[0] = '\0';

    m_hModule = NULL;

    InitializeCriticalSection(&m_cs);
}

/*******************************************************************************

  CGetCurrentModuleName::~CGetCurrentModuleName

  destructor

******************************************************************************/

CGetCurrentModuleName::~CGetCurrentModuleName()
{
    DeleteCriticalSection(&m_cs);
}

/*******************************************************************************

  CGetCurrentModuleName::GetModuleName

  Returns the name of the current module 

******************************************************************************/

LPCSTR CGetCurrentModuleName::GetModuleName()
{
    LazyInit();

    return m_szModuleName;
}

/*******************************************************************************

  CGetCurrentModuleName::LazyInit

  Ensure that the class is initialized. Why not initialize at the constructor?
  What a explendid question!!! We can't initialize in the constructor because
  we need to call LoadLibrary and since this is a global object, it would end 
  up being called from DllMain, which is sin worth of hell according to MSDN.

******************************************************************************/

inline void CGetCurrentModuleName::LazyInit()
{
    if(! m_bInit)
    {
        EnterCriticalSection(&m_cs);

        if(! m_bInit)
        {
            Init();
        
            m_bInit = TRUE;
        }

        LeaveCriticalSection(&m_cs);
    }
}

/*******************************************************************************

  CGetCurrentModuleName::Init

  Find out the name of the current module

******************************************************************************/

void CGetCurrentModuleName::Init()
{
    DWORD i = 0;
    DWORD cModules = 0;
    HMODULE rghModules[1024];
    DWORD cbNeeded = 0;
    CHAR szFullName[256];
    
    // Load PSApi.dll dynamically. We are doing that *only* to avoid having
    // to link psapi.lib with every single project. Also, this will ensure 
    // that the app will work even if it can't find this dll.
    
    HINSTANCE hPSApiDll = LoadLibrary( _T("psapi.dll"));

    if(hPSApiDll != NULL)
    {
        
        // These are the functions we need from PSApi.dll
        
        LPENUMPROCESSMODULES pEnumProcessModules = 
            (LPENUMPROCESSMODULES) GetProcAddress(hPSApiDll, "EnumProcessModules");
        LPGETMODULEINFORMATION pGetModuleInformation = 
            (LPGETMODULEINFORMATION) GetProcAddress(hPSApiDll, "GetModuleInformation");
        
        if(    pEnumProcessModules != NULL &&
            pGetModuleInformation != NULL )
        {
            
            // We have the functions
            
            // enumerate all the modules of the current process                
            
            pEnumProcessModules(GetCurrentProcess(), rghModules, 
                sizeof(rghModules), &cbNeeded);

            cModules = cbNeeded / sizeof(HMODULE);

            // look at each one of them                
            
            for(i=0; i < cModules; i++)
            {
                
                // extract the module information
                
                MODULEINFO sMI;
                
                BOOL br = pGetModuleInformation(GetCurrentProcess(), rghModules[i], 
                    &sMI, sizeof(MODULEINFO));

                // Check the Dummy function pointer against the boundaries of each module
                
                if(br)
                {
                    if( (LPVOID) Dummy >= sMI.lpBaseOfDll &&
                        (LPVOID) Dummy <= (BYTE*) sMI.lpBaseOfDll + sMI.SizeOfImage )
                    {
                        
                        // Found

                        break;
                    }
                }
            }
        }
        
        // Done with the dll

        FreeLibrary(hPSApiDll);
    }

    // Get the module name if a module was found. Otherwise use process name
    
    if(i < cModules)
    {
        m_hModule = rghModules[i];
    }
    else
    {
        m_hModule = NULL;
    }

    GetModuleFileNameA(m_hModule, 
        szFullName, ARRAY_ELEMENTS(szFullName));
        szFullName[ ARRAY_ELEMENTS(szFullName) - 1 ] = '\0';

    _splitpath(szFullName, NULL, NULL, m_szModuleName, NULL);
}


/*******************************************************************************

  CGetCurrentModuleName::Dummy
  (static)

  We use this dude to provide an address we can check against the dll 
  boundaries. It's a almost completely useless dude

******************************************************************************/

void CGetCurrentModuleName::Dummy()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\rptconn.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    rptconn.cpp

Abstract:

--*/

#include "stdafx.h"

XomDefineArea(ReportConnection);

/*****************************************************************************

CReportConnection::CReportConnection

Constructor

*****************************************************************************/
CReportConnection::CReportConnection() :
    CTCPCnt(10240)
{
    memset(m_cServerName, '\0', ARRAYSIZE(m_cServerName));

    m_iServerNameLength = ARRAYSIZE(m_cServerName);
    if (!GetComputerNameA(m_cServerName, &m_iServerNameLength))
    {
        strncpy(m_cServerName, "Unknown\0", 8);
        m_iServerNameLength = strlen(m_cServerName);
    }

    m_iComponentID = 0;
    m_fDroppedEvent = FALSE;
}


/*****************************************************************************

CReportConnection::~CReportConnection

Destructor

*****************************************************************************/
CReportConnection::~CReportConnection()
{
}

/*****************************************************************************

CReportConnection::SendConnect

Now that we're connected, send the connect message

*****************************************************************************/
HRESULT CReportConnection::SendConnect()
{
    HRESULT hr = S_OK;

    FILETIME ftNow;

    RPT_MSG_HEADER msgHeader;

    CTCPCntVarBuffer* pTCPBuffer = NULL;
    BYTE* pbBuffer = NULL;

    //
    // Send a Connect message
    //

    //
    // Create the TCPCntVarBuffer, check for null
    //
    // Note: we are not going to send the terminating null on the wire for the server name 
    // string.
    //
    pTCPBuffer = CTCPCntVarBuffer::CreateInstance( sizeof( RPT_MSG_HEADER ) 
        + sizeof( u_long ) 
        + m_iServerNameLength);  
    if( NULL == pTCPBuffer )
    {
        XomNtEvent( XEVENT_COMMON_CODE_91, "CXomReportTarget::InternalConnect() - CTCPCntVarBuffer::CreateInstance failed " );
        goto lDone;
    }

    pbBuffer = pTCPBuffer->GetBuffer();

    GetSystemTimeAsFileTime( &ftNow );

    //
    // Fill the RPT_MSG_HEADER struct
    //
    msgHeader.bMsgType = RPT_MSG_CONNECT;
    msgHeader.bReserved = 0;
    
    // Ok. Normally, usSize *should* be the size of the remainder of this message, not 
    // including headers. So it should be 4 + m_iServerNameLength. However, there's a bug 
    // here in the cleanser where the WireData definition of this structure in managed 
    // uses the usSize as the string length only. It does not include the 4 byte component 
    // id in it. So we have to match that here.
    //msgHeader.usSize = ( u_short) ( sizeof( u_long ) + m_iServerNameLength );

    msgHeader.usSize = ( u_short) ( m_iServerNameLength );
    msgHeader.ullTime = *( ( const ULONGLONG* ) &ftNow );

    //
    // Send the component id, then the server name in network byte order
    //
    memcpy( pbBuffer, &msgHeader, sizeof( RPT_MSG_HEADER ) );
    *((int *)(pbBuffer + sizeof( RPT_MSG_HEADER ) )) = m_iComponentID;
    memcpy(pbBuffer + sizeof( RPT_MSG_HEADER ) + sizeof( u_long ), m_cServerName, m_iServerNameLength);

    //
    // Finally, send the data to the report connection
    //
    hr = Send( pTCPBuffer, TRUE );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CODE_92, "CReportConnection::OnConnect() - CReportConnection::Send failed, hr=0x%08X", hr );
        goto lDone;
    }

lDone:

    SAFE_RELEASE( pTCPBuffer );

    return( hr );
}

/*****************************************************************************

CReportConnection::~InternalInit

This version allows the reuse of the object.

*****************************************************************************/
HRESULT CReportConnection::InternalInit(
    CServerSocket* pSocket,
    sockaddr_in* psin
)
{
    HRESULT hr = S_OK;

    if( NULL != m_pSocket )
    {
        m_pSocket->Release();
        m_pSocket = NULL;
    }

    hr = CTCPCnt::InternalInit(pSocket, psin);

    return( hr );
}

/*****************************************************************************

CReportConnection::Send

This function queues the incoming data for an async WSASend

*****************************************************************************/
HRESULT CReportConnection::Send(
    CTCPCntBuffer* pBuffer)
{
    return CReportConnection::Send(pBuffer, FALSE);
}

HRESULT CReportConnection::Send(
    CTCPCntBuffer* pBuffer,
    BOOL fSendFirst
)
{
    HRESULT hr = S_OK;

    if(pBuffer != CTCPCnt_DONE_ENTRY)
    {
        pBuffer->AddRef();
    }
    else
    {
        XomTrace(ReportConnection, L_LOW, 
            "[CReportConnection::Send] (%s) Queueing 'Done' mark ",
            m_szDebugName);
    }

    if(fSendFirst)
    {
        DWORD dwOldStart;
        DWORD dwNewStart;

        //
        // Add it to outbound queue at the head
        //
        m_lockBufferList.WriteLock();
        dwOldStart = m_dwOutboundBuffersStart;
        dwNewStart = (dwOldStart + CTCPCnt_MAX_OUTBOUND_BUFFERS - 1) % CTCPCnt_MAX_OUTBOUND_BUFFERS;

        if(dwNewStart == m_dwOutboundBuffersEnd)
        {
            //
            //
            // Outbound queue is full. Drop the previous tail to make room.
            //
            // There is always one "inaccessible" item in the queue (the item located at m_dwOutboundBuffersEnd)
            // so we are really freeing up what will be at the new end
            //
            DWORD dwNewEnd;
            dwNewEnd = (m_dwOutboundBuffersEnd + CTCPCnt_MAX_OUTBOUND_BUFFERS - 1) % CTCPCnt_MAX_OUTBOUND_BUFFERS;

            CTCPCntBuffer *pTailBuffer = m_rgOutboundBuffers[dwNewEnd];
            m_rgOutboundBuffers[dwNewEnd] = NULL;
            
            XomTrace(ReportConnection, L_LOW,
                "[CReportConnection::Send] (%s) Outbound queue is full. Dropping the tail (%p) for a required new head",
                m_szDebugName, pTailBuffer);

            if(pTailBuffer != CTCPCnt_DONE_ENTRY)
            {
                pTailBuffer->Release();
            }

            m_dwOutboundBuffersEnd = dwNewEnd;
        }

        //
        // Add the buffer to the queue, and update the queue pointer
        //
        m_rgOutboundBuffers[dwNewStart] = pBuffer;
        m_dwOutboundBuffersStart = dwNewStart;
        
        m_lockBufferList.WriteUnlock();
    }
    else
    {
        DWORD dwOldEnd;
        DWORD dwNewEnd;

        //
        // Add it to outbound queue at the tail
        //
        m_lockBufferList.WriteLock();
        dwOldEnd = m_dwOutboundBuffersEnd;
        dwNewEnd = (dwOldEnd + 1) % CTCPCnt_MAX_OUTBOUND_BUFFERS;
        
        if(dwNewEnd == m_dwOutboundBuffersStart)
        {
            //
            // Outbound queue is full. Drop the buffer.
            //
            
            if(pBuffer != CTCPCnt_DONE_ENTRY)
            {
                pBuffer->Release();
            }
            
            m_lockBufferList.WriteUnlock();

            XomTrace(ReportConnection, L_LOW,
                "[CReportConnection::Send] (%s) Outbound queue is full. Dropping buffer.",
                m_szDebugName);
        
            //
            // Fire an event saying we dropped an event.
            //
            if(TRUE != InterlockedExchange((LONG*)&m_fDroppedEvent, TRUE))
            {
                XomNtEvent( XEVENT_COMMON_COMM_34, "CReportConnection::Send() - Outbound queue is full (Size: %d). Dropping buffers.", CTCPCnt_MAX_OUTBOUND_BUFFERS );
            }
        
            goto lDone;
        }    

        //
        // If our queue is no longer full, fire an informational event indicating as such.
        //
        if(TRUE == InterlockedExchange((LONG*)&m_fDroppedEvent, FALSE))
        {
            XomNtEvent( XEVENT_COMMON_INFO_48, "CReportConnection::Send() - Outbound queue is no longer full (Size: %d). Accepting new buffers.", CTCPCnt_MAX_OUTBOUND_BUFFERS );
        }
        
        //
        // Add the buffer to the queue, and update the queue pointer
        //
        m_rgOutboundBuffers[dwOldEnd] = pBuffer;
        m_dwOutboundBuffersEnd = dwNewEnd;
        
        m_lockBufferList.WriteUnlock();
    }

    //
    // Keep things going if we are connected
    //

    if( S_CONNECTED == m_eState )
    {
        hr = StartSending();
        if( FAILED( hr ) )
        {
            XomTrace(
                ReportConnection,
                L_ERROR,
                "[CReportConnection::Send] (%s) StartSending failed, hr=0x%08x", 
                m_szDebugName, hr);

            Disconnect(hr);

            goto lDone;
        }
        else
        {
            //
            // If we had an error, we'll just try to keep going for now.
            //
            hr = S_OK;
        }
    }

lDone:

    return( hr );
}

/*****************************************************************************

CReportConnection::OnSocketConnect

This function is the async callback for connect. Here we will send the connect
message first, then send the rest of the messages.

*****************************************************************************/
void CReportConnection::OnSocketConnect(
    HRESULT hr,
    QWORD qwCallbackArg 
)
{
    if(FAILED(hr))
    {
        goto lDone;
    }

    InterlockedExchange((LONG*) &m_eState, (LONG)S_CONNECTED);

    hr = StartReceiving();

    if(FAILED(hr))
    {
        XomTrace(
            ReportConnection,
            L_ERROR,
            "[CReportConnection::OnSocketConnect] (%s) StartReceiving failed, hr=0x%08x",
            m_szDebugName,
            hr);

        goto lDone;
    }            

    hr = SendConnect();
    
    if(FAILED(hr))
    {
        XomTrace(
            ReportConnection,
            L_ERROR,
            "[CReportConnection::OnSocketConnect] (%s) OnConnect failed, hr=0x%08x",
            m_szDebugName,
            hr);

        goto lDone;
    }            

lDone:
    
    if(FAILED(hr))
    {
        Disconnect(hr);
    }

    if(SUCCEEDED(hr))
    {
        XomTrace(ReportConnection, L_NORMAL,
            "[CReportConnection::OnSocketConnect] (%s) OnConnect, addr = "DBGSINFMT", hr = 0x%08x",
            m_szDebugName,
            DBGSINPRM(&m_sinOut), hr);
    }
    else
    {
        XomTrace(ReportConnection, L_ERROR,
            "[CReportConnection::OnSocketConnect] (%s) OnConnect, addr = "DBGSINFMT", hr = 0x%08x",
            m_szDebugName,
            DBGSINPRM(&m_sinOut), hr);
    }

    Release();
}

/*****************************************************************************

CReportConnection::OnSocketSend

This function is the async callback for send. Here we will remove buffers
from the queue appropriately and initiate the subsequent send.

*****************************************************************************/
void CReportConnection::OnSocketSend(
    BYTE *pbBufferSent,
    DWORD cbToSend,
    DWORD cbSent,
    HRESULT hrSend,
    QWORD qwCallbackArg )
{
    HRESULT hr = S_OK;
    DWORD dwCount = (DWORD) qwCallbackArg;

    if( S_OK == hrSend )
    {
        //
        // Release the buffers and adjust the outgoing buffer list start
        //
        m_lockBufferList.WriteLock();
        
        if (m_eState == S_CONNECTED)
        {
            while(dwCount > 0)
            {
                XOMASSERT(m_dwOutboundBuffersStart != m_dwOutboundBuffersEnd);
            
                m_rgOutboundBuffers[m_dwOutboundBuffersStart]->Release();
            
                m_dwOutboundBuffersStart = (m_dwOutboundBuffersStart + 1) % 
                    CTCPCnt_MAX_OUTBOUND_BUFFERS;
            
                dwCount--;
            }
        }
        
        m_lockBufferList.WriteUnlock();
    }
    else
    {
        //
        // The socket is in a state where we won't be able to recover easily.
        // We will disconnect and wait for a new "healthy" socket
        //
        Disconnect(hrSend);
    }
        
    //
    // We're not sending anymore
    //
    
    InterlockedExchange(&m_fSending, FALSE);

    if( ( S_CONNECTED == m_eState ) && 0 != cbSent )
    {
        hr = StartSending();
        if( FAILED( hr ) )
        {
            XomTrace(
                ReportConnection,
                L_ERROR,
                "[CReportConnection::OnSocketSend] (%s) StartSending failed, hr=0x%08x", 
                m_szDebugName, hr);

            Disconnect(hr);

            goto lDone;
        }
        else
        {
            //
            // If we had an error, we'll just try to keep going for now.
            //
            hr = S_OK;
        }

#ifdef THROTTLE_READS
    
        //
        // Call StartReceiving to start receiving again if we stopped receiving
        // because the outbound queue was too big.
        //

        hr = StartReceiving();

        if( FAILED( hr ) )
        {
            XomTrace(ReportConnection, L_ERROR,
                "[CReportConnection::OnSocketSend] (%s) StartReceiving failed, hr=0x%08x",
                m_szDebugName,
                hr);

            Disconnect(hr);
            
            goto lDone;
        }    
        else
        {
            //
            // If we had an error, we'll just try to keep going for now.
            //
            hr = S_OK;
        }

#endif

    }

lDone:
    
    XomTrace(ReportConnection, L_LOW,
        "[CReportConnection::OnSocketSend] (%s) OnSend, addr = "DBGSINFMT", %d bytes, hr = 0x%08x",
        m_szDebugName,
        DBGSINPRM(&m_sinOut), cbSent, hrSend);

    Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\asyncfile.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

  asyncfile.h

Abstract:

  Async file class declaration.
  
--*/

#pragma once

class CAsyncFileIoContext :
    public CCompletionContext
{
public:

    CAsyncFileIoContext()
    {
        m_pHandler = NULL;
    }

    void Init(CCompletionHandler* pHandler)
    {
        m_pHandler = pHandler;
    }
    
    virtual CCompletionHandler* GetHandler()
    {
        return m_pHandler;
    }

    CCompletionHandler* m_pHandler;

};

class CAsyncFile : 
    public CCompletionHandler
{
public:
    IMPLEMENT_REFCOUNT;

    CAsyncFile();

    virtual ~CAsyncFile();
            
    HRESULT Init(
        LPCWSTR pwszFile,
        CCompletionPort* pIOCP,
        DWORD dwBufferSize );

    HRESULT Write(
        BYTE* pbBuffer,
        DWORD cbBuffer );

    LONGLONG GetSize()
    {
        return m_liFileOffset.QuadPart;
    }

protected:

    HRESULT KeepThingsMoving();

    HRESULT StartAsyncWriteOperation();

    virtual void OnIoCompletion( 
        DWORD dwError, 
        DWORD cbTransferred, 
        ULONG_PTR ulpKey,
        CCompletionContext *pCtx );

    CCompletionPort* m_pIOCP;

    HANDLE m_hFile;

    DWORD m_dwBytesPerSector;

    BYTE* m_pBuffer;
    DWORD m_cbBufferSize;

    DWORD m_cbBufferStart;
    DWORD m_cbBufferEnd;
    DWORD m_cbPreviousBufferEnd;

    xlocks::CSpinLock m_WriteAccessLock;

    BOOL m_fWritting;
    BOOL m_fDiskWriteError;

    CAsyncFileIoContext m_AsyncContext;

    LARGE_INTEGER m_liFileOffset;

    BYTE* m_pSectorBuffer;

    bool m_fWritePartialSector;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\rptconn.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef RPTCONN_H_INCLUDED
#define RPTCONN_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

typedef enum {
    RPT_MSG_NONE = 0,
    RPT_MSG_CONNECT = 1,
    RPT_MSG_DISCONNECT = 2,
    RPT_MSG_DATA = 3,
    RPT_MSG_KEEPALIVE = 4
} ReportMessageType;

// Note that usSize member is the size of the remainder of the message, not including the 
// header fields here (12 bytes currently).

#pragma pack(push, 1)
typedef struct {
    byte bMsgType;
    byte bReserved;
    u_short usSize;
    ULONGLONG ullTime;
} RPT_MSG_HEADER;
#pragma pack(pop)

/*****************************************************************************

CReportConnection

This class derives from CTcpCnt in order to handle a couple of things
differently from the base class. Primarily, it will be slightly more resilient
to network errors since we maintain one persistent connection for an extended
period of time.

*****************************************************************************/
class CReportConnection :
    public CTCPCnt
{
public:

    CReportConnection();

    virtual HRESULT Send(
        CTCPCntBuffer* pBuffer );

    virtual HRESULT Send(
        CTCPCntBuffer* pBuffer,
        BOOL fSendFirst );

	static const int MAX_SERVER_NAME_SIZE = 128; // Cap the server name length
	char m_cServerName[CReportConnection::MAX_SERVER_NAME_SIZE];
	DWORD m_iServerNameLength;

    int m_iComponentID;

protected:

    HRESULT SendConnect();

    virtual HRESULT InternalInit(
        CServerSocket* pSocket,
        sockaddr_in* psin );

    //
    // Destructor is protected. The only way to release this object is by
    // calling Release.
    //
    virtual ~CReportConnection();

    virtual void OnSocketConnect(
        HRESULT hr,
        QWORD qwCallbackArg );

    virtual void OnSocketSend(
        BYTE *pbBufferSent,
        DWORD cbToSend,
        DWORD cbSent,
        HRESULT hrSend,
        QWORD qwCallbackArg );

    BOOL m_fDroppedEvent;
};

#endif // RPTCONN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xmgmt.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xmgmt.cpp

Abstract:

  Implementation of CXomCentral.

--*/

#include "stdafx.h"


#pragma warning( disable: 4073)
    // Disable the init_seg pragma warning

#pragma init_seg(lib)
    // We want this object to be initialized as soon as possible

CXOMCentral g_xomcentral;
    // Global instance of CXOMCentral

//
// CXomCentral
//

CXOMCentral::CXOMCentral()
/*++

Routine Description:

  Constructor

Arguments:

  None

Return Value:

  None

--*/
{
    m_pIOCP = NULL;
    m_pSettings = NULL;
    m_pControl = NULL;
    m_pLogging = NULL;
    m_pConfig = NULL;
}

CXOMCentral::~CXOMCentral()
/*++

Routine Description:

  Destructor

Arguments:

  None

Return Value:

  None

--*/
{
    // Don't call Term() here because if Term() was not already called prior
    // to static destructors being called, there's a good chance that the
    // RockAll heap where the m_pIOCP completion port was allocated from
    // has already been destroyed.  When that's the case, calling Term()
    // here will only cause an AV when trying to operate on m_pIOCP
    // member variable.
}


HRESULT CXOMCentral::Init(
    IN LPCSTR pszSource
)
/*++

Routine Description:

  Initializes the Object. This method must be called when the module is being
  initialized.

Arguments:

  pszSource -  The source name that will be used in the NT log when logging
      events. It will also be used to identify this module to the control
      service (xmgmtsrv).

Return Value:

  HRESULT

--*/
{
    return Init(pszSource, NULL);
}

HRESULT CXOMCentral::Init(
    IN LPCSTR pszSource,
    IN LPCSTR pszIni
)
/*++

Routine Description:

  Initializes the Object. This method must be called when the module is being
  initialized.

Arguments:

  pszSource -  The source name that will be used in the NT log when logging
      events. It will also be used to identify this module to the control
      service (xmgmtsrv).

  pszIni - Full path or just the name of this module's INI file.

Return Value:

  HRESULT

--*/
{
    return Init(pszSource, pszIni, pszSource);
}

HRESULT CXOMCentral::Init(
    IN LPCSTR pszSource,
    IN LPCSTR pszIni,
    IN LPCSTR pszComponentName
)
/*++

Routine Description:

  Initializes the Object. This method must be called when the module is being
  initialized.

Arguments:

  pszSource -  The source name that will be used in the NT log when logging
      events. It will also be used to identify this module to the control
      service (xmgmtsrv).

  pszIni - Full path or just the name of this module's INI file.

  pszComponentName - the name of the component (from t_components, or
        the Component enum) that this executable corresponds to.

Return Value:

  HRESULT

--*/
{
    HRESULT hr;
    BOOL fTryAgain = 1;

    //
    // Initialize the NT logging part of the logging stuff. We can't initialize
    // the entire logging stuff because it depends on the settings, but we also
    // would like to be able to log NT events early on to flag any
    // initialization problems.
    //

    m_pLogging = new CXomLoggingControl;

    if(NULL == m_pLogging)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    hr = m_pLogging->InitNTLogTarget(pszSource);

    if(FAILED(hr))
    {
        goto lDone;
    }

    //
    // Create a completion port object that will create the thread that we are
    // going to use to do all the async data stuff of this framework.
    //
    // This completion port is used for all xmgmt commands, xmgmt file logging, etc. We 
    // need more than 1 thread so that any commands (like "e :xkdc reload") that log stuff 
    // won't deadlock themselves when CAsyncFile runs out of buffer space.

    hr = CCompletionPort::CreateInstance(
        0, 2, THREAD_PRIORITY_HIGHEST, &m_pIOCP);

    if(FAILED(hr))
    {
        XomNtEvent( XEVENT_MGMT_INIT_FAILURE, "[CXOMCentral::Init] Failed to create completion port. hr = 0x%08x", hr );
        goto lDone;
    }

 lTryAgain:
    //
    // Create an instance of the Config class
    //

    hr = CoCreateInstance( __uuidof(ConfigInterop), NULL, CLSCTX_ALL, __uuidof(IConfig), (void**)&m_pConfig);
    if (FAILED(hr))
    {
        if ( CO_E_NOTINITIALIZED == hr && fTryAgain )
        {
            fTryAgain = FALSE;

            XomNtEvent( XEVENT_COMMON_CODE_97, "[CXOMCentral::Init] Component needs to call CoInitialize prior to calling g_xomcentral.Init.  Calling CoInitialize implicitly..." );

            hr = CoInitialize(NULL);
            if (FAILED(hr))
            {
                XomNtEvent( XEVENT_COMMON_CONFIG_291, "[CXOMCentral::Init] Failed to CoInitialize. hr = 0x%08x", hr );
                goto lDone;
            }

            // CoInitialize has been called... try CoCreateInstance one more time
            goto lTryAgain;
        }

        XomNtEvent( XEVENT_COMMON_CONFIG_292, "[CXOMCentral::Init] Failed to CoCreateInstance of ConfigInterop. hr = 0x%08x", hr );
        goto lDone;
    }

    // because we are calling into CommonConfig.dll, the Config class 
    // cannot automatically derive our component name from the assembly 
    // name. Therefore, we set it explicity to the source specified in 
    // this function call.
    //
    // Note: This means C++ components must pass a source that matches
    // one of the enums values in the Component enum, or else 
    // Config.Component will resolve to Component.unknown, and component
    // specific overrides will not work.
    //
    // Note: This also means that C++ components must call this method
    // before getting any settings from the Config class, or else
    // the component will still resolve to Component.unknown, and 
    // component specific overrides will not work.
    hr = m_pConfig->put_ComponentName(CComBSTR(pszComponentName));
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_293, "[CXOMCentral::Init] m_pConfig->put_ComponentName failed. hr = 0x%08x", hr );
        goto lDone;
    }

    //
    // Initialize settings
    //

    m_pSettings = new CXomSettings;

    if(NULL == m_pSettings)
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent( XEVENT_MGMT_INIT_FAILURE_1, "[CXOMCentral::Init] m_pSettings = new CXomSettings failed. hr = 0x%08x", hr );
        goto lDone;
    }

    hr = m_pSettings->Init(pszIni);

    if(FAILED(hr))
    {
        XomNtEvent( XEVENT_MGMT_INIT_FAILURE_2, "[CXOMCentral::Init] Failed to initialize settings framework. hr = 0x%08x", hr );
        goto lDone;
    }

    //
    // Initialize the remote admin facilities.
    //

    m_pControl = new CXomControl;

    if(NULL == m_pControl)
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent( XEVENT_MGMT_INIT_FAILURE_3, "[CXOMCentral::Init] m_pControl = new CXomControl failed. hr = 0x%08x", hr );
        goto lDone;
    }

    hr = m_pControl->Init(m_pIOCP, pszSource);

    if(FAILED(hr))
    {
        XomNtEvent( XEVENT_MGMT_INIT_WARNING, "[CXOMCentral::Init] Failed to initialize remote admin framework. "
            "Remote administration won't be available. hr = 0x%08x", hr );

        //
        // Not a fatal error
        //

        hr = S_OK;
    }

    //
    // Now that we have the settings and the admin stuff, we can initialize
    // the logging facilities.
    //
    hr = m_pLogging->Init(m_pIOCP);

    if(FAILED(hr))
    {
        XomNtEvent( XEVENT_MGMT_INIT_FAILURE_4, "[CXOMCentral::Init] Failed to initialize logging framework. hr = 0x%08x", hr );
        goto lDone;
    }

lDone:

    return hr;
}

HRESULT CXOMCentral::Term()
/*++

Routine Description:

  Terminates the management framework. Call this method when the module is
  terminating. After calling this method, don't use the management framework
  anymore.

Arguments:

  None

Return Value:

  HRESULT

--*/
{
    //
    // Shutdown
    //

    if(m_pLogging != NULL)
    {
        m_pLogging->Terminate();
    }

    if(m_pControl != NULL)
    {
        m_pControl->Terminate();
    }

    if(m_pSettings != NULL)
    {
        m_pSettings->Terminate();
    }

    if(m_pIOCP != NULL)
    {
        m_pIOCP->Shutdown();
    }

    //
    // Release
    //

    SAFE_RELEASE(m_pIOCP);
    SAFE_RELEASE(m_pSettings);
    SAFE_RELEASE(m_pLogging);
    SAFE_RELEASE(m_pControl);
    SAFE_RELEASE(m_pConfig);

    return S_OK;
}

HRESULT CXOMCentral::GetSetting(
    CComBSTR enumSetting,
    OUT LPSTR *ppszSetting )
{
    USES_CONVERSION;

    LPSTR pszSetting = NULL;
    CComBSTR bstrValue;
    HRESULT hr = E_FAIL;

    *ppszSetting = NULL;

    if ( m_pConfig != NULL )
    {
        hr = m_pConfig->GetSetting( enumSetting, &bstrValue );

        if ( SUCCEEDED(hr) )
        {
            // If setting does not exist in ConfigDb, value is NULL and S_OK
            // is returned.
            if ( NULL == bstrValue.m_str )
            {
                hr = E_FAIL;
            }
            else
            {
                pszSetting = _strdup(W2A(bstrValue.m_str));
                *ppszSetting = pszSetting;
            }
        }
    }

    return hr;
}

HRESULT CXOMCentral::GetSetting(
    LPCSTR pszName,
    OUT CXomSetting** ppSetting )
{
    return m_pSettings != NULL ?
        m_pSettings->GetSetting(pszName, ppSetting) :
        E_FAIL;
}

HRESULT CXOMCentral::GetMultiSetting(
    CComBSTR enumSetting,
    OUT SAFEARRAY **ppsaSettings )
{
    HRESULT hr = E_FAIL;

    if ( m_pConfig != NULL )
    {
        hr = m_pConfig->GetMultiSetting( enumSetting, ppsaSettings );
    }

    return hr;
}


HRESULT CXOMCentral::RegisterControlCallback(
    CXomControlCallback* pCallback )
{
    return m_pControl != NULL ?
        m_pControl->RegisterControlCallback(pCallback) :
        E_FAIL;
}

HRESULT CXOMCentral::UnregisterControlCallback(
    CXomControlCallback* pCallback )
{
    return m_pControl != NULL ?
        m_pControl->UnregisterControlCallback(pCallback) :
        E_FAIL;
}

LPCSTR CXOMCentral::GetProcessName()
{
    return m_pControl != NULL ?
        m_pControl->GetProcessName() :
        NULL;
}

LPCSTR CXOMCentral::GetComponentName()
{
    return m_pControl != NULL ?
        m_pControl->GetComponentName() :
        NULL;
}

BOOL CXOMCentral::CheckOverrideList(
    LPCSTR pszFile,
    DWORD dwLine,
    BOOL* pfLog )
{
    if(m_pLogging)
    {
        return m_pLogging->CheckOverrideList(pszFile, dwLine, pfLog);
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomadmin.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomadmin.h

Abstract:

--*/

#pragma once

class CXomAdminSocketInputStream
{
public:

    CXomAdminSocketInputStream()
    {
        m_socket = INVALID_SOCKET;
        m_cbStart = 0;
        m_cbEnd = 0;
    }

    void Init(SOCKET _socket)
    {
        m_socket = _socket;
    }

    CHAR ReadByte()
    {
        if(m_cbStart == m_cbEnd)
        {
            if(ReadMore() != S_OK)
            {
                return (CHAR) -1;
            }
        }
        
        CHAR ret = m_buffer[m_cbStart];
        m_cbStart = (m_cbStart + 1) % sizeof(m_buffer);
        return ret;
    }

    HRESULT ReadBytes(BYTE* pBuffer, DWORD cbBuffer);
    
    HRESULT SkipBytes(DWORD cbBytes);
    
    HRESULT ReadLine(LPSTR pszBuffer, DWORD cbBuffer);

protected:

    HRESULT ReadMore();

    SOCKET m_socket;
    BYTE m_buffer[256];
    DWORD m_cbStart;
    DWORD m_cbEnd;
    
};

class CReadCallback
{
protected:
    CReadCallback () {};
public:
    virtual HRESULT OnReadResponseSize(DWORD swSize) = 0;
    virtual HRESULT OnReadResponse(LPCBYTE pbDataRead, DWORD cDataRead) = 0;
};

typedef
void
(WINAPI *LPREADCALLBACK)(
    LPBYTE pbDataRead,
    int cDataRead
    );


class CXomAdminSession
{
public:

    CXomAdminSession();

    ~CXomAdminSession();

    HRESULT Init(
        LPCSTR pszAddr );

    HRESULT SendRequest(
        IN LPCSTR pszRequest,
        OUT LPSTR pszResponse,
        IN DWORD cbResponseBuffer,
        IN DWORD* pcbWritten,
        HRESULT* phrRequest);

    HRESULT CXomAdminSession::SendRequest(
        IN LPCSTR pszRequest,
        CReadCallback *pCallback,
        HRESULT* phrRequest);

protected:

    SOCKET m_socket;

    CXomAdminSocketInputStream m_stin;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomassert.h ===
// ----------------------------------------------------------------------------
// xomassert.h
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#ifndef __XOMASSERT_H__


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <process.h>
#include <psapi.h>
#include <limits.h>
#include <atlbase.h>
#include <atlcom.h>
#include <wchar.h>

#include <xlocks.h>

#if defined(_XALLOC_CRT_)
#define XAlloc(nSize) _aligned_malloc(nSize, MEMORY_ALLOCATION_ALIGNMENT)
#define XFree(pv) if (pv != NULL) _aligned_free(pv)
#define XDumpLeaks()
#endif
#if defined(_XALLOC_ROCKALL_)
#include "xalloc.h"
#endif

#include <xeventids.h>
#include <wmsstd.h>
#include <addref.h>
#include <compport.h>
#include <servpipe.h>
#include <vptrlist.h>
#include <vptrarr.h>
#include <vavltable.h>
#include <tcpcnt.h>

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
#endif // !ARRAY_ELEMENTS

// Pull in the public XMgmt header
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;

#include <atlsafe.h>
#include <xmgmt.h>
#include <commonconfig.h>


// Now pull in our private XMgmt headers
#include "asyncfile.h"
#include "curmod.h"
#include "EventThrottle.h"
#include "xomadmin.h"
#include "xomassert.h"
#include "xomcmmon.h"
#include "xomcontrolprot.h"
#include "xomcontrol.h"
#include "xomlggng.h"
#include "xomfiletarget.h"
#include "xomremotetarget.h"
#include "xomsettings.h"
#include "tcpcnt.h"
#include "ConfigListener.h"
#include "rptconn.h"
#include "xomrpttarget.h"

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
#endif

#define GOTO_LDONE_IF_FAILED_HR(op) \
    if(FAILED(hr = (op))) \
    { \
        XomNtEvent(XEVENT_MGMT_GENERIC_ERROR, "Management framework found an error: hr = 0x%08x, Op = \n%s", hr, #op); \
        goto lDone; \
    }

#define GOTO_LDONE_IF_FAILED_ALLOC(op) \
    if(NULL == (op)) \
    { \
        hr = E_OUTOFMEMORY; \
        XomNtEvent(XEVENT_MGMT_GENERIC_ERROR_1, "Management framework found an error: hr = 0x%08x, Op = \n%s", hr, #op); \
        goto lDone; \
    }

#define GOTO_LDONE_IF_FAILED_ASSERT(op) \
    if(!(op)) \
    { \
        hr = E_UNEXPECTED; \
        XomNtEvent(XEVENT_MGMT_GENERIC_ERROR_2, "Management framework found an error: Assert failed: %s", #op); \
        goto lDone; \
    }

#define GOTO_LDONE_IF(op, hrIf) \
    if(op) \
    { \
        hr = hrIf; \
        XomNtEvent(XEVENT_MGMT_GENERIC_ERROR_3, "Management framework found an error: hr = 0x%08x, Op = \n%s", hr, #op); \
        goto lDone; \
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomcmmon.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomcontrol.cpp

Abstract:

--*/

#include "stdafx.h"


int safe_vsnprintf(char* pszBuffer, size_t cchBuffer, const char* pszFormat, va_list args)
{
    // Return value from _vsnprintf is either -1 or the number of bytes written.
    int iRes = _vsnprintf_s(pszBuffer, cchBuffer, _TRUNCATE, pszFormat, args);

    // -1 means that truncation occured
    if(iRes == -1)
    {
        // Corner Case: if ccbBuffer is 0, then we can't safely touch the string
        if(cchBuffer == 0)
        {
            iRes = 0;
        }
        else
        {
            // Fix up the return value to hide that truncation occured
            iRes = cchBuffer - 1;
            
            // In theory, we don't have to do this
            pszBuffer[iRes] = '\0';
        }
    }

    return iRes;
}

int safe_snprintf(char* pszBuffer, size_t cchBuffer, const char* pszFormat, ...)
{
    va_list marker;
    int iRes;

    va_start(marker, pszFormat);

    iRes = safe_vsnprintf(pszBuffer, cchBuffer, pszFormat, marker);

    va_end(marker);

    return iRes;
}

int safe_vsnwprintf(WCHAR* pwszBuffer, size_t cchBuffer, LPCWSTR pwszFormat, va_list args)
{
    // Return value from _vsnprintf is either -1 or the number of bytes written.
    int iRes = _vsnwprintf_s(pwszBuffer, cchBuffer, _TRUNCATE, pwszFormat, args);

    // -1 means that truncation occured
    if(iRes == -1)
    {
        // Corner Case: if ccbBuffer is 0, then we can't safely touch the string
        if(cchBuffer == 0)
        {
            iRes = 0;
        }
        else
        {
            // Fix up the return value to hide that truncation occured
            iRes = cchBuffer - 1;
            
            // In theory, we don't have to do this
            pwszBuffer[iRes] = L'\0';
        }
    }

    return iRes;
}

int safe_snwprintf(WCHAR* pwszBuffer, size_t cchBuffer, LPCWSTR pwszFormat, ...)
{
    va_list marker;
    int iRes;

    va_start(marker, pwszFormat);

    iRes = safe_vsnwprintf(pwszBuffer, cchBuffer, pwszFormat, marker);

    va_end(marker);

    return iRes;
}

void ParseIPPortString(LPCSTR pszIPPort, DWORD* pAddr, WORD* pPort)
{
    char szStr[256];
    char* pColon;
    lstrcpynA(szStr, pszIPPort, ARRAY_ELEMENTS(szStr));
    pColon = strchr(szStr, ':');

    if(pColon != NULL)
    {
        *pColon = '\0';
        pColon++;
        *pPort = htons((WORD)(atoi(pColon)));
    }
    else
    {
        *pPort = 0;
    }

    *pAddr = inet_addr(szStr);

    if(-1 == *pAddr)
    {
        *pAddr = 0;
    }
}


CXomOption::CXomOption()
{
    m_cSettings = 0;
}

CXomOption::CXomOption(DWORD dwId, DWORD dwData)
{
    m_rgSettings[0].dwId = dwId;
    m_rgSettings[0].eType = T_DWORD;
    m_rgSettings[0].dwData = dwData;
    m_cSettings = 1;
}

CXomOption::CXomOption(DWORD dwId, void* pData)
{
    m_rgSettings[0].dwId = dwId;
    m_rgSettings[0].eType = T_POINTER;
    m_rgSettings[0].pData = pData;
    m_cSettings = 1;
}

CXomOption::CXomOption(DWORD dwId, LPCSTR pszData)
{
    m_rgSettings[0].dwId = dwId;
    m_rgSettings[0].eType = T_STR;
    m_rgSettings[0].pszData = pszData;
    m_cSettings = 1;
}

CXomOption::CXomOption(DWORD dwId, LPCWSTR pwszData)
{
    m_rgSettings[0].dwId = dwId;
    m_rgSettings[0].eType = T_WSTR;
    m_rgSettings[0].pwszData = pwszData;
    m_cSettings = 1;
}

CXomOption CXomOption::operator+( CXomOption& ob )
{
    XOMASSERT(m_cSettings + ob.m_cSettings <= c_xomMaxSettings);

    CXomOption oRet;
    memcpy(&(oRet.m_rgSettings), &m_rgSettings, sizeof(setting_t) * m_cSettings);
    memcpy(&(oRet.m_rgSettings[m_cSettings]), &(ob.m_rgSettings), sizeof(setting_t) * ob.m_cSettings);
    oRet.m_cSettings = m_cSettings + ob.m_cSettings;
    return oRet;
}


CXomParamList::CXomParamList()
{
    m_cParams = 0;
    m_pszString = NULL;
}

CXomParamList::~CXomParamList()
{
    Reset();
}

void CXomParamList::Reset()
{
    if(m_pszString != NULL)
    {
        free(m_pszString);
        m_pszString = NULL;
    }

    m_cParams = 0;
}

HRESULT CXomParamList::Parse(
    LPCSTR pszString)
{
    HRESULT hr = S_OK;
    CHAR* p1;
    CHAR* p2;

    Reset();

    m_pszString = _strdup(pszString);

    if(NULL == m_pszString)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    p1 = m_pszString;

    while(*p1 != '\0' && m_cParams < c_xomMaxParams)
    {
        // Remove leading spaces
        for(; *p1 != '\0' && ' ' == *p1; p1++);

        if('\0' == *p1)
        {
            break;
        }

        // That's the beginning of a parameter. Find the end.
        if(*p1 != '"')
        {
            // Parameter is simple. It ends at the first space or at the
            // end of the string.

            p2 = p1;

            for(; *p2 != '\0' && *p2 != ' '; p2++);

            m_rgpszParams[m_cParams] = p1;

            m_cParams++;

            if(*p2 != '\0')
            {
                *p2 = '\0';
                p1 = p2 + 1;
            }
            else
            {
                break;
            }
        }
        else
        {
            // Parameter is delimited by double-quotes.
            p2 = ++p1;

            for(; *p2 != '\0' && *p2 != '"'; p2++);

            if(*p2 != '"')
            {
                hr = E_INVALIDARG;
                goto lDone;
            }

            *p2 = '\0';

            m_rgpszParams[m_cParams] = p1;

            m_cParams++;

            p1 = p2 + 1;
        }
    }

lDone:

    return hr;
}


CXomNameValuePairList::CXomNameValuePairList()
{
    m_pszString = NULL;
    m_cPairs = 0;
    m_pszDefaultString = NULL;
    m_cDefaultPairs = 0;
}

CXomNameValuePairList::~CXomNameValuePairList()
{
    Reset();
}

void CXomNameValuePairList::Reset()
{
    if(m_pszString != NULL)
    {
        free(m_pszString);
        m_pszString = NULL;
    }
    m_cPairs = 0;
    memset( m_rgPairs, 0, sizeof(pair_t) * c_xomMaxPairs );

    if(m_pszDefaultString != NULL)
    {
        free(m_pszDefaultString);
        m_pszDefaultString = NULL;
    }
    m_cDefaultPairs = 0;
    memset( m_rgDefaultPairs, 0, sizeof(pair_t) * c_xomMaxPairs );
}


HRESULT CXomNameValuePairList::Parse(
        BSTR szString,
        CHAR chSeparator)
{
    USES_CONVERSION;

    LPCSTR pszString = W2A(szString);
    return Parse(pszString, chSeparator);
}

HRESULT CXomNameValuePairList::Parse(
        BSTR szString,
        BSTR szDefault,
        CHAR chSeparator)
{
    USES_CONVERSION;

    LPCSTR pszString = W2A(szString);
    LPCSTR pszDefault = W2A(szDefault);
    return Parse(pszString, pszDefault, chSeparator);
}

HRESULT CXomNameValuePairList::Parse(
        LPCSTR pszString,
        CHAR chSeparator)
{
    Reset();

    return _Parse(
        pszString,
        chSeparator,
        &m_pszString,
        &m_cPairs,
        m_rgPairs,
        _countof(m_rgPairs)
        );
}

HRESULT CXomNameValuePairList::Parse(
        LPCSTR pszString,
        LPCSTR pszDefault,
        CHAR   chSeparator)
{
    HRESULT hr;

    Reset();

    hr = _Parse(
        pszString,
        chSeparator,
        &m_pszString,
        &m_cPairs,
        m_rgPairs,
        _countof(m_rgPairs)
        );
    if (SUCCEEDED(hr) && pszDefault != NULL)
    {
        hr = _Parse(
            pszDefault,
            chSeparator,
            &m_pszDefaultString,
            &m_cDefaultPairs,
            m_rgDefaultPairs,
            _countof(m_rgDefaultPairs)
            );
    }
    return hr;
}

HRESULT CXomNameValuePairList::_Parse(
        LPCSTR  pszString,
        CHAR    chSeparator,
        LPSTR  *pszLocation,
        DWORD  *cPairs,
        pair_t *rgPairs,
        DWORD   maxPairs)
{
    char  * pPars1;
    HRESULT hr = S_OK;

    //
    // Sanity check
    //

    if (pszLocation == NULL || cPairs == NULL || rgPairs == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    //
    // Copy string
    //

    *pszLocation = _strdup(pszString);
    if (NULL == pszLocation)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    //
    // Parse it
    //

    pPars1  = *pszLocation;
    *cPairs = 0;

    //
    // Skip leading spaces
    //

    for (; '\0' != *pPars1 && ' ' == *pPars1 ; pPars1++);

    //
    // Process until the end of the string or there is
    // no more room to store pairs.
    //

    while (*pPars1 != '\0' && *cPairs < maxPairs)
    {
        //
        // This is where the name starts
        //

        rgPairs[*cPairs].pszName = pPars1;

        //
        // Find the end of the name
        //

        for (; *pPars1 != '\0' && *pPars1 != '=' && *pPars1 != chSeparator; pPars1++);

        //
        // Process the character that ended the name
        //

        if ('=' == *pPars1)
        {
            // This name has a corresponding value

            //
            // Mark the end of the name
            //

            *pPars1 = '\0';
            pPars1++;

            //
            // Skip trailing spaces
            //

            for (; '\0' != *pPars1 && ' ' == *pPars1 ; pPars1++);

            //
            // Check to see if the value is quoted
            //

            if('"' == *pPars1)
            {
                //
                // Yes it is
                //

                pPars1++;

                //
                // The value starts right after the first quote
                //

                rgPairs[*cPairs].pszValue = pPars1;

                //
                // The value ends at the next quote
                //

                for (; *pPars1 != '\0' && *pPars1 != '"'; pPars1++);
                if (*pPars1 != '"')
                {
                    //
                    // Value must finish with a quote
                    //

                    hr = E_INVALIDARG;
                    goto lDone;
                }

                //
                // That's the end of the value
                //

                *pPars1 = '\0';
                pPars1++;

                //
                // Skip trailing spaces
                //

                for (; '\0' != *pPars1 && ' ' == *pPars1 ; pPars1++);

                //
                // Skip separator.
                //

                if(chSeparator == *pPars1)
                {
                    *pPars1 = '\0';
                    pPars1++;
                }
            }
            else
            {
                //
                // This value is a standard non delimited value and starts
                // right here.
                //

                rgPairs[*cPairs].pszValue = pPars1;

                //
                // Find the end of the value
                //

                for(; *pPars1 != '\0' && !(*pPars1 == chSeparator && *(pPars1-1) != '\\'); pPars1++);

                //
                // Mark the end of the value and skip the semi-colon.
                //

                if(chSeparator == *pPars1)
                {
                    *pPars1 = '\0';
                    pPars1++;
                }
            }
        }
        else
        {
            //
            // This name doesn't have a corresponding value
            //

            rgPairs[*cPairs].pszValue = NULL;

            //
            // Mark the end of the name
            //

            if(chSeparator == *pPars1)
            {
                *pPars1 = '\0';
                pPars1++;
            }
        }

        //
        // Increment the number of pairs we hae processed
        //

        ++(*cPairs);

        //
        // Skip trailing spaces
        //
        for (; '\0' != *pPars1 && ' ' == *pPars1 ; pPars1++);
    }

    // If we hit the end of the memory, but didn't finish parsing the list
    // fail the call.
    if (*pPars1 != '\0' && *cPairs >= maxPairs)
    {
        hr = E_UNEXPECTED;
    }

lDone:
    return hr;

}

LPCSTR CXomNameValuePairList::GetValueByName( LPCSTR pszName )
{
    DWORD nPair;

    for(nPair=0; nPair < m_cPairs; nPair++)
    {
        if(_stricmp(m_rgPairs[nPair].pszName, pszName) == 0)
        {
            return m_rgPairs[nPair].pszValue;
        }
    }

    for (nPair=0; nPair < m_cDefaultPairs; nPair++)
    {
        if(_stricmp(m_rgDefaultPairs[nPair].pszName, pszName) == 0)
        {
            m_rgDefaultPairs[nPair].bUsed = true;
            return m_rgDefaultPairs[nPair].pszValue;
        }
    }

    return NULL;
}

LPSTR CXomNameValuePairList::GetNameValuePairString( LPCSTR pszSeperator)
{
    DWORD dwLen = 0;
    DWORD dwSeperator = strlen(pszSeperator);
    DWORD nPair;
    LPSTR pszNameValue;

    //
    // Calculate the number of bytes required for the full string
    //

    for (nPair = 0; nPair < m_cPairs; nPair++)
    {
        dwLen += strlen(m_rgPairs[nPair].pszName);
        if (m_rgPairs[nPair].pszValue != NULL)
        {
            dwLen += strlen(m_rgPairs[nPair].pszValue);
            dwLen += 1; // =
        }
        dwLen += dwSeperator; // seperator
    }

    for (nPair = 0; nPair < m_cDefaultPairs; nPair++)
    {
        if (m_rgDefaultPairs[nPair].bUsed == false)
        {
            continue;
        }
        dwLen += strlen(m_rgDefaultPairs[nPair].pszName);
        if (m_rgDefaultPairs[nPair].pszValue != NULL)
        {
            dwLen += strlen(m_rgDefaultPairs[nPair].pszValue);
            dwLen += 1; // =
        }
        dwLen += dwSeperator; // seperator
    }
    dwLen += 1; // terminator

    //
    // Allocate enough space
    //

    pszNameValue = (LPSTR) malloc( dwLen );
    if (pszNameValue == NULL)
    {
        return NULL;
    }
    memset(pszNameValue, 0, dwLen );

    //
    // Copy in all of the used parameters
    //

    for (nPair = 0; nPair < m_cPairs; nPair++)
    {
        strcat( pszNameValue, m_rgPairs[nPair].pszName );
        if (m_rgPairs[nPair].pszValue != NULL)
        {
            strcat( pszNameValue, "=" );
            strcat( pszNameValue, m_rgPairs[nPair].pszValue );
        }
        strcat( pszNameValue, pszSeperator );
    }

    for (nPair = 0; nPair < m_cDefaultPairs; nPair++)
    {
        if (m_rgDefaultPairs[nPair].bUsed == false)
        {
            continue;
        }
        strcat( pszNameValue, m_rgDefaultPairs[nPair].pszName );
        if (m_rgDefaultPairs[nPair].pszValue != NULL)
        {
            strcat( pszNameValue, "=" );
            strcat( pszNameValue, m_rgDefaultPairs[nPair].pszValue );
        }
        strcat( pszNameValue, pszSeperator );
    }

    return pszNameValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomadmin.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomadmin.cpp

Abstract:

--*/

#include "stdafx.h"


CXomAdminSession::CXomAdminSession()
{
    m_socket = INVALID_SOCKET;
}

CXomAdminSession::~CXomAdminSession()
{
    if(m_socket != INVALID_SOCKET)
    {
        closesocket(m_socket);
    }
}

HRESULT CXomAdminSession::Init(
    LPCSTR pszAddr )
{
    HRESULT hr = S_OK;
    
    sockaddr_in sinXmgmt;
    ZeroMemory(&sinXmgmt, sizeof(sinXmgmt));

    sinXmgmt.sin_family = AF_INET;
    sinXmgmt.sin_port = htons(XOMCTRL_ADMIN_PORT);

    // The address in pszAddress could either be in the IP format or it
    // could be the hostname. Let's try it as an IP first.
    
    sinXmgmt.sin_addr.s_addr = inet_addr(pszAddr);

    if( 0 == sinXmgmt.sin_addr.s_addr ||
        INADDR_NONE == sinXmgmt.sin_addr.s_addr )
    {
        // Hmmm, it's not in the IP format or it's an invalid IP. Let's 
        // assume that it is a hostname. Now we need to figure out its IP.

        hostent* pHost = gethostbyname(pszAddr);

        if(NULL == pHost)
        {
            hr = HRESULT_FROM_WIN32(WSAGetLastError());
            goto lDone;
        }

        sinXmgmt.sin_addr.s_addr = ((in_addr*)pHost->h_addr_list[0])->s_addr;
    }

    // Now create the socket and connect to the xmgmt service

    m_socket = socket(AF_INET, SOCK_STREAM, 0);

    if(m_socket == INVALID_SOCKET)
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        goto lDone;
    }

    if(SOCKET_ERROR == connect(m_socket, (const sockaddr*) &sinXmgmt, sizeof(sinXmgmt)))
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        goto lDone;
    }

    m_stin.Init(m_socket);

    // We're ready to go
    
lDone:        


    return hr;
}

class CFillResponseBuffer : public CReadCallback
{
private:
    LPSTR m_pszResponse;
    DWORD m_cbSize;
    DWORD m_cbWritten;
public:
    CFillResponseBuffer(LPSTR pszResponseBuffer, DWORD cbSize)
        : m_pszResponse(pszResponseBuffer),
        m_cbSize(cbSize),
        m_cbWritten(0)
    {
    }

    ~CFillResponseBuffer()
    {
        m_pszResponse[m_cbWritten] = '\0';
    }

    HRESULT OnReadResponseSize(DWORD cbSize)
    {
        return (m_cbSize - m_cbWritten > cbSize) ? S_OK : E_FAIL;
    }

    HRESULT OnReadResponse(LPCBYTE pbDataRead, DWORD cDataRead)
    {
        HRESULT hr = S_OK;

        if (m_cbSize - m_cbWritten > cDataRead)
        {
            memcpy(m_pszResponse + m_cbWritten, pbDataRead, cDataRead);
            m_cbWritten += cDataRead;
        }
        else
        {
            hr = E_FAIL;
        }

        return hr;
    }

    DWORD GetWrittenBytes()
    {
        return m_cbWritten;
    }
};

HRESULT CXomAdminSession::SendRequest(
    IN LPCSTR pszRequest,
    OUT LPSTR pszResponse,
    IN DWORD cbResponseBuffer,
    IN DWORD* pcbWritten,
    HRESULT* phrRequest
)
{
    CFillResponseBuffer oFill(pszResponse, cbResponseBuffer);
    HRESULT hr = SendRequest(pszRequest, pszResponse != NULL ? &oFill : NULL, phrRequest);

    if (pcbWritten)
        *pcbWritten = oFill.GetWrittenBytes();

    return hr;
}

HRESULT CXomAdminSession::SendRequest(
    IN LPCSTR pszRequest,
    CReadCallback *pCallback,
    HRESULT* phrRequest
)
{
    XOMASSERT(m_socket != INVALID_SOCKET);

    HRESULT hr = S_OK;
    char* pBuffer = NULL;
    DWORD cbBuffer = 0;
    DWORD cbWritten = 0;

    BYTE pbResponse[1024];

    DWORD cbRequest = strlen(pszRequest);
    cbBuffer = cbRequest + 2;

    pBuffer = new char[cbBuffer];
    if ( NULL == pBuffer )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // The request is a command string followed by a \r\n pair.
    memcpy(pBuffer,pszRequest, cbRequest);
    pBuffer[cbRequest] = '\r';
    pBuffer[cbRequest+1] = '\n';
    
    // Send it to xmgmt
    if(SOCKET_ERROR == send(m_socket, pBuffer, cbBuffer, 0))
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        goto lDone;
    }

    // The response will come in the form of multiple response blocks 
    // followed by a result block that will mark the end of the response.
    // The response block is in the form of:
    // Size=<size-of-response-block-in-bytes>\r\n<response-block>
    // The result block is in the form of:
    // Result=<unsigned-long-result-code>\r\n
    // Ok. Now let us read the response:

    
    for(;;)
    {
        CHAR szLine[256];

        hr = m_stin.ReadLine(szLine, sizeof(szLine));

        if(FAILED(hr))
        {
            goto lDone;
        }

        // Break line into word and number

        CHAR* pWord = szLine;
        CHAR* pNumber = strchr(szLine, '=');

        if(NULL == pNumber)
        {
            // Invalid response.
            hr = E_FAIL;
            goto lDone;
        }

        *pNumber = '\0';
        pNumber++;

        DWORD dwNumber = (unsigned long) strtoul(pNumber, NULL, 10);

        // Word must be either 'Size' or 'Result'

        if(_stricmp(pWord, "Size") == 0)
        {
            if(pCallback != NULL)
            {
                hr = pCallback->OnReadResponseSize(dwNumber);
                if(hr == S_OK)
                {
                    while (dwNumber > 0)
                    {
                        DWORD numRead = min(dwNumber, ARRAYSIZE(pbResponse));
                        hr = m_stin.ReadBytes(pbResponse, numRead);

                        if(FAILED(hr))
                        {
                            goto lDone;
                        }

                        hr = pCallback->OnReadResponse(pbResponse, numRead);

                        if(FAILED(hr))
                        {
                            goto lDone;
                        }

                        cbWritten += numRead;
                        dwNumber -= numRead;
                    }
                }
                else
                {
                    goto lDone;
                }
            }
            else
            {
                hr = m_stin.SkipBytes(dwNumber);

                if(FAILED(hr))
                {
                    goto lDone;
                }
            }
        }
        else if(_stricmp(pWord, "Result") == 0)
        {
            // Request is done!

            *phrRequest = dwNumber;
            break;
        }
        else
        {
            // Invalid response.
            hr = E_FAIL;
            goto lDone;
        }
            
        
    }

lDone:
    delete [] pBuffer;
    pBuffer = NULL;
    return hr;
}


HRESULT CXomAdminSocketInputStream::ReadBytes(BYTE* pBuffer, DWORD cbBuffer)
{
    for(DWORD nByte=0; nByte < cbBuffer; nByte++)
    {
        BYTE b = ReadByte();

        if(b != (CHAR) -1)
        {
            pBuffer[nByte] = b;
        }
        else
        {
            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT CXomAdminSocketInputStream::SkipBytes(DWORD cbBytes)
{
    for(DWORD nByte=0; nByte < cbBytes; nByte++)
    {
        BYTE b = ReadByte();

        if(b == (CHAR) -1)
        {
            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT CXomAdminSocketInputStream::ReadLine(LPSTR pszBuffer, DWORD cbBuffer)
{
    DWORD cbWritten = 0;

    for(;;)
    {
        if(cbWritten == cbBuffer)
        {
            // Buffer is full
            return E_FAIL;
        }

        CHAR b = ReadByte();

        if('\r' == b)
        {
            if(ReadByte() != '\n')
            {
                // Missing the \n
                return E_FAIL;
            }

            pszBuffer[cbWritten++] = '\0';

            return S_OK;
        }
        else
        {
            pszBuffer[cbWritten++] = b;
        }
    }
}

HRESULT CXomAdminSocketInputStream::ReadMore()
{
    DWORD cbSpace;

    if(m_cbStart <= m_cbEnd)
    {
        cbSpace = sizeof(m_buffer) - m_cbEnd;
    }
    else
    {
        cbSpace = m_cbStart - m_cbEnd - 1;
    }

    if(0 == cbSpace)
    {
        // Buffer is already full
        
        return E_FAIL;
    }

    int iRecvd = recv(m_socket, (char*) m_buffer + m_cbEnd, 
        cbSpace, 0);

    if(0 == iRecvd)
    {
        // Graceful disconnect
        return S_FALSE;
    }
    else if(SOCKET_ERROR == iRecvd)
    {
        // Operation returned an error
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    m_cbEnd = (m_cbEnd + iRecvd) % sizeof(m_buffer);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomcmmon.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomcmmon.h

Abstract:

--*/

#ifndef _XOMCMMON_H_
#define _XOMCMMON_H_

#pragma once

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(*(x)))
#endif

class CXomLogArea;
class CCompletionPort;

///////////////////////////////////////////////////////////////////////////////
//
// Logging levels
//
///////////////////////////////////////////////////////////////////////////////

#define L_OFF -1
#define L_ON 0
#define L_LOW 0
#define L_INFO 1
#define L_NORMAL 1
#define L_HIGH 2
#define L_WARNING 2
#define L_ERROR 3
#define L_MUTED 4


///////////////////////////////////////////////////////////////////////////////
//
// Some very useful formating utility macros
//
///////////////////////////////////////////////////////////////////////////////

#define DBGSINFMT "%d.%d.%d.%d:%d"
#define DBGSINPRM(x) \
    (x)->sin_addr.S_un.S_un_b.s_b1, \
    (x)->sin_addr.S_un.S_un_b.s_b2, \
    (x)->sin_addr.S_un.S_un_b.s_b3, \
    (x)->sin_addr.S_un.S_un_b.s_b4, \
    htons((x)->sin_port)

#define DBGINAFMT "%d.%d.%d.%d"
#define DBGINAPRM(x) \
    (x)->S_un.S_un_b.s_b1, \
    (x)->S_un.S_un_b.s_b2, \
    (x)->S_un.S_un_b.s_b3, \
    (x)->S_un.S_un_b.s_b4

#define DBGSGADDRFMT "inaSg=%d.%d.%d.%d, dwSpiSg=%x, qwXBoxID=%I64x"
#define DBGSGADDRPRM(x) \
    (x)->inaSg.S_un.S_un_b.s_b1, \
    (x)->inaSg.S_un.S_un_b.s_b2, \
    (x)->inaSg.S_un.S_un_b.s_b3, \
    (x)->inaSg.S_un.S_un_b.s_b4, \
    (x)->dwSpiSg, \
    (x)->qwXboxID

#define DBGGUIDFMT "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"
#define DBGGUIDPRM(x) \
    (x)->Data1, \
    (x)->Data2, \
    (x)->Data3, \
    (x)->Data4[0], \
    (x)->Data4[1], \
    (x)->Data4[2], \
    (x)->Data4[3], \
    (x)->Data4[4], \
    (x)->Data4[5], \
    (x)->Data4[6], \
    (x)->Data4[7]

#define DBGSYSTEMTIMEFMT "%04d/%02d/%02d %02d:%02d:%02d.%03d"
#define DBGSYSTEMTIMEPRM(x) \
    (x)->wYear, \
    (x)->wMonth, \
    (x)->wDay, \
    (x)->wHour, \
    (x)->wMinute, \
    (x)->wSecond, \
    (x)->wMilliseconds



///////////////////////////////////////////////////////////////////////////////
//
// Assert definition
//
///////////////////////////////////////////////////////////////////////////////

#if DBG
    void __cdecl XomDbgAssertFailed( LPCSTR pszFilePath, int nLineNum, LPCSTR pszExpression );
    #define XOMASSERT(x) if(!(x)) { XomDbgAssertFailed(__FILE__, __LINE__, #x );  }
#else
    #define XOMASSERT(x)
#endif


///////////////////////////////////////////////////////////////////////////////
//
// safe_snprintf
// _snprintf is a handy tool but has a lot of problems. safe_snprintf is just
// a wrapper that takes care of most of them.
//
///////////////////////////////////////////////////////////////////////////////

int safe_vsnprintf(char* pszBuffer, size_t cchBuffer, const char* pszFormat, va_list args);
int safe_snprintf(char* pszBuffer, size_t cchBuffer, const char* pszFormat, ...);
int safe_vsnwprintf(WCHAR* pwszBuffer, size_t cchBuffer, LPCWSTR pwszFormat, va_list args);
int safe_snwprintf(WCHAR* pwszBuffer, size_t cchBuffer, LPCWSTR pwszFormat, ...);


///////////////////////////////////////////////////////////////////////////////
//
// CXomNameValuePairList - handy parsing class sometimes used with settings
//
///////////////////////////////////////////////////////////////////////////////

class CXomNameValuePairList
{
public:
    CXomNameValuePairList();
    ~CXomNameValuePairList();

    void Reset();
    HRESULT Parse( LPCSTR pszString, LPCSTR pszDefault, CHAR chSeperator = ';' );
    HRESULT Parse( LPCSTR pszString, CHAR chSeparator = ';' );

    HRESULT Parse( BSTR szString, BSTR szDefault, CHAR chSeparator = ';' );
    HRESULT Parse( BSTR szString, CHAR chSeparator = ';' );

    DWORD GetCount() const { return m_cPairs; }
    LPCSTR GetName( DWORD nPair ) const { return m_rgPairs[nPair].pszName; }
    LPCSTR GetValue( DWORD nPair ) const { return m_rgPairs[nPair].pszValue; }

    DWORD GetDefaultCount() const { return m_cDefaultPairs; }
    LPCSTR GetDefaultName( DWORD nPair ) const { return m_rgDefaultPairs[nPair].pszName; }
    LPCSTR GetDefaultValue( DWORD nPair ) const { return m_rgDefaultPairs[nPair].pszValue; }

    LPCSTR GetValueByName( LPCSTR pszName );
    LPSTR GetNameValuePairString( LPCSTR pszSeperator = ";" );

protected:
    const static unsigned int c_xomMaxPairs = 256;

    struct pair_t
    {
        char* pszName;
        char* pszValue;
        bool  bUsed;
    };

    HRESULT _Parse( LPCSTR pszString, CHAR chSeperator, LPSTR * pszLocation, DWORD * cPairs, pair_t *rgPairs, DWORD maxPairs );

    pair_t m_rgPairs[ c_xomMaxPairs ];
    pair_t m_rgDefaultPairs[ c_xomMaxPairs ];

    DWORD m_cPairs;
    DWORD m_cDefaultPairs;

    char* m_pszString;
    char* m_pszDefaultString;

};

void ParseIPPortString(LPCSTR pszIPPort, DWORD* pAddr, WORD* pPort);

//
///////////////////////////////////////////////////////////////////////////////
//
// CXomParamList - used in your OnControlRequest callback handler to work with
//     control command parameters.
//
///////////////////////////////////////////////////////////////////////////////

class CXomParamList
{
public:
    CXomParamList();
    ~CXomParamList();

    void Reset();
    HRESULT Parse( LPCSTR pszString );

    DWORD GetCount() const { return m_cParams; }
    LPCSTR GetParam( DWORD nParam ) const { return m_rgpszParams[ nParam ]; }
    SIZE_T GetParamOffset( DWORD nParam ) const { return m_rgpszParams[nParam] - m_pszString; }

protected:
    const static unsigned int c_xomMaxParams = 256;

    char* m_rgpszParams[ c_xomMaxParams ];
    DWORD m_cParams;
    char* m_pszString;
};

//////////////////////////////////////////////////////////////////////////////
//
// CLogFormatedMessage
//
//////////////////////////////////////////////////////////////////////////////
//
class CLogFormatedMessage
{
public:

    explicit CLogFormatedMessage(
        const FLOKEN& flowToken,
        CXomLogArea* pArea,
        char chLevel = L_LOW,
        WORD wEventId = 0 )
    {
        m_flowToken = flowToken;
        m_pArea = pArea;
        m_chLevel = chLevel;
        m_wEventId = wEventId;
        m_cchText = 0;
    }

    void Format(LPCSTR pszFmt, ...)
    {
        va_list args;
        va_start(args, pszFmt);

        FormatEx(pszFmt, args);

        va_end(args);
    }

    void FormatEx(LPCSTR pszFmt, va_list args)
    {
        m_cchText += safe_vsnprintf(m_szText + m_cchText, c_cchMaxText - m_cchText, pszFmt, args);
    }

    void Prepend(LPCSTR pszFmt, ...)
    {
        int cchTextTemp;

        va_list args;
        va_start(args, pszFmt);

        // This guaranteed to return a value less than c_cchMaxText since it will
        // truncate the string if it is too long.
        cchTextTemp = safe_vsnprintf(m_szTextTemp, c_cchMaxText, pszFmt, args);
        va_end(args);

        // After this operation, cchTextTemp is guaranteeds to be less than c_cchMaxText.
        // This means that the szTextTemp array is properly null terminated.
        cchTextTemp += safe_snprintf(m_szTextTemp + cchTextTemp, c_cchMaxText - cchTextTemp, "%s", m_szText);

        // Since szTextTemp is properly null terminated, the cchTextTemp + 1 operation
        // is guaranteed to not walk past the end of the array.
        memcpy(m_szText, m_szTextTemp, cchTextTemp + 1); 
        m_cchText = cchTextTemp;
    }

    CXomLogArea* GetArea()
    {
        return m_pArea;
    }

    char GetLevel()
    {
        return m_chLevel;
    }

    WORD GetEventId()
    {
        return m_wEventId;
    }

    FLOKEN& GetFlowToken()
    {
        return m_flowToken;
    }

    char* GetText()
    {
        return m_szText;
    }

    int GetTextSize()
    {
        return m_cchText;
    }

protected:
    const static unsigned int c_cchMaxText = 4096;

    char m_szText[c_cchMaxText];
    int m_cchText;

    // The reality is that there is one XomNtLogTarget created,
    // so reserving the memory required for the prepend operation
    // is better than using a stack variable
    char m_szTextTemp[c_cchMaxText];
    
    LPCSTR m_pszFmt;

    CXomLogArea* m_pArea;

    char m_chLevel;

    WORD m_wEventId;

    FLOKEN m_flowToken;
};


//////////////////////////////////////////////////////////////////////////////
//
// CXomTargetBase
//
///////////////////////////////////////////////////////////////////////////////

class CXomTargetBase
{
public:

    CXomTargetBase() :
        m_pszTargetName(NULL),
        m_pszTargetParams(NULL),
        m_dwAdminId(0)
    {
    }

    virtual ~CXomTargetBase()
    {
        if(m_pszTargetName != NULL)
        {
            free(m_pszTargetName);
            m_pszTargetName = NULL;
        }

        if(m_pszTargetParams != NULL)
        {
            free(m_pszTargetParams);
            m_pszTargetParams = NULL;
        }
    }

    HRESULT SetTargetName(
        LPCSTR pszName )
    {
        XOMASSERT(m_pszTargetName == NULL);
        m_pszTargetName = _strdup(pszName);

        if(NULL == pszName)
        {
            return E_OUTOFMEMORY;
        }

        return S_OK;
    }

    LPCSTR GetTargetName()
    {
        return m_pszTargetName;
    }

    HRESULT SetTargetParams(
        LPCSTR pszTargetParams
    )
    {
        if (m_pszTargetParams != NULL)
        {
            free(m_pszTargetParams);
        }

        m_pszTargetParams = _strdup(pszTargetParams);

        if(NULL == m_pszTargetParams)
        {
            return E_OUTOFMEMORY;
        }

        return S_OK;
    }

    LPCSTR GetTargetParams()
    {
        return m_pszTargetParams;
    }

    void SetAdminId(
        DWORD dwAdminId )
    {
        m_dwAdminId = dwAdminId;
    }

    DWORD GetAdminId()
    {
        return m_dwAdminId;
    }

    virtual ULONG AddRef() = 0;

    virtual ULONG Release() = 0;

    virtual void Log(
        CLogFormatedMessage* pMsg) = 0;

    virtual HRESULT Init(
        CCompletionPort* pIOCP,
        LPCSTR pszParams,
        LPCSTR pszDefault = NULL) { return S_OK; }

    virtual HRESULT Startup() { return S_OK; }

    virtual void Term() {}

    virtual HRESULT ResetTarget() { return S_OK; }

protected:

    char* m_pszTargetName;
    char* m_pszTargetParams;
    DWORD m_dwAdminId;
};



#endif // #ifndef _XOMCMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomassert.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xomassert.cpp

Abstract:

--*/

#include "stdafx.h"

#if DBG

#define STATIC_BUFFER(_name,_nbuf,_chbuf) \
    static char s_chStaticBuffer##_name[(_nbuf)*(_chbuf)]; \
    static LONG s_lStaticBuffer##_name = 0; \
    char * pch = &s_chStaticBuffer##_name[(InterlockedIncrement(&s_lStaticBuffer##_name) % (_nbuf)) * (_chbuf)]; \
    UINT cch = (_chbuf);

#pragma optimize( "y", off )    // disable frame pointer omission (FPO)

VOID
__cdecl
XomDbgAssertFailed(const char * pszFilePath,
                   int          nLineNum,
                   const char * pszExpression)
{
    STATIC_BUFFER(DbgAssert, 8, 512);
    safe_snprintf(pch, cch - 1,
                  " Assertion (%s) Failed\n"
                  " File: %s, line %ld\n",
                  pszExpression,
                  pszFilePath,
                  nLineNum);

    OutputDebugStringA(pch);

    DebugBreak();
    return;
}

#pragma optimize( "", on )      // restore frame pointer omission (FPO)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomfiletarget.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomfiletarget.cpp

Abstract:

--*/

#include "stdafx.h"


CXomFileTarget::CXomFileTarget()
{
    m_pIOCP = NULL;
    m_szLogFilePrefix[0] = '\0';
    m_dwRotationTimeMins = 0;
    ZeroMemory(&m_ftNextRotation, sizeof(m_ftNextRotation));
    m_pCurrentFile = NULL;
    m_dwBufferSize = 0;
    m_bEmitThreadId = false;
    m_bEmitFlowToken = false;
}

CXomFileTarget::~CXomFileTarget()
{
    SAFE_RELEASE(m_pIOCP);
    SAFE_RELEASE(m_pCurrentFile);
}

HRESULT CXomFileTarget::Init(
    CCompletionPort* pIOCP,
    LPCSTR pszParams,
    LPCSTR pszDefaults
)
{
    HRESULT hr  = S_OK;

    if (pIOCP == NULL ||
        pszParams == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    m_pIOCP = pIOCP;
    m_pIOCP->AddRef();

    // not part of the params
    m_dwBufferSize = 1024 * 1024;

    GOTO_LDONE_IF_FAILED_HR(
        ParseParams(pszParams, pszDefaults));

    // Create the directory contained in the file prefix if it doesn't exist
    // yet.
    EnsureFilePrefixDirectoryExists();

    // Create the log file
    GOTO_LDONE_IF_FAILED_HR(
        CreateNewLogFile() );

lDone:

    return hr;
}

// ParseParams - parse params in the following format and set the member variables:
//
// log=Type=File;Prefix=#LOGROOT#\app\#COMPONENT#\#MACHINE#.#COMPONENT#.;RotationTime=60;RotationSize=1000000000
//
// No locks are grabbed by this function, so make sure you are protected before calling.
HRESULT CXomFileTarget::ParseParams(
    LPCSTR pszParams,
    LPCSTR pszDefaults
    )
{
    HRESULT                 hr = S_OK;
    CXomNameValuePairList   oParams;
    LPSTR                   pszMergedParams = NULL;
    LPCSTR                  pszEmitThreadId = NULL;
    LPCSTR                  pszEmitFlowToken = NULL;
    LPCSTR                  pszPrefix = NULL;
    LPCSTR                  pszRotationTime = NULL;
    LPCSTR                  pszRotationSize = NULL;

    GOTO_LDONE_IF_FAILED_HR(
        oParams.Parse(pszParams, pszDefaults) );

    // Prefix

    pszPrefix = oParams.GetValueByName("Prefix");

    if(NULL == pszPrefix)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    lstrcpynA(m_szLogFilePrefix, pszPrefix,
        ARRAY_ELEMENTS(m_szLogFilePrefix));

    // Rotation time

    pszRotationTime = oParams.GetValueByName("RotationTime");

    if(pszRotationTime != NULL)
    {
        m_dwRotationTimeMins = (DWORD) atol(pszRotationTime);
    }

    // Rotation size

    pszRotationSize = oParams.GetValueByName("RotationSize");

    if(pszRotationSize != NULL)
    {
        m_dwMaxSize = (DWORD) atol(pszRotationSize);
    }

    pszEmitThreadId = oParams.GetValueByName("EmitThreadId");

    if (pszEmitThreadId != NULL)
    {
        m_bEmitThreadId = _stricmp(pszEmitThreadId, "yes") == 0
            || _stricmp(pszEmitThreadId, "true") == 0
            || _stricmp(pszEmitThreadId, "1") == 0;
    }

    pszEmitFlowToken = oParams.GetValueByName("EmitFlowToken");

    if (pszEmitFlowToken != NULL)
    {
        m_bEmitFlowToken = _stricmp(pszEmitFlowToken, "yes") == 0
            || _stricmp(pszEmitFlowToken, "true") == 0
            || _stricmp(pszEmitFlowToken, "1") == 0;
    }

    // Remember what the parameters we used where

    pszMergedParams = oParams.GetNameValuePairString();
    if (pszMergedParams != NULL)
    {
        GOTO_LDONE_IF_FAILED_HR(
            SetTargetParams( pszMergedParams )
            );
    }

lDone:

    if (pszMergedParams != NULL)
    {
        free(pszMergedParams);
    }

    return hr;
}

HRESULT CXomFileTarget::ResetTarget()
{
    // For the file target, resetting means forcing the rotation to happen
    // immediately.

    return CreateNewLogFile();
}

// ResetTargetWithParams - re-initialize the file target with new parameters and roll the
// logfile.
HRESULT CXomFileTarget::ResetTargetWithParams(
    LPCSTR pszParams)
{
    HRESULT hr = S_OK;
    m_lockCurrentFile.WriteLock();

    GOTO_LDONE_IF_FAILED_HR(
        ParseParams(pszParams));

    // Create the directory contained in the file prefix if it doesn't exist
    // yet.
    EnsureFilePrefixDirectoryExists();

    // OK to call with a write lock held
    GOTO_LDONE_IF_FAILED_HR(
        CreateNewLogFile());

lDone:

    m_lockCurrentFile.WriteUnlock();
    return hr;
}

void CXomFileTarget::Term()
{
    CLogFile* pFile = NULL;

    //
    // Remove the current file from usage.
    //

    m_lockCurrentFile.WriteLock();

    SAFE_RELEASE(m_pCurrentFile);

    m_lockCurrentFile.WriteUnlock();
}

void CXomFileTarget::EnsureFilePrefixDirectoryExists()
{
    CHAR szDrive[_MAX_DRIVE];
    CHAR szDir[_MAX_DIR];
    CHAR szPath[MAX_PATH];
    CHAR* pSlash;

    _splitpath(m_szLogFilePrefix, szDrive, szDir, NULL, NULL);
    safe_snprintf(szPath, MAX_PATH, "%s%s", szDrive, szDir);

    //
    // Stupid brute force way to create the directory. But it works.
    //

    pSlash = szPath;

    while(NULL != (pSlash = strchr(pSlash, '\\')))
    {
        *pSlash = '\0';

        CreateDirectoryA(szPath, NULL);

        *pSlash = '\\';
        pSlash++;
    }

    CreateDirectoryA(szPath, NULL);

    return;

}

HRESULT CXomFileTarget::CreateNewLogFile()
{
    HRESULT     hr = S_OK;
    CAsyncFile* pNewLogFile = NULL;
    SYSTEMTIME  st;
    int         iTry = 0;
    bool        fLock = false;
    FILETIME    ftNow = {0};
    static const ULONGLONG ONEMINUTEINFILETIME = 10000000 * 60;

     // Create the new file object
    GOTO_LDONE_IF_FAILED_ALLOC(
        pNewLogFile = new CAsyncFile());

    GetSystemTime(&st);

    if(m_dwRotationTimeMins != 0)
    {
        // Round up st to be a multiple of m_dwRotationTimeMins
        SystemTimeToFileTime(&st, &ftNow);
        ULONGLONG& ullNow = *((ULONGLONG*)&ftNow);
        ULONGLONG ullRotationTime = ONEMINUTEINFILETIME * m_dwRotationTimeMins;
        ullNow = (ullNow / ullRotationTime) * ullRotationTime;
        FileTimeToSystemTime(&ftNow, &st);

        // Also update the next time the file should be rotated
        *((ULONGLONG*)&m_ftNextRotation) = ullNow + ullRotationTime;
    }

    for(;;)
    {
        // Build filename using the prefix, the date and a try number.
        WCHAR wszFilename[MAX_PATH];
        safe_snwprintf(wszFilename, ARRAY_ELEMENTS(wszFilename),
            L"%S%02d%02d%02d%02d%04d.log", m_szLogFilePrefix, (st.wYear % 100),
            st.wMonth, st.wDay, st.wHour, iTry);

        // Try to create file
        hr = pNewLogFile->Init(wszFilename, m_pIOCP, m_dwBufferSize);
        if(FAILED(hr))
        {
            if(HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
            {
                // Failed because there is a file with the same name. Increment
                // iTry and try again.
                iTry++;
                continue;
            }
            else
            {
                // Failed for some other reason. Not a good thing.
                XomNtEvent( XEVENT_MGMT_GENERIC_ERROR_4,
                    "Management framework found an error: Failed to create target file \"%S\". hr = 0x%08x", wszFilename, hr );
                goto lDone;
            }
        }

        break;
    }

    //
    // Now that we have the new file, replace the current one.
    //

    if(!m_lockCurrentFile.IsWriteLocked())
    {
        // If lock is not already in exclusive mode, write lock.
        m_lockCurrentFile.WriteLock();
        fLock = true;
    }

    CAsyncFile* pPreviousFile = m_pCurrentFile;
    m_pCurrentFile = pNewLogFile;

    if(fLock)
    {
        // We acquired the lock. Release it.
        m_lockCurrentFile.WriteUnlock();
    }

    SAFE_RELEASE(pPreviousFile);

    pNewLogFile = NULL;

lDone:

    SAFE_RELEASE(pNewLogFile);

    return hr;
}

/*******************************************************************************
 CXomFileTarget::IsTimeToRotate
 Returns true if the current file should be rotated.
*******************************************************************************/
bool CXomFileTarget::IsTimeToRotate(FILETIME& ftNow)
{
    XOMASSERT(m_lockCurrentFile.IsReadLocked()||m_lockCurrentFile.IsWriteLocked());

    if(m_pCurrentFile != NULL)
    {
        if(m_dwRotationTimeMins != 0)
        {
            if( *((const ULONGLONG*)&ftNow) >=
                *((const ULONGLONG*)&m_ftNextRotation))
            {
                return true;
            }
        }
        if(m_dwMaxSize != 0)
        {
            if(m_pCurrentFile->GetSize() >= (LONGLONG) m_dwMaxSize)
            {
                return true;
            }
        }
    }

    return false;
}

/*******************************************************************************
 CXomFileTarget::Log
 XomTarget log entry point. Writes a message to the log (in this case a file).
*******************************************************************************/
void CXomFileTarget::Log(
    CLogFormatedMessage* pMsg
)
{
    SYSTEMTIME          st;
    FILETIME            ftNow = {0};
    CLogFormatedMessage oMsg(pMsg->GetFlowToken(), NULL, 0);
    char*               pBuffer;
    DWORD               cbBuffer;
    CAsyncFile*         pFile = NULL;

    // Get current UTC time
    GetSystemTime(&st);

    if(m_dwRotationTimeMins != 0)
    {
        // If this file is configured to rotate by time we'll need the current
        // system time in filetime format.
        SystemTimeToFileTime(&st, &ftNow);
    }

    // Get a reference to the file object
    m_lockCurrentFile.ReadLock();

    // If this file is configured to rotate by time we have to check if it's
    // time to rotate it now.
    if(IsTimeToRotate(ftNow))
    {
        // Check it again, this time in exclusive mode.
        m_lockCurrentFile.ConvertSharedToExclusive();

        if(IsTimeToRotate(ftNow))
        {
            // It's, indeed, time to create a new log file.
            if(FAILED(CreateNewLogFile()))
            {
                m_lockCurrentFile.WriteUnlock();
                goto lDone;
            }
        }

        m_lockCurrentFile.ConvertExclusiveToShared();
    }

    pFile = m_pCurrentFile;

    // Add a reference to the file before we leave the critical section
    if(pFile != NULL)
        pFile->AddRef();

    m_lockCurrentFile.ReadUnlock();

    if(NULL == pFile)
    {
        // Shutting down?
        goto lDone;
    }

    char szFloken[2 + sizeof(FLOKEN)*2 + 1 + 1];  // "FTxxxxxxxxxxxxxxxx|\0"
    if (m_bEmitFlowToken)
    {
        if (pMsg->GetFlowToken().IsValid())
        {
            safe_snprintf(szFloken, ARRAYSIZE(szFloken), "FT%016I64X|", pMsg->GetFlowToken().flowToken);
        }
        else
        {
            safe_snprintf(szFloken, ARRAYSIZE(szFloken), "FT0|");
        }
    }
    else
    {
        szFloken[0] = 0;
    }

    if (m_bEmitThreadId)
    {
        // Build message using log format
        oMsg.Format("%04X|%04d/%02d/%02d %02d:%02d:%02d.%03d|%s%s\r\n",
            GetCurrentThreadId(), 
            st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, 
            szFloken,
            pMsg->GetText());
    }
    else
    {
        // Build message using log format
        oMsg.Format("%04d/%02d/%02d %02d:%02d:%02d.%03d|%s%s\r\n",
            st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, 
            szFloken,
            pMsg->GetText());
    }

    // TODO: optionally insert these if appropriate target param is set
    //  GetCurrentThreadId(), pMsg->GetLevel(),

    //
    // Little hack to guarantee that the \r\n sequence will be at the end of
    // the buffer, even if the buffer was full.
    //

    pBuffer = oMsg.GetText();
    cbBuffer = oMsg.GetTextSize();

    if(pBuffer[cbBuffer-1] != '\n')
    {
        pBuffer[cbBuffer-2] = '\r';
        pBuffer[cbBuffer-1] = '\n';
    }

    //
    // Write entry to log file
    //

    pFile->Write((BYTE*)oMsg.GetText(), oMsg.GetTextSize());

lDone:

    SAFE_RELEASE(pFile);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomcontrol.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomcontrol.cpp

Abstract:

--*/

#include "stdafx.h"


CXomControlConnection::CXomControlConnection()
{
    m_fAlive = FALSE;
    m_pPipe = NULL;
    m_lOutgoing = 0;
    m_pControl = NULL;
}

CXomControlConnection::~CXomControlConnection()
{
    Shutdown();
    SAFE_RELEASE(m_pPipe);         
}

HRESULT CXomControlConnection::Init(
    CXomControl* pControl,
    CCompletionPort* pIOCP,
    LPCSTR pszProcessName,
    LPCSTR pszComponentName
)
{
    HRESULT hr = S_OK;

    m_pControl = pControl;

    hr = m_BufferList.Initialize(64);

    if(FAILED(hr))
    {
        goto lDone;
    }
    
    m_pPipe = new CServerPipe;

    if(NULL == m_pPipe)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    m_fAlive = TRUE;
    
    hr = m_pPipe->Init(pIOCP);

    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = m_pPipe->Connect(L"\\\\.\\pipe\\xmgmtsrvpipe");

    if(FAILED(hr))
    {
        goto lDone;
    }

    Register(pszProcessName, pszComponentName);

    StartReading();

lDone:

    return hr;
}

void CXomControlConnection::Shutdown()
{
    m_fAlive = FALSE;
    
    if(m_pPipe != NULL)
    {
        m_pPipe->Close();
    }
}

HRESULT CXomControlConnection::WriteResponse(
    DWORD dwRequestId,
    BYTE* pBuffer,
    DWORD cbBuffer
)
{
    HRESULT hr = S_OK;
    CXomControlBuffer* pMsgBuffer = NULL;
    XOMCTRLMSG_RESPONSE* pMsg;

    if(((DWORD)-1) == cbBuffer)
    {
        cbBuffer = strlen((char*)pBuffer);
    }
    
    while (cbBuffer > 0)
    {
        DWORD cbSend = min(cbBuffer, XOMCTRL_MAXMESSAGESIZE - sizeof(XOMCTRLMSG_RESPONSE));

        pMsgBuffer = CXomControlBuffer::CreateInstance(cbSend + sizeof(XOMCTRLMSG_RESPONSE));

        if(NULL == pMsgBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        pMsg = (XOMCTRLMSG_RESPONSE*) pMsgBuffer->GetBuffer();

        pMsg->hdr.dwSize = pMsgBuffer->GetBufferLength();
        pMsg->hdr.dwType = XOMCTRLMSGID_RESPONSE;
        pMsg->dwRequestId = dwRequestId;
        memcpy(((BYTE*)pMsg) + sizeof(XOMCTRLMSG_RESPONSE), pBuffer, cbSend);

        hr = Send(pMsgBuffer);
        if (FAILED(hr)) goto lDone;

        pMsgBuffer->Release();
        pMsgBuffer = NULL;

        cbBuffer -= cbSend;
        pBuffer += cbSend;
    }

lDone:

    SAFE_RELEASE(pMsgBuffer);

    return hr;
}

HRESULT CXomControlConnection::RequestDone(
    DWORD dwRequestId,
    HRESULT hrRequest
)
{
    HRESULT hr = S_OK;
    CXomControlBuffer* pMsgBuffer = NULL;
    XOMCTRLMSG_RESPONSE_DONE* pMsg;

    pMsgBuffer = CXomControlBuffer::CreateInstance(sizeof(XOMCTRLMSG_RESPONSE_DONE));

    if(NULL == pMsgBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pMsg = (XOMCTRLMSG_RESPONSE_DONE*) pMsgBuffer->GetBuffer();

    pMsg->hdr.dwSize = pMsgBuffer->GetBufferLength();
    pMsg->hdr.dwType = XOMCTRLMSGID_RESPONSE_DONE;
    pMsg->dwRequestId = dwRequestId;
    pMsg->hr = hrRequest; 

    hr = Send(pMsgBuffer);
    
lDone:

    SAFE_RELEASE(pMsgBuffer);

    return hr;
}

HRESULT CXomControlConnection::Send(
    CXomControlBuffer* pBuffer
)
{
    HRESULT hr = S_OK;
    LISTPOS res;

    pBuffer->AddRef();

    m_lockBufferList.WriteLock();

    res = m_BufferList.AddTail((void*) pBuffer);

    m_lockBufferList.WriteUnlock();

    if(NULL == res)
    {
        pBuffer->Release();
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    if(InterlockedIncrement(&m_lOutgoing) == 1)
    {
        hr = SendNext();

        if(FAILED(hr))
        {
            goto lDone;
        }
    }
    
lDone:

    return hr;
}
    

HRESULT CXomControlConnection::Register(
    LPCSTR pszProcessName, 
    LPCSTR pszComponentName
)
{
    CXomControlBuffer* pMsgBuffer = NULL;
    XOMCTRLMSG_REGISTER* pMsg;
    HRESULT hr = S_OK;

    pMsgBuffer = CXomControlBuffer::CreateInstance(sizeof(XOMCTRLMSG_REGISTER));

    if(NULL == pMsgBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    pMsg = (XOMCTRLMSG_REGISTER*) pMsgBuffer->GetBuffer();

    pMsg->hdr.dwSize = sizeof(XOMCTRLMSG_REGISTER);
    pMsg->hdr.dwType = XOMCTRLMSGID_REGISTER;
    pMsg->dwProcessId = GetCurrentProcessId();
    lstrcpynA(pMsg->szProcessName, pszProcessName, ARRAY_ELEMENTS(pMsg->szProcessName));
    lstrcpynA(pMsg->szComponentName, pszComponentName, ARRAY_ELEMENTS(pMsg->szComponentName));

    InterlockedIncrement(&m_lOutgoing);
    hr = m_pPipe->Write(pMsgBuffer->GetBuffer(), pMsgBuffer->GetBufferLength(), this, (ULONGLONG) pMsgBuffer);

    if(FAILED(hr))
    {
        InterlockedDecrement(&m_lOutgoing);
        goto lDone;
    }


lDone:

    return hr;
}

HRESULT CXomControlConnection::StartReading()
{
    HRESULT hr = S_OK;

    hr = m_pPipe->Read(m_rgbBuffer, ARRAY_ELEMENTS(m_rgbBuffer), this, 0);

    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    return hr;
}

HRESULT CXomControlConnection::SendNext()
{
    HRESULT hr = S_OK;
    CXomControlBuffer* pBuffer = NULL;
    BOOL fRes;

    m_lockBufferList.WriteLock();

    fRes = m_BufferList.RemoveHead((void**) &pBuffer);

    m_lockBufferList.WriteUnlock();

    if(!fRes)
    {
        hr = E_FAIL;
        goto lDone;
    }

    hr = m_pPipe->Write(pBuffer->GetBuffer(), pBuffer->GetBufferLength(), 
        this, (ULONGLONG) pBuffer);

    if(FAILED(hr))
    {
        goto lDone;
    }

    pBuffer = NULL;

lDone:

    SAFE_RELEASE(pBuffer);

    return hr;
}

HRESULT CXomControlConnection::OnPipeWrite(
    BYTE* pBufferSent,
    DWORD cbToSend,
    DWORD cbSent,
    HRESULT hr,
    ULONGLONG qwCallbackArg
)
{
    CXomControlBuffer* pMsgBuffer = (CXomControlBuffer*) qwCallbackArg;

    if(FAILED(hr))
    {
        goto lDone;
    }

    if(InterlockedDecrement(&m_lOutgoing) != 0)
    {
        hr = SendNext();
    }
    
lDone:

    SAFE_RELEASE(pMsgBuffer);

    // do not reconnect on shutdown
    if(FAILED(hr) && m_fAlive)
    {
        XomNtEvent( XEVENT_MGMT_SRV_DISCONNECT, "[CXomControlConnection::OnPipeWrite] remote admin framework is unavailable. hr = 0x%x", hr);
        m_pControl-> ResetConnection();
    }

    return S_OK;
}

HRESULT CXomControlConnection::OnPipeRead(
    BYTE* pbFilledInBuffer,
    DWORD cbRead,
    HRESULT hr,
    ULONGLONG qwCallbackArg
)
{
    LPSTR pszRequest;
    DWORD cchRequest;
    XOMCTRLMSG_REQUEST* pMsg = (XOMCTRLMSG_REQUEST*) m_rgbBuffer;
    
    // do not reconnect on shutdown
    if(FAILED(hr))
    {
        goto lDone;
    }

    if(pMsg->hdr.dwSize != cbRead)
    {
        goto lDone;
    }
    
    if(pMsg->hdr.dwType != XOMCTRLMSGID_REQUEST)
    {
        goto lDone;
    }
    
    if(pMsg->hdr.dwSize > XOMCTRL_MAXMESSAGESIZE)
    {
        goto lDone;
    }

    if(pMsg->hdr.dwSize < sizeof(XOMCTRLMSG_REQUEST))
    {
        goto lDone;
    }
    
    pszRequest = (LPSTR) (((BYTE*)pMsg) + sizeof(XOMCTRLMSG_REQUEST));
    cchRequest = pMsg->hdr.dwSize - sizeof(XOMCTRLMSG_REQUEST);
    
    pszRequest[cchRequest] = '\0';

    HRESULT hrRequest = m_pControl->ProcessRequest(pszRequest, pMsg->dwRequestId, (CXomControlResponseInterface*) this);
    RequestDone(pMsg->dwRequestId, hrRequest);    
   
lDone:

    // Trigger a new read AFTER we are done processing the previous one.
    if(SUCCEEDED(hr))
    {
        hr = StartReading();

        // Let errors fall through
    }

    if(FAILED(hr) && m_fAlive)
    {
        // Connection lost.
        XomNtEvent( XEVENT_MGMT_SRV_DISCONNECT_1, "[CXomControlConnection::OnPipeRead] remote admin framework is unavailable, hr = 0x%x", hr);

        m_pControl-> ResetConnection();
    }
    
    return S_OK;
}

CXomControl::CXomControl()
{
    m_pIOCP = NULL;
    m_pCurrentConnection = NULL;
    m_szComponentName[0] = '\0';
    m_szProcessName[0] = '\0';

    m_hConnectXmgmtSrv = NULL;
    m_heShutdown = NULL;
}

CXomControl::~CXomControl()
{
    Terminate();
}

HRESULT CXomControl::Init(
    CCompletionPort* pIOCP,
    LPCSTR pszComponentName )
{
    HRESULT hr = S_OK;
    CHAR szProcessName[MAX_PATH];

    m_pIOCP = pIOCP;
    m_pIOCP->AddRef();

    lstrcpynA(m_szComponentName, pszComponentName, ARRAY_ELEMENTS(m_szComponentName));

    if(!GetModuleFileNameA(GetModuleHandle(NULL), szProcessName, ARRAY_ELEMENTS(szProcessName)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto lDone;
    }
        szProcessName[ MAX_PATH - 1 ] = '\0';

    _splitpath(szProcessName, NULL, NULL, m_szProcessName, NULL);

    hr = LazyConnect();    

    if(FAILED(hr))
    {
        CreateWatchDogThread();
        goto lDone;
    }

lDone:

    return hr;
}

HRESULT CXomControl::Terminate()
{
    SAFE_RELEASE(m_pIOCP);

    // Shutdown the thread if there is one
    if( NULL != m_hConnectXmgmtSrv )
    {
        SetEvent ( m_heShutdown );
        WaitForSingleObject( m_hConnectXmgmtSrv, INFINITE );
        CloseHandle( m_hConnectXmgmtSrv );
        m_hConnectXmgmtSrv = NULL;
    }

    // NOTE: If we succeed in creating the event but fail to create the thread, we still
    // need to clean up the event, so this must be outside of the above 'if'.
    SAFE_CLOSEHANDLE( m_heShutdown );

    if(m_pCurrentConnection != NULL)
    {
        m_pCurrentConnection->Shutdown();
        m_pCurrentConnection->Release();
        m_pCurrentConnection = NULL;
    }
    
    m_CallbackList.RemoveAll();

    return S_OK;
}

HRESULT CXomControl::RegisterControlCallback(
    CXomControlCallback* pCallback )
{
    HRESULT hr = S_OK;
    BOOL fRes;

    pCallback->AddRef();

    m_lockCallbackList.WriteLock();

    fRes = m_CallbackList.Add((void*)pCallback, NULL);

    m_lockCallbackList.WriteUnlock();

    if(!fRes)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCallback = NULL;

lDone:
    
    SAFE_RELEASE(pCallback);

    return hr;
}

HRESULT CXomControl::UnregisterControlCallback(
    CXomControlCallback* pCallback )
{
    HRESULT hr = S_OK;
    DWORD nEntry;
    CXomControlCallback* pCallback2;

    m_lockCallbackList.WriteLock();

    for(nEntry=0; nEntry < m_CallbackList.GetSize(); nEntry++)
    {
        if(!m_CallbackList.GetAt(nEntry, (void**) &pCallback2))
        {
            hr = E_UNEXPECTED;
            break;
        }

        if(pCallback2 == pCallback)
        {
            if(!m_CallbackList.RemoveAt(nEntry, 1))
            {
                hr = E_UNEXPECTED;
                break;
            }

            pCallback->Release();
            break;
        }
    }

    m_lockCallbackList.WriteUnlock();

    return hr;
}

LPCSTR CXomControl::GetProcessName()
{
    return m_szProcessName;
}

LPCSTR CXomControl::GetComponentName()
{
    return m_szComponentName;
}

HRESULT CXomControl::ProcessRequest(
    LPCSTR pszRequest,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface )
{
    HRESULT hr = S_OK;
    DWORD nCallback;
    CXomControlCallback* pCallback;

    m_lockCallbackList.ReadLock();

    for(nCallback=0; nCallback < m_CallbackList.GetSize(); nCallback++)
    {
        if(!m_CallbackList.GetAt(nCallback, (void**) &pCallback))
        {
            hr = E_UNEXPECTED;
            break;
        }

        hr = pCallback->OnControlRequest(pszRequest, dwRequestId, pResponseInterface);

        if(FAILED(hr))
        {
            break;
        }
    }

    m_lockCallbackList.ReadUnlock();

    return hr;
}

HRESULT CXomControl::LazyConnect()
{
    HRESULT hr = S_OK;
    CXomControlConnection* pConnection = NULL;

    if(m_pCurrentConnection != NULL)
    {
        goto lDone;
    }
    
    pConnection = new CXomControlConnection;

    if(NULL == pConnection)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    hr = pConnection->Init(this, m_pIOCP, m_szProcessName, m_szComponentName);

    if(FAILED(hr))
    {
        goto lDone;
    }

    m_pCurrentConnection = pConnection;
    pConnection = NULL;

lDone:

    if(pConnection != NULL)
    {
        // BUGBUG: close
        pConnection->Release();
        pConnection = NULL;
    }

    return hr;
}

DWORD WINAPI CXomControl::ConnectXmgmtSrv( void *pvParam )
{
    CXomControl* pControl = (CXomControl *) pvParam;
    for ( ; ; )
    {

        DWORD dwWaitRes = WaitForSingleObject( pControl->m_heShutdown, 30000 );

        if( dwWaitRes != WAIT_TIMEOUT )
        {
            break;
        }
        
        if ( pControl->m_pCurrentConnection )
        {
            continue;
        }
        HRESULT hr = pControl->LazyConnect();
        if(SUCCEEDED(hr))
        {
            XomNtEvent( XEVENT_MGMT_SRV_CONNECTED, "[CXomControl::ConnectXmgmtSrv] Remote administration is available now." );
        }
    }

    return 0;
}

void CXomControl::ResetConnection()
{
   SAFE_SHUTRELEASE( m_pCurrentConnection );
   CreateWatchDogThread();
}

void CXomControl::CreateWatchDogThread()
{
    if ( NULL == m_hConnectXmgmtSrv )
    {
        m_heShutdown = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( NULL == m_heShutdown )
        {
            HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
            XomNtEvent( XEVENT_MGMT_INIT_FAILURE_5, "[CXomControl::Init()] remote admin framework is unavailable and won't be available later. Fail to create shutdown event for the watchdog thread hr = 0x%x. ",
                hr );
            return;
        }

        m_hConnectXmgmtSrv = CreateThread (NULL, 0, CXomControl::ConnectXmgmtSrv, this, 0, NULL);
        if ( NULL == m_hConnectXmgmtSrv )
        {
            HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
            XomNtEvent( XEVENT_MGMT_INIT_FAILURE_6, "[CXomControl::Init()] remote admin framework is unavailable and won't be available later. Fail to create the watchdog thread hr = 0x%x. ",
                hr );
            return;
        }

    }
}

HRESULT XomWriteFormattedResponse(
    CXomControlResponseInterface* pResponseInterface,
    DWORD dwRequestId,
    const char* pszFmt,
    ...
)
{
    CHAR szBuffer[ 0x800 ];
    va_list marker;
    int cchBuffer;
    
    va_start(marker, pszFmt);
    
    cchBuffer = _vsnprintf(szBuffer, ARRAY_ELEMENTS(szBuffer), pszFmt, marker);
    szBuffer[ARRAY_ELEMENTS(szBuffer)-1] = '\0';

    va_end(marker);

    HRESULT hr = pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szBuffer, cchBuffer );

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomremotetarget.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

  xomremotetarget.h

Abstract:

  Remote logging target.

--*/

#ifndef _XOMREMOTETARGET_H_
#define _XOMREMOTETARGET_H_

class CXomRemoteTarget :
    public CXomTargetBase
{
public:

    IMPLEMENT_REFCOUNT;

    CXomRemoteTarget();

    ~CXomRemoteTarget();

    HRESULT Init(
        CCompletionPort* pIOCP,
        LPCSTR pszParams,
        LPCSTR pszDefaults = NULL );

    virtual void Log(
        CLogFormatedMessage* pMsg);

protected:

    SOCKET m_socket;
    sockaddr_in m_sinRemote;

};



#endif // #ifndef _XOMREMOTETARGET_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomlggng.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomlggng.cpp

Abstract:

--*/

#include "stdafx.h"

#include <string>
using namespace std;

const char c_szNTLogTargetName[] = "NtLog";
const char c_szDefaultEvent[] = "default";

const char c_szMachineToken[] = "#MACHINE#";
const int  c_cchMachineToken = ARRAY_ELEMENTS(c_szMachineToken) - 1;

const char c_szComponentToken[] = "#COMPONENT#";
const int  c_cchComponentToken = ARRAY_ELEMENTS(c_szComponentToken) - 1;

const char c_szLogrootToken[] = "#LOGROOT#";
const int  c_cchLogrootToken = ARRAY_ELEMENTS(c_szLogrootToken) - 1;


// This is a global so that consumers of xmgmt.h don't have to know the full definition of CXomLoggingControl
DWORD g_dwLastChangeSignature = 0x00010000;

XomDefineArea(DefaultNtLog);

//
//
//

CXomLogArea::CXomLogArea( const char* pszAreaName, CComBSTR enumAreaSetting ) :
    m_pszAreaName(pszAreaName),
    m_enumAreaSetting(enumAreaSetting),
    m_chLevel(L_MUTED),
    m_cTargets(0),
    m_fIsTheEventLog(FALSE)
{
    // We allocate this here so all users of XMgmt don't have to pull in dstruct to get the lock definitions
    m_pLockTargets = new xlocks::CReaderWriterLock3();
    RegisterArea();
}

CXomLogArea::~CXomLogArea()
{
    Terminate();
    delete m_pLockTargets;
}

void CXomLogArea::Terminate()
{
    DWORD nTarget;

    m_pLockTargets->WriteLock();

    for(nTarget=0; nTarget < m_cTargets; nTarget++)
    {
        m_rgTargets[nTarget]->Release();
    }
    m_cTargets = 0;

    m_pLockTargets->WriteUnlock();
}

void CXomLogArea::RegisterArea()
{
    CXomLoggingControl::RegisterArea(this);
}

void CXomLogArea::LockTargetList()
{
    m_pLockTargets->ReadLock();
}

void CXomLogArea::UnlockTargetList()
{
    m_pLockTargets->ReadUnlock();
}

HRESULT CXomLogArea::AddTarget(
    CXomTargetBase* pTarget
)
{
    HRESULT hr = S_OK;

    if(m_cTargets < c_xomMaxTargets)
    {
        m_pLockTargets->WriteLock();

        hr = pTarget->Startup();
        if(FAILED(hr))
        {
            m_pLockTargets->WriteUnlock();
            goto lDone;
        }
        pTarget->AddRef();

        m_rgTargets[m_cTargets++] = pTarget;

        m_pLockTargets->WriteUnlock();
    }

lDone:

    return(hr);
}

void CXomLogArea::RemoveTarget(
    CXomTargetBase* pTarget
)
{
    DWORD nTarget;

    m_pLockTargets->WriteLock();

    for(nTarget=0; nTarget < m_cTargets; nTarget++)
    {
        if(m_rgTargets[nTarget] == pTarget)
        {
            for(; nTarget < m_cTargets - 1; nTarget++)
            {
                m_rgTargets[nTarget] = m_rgTargets[nTarget + 1];
            }

            pTarget->Release();

            m_cTargets--;
        }
    }

    m_pLockTargets->WriteUnlock();
}

void CXomLogArea::Log(
    char chLevel,
    const FLOKEN& flowToken,
    DWORD* pdwCanLog,
    LPCSTR pszName,
    DWORD dwLine,
    WORD wId,
    WORD wPacketSize,
    DWORD *pina,
    LPCSTR pszPreMsg,
    LPCSTR pszFmt,
    ...
)
{
    if( CanLog( chLevel, pszName, dwLine, pdwCanLog ) )
    {
        //
        // Format the message
        //

        va_list args;
        CLogFormatedMessage oMsg(flowToken, this, chLevel, wId);


        if(pszPreMsg != NULL)
        {
            oMsg.Format(pszPreMsg);
        }

        va_start(args, pszFmt);
        oMsg.FormatEx(pszFmt, args);
        va_end(args);

        //
        // Log it
        //
        LogInternal(oMsg, wId, wPacketSize, pina);
    }
}

void CXomLogArea::LogInternal(
    CLogFormatedMessage &oMsg,
    WORD wId,
    WORD wPacketSize,
    DWORD *pina
)
{
    m_pLockTargets->ReadLock();

    for(DWORD nTarget=0; nTarget < m_cTargets; nTarget++)
    {
        CXomTargetBase *pTarget = m_rgTargets[ nTarget ];

        // Wow!!!  We absolutely must check for c_szNTLogTargetName
        // because the target must be an NtLogTarget.
        // OkToLog is *not* a virtual function, and we
        // hard-cast pTarget to a CXomNtLogTarget*.
        if( 0 == strcmp( pTarget->GetTargetName(), c_szNTLogTargetName ) )
        {
            BOOL fAllow = FALSE;
            DWORD dwNumSkips = 0;
            DWORD dwNumSkipsTotal = 0;
            DWORD dwRecentRate = 0;

            FILETIME ftNow;
            GetSystemTimeAsFileTime( &ftNow );

            QWORD hnsNow = *(QWORD *)&ftNow;

            BOOL fOk = ((CXomNtLogTarget*)pTarget)->OkToLog(
                                        hnsNow,
                                        wId,
                                        oMsg.GetText(),
                                        wPacketSize,
                                        pina,
                                        &fAllow,
                                        &dwNumSkips,
                                        &dwNumSkipsTotal,
                                        &dwRecentRate );

            if( fOk && !fAllow )
            {
                m_pLockTargets->ReadUnlock();
                return;
            }
            else if( fOk && ( 0 != dwNumSkips ) )
            {
                oMsg.Prepend( "Event Throttle: skipped %d previous events (%d total); recent rate = %d units/sec\r\n\r\n",
                    dwNumSkips, dwNumSkipsTotal, dwRecentRate);
            }

        }

        pTarget->Log( &oMsg );

    }

    m_pLockTargets->ReadUnlock();
}


BOOL CXomLogArea::CanLog(
    char chLevel,
    LPCSTR pszName,
    DWORD dwLine,
    DWORD* pdwCanLog
)
{
    DWORD dwLastChangeSignature;
    DWORD dwNewCanLog;
    BOOL  fCanLog;

    if( HIWORD( *pdwCanLog ) == HIWORD( g_dwLastChangeSignature ) )
    {
        fCanLog = !!LOWORD( *pdwCanLog );
    }
    else
    {
        //
        // We need to re-evaluate whether this particular trace statement should consider
        // processing anything
        //
        do
        {
            dwLastChangeSignature = g_dwLastChangeSignature;

            //
            // If not special-cased in the override list, the current level of the area
            // determines if we should log or not.
            //
            if( !g_xomcentral.CheckOverrideList( pszName, dwLine, &fCanLog ) )
            {
                fCanLog = ( chLevel >= m_chLevel );
            }

            //
            // No matter how it got figured out, we only want to log if there's a destination
            //
            fCanLog = fCanLog && ( m_cTargets > 0 );

        }
        while( g_dwLastChangeSignature != dwLastChangeSignature );

        dwNewCanLog = dwLastChangeSignature | fCanLog;

        InterlockedExchange( (LONG *) pdwCanLog, (LONG) dwNewCanLog );
    }

    return( fCanLog );
}

//////////////////////////////////////////////////////////////////////////////
CXomNtLogTarget::CXomNtLogTarget() :
    m_hEventLog( NULL ),
    m_pEventThrottle( NULL )
{
    InitializeCriticalSection( &m_csThrottle );
}

//////////////////////////////////////////////////////////////////////////////
CXomNtLogTarget::~CXomNtLogTarget()
{
    if( NULL != m_hEventLog )
    {
        DeregisterEventSource( m_hEventLog );
        m_hEventLog = NULL;
    }

    EnterCriticalSection( &m_csThrottle );

    delete m_pEventThrottle;
    m_pEventThrottle = NULL;

    LeaveCriticalSection( &m_csThrottle );

    DeleteCriticalSection( &m_csThrottle );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CXomNtLogTarget::Init( LPCSTR pszSource )
{
    HRESULT hr = S_OK;

    XOMASSERT( NULL == m_hEventLog );
    m_hEventLog = RegisterEventSourceA( NULL, pszSource );

    if( NULL == m_hEventLog )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto lDone;
    }

    XOMASSERT( NULL == m_pEventThrottle );

    EnterCriticalSection( &m_csThrottle );

    m_pEventThrottle = new CNtEventThrottle;

    LeaveCriticalSection( &m_csThrottle );

    if( NULL == m_pEventThrottle )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

lDone:
    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
BOOL CXomNtLogTarget::EventInit(
                        DWORD dwEventID,
                        const char* pszEventLine,
                        CNtEventThrottle::ALLOW_TYPE eAllowType,
                        BOOL fRateUnitsAreBytes,
                        DWORD dwAlertUnitsPerSec,
                        QWORD hnsEventInterval,
                        BOOL fTrackPerIP )
{
    BOOL fOk = FALSE;

    EnterCriticalSection( &m_csThrottle );

    if( NULL != m_pEventThrottle )
    {
        fOk = m_pEventThrottle->Initialize(
                                    dwEventID,
                                    pszEventLine,
                                    eAllowType,
                                    fRateUnitsAreBytes,
                                    dwAlertUnitsPerSec,
                                    hnsEventInterval,
                                    fTrackPerIP );
    }

    LeaveCriticalSection( &m_csThrottle );

    return( fOk );
}

//////////////////////////////////////////////////////////////////////////////
void CXomNtLogTarget::DumpEventList(DWORD dwRequestId, CXomControlResponseInterface* pResponseInterface)
{
    EnterCriticalSection( &m_csThrottle );

    m_pEventThrottle->DumpEventConfig(dwRequestId, pResponseInterface);

    LeaveCriticalSection( &m_csThrottle );

}

//////////////////////////////////////////////////////////////////////////////
BOOL CXomNtLogTarget::OkToLog(
                        QWORD hnsNow,
                        DWORD dwEventID,
                        LPCSTR pszText,
                        WORD wPacketSize,
                        DWORD *pina,
                        BOOL *pfAllowThisEvent,
                        DWORD *pdwNumSkips,
                        DWORD *pdwNumSkipsTotal,
                        DWORD *pdwRecentRate )
{
    BOOL fOk = FALSE;

    EnterCriticalSection( &m_csThrottle );

    if( NULL != m_pEventThrottle )
    {
        fOk = m_pEventThrottle->ProcessEvent(
                                    hnsNow,
                                    dwEventID,
                                    pszText,
                                    wPacketSize,
                                    pina,
                                    pfAllowThisEvent,
                                    pdwNumSkips,
                                    pdwNumSkipsTotal,
                                    pdwRecentRate );
    }

    LeaveCriticalSection( &m_csThrottle );

    return( fOk );
}

//////////////////////////////////////////////////////////////////////////////
void CXomNtLogTarget::Log( CLogFormatedMessage* pMsg )
{
    static const WORD leveltypemapping[] =
    {
        /*L_LOW*/    EVENTLOG_INFORMATION_TYPE,
        /*L_NORMAL*/ EVENTLOG_INFORMATION_TYPE,
        /*L_HIGH*/   EVENTLOG_WARNING_TYPE,
        /*L_ERROR*/  EVENTLOG_ERROR_TYPE
    };

    if (pMsg->GetFlowToken().IsValid())
    {
        pMsg->Prepend("Floken: FT%016I64X\r\n\r\n", pMsg->GetFlowToken().flowToken);
    }

    LPCSTR pszText = pMsg->GetText();

    ReportEventA(
            m_hEventLog,
            leveltypemapping[ pMsg->GetLevel() ],
            0,
            pMsg->GetEventId(),
            NULL,
            1,
            0,
            &pszText,
            NULL );
}


//////////////////////////////////////////////////////////////////////////////
CXomLogArea* CXomLoggingControl::s_rgpLogArea[c_xomMaxLogAreas];
DWORD CXomLoggingControl::s_cLogArea = 0;


CXomLoggingControl::CXomLoggingControl()
{
    m_fOverride = false;
    m_pIOCP = NULL;
    m_fTerm = false;
}

CXomLoggingControl::~CXomLoggingControl()
{
    Terminate();
}

void CXomLoggingControl::RegisterArea(
    CXomLogArea* pArea
)
{
    LONG lIndex = InterlockedIncrement((LONG*)&s_cLogArea) - 1;

    XOMASSERT(lIndex < c_xomMaxLogAreas);

    s_rgpLogArea[lIndex] = pArea;
}

HRESULT CXomLoggingControl::Init(
    CCompletionPort* pIOCP
)
{
    HRESULT hr = S_OK;
    int     iErr;
    WORD    wVersionRequested;
    WSADATA wsaData;

    m_pIOCP = pIOCP;
    m_pIOCP->AddRef();

    hr = g_xomcentral.RegisterControlCallback((CXomControlCallback*)this);

    if (FAILED(hr))
    {
        goto lDone;
    }

    //
    // Initialize Winsock library
    //

    wVersionRequested = MAKEWORD(2, 2);

    iErr = WSAStartup(wVersionRequested, &wsaData);

    if (0 != iErr)
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING, "[CXomLoggingControl::Init] WSAStartup failed, hr = 0x%08x", hr );
        goto lDone;
    }

    hr = m_TargetList.Initialize(8);

    if (FAILED(hr))
    {
        goto lDone;
    }

    //
    // Get the default target settings
    //

    hr = g_xomcentral.GetSetting(
        Setting_xmgmt_default_target_settings,
        &g_pszDefaultTargetSettings
        );
    if (FAILED(hr))
    {
        g_pszDefaultTargetSettings = NULL;
    }

    //
    // Create the default debug output setting
    //

    m_oDebugOutputTarget.SetTargetName("DebugOutput");
    if (!m_TargetList.AddTail((void*)&m_oDebugOutputTarget))
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    //
    // Create targets by the areas loaded
    //

    hr = ConfigureAreas();
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_1, "[CXomLoggingControl::Init] ConfigureAreas failed, hr = 0x%08x", hr );
        goto lDone;
    }

    hr = ConfigureEvents();
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_2, "[CXomLoggingControl::Init] ConfigureEvents failed, hr = 0x%08x", hr );
        goto lDone;
    }

    if (QueryPerformanceFrequency(&m_liTicksPerSec))
    {
        INT64 i = m_liTicksPerSec.QuadPart;
        UINT pad = 0;

        while (i > 0)
        {
            pad++;
            i /= 10;
        }

        sprintf(m_szFormat, "%%02d:%%02d:%%02d.%%0%dd", pad);
    }
    QueryPerformanceCounter(&m_liInitCount);
lDone:

    return hr;
}

HRESULT CXomLoggingControl::InitNTLogTarget(
    LPCSTR pszSource
)
{
    HRESULT hr = S_OK;

    hr = m_oNTLogTarget.Init(pszSource);

    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = m_oNTLogTarget.SetTargetName( c_szNTLogTargetName );

    if(FAILED(hr))
    {
        goto lDone;
    }

    XomAreaObjDecoration(DefaultNtLog).SetFilterLevel(L_LOW);
    XomAreaObjDecoration(DefaultNtLog).AddTarget(&m_oNTLogTarget);
    XomAreaObjDecoration(DefaultNtLog).SetIsEventLog();

lDone:

    return hr;
}

void CXomLoggingControl::Terminate()
{
    CXomTargetBase* pTarget;
    DWORD dwAreaNdx;

    if(m_fTerm)
    {
        return;
    }

    m_fTerm = true;

    g_xomcentral.UnregisterControlCallback((CXomControlCallback*)this);

    //
    // Release targets
    //

    m_lockTargetList.WriteLock();

    while(m_TargetList.RemoveHead((void**)&pTarget))
    {
        pTarget->Term();
        pTarget->Release();
    }

    m_lockTargetList.WriteUnlock();

    //
    // Terminate areas
    //

    for(dwAreaNdx=0; dwAreaNdx < s_cLogArea; dwAreaNdx++)
    {
        s_rgpLogArea[dwAreaNdx]->Terminate();
    }

    SAFE_RELEASE(m_pIOCP);

}

HRESULT CXomLoggingControl::ConfigureAreas()
{
    CXomNameValuePairList oParams;
    CXomTargetBase *      pTarget;
    DWORD                 nParam;
    DWORD                 nArea;
    HRESULT               hr = S_OK;
    LPCSTR                pszEnable;
    LPCSTR                pszTarget;
    LPSTR                 pszSetting;

    pszSetting = NULL;

    for (nArea = 0; nArea < s_cLogArea; ++nArea)
    {
        hr = g_xomcentral.GetSetting(
            s_rgpLogArea[nArea]->GetAreaSetting(),
            &pszSetting
            );
        if (FAILED(hr))
        {
            // No setting
            continue;
        }

        //
        // Parse the target name from the area name
        //

        hr = oParams.Parse(pszSetting);
        if(FAILED(hr))
        {
            XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_3,
                "[CXomLoggingControl::ConfigureAreas()] oParams.Parse failed, hr = 0x%08x",
                hr
                );
            goto lDone;
        }
        free(pszSetting);
        pszSetting = NULL;

        //
        // In order to support multiple targets per area, we have to examine
        // each parsed element
        //

        for (nParam = 0; nParam < oParams.GetCount(); ++nParam)
        {
            //
            // Grab the name of the target. We have to make sure that the target
            // is created before we try to enable it
            //

            if ( _stricmp( oParams.GetName(nParam), "target") == 0)
            {
                pszTarget = oParams.GetValue(nParam);

                //
                // Find the target by name. It may not exist however
                //

                hr = FindTarget( pszTarget, NULL );
                if (FAILED(hr))
                {
                    //
                    // We have to create it
                    //

                    hr = CreateTarget( pszTarget );
                    if (FAILED(hr))
                    {
                        continue;
                    //    goto lDone;
                    }
                }
                hr = FindTarget( pszTarget, &pTarget );
                if (FAILED(hr))
                {
                    XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_4,
                        "[CXomLoggingControl::CreateTarget()] specified target not found '%s', hr = 0x%08x",
                        pszTarget,
                        hr
                        );
                    goto lDone;
                }

                //
                // At this point, we must have a valid target
                //
                hr = s_rgpLogArea[nArea]->AddTarget(pTarget);
                if(FAILED(hr))
                {
                    XomNtEvent( XEVENT_COMMON_CONFIG_307,
                        "[CXomLoggingControl::ConfigureAreas()] Target.AddTarget(%s) failed, hr = 0x%08x",
                        pszTarget,
                        hr
                        );
                    goto lDone;
                }

            }

            //
            // Grab the enable value
            //

            if ( _stricmp( oParams.GetName(nParam), "enable") == 0)
            {
                pszEnable = oParams.GetValue(nParam);

                //
                // Special case. Can't override the DefaultNtLog area.
                //

                if (s_rgpLogArea[nArea] == &XomAreaObjDecoration(DefaultNtLog))
                {
                    continue;
                }

                char chLevel = L_MUTED;

                hr = ParseFilterLevel(pszEnable, &chLevel);
                if(FAILED(hr))
                {
                    XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_5,
                        "[CXomLoggingControl::ConfigureAreas()] unknown log area level '%s', hr = 0x%08x",
                        (pszTarget == NULL ? "Unknown" : pszTarget),
                        hr
                        );
                    goto lDone;
                }

                //
                // Set the filter level
                //

                s_rgpLogArea[nArea]->SetFilterLevel(chLevel);
            }
        }
    }

lDone:

    if ( pszSetting != NULL )
    {
        free(pszSetting);
        pszSetting = NULL;
    }

    return hr;
}

HRESULT CXomLoggingControl::ParseFilterLevel(
    LPCSTR pszParam,
    char* pchLevel
)
{
    HRESULT hr = S_OK;

    if( _stricmp(pszParam, "-1") == 0 )
    {
        // Level '-1' is supported to remain consistent with the C# version
        // of the library. Internally it translates to L_MUTED
        *pchLevel = L_MUTED;
    }
    else if(
        _stricmp(pszParam, "0")   == 0 ||
        _stricmp(pszParam, "low") == 0 ||
        _stricmp(pszParam, "on")  == 0 ||
        _stricmp(pszParam, "yes") == 0 )
    {
        *pchLevel = L_LOW;
    }
    else if(
        _stricmp(pszParam, "1")      == 0 ||
        _stricmp(pszParam, "info")   == 0 ||
        _stricmp(pszParam, "normal") == 0 )
    {
        *pchLevel = L_NORMAL;
    }
    else if(
        _stricmp(pszParam, "2")       == 0 ||
        _stricmp(pszParam, "high")    == 0 ||
        _stricmp(pszParam, "warning") == 0 )
    {
        *pchLevel = L_HIGH;
    }
    else if(
        _stricmp(pszParam, "3")     == 0 ||
        _stricmp(pszParam, "error") == 0 )
    {
        *pchLevel = L_ERROR;
    }
    else if(
        _stricmp(pszParam, "4")     == 0 ||
        _stricmp(pszParam, "muted") == 0 ||
        _stricmp(pszParam, "off")   == 0 ||
        _stricmp(pszParam, "no")    == 0)
    {
        *pchLevel = L_MUTED;
    }
    else
    {
        *pchLevel = L_MUTED;
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CXomLoggingControl::ConfigureEvents()
{
    CXomNameValuePairList oParams;
    DWORD nParam;
    HRESULT hr = S_OK;
    SAFEARRAY *psaSettings;
    CComSafeArray<BSTR> saSettings;

    LPSTR pszSetting = NULL;

    int size = 0;

    if ( FAILED(g_xomcentral.GetMultiSetting( MultiSetting_xmgmt_eventThrottles, &psaSettings)) )
    {
        // no event settings, no problem
        goto lDone;
    }

    if ( FAILED(saSettings.Attach( psaSettings )) )
    {
        goto lDone;
    }

    if (saSettings.GetCount() == 0)
    {
        // no event settings, no problem
        goto lDone;
    }

    size = (int)saSettings.GetCount();
    int capacity = m_oNTLogTarget.GetEventThrottleCapacity();
    if( capacity < size )
    {
        // too many settings to store
        XomNtEvent( XEVENT_COMMON_CONFIG_311, "[CXomLoggingControl::ConfigureEvents()] ApplyEventSettings cannot store %d settings (truncated to %d settings)", size, capacity);
        size = capacity;
    }

    //
    // Loop through all event throttles, applying their settings
    //

    for (int i = 0; i < size; i++)
    {
        hr = oParams.Parse(saSettings[i]);

        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_COMMON_CONFIG_310, "[CXomLoggingControl::ConfigureEvents()] Couldn't parse event config string '%s', hr = 0x%08x", pszSetting, hr );
            continue;
        }

        hr = ApplyEventSettings( oParams );

        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_COMMON_CONFIG_311, "[CXomLoggingControl::ConfigureEvents()] ApplyEventSettings failed for config string '%s', hr = 0x%08x", pszSetting, hr );
            continue;
        }
    }

    hr = S_OK;

lDone:

    if ( psaSettings != NULL )
    {
        SafeArrayDestroy(psaSettings);
        psaSettings = NULL;
    }

    return( hr );
}

HRESULT CXomLoggingControl::ApplyEventSettings( CXomNameValuePairList &oParams )
{
    HRESULT hr = S_OK;

    //
    // Initialize event settings to their defaults
    //
    CNtEventThrottle::ALLOW_TYPE eAllowType = CNtEventThrottle::UNKNOWN;
    BOOL fRateUnitsAreBytes = FALSE;
    DWORD dwAlertUnitsPerSec = 0;
    QWORD hnsAlertInterval = 0;
    BOOL fTrackPerIP = FALSE;
    DWORD dwEventID = 0;
    char szSearchText[CNtEventThrottle::MAX_SEARCH_TEXT_LEN];

    memset(szSearchText, 0, sizeof(szSearchText));

    for( DWORD iParam = 0; iParam < oParams.GetCount(); iParam++ )
    {
        if( 0 == _stricmp( oParams.GetName( iParam ), "id" ) )
        {
            dwEventID = strtoul( oParams.GetValue( iParam ), NULL, 10 );
        }
        else if ( 0 == _stricmp( oParams.GetName( iParam ), "text" ) )
        {
            strncpy(szSearchText, oParams.GetValue(iParam), CNtEventThrottle::MAX_SEARCH_TEXT_LEN);
        }
        else if( 0 == _stricmp( oParams.GetName( iParam ), "freq" ) )
        {
            if( ( 0 == _stricmp( oParams.GetValue( iParam ), "maybe" ) ) ||
                ( 0 == _stricmp( oParams.GetValue( iParam ), "some" ) ) ||
                ( 0 == _stricmp( oParams.GetValue( iParam ), "sometimes" ) ) )
            {
                eAllowType = CNtEventThrottle::SOMETIMES_ALLOW;
            }
            else if( ( 0 == _stricmp( oParams.GetValue( iParam ), "no" ) ) ||
                     ( 0 == _stricmp( oParams.GetValue( iParam ), "none" ) ) ||
                     ( 0 == _stricmp( oParams.GetValue( iParam ), "never" ) ) )
            {
                eAllowType = CNtEventThrottle::NEVER_ALLOW;
            }
            else if( ( 0 == _stricmp( oParams.GetValue( iParam ), "all" ) ) ||
                     ( 0 == _stricmp( oParams.GetValue( iParam ), "always" ) ) ||
                     ( 0 == _stricmp( oParams.GetValue( iParam ), "yes" ) ) )
            {
                eAllowType = CNtEventThrottle::ALWAYS_ALLOW;
            }
            else
            {
                hr = E_INVALIDARG;
                goto lDone;
            }
        }
        else if( 0 == _stricmp( oParams.GetName( iParam ), "rateunits" ) )
        {
            if( ( 0 == _stricmp( oParams.GetValue( iParam ), "bytes" ) ) ||
                ( 0 == _stricmp( oParams.GetValue( iParam ), "data" ) ) )
            {
                fRateUnitsAreBytes = TRUE;
            }
            else if( ( 0 == _stricmp( oParams.GetValue( iParam ), "events" ) ) ||
                     ( 0 == _stricmp( oParams.GetValue( iParam ), "packets" ) ) )
            {
                fRateUnitsAreBytes = FALSE;
            }
            else
            {
                hr = E_INVALIDARG;
                goto lDone;
            }

            if (eAllowType == CNtEventThrottle::UNKNOWN)
                eAllowType = CNtEventThrottle::SOMETIMES_ALLOW;
        }
        else if( 0 == _stricmp( oParams.GetName( iParam ), "alertrate" ) )
        {
            dwAlertUnitsPerSec = strtoul( oParams.GetValue( iParam ), NULL, 0 );

            if( ULONG_MAX == dwAlertUnitsPerSec )
            {
                hr = E_INVALIDARG;
                goto lDone;
            }

            if (eAllowType == CNtEventThrottle::UNKNOWN)
                eAllowType = CNtEventThrottle::SOMETIMES_ALLOW;
        }
        else if( 0 == _stricmp( oParams.GetName( iParam ), "intervalsecs" ) )
        {
            hnsAlertInterval = _strtoui64( oParams.GetValue( iParam ), NULL, 0 );

            if( _UI64_MAX == hnsAlertInterval )
            {
                hr = E_INVALIDARG;
                goto lDone;
            }

            hnsAlertInterval *= CNtEventThrottle::HNS_PER_SECOND;

            if (eAllowType == CNtEventThrottle::UNKNOWN)
                eAllowType = CNtEventThrottle::SOMETIMES_ALLOW;
        }
        else if( 0 == _stricmp( oParams.GetName( iParam ), "intervalhns" ) )
        {
            hnsAlertInterval = _strtoui64( oParams.GetValue( iParam ), NULL, 0 );

            if( _UI64_MAX == hnsAlertInterval )
            {
                hr = E_INVALIDARG;
                goto lDone;
            }

            if (eAllowType == CNtEventThrottle::UNKNOWN)
                eAllowType = CNtEventThrottle::SOMETIMES_ALLOW;
        }
        else if( 0 == _stricmp( oParams.GetName( iParam ), "comment" ) )
        {
            // ignore this
        }
        else
        {
            hr = E_INVALIDARG;
            goto lDone;
        }
    }

    if( !m_oNTLogTarget.EventInit(
                            dwEventID,
                            szSearchText,
                            eAllowType,
                            fRateUnitsAreBytes,
                            dwAlertUnitsPerSec,
                            hnsAlertInterval,
                            fTrackPerIP ) )
    {
        hr = E_FAIL;
        goto lDone;
    }

lDone:
    return( hr );
}


HRESULT CXomLoggingControl::CreateTarget(
    LPCSTR pszTargetName,
    LPCSTR pszParam,
    DWORD dwAdminId
)
{
    CXomNameValuePairList oParams;
    LPCSTR pszType;
    CXomTargetBase* pTarget = NULL;
    LPCSTR pszFilter = NULL;
    LPCSTR pszPersist = NULL;
    bool fPersist = true;
    HRESULT hr = S_OK;

    // Parse the parameters.

    hr = oParams.Parse(pszParam);

    if(FAILED(hr))
    {
        goto lDone;
    }

    // Parameter type is mandatory and indicates the type of the target.

    pszType = oParams.GetValueByName("Type");

    if(NULL == pszType)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    if(_stricmp(pszType, "File") == 0)
    {
        // Target is a file

        GOTO_LDONE_IF_FAILED_ALLOC(
            pTarget = new CXomFileTarget );
    }
    else if(_stricmp(pszType, "Remote") == 0)
    {
        // Target is remote

        GOTO_LDONE_IF_FAILED_ALLOC(
            pTarget = new CXomRemoteTarget );

        // Remote targets has default 'persist' = false because we don't want
        // remote targets getting created dynamically and left forgotten
        // spamming the network with undeliverable UDP packets. However you
        // can always override this option by adding Persist=false to the
        // target parameters.

        fPersist = false;
    }
    else if(_stricmp(pszType, "Report") == 0)
    {
        // Target is the reporting target

        GOTO_LDONE_IF_FAILED_ALLOC(
            pTarget = new CXomReportTarget );
    }
    else
    {
        // Invalid target type

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Optional 'Persist' parameter specifies whether or not the target's life
    // is tied to the admin session that created it.

    pszPersist = oParams.GetValueByName("Persist");

    if( pszPersist != NULL )
    {
        if(_stricmp(pszPersist, "yes") == 0
            || _stricmp(pszPersist, "true") == 0
            || _stricmp(pszPersist, "1") == 0)
        {
            fPersist = true;
        }
        else
        {
            fPersist = false;
        }
    }

    // Initialize target

    GOTO_LDONE_IF_FAILED_HR(
        pTarget->Init(m_pIOCP, pszParam, g_pszDefaultTargetSettings ) );

    if(!fPersist)
    {
        pTarget->SetAdminId(dwAdminId);
    }

    GOTO_LDONE_IF_FAILED_HR(
        pTarget->SetTargetName(pszTargetName) );

    // Add target to list

    m_lockTargetList.WriteLock();

    LISTPOS res = m_TargetList.AddTail((void*)pTarget);

    m_lockTargetList.WriteUnlock();

    if(!res)
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_6,
            "[CXomLoggingControl::CreateTarget] failed to enlist target object. Out of memory perhaps?" );
        goto lDone;
    }

    pTarget = NULL;

lDone:

    SAFE_RELEASE(pTarget);

    return hr;
}

HRESULT CXomLoggingControl::CreateTarget(
    LPCSTR              pszTargetName
)
{
    CComBSTR    bstrTarget;
    HRESULT     hr = S_OK;
    LPSTR       pszParams = NULL;
    LPSTR       pszExpandedParams = NULL;

    //
    // Build the CComBSTR that corresponds to the target that we want to build
    //

    bstrTarget.AppendBSTR( Setting_xmgmt_target_ );
    bstrTarget.Append( pszTargetName );

    //
    // Resolve that to a setting
    //

    hr = g_xomcentral.GetSetting( bstrTarget, & pszParams );
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_4,
            "[CXomLoggingControl::CreateTarget()] specified target not found '%s', hr = 0x%08x",
            pszTargetName,
            hr
            );
        hr = E_INVALIDARG;
        goto lDone;
    }

    //
    // Expand out the params to their final form
    //

    pszExpandedParams = ExpandTargetValues( pszParams );

    //
    // Create the target
    //

    hr = CreateTarget( pszTargetName, pszExpandedParams, 0 );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:

    if (pszParams != NULL)
    {
        free(pszParams);
        pszParams = NULL;
    }
    if (pszExpandedParams != NULL)
    {
        free(pszExpandedParams);
        pszExpandedParams = NULL;
    }
    return hr;
}

HRESULT CXomLoggingControl::DeleteTarget(
    CXomTargetBase* pDelTarget
)
{
    HRESULT hr = S_OK;
    LISTPOS pos, pos2;
    CXomTargetBase* pTarget = NULL;
    DWORD nArea;

    // First find the target and remove it from the target list.

    m_lockTargetList.WriteLock();

    pos = m_TargetList.GetHeadPosition();
    pos2 = pos;

    while(m_TargetList.GetNext(pos, (void**)&pTarget))
    {
        if(pTarget == pDelTarget)
        {
            m_TargetList.RemoveAt(pos2);
            break;
        }

        pTarget = NULL;
        pos2 = pos;
    }

    m_lockTargetList.WriteUnlock();

    if(NULL == pTarget)
    {
        // Target not found

        hr = E_FAIL;
        goto lDone;
    }

    // Remove target from all areas

    for(nArea=0; nArea < s_cLogArea; nArea++)
    {
        s_rgpLogArea[nArea]->RemoveTarget(pTarget);
    }

    // Finally, close object

    pTarget->Term();
    pTarget->Release();

lDone:

    return hr;
}

HRESULT CXomLoggingControl::FindTarget(
    LPCSTR pszTargetName,
    CXomTargetBase** ppTarget
    )
{
    bool            fFound = false;
    CXomTargetBase* pTarget;
    HRESULT         hr = E_FAIL;
    LISTPOS         pos;

    //
    // Loop for every element in the target list
    //
    // NOTE: This code is currently only called from the init path, so the
    // the m_lockTargetList.WriteLock() is NOT TAKEN. This matches the
    // previous code's behavior.
    //

    pos = m_TargetList.GetHeadPosition();
    while (m_TargetList.GetNext( pos, (void **) &pTarget))
    {
        //
        // Check for match
        //

        if (_stricmp(pTarget->GetTargetName(), pszTargetName) != 0)
        {
            continue;
        }

        //
        // Match
        //

        fFound = true;
        hr = S_OK;
        break;
    }

    //
    // Did we get a match?
    //

    if (ppTarget != NULL)
    {
        if (fFound == true)
        {
            *ppTarget = pTarget;
        }
        else
        {
            *ppTarget = NULL;
        }
    }
    return hr;
}

HRESULT CXomLoggingControl::OnControlRequest(
    LPCSTR pszRequest,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    CXomParamList oParams;
    HRESULT hr = S_OK;

    hr = oParams.Parse(pszRequest);

    if(FAILED(hr))
    {
        goto lDone;
    }

    if(oParams.GetCount() < 1)
    {
        goto lDone;
    }

    if( _stricmp(oParams.GetParam(0), "AdminSessionDied") == 0)
    {
        // This is a special command sent by xmgmtsvc itself whenever a admin
        // client disconnects. This gives us the opportunity to clean up
        // everything whose lifetime was restricted to the admin session.
        // dwRequestId contains the Id of the session that just died.

        CleanUpAdminSessionObjects(dwRequestId);
    }
    else if( _stricmp(oParams.GetParam(0), "Help") == 0 ||
        _stricmp(oParams.GetParam(0), "h") == 0)
    {
        hr = ProcessCommandHelp(&oParams, dwRequestId, pResponseInterface);
    }
    else if( _stricmp(oParams.GetParam(0), "GetVersion") == 0 ||
        _stricmp(oParams.GetParam(0), "gv") == 0)
    {
        hr = ProcessCommandGetVersion(&oParams, dwRequestId, pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "ListAreas") == 0 ||
        _stricmp(oParams.GetParam(0), "la") == 0)
    {
        hr = ProcessCommandListAreas(&oParams, dwRequestId, pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "ListTargets") == 0 ||
        _stricmp(oParams.GetParam(0), "lt") == 0)
    {
        hr = ProcessCommandListTargets(&oParams, dwRequestId,
            pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "ChangeAreaLevel") == 0 ||
        _stricmp(oParams.GetParam(0), "cal") == 0)
    {
        hr = ProcessCommandChangeAreaLevel(&oParams, dwRequestId,
            pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "NewTarget") == 0 ||
        _stricmp(oParams.GetParam(0), "nt") == 0)
    {
        hr = ProcessCommandNewTarget(&oParams, dwRequestId,
            pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "DeleteTarget") == 0 ||
        _stricmp(oParams.GetParam(0), "dt") == 0)
    {
        hr = ProcessCommandDeleteTarget(&oParams, dwRequestId,
            pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "AddTarget") == 0 ||
        _stricmp(oParams.GetParam(0), "at") == 0)
    {
        hr = ProcessCommandAddTarget(&oParams, dwRequestId,
            pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "RemoveTarget") == 0 ||
        _stricmp(oParams.GetParam(0), "rt") == 0)
    {
        hr = ProcessCommandRemoveTarget(&oParams, dwRequestId,
            pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "ResetTarget") == 0 ||
        _stricmp(oParams.GetParam(0), "rst") == 0)
    {
        hr = ProcessCommandResetTarget(&oParams, dwRequestId,
            pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "ListOverrides") == 0 ||
        _stricmp(oParams.GetParam(0), "lo") == 0)
    {
        hr = ProcessCommandListOverrides(&oParams, dwRequestId,
            pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "SetOverride") == 0 ||
        _stricmp(oParams.GetParam(0), "so") == 0)
    {
        hr = ProcessCommandSetOverride(&oParams, dwRequestId,
            pResponseInterface);
    }
    else if(_stricmp(oParams.GetParam(0), "RemoveOverride") == 0 ||
        _stricmp(oParams.GetParam(0), "ro") == 0)
    {
        hr = ProcessCommandRemoveOverride(&oParams, dwRequestId,
            pResponseInterface);
    }
    else if( ( 0 == _stricmp( oParams.GetParam( 0 ), "AddEvent" ) ) ||
             ( 0 == _stricmp( oParams.GetParam( 0 ), "ae" ) ) )
    {
        hr = ProcessCommandEvent( &oParams, dwRequestId, pResponseInterface );
    }
    else if( ( 0 == _stricmp( oParams.GetParam( 0 ), "ListEvents" ) ) ||
             ( 0 == _stricmp( oParams.GetParam( 0 ), "le" ) ) )
    {
        hr = ProcessCommandListEvents( &oParams, dwRequestId, pResponseInterface );
    }
    else if( ( 0 == _stricmp( oParams.GetParam( 0 ), "UpTime" ) ) ||
             ( 0 == _stricmp( oParams.GetParam( 0 ), "ut" ) ) )
    {
        hr = ProcessCommandUpTime( &oParams, dwRequestId, pResponseInterface );
    }

lDone:

    return hr;
}

void CXomLoggingControl::CleanUpAdminSessionObjects( DWORD dwRequestId )
{
    if( 0 == dwRequestId )
    {
        return;
    }

    CXomTargetBase* pTarget;
    LISTPOS pos;
    bool fRepeat;

    m_lockTargetList.WriteLock();

    do
    {
        fRepeat = false;

        pos = m_TargetList.GetHeadPosition();

        while( m_TargetList.GetNext( pos, (void**) &pTarget ) )
        {
            if( pTarget->GetAdminId() == dwRequestId )
            {
                // This target says that it should be removed with this session.

                if( SUCCEEDED( DeleteTarget( pTarget ) ) )
                {
                    // After removing this target, 'pos' is invalid and we have
                    // to start from the beginning. Bummer.
                    fRepeat = true;
                }

                break;
            }
        }
    }
    while( fRepeat );

    m_lockTargetList.WriteUnlock();
}

HRESULT CXomLoggingControl::ProcessCommandHelp(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface )
{
    static const char szHelp[] =
        "Logging and tracing help:\r\n"
        "  GetVersion\r\n"
        "  UpTime\r\n"
        "  ListAreas\r\n"
        "  ListTargets\r\n"
        "  ChangeAreaLevel <area name> <level = 0,1,2,3,4>\r\n"
        "  NewTarget <target name> <target parameters>\r\n"
        "    where <target parameters> can be:\r\n"
        "       type=File;prefix=<filename prefix>;RotationTime=<time in minutes>;RotationSize=<size in bytes>\r\n"
        "       type=Remote;address=<ip or hostname of rtrace terminal>\r\n"
        "  DeleteTarget <target name>\r\n"
        "  AddTarget <target name> <area name>\r\n"
        "  RemoveTarget <target name> <area name>\r\n"
        "  ResetTarget <target name>\r\n"
        "  ListOverrides\r\n"
        "  SetOverride <filename> <line> <log 0=no, 1=yes>\r\n"
        "  RemoveOverride <override index>\r\n"
        "  ListEvents (le)\r\n"
        "  AddEvent (ae) <event params>\r\n"
        "    where <event params> are a ; delmited list of:\r\n"
        "       id=<eventid> OR text=<file:line> (required)\r\n"
        "       freq=<always|sometimes|never>\r\n"
        "       intervalsecs=<seconds between events>\r\n"
        "       alertrate=<# of events per second>\r\n"
        "    For example, to turn off the event thrown from wiredata.cs, line 719:\r\n"
        "      text=e:\\src\\xonline\\main\\private\\common\\service\\wiredata.cs:719;freq=never\r\n"
        "    or to limit it to every 5 seconds:\r\n"
        "      text=private\\common\\service\\wiredata.cs:719;intervalsecs=5\r\n"
        "    or to allow event id 2 up to twenty times per second:\r\n"
        "      id=2;alertrate=20\r\n"
        "    or to throttle event id 53900 to no more than once per 10 seconds:\r\n"
        "      id=53900;freq=sometimes;intervalsecs=10\r\n"
        "\r\n";

    return pResponseInterface->WriteResponse( dwRequestId, (BYTE*)szHelp, -1 );
}

HRESULT CXomLoggingControl::ProcessCommandGetVersion(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    HRESULT hr = S_OK;
    LPBYTE pbVersionData = NULL;
    DWORD dwVersionInfoSize = 0;
    CHAR szModuleFileName[MAX_PATH];
    VS_FIXEDFILEINFO* pFixedFileInfo;
    CGetCurrentModuleName oCurrentModule;

    // Get the module file name
    if (0 == GetModuleFileNameA(oCurrentModule.GetModuleHandle(), szModuleFileName, ARRAY_ELEMENTS(szModuleFileName)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto lDone;
    }
        szModuleFileName[ MAX_PATH - 1 ] = '\0';

    // Get the size of the buffer to be allocated for the version info
    dwVersionInfoSize = GetFileVersionInfoSizeA(szModuleFileName, NULL);
    if (0 == dwVersionInfoSize)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto lDone;
    }

    // Allocate a buffer for the info
    pbVersionData = new BYTE[ dwVersionInfoSize ];
    if( NULL == pbVersionData )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Get the version info
    if( !GetFileVersionInfoA( szModuleFileName, 0, dwVersionInfoSize, pbVersionData ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto lDone;
    }

    // Get the pointer to the FIXEDFILEINFO
    UINT uFixedInfoSize;
    if( !VerQueryValueA( pbVersionData, "\\", (void**) &pFixedFileInfo, &uFixedInfoSize ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto lDone;
    }

    XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "%d.%d.%d.%d\r\n",
            HIWORD(pFixedFileInfo->dwFileVersionMS),
            LOWORD(pFixedFileInfo->dwFileVersionMS),
            HIWORD(pFixedFileInfo->dwFileVersionLS),
            LOWORD(pFixedFileInfo->dwFileVersionLS));

lDone:
    SAFE_ARRAYDELETE( pbVersionData );

    return( hr );
}

HRESULT CXomLoggingControl::ProcessCommandListAreas(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface )
{
    CHAR szResponse[0x400];
    int cchResponse;
    DWORD nArea;
    DWORD nTarget;
    CXomLogArea* pArea;

    for(nArea=0; nArea < s_cLogArea; nArea++)
    {
        pArea = s_rgpLogArea[nArea];

        cchResponse = safe_snprintf(szResponse, ARRAY_ELEMENTS(szResponse),
            "Area:%s Level:%d Targets:", pArea->GetName(),
            pArea->GetFilterLevel());

        pArea->LockTargetList();

        for(nTarget=0; nTarget < pArea->GetTargetCount(); nTarget++)
        {
            cchResponse += safe_snprintf(szResponse + cchResponse,
                ARRAY_ELEMENTS(szResponse) - cchResponse, "%s ",
                pArea->GetTarget(nTarget)->GetTargetName());
        }

        pArea->UnlockTargetList();

        cchResponse += safe_snprintf(szResponse + cchResponse,
            ARRAY_ELEMENTS(szResponse) - cchResponse, "\r\n");

        XomWriteFormattedResponse(
                    pResponseInterface,
                    dwRequestId,
                    szResponse );
    }

    return( S_OK );
}

HRESULT CXomLoggingControl::ProcessCommandListTargets(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface )
{
    CXomTargetBase* pTarget;
    LISTPOS pos;

    m_lockTargetList.ReadLock();

    pos = m_TargetList.GetHeadPosition();

    while( m_TargetList.GetNext( pos, (void**) &pTarget ) )
    {
        XomWriteFormattedResponse(
                    pResponseInterface,
                    dwRequestId,
                    "Target:%s Params:%s\r\n",
                    pTarget->GetTargetName(),
                    pTarget->GetTargetParams() );
    }

    m_lockTargetList.ReadUnlock();

    return( S_OK );
}

HRESULT CXomLoggingControl::ProcessCommandChangeAreaLevel(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    HRESULT hr = S_OK;
    DWORD nArea;
    LPCSTR pszAreaName;
    BYTE bFilterLevel;
    BYTE bPreviousFilterLevel;

    if( pParams->GetCount() < 3 )
    {
        goto lDone;
    }

    pszAreaName = pParams->GetParam( 1 );

    if(FAILED(hr = ParseFilterLevel(pParams->GetParam(2), (char*) &bFilterLevel)))
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Invalid area level '%s'.\n",
                pParams->GetParam(2));

        goto lDone;
    }

    for( nArea = 0; nArea < s_cLogArea; nArea++ )
    {
        if( 0 == _stricmp( s_rgpLogArea[ nArea ]->GetName(), pszAreaName ) )
        {
            bPreviousFilterLevel = s_rgpLogArea[ nArea ]->GetFilterLevel();

            s_rgpLogArea[ nArea ]->SetFilterLevel( bFilterLevel );

            RegisterNewChange();

            XomWriteFormattedResponse(
                    pResponseInterface,
                    dwRequestId,
                    "Changed filter level of area %s from %d to %d\r\n",
                    s_rgpLogArea[ nArea ]->GetName(),
                    bPreviousFilterLevel,
                    bFilterLevel );
            break;
        }
    }

lDone:

    return( hr );
}

HRESULT CXomLoggingControl::ProcessCommandNewTarget(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    HRESULT hr = S_OK;
    LPCSTR pszTargetName;
    LPCSTR pszParams;

    if( pParams->GetCount() < 3 )
    {
        goto lDone;
    }

    pszTargetName = pParams->GetParam( 1 );

    pszParams = pParams->GetParam( 2 );

    m_lockTargetList.ReadLock();
    hr = FindTarget( pszTargetName, NULL );
    m_lockTargetList.ReadUnlock();

    if (hr == S_OK)
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error: target already exists.\r\n");
        goto lDone;
    }

    hr = CreateTarget( pszTargetName, pszParams, dwRequestId );

    if( FAILED( hr ) )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error: failed to create target.\r\n");
        goto lDone;
    }

    RegisterNewChange();

    XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Target %s was created successfully.\r\n",
            pszTargetName );

lDone:
    return( hr );
}

HRESULT CXomLoggingControl::ProcessCommandDeleteTarget(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    HRESULT hr = S_OK;
    LPCSTR pszTargetName;
    CXomTargetBase* pTarget = NULL;
    LISTPOS pos;

    if( pParams->GetCount() < 2 )
    {
        goto lDone;
    }

    pszTargetName = pParams->GetParam( 1 );

    //
    // Find the target
    //
    m_lockTargetList.WriteLock();

    pos = m_TargetList.GetHeadPosition();

    while( m_TargetList.GetNext( pos, (void**) &pTarget ) )
    {
        if( 0 == _stricmp( pTarget->GetTargetName(), pszTargetName ) )
        {
            DeleteTarget( pTarget );
            break;
        }

        pTarget = NULL;
    }

    m_lockTargetList.WriteUnlock();

    if( NULL == pTarget )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error: target not found\r\n" );

        hr = E_INVALIDARG;
        goto lDone;
    }

    RegisterNewChange();

    XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Target deleted.\r\n" );

lDone:
    return( hr );
}


HRESULT CXomLoggingControl::ProcessCommandAddTarget(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    HRESULT hr = S_OK;
    LPCSTR pszAreaName;
    LPCSTR pszTargetName;
    DWORD nArea;
    LISTPOS pos;
    CXomLogArea* pArea = NULL;
    CXomTargetBase* pTarget = NULL;


    if( pParams->GetCount() < 3 )
    {
        goto lDone;
    }

    pszTargetName = pParams->GetParam( 1 );

    pszAreaName = pParams->GetParam( 2 );


    //
    // Find the area
    //
    for( nArea = 0; nArea < s_cLogArea; nArea++ )
    {
        if( 0 == _stricmp( s_rgpLogArea[ nArea ]->GetName(), pszAreaName ) )
        {
            pArea = s_rgpLogArea[ nArea ];
            break;
        }
    }

    if( NULL == pArea )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error: area not found\r\n" );
        hr = E_INVALIDARG;
        goto lDone;
    }

    //
    // Find the target
    //
    m_lockTargetList.ReadLock();

    pos = m_TargetList.GetHeadPosition();

    while( m_TargetList.GetNext( pos, (void**) &pTarget ) )
    {
        if( 0 == _stricmp( pTarget->GetTargetName(), pszTargetName ) )
        {
            break;
        }

        pTarget = NULL;
    }

    if( NULL == pTarget )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error: target not found\r\n" );

        m_lockTargetList.ReadUnlock();

        hr = E_INVALIDARG;
        goto lDone;
    }

    //
    // Assign it to the area
    //
    pArea->AddTarget( pTarget );

    m_lockTargetList.ReadUnlock();

    RegisterNewChange();

    XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Target %s assigned to area %s\r\n",
            pszTargetName,
            pszAreaName );

lDone:
    return( hr );
}

HRESULT CXomLoggingControl::ProcessCommandRemoveTarget(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    HRESULT hr = S_OK;
    LPCSTR pszAreaName;
    LPCSTR pszTargetName;
    DWORD nArea;
    DWORD nTarget;
    CXomLogArea* pArea = NULL;
    CXomTargetBase* pTarget = NULL;

    if( pParams->GetCount() < 3 )
    {
        goto lDone;
    }

    pszTargetName = pParams->GetParam( 1 );

    pszAreaName = pParams->GetParam( 2 );

    //
    // Find the area
    //
    for( nArea = 0; nArea < s_cLogArea; nArea++ )
    {
        if( 0 == _stricmp( s_rgpLogArea[ nArea ]->GetName(), pszAreaName ) )
        {
            pArea = s_rgpLogArea[ nArea ];
            break;
        }
    }

    if( NULL == pArea )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error: area not found\r\n" );

        hr = E_INVALIDARG;
        goto lDone;
    }

    //
    // Find the target inside that area
    //
    pArea->LockTargetList();

    for( nTarget=0; nTarget < pArea->GetTargetCount(); nTarget++ )
    {
        pTarget = pArea->GetTarget( nTarget );

        if( 0 == _stricmp( pTarget->GetTargetName(), pszTargetName ) )
        {
            break;
        }

        pTarget = NULL;
    }

    if( NULL == pTarget )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error: target not found\r\n");

        pArea->UnlockTargetList();

        hr = E_INVALIDARG;
        goto lDone;
    }

    //
    // We found the target object that we want to remote but we need to get out
    // of the lock before calling RemoteTarget. However, after we leave the
    // lock, it could be released, so we're going to addref it.
    //
    pTarget->AddRef();
    pArea->UnlockTargetList();

    //
    // Now we can call RemoveTarget and finally release the object.
    //
    pArea->RemoveTarget(pTarget);
    pTarget->Release();

    RegisterNewChange();

    XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Target removed.\r\n" );

lDone:

    return hr;

}

HRESULT CXomLoggingControl::ProcessCommandResetTarget(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    HRESULT hr = S_OK;
    LPCSTR pszTargetName;
    CXomTargetBase* pTarget = NULL;
    LISTPOS pos;

    if( pParams->GetCount() < 2 )
    {
        goto lDone;
    }

    pszTargetName = pParams->GetParam( 1 );

    //
    // Find the target
    //
    m_lockTargetList.WriteLock();

    pos = m_TargetList.GetHeadPosition();

    while( m_TargetList.GetNext( pos, (void**) &pTarget ) )
    {
        if( 0 == _stricmp( pTarget->GetTargetName(), pszTargetName ) )
        {
            pTarget->AddRef();
            break;
        }

        pTarget = NULL;
    }

    m_lockTargetList.WriteUnlock();

    if( NULL == pTarget )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error: target not found\r\n" );

        hr = E_INVALIDARG;
        goto lDone;
    }

    hr = pTarget->ResetTarget();

    if( FAILED( hr ) )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error: Reset failed (%X)\r\n",
                hr );

        goto lDone;
    }

    RegisterNewChange();

    XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Target reset.\r\n" );

lDone:
    SAFE_RELEASE( pTarget );

    return( hr );
}

HRESULT CXomLoggingControl::ProcessCommandListOverrides(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    OVERRIDE_ENTRY* pOverride;

    DWORD dwOverNdx;

    m_lockOverrideList.ReadLock();

    for( dwOverNdx = 0; dwOverNdx < m_OverrideList.GetSize(); dwOverNdx++ )
    {
        if( !m_OverrideList.GetAt( dwOverNdx, (void**) &pOverride ) )
        {
            break;
        }

        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "%d: F:%s L:%d On:%d\r\n",
                dwOverNdx,
                pOverride->szFile,
                pOverride->dwLine,
                pOverride->fCanLog );
    }

    m_lockOverrideList.ReadUnlock();

    if( 0 == dwOverNdx )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "No overrides currently active\r\n" );
    }

    return( S_OK );
}

HRESULT CXomLoggingControl::ProcessCommandSetOverride(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    LPCSTR pszFile;
    DWORD dwLine;
    DWORD dwOverNdx;
    BOOL fLog;

    if( pParams->GetCount() < 4 )
    {
        goto lDone;
    }

    pszFile = pParams->GetParam( 1 );
    dwLine = strtoul( pParams->GetParam( 2 ), NULL, 0 );
    fLog = atoi( pParams->GetParam( 3 ) );

    if( !SetOverride( pszFile, dwLine, fLog, &dwOverNdx ) )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Override set failed\r\n" );
        goto lDone;
    }

    RegisterNewChange();

    XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Override #%d added/altered\r\n",
            dwOverNdx );

lDone:
    return( S_OK );
}

HRESULT CXomLoggingControl::ProcessCommandRemoveOverride(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    DWORD dwOverNdx;

    if(pParams->GetCount() < 2)
    {
        goto lDone;
    }

    dwOverNdx = strtoul( pParams->GetParam( 1 ), NULL, 0 );

    if( !RemoveOverride( dwOverNdx ) )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Override remove of index %d failed\r\n",
                dwOverNdx );
        goto lDone;
    }

    RegisterNewChange();

    XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Override %d removed\r\n",
            dwOverNdx );

lDone:
    return( S_OK );
}

HRESULT CXomLoggingControl::ProcessCommandEvent(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    CXomNameValuePairList oParams;
    HRESULT hr = S_OK;

    if( pParams->GetCount() < 2 )
    {
        goto lDone;
    }

    //
    // First attempt to parse the event params
    //
    hr = oParams.Parse( pParams->GetParam( 1 ) );

    if( FAILED( hr ) )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error (%X) parsing event parameters.\r\n",
                hr );
        goto lDone;
    }

    //
    // Now apply the settings to the given event ID
    //

    hr = ApplyEventSettings( oParams );

    if( FAILED( hr ) )
    {
        XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "Error (%X) applying event settings\r\n",
                hr );
        goto lDone;
    }

    XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Event settings applied.\r\n" );

lDone:
    return( hr );
}

HRESULT CXomLoggingControl::ProcessCommandListEvents(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    m_oNTLogTarget.DumpEventList(dwRequestId, pResponseInterface);

    return( S_OK );
}

HRESULT CXomLoggingControl::ProcessCommandUpTime(
    CXomParamList* pParams,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface
)
{
    LARGE_INTEGER liCurrent = {0};

    if (QueryPerformanceCounter(&liCurrent))
    {
        INT64 i64ElapsedInMs = liCurrent.QuadPart - m_liInitCount.QuadPart;
        UINT ms = (UINT)(i64ElapsedInMs % m_liTicksPerSec.QuadPart);
        UINT s = (UINT)((i64ElapsedInMs / m_liTicksPerSec.QuadPart) % 60);
        UINT m = (UINT)((i64ElapsedInMs / m_liTicksPerSec.QuadPart / 60) % 60);
        UINT h = (UINT)((i64ElapsedInMs / m_liTicksPerSec.QuadPart / 60 / 60) % 24);
        UINT d = (UINT)(i64ElapsedInMs / m_liTicksPerSec.QuadPart / 60 / 60 / 24);

        if (d > 0)
        {
            XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "%d.",
                d);
        }

        XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            m_szFormat,
            h, m, s, ms);
    }
    else
    {
        XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "Uptime not available");
    }

    return( S_OK );
}


void CXomLoggingControl::RegisterNewChange()
{
    DWORD dwOldSig;

    do
    {
        dwOldSig = g_dwLastChangeSignature;

    }
    while( InterlockedCompareExchange(
                (LONG*) &g_dwLastChangeSignature,
                (LONG) ((g_dwLastChangeSignature + 0x00010000) & 0xFFFF0000),
                dwOldSig ) != dwOldSig );
}

BOOL CXomLoggingControl::CheckOverrideList(
    LPCSTR pszFile,
    DWORD dwLine,
    BOOL* pfLog
)
{
    OVERRIDE_ENTRY *pOverride;
    BOOL fRet = FALSE;

    //
    // Loop through list of line-level overrides checking to see if the
    // last part of the given filename matches an override pattern.  This lets us
    // use fractional pathnames such as private\foo\bar.cpp instead of the full path.
    //
    int cchFile = 0;

    m_lockOverrideList.ReadLock();

    for( DWORD i = 0; i < m_OverrideList.GetSize(); i++ )
    {
        if( !m_OverrideList.GetAt( i, (void**)&pOverride ) )
        {
            break;
        }

        if( dwLine == pOverride->dwLine )
        {
            int cchPattern = strlen( pOverride->szFile );

            if( 0 == i )
            {
                cchFile = strlen( pszFile );
            }

            if( cchFile >= cchPattern )
            {
                LPCSTR pszFilePortion = pszFile + cchFile - cchPattern;

                if( 0 == _stricmp( pszFilePortion, pOverride->szFile ) )
                {
                    *pfLog = pOverride->fCanLog;
                    fRet = TRUE;
                    break;
                }
            }
        }
    }

    m_lockOverrideList.ReadUnlock();

    return( fRet );
}

BOOL CXomLoggingControl::SetOverride(
    LPCSTR pszFile,
    DWORD dwLine,
    BOOL fCanLog,
    DWORD *pdwOverNdx
)
{
    bool fFound;
    DWORD dwOverNdx;
    OVERRIDE_ENTRY* pOverride;
    OVERRIDE_ENTRY* pNewOverride = NULL;
    HRESULT hr = S_OK;

    m_lockOverrideList.WriteLock();

    //
    // Check if entry isn't already there
    //
    fFound = false;

    for( dwOverNdx = 0; dwOverNdx < m_OverrideList.GetSize(); dwOverNdx++ )
    {
        if( !m_OverrideList.GetAt( dwOverNdx, (void**) &pOverride ) )
        {
            hr = E_UNEXPECTED;
            goto lDone;
        }

        if( ( dwLine == pOverride->dwLine ) &&
            ( 0 == _stricmp( pszFile, pOverride->szFile ) ) )
        {
            fFound = true;
            break;
        }
    }

    //
    // If we found the entry, just update it. Otherwise, create a new entry.
    //
    if( fFound )
    {
        pOverride->fCanLog = fCanLog;
        *pdwOverNdx = dwOverNdx;
    }
    else
    {
        pNewOverride = new OVERRIDE_ENTRY;

        if( NULL == pNewOverride )
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        lstrcpynA( pNewOverride->szFile, pszFile, ARRAY_ELEMENTS( pNewOverride->szFile ) );
        pNewOverride->dwLine = dwLine;
        pNewOverride->fCanLog = fCanLog;

        if( !m_OverrideList.Add( pNewOverride, NULL ) )
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        *pdwOverNdx = m_OverrideList.GetSize() - 1;

        pNewOverride = NULL;
    }

lDone:
    m_lockOverrideList.WriteUnlock();

    SAFE_DELETE( pNewOverride );

    return( SUCCEEDED( hr ) );
}

BOOL CXomLoggingControl::RemoveOverride( DWORD dwOverNdx )
{
    OVERRIDE_ENTRY* pOverride;
    BOOL fRet = FALSE;

    m_lockOverrideList.WriteLock();

    if( m_OverrideList.GetAt( dwOverNdx, (void**)&pOverride ) )
    {
        m_OverrideList.RemoveAt( dwOverNdx );
        SAFE_DELETE( pOverride );
        fRet = TRUE;
    }

    m_lockOverrideList.WriteUnlock();

    return( fRet );
}

LPSTR CXomLoggingControl::ExpandTargetValues(LPCSTR pszRawValue)
{
    CHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1] = {0};
    DWORD cchComputerName = 0;

    CHAR szComponentName[XOMCTRL_MAXCOMPONENTNAME] = {0};
    size_t cchComponentName = 0;

    LPSTR pszRetval = NULL;
    LPSTR pszLogRoot = NULL;

    int iCurrPosition = 0;
    int index = 0;

    HRESULT hr = S_OK;

    string srcValue(pszRawValue);
    string destValue("");

    // determine the component name
    string componentName(g_xomcentral.GetComponentName());


    // determine the computer name
    cchComputerName = MAX_COMPUTERNAME_LENGTH+1;
    if (0 == GetComputerNameExA(ComputerNameNetBIOS, szComputerName, &cchComputerName))
    {
        goto lDone;
    }


    hr = g_xomcentral.GetSetting(Setting_setup_logroot, &pszLogRoot);
    if (!SUCCEEDED(hr) || pszLogRoot == NULL)
    {
        goto lDone;
    }



    // replace all occurrences of #COMPONENT# with component name
    while ( iCurrPosition < (int)srcValue.length() )
    {
        if ( (index = srcValue.find(c_szMachineToken, iCurrPosition)) != -1 )
        {
            destValue.append(srcValue, iCurrPosition, index-iCurrPosition);
            destValue.append(szComputerName);
            iCurrPosition = index + c_cchMachineToken;
        }
        else
        {
            destValue.append(srcValue, iCurrPosition, srcValue.length() - iCurrPosition);
            break;
        }
    }

    srcValue = destValue;
    destValue = "";

    iCurrPosition = 0;
    index = 0;

    // replace all occurrences of #MACHINE# with computer name
    while ( iCurrPosition < (int)srcValue.length() )
    {
        if ( (index = srcValue.find(c_szComponentToken, iCurrPosition)) != -1 )
        {
            destValue.append(srcValue, iCurrPosition, index-iCurrPosition);
            destValue.append(componentName);
            iCurrPosition = index + c_cchComponentToken;
        }
        else
        {
            destValue.append(srcValue, iCurrPosition, srcValue.length() - iCurrPosition);
            break;
        }
    }



    srcValue = destValue;
    destValue = "";

    iCurrPosition = 0;
    index = 0;

    // replace all occurrences of #LOGROOT# with the setup_logroot setting that should be in the configdb
    while ( iCurrPosition < (int)srcValue.length() )
    {
        if ( (index = srcValue.find(c_szLogrootToken, iCurrPosition)) != -1 )
        {
            destValue.append(srcValue, iCurrPosition, index-iCurrPosition);
            destValue.append(pszLogRoot);
            iCurrPosition = index + c_cchLogrootToken;
        }
        else
        {
            destValue.append(srcValue, iCurrPosition, srcValue.length() - iCurrPosition);
            break;
        }
    }



    pszRetval = _strdup(destValue.c_str());

lDone:
    return( pszRetval );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomcontrol.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomcontrol.h

Abstract:

--*/

#ifndef _XOMCONTROL_H_
#define _XOMCONTROL_H_


class CXomControl;
class CXomControlResponseInterface;
class CXomControlBuffer;

//
//
//
class CXomControlConnection :
    public CServerPipeCallback,
    public CXomControlResponseInterface
{
public:

    IMPLEMENT_REFCOUNT;

    CXomControlConnection();

    ~CXomControlConnection();

    HRESULT Init(
        CXomControl* pControl,
        CCompletionPort* pIOCP,
        LPCSTR pszProcessName,
        LPCSTR pszComponentName);

    virtual HRESULT WriteResponse(
        DWORD dwRequestId,
        BYTE* pBuffer,
        DWORD cbBuffer);

    void Shutdown();

protected:

    HRESULT Register(
        LPCSTR pszProcessName, 
        LPCSTR pszComponentName );
    
    HRESULT StartReading();

    HRESULT SendNext();

    HRESULT RequestDone(
        DWORD dwRequestId,
        HRESULT hr );

    HRESULT Send(
        CXomControlBuffer* pBuffer );

    virtual HRESULT OnPipeWrite(
        BYTE* pBufferSent,
        DWORD cbToSend,
        DWORD cbSent,
        HRESULT hr,
        ULONGLONG qwCallbackArg);

    virtual HRESULT OnPipeRead(
        BYTE* pbFilledInBuffer,
        DWORD cbRead,
        HRESULT hr,
        ULONGLONG qwCallbackArg);

    CXomControl* m_pControl;

    BOOL m_fAlive;
    CServerPipe* m_pPipe;

    BYTE m_rgbBuffer[XOMCTRL_MAXMESSAGESIZE];
        // Used to receive data.

    CVPtrList m_BufferList;
        // Queue of outgoing buffers.

    xlocks::CSpinLock m_lockBufferList;
        // To synch access to m_BufferList.

    LONG m_lOutgoing;
};

//
//
//
class CXomControl
{
friend CXomControlConnection;
public:

    IMPLEMENT_REFCOUNT;

    CXomControl();

    ~CXomControl();

    HRESULT Init(
        CCompletionPort* pIOCP,
        LPCSTR pszComponentName );

    HRESULT Terminate();

    HRESULT RegisterControlCallback(
        CXomControlCallback* pCallback );

    HRESULT UnregisterControlCallback(
        CXomControlCallback* pCallback );

    LPCSTR GetProcessName();

    LPCSTR GetComponentName();

protected:

    HRESULT ProcessRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT LazyConnect();
    
    CCompletionPort* m_pIOCP;
    
    CXomControlConnection* m_pCurrentConnection;

    CHAR m_szProcessName[XOMCTRL_MAXPROCESSNAME];
    CHAR m_szComponentName[XOMCTRL_MAXCOMPONENTNAME];

    CVPtrArray m_CallbackList;
    xlocks::CReaderWriterLock3 m_lockCallbackList;

    static DWORD WINAPI ConnectXmgmtSrv( void *pvParam );
    void ResetConnection();
    void CreateWatchDogThread();

    HANDLE m_hConnectXmgmtSrv;
    HANDLE m_heShutdown;

};

//
//
//
class CXomControlBuffer
{
public:

    IMPLEMENT_REFCOUNT;

    static CXomControlBuffer * __stdcall CreateInstance(DWORD cbBuffer)
    {
        CXomControlBuffer *pCRet;

        // 48839 - Check for overflow
        if(cbBuffer > (cbBuffer + sizeof(CXomControlBuffer)))
        {
            return NULL;
        }

        pCRet = (CXomControlBuffer *) malloc(cbBuffer + sizeof(CXomControlBuffer));
        if (pCRet == NULL)
        {
            return NULL;
        }
        else
        {
            pCRet->CXomControlBuffer::CXomControlBuffer();
            pCRet->m_cbBuffer = cbBuffer;
            return pCRet;
        }
    }

    CXomControlBuffer *Resize(DWORD cbBuffer)
    {
        if (cbBuffer <= m_cbBuffer)
        {
            m_cbBuffer = cbBuffer;
            return this;
        }
        else
        {
            return NULL;
        }
    }

    void operator delete(void *pv) { free(pv); }
      
    BYTE* GetBuffer()
    {
        return (BYTE *)(this + 1);
    }

    DWORD GetBufferLength()
    {
        return m_cbBuffer;
    }

protected:    

    void *operator new(size_t len) { return NULL; }

    DWORD m_cbBuffer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomfiletarget.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    mlog.h

Abstract:

--*/

#ifndef _XOMFILETARGET_H_
#define _XOMFILETARGET_H_


class CLogFile;

class CXomFileTargetCentralContext :
    public CCompletionContext
{
public:

    CXomFileTargetCentralContext()
    {
        m_pHandler = NULL;
    }

    void Init(CCompletionHandler* pHandler)
    {
        m_pHandler = pHandler;
    }

    virtual CCompletionHandler* GetHandler()
    {
        return m_pHandler;
    }

    CCompletionHandler* m_pHandler;
};

class CXomFileTarget :
    public CXomTargetBase
{
public:

    IMPLEMENT_REFCOUNT;

    CXomFileTarget();

    ~CXomFileTarget();

    HRESULT Init(
        CCompletionPort* pIOCP,
        LPCSTR pszParams,
        LPCSTR pszDefaults = NULL);

    virtual void Term();

    virtual void Log(
        CLogFormatedMessage* pMsg );

    virtual HRESULT ResetTarget();

    HRESULT ResetTargetWithParams(LPCSTR pszParams);

    bool IsInitialized() { return m_pIOCP != NULL; }

protected:

    HRESULT ParseParams(LPCSTR pszParams, LPCSTR pszDefaults = NULL);

    void EnsureFilePrefixDirectoryExists();

    HRESULT CreateNewLogFile();

    bool IsTimeToRotate(FILETIME& ftNow);

    CCompletionPort* m_pIOCP;
    CHAR m_szLogFilePrefix[MAX_PATH];
    DWORD m_dwRotationTimeMins;
        // Internval after which the file should be rotated (old file closed,
        // new file opened) in minutes aligned to 12:00AM GMT. E.g. if the
        // rotation time is 15, then the file will be rotated at 12:00, 12:15,
        // 12:30... so on and so forth independent of the time the application
        // started or the first file was created.
    FILETIME m_ftNextRotation;
        // UTC filetime with when the next rotation should happen.
    DWORD m_dwBufferSize;
    DWORD m_dwMaxSize;
    bool  m_bEmitThreadId;
    bool  m_bEmitFlowToken;

    CAsyncFile* m_pCurrentFile;
    xlocks::CReaderWriterLock3 m_lockCurrentFile;
};

 #endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomlggng.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

  xomlggng.h

Abstract:

  logging and tracing framework classes and company.

--*/

#ifndef _XOMLGGNG_H_
#define _XOMLGGNG_H_

#pragma once

//
// Forward class declarations
//
struct XomLogContext;
class CXomLoggingControl;
class CXomTargetBase;
class CLogFormatedMessage;
class CXomLogArea;


//////////////////////////////////////////////////////////////////////////////
//
// CXomDebugOutputTarget
//
class CXomDebugOutputTarget :
    public CXomTargetBase
{
public:

    // Bogus refcount implementation. This class is a special case and there
    // will be only one object of it declared as a member of
    // CXomLoggingControl.

    virtual ULONG AddRef()
    {
        return 1;
    }

    virtual ULONG Release()
    {
        return 1;
    }

    virtual void Log(
        CLogFormatedMessage* pMsg )
    {
        CLogFormatedMessage oMsg(pMsg->GetFlowToken(), NULL);
        if (pMsg->GetFlowToken().IsValid())
        {
            oMsg.Format("%016I64X: %s\r\n", pMsg->GetFlowToken().flowToken, pMsg->GetText());
        }
        else
        {
            oMsg.Format("%s\r\n", pMsg->GetText());
        }

        OutputDebugStringA(oMsg.GetText());
    }
};


//////////////////////////////////////////////////////////////////////////////
//
// CXomNtLogTarget
//
typedef CEventThrottle
        <
            0,          // wBaseEventId
            1000,       // wNumEvents
            5009,       // wIPHashSize - each IP-tracked event will consume ~20KB
            2000000,    // 2MB of IP tracking hash tables (about 100 events worth)
            10000000    // 10MB of hash entries (about 240K IPs across all events)
        > CNtEventThrottle;

class CXomNtLogTarget :
    public CXomTargetBase
{
public:
    CXomNtLogTarget();
    virtual ~CXomNtLogTarget();

    HRESULT Init( LPCSTR pszSource );

    BOOL EventInit(
            DWORD dwEventID,
            const char* pszEventLine,
            CNtEventThrottle::ALLOW_TYPE eAllowType,
            BOOL fRateUnitsAreBytes,
            DWORD dwAlertUnitsPerSec,
            QWORD hnsEventInterval,
            BOOL fTrackPerIP );

    BOOL OkToLog(
            QWORD hnsNow,
            DWORD dwEventID,
            LPCSTR pszText,
            WORD wPacketSize,
            DWORD *pina,
            BOOL *pfAllowThisEvent,
            DWORD *pdwNumSkips,
            DWORD *pdwNumSkipsTotal,
            DWORD *pdwRecentRate );

    WORD GetEventThrottleCapacity()
    {
        return m_pEventThrottle->GetSize();
    }

    virtual void Log( CLogFormatedMessage* pMsg );

    void DumpEventList(DWORD dwRequestId, CXomControlResponseInterface* pResponseInterface);

    // Bogus refcount implementation. This class is a special case and there
    // will be only one object of it declared as a member of
    // CXomLoggingControl.
    virtual ULONG AddRef()  { return( 1 ); }
    virtual ULONG Release() { return( 1 ); }

protected:
    HANDLE m_hEventLog;

    CNtEventThrottle *m_pEventThrottle;
    CRITICAL_SECTION m_csThrottle;
};


//////////////////////////////////////////////////////////////////////////////
//
// CXomLoggingControl
//
class CXomLoggingControl :
    public CXomControlCallback
{
public:

    IMPLEMENT_REFCOUNT_COM;

    CXomLoggingControl();

    ~CXomLoggingControl();

    HRESULT Init(
        CCompletionPort* pIOCP );

    HRESULT InitNTLogTarget(
        LPCSTR pszSource );

    static void RegisterArea(
        CXomLogArea* pArea );

    BOOL CheckOverrideList(
        LPCSTR pszFile,
        DWORD dwLine,
        BOOL* pfLog );

    void Terminate();

protected:
    const static unsigned int c_xomMaxLogAreas = 1024;

    HRESULT ConfigureAreas();

    // Convert the area filter level string in pszParam to one of the
    // level constants. Returns E_INVALID_ARG if the string is invalid.
    HRESULT ParseFilterLevel(
        IN  LPCSTR pszParam, // Filter level string
        OUT char* pchLevel   // The resulting area level constant
    );

    HRESULT ConfigureEvents();

    HRESULT ApplyEventSettings( CXomNameValuePairList &oParams );

    HRESULT CreateTarget(
        LPCSTR pszTargetName,
        LPCSTR pszParam,
        DWORD dwAdminId );

    HRESULT CreateTarget(
        LPCSTR pszTargetName );

    HRESULT CreateFileTarget(
        LPCSTR pszTargetName,
        LPCSTR pszParam );

    HRESULT CreateRemoteTarget(
        LPCSTR pszTargetName,
        LPCSTR pszParam,
        DWORD dwAdminId );

    HRESULT DeleteTarget(
        CXomTargetBase* _pTarget );

    HRESULT FindTarget(
        LPCSTR pszTargetName,
        CXomTargetBase** ppTarget );

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    void CleanUpAdminSessionObjects(
        DWORD dwRequestId );

    HRESULT ProcessCommandHelp(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandGetVersion(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandListAreas(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandListTargets(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandChangeAreaLevel(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandNewTarget(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandDeleteTarget(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandAddTarget(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandRemoveTarget(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface);

    HRESULT ProcessCommandResetTarget(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface);

    HRESULT ProcessCommandListOverrides(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface);

    HRESULT ProcessCommandSetOverride(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandRemoveOverride(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandEvent(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandListEvents(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    HRESULT ProcessCommandUpTime(
        CXomParamList* pParams,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

    void RegisterNewChange();

    BOOL SetOverride(
        LPCSTR pszFile,
        DWORD dwLine,
        BOOL fCanLog,
        DWORD *pdwOverNdx );

    BOOL RemoveOverride(
        DWORD dwOverNdx );

    LPSTR ExpandTargetValues(
        LPCSTR pszRawValue);

    struct OVERRIDE_ENTRY
    {
        CHAR szFile[MAX_PATH];
        DWORD dwLine;
        BOOL fCanLog;
    };

    bool m_fOverride;

    static CXomLogArea* s_rgpLogArea[c_xomMaxLogAreas];
    static DWORD s_cLogArea;

    CVPtrList m_TargetList;

    xlocks::CReaderWriterLock3 m_lockTargetList;

    CXomDebugOutputTarget m_oDebugOutputTarget;

    CXomNtLogTarget m_oNTLogTarget;

    CCompletionPort* m_pIOCP;

    static CXomLogArea s_oDefaultArea;

    bool m_fTerm;

    CVPtrArray m_OverrideList;

    xlocks::CReaderWriterLock3 m_lockOverrideList;

    LPSTR g_pszDefaultTargetSettings;

    LARGE_INTEGER m_liTicksPerSec;
    LARGE_INTEGER m_liInitCount;

    CHAR m_szFormat[32];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomremotetarget.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

  xomremotetarget.h

Abstract:

  Remote logging target.

--*/

#include "stdafx.h"


CXomRemoteTarget::CXomRemoteTarget()
{
    m_socket = INVALID_SOCKET;
    m_dwAdminId = 0;
}

CXomRemoteTarget::~CXomRemoteTarget()
{
    if(m_socket != INVALID_SOCKET)
    {
        closesocket(m_socket);
    }
}

HRESULT CXomRemoteTarget::Init(
    CCompletionPort* pIOCP,
    LPCSTR pszParams,
    LPCSTR pszDefaults
)
{
    HRESULT               hr = S_OK;
    CXomNameValuePairList oParams;
    LPCSTR                pszAddress = NULL;
    LPCSTR                pszInterface = NULL;
    LPSTR                 pszMergedParams = NULL;
    LPSTR                 pszPort = NULL;
    in_addr               inaAddress;
    in_addr               inaInterface;
    sockaddr_in           sinInterface;
    HOSTENT*              pHE;
    WORD                  wPort = 0;
    CXomRemoteTarget*     pTarget = NULL;

    hr = oParams.Parse(pszParams, pszDefaults);

    if(FAILED(hr))
    {
        goto lDone;
    }

    //
    // Get the 'Address' parameter. It contains the IP and optionally the port
    // of the remote target machine.
    //

    pszAddress = oParams.GetValueByName("Address");

    if(NULL == pszAddress)
    {
        hr = E_INVALIDARG;
        XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_7, "[CXomLoggingControl::CreateRemoteTarget] missing required parameter 'Address'");
        goto lDone;
    }

    CHAR szAddress[128];
    lstrcpynA(szAddress, pszAddress, ARRAY_ELEMENTS(szAddress));

    // Check if the port is also specified in the string

    pszPort = strchr(szAddress, ':');

    if(pszPort != NULL)
    {
        *pszPort = '\0';
        pszPort++;
        wPort = (WORD) atoi(pszPort);
    }

    inaAddress.S_un.S_addr = inet_addr(szAddress);

    if( 0 == inaAddress.S_un.S_addr ||
        INADDR_NONE == inaAddress.S_un.S_addr )
    {
        //
        // Hmmm, it's not a IP address. Maybe it's the host name?
        //

        pHE = gethostbyname( szAddress );

        if( NULL == pHE )
        {
            //
            // No cigar...
            //

            hr = E_INVALIDARG;
            XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_8, "[CXomLoggingControl::CreateRemoteTarget] parameter 'Address' is invalid or host name not found.");
            goto lDone;
        }

        memcpy( &inaAddress, pHE->h_addr, sizeof(inaAddress) );
    }

    //
    // Optional 'Interface' parameter contains the IP of the interface
    // that will be used to send the data.
    //

    inaInterface.s_addr = 0;

    pszInterface = oParams.GetValueByName("Interface");

    if(NULL != pszInterface)
    {
        inaInterface.s_addr = inet_addr(pszInterface);

        if(inaInterface.s_addr == INADDR_NONE)
        {
            inaInterface.s_addr = 0;
        }
    }

    ZeroMemory(&sinInterface, sizeof(sinInterface));
    sinInterface.sin_family = AF_INET;
    sinInterface.sin_addr = inaInterface;

    ZeroMemory(&m_sinRemote, sizeof(m_sinRemote));
    m_sinRemote.sin_family = AF_INET;
    m_sinRemote.sin_port = wPort != 0 ? htons(wPort) : htons(4101);
    m_sinRemote.sin_addr = inaAddress;

    // Create the socket

    m_socket = socket(AF_INET, SOCK_DGRAM, 0);

    if(INVALID_SOCKET == m_socket)
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_9,
            "[CXomRemoteTarget::Init] socket failed, hr = 0x%08x", hr );
        goto lDone;
    }

    // Bind it to port/addr

    int res = bind(m_socket, (sockaddr*) &sinInterface, sizeof(sockaddr_in));

    if(res != 0)
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        XomNtEvent( XEVENT_MGMT_SUBCOMPONENT_WARNING_10,
            "[CXomRemoteTarget::Init] bind failed, hr = 0x%08x", hr );
        goto lDone;
    }

    // Remember what the parameters we used where

    pszMergedParams = oParams.GetNameValuePairString();
    if (pszMergedParams != NULL)
    {
        GOTO_LDONE_IF_FAILED_HR(
            SetTargetParams( pszMergedParams )
            );
    }

lDone:

    if (pszMergedParams != NULL)
    {
        free(pszMergedParams);
    }

    return hr;

}

void CXomRemoteTarget::Log(
    CLogFormatedMessage* pMsg
)
{
    HRESULT hr;
    CLogFormatedMessage oMsg(pMsg->GetFlowToken(), NULL, 0);
    int res;

    //
    // Send message in UDP packet.
    //

    char szFloken[2 + sizeof(FLOKEN)*2 + 1] = { 'F', 'T', '0', '\0' };
    if (pMsg->GetFlowToken().IsValid())
    {
        safe_snprintf(szFloken, ARRAYSIZE(szFloken), "FT%016I64X", pMsg->GetFlowToken().flowToken);
    }

    oMsg.Format("%s;%d;%s;%d;%s;%d;%d;%s::%s",
        g_xomcentral.GetProcessName(), 
        GetCurrentProcessId(),
        g_xomcentral.GetComponentName(), 
        GetCurrentThreadId(),
        pMsg->GetArea()->GetName(), 
        pMsg->GetLevel(), 
        pMsg->GetEventId(),
        szFloken,
        pMsg->GetText());

    res = sendto(m_socket, oMsg.GetText(), oMsg.GetTextSize(), 0,
        (sockaddr*) &m_sinRemote, sizeof(m_sinRemote));

    if(!res)
    {
        //
        // Send failed. We'll register the problem with an NT event however
        // we have to be carreful not to flood the event log.
        //

        static int errorcount = 0;
        if((errorcount++ % 32) == 0)
        {
            hr = HRESULT_FROM_WIN32(WSAGetLastError());
            XomNtEvent( XEVENT_MGMT_REMOTE_TARGET_WARNING, "hr = 0x%08x", hr );
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomrpttarget.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomrpttarget.cpp

Abstract:

--*/

#include "stdafx.h"

/*****************************************************************************

CXomReportTarget::CXomReportTarget

Constructor

*****************************************************************************/
CXomReportTarget::CXomReportTarget()
{
    m_dwHeartBeatInterval = 15 * 1000; // Default heartbeat interval is 15 second(s)
    m_dwKeepaliveInterval = 5 * 60 * 1000; // Default keep alive interval is 5 minute(s)
    m_dwShutdownWait = 15 * 1000; // Wait 15 seconds to shutdown

    m_usCleansingPort = 0;

    m_pIOCP = NULL;
    m_pSocketCleansing = NULL;
    m_pReportConnection = NULL;

    m_hHeartBeatThread = NULL;
    m_dwHeartBeatThreadId = 0;
    m_dwLastMessage = 0;

    m_componentId = 0;

    m_lStarted = 0;
    m_hShutdown = NULL;
    m_hMain = NULL;
    m_lShutdown = 0;
    m_fDisconnectNotified = FALSE;

    m_pListener = NULL;
}

/*****************************************************************************

CXomReportTarget::~CXomReportTarget

Destructor

*****************************************************************************/
CXomReportTarget::~CXomReportTarget()
{
    if (m_pConfig && m_pListener)
    {
        m_pConfig->putref_ConfigListener(NULL);
        m_pListener->Release();
        m_pListener = NULL;
    }

    if (m_pConfig)
    {
        m_pConfig.Release();
        m_pConfig = NULL;
    }

    SAFE_RELEASE(m_pIOCP);
    SAFE_RELEASE(m_pReportConnection);
    SAFE_RELEASE(m_pSocketCleansing);
    SAFE_CLOSEHANDLE( m_hShutdown );
    SAFE_CLOSEHANDLE( m_hMain );
    SAFE_CLOSEHANDLE( m_hHeartBeatThread );
}

/*****************************************************************************

CXomReportTarget::Init

Takes in parameters used to initialize the reporting target

*****************************************************************************/
HRESULT CXomReportTarget::Init(
    CCompletionPort* pIOCP,
    LPCSTR pszParams,
    LPCSTR pszDefaults
    )
{
    HRESULT hr = S_OK;
    CXomNameValuePairList oParams;
    LPCSTR pszHeartBeatInterval = NULL;
    LPCSTR pszKeepAliveInterval = NULL;
    LPSTR  pszMergedParams = NULL;

    if( NULL == pIOCP )
    {
        hr = E_INVALIDARG;
        XomNtEvent( XEVENT_COMMON_CONFIG_318, "CXomReportTarget::Init() - Received invalid IOCP, hr=0x%08X", hr );
        goto lDone;
    }

    m_pIOCP = pIOCP;
    SAFE_ADDREF( m_pIOCP );

    GOTO_LDONE_IF_FAILED_HR(
        oParams.Parse(pszParams, pszDefaults) );

    //
    // Create an instance of Config class
    //
    hr = m_pConfig.CoCreateInstance(__uuidof(ConfigInterop));
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_319, "CXomReportTarget::Init() - Failed to CoCreate ConfigInterop object, hr=0x%08X", hr );
        goto lDone;
    }

    //
    // Retrieve a couple of settings - heart beat interval, and keep alive interval
    //
    pszHeartBeatInterval = oParams.GetValueByName( "HeartBeatIntervalSec" );
    if( NULL != pszHeartBeatInterval )
    {
        m_dwHeartBeatInterval = ( DWORD ) atol( pszHeartBeatInterval ) * 1000;
    }

    pszKeepAliveInterval = oParams.GetValueByName( "KeepAliveIntervalSec" );
    if( NULL != pszKeepAliveInterval )
    {
        m_dwKeepaliveInterval = ( DWORD ) atol( pszKeepAliveInterval ) * 1000;
    }

    //
    // Remember what the parameters we used where
    //
    pszMergedParams = oParams.GetNameValuePairString();
    if (pszMergedParams != NULL)
    {
        GOTO_LDONE_IF_FAILED_HR(
            SetTargetParams( pszMergedParams )
            );
    }

lDone:

    if (pszMergedParams != NULL)
    {
        free(pszMergedParams);
    }
    return( hr );
}

/*****************************************************************************

CXomReportTarget::Startup

Execute code that we want to run if and only if we know the target is actually
being used.

*****************************************************************************/
HRESULT CXomReportTarget::Startup()
{
    HRESULT hr = S_OK;

    CComPtr<IVirtualInterfaceInfo> pInterface;
    CComBSTR bsEnvironment;
    CComBSTR bsVirtualInterface;

    //
    // If this logic has already been called, don't execute it again.
    //
    if( InterlockedExchange( &m_lStarted, 1 ) == 1 )
    {
        goto lDone;
    }

    m_pListener = new CXomReportTargetListener( this );
    if( NULL != m_pListener )
    {
        hr = m_pConfig->putref_ConfigListener( m_pListener );
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_320, "CXomReportTarget::Init() - Config.putref_ConfigListener failed, hr=0x%08X", hr );
        goto lDone;
    }

    //
    // Figure out which component we are, so it can be sent on startup
    //
    hr = m_pConfig->get_ReportMessageComponentId( &m_componentId );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_322, "CXomReportTarget::Init() - Config.get_ReportMessageComponentId failed, hr=0x%08X", hr );
        goto lDone;
    }

    //
    // Figure out which virtual interface we need, and remember it
    //
    hr = m_pConfig->get_ReportMessageCleanserVirtualInterface( &bsVirtualInterface );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_322, "CXomReportTarget::Init() - Config.get_ReportMessageCleanserVirtualInterface failed, hr=0x%08X", hr );
        goto lDone;
    }

    m_bsVirtualInterface = bsVirtualInterface;

    //
    // Remember our environment
    //
    hr = m_pConfig->get_Environment( &bsEnvironment );
    if( FAILED( hr ) || ( NULL == bsEnvironment.m_str ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_323, "CXomReportTarget::Init() - get_Environment failed, hr=0x%08X", hr );
        goto lDone;
    }

    m_bsEnvironment = bsEnvironment;

    //
    // Get cleansing server information from configdb - it is retrieved for the virtual interface
    // - it will contain the cleansing server IP address and port
    //
    hr = m_pConfig->GetVirtualInterface( bsVirtualInterface, 1, &pInterface );
    if( FAILED( hr ) || ( NULL == pInterface.p ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_324, "CXomReportTarget::Init() - Config.GetVirtualInterface failed, hr=0x%08X", hr );
        goto lDone;
    }

    hr = ExtractCleanserInfo( pInterface );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_325, "CXomReportTarget::Init() - Unable to retrieve the cleanser information from the bucket server" );
        goto lDone;
    }

    //
    // Create an instance of the CReportConnection object
    //
    m_pReportConnection = new CReportConnection( );
    if( NULL == m_pReportConnection )
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent( XEVENT_COMMON_CONFIG_326, "CXomReportTarget::Startup() - CReportConnection::CReportConnection failed" );
        goto lDone;
    }

    //
    // Set server / component ID on the report connection object
    //
    m_pReportConnection->m_iComponentID = m_componentId;

    //
    // Create the ServerSocket and attach it
    //
    hr = InternalConnect( );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_327, "CXomReportTarget::Startup() - CXomReportTarget::InternalConnect failed, hr=0x%08X", hr );
        goto lDone;
    }

    //
    // Create the shutdown event
    //
    m_hShutdown = ::CreateEvent( NULL, TRUE, FALSE, NULL );
    if( NULL == m_hShutdown )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        XomNtEvent( XEVENT_COMMON_CONFIG_328, "CXomReportTarget::Startup() - CreateEvent for shutdown event failed, hr=0x%08X", hr );
        goto lDone;
    }

    //
    // Create the event on which the Term call waits for the HB thread to shutdown
    //
    m_hMain = ::CreateEvent( NULL, TRUE, FALSE, NULL );
    if( NULL == m_hMain )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        XomNtEvent( XEVENT_COMMON_CONFIG_329, "CXomReportTarget::Startup() - CreateEvent for main thread failed, hr=0x%08X", hr );
        goto lDone;
    }

    //
    // Create the heartbeat thread
    //
    m_hHeartBeatThread = ::CreateThread( NULL, 0, HeartBeatThreadProc, (LPVOID) this, 0, &m_dwHeartBeatThreadId );
    if( NULL == m_hHeartBeatThread )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        XomNtEvent( XEVENT_COMMON_CONFIG_330, "CXomReportTarget::Startup() - CreateThread for heartbeat thread failed, hr=0x%08X", hr );
        goto lDone;
    }

lDone:

    //
    // Cleanup on failure
    //
    if( FAILED( hr ) )
    {
        if (m_pConfig)
        {
            m_pConfig.Release();
            m_pConfig = NULL;
        }

        SAFE_RELEASE( m_pReportConnection );
        SAFE_RELEASE( m_pSocketCleansing );
        SAFE_CLOSEHANDLE( m_hShutdown );
        SAFE_CLOSEHANDLE( m_hMain );
        SAFE_CLOSEHANDLE( m_hHeartBeatThread );
        InterlockedExchange( &m_lStarted, 0 );
    }

    return( hr );
}

/*****************************************************************************

CXomReportTarget::Term

Terminates the target

*****************************************************************************/
void CXomReportTarget::Term()
{
    HRESULT hr = S_OK;
    DWORD dwRet = 0;

    CTCPCntVarBuffer* pTCPBuffer = NULL;
    BYTE* pbBuffer = NULL;

    RPT_MSG_HEADER msgHeader;
    FILETIME ftNow;

    //
    // If we were never started, nothing to really terminate
    //
    if( 0 == m_lStarted )
    {
        goto lDone;
    }

    //
    // If this logic has already been called, don't execute it again.
    //
    if( InterlockedExchange( &m_lShutdown, 1 ) == 1 )
    {
        goto lDone;
    }

    //
    // Send a Disconnect message
    // Create the TCPCntVarBuffer, check for null
    //
    pTCPBuffer = CTCPCntVarBuffer::CreateInstance( sizeof( RPT_MSG_HEADER ) );
    if( NULL == pTCPBuffer )
    {
        XomNtEvent( XEVENT_COMMON_CODE_99, "CXomReportTarget::Term() - CTCPCntVarBuffer::CreateInstance failed " );
    }
    else
    {
        pbBuffer = pTCPBuffer->GetBuffer();

        GetSystemTimeAsFileTime( &ftNow );

        //
        // Fill the RPT_MSG_HEADER struct
        //
        msgHeader.bMsgType = RPT_MSG_DISCONNECT;
        msgHeader.bReserved = 0;
        msgHeader.usSize = 0;
        msgHeader.ullTime = *( ( const ULONGLONG* ) &ftNow );

        memcpy( pbBuffer, &msgHeader, sizeof( RPT_MSG_HEADER ) );

        //
        // Finally, send the data to the report connection
        //
        hr = m_pReportConnection->Send( pTCPBuffer );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_COMMON_CODE_100, "CXomReportTarget::Term() - CReportConnection::Send failed, hr=0x%08X", hr );
        }
    }

    //
    // Signal heartbeat thread that we are shutting down, and wait a bit for it
    // to exit
    //
    ::SetEvent( m_hShutdown );

    dwRet = ::WaitForSingleObject( m_hMain, m_dwShutdownWait );
    if( WAIT_TIMEOUT == dwRet )
    {
        XomNtEvent( XEVENT_COMMON_CODE_101, "CXomReportTarget::Term() - Heartbeat thread did not shutdown cleanly." );
    }

    //
    // Sleep for a couple of seconds so we have time to send the disconnect, then disconnect.
    //
    Sleep( 2000 );

    m_pReportConnection->Disconnect( S_OK );

    m_lStarted = 0;

    //
    // Release our objects
    //
    SAFE_RELEASE( m_pReportConnection );
    SAFE_RELEASE( m_pSocketCleansing );
    SAFE_CLOSEHANDLE( m_hShutdown );
    SAFE_CLOSEHANDLE( m_hMain );

lDone:

    //
    // We received the IOCP in Init, so it needs to always be released
    //
    SAFE_RELEASE( m_pIOCP );

    return;
}

/*****************************************************************************

CXomReportTarget::InternalConnect

Handles creating the ServerSocket, and connecting it to the ReportConnection

*****************************************************************************/
HRESULT CXomReportTarget::InternalConnect()
{
    USES_CONVERSION;

    HRESULT hr = S_OK;

    LPCSTR pszServer;
    sockaddr_in addrCleansingServer;
    sockaddr_in addrLocalhost;

    //
    // Clean up any existing old CServerSocket object
    //
    if( NULL != m_pSocketCleansing )
    {
        m_pSocketCleansing->Close( );
        m_pSocketCleansing->Release( );
        m_pSocketCleansing = NULL;
    }

    //
    // Create an instance of the CServerSocket object
    //
    hr = CServerSocket::CreateInstance( &m_pSocketCleansing, m_pIOCP, NULL );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_331, "CXomReportTarget::InternalConnect() - CServerSocket::CreateInstance failed, hr=0x%08X", hr );
        goto lDone;
    }

    //
    // Get the ip information for the cleansing server
    //
    pszServer = W2A( m_bsCleansingServer );

    memset( &addrCleansingServer, 0, sizeof( addrCleansingServer ) );
    addrCleansingServer.sin_family = AF_INET;
    addrCleansingServer.sin_port = htons( m_usCleansingPort );

    addrCleansingServer.sin_addr.s_addr = inet_addr( pszServer );

    if( 0 == addrCleansingServer.sin_addr.s_addr ||
        INADDR_NONE == addrCleansingServer.sin_addr.s_addr )
    {
        hostent* pHost = gethostbyname( pszServer );

        if(NULL == pHost)
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
            goto lDone;
        }

        addrCleansingServer.sin_addr.s_addr = ((in_addr*)pHost->h_addr_list[0])->s_addr;
    }

    //
    // Get the ip information for our local address (currently unused)
    //
    memset( &addrLocalhost, 0, sizeof( addrLocalhost ) );
    addrLocalhost.sin_family = AF_INET;

    //
    // Init the socket
    //
    hr = m_pSocketCleansing->Init( IPPROTO_TCP, &addrLocalhost, TRUE );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_332, "CXomReportTarget::InternalConnect() - CServerSocket::Init failed, hr=0x%08X", hr );
        goto lDone;
    }

    //
    // Attach the CSocketServer to the CReportConnection object and connect to it
    //
    hr = m_pReportConnection->AttachAndConnect( m_pSocketCleansing, &addrCleansingServer );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_333, "CXomReportTarget::InternalConnect() - CReportConnection::AttachAndConnect failed, hr=0x%08X", hr );
        goto lDone;
    }

lDone:

    return( hr );
}

/*****************************************************************************

CXomReportTarget::Log

Takes the given log message and passes it to the ReportConnection to be
sent to the cleansing server

*****************************************************************************/
void CXomReportTarget::Log(
    CLogFormatedMessage* pMsg
    )
{
    HRESULT hr = S_OK;

    DWORD dwTickNow;
    CTCPCntVarBuffer* pTCPBuffer = NULL;
    BYTE* pbBuffer = NULL;

    RPT_MSG_HEADER msgHeader;
    FILETIME ftNow;

    //
    // If we are shutdown, just return
    //
    if( 1 == m_lShutdown )
    {
        goto lDone;
    }

    // Check for overflow
    if ((DWORD)pMsg->GetTextSize() > (DWORD)pMsg->GetTextSize() + sizeof( RPT_MSG_HEADER ))
    {
        XomNtEvent( XEVENT_COMMON_CODE_102, "CXomReportTarget::Log() - CTCPCntVarBuffer::Out of Memory " );
        goto lDone;
    }

    //
    // Create the TCPCntVarBuffer, check for null
    //
    pTCPBuffer = CTCPCntVarBuffer::CreateInstance( pMsg->GetTextSize() + sizeof( RPT_MSG_HEADER ) );
    if( NULL == pTCPBuffer )
    {
        XomNtEvent( XEVENT_COMMON_CODE_102, "CXomReportTarget::Log() - CTCPCntVarBuffer::CreateInstance failed " );
        goto lDone;
    }

    pbBuffer = pTCPBuffer->GetBuffer();

    GetSystemTimeAsFileTime( &ftNow );

    //
    // Fill the RPT_MSG_HEADER struct
    //
    msgHeader.bMsgType = RPT_MSG_DATA;
    msgHeader.bReserved = 0;
    msgHeader.usSize = ( u_short) pMsg->GetTextSize();
    msgHeader.ullTime = *( ( const ULONGLONG* ) &ftNow );

    //
    // Copy the RPT_MSG_HEADER struct, then the message
    //
    memcpy( pbBuffer, &msgHeader, sizeof( RPT_MSG_HEADER ) );
    memcpy( pbBuffer + sizeof( RPT_MSG_HEADER ), pMsg->GetText(), pMsg->GetTextSize() );

    //
    // Finally, send the data to the report connection
    //
    hr = m_pReportConnection->Send( pTCPBuffer );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CODE_103, "CXomReportTarget::Log() - CReportConnection::Send failed, hr=0x%08X", hr );
        goto lDone;
    }

    dwTickNow = ( ::GetTickCount( ) );
    InterlockedExchange( ( LONG * ) &m_dwLastMessage, dwTickNow );

lDone:

    SAFE_RELEASE( pTCPBuffer );

    return;
}

HRESULT CXomReportTarget::VirtualInterfaceChange(
        struct IVirtualInterfaceChangeEventArgs * e )
{
    HRESULT hr = S_OK;
    CComPtr<IVirtualInterfaceInfo> pVirtualInterface;
    CComBSTR bsEnvironment;
    CComBSTR bsVirtualInterface;

    if( NULL == e )
    {
        hr = E_POINTER;
        goto lDone;
    }

    hr = e->get_Environment( &bsEnvironment );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CODE_104, "CXomReportTarget::VirtualInterfaceChange() - Unable to get the environment from the eventargs, hr=0x%08X", hr );
        goto lDone;
    }

    if( m_bsEnvironment != bsEnvironment )
    {
        hr = E_FAIL;
        goto lDone;
    }

    hr = e->get_VirtualInterface( &bsVirtualInterface );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CODE_105, "CXomReportTarget::VirtualInterfaceChange() - Unable to get the virtual interface from the eventargs, hr=0x%08X", hr );
        goto lDone;
    }

    if( m_bsVirtualInterface != bsVirtualInterface )
    {
        // NOTE: dont return an error here.  it will cause the change to get rejected, preventing the real owner from handling the change.
        goto lDone;
    }

    //
    // Ok, now we know that this is a virtual interface change for our environment/virtual interface
    //
    hr = e->get_ValueNew( &pVirtualInterface );
    if( FAILED( hr ) || ( NULL == pVirtualInterface.p ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_334, "CXomReportTarget::VirtualInterfaceChange() - IVirtualInterfaceChangeEventArgs.GetVirtualInterface failed, hr=0x%08X", hr );
        goto lDone;
    }

    hr = ExtractCleanserInfo( pVirtualInterface );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_335, "CXomReportTarget::VirtualInterfaceChange() - Unable to retrieve the cleanser information from the bucket server" );
        goto lDone;
    }

    m_pReportConnection->Disconnect( S_OK );

lDone:

    return( hr );
}

HRESULT CXomReportTarget::ExtractCleanserInfo( IVirtualInterfaceInfo * pVirtualInterface )
{
    USES_CONVERSION;

    CComBSTR bsCurrentServer;
    long lPort;

    HRESULT hr = S_OK;

    hr = pVirtualInterface->get_IPAddressString( &bsCurrentServer );
    if( FAILED( hr ) || ( NULL == bsCurrentServer.m_str ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_337, "CXomReportTarget::Init() - IVirtualInterfaceInfo.IPAddressString failed, hr=0x%08X", hr );
        goto lDone;
    }

    m_bsCleansingServer = bsCurrentServer;

    hr = pVirtualInterface->get_Port( &lPort );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_338, "CXomReportTarget::Init() - IVirtualInterfaceInfo.Port failed, hr=0x%08X", hr );
        goto lDone;
    }

    m_usCleansingPort = (u_short) lPort;
    if( 0 == m_usCleansingPort )
    {
        XomNtEvent( XEVENT_COMMON_CONFIG_339, "CXomReportTarget::Init() - Invalid cleansing server port specified" );
        goto lDone;
    }

lDone:

    return( hr );

}


/*****************************************************************************

CXomReportTarget::HeartBeatThread

The heartbeat thread checks the connection status intermittently, and if
required, it will recreate and reassociate the underlying socket.

It also will send keepalive messages to the cleansing server as appropriate.

*****************************************************************************/
DWORD WINAPI CXomReportTarget::HeartBeatThreadProc(
    LPVOID lpThis
    )
{
    ((CXomReportTarget *)lpThis)->HeartBeatThread();

    return 0;
}

/*****************************************************************************

CXomReportTarget::HeartBeatThread

The heartbeat thread checks the connection status intermittently, and if
required, it will recreate and reassociate the underlying socket.

It also will send keepalive messages to the cleansing server as appropriate.

*****************************************************************************/
void CXomReportTarget::HeartBeatThread()
{
    DWORD dwRet;
    HRESULT hr;
    DWORD dwTickNow;


    CTCPCntVarBuffer* pBufferKA = NULL;
    BYTE * pBuffer;
    RPT_MSG_HEADER msgHeader;
    FILETIME ftNow;

    //
    // KA message is always the same header
    //
    msgHeader.bMsgType = RPT_MSG_KEEPALIVE;
    msgHeader.bReserved = 0;
    msgHeader.usSize = 0;

    while( 1 )
    {
        dwRet = ::WaitForSingleObject( m_hShutdown, m_dwHeartBeatInterval );

        if( 0 != m_lShutdown )
        {
            break;
        }

        //
        // If we're disconnected, log an event, create a new serversocket,
        // connect to the socket, reattach the socket to the connection,
        // and send a keepalive (which will kick start the queue)
        //
        if( !m_pReportConnection->IsConnected( ) )
        {
            if( !m_fDisconnectNotified )
            {
                XomNtEvent( XEVENT_COMMON_COMM_35, "CXomReportTarget::HeartBeatThread() - Reporting target has lost connection to the cleansing server %S:%d. Attempting to reconnect", m_bsCleansingServer, m_usCleansingPort );
                m_fDisconnectNotified = TRUE;
            }

            hr = InternalConnect( );
            if( FAILED( hr ) )
            {
                continue;
            }

            if( m_dwLastMessage > m_dwKeepaliveInterval )
            {
                dwTickNow = 0;
            }
            else
            {
                dwTickNow = m_dwLastMessage + 1;
            }

            //
            // Try and wait 10 seconds for the connection to open
            //
            Sleep( 10000 );

            if( m_fDisconnectNotified && m_pReportConnection->IsConnected( ) )
            {
                XomNtEvent( XEVENT_REPORTINGTARGET_RECONNECTED, "CXomReportTarget::HeartBeatThread() - Reporting target has reconnected to the cleansing server %S:%d.", m_bsCleansingServer, m_usCleansingPort );
                m_fDisconnectNotified = FALSE;
            }
            InterlockedExchange( ( LONG * ) &m_dwLastMessage, dwTickNow );
        }

        //
        // See if it's time to send a keep alive message because we haven't been sending
        // any messages in the last little while. Since GetTickCount can wrap around,
        // we have to make sure we handle the wraparound correctly.
        //
        dwTickNow = ( ::GetTickCount( ) );
        if( ( ( dwTickNow >= m_dwLastMessage ) && ( dwTickNow - m_dwLastMessage > m_dwKeepaliveInterval ) ) ||
            ( ( dwTickNow < m_dwLastMessage ) && ( dwTickNow + ( ( ( DWORD ) -1 ) - m_dwLastMessage ) > m_dwKeepaliveInterval ) ) )
        {
            GetSystemTimeAsFileTime( &ftNow );

            //
            // Create the keepalive message
            //

            pBufferKA = CTCPCntVarBuffer::CreateInstance( sizeof( RPT_MSG_HEADER ) );
            if( NULL == pBufferKA )
            {
                XomNtEvent( XEVENT_COMMON_CODE_108, "CXomReportTarget::HeartBeatThread() - Unable to create CTCPCntTemplateBuffer<4>." );
                continue;
            }

            pBuffer = pBufferKA->GetBuffer();
            msgHeader.ullTime = *( ( const ULONGLONG* ) &ftNow );
            memcpy( pBuffer, &msgHeader, sizeof( RPT_MSG_HEADER ) );

            hr = m_pReportConnection->Send( pBufferKA );
            if( FAILED( hr ) )
            {
                XomNtEvent( XEVENT_COMMON_CODE_109, "CXomReportTarget::HeartBeatThread() - CReportConnection::Send failed, hr=0x%08X", hr );
            }

            SAFE_RELEASE( pBufferKA );

            InterlockedExchange( ( LONG * ) &m_dwLastMessage, dwTickNow );
        }
    }

    ::SetEvent( m_hMain );

    ::ExitThread( 0 );
}

HRESULT __stdcall CXomReportTargetListener::VirtualInterfaceChange(
        struct IVirtualInterfaceChangeEventArgs * e )
{
    HRESULT hr = S_OK;

    if( NULL == m_pReportTarget )
    {
        hr = E_FAIL;
        goto lDone;
    }

    hr = m_pReportTarget->VirtualInterfaceChange( e );

lDone:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomsettings.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomsettings.h

Abstract:

--*/

#ifndef _XOMSETTINGS_H_
#define _XOMSETTINGS_H_


class CXomSettings;
class CXomSetting;


//
// CXomSettings
//

class CXomSettings
{
public:

    IMPLEMENT_REFCOUNT;

    CXomSettings();

    virtual ~CXomSettings();

    HRESULT Init(
        LPCSTR pszIni );

    HRESULT Terminate();

    HRESULT GetSetting(
        LPCSTR pszName,
        OUT CXomSetting** ppSetting );

    HRESULT AddSetting(
        CXomSetting* pSetting );

protected:



    HRESULT ParseConfiguration(
        CHAR* pbBuffer,
        DWORD cbBuffer );

    static AVL_COMPARE_RESULT AVLAPI AvlCompare(
        struct _AVL_TABLE *pTable,
        void *pvFirst,
        void *pvSecond );

    static void * AVLAPI AvlAlloc(
        struct _AVL_TABLE *pTable,
        DWORD cbTreeNode );

    static void AVLAPI AvlFree(
        struct _AVL_TABLE *pTable,
        void *pvTreeNode );

    AVL_TABLE m_Table;

    bool m_fNoErrors;
};


#endif // #ifndef _XOMSETTINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\crt\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xmgmtlib_none_12.4.56.0_none_f3fb2f42c8869f38
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmgmtlib
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.manifest
XP_MANIFEST_PATH=manifests\x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.cat
XP_CATALOG_PATH=manifests\x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.cat
XP_PAYLOAD_PATH=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmgmtlib,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomsettings.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomcmmon.h

Abstract:

--*/

#include "stdafx.h"


CXomSetting* CXomSettingEx::s_rgSettings[c_xomMaxSettings];
DWORD CXomSettingEx::s_dwSettingCount = 0;

//
// CXomSetting
//

CXomSetting::CXomSetting(
    CXomOption& op
)
/*++

Routine Description:

  Constructor

Arguments:

  op - CXomOption object containing set of options to configure this setting
      object. The types of options supported are the ones listed in the
      OPTIONS enumeration.

Return Value:

  None

--*/
{
    m_szSettingName[0] = '\0';
    m_hrResult = S_OK;
    ZeroMemory(&m_d, sizeof(m_d));
    m_fMandatory = true;
    m_fSet = false;
    m_dwMin = 0;
    m_dwMax = ~0;
    m_lRefCount = 1;

    Init(op);
}

CXomSetting::~CXomSetting()
/*++

Routine Description:

  Destructor

Arguments:

  None

Return Value:

  None

--*/
{
    if(m_d.pwszData != NULL)
    {
        free((void*)m_d.pwszData);
        m_d.pwszData = NULL;
    }

    if(m_d.pszData != NULL)
    {
        free((void*)m_d.pszData);
        m_d.pszData = NULL;
    }
}

void CXomSetting::Init(
    CXomOption& op
)
/*++

Routine Description:

  Initialize setting object. This method is called by the constructor.

Arguments:

  op - same options object passed to the constructor

Return Value:

  None - however, if the initialization failed (for example, if the options are
      invalid, m_hrResult will contain an error.

--*/
{
    DWORD nOp;

    for(nOp=0; nOp < op.GetSettingCount(); nOp++)
    {
        switch(op.GetSetting(nOp)->dwId)
        {
        case O_NAME:
            //
            // Setting name
            //

            XOMASSERT(op.GetSetting(nOp)->eType == op.T_STR);
            lstrcpynA(m_szSettingName, op.GetSetting(nOp)->pszData, ARRAY_ELEMENTS(m_szSettingName));
            _strlwr(m_szSettingName);
            break;


        case O_DEFAULT:
            {
                //
                // Setting default value
                //

                switch(op.GetSetting(nOp)->eType)
                {
                case op.T_DWORD:

                    m_hrResult = SetDw(op.GetSetting(nOp)->dwData);

                    if(FAILED(m_hrResult))
                    {
                        goto lDone;
                    }

                    break;

                case op.T_STR:

                    m_hrResult = SetStr(op.GetSetting(nOp)->pszData);

                    if(FAILED(m_hrResult))
                    {
                        goto lDone;
                    }

                    break;

                case op.T_WSTR:

                    m_hrResult = SetWStr(op.GetSetting(nOp)->pwszData);

                    if(FAILED(m_hrResult))
                    {
                        goto lDone;
                    }

                    break;
                }

                //
                // If we have a default value, the setting isn't mandatory.
                //

                m_fMandatory = false;
                m_fSet = true;

                break;
            }

        case O_MIN:
            //
            // Setting MIN constraint
            //

            XOMASSERT(op.GetSetting(nOp)->eType == op.T_DWORD);

            m_dwMin = op.GetSetting(nOp)->dwData;

            SetDw(m_d.dwData);

            break;

        case O_MAX:
            //
            // Setting MAX constraint
            //

            XOMASSERT(op.GetSetting(nOp)->eType == op.T_DWORD);

            m_dwMax = op.GetSetting(nOp)->dwData;

            SetDw(m_d.dwData);

            break;

        default:
            //
            // This option is not supported
            //
            XOMASSERT(!"Invalid option");

            m_hrResult = E_INVALIDARG;

            goto lDone;
        };
    }

lDone:

    return;
}

HRESULT CXomSetting::SetDw(
    DWORD dwNewValue
)
/*++

Routine Description:

  Set value using a DWORD

Arguments:

  dwNewValue - new value of DWORD type

Return Value:

  HRESULT

--*/
{
    WCHAR wszNewValue[32];

    dwNewValue = __max(__min(dwNewValue, m_dwMax), m_dwMin);

    _ultow(dwNewValue, wszNewValue, 10);

    return SetWStr(wszNewValue);
}

HRESULT CXomSetting::SetStr(
    LPCSTR pszNewValue
)
/*++

Routine Description:

  Set value using an UTF8 string.

Arguments:

  pszNewValue - New string value.

Return Value:

  HRESULT

--*/
{
    int cchMultiByte = strlen(pszNewValue) + 1;
    WCHAR* wszNewValue;
    int cbNewString;

    __try
    {
        wszNewValue = (WCHAR*)_alloca(cchMultiByte * sizeof(WCHAR));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return E_OUTOFMEMORY;
    }

    cbNewString = MultiByteToWideChar(CP_UTF8, 0, pszNewValue, cchMultiByte, wszNewValue, cchMultiByte);

    if(cbNewString != 0 || GetLastError() == NO_ERROR)
    {
        return SetWStr(wszNewValue);
    }
    else
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
}

HRESULT CXomSetting::SetWStr(
    LPCWSTR pwszNewValue
)
/*++

Routine Description:

  Set value using an unicode string. This method is used internally to set the
  other value types.

Arguments:

  pwszNewValue - new unicode string value.

Return Value:

  HRESULT

--*/
{
    int cbMultiByte;
    LPWSTR pwszNew = NULL;
    LPSTR pszNew = NULL;
    void* pOld = NULL;
    wchar_t* endptr;
    DWORD dwNew = 0;
    HRESULT hr = S_OK;

    //
    // Alloc new wstring value
    //

    pwszNew = _wcsdup(pwszNewValue);

    if(NULL == pwszNew)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    //
    // Alloc new string value
    //

    cbMultiByte = WideCharToMultiByte(CP_UTF8, 0, pwszNewValue, -1, NULL, 0, NULL, NULL);

    if(0 == cbMultiByte && GetLastError() != NO_ERROR)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto lDone;
    }

    pszNew = (LPSTR) malloc(cbMultiByte);

    if(NULL == pszNew)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    if(cbMultiByte != WideCharToMultiByte(CP_UTF8, 0, pwszNewValue, -1, pszNew, cbMultiByte, NULL, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto lDone;
    }

    //
    // Calculate new DWORD value
    //

    dwNew = wcstoul(pwszNewValue, &endptr, 0);

    //
    // Switch
    //

    if(m_d.pwszData != NULL)
    {
        free((void*)m_d.pwszData);
    }

    m_d.pwszData = pwszNew;

    if(m_d.pszData != NULL)
    {
        free((void*)m_d.pszData);
    }

    m_d.pszData = pszNew;

    InterlockedExchange((LONG*)&(m_d.dwData), (LONG) dwNew);

    pwszNew = NULL;
    pszNew = NULL;

lDone:

    if(pwszNew != NULL)
    {
        free(pwszNew);
    }

    if(pszNew != NULL)
    {
        free(pszNew);
    }

    return hr;
}

//
// CXomSettings
//

CXomSettings::CXomSettings()
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    //
    // Initialize setting table. There is no memory allocation involved so this
    // operation can't fail and therefore it's "constructor-safe".
    //

    AvlInitializeTable(&m_Table, AvlCompare, AvlAlloc, AvlFree, this );
}

CXomSettings::~CXomSettings()
/*++

Routine Description:

  Constructor

Arguments:

  None

Return Value:

  None

--*/
{
    Terminate();
}

HRESULT CXomSettings::Init(
    LPCSTR pszIni
)
/*++

Routine Description:

  Initialize the settings framework object.

Arguments:

  pszIni - full path or name of the INI file.

Return Value:

  HRESULT

--*/
{
    DWORD nSetting;
    HRESULT hr = S_OK;
    CHAR szModuleName[MAX_PATH];
    CHAR szDrive[_MAX_DRIVE];
    CHAR szDir[_MAX_DIR];
    CHAR szIniPath[MAX_PATH];
    BYTE* pBuffer = NULL;
    DWORD cbBuffer = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbFileSize = 0;
    DWORD cbRead = 0;

    //
    // First process all the global settings.
    //

    for(nSetting=0; nSetting < CXomSettingEx::s_dwSettingCount; nSetting++)
    {
        hr = CXomSettingEx::s_rgSettings[nSetting]->GetStatus();

        if(FAILED(hr))
        {
            XomNtEvent( XEVENT_MGMT_INIT_FAILURE_7, "[CXomSettings::Init] Configuration "
                "setting %s has an error (hr = 0x%08x). Check your configuration file.",
                CXomSettingEx::s_rgSettings[nSetting]->GetName(), hr );
            goto lDone;
        }

        hr = AddSetting(CXomSettingEx::s_rgSettings[nSetting]);

        if(FAILED(hr))
        {
            XomNtEvent( XEVENT_MGMT_INIT_FAILURE_8, "[CXomSettings::Init] hr = AddSetting failed, hr = 0x%08x)",
                CXomSettingEx::s_rgSettings[nSetting]->GetName(), hr );
            goto lDone;
        }
    }

    if(pszIni != NULL)
    {
        //
        // Is pszIni a full path or should we use the module's directory
        //

        _splitpath(pszIni, NULL, szDir, NULL, NULL);

        if(szDir[0] != '\0')
        {
            //
            // The full path was specified
            //

            lstrcpynA(szIniPath, pszIni, ARRAY_ELEMENTS(szIniPath));
        }
        else
        {
            //
            // Only the file name was specified. Use the current module's
            // path
            //

            if(!GetModuleFileNameA(NULL, szModuleName, ARRAY_ELEMENTS(szModuleName)))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto lDone;
            }

            _splitpath(szModuleName, szDrive, szDir, NULL, NULL);

            _snprintf(szIniPath, ARRAY_ELEMENTS(szIniPath), "%s%s%s", szDrive, szDir, pszIni);
            szIniPath[ARRAY_ELEMENTS(szIniPath)-1] = '\0';
        }

        //
        // Open the file and read it all in a buffer
        //

        hFile = CreateFileA(szIniPath, GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, 0, NULL);

        if(INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto lDone;
        }

        cbFileSize = GetFileSize(hFile, NULL);

        // Check for overflow
        if (cbFileSize > cbFileSize + 2)
        {   
            hr = E_OUTOFMEMORY;
            goto lDone;        
        }
        
        pBuffer = new BYTE[cbFileSize + 2];

        if(NULL == pBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        if(! ReadFile(hFile, pBuffer, cbFileSize, &cbRead, NULL) ||
            cbRead != cbFileSize )
        {
            hr = GetLastError() != NO_ERROR ? HRESULT_FROM_WIN32(GetLastError()) : E_FAIL;
            goto lDone;
        }

        //
        // The parsing function requires that the buffer ends with a CR-LF pair
        //

        pBuffer[cbFileSize] = '\r';
        pBuffer[cbFileSize+1] = '\n';

        //
        // Parse the buffer
        //

        hr = ParseConfiguration((CHAR*)pBuffer, cbFileSize + 2);

        if(FAILED(hr))
        {
            goto lDone;
        }
    }

lDone:

    if(hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    if(pBuffer)
    {
        delete [] pBuffer;
        pBuffer = NULL;
    }

    return hr;
}

HRESULT CXomSettings::Terminate()
/*++

Routine Description:

  Release stuff. Unsubscribe from the control notification list. Prepare for shutdown.
  Automatically called by the destructor.

Arguments:

  None

Return Value:

--*/
{
    CXomSetting** ppSetting;
    CXomSetting* pSetting;
    BOOL fRestart = TRUE;

    while( (ppSetting = (CXomSetting**)AvlEnumerate(&m_Table, fRestart) ) != NULL)
    {
        pSetting = *ppSetting;

        if(!AvlDeleteElement(&m_Table, ppSetting))
        {
            break;
        }

        pSetting->Release();
    }

    return S_OK;
}

AVL_COMPARE_RESULT AVLAPI CXomSettings::AvlCompare(
    struct _AVL_TABLE *pTable,
    void *pvFirst,
    void *pvSecond
)
/*++

Routine Description:

  We provide this to the AVL tree library so it knows how to sort our settings,
  which BTW, will be sorted ascendingly by name, case-insensitive.

Arguments:

  pTable - pointer to the AVL table object.

  pvFirst - pointer to first object (in our case, a pointer to CXomSetting).

  pvSecond - pointer to second object (in our case, a pointer to CXomSetting).

Return Value:

  AvlLessThan - pvFirst is less than pvSecond
  AvlGreaterThan - pvFirst is greater than pvSecond
  AvlEqual - pvFirst is equal to pvSecond


--*/
{
    LPCSTR pszFirst  = (*((CXomSetting**)pvFirst))->GetName();
    LPCSTR pszSecond = (*((CXomSetting**)pvSecond))->GetName();

    int iRes = strcmp(pszFirst, pszSecond);

    if(iRes < 0)
    {
        return AvlLessThan;
    }
    else if(iRes > 0)
    {
        return AvlGreaterThan;
    }
    else
    {
        return AvlEqual;
    }
}

void * AVLAPI CXomSettings::AvlAlloc(
    struct _AVL_TABLE *pTable,
    DWORD cbTreeNode
)
/*++

Routine Description:

  Used by the AVL tree library to allocate new tree nodes.

Arguments:

  pTable - pointer to AVL table object

  cbTreeNode - size of the node in bytes

Return Value:

  void* - pointer to new allocated memory buffer.

--*/
{
    void *pvNode = new BYTE[ cbTreeNode ];
    return( pvNode );

}

void AVLAPI CXomSettings::AvlFree(
    struct _AVL_TABLE *pTable,
    void *pvTreeNode
)
/*++

Routine Description:

  Used by the AVL tree library to release tree nodes.

Arguments:

  pTable - pointer to AVL table object.

  pvTreeNode - pointer to node to be released.

Return Value:

  None.

--*/
{
    delete [] (BYTE *) pvTreeNode;
}


HRESULT CXomSettings::AddSetting(
    CXomSetting* pSetting
)
/*++

Routine Description:

  Add a CXomSetting object to our table. After that we can search for it or
  change it using the remote admin service.

Arguments:

  pSetting - pointer to CXomSetting object. It will be addref'd if the function
      succeeds.

Return Value:

  HRESULT

--*/
{
    BOOL fNoDuplicateFound;
    void* pvNode = NULL;
    HRESULT hr = S_OK;

    pSetting->AddRef();

    //
    // Add setting to table
    //

    pvNode = AvlInsertElement(&m_Table, (void*) &pSetting, sizeof(pSetting), &fNoDuplicateFound);

    if(NULL == pvNode)
    {
        //
        // Failed to insert element. Probably out of memory?
        //

        pSetting->Release();
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    if(!fNoDuplicateFound)
    {
        //
        // An element with the same key was found.
        //

        pSetting->Release();
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        goto lDone;
    }

lDone:

    return hr;
}

HRESULT CXomSettings::GetSetting(
    LPCSTR pszName,
    OUT CXomSetting** ppSetting
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    HRESULT hr = S_OK;

    CXomSetting oDummy(CXomOption(CXomSetting::O_NAME, pszName));
    CXomSetting* pDummy = &oDummy;

    CXomSetting** pRet = NULL;

    pRet = (CXomSetting**) AvlFindElement(&m_Table, &pDummy);

    if(pRet != NULL)
    {
        *ppSetting = (*pRet);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT CXomSettings::ParseConfiguration(
    CHAR* pbBuffer,
    DWORD cbBuffer
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    CHAR* pbParsing = pbBuffer;
    CHAR* pbParsing2 = NULL;
    CHAR* pbSectionName = NULL;
    SIZE_T cbSectionName = 0;
    CHAR* pbKeyName = NULL;
    SIZE_T cbKeyName = 0;
    CHAR* pbKeyValue = NULL;
    DWORD cbKeyValue = 0;
    CHAR* pbEnd = pbBuffer + cbBuffer - 1;
    CXomSetting* pSetting = NULL;
    CHAR szSettingName[CXomSetting::c_xomMaxSettingName];
    HRESULT hr = S_OK;


    while(pbParsing <= pbEnd)
    {
        switch(*pbParsing)
        {
        case ' ':

            // Trimming leading spaces

            pbParsing++;

            break;

        case ';':

            // Comments

            for(; pbParsing < pbEnd && *pbParsing != '\r' && *pbParsing != '\n'; pbParsing++);

            if('\r' == *pbParsing || '\n' == *pbParsing)
            {
                pbParsing++;
            }

            break;

        case '\n':
        case '\r':

            // New lines

            pbParsing++;
            break;

        case '[':

            // Section name

            pbParsing++;
            pbParsing2 = pbParsing;
            pbSectionName = pbParsing;

            for(; pbParsing2 < pbEnd && *pbParsing2 != ']'; pbParsing2++);

            if(*pbParsing2 != ']')
            {
                hr = E_FAIL;
                goto lDone;
            }

            *pbParsing2 = '\0';

            cbSectionName = pbParsing2 - pbParsing;

            pbParsing = pbParsing2 + 1;

            break;

        default:

            // Key value pair

            pbParsing2 = pbParsing;
            pbKeyName = pbParsing;

            // Parse the key

            for(; pbParsing2 < pbEnd && isalnum(*pbParsing2); pbParsing2++);

            if(*pbParsing2 == ' ')
            {
                // skip spaces at the end of the key

                *pbParsing2 = '\0';
                pbParsing2++;

                for(; pbParsing2 < pbEnd && *pbParsing2 == ' '; pbParsing2++);
            }

            if(*pbParsing2 != '=')
            {
                XomNtEvent(XEVENT_MGMT_INIT_FAILURE_9,
                    "Failed to parse configuration file. Expected '=' after key.");

                hr = E_FAIL;
                goto lDone;
            }

            *pbParsing2 = '\0';

            cbKeyName = pbParsing2 - pbParsing;

            pbKeyValue = pbParsing2 + 1;

            if(pbKeyValue > pbEnd)
            {
                hr = E_FAIL;
                goto lDone;
            }

            // Parse the value

            for(; pbParsing2 < pbEnd && *pbParsing2 != '\r' && *pbParsing2 != '\n'; pbParsing2++);

            *pbParsing2 = '\0';

            pbParsing = pbParsing2 + 1;

            _snprintf(szSettingName, ARRAY_ELEMENTS(szSettingName), "%s%s%s",
                pbSectionName != NULL ? pbSectionName : "",
                pbSectionName != NULL ? "." : "",
                pbKeyName);

            if(SUCCEEDED(GetSetting(szSettingName, &pSetting)))
            {
                // Update setting value

                hr = pSetting->SetStr(pbKeyValue);

                if(FAILED(hr))
                {
                    goto lDone;
                }

                pSetting = NULL;
            }
            else
            {
                // Setting not found. Create a new setting

                pSetting = new CXomSetting(
                    CXomOption(CXomSetting::O_NAME, szSettingName) +
                    CXomOption(CXomSetting::O_DEFAULT, pbKeyValue) );

                if(NULL == pSetting)
                {
                    hr = E_OUTOFMEMORY;
                    goto lDone;
                }

                // Add setting to table

                hr = AddSetting(pSetting);

                // If succeeded, pSetting's refcount got incremented and we can
                // release the object. If failed, releasing the object will
                // also destroy it (which is good).

                pSetting->Release();
                pSetting = NULL;

                // Now we can check if the AddSetting operation succeeded.

                if(FAILED(hr))
                {
                    goto lDone;
                }
            }

            break;
        }
    }

lDone:

    return hr;
}


CXomSettingEx::CXomSettingEx( CXomOption& op )
    : CXomSetting(op)
{
    if(SUCCEEDED(m_hrResult))
    {
        if(s_dwSettingCount < c_xomMaxSettings)
        {
            s_rgSettings[s_dwSettingCount++] = (CXomSetting*)this;
        }
        else
        {
            m_hrResult = E_FAIL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\xomrpttarget.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef XOMRPTTARGET_H_INCLUDED
#define XOMRPTTARGET_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CXomReportTargetListener;

/*****************************************************************************

CXomReportTarget

This class implements the xmgmt target for reporting. In a nutshell, it takes
logs and sends them to a cleansing server over TCP.

*****************************************************************************/
class CXomReportTarget :
    public CXomTargetBase
{
public:

    IMPLEMENT_REFCOUNT

    CXomReportTarget();

    virtual ~CXomReportTarget();

    HRESULT Init(
        CCompletionPort* pIOCP,
        LPCSTR pszParams,
        LPCSTR pszDefault = NULL);

    virtual HRESULT Startup();

    virtual void Term();

    virtual void Log(
        CLogFormatedMessage* pMsg);

    virtual HRESULT VirtualInterfaceChange(
        /* [in] */ struct IVirtualInterfaceChangeEventArgs * e );

protected:

    HRESULT InternalConnect( );

    HRESULT ExtractCleanserInfo( IVirtualInterfaceInfo * pVirtualInterface );

    static DWORD WINAPI HeartBeatThreadProc( LPVOID lpThis );
    void HeartBeatThread();

    //
    // Configuration parameters
    //
    CComPtr<IConfig> m_pConfig;
    CComBSTR m_bsEnvironment;
    CComBSTR m_bsCleansingServer;
    CComBSTR m_bsVirtualInterface;
    u_short m_usCleansingPort;
    DWORD m_dwHeartBeatInterval;
    DWORD m_dwKeepaliveInterval;
    long m_componentId;

    //
    // Pointer to classes we use to actually handle
    // the network I/O of our log messages
    //
    CCompletionPort* m_pIOCP;
    CServerSocket* m_pSocketCleansing;
    CReportConnection* m_pReportConnection;

    //
    // These members are used for our heartbeat thread
    //
    HANDLE m_hHeartBeatThread;
    DWORD m_dwHeartBeatThreadId;
    DWORD m_dwLastMessage;

    //
    // These members handle our startup/shutdown logic
    //
    DWORD m_dwShutdownWait;
    LONG m_lStarted;
    HANDLE m_hShutdown;
    HANDLE m_hMain;
    LONG m_lShutdown;
    BOOL m_fDisconnectNotified;

    CXomReportTargetListener* m_pListener;
};

class CXomReportTargetListener :
    public CConfigListenerBase
{
    IMPLEMENT_REFCOUNT_COM

    CXomReportTargetListener( CXomReportTarget * pReportTarget )
    {
        m_pReportTarget = pReportTarget;
    }

    STDMETHODIMP QueryInterface( REFIID riid, void** ppObj )
    {
        HRESULT hr;

        if( NULL == ppObj )
        {
            hr = E_POINTER;
            goto lDone;
        }

        if( IID_IUnknown == riid )
        {
            *ppObj = ( void* )( IUnknown * )this;
            hr = S_OK;
            AddRef();
        }
        else if( _uuidof( IConfigListener ) == riid )
        {
            *ppObj = ( void* )( IConfigListener * )this;
            hr = S_OK;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }

    lDone:

        return hr;
    }

    virtual HRESULT __stdcall VirtualInterfaceChange(
        /* [in] */ struct IVirtualInterfaceChangeEventArgs * e );

protected:

    CXomReportTarget * m_pReportTarget;

};

#endif // XOMRPTTARGET_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\crt\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xmgmtlib_none_12.4.56.0_none_f3fb2f42c8869f38
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmgmtlib
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.manifest
XP_MANIFEST_PATH=manifests\x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.cat
XP_CATALOG_PATH=manifests\x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.cat
XP_PAYLOAD_PATH=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmgmtlib,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\rockall\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xmgmtlib_none_12.4.56.0_none_f3fb2f42c8869f38
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmgmtlib
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.manifest
XP_MANIFEST_PATH=manifests\x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.cat
XP_CATALOG_PATH=manifests\x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.cat
XP_PAYLOAD_PATH=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmgmtlib,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\rockall\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xmgmtlib_none_12.4.56.0_none_f3fb2f42c8869f38
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmgmtlib
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.manifest
XP_MANIFEST_PATH=manifests\x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.cat
XP_CATALOG_PATH=manifests\x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122.cat
XP_PAYLOAD_PATH=x86_xmgmtlib_no-public-key_12.4.56.0_x-ww_d368c122
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmgmtlib,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\inc\XmgmtLogging.h ===
/*++

Copyright (c) 2007 Microsoft Corporation

Module Name:

    XmgmtLogging.h

Abstract:

--*/

#ifndef _XMGMTLOGGING_H_
#define _XMGMTLOGGING_H_

#include <compport.h>
#include "..\xomcmmon.h"
#include "..\asyncfile.h"
#include "..\xomfiletarget.h"

#endif // #ifndef _XMGMTLOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\inc\xomcontrolprot.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    xomcontrolprot.h

Abstract:

--*/

#ifndef _XOMCONTROLPROT_H_
#define _XOMCONTROLPROT_H_

#define XOMCTRL_ADMIN_PORT 4100
#define XOMCTRL_TRACE_PORT 4101
#define XOMCTRL_MAXPROCESSNAME 256
#define XOMCTRL_MAXCOMPONENTNAME 256
#define XOMCTRL_MAXMESSAGESIZE 30720

// Disable word-alignment for structures and unions.
// Preserve previous setting.

#pragma pack( push, before_xomcontrolprot_h )
#pragma pack(1)

struct XOMCTRLMSG_HEADER
{
    DWORD dwSize;
    DWORD dwType;
    
    #define XOMCTRLMSGID_REGISTER 0x01
    #define XOMCTRLMSGID_REQUEST 0x02
    #define XOMCTRLMSGID_RESPONSE 0x03
    #define XOMCTRLMSGID_RESPONSE_DONE 0x04
};

struct XOMCTRLMSG_REGISTER
{
    XOMCTRLMSG_HEADER hdr;
    DWORD dwProcessId;
    CHAR szProcessName[XOMCTRL_MAXPROCESSNAME];
    CHAR szComponentName[256];
};

struct XOMCTRLMSG_REQUEST
{
    XOMCTRLMSG_HEADER hdr;
    DWORD dwRequestId;
    // CHAR rgbRequest[];
};

struct XOMCTRLMSG_RESPONSE
{
    XOMCTRLMSG_HEADER hdr;
    DWORD dwRequestId;
    // CHAR rgbResponse[];
};

struct XOMCTRLMSG_RESPONSE_DONE
{
    XOMCTRLMSG_HEADER hdr;
    DWORD dwRequestId;
    HRESULT hr;
};

// Restore packing alignment setting.

#pragma pack( pop, before_xomcontrolprot_h )

#endif // #ifndef _XOMCONTROLPROT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\inc\EventThrottle.h ===
#pragma once


//////////////////////////////////////////////////////////////////////////////
#ifndef THROTTLE_ASSERT

#if DBG
#define THROTTLE_ASSERT(x)  assert(x)
#else
#define THROTTLE_ASSERT(x)
#endif

#endif


//////////////////////////////////////////////////////////////////////////////
typedef ULONGLONG QWORD;
#define dimensionof(x)          (sizeof((x))/sizeof(*(x)))

#define USE_MACRO_MOVETOHEAD    1
#if DBG
#define SANITY_CHECK_LRUS       0
#endif

#if USE_MACRO_MOVETOHEAD == 1

#define MoveToHead(pItem,pHead,pTail) \
    THROTTLE_ASSERT( NULL == pHead->pLRUPrev ); \
    THROTTLE_ASSERT( NULL == pTail->pLRUNext ); \
    if( pItem != pHead ) \
    { \
        THROTTLE_ASSERT( NULL != pItem->pLRUPrev ); \
        pItem->pLRUPrev->pLRUNext = pItem->pLRUNext; \
        if( pItem == pTail ) \
        { \
            THROTTLE_ASSERT( NULL == pItem->pLRUNext ); \
            pTail = pItem->pLRUPrev; \
            THROTTLE_ASSERT( NULL == pTail->pLRUNext ); \
        } \
        else \
        { \
            THROTTLE_ASSERT( NULL != pItem->pLRUNext ); \
            THROTTLE_ASSERT( NULL != pItem->pLRUPrev ); \
            pItem->pLRUNext->pLRUPrev = pItem->pLRUPrev; \
        } \
        pItem->pLRUPrev = NULL; \
        pItem->pLRUNext = pHead; \
        THROTTLE_ASSERT( NULL == pHead->pLRUPrev ); \
        pHead->pLRUPrev = pItem; \
        pHead = pItem; \
        THROTTLE_ASSERT( NULL == pHead->pLRUPrev ); \
        THROTTLE_ASSERT( NULL == pTail->pLRUNext ); \
    } \
    else

#endif

class CXomControlResponseInterface;

//////////////////////////////////////////////////////////////////////////////
//
// Convenient list of prime numbers for use as wIPHashSize template argument:
// 37,59,89,139,227,359,577,929,1499,2423,3919,5009,6337,10007,25031
//

//////////////////////////////////////////////////////////////////////////////
template
<
    WORD wBaseEventId,              // First recognized NT event ID to handle
    WORD wMaxEntries,               // Number of event throttles to handle
    WORD wIPHashSize,               // Desired number of IPs to track per event - should be prime
    DWORD dwHashBlockPoolSize,      // Amount of memory (in bytes) to use for hash blocks
    DWORD dwEntryBlockPoolSize,     // Amount of memory (in bytes) to use for table entry blocks
    DWORD dwMaxChainBlocks = 250    // Don't add more than this many entry blocks to any hash bucket
>
class CEventThrottle
{
public:
    CEventThrottle()
    {
        WipeAllState();
    }

    const static int HNS_PER_SECOND = 10000000;
    const static int ETHERNET_OVERHEAD_PER_PACKET = 8 /* preamble */ + 14 /* src, dst, type */ + 4 /* CRC */;
    const static DWORD ALL_EVENTS = 0;                // special event id to represent all events
    const static DWORD MAX_SEARCH_TEXT_LEN = 1024;
    const static DWORD MAX_SEARCH_TERMS = 8;
    




    //////////////////////////////////////////////////////////////////////////////
    enum ALLOW_TYPE
    {
        UNKNOWN = 0,
        ALWAYS_ALLOW    = 1,    // This event will always occur, and isn't tracked
        SOMETIMES_ALLOW = 2,    // This event will sometimes occur (based on other params)
        NEVER_ALLOW     = 3     // This event has been squelched
    };

    WORD GetSize() { return wMaxEntries; } const

    BOOL Initialize(
                DWORD dwEventID,                    // Which event to initialize, or ALL_EVENTS
                const char* pszSearchText,           // event search string
                ALLOW_TYPE eAllowType,              // What kind of logic to apply to the event(s)
                BOOL fRateUnitsAreBytes = FALSE,    // If TRUE, uses data rate instead of event rate
                DWORD dwAlertUnitsPerSec = 0,       // If != 0, alert at this many events|bytes /sec
                QWORD hnsEventInterval = 0,         // How long to wait between allowing events
                BOOL fTrackPerIP = FALSE )          // By default don't track info per source IP address
    {
        PerEventStuff*  pEventStuff    = NULL;
        BOOL            bHasSearchText = (pszSearchText != NULL && pszSearchText[0] != '\0');

        //
        // Validate parameters
        //
        WORD wEventID = LOWORD( dwEventID );

        if( ( eAllowType < ALWAYS_ALLOW ) || ( eAllowType > NEVER_ALLOW ) )
        {
            return( FALSE );
        }

        if( dwAlertUnitsPerSec > 0x0FFFFFFF )
        {
            return( FALSE );
        }

        if ( !bHasSearchText ) 
        {
            pEventStuff = FindEntry( wEventID, NULL );
        }

        if ( pEventStuff == NULL )
        {
            pEventStuff = AllocateEntry();
        }

        if ( pEventStuff == NULL )
        {
            // too many events to be tracked!
            return( FALSE );
        }

        WipeEvent( pEventStuff );

        //
        // Fill in new event settings
        //
        pEventStuff->wEventId = wEventID;
        pEventStuff->Flags.fSometimesOn = ( SOMETIMES_ALLOW == eAllowType );
        pEventStuff->Flags.fNeverOn = ( NEVER_ALLOW == eAllowType );
        pEventStuff->Flags.fRateUnitsAreBytes = fRateUnitsAreBytes;
        pEventStuff->Flags.fTrackPerIP = fTrackPerIP;
        pEventStuff->Flags.dwAlertUnitsPerSec = dwAlertUnitsPerSec;
        pEventStuff->hnsEventInterval = hnsEventInterval;

        if ( bHasSearchText )
        {
            // WipeEvent zeroes everything out, so by copying 1 less than the max 
            // characters, we will always have a null terminator.
            strncpy(pEventStuff->szSearchText, pszSearchText, MAX_SEARCH_TEXT_LEN - 1);
            pEventStuff->pszSearchTerms[0] = pEventStuff->szSearchText;
            
            int cTerms = 0;
            char* psz = pEventStuff->pszSearchTerms[0];
            char* pch = strchr(psz, '*');


            // populate pszSearchTerms with the search string split up by '*'s
            while (pch != NULL)
            {
                if (pch != psz && *(pch - 1) == '\\')
                {
                    // escaped character, move on to the next.
                    pch = strchr(pch+1, '*');
                    continue;
                }

                *pch = NULL;
                pch++;
                
                if (*pch != NULL)
                {
                    if (++cTerms >= MAX_SEARCH_TERMS)
                    {
                        // too many search terms!
                        return( FALSE );
                    }

                    pEventStuff->pszSearchTerms[cTerms] = pch;
                    pch = strchr(pch, '*');
                }
            }
        }


        return( TRUE );
    }

    
    //////////////////////////////////////////////////////////////////////////////
    //
    // The workhorse event processing routine:  call it with the right info,
    // and it will tell you what to do with the event.  If an alert event should be fired,
    // include the source IP (if applicable), NumSkips, and RecentRate in that event text/data.
    //
    BOOL ProcessEvent(
                QWORD hnsNow,               // What time is it (in 100-nanosecond units)? (zero isn't allowed)
                DWORD dwEventID,            // Which event just occurred?
                LPCSTR pszText,             // what is the text of the event?
                WORD wPacketSize,           // Packet size of event cause, or 0 if unknown or not applicable
                DWORD *pina,                // Source IP address if known, or NULL if unknown or not applicable
                BOOL *pfAllowThisEvent,     // Should the calling code fire the event?
                DWORD *pdwNumSkips,         // How many have been skipped since last allowed event
                DWORD *pdwNumSkipsTotal,    // How many have been skipped overall
                DWORD *pdwRecentRate )      // How many units of this event happened in the last wall clock second
    {
        WORD wEventID = LOWORD( dwEventID );
        PerEventStuff* pEvent;
        int index = 0;
        

#if DBG
        //
        // Validate parameters (debug only)
        //
        if( ( 0 == hnsNow ) ||
            ( NULL == pfAllowThisEvent ) ||
            ( NULL == pdwNumSkips ) ||
            ( NULL == pdwNumSkipsTotal ) ||
            ( NULL == pdwRecentRate ) )
        {
            return( FALSE );
        }
#endif // DBG


        //
        // Set up for default fast path processing
        //
        *pfAllowThisEvent = TRUE;
        *pdwNumSkips = 0;
        *pdwNumSkipsTotal = 0;
        *pdwRecentRate = 0;


        //
        // Find any event configurations for this particular event id
        //
        pEvent = FindEntry(wEventID, pszText);

        if (pEvent == NULL)
        {
            // 
            // Find any event configurations for all events
            //

            pEvent = FindEntry(ALL_EVENTS, pszText);

            if(pEvent == NULL)
            {
                // no matching event throttling found
                return( TRUE );
            }
        }

        //
        // Check for fast path cases
        //
        if( !pEvent->Flags.fSometimesOn || pEvent->Flags.fNeverOn )
        {
            if( pEvent->Flags.fNeverOn )
            {
                *pfAllowThisEvent = FALSE;
            }

            return( TRUE );
        }

        //
        // Validate event-specific parameter
        //
        if( pEvent->Flags.fTrackPerIP && ( NULL == pina ) )
        {
            // TODO: convert this to an appropriate trace call
            // XomTrace( area, L_ERROR, "Event ID %d being tracked by IP address and source ip is unknown!", wEventID );

            return( FALSE );
        }

        //
        // Find the proper event tracking info, based on the track by IP setting
        //
        EventTrackingStuff *pTrack = &pEvent->evt;

        if( pEvent->Flags.fTrackPerIP )
        {
            pTrack = FindOrInsertIP( pEvent, *pina );

            if( NULL == pTrack )
            {
                THROTTLE_ASSERT( !"Failure in FindOrInsertIP" );
                return( FALSE );
            }
        }

        //
        // Handle any rate tracking on second-aligned boundaries; gather an approximation
        // of the current rate when the trigger threshold is crossed in the current second.
        //
        if( pEvent->Flags.dwAlertUnitsPerSec > 0 )
        {
            QWORD qwNowSecs = hnsNow / HNS_PER_SECOND;
            QWORD qwThenSecs = pTrack->qwFirstTimeThisSec / HNS_PER_SECOND;

            if( qwNowSecs != qwThenSecs )
            {
                pTrack->dwUnitsLastSec = ( qwNowSecs == qwThenSecs + 1 ) ? pTrack->dwUnitsThisSec : 0;
                pTrack->dwUnitsThisSec = 0;
                pTrack->qwFirstTimeThisSec = hnsNow;
            }

            if( pEvent->Flags.fRateUnitsAreBytes )
            {
                pTrack->dwUnitsThisSec += wPacketSize + ETHERNET_OVERHEAD_PER_PACKET;
            }
            else
            {
                pTrack->dwUnitsThisSec++;
            }
        }
        else
        {
            pTrack->dwUnitsThisSec++;
        }

        if( ( pTrack->dwUnitsThisSec >= pEvent->Flags.dwAlertUnitsPerSec ) &&
            ( ( 0 == pTrack->qwLastTime ) || ( hnsNow >= pTrack->qwLastTime + pEvent->hnsEventInterval ) ) )
        {
            //
            // We've reached the threshold rate (again) for this event ID (globally or per-IP) and it has
            // been sufficiently long since the last time we fired an alert.
            // Also, indicate the recent event (data) rate (global or per-IP); this value is typically just the
            // alert (data) rate threshold value unless the interval is set to one second.  If that happens, this
            // code should cause one alert per second to fire with a reasonable (data) rate value >= threshold.
            //
            *pdwRecentRate = pTrack->dwUnitsLastSec + pTrack->dwUnitsThisSec;

            //
            // We're going to allow this event; indicate how many similar ones have been skipped
            //
            *pdwNumSkips = pTrack->dwNumSkips;
            *pdwNumSkipsTotal = pTrack->dwNumSkipsTotal;
            pTrack->dwNumSkips = 0;

            pTrack->dwUnitsThisSec = 0;

            //
            // The caller's clock should never go backwards
            //
            THROTTLE_ASSERT( hnsNow >= pTrack->qwLastTime );
            pTrack->qwLastTime = hnsNow;
        }
        else
        {
            //
            // Make sure we track recent rate properly by resetting our counter each second when we would
            // have alerted if it had been long enough since the last alert
            //
            if( ( pTrack->dwUnitsThisSec >= pEvent->Flags.dwAlertUnitsPerSec ) &&
                ( hnsNow >= pTrack->qwFirstTimeThisSec + HNS_PER_SECOND ) )
            {
                pTrack->dwUnitsThisSec = 0;
            }

            //
            // We're suppressing this event because the outside world doesn't want to know about this kind
            // of thing until we reach our configured rate (globally or per-IP) and it has been 'a while'
            // since the last time we alerted
            //
            pTrack->dwNumSkips++;
            pTrack->dwNumSkipsTotal++;
            *pfAllowThisEvent = FALSE;
        }

        return( TRUE );
    }


    void DumpEventConfig(DWORD dwRequestId, CXomControlResponseInterface* pResponseInterface)
    {
        if (_iHighWaterIndex == 0)
        {
            XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "No events throttled.\r\n" );
            return;
        }

        for (int i = 0; i < _iHighWaterIndex; i++)
        {
            if (_rgEvents[i].pszSearchTerms[0] == NULL)
            {
                XomWriteFormattedResponse(
                        pResponseInterface,
                        dwRequestId,
                        "Event %d:\r\n"
                        "  EventID: %d\r\n"
                        "  Allow Sometimes: %d\r\n"
                        "  Allow Never: %d\r\n"
                        "  Alerts Per Sec: %d\r\n"
                        "  Interval (hns): %I64d\r\n",
                        i,
                        _rgEvents[i].wEventId,
                        _rgEvents[i].Flags.fSometimesOn,
                        _rgEvents[i].Flags.fNeverOn,
                        _rgEvents[i].Flags.dwAlertUnitsPerSec,
                        _rgEvents[i].hnsEventInterval
                        );
            }
            else
            {
                XomWriteFormattedResponse(
                        pResponseInterface,
                        dwRequestId,
                        "Event %d:\r\n"
                        "  Allow Sometimes: %d\r\n"
                        "  Allow Never: %d\r\n"
                        "  Alerts Per Sec: %d\r\n"
                        "  Interval (hns): %I64d\r\n",
                        i,
                        _rgEvents[i].Flags.fSometimesOn,
                        _rgEvents[i].Flags.fNeverOn,
                        _rgEvents[i].Flags.dwAlertUnitsPerSec,
                        _rgEvents[i].hnsEventInterval
                        );

                for (int j = 0; j < CEventThrottle::MAX_SEARCH_TERMS; j++)
                {
                    if (_rgEvents[i].pszSearchTerms[j] == NULL)
                    {
                        break;
                    }
                    
                    XomWriteFormattedResponse(
                            pResponseInterface,
                            dwRequestId,
                            "  Search Term %d: %s\r\n",
                            j,
                            _rgEvents[i].pszSearchTerms[j]
                            );
                }

            }
        }
    }




private:
    //////////////////////////////////////////////////////////////////////////////
    struct EventTrackingStuff;
    struct HashBlock;
    struct IPEntryBlock;
    struct PerEventStuff;

#if USE_MACRO_MOVETOHEAD != 1

    void __forceinline MoveToHead( HashBlock *pItem, HashBlock *& pHead, HashBlock *& pTail )
    {
#if DBG
        HashBlock *pOrigItem = pItem;
        HashBlock *pOrigHead = pHead;
        HashBlock *pOrigTail = pTail;
#endif

        THROTTLE_ASSERT( NULL == pHead->pLRUPrev );
        THROTTLE_ASSERT( NULL == pTail->pLRUNext );

#if SANITY_CHECK_LRUS
        SanityCheckHashLRU();
#endif

        if( pItem != pHead )
        {
            THROTTLE_ASSERT( NULL != pItem->pLRUPrev );
            pItem->pLRUPrev->pLRUNext = pItem->pLRUNext;

            if( pItem == pTail )
            {
                pTail = pItem->pLRUPrev;
                THROTTLE_ASSERT( NULL == pTail->pLRUNext );
            }
            else
            {
                THROTTLE_ASSERT( NULL != pItem->pLRUNext );
                THROTTLE_ASSERT( NULL != pItem->pLRUPrev );
                pItem->pLRUNext->pLRUPrev = pItem->pLRUPrev;
            }

            pItem->pLRUPrev = NULL;
            pItem->pLRUNext = pHead;

            THROTTLE_ASSERT( NULL == pHead->pLRUPrev );
            pHead->pLRUPrev = pItem;
            pHead = pItem;

            THROTTLE_ASSERT( NULL == pHead->pLRUPrev );
            THROTTLE_ASSERT( NULL == pTail->pLRUNext );

#if DBG
            THROTTLE_ASSERT( pHead != pOrigHead );
#endif
        }

#if SANITY_CHECK_LRUS
        SanityCheckHashLRU();
#endif
    }

    void __forceinline MoveToHead( IPEntryBlock *pItem, IPEntryBlock *& pHead, IPEntryBlock *& pTail )
    {
#if DBG
        IPEntryBlock *pOrigItem = pItem;
        IPEntryBlock *pOrigHead = pHead;
        IPEntryBlock *pOrigTail = pTail;
#endif

        THROTTLE_ASSERT( NULL == pHead->pLRUPrev );
        THROTTLE_ASSERT( NULL == pTail->pLRUNext );

#if SANITY_CHECK_LRUS
        SanityCheckEntryLRU();
#endif

        if( pItem != pHead )
        {
            THROTTLE_ASSERT( NULL != pItem->pLRUPrev );
            pItem->pLRUPrev->pLRUNext = pItem->pLRUNext;

            if( pItem == pTail )
            {
                pTail = pItem->pLRUPrev;
                THROTTLE_ASSERT( NULL == pTail->pLRUNext );
            }
            else
            {
                THROTTLE_ASSERT( NULL != pItem->pLRUNext );
                THROTTLE_ASSERT( NULL != pItem->pLRUPrev );
                pItem->pLRUNext->pLRUPrev = pItem->pLRUPrev;
            }

            pItem->pLRUPrev = NULL;
            pItem->pLRUNext = pHead;

            THROTTLE_ASSERT( NULL == pHead->pLRUPrev );
            pHead->pLRUPrev = pItem;
            pHead = pItem;

            THROTTLE_ASSERT( NULL == pHead->pLRUPrev );
            THROTTLE_ASSERT( NULL == pTail->pLRUNext );

#if DBG
            THROTTLE_ASSERT( pHead != pOrigHead );
#endif
        }

#if SANITY_CHECK_LRUS
        SanityCheckEntryLRU();
#endif
    }

#endif

#if SANITY_CHECK_LRUS
    void __forceinline SanityCheckEntryLRU()
    {
        static int iCall = 0;

        if( ( iCall++ % 1000 ) != 0 )
        {
            return;
        }

        IPEntryBlock *pHead = _pEntryLRUHead;
        IPEntryBlock *pTail = _pEntryLRUTail;

        THROTTLE_ASSERT( NULL == pHead->pLRUPrev );
        THROTTLE_ASSERT( NULL == pTail->pLRUNext );

        THROTTLE_ASSERT( NULL != pHead->pLRUNext );
        THROTTLE_ASSERT( NULL != pTail->pLRUPrev );

        int i = 0;
        while( NULL != pHead )
        {
            i++;

            if( pHead == pTail )
            {
                THROTTLE_ASSERT( NULL == pTail->pLRUNext );
                break;
            }

            pHead = pHead->pLRUNext;
        }

        THROTTLE_ASSERT( i == dimensionof( _rgEntryBlocks ) );
    }

    void __forceinline SanityCheckHashLRU()
    {
        static int iCall = 0;

        if( ( iCall++ % 1000 ) != 0 )
        {
            return;
        }

        HashBlock *pHead = _pHashLRUHead;
        HashBlock *pTail = _pHashLRUTail;

        THROTTLE_ASSERT( NULL == pHead->pLRUPrev );
        THROTTLE_ASSERT( NULL == pTail->pLRUNext );

        THROTTLE_ASSERT( NULL != pHead->pLRUNext );
        THROTTLE_ASSERT( NULL != pTail->pLRUPrev );

        int i = 0;
        while( NULL != pHead )
        {
            i++;

            if( pHead == pTail )
            {
                THROTTLE_ASSERT( NULL == pTail->pLRUNext );
                break;
            }

            pHead = pHead->pLRUNext;
        }

        THROTTLE_ASSERT( i == dimensionof( _rgHashBlocks ) );
    }
#endif

protected:
    //////////////////////////////////////////////////////////////////////////////
    //
    // Worker method that maintains the doubly-linked lists and hash table
    //
    EventTrackingStuff *FindOrInsertIP( PerEventStuff *pEvent, DWORD dwIna )
    {
        if( NULL == pEvent->pHash )
        {
            //
            // We need to (re)allocate the oldest hash block
            //
            THROTTLE_ASSERT( NULL != _pHashLRUTail );
            HashBlock *pNewHead = _pHashLRUTail;

            MoveToHead( pNewHead, _pHashLRUHead, _pHashLRUTail );

            WipeHashEntries( pNewHead );

            pEvent->pHash = pNewHead;
            THROTTLE_ASSERT( NULL != pEvent->pHash );
        }

        //
        // Find the hash bucket this IP address belongs in
        //
        DWORD dwHashIndex = ( dwIna % wIPHashSize );

        IPEntryBlock *pEntry = pEvent->pHash->rgpEntries[ dwHashIndex ];
        DWORD cBlocksSeen = 0;

        while( NULL != pEntry )
        {
            cBlocksSeen++;

			int i;
            for( i = 0; i < wNumIPsPerEntryBlock; i++ )
            {
                if( ( dwIna == pEntry->rgEntries[ i ].dwIna ) ||
                    ( 0 == pEntry->rgEntries[ i ].dwIna ) )
                {
                    break;
                }
            }

            if( i < wNumIPsPerEntryBlock )
            {
                //
                // Found matching IP addr or empty slot - either way, store the IP
                //
                pEntry->rgEntries[ i ].dwIna = dwIna;

                //
                // Promote this entry block to the head of the entry block LRU list, and
                // also promote this event's hash block in the hash block LRU list.
                //
                MoveToHead( pEntry, _pEntryLRUHead, _pEntryLRUTail );

                THROTTLE_ASSERT( NULL != pEntry->pHashBlock );
                THROTTLE_ASSERT( pEvent->pHash == pEntry->pHashBlock );
                MoveToHead( pEntry->pHashBlock, _pHashLRUHead, _pHashLRUTail );

                return( &( pEntry->rgEntries[ i ].evt ) );
            }

            //
            // Look in next entry block, if any
            //
            if( NULL == pEntry->pHashNext )
            {
                break;
            }

            pEntry = pEntry->pHashNext;
        }

        //
        // See if this hash chain already contains the maximum number of blocks -
        // if so, remove the first (& presumably oldest) from the chain
        //
        if( cBlocksSeen >= dwMaxChainBlocks )
        {
            IPEntryBlock *pFirstEntry = pEvent->pHash->rgpEntries[ dwHashIndex ];
            THROTTLE_ASSERT( NULL != pFirstEntry );

            RemoveFromHash( pFirstEntry );
        }

        //
        // We need to allocate a new entry block, and attach it to this hash bucket
        //
        THROTTLE_ASSERT( NULL != _pEntryLRUTail );
        IPEntryBlock *pNewBlock = _pEntryLRUTail;

#if SANITY_CHECK_LRUS
        SanityCheckEntryLRU();
#endif

        RemoveFromHash( pNewBlock );

        MoveToHead( pNewBlock, _pEntryLRUHead, _pEntryLRUTail );

        THROTTLE_ASSERT( NULL == pNewBlock->pHashBlock );
        THROTTLE_ASSERT( NULL != pEvent->pHash );
        pNewBlock->pHashBlock = pEvent->pHash;

        if( NULL == pEntry )
        {
            //
            // This hash bucket didn't contain an entry block - add this one
            //
            pEvent->pHash->rgpEntries[ dwHashIndex ] = pNewBlock;
        }
        else
        {
            //
            // pEntry points to the last entry block in the current chain - append
            // the new block to that chain.
            //
            THROTTLE_ASSERT( NULL == pEntry->pHashNext );
            pEntry->pHashNext = pNewBlock;
            pNewBlock->pHashPrev = pEntry;
        }

        //
        // Promote this event's hash block in the hash block LRU list
        //
        THROTTLE_ASSERT( NULL != pEvent->pHash );
        MoveToHead( pEvent->pHash, _pHashLRUHead, _pHashLRUTail );

        pNewBlock->rgEntries[ 0 ].dwIna = dwIna;

        return( &( pNewBlock->rgEntries[ 0 ].evt ) );
    }


    //////////////////////////////////////////////////////////////////////////////
    void RemoveFromHash( IPEntryBlock *pEntry )
    {
        if( NULL == pEntry->pHashBlock )
        {
            //
            // Nothing to do
            //
            THROTTLE_ASSERT( NULL == pEntry->pHashPrev );
            THROTTLE_ASSERT( NULL == pEntry->pHashNext );
            return;
        }

        if( NULL == pEntry->pHashPrev )
        {
            //
            // This entry block is currently the first in a hash bucket chain.
            // We need to set that bucket to point to the next entry block.
            //
            THROTTLE_ASSERT( 0 != pEntry->rgEntries[ 0 ].dwIna );
            DWORD dwHashIndex = ( pEntry->rgEntries[ 0 ].dwIna % wIPHashSize );

            THROTTLE_ASSERT( pEntry->pHashBlock->rgpEntries[ dwHashIndex ] == pEntry );
            pEntry->pHashBlock->rgpEntries[ dwHashIndex ] = pEntry->pHashNext;

            //
            // The new head of the chain has no predecessor
            //
            if( NULL != pEntry->pHashNext )
            {
                THROTTLE_ASSERT( pEntry->pHashNext->pHashPrev == pEntry );
                pEntry->pHashNext->pHashPrev = NULL;
            }
        }
        else
        {
            //
            // Simply pull this entry out of the chain
            //
            pEntry->pHashPrev->pHashNext = pEntry->pHashNext;

            if( NULL != pEntry->pHashNext )
            {
                pEntry->pHashNext->pHashPrev = pEntry->pHashPrev;
            }
        }

        //
        // Wipe out previous entry block state, except for position in entry block LRU chain
        //
        pEntry->pHashBlock = NULL;
        pEntry->pHashPrev = NULL;
        pEntry->pHashNext = NULL;

        memset( pEntry->rgEntries, 0, sizeof( pEntry->rgEntries ) );
    }


    //////////////////////////////////////////////////////////////////////////////
    PerEventStuff* AllocateEntry()
    {
        PerEventStuff* pEntry = NULL;

        if (_iHighWaterIndex < wMaxEntries)
        {
            pEntry = &_rgEvents[_iHighWaterIndex];
            _iHighWaterIndex++;
        }
        
        return pEntry;
    }


    //////////////////////////////////////////////////////////////////////////////
    //
    // Locates an event configuration that matches the event id and, 
    // optionally, the event text 
    //
    //////////////////////////////////////////////////////////////////////////////
    PerEventStuff* FindEntry(WORD wEventId, LPCSTR pszEventText)
    {
        for ( int i = 0; i < _iHighWaterIndex; i++ )
        {
            if ( _rgEvents[ i ].wEventId == wEventId )
            {
                if (_rgEvents[ i ].pszSearchTerms[0] == NULL)
                {
                    // event covers all events of this id, reguardless of text
                    return &_rgEvents[ i ];
                }

                if (pszEventText != NULL)
                {
                    LPCSTR psz = pszEventText;
                    BOOL fFound = TRUE;

                    for (int j = 0; j < MAX_SEARCH_TERMS; j++)
                    {
                        if (_rgEvents[i].pszSearchTerms[j] == NULL)
                        {
                            // no more terms
                            break;
                        }

                        psz = strstr(psz, _rgEvents[i].pszSearchTerms[j]);
                        if (psz == NULL)
                        {
                            fFound = FALSE;
                            break;
                        }

                        // advance to the end of the string for the next search
                        psz += strlen(_rgEvents[i].pszSearchTerms[j]);
                    }

                    if (fFound)
                    {
                        return &_rgEvents[i];
                    }
                }
                
            }
        }

        return NULL;
    }
    
    //////////////////////////////////////////////////////////////////////////////
    void WipeHashEntries( HashBlock *pHash )
    {
        for( int i = 0; i < wIPHashSize; i++ )
        {
            IPEntryBlock *pEntry = pHash->rgpEntries[ i ];

            while( NULL != pEntry )
            {
                IPEntryBlock *pBlockToClear = pEntry;
                pEntry = pEntry->pHashNext;

                pBlockToClear->pHashPrev = NULL;
                pBlockToClear->pHashNext = NULL;
                pBlockToClear->pHashBlock = NULL;
            }
        }

        memset( pHash->rgpEntries, 0, sizeof( pHash->rgpEntries ) );
    }

    

    //////////////////////////////////////////////////////////////////////////////
    void WipeEvent( PerEventStuff *pEvent )
    {
        if( NULL != pEvent->pHash )
        {
            WipeHashEntries( pEvent->pHash );
        }

        memset( pEvent, 0, sizeof( *pEvent ) );
    }

    //////////////////////////////////////////////////////////////////////////////
    void WipeAllState()
    {
        memset( this, 0, sizeof( *this ) );

        //
        // Initialize entry block LRU linked list
        //
        _pEntryLRUHead = &_rgEntryBlocks[ 0 ];
        _pEntryLRUTail = &_rgEntryBlocks[ dimensionof( _rgEntryBlocks ) - 1 ];

        for( int i = 0; i < dimensionof( _rgEntryBlocks ); i++ )
        {
            if( i < dimensionof( _rgEntryBlocks ) - 1 )
            {
                _rgEntryBlocks[ i ].pLRUNext = &_rgEntryBlocks[ i + 1 ];
            }
            if( i > 0 )
            {
                _rgEntryBlocks[ i ].pLRUPrev = &_rgEntryBlocks[ i - 1 ];
            }
        }

#if SANITY_CHECK_LRUS
        SanityCheckEntryLRU();
#endif

        //
        // Initialize hash block LRU linked list
        //
        _pHashLRUHead = &_rgHashBlocks[ 0 ];
        _pHashLRUTail = &_rgHashBlocks[ dimensionof( _rgHashBlocks ) - 1 ];

        for( int i = 0; i < dimensionof( _rgHashBlocks ); i++ )
        {
            if( i < dimensionof( _rgHashBlocks ) - 1 )
            {
                _rgHashBlocks[ i ].pLRUNext = &_rgHashBlocks[ i + 1 ];
            }
            if( i > 0 )
            {
                _rgHashBlocks[ i ].pLRUPrev = &_rgHashBlocks[ i - 1 ];
            }
        }

#if SANITY_CHECK_LRUS
        SanityCheckHashLRU();
#endif
    }

private:
    //////////////////////////////////////////////////////////////////////////////
    //
    // IMPORTANT: these structure sizes were designed to align well with CPU cache lines.
    //            Do not change them without a really good reason.
    //
#pragma pack( push, 1 )

    struct EventTrackingStuff           // sizeof() == 32
    {
        QWORD qwLastTime;
        QWORD qwFirstTimeThisSec;
        DWORD dwNumSkips;
        DWORD dwNumSkipsTotal;
        DWORD dwUnitsLastSec;
        DWORD dwUnitsThisSec;
    };

    struct PerIPStuff                   // sizeof() == 32 + 4 == 36
    {
        EventTrackingStuff evt;
        DWORD dwIna;
    };

    const static WORD wNumIPsPerEntryBlock = 3;

    struct IPEntryBlock                 // sizeof() == ( 4 * 5 ) + ( 36 * 3 ) == 128
    {
        //
        // LRU list pointers
        //
        IPEntryBlock *pLRUPrev;
        IPEntryBlock *pLRUNext;

        //
        // Hash chain list pointers
        //
        IPEntryBlock *pHashPrev;
        IPEntryBlock *pHashNext;

        HashBlock *pHashBlock;

        PerIPStuff rgEntries[ wNumIPsPerEntryBlock ];
    };

    struct HashBlock                    // sizeof() == ( 4 * ( wIPHashSize + 2 ) ) rounded up % 16
    {
        HashBlock *pLRUPrev;
        HashBlock *pLRUNext;

        IPEntryBlock *rgpEntries[ wIPHashSize ];

        void *pvReserved[ 4 - ( ( wIPHashSize + 2 ) % 4 ) ];    // this works if wIPHashSize is odd
    };

    struct PerEventStuff                // sizeof() == 2 + 2 + 76 + 32 + 8 + 4 + 4 == 128
    {
        WORD wEventId;        
        char szSearchText[MAX_SEARCH_TEXT_LEN];
        char* pszSearchTerms[MAX_SEARCH_TERMS];

        EventTrackingStuff evt;

        QWORD hnsEventInterval;         // Interval between allowed events in 100-nanosecond units

        struct _Flags
        {
            DWORD fSometimesOn       : 1;   // Sometimes block it, according to rates and stuff
            DWORD fNeverOn           : 1;   // Block it, don't track anything
            DWORD fRateUnitsAreBytes : 1;   // Is dwAlertUnitsPerSec in events/packets or bytes
            DWORD fTrackPerIP        : 1;   // Should state be tracked per event source IP address
            DWORD dwAlertUnitsPerSec : 28;  // either events/packets or bytes, depending on fRateUnitsAreBytes

        } Flags;

        HashBlock *pHash;               // Room for hash table if IP tracking is enabled
    };

#pragma pack( pop )

    PerEventStuff _rgEvents[ wMaxEntries ];
    int _iHighWaterIndex;

    IPEntryBlock _rgEntryBlocks[ ( dwEntryBlockPoolSize + sizeof( IPEntryBlock ) - 1 ) / sizeof( IPEntryBlock ) ];
    HashBlock _rgHashBlocks[ ( dwHashBlockPoolSize + sizeof( HashBlock ) - 1 ) / sizeof( HashBlock ) ];

    IPEntryBlock *_pEntryLRUHead;
    IPEntryBlock *_pEntryLRUTail;

    HashBlock *_pHashLRUHead;
    HashBlock *_pHashLRUTail;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmlsequencer\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\i386\xomcapctx.asm ===
title  "Capture Context"

;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    xomcapctx.asm
;
; Abstract:
;
;    This module implements a routine that captures the current execution context.
;
; Author:
;
;    David N. Cutler (davec) 14-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   6 April 90  bryanwi
;
;           386 version created
;
;   21 March 02  mcourage
;
;           Xbox Online version created
;--

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

XNET    SEGMENT DWORD PUBLIC 'CODE'

;++
;
; VOID
; XomCaptureContext (PCONTEXT ContextRecord)
;
; Routine Description:
;
;   This fucntion fills in the specified context record with the
;   current state of the machine, except that the values of EBP
;   and ESP are computed to be those of the caller's caller.
;
;   N.B.  This function assumes it is called from a 'C' procedure with
;         the old ebp at [ebp], the return address at [ebp+4], and
;         old esp = ebp + 8.
;
;         Certain 'C' optimizations may cause this to not be true.
;
;   N.B.  This function does NOT adjust ESP to pop the arguments off
;         the caller's stack.  In other words, it provides a __cdecl ESP,
;         NOT a __stdcall ESP.  This is mainly because we can't figure
;         out how many arguments the caller takes.
;
;   N.B.  Floating point state is NOT captured.
;
;   RtlCaptureContext captures volitales.
;
; Arguments:
;
;    ContextRecord  (esp+4) - Address of context record to fill in.
;
; Return Value:
;
;    The caller's return address.
;
;--

cPublicProc _XomCaptureContext ,1

        push    ebx
        mov     ebx,[esp+8]         ; (ebx) -> ContextRecord

        mov     dword ptr [ebx.CsEax],eax
        mov     dword ptr [ebx.CsEcx],ecx
        mov     dword ptr [ebx.CsEdx],edx
        mov     eax, [esp]
        mov     dword ptr [ebx.CsEbx],eax

        mov     dword ptr [ebx.CsEsi],esi
        mov     dword ptr [ebx.CsEdi],edi

        mov     [ebx.CsSegCs],cs
        mov     [ebx.CsSegDs],ds
        mov     [ebx.CsSegEs],es
        mov     [ebx.CsSegFs],fs
        mov     [ebx.CsSegGs],gs
        mov     [ebx.CsSegSs],ss

        pushfd
        pop     [ebx.CsEflags]

        mov     eax,[ebp+4]
        mov     [ebx.CsEip],eax

        mov     eax,[ebp]
        mov     [ebx.CsEbp],eax

        lea     eax,[ebp+8]
        mov     [ebx.CsEsp],eax

        pop     ebx
        stdRET    _XomCaptureContext
        
stdENDP _XomCaptureContext
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmgmtlib\inc\xmgmt.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

  xmgmt.h

Abstract:

  This is the main file of the xbox online management framework and should be
  all you need to include in your file.

--*/

#ifndef _XMGMT_H_
#define _XMGMT_H_

#pragma once

#include <Oaidl.h>
#include <commonconfig.h>
#include <wsockntp.h>
#include <xonlinep.h>
#include "..\xomcmmon.h"

// Forward declarations
namespace XblConfig { struct IConfig; };

//
// This is the externally used portion of the management framework and shouldn't
// require unnecessary dependencies to be pulled in.
//

//
// Forward declarations to avoid pulling in dependencies
//
class CCompletionPort;
namespace xlocks { class CReaderWriterLock3; };
class CXomControl;
class CXomControlCallback;
class CXomControlResponseInterface;
class CXomLoggingControl;
class CXomSettings;
class CXomSetting;
class CXomTargetBase;


///////////////////////////////////////////////////////////////////////////////
//
// CXomCentral
//
// That's the main class of the management framework. Don't instantiate objects
// of this class directly. Instead, use the global instance g_xomcentral
// declared below.
//
///////////////////////////////////////////////////////////////////////////////

class CXOMCentral
{
public:

    CXOMCentral();
    ~CXOMCentral();

    HRESULT Init( LPCSTR pszSource, LPCSTR pszIni, LPCSTR pszComponentName );
    HRESULT Init( LPCSTR pszSource, LPCSTR pszIni );
    HRESULT Init( LPCSTR pszSource );
    HRESULT Term();

    //
    // Settings framework
    //
    HRESULT GetSetting( CComBSTR enumSetting, OUT LPSTR* pszSetting );
    HRESULT GetSetting( LPCSTR pszName, OUT CXomSetting** ppSetting );
    HRESULT GetMultiSetting( CComBSTR enumSetting, OUT SAFEARRAY **ppsaSetting );

    //
    // Remote admin framework
    //
    HRESULT RegisterControlCallback( CXomControlCallback* pCallback );
    HRESULT UnregisterControlCallback( CXomControlCallback* pCallback );
    LPCSTR GetProcessName();
    LPCSTR GetComponentName();

    XblConfig::IConfig* GetConfigPtr() { return m_pConfig; }
    //
    // Logging framework
    //
    BOOL CheckOverrideList( LPCSTR pszFile, DWORD dwLine, BOOL* pfLog );

private:
    CCompletionPort* m_pIOCP;
    CXomSettings* m_pSettings;
    CXomControl* m_pControl;
    CXomLoggingControl* m_pLogging;
    XblConfig::IConfig *m_pConfig;

};

//
// g_xomcentral
//
// This is the global instance of CXomCentral. Macros and other modules refer
// to this object.
//
extern CXOMCentral g_xomcentral;

///////////////////////////////////////////////////////////////////////////////
//
// Control callback definition
//
///////////////////////////////////////////////////////////////////////////////

//
// CXomControlCallback - your component can define this and call g_xomCentral.RegisterControlCallback
//     to be notified of control commands.
//
class CXomControlCallback
{
public:

    virtual ULONG __stdcall AddRef() = 0;
    virtual ULONG __stdcall Release() = 0;
    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface ) = 0;
};

//
// CXomControlResponseInterface - interface used in your OnControlRequest callback
//     handler to respond to the command.
//
class CXomControlResponseInterface
{
public:
    virtual HRESULT WriteResponse( DWORD dwRequestId, BYTE* pBuffer, DWORD cbBuffer) = 0;
};

// Helper function to write formatted responses
HRESULT XomWriteFormattedResponse( CXomControlResponseInterface* pResponseInterface, DWORD dwRequestId, const char* pszFmt, ... );


///////////////////////////////////////////////////////////////////////////////
//
// Settings defition
//
///////////////////////////////////////////////////////////////////////////////

//
// CXomOption - an individual option for a setting
//
class CXomOption
{
public:
    enum setting_type_t
    {
        T_EMPTY = 0,
        T_DWORD,
        T_POINTER,
        T_STR,
        T_WSTR
    };

    struct setting_t
    {
        DWORD dwId;
        setting_type_t eType;

        union
        {
            DWORD dwData;
            void* pData;
            LPCSTR pszData;
            LPCWSTR pwszData;
        };
    };

    CXomOption( DWORD dwId, DWORD dwData );
    CXomOption( DWORD dwId, void* pData );
    CXomOption( DWORD dwId, LPCSTR pszData );
    CXomOption( DWORD dwId, LPCWSTR pwszData );
    CXomOption operator+ ( CXomOption& ob );

    DWORD GetSettingCount() { return m_cSettings; }
    setting_t* GetSetting(DWORD nSetting) { return &m_rgSettings[nSetting]; }

protected:
    const static unsigned int c_xomMaxSettings = 256;

    CXomOption();

    setting_t m_rgSettings[ c_xomMaxSettings ];
    DWORD m_cSettings;
};

//
// CXomSetting - defines a single setting value
//
class CXomSetting
{
public:
    enum OPTION
    {
        O_NAME,
        O_DEFAULT,
        O_MAX,
        O_MIN
    };

    CXomSetting( CXomOption& op );
    virtual ~CXomSetting();

    ULONG AddRef() { return (ULONG) InterlockedIncrement( &m_lRefCount ); }
    ULONG Release() { LONG lCount = InterlockedDecrement( &m_lRefCount ); if( 0 == lCount ) { delete this; } return (ULONG) lCount; }

    LPCSTR GetName() const { return m_szSettingName; }
    LPCSTR GetStr() const { return m_d.pszData; }
    LPCWSTR GetWStr() const { return m_d.pwszData; }
    DWORD GetDw() const { return m_d.dwData; }
    HRESULT GetStatus() const { return m_hrResult; }

    HRESULT SetDw( DWORD dwNewValue );
    HRESULT SetStr( LPCSTR pszNewValue );
    HRESULT SetWStr( LPCWSTR pwszNewValue );

    const static unsigned int c_xomMaxSettingName = 256;

protected:
    void Init( CXomOption& op );
    void Reset();

    // Contains the health status of this setting. If it's invalid, it will
    // contain an error.
    HRESULT m_hrResult;

    struct
    {
        LPCSTR pszData;   // Ansi string data
        LPCWSTR pwszData; // Unicode string data
        DWORD dwData;     // DWORD data

    } m_d; // Setting data

    LONG m_lRefCount;
    DWORD m_dwMin;     // Minimum value allowed (only for DWORD type).
    DWORD m_dwMax;     // Maximum value allowed (only for DWORD type).
    bool m_fMandatory; // If the setting is mandatory, it must be in the INI file otherwise initialization will fail.
    bool m_fSet;       // Has the value been set?
    char m_szSettingName[c_xomMaxSettingName]; // Name of the setting, used to match the setting names in the INI file.
};

//
// CXomSettingEx
//
// This is an enhanced version of CXomSetting.
// Its constructor will register the setting automatically with the
// global g_xomcentral object.
//
// Declare objects of this class globally or statically or anything that
// initializes when the module loads (before calling g_xomcentral.Init)
// and you should be all set.
//
class CXomSettingEx : public CXomSetting
{
    friend CXomSettings;
public:

    CXomSettingEx( CXomOption& op );

protected:
    const static unsigned int c_xomMaxSettings = 512;

    static CXomSetting* s_rgSettings[c_xomMaxSettings];
    static DWORD s_dwSettingCount;
};


///////////////////////////////////////////////////////////////////////////////
//
// Log area definition
//
///////////////////////////////////////////////////////////////////////////////

class CXomLogArea
{
private:
    void LogInternal(CLogFormatedMessage &oMsg, WORD wId, WORD wPacketSize, DWORD *pina);
public:
    CXomLogArea( const char* pszAreaName, CComBSTR enumAreaSetting );
    ~CXomLogArea();

    const char* GetName() const { return m_pszAreaName; }
    CComBSTR GetAreaSetting() const { return m_enumAreaSetting; }
    char GetFilterLevel() const { return m_chLevel; }
    DWORD GetTargetCount() const { return m_cTargets; }

    void RegisterArea();
    void Terminate();

    void LockTargetList();
    void UnlockTargetList();
    HRESULT AddTarget( CXomTargetBase* pTarget );
    void RemoveTarget( CXomTargetBase* pTarget );
    CXomTargetBase* GetTarget(DWORD nTarget) { XOMASSERT(nTarget < m_cTargets); return m_rgTargets[nTarget]; }

    BOOL CanLog( char chLevel, LPCSTR pszName, DWORD dwLine, DWORD* pdwCanLog );
    void Log( char chLevel, const FLOKEN& flowToken, DWORD* pdwCanLog, LPCSTR pszName, DWORD dwLine, WORD wId, WORD wPacketSize, DWORD *pina, LPCSTR pszPreMsg, LPCSTR pszFmt, ... );

    void SetFilterLevel(char chLevel) { m_chLevel = chLevel; }
    void SetIsEventLog() { m_fIsTheEventLog = TRUE; }

protected:
    const static int c_xomMaxTargets = 16;

    BOOL m_fIsTheEventLog;
    const char* m_pszAreaName;
    CComBSTR m_enumAreaSetting;
    CXomTargetBase* m_rgTargets[ c_xomMaxTargets ];
    DWORD m_cTargets;
    DWORD m_cFilterTargets;
    xlocks::CReaderWriterLock3* m_pLockTargets;
    char m_chLevel;
};

#define XomAreaObjDecoration(area) g_xomArea_##area
#define XomAreaObjSetting(area) Setting_xmgmt_area_##area
#define XomDefineArea(area) CXomLogArea XomAreaObjDecoration(area)(#area,XomAreaObjSetting(area))
#define XomImportArea(area) extern CXomLogArea XomAreaObjDecoration(area)

// Import default logging area - used by XomNtEvent and XomNtDataEvent macros
XomImportArea(DefaultNtLog);

///////////////////////////////////////////////////////////////////////////////
//
// Logging macros
//
///////////////////////////////////////////////////////////////////////////////

//
// Persistent text file logging
//
#define XomLog(area, ...) \
    XomLogEx(area, L_NORMAL, 0, 0, NULL, NULL, __VA_ARGS__)

#define XomLogFT(area, flowToken, ...) \
    XomLogExFT(area, L_NORMAL, flowToken, 0, 0, NULL, NULL, __VA_ARGS__)

//
// General diagnostic tracing
//

#define XomTrace(area, lvl, ...) \
    XomLogEx(area, lvl, 0, 0, NULL, NULL, __VA_ARGS__)

#define XomTraceFT(area, lvl, flowToken, ...) \
    XomLogExFT(area, lvl, flowToken, 0, 0, NULL, NULL, __VA_ARGS__)

//
// NT Event logging w/ variable message
//
#define XomMakeLineStr2(x) #x
#define XomMakeLineStr(line) XomMakeLineStr2(line)

#define XomNtEvent(id, ...) \
    XomLogEx(DefaultNtLog, (CHAR)( id / 0x40000000 ), (WORD)( id & 0xffff ), 0, NULL, NULL, __FILE__ ":" XomMakeLineStr(__LINE__) "\r\n\r\n" __VA_ARGS__)

#define XomNtEventFT(id, flowToken, ...) \
    XomLogExFT(DefaultNtLog, (CHAR)( id / 0x40000000 ), flowToken, (WORD)( id & 0xffff ), 0, NULL, NULL, __FILE__ ":" XomMakeLineStr(__LINE__) "\r\n\r\n" __VA_ARGS__)


//////////////////////////////////////////////////////////////////////////////
//
// Private implementation details - don't look behind the curtain
//
//////////////////////////////////////////////////////////////////////////////

extern DWORD g_dwLastChangeSignature;

//
// Generic logging base macros - don't use these
//

#define XomLogEx(area,lvl,id,pkt,pina,preMsg,...) \
    do \
    { \
        static DWORD dwCanLog = 0; \
        if( dwCanLog == g_dwLastChangeSignature ) \
        { \
            break; \
        } \
        FLOKEN NoFloken = { 0 }; \
        XomAreaObjDecoration(area).Log(lvl,NoFloken,&dwCanLog,__FILE__,__LINE__, id, pkt, (DWORD *)pina,\
            preMsg, __VA_ARGS__); \
    } while (0)

#define XomLogExFT(area,lvl,flowToken,id,pkt,pina,preMsg,...) \
    do \
    { \
        static DWORD dwCanLog = 0; \
        if( dwCanLog == g_dwLastChangeSignature ) \
        { \
            break; \
        } \
        XomAreaObjDecoration(area).Log(lvl,flowToken,&dwCanLog,__FILE__,__LINE__, id, pkt, (DWORD *)pina,\
            preMsg, __VA_ARGS__); \
    } while (0)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmlsequencer\ElementTypeMapping.cs ===
using System;
using System.Collections;

namespace xonline.common.xmlsequencer
{
    /// <summary>
    /// 
    /// </summary>
	public class ElementTypeMapping : DictionaryBase  
	{
        /// <summary>
        /// 
        /// </summary>
        public System.Type this[ String key ]  
		{
			get  
			{
				return( (System.Type) Dictionary[key] );
			}
			set  
			{
				Dictionary[key] = value;
			}
		}

        /// <summary>
        /// 
        /// </summary>
		public ICollection Keys  
		{
			get  
			{
				return( Dictionary.Keys );
			}
		}

        /// <summary>
        /// 
        /// </summary>
		public ICollection Values  
		{
			get  
			{
				return( Dictionary.Values );
			}
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="key"></param>
        /// <param name="value"></param>
		public void Add( String key, System.Type value )  
		{
			Dictionary.Add( key, value );
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
		public bool Contains( String key )  
		{
			return( Dictionary.Contains( key ) );
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="key"></param>
		public void Remove( String key )  
		{
			Dictionary.Remove( key );
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="key"></param>
        /// <param name="value"></param>
		protected override void OnValidate( Object key, Object value )  
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}

			if ( key.GetType() != Type.GetType("System.String") )
			{
				throw new ArgumentException( "key must be of type String.", "key" );
			}

			if (value == null)
			{
				throw new ArgumentNullException("value");
			}

			System.Type testType = Type.GetType("System.Type");
			if ( !testType.IsAssignableFrom(value.GetType()))
			{
				throw new ArgumentException( "value must be of type System.Type.", "value" );
			}

			testType = Type.GetType("xonline.common.xmlsequencer.Step");
			if (!testType.IsAssignableFrom((System.Type) value))
			{
				throw new ArgumentException( "The type passed must be derrived from xonline.common.xmlsequencer.Step.", "value" );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmlsequencer\InMemoryMessageLog.cs ===
using System;
using System.Collections;

namespace xonline.common.xmlsequencer
{
    /// <summary>
    /// Provides a MessageLog helper class that stores XmlSequencer generated messages to an
    /// ArrayList.
    /// </summary>
    public class InMemoryMessageLog
    {
        private RootStepContainer rootContext = null;

        /// <summary>
        /// The array of messages that have been captured.
        /// </summary>
        public ArrayList Messages = new ArrayList();

        private void myRoot_OnMessage(object sender, MessageEventArgs e)
        {
            Messages.Add(e.Message);
        }

        /// <summary>
        /// Connects the MessageLog to the passed RootStepContainer and starts
        /// the collecting of messages. Any current messages will be discarded.
        /// </summary>
        /// <param name="root">The RootStepContainer to start collecting messages from.</param>
        public void StartListening(RootStepContainer root)
        {
            if (rootContext != null)
            {
                StopListening();
            }

            rootContext = root;

            Messages.Clear();
            rootContext.OnMessage += new MessageEventHandler(myRoot_OnMessage);
        }

        /// <summary>
        /// Stops this message log from collecting any more messages from the current source.
        /// </summary>
        public void StopListening()
        {
            if (rootContext != null)
            {
                rootContext.OnMessage -= new MessageEventHandler(myRoot_OnMessage);
            }
            
            rootContext = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmlsequencer\RootStepContainer.cs ===
using System;
using System.Xml;
using System.Reflection;

namespace xonline.common.xmlsequencer
{
	/// <summary>
	/// Represents the root of a StepContainer/Step hierarchy.
	/// </summary>
	/// <remarks>
	/// This class defines the root of a StepContainer/Step object hierarchy. In addition to
	/// implementing a StepContainer, it provides the following additional functionality.
	/// <list type="bullet">
	/// <item><description>
	/// Provides a method that other Steps and StepContainers can use to send text messages 
	/// to subscribing objects through the root <c>Message</c> event.
	/// </description></item>
	/// <item><description>
	/// Provides a mechanism to map XML element names to the .NET types that will be instantiated
	/// when the named XML element is encountered when processing the XML.
	/// </description></item>
	/// </list>
	/// </remarks>
	public class RootStepContainer : StepContainer
	{
        private XmlNamespaceManager namespaceManager = null;
        private ElementTypeMapping typeMap = new ElementTypeMapping();


		/// <summary>
		/// 
		/// </summary>
		/// <param name="rootStepElement"></param>
		public RootStepContainer(XmlElement rootStepElement) : base(rootStepElement)
		{
            if (BaseXmlElement.NamespaceURI != Namespace)
            {
                throw new InvalidOperationException(BaseXmlElement.Name + " element must belong to the " + Namespace + " namespace.");
            }

            InitializeTypeMap();
        }

        private void InitializeTypeMap()
        {
            TypeMap.Clear();
            
            Assembly assembly = Assembly.GetExecutingAssembly();
            Type[] allTypes = assembly.GetExportedTypes();

            foreach (Type type in allTypes)
            {
                if (type.IsSubclassOf(typeof(Step)) || (type == typeof(Step)))
                {
                    object[] attributes = type.GetCustomAttributes(false);

                    foreach (object attribute in attributes)
                    {
                        StepElementAttribute stepElement = attribute as StepElementAttribute;

                        if ((stepElement != null) && (stepElement.ElementName.Length > 0))
                        {
                            TypeMap.Add(stepElement.ElementName, type);
                        }

                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public virtual string Namespace
        {
            get {return "http://www.xbox.com/xmlsequencer.xsd";}
        }
        
        /// <summary>
        /// 
        /// </summary>
        public XmlNamespaceManager NamespaceManager
        {
            get
            {
                if (namespaceManager == null)
                {
                    namespaceManager = new XmlNamespaceManager(BaseXmlElement.OwnerDocument.NameTable);
                    namespaceManager.AddNamespace("sequencens", this.Namespace);
                    namespaceManager.PushScope();
                }

                return namespaceManager;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public ElementTypeMapping TypeMap
		{
			get {return typeMap;}
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public void LogMessage(string message)
		{
			MessageEventArgs e = new MessageEventArgs(message);
			OnMessageNotifier(e);
		}

        /// <summary>
        /// 
        /// </summary>
		public event MessageEventHandler OnMessage;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
		protected virtual void OnMessageNotifier(MessageEventArgs e)
		{
			if (OnMessage != null) 
			{
				// Invokes the delegates. 
				OnMessage(this, e);
			}
		}
	}

    /// <summary>
    /// 
    /// </summary>
	public delegate void MessageEventHandler(object sender, MessageEventArgs e);

    /// <summary>
    /// 
    /// </summary>
	public class MessageEventArgs : EventArgs
	{
        private string message = "";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
		public MessageEventArgs(string message)
		{
			Message = message;
		}

        /// <summary>
        /// 
        /// </summary>
		public string Message
		{
			get {return message;}
			set
			{
				if (value == null)
				{
					message = "";
				}
				else
				{
					message = value;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmlsequencer\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xmlsequencer_2_none_12.4.56.0_none_f60a67ed0b2c7df8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xmlsequencer_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762.manifest
XP_MANIFEST_PATH=manifests\x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762.cat
XP_CATALOG_PATH=manifests\x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762.cat
XP_PAYLOAD_PATH=x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xmlsequencer_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmlsequencer\ConfigurationTransform.cs ===
using System;
using System.Xml;
using System.Text;
using System.Reflection;
using System.Data.SqlClient;
using System.Text.RegularExpressions;
using System.Collections.Specialized;

using xonline.common.config;

namespace xonline.common.xmlsequencer 
{

    /// <summary>
    /// Summary description for ConfigurationTransform.
    /// </summary>
    public class ConfigurationTransform 
    {
        private NameValueCollection overrideVariableCollection = new NameValueCollection();

        /// <summary>
        /// 
        /// </summary>
        public NameValueCollection OverrideVariableCollection 
        {
            get {return overrideVariableCollection;}
        }

        /// <summary>
        /// 
        /// </summary>
        static public string Namespace 
        {
            get {return "http://www.xbox.com/configurationTransform.xsd";}
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xmlDoc"></param>
        public void TransformDocument(XmlDocument xmlDoc) 
        {
            if (xmlDoc == null) 
            {
                throw new ArgumentNullException("xmlDoc");
            }

            XmlNamespaceManager namespaceManager = new XmlNamespaceManager(xmlDoc.NameTable);
            namespaceManager.AddNamespace("configurationTransform", Namespace);
            namespaceManager.PushScope();

            TransformElements(xmlDoc.DocumentElement, namespaceManager);
        }

        private void TransformElements(XmlElement currentElement, XmlNamespaceManager namespaceManager) 
        {
            while (true) 
            {
                XmlElement nextElement = (XmlElement) currentElement.SelectSingleNode("descendant::configurationTransform:*", namespaceManager);

                if (nextElement == null) 
                {
                    break;
                }

                TransformElements(nextElement, namespaceManager);
            }

            if (currentElement.NamespaceURI == Namespace) 
            {
                TransformElement(currentElement);
            }
        }
        
        private void TransformElement(XmlElement currentElement) 
        {
            switch (currentElement.LocalName.ToLower()) 
            {
                case "inline":
                    ProcessInlineTransform(currentElement);
                    break;

                case "setattribute":
                    ProcessSetAttributeTransform(currentElement);
                    break;

                case "includeifmatches":
                    ProcessIncludeIfMatchesTransform(currentElement);
                    break;

                default:
                    throw new InvalidOperationException("Unknown element " + currentElement.Name + " specified in the '" + Namespace + "' namespace.");
            }
        }

        private void ProcessInlineTransform(XmlElement currentElement) 
        {
            string newValue = GetConfigurationValue(currentElement);

            XmlText textNode = currentElement.OwnerDocument.CreateTextNode(newValue);
            currentElement.ParentNode.InsertBefore(textNode, currentElement);
            currentElement.ParentNode.RemoveChild(currentElement);
        }

        private void ProcessSetAttributeTransform(XmlElement currentElement) 
        {
            string name = currentElement.GetAttribute("name");
            if (name.Length == 0) 
            {
                throw new InvalidOperationException("Required attribute 'name' not specified in <setAttribute> element.");
            }

            ((XmlElement) currentElement.ParentNode).SetAttribute(name, currentElement.InnerText);
            currentElement.ParentNode.RemoveChild(currentElement);
        }

        private void ProcessIncludeIfMatchesTransform(XmlElement currentElement) 
        {
            string pattern = currentElement.GetAttribute("pattern");
            if (pattern.Length == 0) 
            {
                throw new InvalidOperationException("Required attribute 'pattern' not specified in <includeIfMatches> element.");
            }

            string value = GetConfigurationValue(currentElement);
            Regex conditional = new Regex(pattern, RegexOptions.IgnoreCase);

            if (conditional.IsMatch(value)) 
            {
                while (currentElement.ChildNodes.Count > 0) 
                {
                    XmlNode firstChild = currentElement.FirstChild;
                    currentElement.RemoveChild(firstChild);
                    currentElement.ParentNode.InsertBefore(firstChild, currentElement);
                }
            }

            currentElement.ParentNode.RemoveChild(currentElement);
        }

        private string GetConfigurationValue(XmlElement configurationElement) 
        {
            string name = configurationElement.GetAttribute("name");
            if (name.Length == 0) 
            {
                throw new InvalidOperationException("Required attribute 'name' not specified in <" + configurationElement.Name + "> element.");
            }

            string type = configurationElement.GetAttribute("type");
            if (type.Length == 0) 
            {
                throw new ArgumentException("Required attribute 'type' not specified in <" + configurationElement.Name + "> element.");
            }

            string value = OverrideVariableCollection.Get(name);

            if (value != null) 
            {
                return value;
            }

            switch (type.ToLower()) 
            {
                case "env":
                    value = Environment.GetEnvironmentVariable(name);

                    if (value == null) 
                    {
                        throw new ArgumentException("No environment variable named '" + name + "' is defined.", "name");
                    }

                    return value;
                    
                case "config.setting":
                    string setting = name;
                    return Config.GetSetting(setting);
                    
                case "config.component":
                    return GetComponentInformation(name, configurationElement);

                case "config.interface":
                    return GetInterfaceInformation(name, configurationElement);

                case "config.virtualinterface":
                    return GetVirtualInterfaceInformation(name, configurationElement);

                case "config.environment":
                    return Config.Environment;

                default:
                    throw new ArgumentException("'" + type + "' is not a valid type for a configuration transform.", "type");        
            }
        }

        public string GetComponentInformation(string propertyName, XmlElement configurationElement) 
        {
            string componentName = configurationElement.GetAttribute("component");
            if (componentName.Length == 0) 
            {
                throw new ArgumentException("Required attribute 'component' not specified in <" + configurationElement.Name + "> element.");
            }

            string component = componentName;
            IComponentInfo componentInfo = Config.GetComponent(component);

            switch (propertyName.ToLower())
            {
                case "executable":
                    if (componentInfo.Executable == null)
                    {
                        throw new InvalidOperationException("No value for property 'executable' specified for component '" + componentName + "'.");
                    }
                    return componentInfo.Executable;

                case "username":
                    if (componentInfo.Username == null)
                    {
                        throw new InvalidOperationException("No value for property 'username' specified for component '" + componentName + "'.");
                    }

                    // transform any %COMPUTERNAME% tokens in the username field to be the current machine name.
                    // this allows us to use local machine accounts, changing the username to always reference
                    // the local instance of the account.
                    return componentInfo.Username.Replace("%COMPUTERNAME%", Environment.MachineName);

                case "password":
                    if (componentInfo.Password == null)
                    {
                        throw new InvalidOperationException("No value for property 'password' specified for component '" + componentName + "'.");
                    }
                    return ResolvePassword(componentInfo.Password);

                case "info1":
                    if (componentInfo.Info1 == null)
                    {
                        throw new InvalidOperationException("No value for property 'info1' specified for component '" + componentName + "'.");
                    }
                    return componentInfo.Info1;

                case "info2":
                    if (componentInfo.Info2 == null)
                    {
                        throw new InvalidOperationException("No value for property 'info2' specified for component '" + componentName + "'.");
                    }
                    return componentInfo.Info2;
            }

            throw new ArgumentException("No component property name '" + propertyName + "' is available.");
        }

        public string GetInterfaceInformation(string propertyName, XmlElement configurationElement) 
        {
            string interfaceName = configurationElement.GetAttribute("interface");
            if (interfaceName.Length == 0) 
            {
                throw new ArgumentException("Required attribute 'interface' not specified in <" + configurationElement.Name + "> element.");
            }

            string computerName = configurationElement.GetAttribute("computer");
            if (computerName.Length == 0)
            {
                computerName = Environment.MachineName;
            }

            IInterfaceInfo interfaceInfo = null;
            
            if (computerName.ToLower() == "single")
            {
                interfaceInfo = Config.GetSingleInterface(interfaceName);
            }
            else
            {
                interfaceInfo = Config.GetInterface(computerName, interfaceName);
            }
            
            PropertyInfo requestedProperty = (typeof(IInterfaceInfo)).GetProperty(propertyName);
 
            if (requestedProperty == null)
            {
                throw new ArgumentException("No interface property name '" + propertyName + "' is available.");
            }

            string propertyValue;
            try
            {
                propertyValue = requestedProperty.GetValue(interfaceInfo, null).ToString();
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Error reading property " + propertyName + " from interface " + interfaceName, ex);
            }

            if (String.Compare(propertyName, "username", true) == 0)
            {
                // transform any %COMPUTERNAME% tokens in the username field to be the current machine name.
                // this allows us to use local machine accounts, changing the username to always reference
                // the local instance of the account.
                propertyValue = propertyValue.Replace("%COMPUTERNAME%", Environment.MachineName);
            }

            return propertyValue;
        }

        public string GetVirtualInterfaceInformation(string propertyName, XmlElement configurationElement) 
        {
            string interfaceName = configurationElement.GetAttribute("virtualInterface");
            if (interfaceName.Length == 0) 
            {
                throw new ArgumentException("Required attribute 'virtualInterface' not specified in <" + configurationElement.Name + "> element.");
            }

            string interfaceType = interfaceName;
            IVirtualInterfaceInfo interfaceInfo = null;            
            interfaceInfo = Config.GetVirtualInterface(interfaceType);
            
            PropertyInfo requestedProperty = (typeof(IVirtualInterfaceInfo)).GetProperty(propertyName);
 
            if (requestedProperty == null)
            {
                throw new ArgumentException("No virtual interface property name '" + propertyName + "' is available.");
            }

            string propertyValue;
            try
            {
                propertyValue = requestedProperty.GetValue(interfaceInfo, null).ToString();
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Error reading property " + propertyName + " from virtual interface " + interfaceType.ToString(), ex);
            }

            return propertyValue;
        }

        private string GetElementText(XmlElement element) 
        {
            System.Text.StringBuilder elementText = new System.Text.StringBuilder();

            elementText.Append("<");
            elementText.Append(element.Name);
            
            foreach (XmlAttribute attribute in element.Attributes) 
            {
                elementText.Append(" ");
                elementText.Append(attribute.OuterXml);
            }

            elementText.Append(" >");

            return elementText.ToString();
        }

        private string ResolvePassword(string accountIdent)
        {
            CSetupSecureResolver decoder = new CSetupSecureResolver();
            string password = decoder.UserSecret(accountIdent);
            return password;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmlsequencer\StepContainer.cs ===
using System;
using System.Xml;
using System.Reflection;

namespace xonline.common.xmlsequencer
{
	/// <summary>
	/// Summary description for StepContainer.
	/// </summary>
	public class StepContainer : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public StepContainer(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
		protected StepContainer(XmlElement stepElement) : base(stepElement)
		{
		}

        /// <summary>
        /// 
        /// </summary>
		protected override void OnExecute()
		{
			XmlNodeList childElements = BaseXmlElement.SelectNodes("sequencens:*", Root.NamespaceManager);

			foreach (XmlNode childNode in childElements)
			{
				Step childStep = InstantiateChild(childNode);
				childStep.Execute();
			}
		}

        /// <summary>
        /// 
        /// </summary>
        public override void Validate()
        {
            XmlNodeList childElements = BaseXmlElement.SelectNodes("*");

            foreach (XmlNode childNode in childElements)
            {
                Step childStep = InstantiateChild(childNode);
                childStep.Validate();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="output"></param>
        public override void GenerateWix(XmlTextWriter output)
        {
            XmlNodeList childElements = BaseXmlElement.SelectNodes("*");

            foreach (XmlNode childNode in childElements)
            {
                Step childStep = InstantiateChild(childNode);
                childStep.GenerateWix(output);
            }
        }

        private Step InstantiateChild(XmlNode childNode)
        {
            XmlElement child = (XmlElement) childNode;
            System.Type childType = null;

            childType = Root.TypeMap[child.Name];
            if (childType == null)
            {
                throw new InvalidOperationException("Encountered XML element " + child.Name + " with no matching entry in TypeMap.");
            }

            System.Type[] constructorPrototype = {child.GetType(), this.GetType()};
            ConstructorInfo ctor = childType.GetConstructor(constructorPrototype);
				
            object[] constructorParameters = {child, this};
            return (Step) ctor.Invoke(constructorParameters);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmlsequencer\Step.cs ===
using System;
using System.IO;
using System.Xml;

namespace xonline.common.xmlsequencer
{
	/// <summary>
	/// Provides the base class that all steps will inherit from. 
	/// </summary>
	/// <remarks>
	/// <para>
	/// A step is the fundamental piece of XML Sequencing. In the source XML file, elements will get assoicated with
	/// a step type, which provides the implementation to process the step.
	/// </para>
	/// <para>
	/// While the step class can be used directly as a step type, the only functionality it provides is to log messages
	/// to the message log. To provide further functionality, you need to create a derived class that overrides one or more
	/// of the <see cref="Step.Validate"/>, <see cref="Step.OnBeforeExecute" />, <see cref="Step.OnExecute"/>, or 
	/// <see cref="Step.OnAfterExecute" /> methods. Within those methods, you can access the data in the step's element
	/// through the <see cref="Step.BaseXmlElement"/> property.
	/// </para>
	/// <para>
	/// Note that a Step is used for steps that do not have children steps. To implement a step that will have
	/// child steps, you need to derrive from the <see cref="StepContainer"/> class.
	/// </para>
    /// <para>
    /// The following table lists the attributes supported by the <c>&lt;Step&gt;</c> element
    /// and a brief description of their meaning. Note that these attributes are available for any steps that derrive from this class.
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>message</term>
    ///     <description>A message to send to the message log when this step is processed.</description>
    /// </item>
    /// </list> 
  	/// </remarks>
  	[StepElement("Log")]
	public class Step
	{
        private XmlElement baseXmlElement = null;
        private StepContainer parent = null;
        private RootStepContainer root = null;
        
        /// <summary>
		/// Initializes a new instance of the Step class from an XML element, and its parent StepContainer.
		/// </summary>
		/// <param name="stepElement">The XML element that contains the information needed to initialize this object.</param>
		/// <param name="parent">
		/// The StepContainer object that contains this step.
		/// </param>
		/// <exception cref="ArgumentNullException">A null stepElement or parent was passed.</exception>
		public Step(XmlElement stepElement, StepContainer parent) : this(stepElement)
		{
			if (parent == null)
			{
				throw new ArgumentNullException("parent");
			}
			this.parent = parent;

		}

		/// <summary>
		/// Initializes a new instance of the Step class from and XML element. This version of the
		/// constructor should only be called by a RootStepContainer, since it is the only type that
		/// does not have a parent.
		/// </summary>
		/// <param name="stepElement">The XML element that contains the information needed to initialize this object.</param>
		/// <exception cref="ArgumentNullException">A null stepElement or parent was passed.</exception>
		protected Step(XmlElement stepElement)
		{
			if (stepElement == null)
			{
				throw new ArgumentNullException("stepElement");
			}

			baseXmlElement = stepElement;
		}

        /// <summary>
        /// 
        /// </summary>
		public XmlElement BaseXmlElement
		{
			get 
			{
				return baseXmlElement;
			}
		}

        /// <summary>
        /// Gets the parent StepContainer for this step in the XmlSequencer hierarchy.
        /// </summary>
		public StepContainer Parent
		{
			get {return parent;}
		}

        /// <summary>
        /// Gets the RootStepContainer for this step in the XmlSequencer hierarchy.
        /// </summary>
		public RootStepContainer Root
		{
			get
			{
				if (root == null)
				{
					if (Parent == null)
					{
						root = (RootStepContainer) this;
					}
					else
					{
						root = Parent.Root;
					}
				}
				return root;
			}
		}

        /// <summary>
        /// Tells the step to execute itself.
        /// </summary>
        /// <remarks>
        /// This method calls the <see cref="Step.OnBeforeExecute" />, <see cref="Step.OnExecute"/>, and 
        /// <see cref="Step.OnAfterExecute" /> methods, in that order, for the current step. If either
        /// OnBeforeExecute or OnExecute generate an exception, the OnAfterExecute will still get called.
        /// </remarks>
		public void Execute()
		{
			try
			{
				OnBeforeExecute();
				OnExecute();
			}
			finally
			{
				OnAfterExecute();
			}
		}

        /// <summary>
        /// Called by the <see cref="Step.Execute"/> method before the <see cref="Step.OnExecute"/>
        /// method.
        /// </summary>
        /// <remarks>
        /// Override this method in your derived class to perform any initialization or setup that needs to be 
        /// performed before the main execution path begins.  
        /// </remarks>
		protected virtual void OnBeforeExecute()
		{
			string message = BaseXmlElement.GetAttribute("message");
			
			if (message.Length > 0)
			{
				Root.LogMessage(message);
			}
		}

        /// <summary>
        /// Called by the <see cref="Step.Execute"/> method before the <see cref="Step.OnAfterExecute"/>
        /// method.
        /// </summary>
        /// <remarks>
        /// Override this method in your derived class to perform the action of your step.  
        /// </remarks>
        protected virtual void OnExecute()
		{
		}

        /// <summary>
        /// Called by the <see cref="Step.Execute"/> method after the <see cref="Step.OnExecute"/>
        /// method.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Override this method in your derived class to perform any cleanup for your step.
        /// </para>
        /// <para>
        /// This method will get called even if an exception is generated in the <see cref="Step.OnBeforeExecute"/>
        /// or <see cref="Step.OnExecute"/> methods.
        /// </para>  
        /// </remarks>
        protected virtual void OnAfterExecute()
		{
		}

        /// <summary>
        /// Provides a method that can be overridden to validate that this Step could execute
        /// based on the information in its XML element. 
        /// </summary>
        /// <remarks>
        /// <para>
        /// When the XML Sequencer is executed, it is typically done in two passes. The validation pass
        /// calls this method for each step. Only when validation has completed successfully for all steps
        /// will the steps be executed. 
        /// </para>
        /// <para>
        /// This method should be overridden in you derived classes if there is any validation that
        /// can be performed without side effects. This includes verifying that any required 
        /// attributes have been provided, any external resources (such as files) specified in the XML
        /// attributes exist, etc. You should throw an exception if your step fails validation. 
        /// </para>
        /// </remarks>
        public virtual void Validate()
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="ouput"></param>
        public virtual void GenerateWix(XmlTextWriter ouput)
        {
        }
	}

    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
    public class StepElementAttribute : System.Attribute
    {
        private string elementName = "";

        public StepElementAttribute(string elementName)
        {
            this.elementName = elementName;
        }

        public string ElementName
        {
            get {return elementName;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\xmlsequencer\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xmlsequencer_2_none_12.4.56.0_none_f60a67ed0b2c7df8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xmlsequencer_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762.manifest
XP_MANIFEST_PATH=manifests\x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762.cat
XP_CATALOG_PATH=manifests\x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762.cat
XP_PAYLOAD_PATH=x86__xmlsequencer_2_no-public-key_12.4.56.0_x-ww_302bb762
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xmlsequencer_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\BI_Octopus\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\BI_Octopus\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__bi_octopus_1_none_12.4.56.0_none_f086e548ec0ad734
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_bi_octopus_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae.manifest
XP_MANIFEST_PATH=manifests\x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae.cat
XP_CATALOG_PATH=manifests\x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae.cat
XP_PAYLOAD_PATH=x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_bi_octopus_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\BI_Octopus\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__bi_octopus_1_none_12.4.56.0_none_f086e548ec0ad734
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_bi_octopus_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae.manifest
XP_MANIFEST_PATH=manifests\x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae.cat
XP_CATALOG_PATH=manifests\x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae.cat
XP_PAYLOAD_PATH=x86__bi_octopus_1_no-public-key_12.4.56.0_x-ww_e93c7fae
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_bi_octopus_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\CopyString.cpp ===
#include "stdafx.h"

LPTSTR CopyString(LPCTSTR str)
{
	DWORD  dwLength;
	LPTSTR szCopy;
	
	dwLength = _tcslen(str) + 1;
	szCopy = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, dwLength * sizeof(TCHAR));
	if( !szCopy )
	{
		return NULL;
	}

	CopyMemory(szCopy, str, dwLength * sizeof(TCHAR));

	return szCopy;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\ExpandEnvironmentVariables.cpp ===
#include "StdAfx.h"

HRESULT ExpandEnvironmentVariables(const TCHAR *sourceString, TCHAR **expanded)
{
	DWORD dwLength = ExpandEnvironmentStrings(sourceString, NULL, 0) + 1;

	(*expanded) = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, dwLength * sizeof(TCHAR));
	if( !(*expanded) )
	{
		return E_OUTOFMEMORY;
	}
	ExpandEnvironmentStrings(sourceString, (*expanded), dwLength);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\MsiDatabase.cpp ===
#include "StdAfx.h"
#include "XCmdCA.h"

UINT MsiDatabaseCreateQueryView(MSIHANDLE *phView, MSIHANDLE hDatabase, LPTSTR szQuery, MSIHANDLE hParameters)
{
	UINT uiErrorCode;

	uiErrorCode = MsiDatabaseOpenView(hDatabase,  szQuery, phView);
	if( uiErrorCode != ERROR_SUCCESS )
	{
		return uiErrorCode;
	}

	return MsiViewExecute( *phView, NULL );
}

UINT MsiGetStringField( MSIHANDLE hInstall, MSIHANDLE hRecHandle, int nFieldIdx, PTCHAR *pszBuffer )
{
	UINT uiErrorCode = ERROR_SUCCESS;
	DWORD cchVal = 0;

	*pszBuffer = NULL;

	// get the record.
	uiErrorCode = MsiRecordGetString( hRecHandle, nFieldIdx, TEXT(""), &cchVal);
	if (uiErrorCode != ERROR_MORE_DATA )
	{
		return uiErrorCode;
	}

	// create a buffer to pass on...
	*pszBuffer = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (++(cchVal)) * sizeof(TCHAR));
	if ( *pszBuffer == NULL )
	{
		MsiLogError(hInstall, TEXT("Out of memory.") );
		return E_OUTOFMEMORY;
	}
	ZeroMemory( *pszBuffer, cchVal );

	// copy the string into our buffer.
	uiErrorCode = MsiRecordGetString( hRecHandle, nFieldIdx, *pszBuffer, &cchVal);
	if (uiErrorCode != ERROR_SUCCESS )
	{
		MsiLogError(hInstall, TEXT("This value is invalid for this implementation.  This is due to MSI settings not user input." ));
		return uiErrorCode;
	}

	return ERROR_SUCCESS;
}

UINT MsiRecordGetStringField(MSIHANDLE hInstall, MSIHANDLE hRecord, UINT uiField, DWORD dwFormatFlags, PTCHAR *pszBuffer)
{
	UINT uiErrorCode = ERROR_SUCCESS;
	DWORD cchVal = 0;
	DWORD dwErrorCode;
	LPTSTR szBuffer;

	szBuffer = NULL;

	// get the record.
	uiErrorCode = MsiRecordGetString( hRecord, uiField, TEXT(""), &cchVal);
	if (uiErrorCode != ERROR_MORE_DATA )
	{
		return uiErrorCode;
	}

	// create a buffer to pass on...
	szBuffer = (PTCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (++(cchVal)) * sizeof(TCHAR));
	if ( szBuffer == NULL )
	{
		return E_OUTOFMEMORY;
	}
	ZeroMemory( szBuffer, cchVal );

	// copy the string into our buffer.
	uiErrorCode = MsiRecordGetString( hRecord, uiField, szBuffer, &cchVal);
	if (uiErrorCode != ERROR_SUCCESS )
	{
		return uiErrorCode;
	}

	// Process FormatFlags
	if( dwFormatFlags & MSIRECORDFORMAT_FORMATTED )
	{
		dwErrorCode = MsiExpandFormattedString(hInstall, szBuffer, pszBuffer);
		HeapFree(GetProcessHeap(), 0, szBuffer);
		if( dwErrorCode != S_OK )
		{
			HeapFree(GetProcessHeap(), 0, *pszBuffer);
			return dwErrorCode;
		}
		
		szBuffer = *pszBuffer;
	}

	if( dwFormatFlags & MSIRECORDFORMAT_ENV )
	{
		dwErrorCode = ExpandEnvironmentVariables(szBuffer, pszBuffer);
		HeapFree(GetProcessHeap(), 0, szBuffer);
		if( dwErrorCode != S_OK )
		{
			HeapFree(GetProcessHeap(), 0, *pszBuffer);
			return dwErrorCode;
		}

		szBuffer = *pszBuffer;
	}

	// Set the returned buffer
	*pszBuffer = szBuffer;

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\MsiExecuteBinary.cpp ===
#include "stdafx.h"

HRESULT MsiExecuteBinary(MSIHANDLE hInstaller, LPTSTR szBinaryId)
{
	LPTSTR  szCmdFileName, szCmdFile, szArguments;
	HRESULT hrResult;
	DWORD   dwLength;

	dwLength = _tcslen(szBinaryId) + 5;
	szCmdFileName = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, dwLength * sizeof(TCHAR));
	if( !szCmdFileName )
	{
		return E_OUTOFMEMORY;
	}

	_sntprintf_s( szCmdFileName, dwLength, _TRUNCATE, TEXT("%%TEMP%%\\%s.cmd"), szBinaryId );

	hrResult = ExpandEnvironmentVariables(szCmdFileName, &szCmdFile);
	HeapFree( GetProcessHeap(), 0, szCmdFileName );
	if( hrResult != ERROR_SUCCESS )
	{
		return hrResult;
	}

	hrResult = MsiExtractBinaryFile(hInstaller, szBinaryId, szCmdFile);
	if( hrResult != ERROR_SUCCESS )
	{		
		HeapFree(GetProcessHeap(), 0, szCmdFile );
		return hrResult;
	}

	hrResult = MsiGetPropertyValue(hInstaller, TEXT("CMDARGUMENTS"), &szArguments);
	if( hrResult != ERROR_SUCCESS )
	{		
		HeapFree(GetProcessHeap(), 0, szCmdFile );
		return hrResult;
	}

	MsiExecuteCommand(0, hInstaller, szCmdFile, szArguments, NULL);
	
	DeleteFile(szCmdFile);

	HeapFree(GetProcessHeap(), 0, szCmdFile );

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\MsiExecuteCommand.cpp ===
#include "stdafx.h"

typedef struct _PLUMBINGINFO 
{
	MSIHANDLE hInstaller;
	HANDLE    hThread;
	LPSTR     szStreamName;
	DWORD     dwThreadId;
	HANDLE    hPipe[2];
} PLUMBINGINFO, *PPLUMBINGINFO;

DWORD WINAPI ProcessOutputStream(LPVOID lpvThreadParam)
{
	DWORD         dwBufferSize = 4096;
	PPLUMBINGINFO plumbing = (PPLUMBINGINFO)lpvThreadParam;
	LPSTR         buffer   = (LPSTR)HeapAlloc(GetProcessHeap(), 0, dwBufferSize);
	LPSTR         line     = (LPSTR)HeapAlloc(GetProcessHeap(), 0, 1024);
	DWORD         dwBytesRead, dwIndex, dwPointer, dwLength, dwLinePointer;

	dwLength = dwIndex = dwPointer = dwLinePointer = 0;
	while( ReadFile( plumbing->hPipe[0], buffer + dwLength, dwBufferSize - dwLength, &dwBytesRead, NULL ) && dwBytesRead )
	{
		dwLength += dwBytesRead;
		while( TRUE )
		{
			for( ; dwPointer < dwLength && buffer[dwPointer] != '\r' && buffer[dwPointer] != '\n'; dwPointer ++ )
			{
				if( isprint(buffer[dwPointer]) )
				{
					line[dwLinePointer ++] = buffer[dwPointer];
				}
				else
				{
					line[dwLinePointer ++] = ' ';
				}
				if( dwLinePointer == 1023 )
				{
					line[dwLinePointer ++]= 0;

					MsiLogInfoA(plumbing->hInstaller, "%s: %s", plumbing->szStreamName, line );

					line[0] = line[1] = ' ';
					dwLinePointer = 2;				
				}
			}

			if( dwPointer == dwLength || (dwPointer + 1 == dwLength && buffer[dwPointer] == '\r' ))
			{
				if( dwPointer == dwBufferSize )
				{
					buffer = (LPSTR)HeapReAlloc(GetProcessHeap(), 0, buffer, dwBufferSize + 4096);
				}

				MoveMemory(buffer, buffer + dwIndex, dwLength - dwIndex);
				dwLength -= dwIndex;
				dwPointer -= dwIndex;
				dwIndex = 0;

				break;
			}

			if( buffer[dwPointer] == '\r' && buffer[dwPointer+1] == '\n' )
			{
				dwPointer ++;
			}
			dwPointer ++;
			dwIndex = dwPointer;

			line[dwLinePointer ++]= 0;

			MsiLogInfoA(plumbing->hInstaller, "%s: %s", plumbing->szStreamName, line );

			dwLinePointer = 0;
		}
	}

	HeapFree(GetProcessHeap(), 0, buffer);
	HeapFree(GetProcessHeap(), 0, line);

	return 0;
}

BOOL MsiExecuteCommand(LPDWORD exitCode, MSIHANDLE hInstaller, LPTSTR szCommand, LPTSTR szArguments, LPTSTR szWorkingDir)
{
	PROCESS_INFORMATION piProcess;
	SECURITY_ATTRIBUTES saPipes;
	STARTUPINFO         siProcess;
	LPTSTR              szCommandLine;
	LPTSTR              szWorkingDirectory;
	SIZE_T              dwLength;
	DWORD               dwResult;
	DWORD               dwLastError;
	PLUMBINGINFO        plumbingInfo[3];

	// Setup the security attributes for the pipes i.e. allow them 
	// to be inherited
	ZeroMemory(&siProcess, sizeof(SECURITY_ATTRIBUTES));
	saPipes.nLength               = sizeof(SECURITY_ATTRIBUTES);
	saPipes.bInheritHandle        = TRUE;
	saPipes.lpSecurityDescriptor  = NULL;

	// Create the pipes
	ZeroMemory(&plumbingInfo, sizeof(plumbingInfo));
	plumbingInfo[0].szStreamName = "STDIN";
	plumbingInfo[0].hInstaller = hInstaller;
	if( !CreatePipe(&(plumbingInfo[0].hPipe[0]), &(plumbingInfo[0].hPipe[1]), &saPipes, 1024) )
	{
		return FALSE;
	}
	SetHandleInformation(plumbingInfo[0].hPipe[1], HANDLE_FLAG_INHERIT, 0);

	plumbingInfo[1].szStreamName = "STDOUT";
	plumbingInfo[1].hInstaller = hInstaller;
	if( !CreatePipe(&(plumbingInfo[1].hPipe[0]), &(plumbingInfo[1].hPipe[1]), &saPipes, 1024) )
	{
		CloseHandle(plumbingInfo[0].hPipe[0]);
		CloseHandle(plumbingInfo[0].hPipe[1]);

		return FALSE;
	}
	SetHandleInformation(plumbingInfo[1].hPipe[0], HANDLE_FLAG_INHERIT, 0);

	plumbingInfo[2].szStreamName = "STDERR";
	plumbingInfo[2].hInstaller = hInstaller;
	if( !CreatePipe(&(plumbingInfo[2].hPipe[0]), &(plumbingInfo[2].hPipe[1]), &saPipes, 1024) )
	{
		CloseHandle(plumbingInfo[1].hPipe[0]);
		CloseHandle(plumbingInfo[1].hPipe[1]);
		CloseHandle(plumbingInfo[0].hPipe[0]);
		CloseHandle(plumbingInfo[0].hPipe[1]);

		return FALSE;
	}
	SetHandleInformation(plumbingInfo[2].hPipe[0], HANDLE_FLAG_INHERIT, 0);

	// Construct the STARTUPINFO
	ZeroMemory(&siProcess, sizeof(siProcess));
	siProcess.cb            = sizeof(siProcess);
	siProcess.hStdInput     = NULL;
	siProcess.dwFlags       = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	siProcess.wShowWindow   = SW_HIDE; //SW_SHOWNORMAL;
	siProcess.lpDesktop     = TEXT("winsta0\\default");
	siProcess.hStdInput     = plumbingInfo[0].hPipe[0];
	siProcess.hStdOutput    = plumbingInfo[1].hPipe[1];
	siProcess.hStdError     = plumbingInfo[2].hPipe[1];

	// Construct the commandline
	dwLength = _tcslen(szCommand) + _tcslen(szArguments) + 8;
	szCommandLine = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, dwLength * sizeof(TCHAR) );
	if( !szCommandLine )
	{
		CloseHandle(plumbingInfo[2].hPipe[0]);
		CloseHandle(plumbingInfo[2].hPipe[1]);
		CloseHandle(plumbingInfo[1].hPipe[0]);
		CloseHandle(plumbingInfo[1].hPipe[1]);
		CloseHandle(plumbingInfo[0].hPipe[0]);
		CloseHandle(plumbingInfo[0].hPipe[1]);

		return FALSE;
	}
	_sntprintf_s( szCommandLine, dwLength, _TRUNCATE, TEXT("\"%s\" %s"), szCommand, szArguments);	

	// Fixup the working directory so CreateProcess doesn't choke
	szWorkingDirectory = NULL;
	if(szWorkingDir !=NULL && *szWorkingDir)
	{
		szWorkingDirectory = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, (1+_tcslen(szWorkingDir)) * sizeof( TCHAR ) );
		if( !szWorkingDirectory  )
		{
			HeapFree(GetProcessHeap(), 0, szCommandLine);
			CloseHandle(plumbingInfo[2].hPipe[0]);
			CloseHandle(plumbingInfo[2].hPipe[1]);
			CloseHandle(plumbingInfo[1].hPipe[0]);
			CloseHandle(plumbingInfo[1].hPipe[1]);
			CloseHandle(plumbingInfo[0].hPipe[0]);
			CloseHandle(plumbingInfo[0].hPipe[1]);

			return FALSE;
		}
		CopyMemory(szWorkingDirectory, szWorkingDir, (1+_tcslen(szWorkingDir)) * sizeof( TCHAR ));
		LPTSTR szLastChar = szWorkingDirectory + _tcslen(szWorkingDirectory)-1;

		if( *szLastChar == '\\' )
		{
			*szLastChar = 0;
		}
	}

	MsiLogInfo(hInstaller, TEXT("szCommand: %s"), szCommand);
	MsiLogInfo(hInstaller, TEXT("szCommandLine: %s"), szCommandLine);
	if( szWorkingDirectory != NULL && *szWorkingDirectory != NULL )
		MsiLogInfo(hInstaller, TEXT("szWorkingDirectory: %s"), szWorkingDirectory);
	MsiLogInfo(hInstaller, TEXT(""));

	// Create the process
	dwResult = CreateProcess(
		szCommand, 
		szCommandLine,
		NULL, NULL,
		TRUE,
		0,
		NULL, 
		szWorkingDirectory, 
		&siProcess, &piProcess);
	dwLastError = GetLastError();
	HeapFree(GetProcessHeap(), 0, szCommandLine);
	if( szWorkingDirectory )
	{
		HeapFree(GetProcessHeap(), 0, szWorkingDirectory);
	}
	if( !dwResult )
	{
		CloseHandle(plumbingInfo[2].hPipe[0]);
		CloseHandle(plumbingInfo[2].hPipe[1]);
		CloseHandle(plumbingInfo[1].hPipe[0]);
		CloseHandle(plumbingInfo[1].hPipe[1]);
		CloseHandle(plumbingInfo[0].hPipe[0]);
		CloseHandle(plumbingInfo[0].hPipe[1]);
		MsiLogInfo(hInstaller, szWorkingDir);
		MsiLogInfo(hInstaller, TEXT("CreateProcess failed with error 0x%08X"), dwLastError);
		return FALSE;
	}

	// Close unused handles
	CloseHandle(plumbingInfo[0].hPipe[0]);
	CloseHandle(plumbingInfo[0].hPipe[1]);
	CloseHandle(plumbingInfo[2].hPipe[1]);
	CloseHandle(plumbingInfo[1].hPipe[1]);

	// Create pumps for stdout and stderr
	plumbingInfo[1].hThread = CreateThread(0, 0, ProcessOutputStream, &plumbingInfo[1], 0, &plumbingInfo[1].dwThreadId);
	if( !plumbingInfo[1].hThread )
	{
		CloseHandle(piProcess.hThread);
		CloseHandle(piProcess.hProcess);
		CloseHandle(plumbingInfo[2].hPipe[0]);
		CloseHandle(plumbingInfo[1].hPipe[0]);

		return FALSE;
	}

	plumbingInfo[2].hThread = CreateThread(0, 0, ProcessOutputStream, &plumbingInfo[2], 0, &plumbingInfo[2].dwThreadId);
	if( !plumbingInfo[1].hThread )
	{
		CloseHandle(piProcess.hThread);
		CloseHandle(piProcess.hProcess);
		CloseHandle(plumbingInfo[1].hThread);
		CloseHandle(plumbingInfo[2].hPipe[0]);
		CloseHandle(plumbingInfo[1].hPipe[0]);

		return FALSE;
	}

	// Wait for the process to complete
	dwResult = WaitForSingleObject( piProcess.hProcess, INFINITE);
	if( dwResult != WAIT_OBJECT_0 )
	{
		CloseHandle(piProcess.hThread);
		CloseHandle(piProcess.hProcess);
		CloseHandle(plumbingInfo[2].hThread);
		CloseHandle(plumbingInfo[1].hThread);
		CloseHandle(plumbingInfo[2].hPipe[0]);
		CloseHandle(plumbingInfo[1].hPipe[0]);

		return FALSE;
	}

	// Close the pipes to force the Output processor threads to stop
	CloseHandle(plumbingInfo[2].hPipe[0]);
	CloseHandle(plumbingInfo[1].hPipe[0]);

	// Wait for the threads to exit
	dwResult = WaitForSingleObject( plumbingInfo[1].hThread, INFINITE);
	CloseHandle(plumbingInfo[1].hThread);
	if( dwResult != WAIT_OBJECT_0 )
	{
		CloseHandle(piProcess.hThread);
		CloseHandle(piProcess.hProcess);
		CloseHandle(plumbingInfo[2].hThread);

		return FALSE;
	}

	dwResult = WaitForSingleObject( plumbingInfo[0].hThread, INFINITE);
	CloseHandle(plumbingInfo[2].hThread);
	if( dwResult != WAIT_OBJECT_0 )
	{
		CloseHandle(piProcess.hThread);
		CloseHandle(piProcess.hProcess);

		return FALSE;
	}

	if (exitCode && !GetExitCodeProcess(piProcess.hProcess, exitCode)) 
	{
		CloseHandle(piProcess.hThread);
		CloseHandle(piProcess.hProcess);

		return FALSE;
	}

	CloseHandle(piProcess.hThread);
	CloseHandle(piProcess.hProcess);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\MsiEscapeString.cpp ===
#include "StdAfx.h"
#include "XCmdCA.h"

HRESULT MsiEscapeString(MSIHANDLE hInstall, TCHAR *szInput, TCHAR **szOutput)
{
	DWORD  dwEscapes = 0;
	TCHAR *szInputPtr;
	TCHAR *szOutputPtr;

	szInputPtr = szInput;
	while( *szInputPtr )
	{
		if( _tcschr(TEXT("{}[]"), *szInputPtr ) )
		{
			dwEscapes ++;
		}
		szInputPtr ++;
	}

	(*szOutput) = (TCHAR *)HeapAlloc(GetProcessHeap(), 0, (_tcslen(szInput) + dwEscapes * 3 + 1) * sizeof(TCHAR) );
	if( !(*szOutput) )
	{
		return E_OUTOFMEMORY;
	}

	szInputPtr = szInput;
	szOutputPtr = *szOutput;
	while( *szInputPtr )
	{
		if( _tcschr(TEXT("{}[]"), *szInputPtr ) )
		{
			*szOutputPtr ++ = TEXT('[');
			*szOutputPtr ++ = TEXT('\\');
			*szOutputPtr ++ = *szInputPtr ++;
			*szOutputPtr ++ = TEXT(']');
		}
		else
		{
			*szOutputPtr ++ = *szInputPtr ++;
		}
	}
	*szOutputPtr = 0;

	return S_OK;
}

HRESULT MsiEscapeStringA(MSIHANDLE hInstall, char *szInput, char **szOutput)
{
	DWORD  dwEscapes = 0;
	char *szInputPtr;
	char *szOutputPtr;

	szInputPtr = szInput;
	while( *szInputPtr )
	{
		if( strchr("{}[]", *szInputPtr ) )
		{
			dwEscapes ++;
		}
		szInputPtr ++;
	}

	(*szOutput) = (char *)HeapAlloc(GetProcessHeap(), 0, (strlen(szInput) + dwEscapes * 3 + 1) * sizeof(char) );
	if( !(*szOutput) )
	{
		return E_OUTOFMEMORY;
	}

	szInputPtr = szInput;
	szOutputPtr = *szOutput;
	while( *szInputPtr )
	{
		if( strchr("{}[]", *szInputPtr ) )
		{
			*szOutputPtr ++ = '[';
			*szOutputPtr ++ = '\\';
			*szOutputPtr ++ = *szInputPtr ++;
			*szOutputPtr ++ = ']';
		}
		else
		{
			*szOutputPtr ++ = *szInputPtr ++;
		}
	}
	*szOutputPtr = 0;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\MsiExpandFormattedString.cpp ===
#include "StdAfx.h"
#include "XCmdCA.h"

HRESULT MsiExpandFormattedString(MSIHANDLE hInstall, const TCHAR *formattedString, TCHAR **expanded)
{
	DWORD dwLength=0;

	// Don't do anything for null strings
	if( formattedString == NULL )
	{
		*expanded = NULL;
		return S_OK;
	}

	if( *formattedString == NULL )
	{
		(*expanded) = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, sizeof(TCHAR));
		if( !(*expanded) )
		{
			return E_OUTOFMEMORY;
		}
		**expanded = NULL;
		return S_OK;
	}

	// Create an MSI record for FormatRecord
	PMSIHANDLE hRecord = MsiCreateRecord(1);
	MsiRecordSetString(hRecord, 0, formattedString);

	// Get the length of the expanded string
	*expanded = TEXT("");
	MsiFormatRecord(hInstall, hRecord, *expanded, &dwLength);
	dwLength ++;

	// Allocate memory for new string
	(*expanded) = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, dwLength * sizeof(TCHAR));
	if( !(*expanded) )
	{
		return E_OUTOFMEMORY;
	}

	// Get the expanded string
	MsiFormatRecord(hInstall, hRecord, *expanded, &dwLength);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\MsiGetPropertyValue.cpp ===
#include "StdAfx.h"
#include "XCmdCA.h"

UINT MsiGetPropertyValue(MSIHANDLE hInstaller, LPCTSTR szName, LPTSTR *szValue)
{
	UINT  uiErrorCode;
	DWORD dwSize=0;

	*szValue = TEXT("");
	uiErrorCode = MsiGetProperty(hInstaller, szName, *szValue, &dwSize);
	if( uiErrorCode != ERROR_MORE_DATA && uiErrorCode != ERROR_SUCCESS )
	{
		return uiErrorCode;
	}

	dwSize ++;

	*szValue = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, dwSize * sizeof(TCHAR));
	if( !(*szValue) )
	{
		return E_OUTOFMEMORY;
	}

	uiErrorCode = MsiGetProperty(hInstaller, szName, *szValue, &dwSize);
	
	return uiErrorCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\MsiExtractBinaryFile.cpp ===
#include "StdAfx.h"
#include "XCmdCA.h"

HRESULT MsiExtractBinaryFile(MSIHANDLE hInstaller, LPTSTR szBinaryId, LPTSTR szOutputFile)
{
	HANDLE hFile;
	LPBYTE transferBuffer;
	DWORD dwBytesRead = 8192;
	PMSIHANDLE hDatabase;
	PMSIHANDLE hRecord;
	PMSIHANDLE hView;
	UINT uiErrorCode = 0;

	transferBuffer = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwBytesRead);
	if( !transferBuffer )
	{
		return E_OUTOFMEMORY;
	}

	hDatabase = MsiGetActiveDatabase(hInstaller);
	if( !hDatabase )
	{
		HeapFree(GetProcessHeap(), 0, transferBuffer);
		return E_FAIL;
	}
	
	_sntprintf_s( (LPTSTR)transferBuffer, dwBytesRead / sizeof(TCHAR), _TRUNCATE, TEXT("SELECT Data FROM Binary WHERE Name = \'%s\'"), szBinaryId );

	uiErrorCode = MsiDatabaseCreateQueryView(
		&hView, hDatabase,
		(LPTSTR)transferBuffer, NULL );
	if( uiErrorCode != ERROR_SUCCESS )
	{
		HeapFree(GetProcessHeap(), 0, transferBuffer);
		return uiErrorCode;
	}

	uiErrorCode = MsiViewFetch(hView, &hRecord);
	if( uiErrorCode != ERROR_SUCCESS )
	{
		HeapFree(GetProcessHeap(), 0, transferBuffer);
		return uiErrorCode;
	}

	hFile = CreateFile(szOutputFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if( !hFile )
	{
		HeapFree(GetProcessHeap(), 0, transferBuffer);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	while( (MsiRecordReadStream(hRecord, 1, (char *)transferBuffer, &dwBytesRead) == ERROR_SUCCESS) && (dwBytesRead == 8192) )
	{
		WriteFile( hFile, transferBuffer, dwBytesRead, &dwBytesRead, NULL );
	}
	WriteFile( hFile, transferBuffer, dwBytesRead, &dwBytesRead, NULL );

	HeapFree(GetProcessHeap(), 0, transferBuffer);

	CloseHandle(hFile);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// CmdCA.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows XP or later.
#define WINVER 0x0501		// Change this to the appropriate value to target other versions of Windows.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows XP or later.                   
#define _WIN32_WINNT 0x0501	// Change this to the appropriate value to target other versions of Windows.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 6.0 or later.
#define _WIN32_IE 0x0600	// Change this to the appropriate value to target other versions of IE.
#endif

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>



// TODO: reference additional headers your program requires here
#include <tchar.h>
#include <msiquery.h>
#include <msi.h>
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>

#include "XCmdCA.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\MsiLogging.cpp ===
#include "StdAfx.h"
#include "XCmdCA.h"

void __MsiLogMessage(MSIHANDLE hInstaller, INSTALLMESSAGE eMessageType, const TCHAR *pszFormat, va_list args );
void __MsiLogMessageA(MSIHANDLE hInstaller, INSTALLMESSAGE eMessageType, const char *pszFormat, va_list args );

void MsiLogError(MSIHANDLE hInstaller, const TCHAR *pszFormat, ...)
{
	va_list vaArgs;

	va_start(vaArgs, pszFormat);
	__MsiLogMessage(hInstaller, INSTALLMESSAGE_ERROR, pszFormat, vaArgs);
	va_end(vaArgs);
}

void MsiLogInfo(MSIHANDLE hInstaller, const TCHAR *pszFormat, ...)
{
	va_list vaArgs;

	va_start(vaArgs, pszFormat);
	__MsiLogMessage(hInstaller, INSTALLMESSAGE_INFO, pszFormat, vaArgs);
	va_end(vaArgs);
}

void MsiLogMessage(MSIHANDLE hInstaller, INSTALLMESSAGE eMessageType, const TCHAR *pszFormat, ...)
{
	va_list vaArgs;

	va_start(vaArgs, pszFormat);
	__MsiLogMessage(hInstaller, eMessageType, pszFormat, vaArgs);
	va_end(vaArgs);
}

void MsiLogErrorA(MSIHANDLE hInstaller, const char *pszFormat, ...)
{
	va_list vaArgs;

	va_start(vaArgs, pszFormat);
	__MsiLogMessageA(hInstaller, INSTALLMESSAGE_ERROR, pszFormat, vaArgs);
	va_end(vaArgs);
}

void MsiLogInfoA(MSIHANDLE hInstaller, const char *pszFormat, ...)
{
	va_list vaArgs;

	va_start(vaArgs, pszFormat);
	__MsiLogMessageA(hInstaller, INSTALLMESSAGE_INFO, pszFormat, vaArgs);
	va_end(vaArgs);
}

void MsiLogMessageA(MSIHANDLE hInstaller, INSTALLMESSAGE eMessageType, const char *pszFormat, ...)
{
	va_list vaArgs;

	va_start(vaArgs, pszFormat);
	__MsiLogMessageA(hInstaller, eMessageType, pszFormat, vaArgs);
	va_end(vaArgs);
}

void __MsiLogMessage(MSIHANDLE hInstaller, INSTALLMESSAGE eMessageType, const TCHAR *pszFormat, va_list args )
{
	static SYSTEMTIME currentTime;
	static TCHAR szMessage[2048];
	static TCHAR szBuffer[2048];
	static PTCHAR szEscaped;

	// Expand the format string
	_vstprintf_s(szMessage, ARRAYSIZE(szMessage), pszFormat, args);	

	// Get the current time
	GetSystemTime(&currentTime);

	if( eMessageType != INSTALLMESSAGE_ERROR )
	{
		// Prepend the time to the format string

		_sntprintf_s(szBuffer, ARRAYSIZE(szBuffer), _TRUNCATE, TEXT("Custom Action [%02d:%02d:%02d.%03d]: %s"), 		
			currentTime.wHour, currentTime.wMinute, currentTime.wSecond,
			currentTime.wMilliseconds, szMessage);

		// Escape the string so it is printed literally
		MsiEscapeString(hInstaller, szBuffer, &szEscaped);
	}
	else
	{
		// Escape the String
		MsiEscapeString(hInstaller, szMessage, &szEscaped);
	}

	// Create the MSI log record and log it
	PMSIHANDLE hRecord = MsiCreateRecord(1);
	MsiRecordSetString(hRecord, 0, szEscaped);
	MsiProcessMessage(hInstaller, eMessageType, hRecord);

	HeapFree(GetProcessHeap(), 0, szEscaped);
}

void __MsiLogMessageA(MSIHANDLE hInstaller, INSTALLMESSAGE eMessageType, const char *pszFormat, va_list args )
{
	static SYSTEMTIME currentTime;
	static char szMessage[2048];
	static char szBuffer[2048];
	static char *szEscaped;

	// Expand the format string
	vsprintf_s(szMessage, ARRAYSIZE(szMessage), pszFormat, args);

	// Get the current time
	GetSystemTime(&currentTime);

	if( eMessageType != INSTALLMESSAGE_ERROR )
	{
		// Prepend the time to the format string
		_snprintf_s(szBuffer, ARRAYSIZE(szBuffer), "Custom Action [%02d:%02d:%02d.%03d]: %s",
			currentTime.wHour, currentTime.wMinute, currentTime.wSecond,
			currentTime.wMilliseconds, szMessage);

		// Escape the String
		MsiEscapeStringA(hInstaller, szBuffer, &szEscaped);
	}
	else
	{
		// Escape the String
		MsiEscapeStringA(hInstaller, szMessage, &szEscaped);
	}

	// Create the MSI log record and log it
	PMSIHANDLE hRecord = MsiCreateRecord(1);
	MsiRecordSetStringA(hRecord, 0, szEscaped);
	MsiProcessMessage(hInstaller, eMessageType, hRecord);

	HeapFree(GetProcessHeap(), 0, szEscaped);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\XCmdCA.cpp ===
// CmdCA.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"

UINT ExecuteAction(MSIHANDLE hInstaller, LPTSTR szActionId)
{
	TCHAR      szOldWorkingDirectory[1024];
	TCHAR      szTempDirectory[1024];
	TCHAR      szQuery[128];
	UINT       uiErrorCode;
	PMSIHANDLE hDatabase;
	PMSIHANDLE hRecord;
	PMSIHANDLE hView;
	LPTSTR     szCommand;
	LPTSTR     szArguments;
	LPTSTR     szWorkingDirectory;
	LPTSTR     szExtract;
	LPTSTR     szContext, szBinaryId, szBinaryFile;
	LPTSTR     szTemp;
	DWORD      dwExitCode;

	// Construct the query
	_sntprintf_s( szQuery, ARRAYSIZE(szQuery), _TRUNCATE, 
		TEXT("SELECT Command, Arguments, WorkingDir, Extract FROM XCmdActions WHERE Id=\'%s\'"), szActionId);

	// Connect to the database
	hDatabase = MsiGetActiveDatabase(hInstaller);
	if( !hDatabase )
	{
		MsiLogError(hInstaller, TEXT("Failed to get a handle to the MSI database."));
		return ERROR_INSTALL_FAILURE;
	}

	// Execute the query to get the data for the current action.
	uiErrorCode = MsiDatabaseCreateQueryView(
		&hView,
		hDatabase,  
		szQuery, 
		NULL);
	if( uiErrorCode != ERROR_SUCCESS )
	{
		MsiLogError(hInstaller, TEXT("Error 0x%08X. Failed to open a view to the CmdCaActions database."), uiErrorCode);
		return ERROR_INSTALL_FAILURE;
	}

	// Grab the first (and only) record
	uiErrorCode = MsiViewFetch(hView, &hRecord);
	if( uiErrorCode != ERROR_SUCCESS )
	{
		MsiLogError(hInstaller, TEXT("2Error 0x%08X. Failed to open a view to the CmdCaActions database."), uiErrorCode);
		return ERROR_INSTALL_FAILURE;
	}

	// Get the Command
	uiErrorCode = MsiRecordGetStringField(hInstaller, hRecord, 1, MSIRECORDFORMAT_ENV | MSIRECORDFORMAT_FORMATTED, &szCommand);
	if( uiErrorCode != ERROR_SUCCESS )
	{
		MsiLogError(hInstaller, TEXT("Error %d. Failed to read Command field from XCmdInstall"), uiErrorCode);
		return ERROR_INSTALL_FAILURE;
	}

	// Get the Arguments
	uiErrorCode = MsiRecordGetStringField(hInstaller, hRecord, 2, MSIRECORDFORMAT_ENV | MSIRECORDFORMAT_FORMATTED, &szArguments);
	if( uiErrorCode != ERROR_SUCCESS )
	{
		HeapFree(GetProcessHeap(), 0, szCommand);
		MsiLogError(hInstaller, TEXT("Error %d. Failed to read Command field from XCmdInstall"), uiErrorCode);
		return ERROR_INSTALL_FAILURE;
	}

	// Get the Working Directory
	uiErrorCode = MsiRecordGetStringField(hInstaller, hRecord, 3, MSIRECORDFORMAT_ENV | MSIRECORDFORMAT_FORMATTED, &szWorkingDirectory);
	if( uiErrorCode != ERROR_SUCCESS )
	{
		HeapFree(GetProcessHeap(), 0, szArguments);
		HeapFree(GetProcessHeap(), 0, szCommand);
		MsiLogError(hInstaller, TEXT("Error %d. Failed to read Command field from XCmdInstall"), uiErrorCode);
		return ERROR_INSTALL_FAILURE;
	}

	// Get the Extract List
	uiErrorCode = MsiRecordGetStringField(hInstaller, hRecord, 4, MSIRECORDFORMAT_ENV | MSIRECORDFORMAT_FORMATTED, &szExtract);
	if( uiErrorCode != ERROR_SUCCESS )
	{
		HeapFree(GetProcessHeap(), 0, szWorkingDirectory);
		HeapFree(GetProcessHeap(), 0, szArguments);
		HeapFree(GetProcessHeap(), 0, szCommand);
		MsiLogError(hInstaller, TEXT("Error %d. Failed to read Command field from XCmdInstall"), uiErrorCode);
		return ERROR_INSTALL_FAILURE;
	}

	// Save the old working directory, and change to %TEMP%
	GetCurrentDirectory(1024, szOldWorkingDirectory);
	GetEnvironmentVariable(TEXT("TEMP"), szTempDirectory, 1024);
	SetCurrentDirectory(szTempDirectory);

	// Make a copy of szExtract
	szTemp = CopyString(szExtract);

	// Destructively parse szExtract(szTemp) and extract files
	szBinaryId = _tcstok_s(szTemp, TEXT(":"), &szContext);
	szBinaryFile = _tcstok_s(NULL, TEXT(";"), &szContext);
	while( szBinaryId && szBinaryFile )
	{
		MsiLogInfo(hInstaller, TEXT("Extracting %s -> %s\n"), szBinaryId, szBinaryFile);
		uiErrorCode = MsiExtractBinaryFile(hInstaller, szBinaryId, szBinaryFile);
		if( uiErrorCode != ERROR_SUCCESS )
		{
			MsiLogError(hInstaller, TEXT("Error %d. Failed to extract %s(%s) from database."), uiErrorCode, szBinaryId, szBinaryFile);
			break;
		}
		szBinaryId = _tcstok_s(NULL, TEXT(":"), &szContext);
		szBinaryFile = _tcstok_s(NULL, TEXT(";"), &szContext);
	}

	// Free trashed copy of szExtract
	HeapFree(GetProcessHeap(), 0, szTemp);

	// Only execute if files were successfully extracted
	if( uiErrorCode == ERROR_SUCCESS )
	{
		MsiExecuteCommand(&dwExitCode, hInstaller, szCommand, szArguments, szWorkingDirectory);
	}
	
	// Destructively parse szExtract and delete extracted files
	szBinaryId = _tcstok_s(szExtract, TEXT(":"), &szContext);
	szBinaryFile = _tcstok_s(NULL, TEXT(";"), &szContext);
	while( szBinaryId && szBinaryFile )
	{
		MsiLogInfo(hInstaller, TEXT("Removing %s\n"), szBinaryFile);
		DeleteFile(szBinaryFile);
		szBinaryId = _tcstok_s(NULL, TEXT(":"), &szContext);
		szBinaryFile = _tcstok_s(NULL, TEXT(";"), &szContext);
	}

	// Restore the old working directory
	SetCurrentDirectory(szOldWorkingDirectory);

	// Free all memory and clean up handles
	HeapFree(GetProcessHeap(), 0, szExtract);
	HeapFree(GetProcessHeap(), 0, szWorkingDirectory);
	HeapFree(GetProcessHeap(), 0, szArguments);
	HeapFree(GetProcessHeap(), 0, szCommand);

	MsiCloseHandle(hRecord);
	MsiCloseHandle(hView);
	MsiCloseHandle(hDatabase);

	return uiErrorCode == ERROR_SUCCESS ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE;
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction(MSIHANDLE hInstaller)
{
	LPTSTR szActionId;
	UINT uiReturn;

	// Get the last set CmdActionId
	MsiGetPropertyValue(hInstaller, TEXT("CmdActionId"), &szActionId);

	// Execute the action
	uiReturn = ExecuteAction(hInstaller, szActionId);

	// Release the allocated property string
	HeapFree(GetProcessHeap(), 0, szActionId);

	return uiReturn;
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction1(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("1"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction2(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("2"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction3(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("3"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction4(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("4"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction5(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("5"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction6(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("6"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction7(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("7"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction8(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("8"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction9(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("9"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction10(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("10"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction11(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("11"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction12(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("12"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction13(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("13"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction14(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("14"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction15(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("15"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction16(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("16"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction17(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("17"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction18(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("18"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction19(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("19"));
}

extern "C" __declspec(dllexport) UINT __stdcall ExecuteAction20(MSIHANDLE hInstaller)
{
	return ExecuteAction(hInstaller, TEXT("20"));
}


BOOL APIENTRY DllMain( HMODULE hModule,
					  DWORD  ul_reason_for_call,
					  LPVOID lpReserved
					  )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ca\xcmdca\dll\XCmdCA.h ===
#pragma once

#define MSIRECORDFORMAT_NONE         0
#define MSIRECORDFORMAT_FORMATTED    1
#define MSIRECORDFORMAT_ENV          2
#define MSIRECORDFORMAT_ENVFORMATTED 3

void MsiLogError(MSIHANDLE hInstaller, const TCHAR *pszFormat, ...);
void MsiLogInfo(MSIHANDLE hInstaller, const TCHAR *pszFormat, ...);
void MsiLogMessage(MSIHANDLE hInstaller, INSTALLMESSAGE eMessageType, const TCHAR *pszFormat, ...);
void MsiLogErrorA(MSIHANDLE hInstaller, const char *pszFormat, ...);
void MsiLogInfoA(MSIHANDLE hInstaller, const char *pszFormat, ...);
void MsiLogMessageA(MSIHANDLE hInstaller, INSTALLMESSAGE eMessageType, const char *pszFormat, ...);

UINT MsiDatabaseCreateQueryView(MSIHANDLE *phView, MSIHANDLE hDatabase, LPTSTR szQuery, MSIHANDLE hParameters);
UINT MsiGetStringField( MSIHANDLE hInstall, MSIHANDLE hRecHandle, int nFieldIdx, PTCHAR *pszBuffer );
UINT MsiRecordGetStringField(MSIHANDLE hInstall, MSIHANDLE hRecord, UINT uiField, DWORD dwFormatFlags, PTCHAR *pszBuffer);
HRESULT MsiEscapeString(MSIHANDLE hInstall, TCHAR *szInput, TCHAR **szOutput);
HRESULT MsiEscapeStringA(MSIHANDLE hInstall, char *szInput, char **szOutput);
HRESULT MsiExpandFormattedString(MSIHANDLE hInstall, const TCHAR *formattedString, TCHAR **expanded);
HRESULT ExpandEnvironmentVariables(const TCHAR *sourceString, TCHAR **expanded);
HRESULT MsiExtractBinaryFile(MSIHANDLE hInstaller, LPTSTR szBinaryId, LPTSTR szOutputFile);
UINT MsiGetPropertyValue(MSIHANDLE hInstaller, LPCTSTR szName, LPTSTR *szValue);

BOOL MsiExecuteCommand(LPDWORD exitCode, MSIHANDLE hInstaller, LPTSTR szCommand, LPTSTR szArguments, LPTSTR szWorkingDir);

LPTSTR CopyString(LPCTSTR str);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\common\CommonDeployment\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\CatalogTools\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_editorialwebsite_none_12.4.56.0_none_98f94dc5913af3a2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=editorialwebsite
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa.manifest
XP_MANIFEST_PATH=manifests\x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa.cat
XP_CATALOG_PATH=manifests\x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa.cat
XP_PAYLOAD_PATH=x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=editorialwebsite,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\CatalogTools\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

delete_webroot_files :
    @echo Deleting www_webroot_files.wxs
    del www_webroot_files.wxs

www_webroot_files.wxs :
!if "$(LINKONLY)" == "1"
    @echo Building $@
    cscript /e:jscript /nologo $(INETROOT)\public\ext\dir2wix\dir2wix.js $(_NTTREE)\server\ContentIngestion\CatalogTools www_editorial_web_site_webroot WebRoot www_editorial_web_site_webroot_feature $@ & \
    if errorlevel 1 echo NMAKE : dir2wix.js: error building $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\CatalogTools\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_editorialwebsite_none_12.4.56.0_none_98f94dc5913af3a2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=editorialwebsite
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa.manifest
XP_MANIFEST_PATH=manifests\x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa.cat
XP_CATALOG_PATH=manifests\x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa.cat
XP_PAYLOAD_PATH=x86_editorialwebsite_no-public-key_12.4.56.0_x-ww_8a1079aa
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=editorialwebsite,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\common\CommonDeployment\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_commondeployment_none_12.4.56.0_none_ba54b0d647515e86
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=commondeployment
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86.manifest
XP_MANIFEST_PATH=manifests\x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86.cat
XP_CATALOG_PATH=manifests\x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86.cat
XP_PAYLOAD_PATH=x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=commondeployment,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\common\CommonDeployment\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_commondeployment_none_12.4.56.0_none_ba54b0d647515e86
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=commondeployment
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86.manifest
XP_MANIFEST_PATH=manifests\x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86.cat
XP_CATALOG_PATH=manifests\x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86.cat
XP_PAYLOAD_PATH=x86_commondeployment_no-public-key_12.4.56.0_x-ww_cf413f86
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=commondeployment,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livelsp\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\ContentIngestion\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

delete_webroot_files :
    @echo Deleting www_webroot_files.wxs
    del www_webroot_files.wxs

www_webroot_files.wxs :
!if "$(LINKONLY)" == "1"
    @echo Building $@
    cscript /e:jscript /nologo $(INETROOT)\public\ext\dir2wix\dir2wix.js $(_NTTREE)\server\CatalogWebService\ www_catalog_web_service_webroot WebRoot www_catalog_web_service_webroot_feature $@ & \
    if errorlevel 1 echo NMAKE : dir2wix.js: error building $@
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\database\scripts\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__scripts_2_none_12.4.56.0_none_d2852e45a5f29242
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_scripts_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12.manifest
XP_MANIFEST_PATH=manifests\x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12.cat
XP_CATALOG_PATH=manifests\x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12.cat
XP_PAYLOAD_PATH=x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_scripts_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\database\scripts\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__scripts_2_none_12.4.56.0_none_d2852e45a5f29242
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_scripts_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12.manifest
XP_MANIFEST_PATH=manifests\x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12.cat
XP_CATALOG_PATH=manifests\x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12.cat
XP_PAYLOAD_PATH=x86__scripts_2_no-public-key_12.4.56.0_x-ww_23615e12
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_scripts_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livelsp\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__livelsp_4_none_12.4.56.0_none_bd257d2b737746b5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_livelsp_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9.manifest
XP_MANIFEST_PATH=manifests\x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9.cat
XP_CATALOG_PATH=manifests\x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9.cat
XP_PAYLOAD_PATH=x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_livelsp_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livematch\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livelsp\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__livelsp_4_none_12.4.56.0_none_bd257d2b737746b5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_livelsp_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9.manifest
XP_MANIFEST_PATH=manifests\x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9.cat
XP_CATALOG_PATH=manifests\x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9.cat
XP_PAYLOAD_PATH=x86__livelsp_4_no-public-key_12.4.56.0_x-ww_03bb64c9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_livelsp_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livestats\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livematch\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__livematch_0_none_12.4.56.0_none_93ffabfdc948e747
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_livematch_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21.manifest
XP_MANIFEST_PATH=manifests\x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21.cat
XP_CATALOG_PATH=manifests\x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21.cat
XP_PAYLOAD_PATH=x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_livematch_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livematch\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__livematch_0_none_12.4.56.0_none_93ffabfdc948e747
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_livematch_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21.manifest
XP_MANIFEST_PATH=manifests\x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21.cat
XP_CATALOG_PATH=manifests\x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21.cat
XP_PAYLOAD_PATH=x86__livematch_0_no-public-key_12.4.56.0_x-ww_8af72c21
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_livematch_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livestats\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__livestats_1_none_12.4.56.0_none_32059b9e26f9bca2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_livestats_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c.manifest
XP_MANIFEST_PATH=manifests\x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c.cat
XP_CATALOG_PATH=manifests\x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c.cat
XP_PAYLOAD_PATH=x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_livestats_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livetools\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc

$(TARGETNAME).wxs:wxs\$(TARGETNAME).wxs
!IF "$(LINKONLY)"=="1"
    copy $** $@
    for /f %i in ('uuidgen -c') do rep -find:'PRODUCT_GUID' -replace:'%i' $@
    for /f %i in ('uuidgen -c') do rep -find:'PACKAGE_GUID' -replace:'%i' $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livetools\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_microsoft.ems.tools.livetools_none_12.4.56.0_none_d614835ca5d0528b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.ems.tools.livetools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f.manifest
XP_MANIFEST_PATH=manifests\x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f.cat
XP_CATALOG_PATH=manifests\x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f.cat
XP_PAYLOAD_PATH=x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.ems.tools.livetools,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livestats\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__livestats_1_none_12.4.56.0_none_32059b9e26f9bca2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_livestats_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c.manifest
XP_MANIFEST_PATH=manifests\x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c.cat
XP_CATALOG_PATH=manifests\x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c.cat
XP_PAYLOAD_PATH=x86__livestats_1_no-public-key_12.4.56.0_x-ww_174ab77c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_livestats_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\livetools\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_microsoft.ems.tools.livetools_none_12.4.56.0_none_d614835ca5d0528b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=microsoft.ems.tools.livetools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f.manifest
XP_MANIFEST_PATH=manifests\x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f.cat
XP_CATALOG_PATH=manifests\x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f.cat
XP_PAYLOAD_PATH=x86_microsoft.ems.tools.livetools_no-public-key_12.4.56.0_x-ww_9553ab4f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=microsoft.ems.tools.livetools,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\machineban\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\machinehelper\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\machineban\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__machineban_3_none_12.4.56.0_none_c33753adf25fa431
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_machineban_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1.manifest
XP_MANIFEST_PATH=manifests\x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1.cat
XP_CATALOG_PATH=manifests\x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1.cat
XP_PAYLOAD_PATH=x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_machineban_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\msgtool\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\machineban\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__machineban_3_none_12.4.56.0_none_c33753adf25fa431
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_machineban_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1.manifest
XP_MANIFEST_PATH=manifests\x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1.cat
XP_CATALOG_PATH=manifests\x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1.cat
XP_PAYLOAD_PATH=x86__machineban_3_no-public-key_12.4.56.0_x-ww_459637f1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_machineban_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\machinehelper\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__machinehelper_3_none_12.4.56.0_none_2cdd3c4df4ff8aea
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_machinehelper_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280.manifest
XP_MANIFEST_PATH=manifests\x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280.cat
XP_CATALOG_PATH=manifests\x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280.cat
XP_PAYLOAD_PATH=x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_machinehelper_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\msgtool\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__msgtool_0_none_12.4.56.0_none_5e112885b6bc8c6f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_msgtool_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61.manifest
XP_MANIFEST_PATH=manifests\x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61.cat
XP_CATALOG_PATH=manifests\x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61.cat
XP_PAYLOAD_PATH=x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_msgtool_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\machinehelper\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__machinehelper_3_none_12.4.56.0_none_2cdd3c4df4ff8aea
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_machinehelper_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280.manifest
XP_MANIFEST_PATH=manifests\x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280.cat
XP_CATALOG_PATH=manifests\x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280.cat
XP_PAYLOAD_PATH=x86__machinehelper_3_no-public-key_12.4.56.0_x-ww_39d8b280
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_machinehelper_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\partnermgr\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\msgtool\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__msgtool_0_none_12.4.56.0_none_5e112885b6bc8c6f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_msgtool_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61.manifest
XP_MANIFEST_PATH=manifests\x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61.cat
XP_CATALOG_PATH=manifests\x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61.cat
XP_PAYLOAD_PATH=x86__msgtool_0_no-public-key_12.4.56.0_x-ww_9f649d61
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_msgtool_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\propcert\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\partnermgr\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__partnermgr_0_none_12.4.56.0_none_020fe1e1d99d60a4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_partnermgr_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556.manifest
XP_MANIFEST_PATH=manifests\x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556.cat
XP_CATALOG_PATH=manifests\x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556.cat
XP_PAYLOAD_PATH=x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_partnermgr_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\partnermgr\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__partnermgr_0_none_12.4.56.0_none_020fe1e1d99d60a4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_partnermgr_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556.manifest
XP_MANIFEST_PATH=manifests\x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556.cat
XP_CATALOG_PATH=manifests\x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556.cat
XP_PAYLOAD_PATH=x86__partnermgr_0_no-public-key_12.4.56.0_x-ww_4aa7d556
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_partnermgr_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\propxqs\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\propcert\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__propcert_3_none_12.4.56.0_none_3cb48b7949cbc7a6
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_propcert_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0.manifest
XP_MANIFEST_PATH=manifests\x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0.cat
XP_CATALOG_PATH=manifests\x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0.cat
XP_PAYLOAD_PATH=x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_propcert_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\refurbfeedprocessor\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\propcert\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__propcert_3_none_12.4.56.0_none_3cb48b7949cbc7a6
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_propcert_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0.manifest
XP_MANIFEST_PATH=manifests\x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0.cat
XP_CATALOG_PATH=manifests\x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0.cat
XP_PAYLOAD_PATH=x86__propcert_3_no-public-key_12.4.56.0_x-ww_9a5a9bb0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_propcert_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\propxqs\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__propxqs_2_none_12.4.56.0_none_e43836311ae9ec6b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_propxqs_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1.manifest
XP_MANIFEST_PATH=manifests\x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1.cat
XP_CATALOG_PATH=manifests\x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1.cat
XP_PAYLOAD_PATH=x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_propxqs_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\refurbfeedprocessor\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__refurbfeedprocessor_3_none_12.4.56.0_none_59aac9f37adb8f97
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_refurbfeedprocessor_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d.manifest
XP_MANIFEST_PATH=manifests\x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d.cat
XP_CATALOG_PATH=manifests\x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d.cat
XP_PAYLOAD_PATH=x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_refurbfeedprocessor_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\propxqs\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__propxqs_2_none_12.4.56.0_none_e43836311ae9ec6b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_propxqs_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1.manifest
XP_MANIFEST_PATH=manifests\x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1.cat
XP_CATALOG_PATH=manifests\x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1.cat
XP_PAYLOAD_PATH=x86__propxqs_2_no-public-key_12.4.56.0_x-ww_bead49c1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_propxqs_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\removepi\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\refurbfeedprocessor\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__refurbfeedprocessor_3_none_12.4.56.0_none_59aac9f37adb8f97
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_refurbfeedprocessor_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d.manifest
XP_MANIFEST_PATH=manifests\x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d.cat
XP_CATALOG_PATH=manifests\x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d.cat
XP_PAYLOAD_PATH=x86__refurbfeedprocessor_3_no-public-key_12.4.56.0_x-ww_23e8428d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_refurbfeedprocessor_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\sput\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\removepi\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__removepi_4_none_12.4.56.0_none_f461560a8fcac3bb
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_removepi_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847.manifest
XP_MANIFEST_PATH=manifests\x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847.cat
XP_CATALOG_PATH=manifests\x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847.cat
XP_PAYLOAD_PATH=x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_removepi_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\removepi\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__removepi_4_none_12.4.56.0_none_f461560a8fcac3bb
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_removepi_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847.manifest
XP_MANIFEST_PATH=manifests\x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847.cat
XP_CATALOG_PATH=manifests\x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847.cat
XP_PAYLOAD_PATH=x86__removepi_4_no-public-key_12.4.56.0_x-ww_4c557847
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_removepi_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\stutil\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\sput\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__sput_4_none_12.4.56.0_none_7e397fb7b2511512
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_sput_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6.manifest
XP_MANIFEST_PATH=manifests\x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6.cat
XP_CATALOG_PATH=manifests\x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6.cat
XP_PAYLOAD_PATH=x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_sput_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\systemcheck\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\sput\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__sput_4_none_12.4.56.0_none_7e397fb7b2511512
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_sput_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6.manifest
XP_MANIFEST_PATH=manifests\x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6.cat
XP_CATALOG_PATH=manifests\x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6.cat
XP_PAYLOAD_PATH=x86__sput_4_no-public-key_12.4.56.0_x-ww_0afae8a6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_sput_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\stutil\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__stutil_2_none_12.4.56.0_none_c69e440b82887c85
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_stutil_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b.manifest
XP_MANIFEST_PATH=manifests\x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b.cat
XP_CATALOG_PATH=manifests\x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b.cat
XP_PAYLOAD_PATH=x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_stutil_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\stutil\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__stutil_2_none_12.4.56.0_none_c69e440b82887c85
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_stutil_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b.manifest
XP_MANIFEST_PATH=manifests\x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b.cat
XP_CATALOG_PATH=manifests\x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b.cat
XP_PAYLOAD_PATH=x86__stutil_2_no-public-key_12.4.56.0_x-ww_ff10736b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_stutil_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\tokenimport\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\systemcheck\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__systemcheck_1_none_12.4.56.0_none_b287e84d11d5fc48
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_systemcheck_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322.manifest
XP_MANIFEST_PATH=manifests\x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322.cat
XP_CATALOG_PATH=manifests\x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322.cat
XP_PAYLOAD_PATH=x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_systemcheck_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\systemcheck\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__systemcheck_1_none_12.4.56.0_none_b287e84d11d5fc48
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_systemcheck_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322.manifest
XP_MANIFEST_PATH=manifests\x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322.cat
XP_CATALOG_PATH=manifests\x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322.cat
XP_PAYLOAD_PATH=x86__systemcheck_1_no-public-key_12.4.56.0_x-ww_f56c6322
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_systemcheck_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\vouchermgr\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\tokenimport\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__tokenimport_0_none_12.4.56.0_none_27677b80701e97da
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_tokenimport_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6.manifest
XP_MANIFEST_PATH=manifests\x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6.cat
XP_CATALOG_PATH=manifests\x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6.cat
XP_PAYLOAD_PATH=x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_tokenimport_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xappadmin\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\vouchermgr\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__vouchermgr_3_none_12.4.56.0_none_aa497774b5f5cf03
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_vouchermgr_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293.manifest
XP_MANIFEST_PATH=manifests\x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293.cat
XP_CATALOG_PATH=manifests\x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293.cat
XP_PAYLOAD_PATH=x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_vouchermgr_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\tokenimport\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__tokenimport_0_none_12.4.56.0_none_27677b80701e97da
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_tokenimport_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6.manifest
XP_MANIFEST_PATH=manifests\x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6.cat
XP_CATALOG_PATH=manifests\x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6.cat
XP_PAYLOAD_PATH=x86__tokenimport_0_no-public-key_12.4.56.0_x-ww_deffa3c6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_tokenimport_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xblcfg\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\vouchermgr\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__vouchermgr_3_none_12.4.56.0_none_aa497774b5f5cf03
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_vouchermgr_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293.manifest
XP_MANIFEST_PATH=manifests\x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293.cat
XP_CATALOG_PATH=manifests\x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293.cat
XP_PAYLOAD_PATH=x86__vouchermgr_3_no-public-key_12.4.56.0_x-ww_59b8f293
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_vouchermgr_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xappadmin\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xappadmin_3_none_12.4.56.0_none_04405dae58fc4ec9
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xappadmin_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191.manifest
XP_MANIFEST_PATH=manifests\x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191.cat
XP_CATALOG_PATH=manifests\x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191.cat
XP_PAYLOAD_PATH=x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xappadmin_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xappadmin\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xappadmin_3_none_12.4.56.0_none_04405dae58fc4ec9
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xappadmin_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191.manifest
XP_MANIFEST_PATH=manifests\x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191.cat
XP_CATALOG_PATH=manifests\x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191.cat
XP_PAYLOAD_PATH=x86__xappadmin_3_no-public-key_12.4.56.0_x-ww_3683d191
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xappadmin_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xkeymgr\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xblcfg\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xblcfg_3_none_12.4.56.0_none_2a912879883ec72f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xblcfg_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b.manifest
XP_MANIFEST_PATH=manifests\x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b.cat
XP_CATALOG_PATH=manifests\x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b.cat
XP_PAYLOAD_PATH=x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xblcfg_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xkeymgr\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xkeymgr_3_none_12.4.56.0_none_1971a664e9edca94
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xkeymgr_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c.manifest
XP_MANIFEST_PATH=manifests\x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c.cat
XP_CATALOG_PATH=manifests\x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c.cat
XP_PAYLOAD_PATH=x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xkeymgr_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xmgmtc\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xblcfg\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xblcfg_3_none_12.4.56.0_none_2a912879883ec72f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xblcfg_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b.manifest
XP_MANIFEST_PATH=manifests\x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b.cat
XP_CATALOG_PATH=manifests\x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b.cat
XP_PAYLOAD_PATH=x86__xblcfg_3_no-public-key_12.4.56.0_x-ww_13d4dd0b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xblcfg_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xsigner\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xkeymgr\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xkeymgr_3_none_12.4.56.0_none_1971a664e9edca94
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xkeymgr_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c.manifest
XP_MANIFEST_PATH=manifests\x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c.cat
XP_CATALOG_PATH=manifests\x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c.cat
XP_PAYLOAD_PATH=x86__xkeymgr_3_no-public-key_12.4.56.0_x-ww_41afde3c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xkeymgr_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xsigner\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xsigner_0_none_12.4.56.0_none_07a49d5d29eb4724
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xsigner_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a.manifest
XP_MANIFEST_PATH=manifests\x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a.cat
XP_CATALOG_PATH=manifests\x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a.cat
XP_PAYLOAD_PATH=x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xsigner_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xmgmtc\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xmgmtc_3_none_12.4.56.0_none_4585e7ee627e7c63
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xmgmtc_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3.manifest
XP_MANIFEST_PATH=manifests\x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3.cat
XP_CATALOG_PATH=manifests\x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3.cat
XP_PAYLOAD_PATH=x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xmgmtc_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xmgmtc\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xmgmtc_3_none_12.4.56.0_none_4585e7ee627e7c63
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xmgmtc_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3.manifest
XP_MANIFEST_PATH=manifests\x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3.cat
XP_CATALOG_PATH=manifests\x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3.cat
XP_PAYLOAD_PATH=x86__xmgmtc_3_no-public-key_12.4.56.0_x-ww_7b00b4d3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xmgmtc_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\_template\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\eventsysmomplugin\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\esp\xbltools\xsigner\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xsigner_0_none_12.4.56.0_none_07a49d5d29eb4724
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xsigner_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a.manifest
XP_MANIFEST_PATH=manifests\x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a.cat
XP_CATALOG_PATH=manifests\x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a.cat
XP_PAYLOAD_PATH=x86__xsigner_0_no-public-key_12.4.56.0_x-ww_49e6664a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xsigner_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\aamodule\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\aamodule_partner\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\aamodule\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_aamodule_none_12.4.56.0_none_045bc29e428ebf6a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=aamodule
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2.manifest
XP_MANIFEST_PATH=manifests\x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2.cat
XP_CATALOG_PATH=manifests\x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2.cat
XP_PAYLOAD_PATH=x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=aamodule,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\aamodule\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_aamodule_none_12.4.56.0_none_045bc29e428ebf6a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=aamodule
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2.manifest
XP_MANIFEST_PATH=manifests\x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2.cat
XP_CATALOG_PATH=manifests\x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2.cat
XP_PAYLOAD_PATH=x86_aamodule_no-public-key_12.4.56.0_x-ww_0bc050c2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=aamodule,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\aamodule_partner\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_activeauth_partner_msi_none_12.4.56.0_none_97b4c548b35b416b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_activeauth_partner_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9.cat
XP_PAYLOAD_PATH=x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_activeauth_partner_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\activeauth\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\aamodule_partner\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_activeauth_partner_msi_none_12.4.56.0_none_97b4c548b35b416b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_activeauth_partner_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9.cat
XP_PAYLOAD_PATH=x86_frontdoor_activeauth_partner_msi_no-public-key_12.4.56.0_x-ww_e9f954d9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_activeauth_partner_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\catalog\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\cron\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\download\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\feedback\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\livecache\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\liveinfo\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\liveproxy\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\lsp\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\activeauth\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_activeauth_msi_none_12.4.56.0_none_9a3fea7e5950d528
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_activeauth_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790.cat
XP_PAYLOAD_PATH=x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_activeauth_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\activeauth\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_activeauth_msi_none_12.4.56.0_none_9a3fea7e5950d528
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_activeauth_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790.cat
XP_PAYLOAD_PATH=x86_frontdoor_activeauth_msi_no-public-key_12.4.56.0_x-ww_1d129790
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_activeauth_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\MarketplaceCatalog\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\match\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\lsp\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_lsp_msi_none_12.4.56.0_none_5ce99f2e13d1cc27
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_lsp_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b.cat
XP_PAYLOAD_PATH=x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_lsp_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\messaging\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\profileshim\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\presence\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\progressshim\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\query\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\ratings\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\signature\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\stats\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\storage\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\lsp\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_lsp_msi_none_12.4.56.0_none_5ce99f2e13d1cc27
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_lsp_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b.cat
XP_PAYLOAD_PATH=x86_frontdoor_lsp_msi_no-public-key_12.4.56.0_x-ww_07f6a49b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_lsp_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\sts\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\svctunnel\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\vortex\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xarb\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xcrypto\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\signature\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_signature_msi_none_12.4.56.0_none_5165cb16835170d2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_signature_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a.cat
XP_PAYLOAD_PATH=x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_signature_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\signature\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_signature_msi_none_12.4.56.0_none_5165cb16835170d2
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_signature_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a.cat
XP_PAYLOAD_PATH=x86_frontdoor_signature_msi_no-public-key_12.4.56.0_x-ww_10b5940a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_signature_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xmachine\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xrlscan\xrlscan32\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xcrypto\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_xcrypto_msi_none_12.4.56.0_none_1600ac2ce29dca91
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_xcrypto_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b.cat
XP_PAYLOAD_PATH=x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_xcrypto_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xcrypto\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_xcrypto_msi_none_12.4.56.0_none_1600ac2ce29dca91
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_xcrypto_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b.cat
XP_PAYLOAD_PATH=x86_frontdoor_xcrypto_msi_no-public-key_12.4.56.0_x-ww_7f18236b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_xcrypto_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xrlscan\xrlscan64\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\XSts\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xuser\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\acceleration\acceleration\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\acceleration\PresenceCache\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\acceleration\NotificationCache\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xrlscan\xrlscan32\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_xrlscan32_msi_none_12.4.56.0_none_4d20e58462617096
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_xrlscan32_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320.cat
XP_PAYLOAD_PATH=x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_xrlscan32_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xsecsup\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\acceleration\ProfileCache\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\acceleration\template\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\cleanser\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\eventsink\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\frontdoors\xrlscan\xrlscan32\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_xrlscan32_msi_none_12.4.56.0_none_4d20e58462617096
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_xrlscan32_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320.cat
XP_PAYLOAD_PATH=x86_frontdoor_xrlscan32_msi_no-public-key_12.4.56.0_x-ww_25086320
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_xrlscan32_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\kdcsvc\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\cleanser\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_cleanser_msi_none_12.4.56.0_none_4246d484f8eac898
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_cleanser_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c.manifest
XP_MANIFEST_PATH=manifests\x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c.cat
XP_CATALOG_PATH=manifests\x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c.cat
XP_PAYLOAD_PATH=x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_cleanser_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\cleanser\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_cleanser_msi_none_12.4.56.0_none_4246d484f8eac898
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_cleanser_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c.manifest
XP_MANIFEST_PATH=manifests\x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c.cat
XP_CATALOG_PATH=manifests\x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c.cat
XP_PAYLOAD_PATH=x86__inh_cleanser_msi_no-public-key_12.4.56.0_x-ww_b1766a2c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_cleanser_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\lbsvr\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\sgsvc\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\kdcsvc\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_kdcsvc_msi_none_12.4.56.0_none_e031697649cc5fbf
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_kdcsvc_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b.manifest
XP_MANIFEST_PATH=manifests\x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b.cat
XP_CATALOG_PATH=manifests\x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b.cat
XP_PAYLOAD_PATH=x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_kdcsvc_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\kdcsvc\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_kdcsvc_msi_none_12.4.56.0_none_e031697649cc5fbf
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_kdcsvc_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b.manifest
XP_MANIFEST_PATH=manifests\x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b.cat
XP_CATALOG_PATH=manifests\x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b.cat
XP_PAYLOAD_PATH=x86__inh_kdcsvc_msi_no-public-key_12.4.56.0_x-ww_0f56564b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_kdcsvc_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\socialcache\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\udpadpt\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\vortex\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\wsreader\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\udpadpt\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_udpadpt_msi_none_12.4.56.0_none_789c1c5b0f9680e5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_udpadpt_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647.manifest
XP_MANIFEST_PATH=manifests\x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647.cat
XP_CATALOG_PATH=manifests\x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647.cat
XP_PAYLOAD_PATH=x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_udpadpt_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\wsreader\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_wsreader_msi_none_12.4.56.0_none_6668afa01f2674ac
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_wsreader_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094.manifest
XP_MANIFEST_PATH=manifests\x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094.cat
XP_CATALOG_PATH=manifests\x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094.cat
XP_PAYLOAD_PATH=x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_wsreader_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\xbanc\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\udpadpt\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_udpadpt_msi_none_12.4.56.0_none_789c1c5b0f9680e5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_udpadpt_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647.manifest
XP_MANIFEST_PATH=manifests\x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647.cat
XP_CATALOG_PATH=manifests\x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647.cat
XP_PAYLOAD_PATH=x86__inh_udpadpt_msi_no-public-key_12.4.56.0_x-ww_897da647
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_udpadpt_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\wsreader\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_wsreader_msi_none_12.4.56.0_none_6668afa01f2674ac
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_wsreader_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094.manifest
XP_MANIFEST_PATH=manifests\x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094.cat
XP_CATALOG_PATH=manifests\x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094.cat
XP_PAYLOAD_PATH=x86__inh_wsreader_msi_no-public-key_12.4.56.0_x-ww_2011a094
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_wsreader_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\xcache\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\xconnsrv\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\xds\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\xmgmt\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\xbanc\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_xbanc_msi_none_12.4.56.0_none_39a45dee0b69bc8b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_xbanc_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb.manifest
XP_MANIFEST_PATH=manifests\x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb.cat
XP_CATALOG_PATH=manifests\x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb.cat
XP_PAYLOAD_PATH=x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_xbanc_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\xpserver\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\xbanc\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_xbanc_msi_none_12.4.56.0_none_39a45dee0b69bc8b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_xbanc_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb.manifest
XP_MANIFEST_PATH=manifests\x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb.cat
XP_CATALOG_PATH=manifests\x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb.cat
XP_PAYLOAD_PATH=x86__inh_xbanc_msi_no-public-key_12.4.56.0_x-ww_f924f6eb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_xbanc_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\lsmonitor\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\lsp\installer\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\xmgmt\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_xmgmt_msi_none_12.4.56.0_none_c982eb7888f37ade
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_xmgmt_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878.manifest
XP_MANIFEST_PATH=manifests\x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878.cat
XP_CATALOG_PATH=manifests\x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878.cat
XP_PAYLOAD_PATH=x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_xmgmt_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\BetaManagement\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\Match\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\inh\xmgmt\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__inh_xmgmt_msi_none_12.4.56.0_none_c982eb7888f37ade
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_inh_xmgmt_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878.manifest
XP_MANIFEST_PATH=manifests\x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878.cat
XP_CATALOG_PATH=manifests\x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878.cat
XP_PAYLOAD_PATH=x86__inh_xmgmt_msi_no-public-key_12.4.56.0_x-ww_2041e878
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_inh_xmgmt_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\OfferManagement\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\ProductManagement\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\ReleaseManagement\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\SettingsManagement\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\Stats\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\Storage\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\SubscriptionFamily\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\TitleManagement\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\Mix\TokenManagement\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\partner\xblplatform\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\iisrunner\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\partner\xblplatform\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_esp_common_none_12.4.56.0_none_392b31cf4b961e74
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=esp_common
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e.manifest
XP_MANIFEST_PATH=manifests\x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e.cat
XP_CATALOG_PATH=manifests\x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e.cat
XP_PAYLOAD_PATH=x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=esp_common,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\iisrunner\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_iis_runner_none_12.4.56.0_none_bbf7f5edcd39c8c8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=iis_runner
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712.manifest
XP_MANIFEST_PATH=manifests\x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712.cat
XP_CATALOG_PATH=manifests\x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712.cat
XP_PAYLOAD_PATH=x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=iis_runner,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\installutil\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\partner\xblplatform\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_esp_common_none_12.4.56.0_none_392b31cf4b961e74
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=esp_common
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e.manifest
XP_MANIFEST_PATH=manifests\x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e.cat
XP_CATALOG_PATH=manifests\x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e.cat
XP_PAYLOAD_PATH=x86_esp_common_no-public-key_12.4.56.0_x-ww_d251a45e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=esp_common,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\iisrunner\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_iis_runner_none_12.4.56.0_none_bbf7f5edcd39c8c8
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=iis_runner
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712.manifest
XP_MANIFEST_PATH=manifests\x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712.cat
XP_CATALOG_PATH=manifests\x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712.cat
XP_PAYLOAD_PATH=x86_iis_runner_no-public-key_12.4.56.0_x-ww_36a40712
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=iis_runner,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\msierrors\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\installutil\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_install_util_wixobj_none_12.4.56.0_none_581151f2fc40436c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=install_util_wixobj
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760.manifest
XP_MANIFEST_PATH=manifests\x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760.cat
XP_CATALOG_PATH=manifests\x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760.cat
XP_PAYLOAD_PATH=x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=install_util_wixobj,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\installutil\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_install_util_wixobj_none_12.4.56.0_none_581151f2fc40436c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=install_util_wixobj
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760.manifest
XP_MANIFEST_PATH=manifests\x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760.cat
XP_CATALOG_PATH=manifests\x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760.cat
XP_PAYLOAD_PATH=x86_install_util_wixobj_no-public-key_12.4.56.0_x-ww_44883760
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=install_util_wixobj,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\msitools\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\msierrors\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_msierrors_none_12.4.56.0_none_8a4ded234245ef2a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=msierrors
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84.manifest
XP_MANIFEST_PATH=manifests\x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84.cat
XP_CATALOG_PATH=manifests\x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84.cat
XP_PAYLOAD_PATH=x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=msierrors,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\test\AAModuleIFDReflector\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\msitools\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_msi_tools_none_12.4.56.0_none_8c388be5729ba199
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=msi_tools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5.manifest
XP_MANIFEST_PATH=manifests\x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5.cat
XP_CATALOG_PATH=manifests\x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5.cat
XP_PAYLOAD_PATH=x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=msi_tools,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\msierrors\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_msierrors_none_12.4.56.0_none_8a4ded234245ef2a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=msierrors
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84.manifest
XP_MANIFEST_PATH=manifests\x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84.cat
XP_CATALOG_PATH=manifests\x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84.cat
XP_PAYLOAD_PATH=x86_msierrors_no-public-key_12.4.56.0_x-ww_1f81cb84
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=msierrors,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\private\msitools\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_msi_tools_none_12.4.56.0_none_8c388be5729ba199
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=msi_tools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5.manifest
XP_MANIFEST_PATH=manifests\x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5.cat
XP_CATALOG_PATH=manifests\x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5.cat
XP_PAYLOAD_PATH=x86_msi_tools_no-public-key_12.4.56.0_x-ww_01f5adb5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=msi_tools,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\test\testfd\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\test\AAModuleIFDReflector\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_aamoduleifdreflector_msi_none_12.4.56.0_none_f7bdfe267bd126f3
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_aamoduleifdreflector_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47.cat
XP_PAYLOAD_PATH=x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_aamoduleifdreflector_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\test\TestFdXsts\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\widgets\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xbl4xboxcom\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\test\AAModuleIFDReflector\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_frontdoor_aamoduleifdreflector_msi_none_12.4.56.0_none_f7bdfe267bd126f3
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=frontdoor_aamoduleifdreflector_msi
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47.manifest
XP_MANIFEST_PATH=manifests\x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47.cat
XP_CATALOG_PATH=manifests\x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47.cat
XP_PAYLOAD_PATH=x86_frontdoor_aamoduleifdreflector_msi_no-public-key_12.4.56.0_x-ww_3e158b47
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=frontdoor_aamoduleifdreflector_msi,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xbl4xboxcom\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xbl4xboxcom_none_12.4.56.0_none_f70cbab8f3faba80
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xbl4xboxcom
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72.manifest
XP_MANIFEST_PATH=manifests\x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72.cat
XP_CATALOG_PATH=manifests\x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72.cat
XP_PAYLOAD_PATH=x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xbl4xboxcom,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xbl4xboxcom\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xbl4xboxcom_none_12.4.56.0_none_f70cbab8f3faba80
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xbl4xboxcom
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72.manifest
XP_MANIFEST_PATH=manifests\x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72.cat
XP_CATALOG_PATH=manifests\x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72.cat
XP_PAYLOAD_PATH=x86_xbl4xboxcom_no-public-key_12.4.56.0_x-ww_a9868b72
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xbl4xboxcom,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xblob\preputil\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xblob\regclient\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xblob\regclient\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_regclientauto_none_12.4.56.0_none_c055a4aa31a1d73c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=regclientauto
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.manifest
XP_MANIFEST_PATH=manifests\x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.cat
XP_CATALOG_PATH=manifests\x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.cat
XP_PAYLOAD_PATH=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=regclientauto,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xblob\serverprep\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xblob\preputil\xblob-postprep.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
//using System.Reflection;
using System.Text;
//using System.Xml;
using System.Management;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.utilities2;


namespace xonline.tools.setup.xblob
{
    /// <summary>
    /// This program creates the TitleVault directory on Xblob. It is not intended for an expanded environment;
    /// This directory is created by hand in expanded environments.
    /// </summary>
    class PostPrep
    {
        [STAThread]
        static int Main(string[] args)
        {
            string server = (args.Length > 0) ? args[0] : Environment.MachineName;


            Console.WriteLine("XBLOB Title Prep Utility\n");

            try
            {

                string appRoot = Config.GetSetting(Setting.setup_approot);
                string tvRoot = Config.GetSetting(Setting.titlevault_root);


                // Titlevault root directory must exist in order for tools to work
                //-------------------------------------------------------------------------------------
                // Create it if it doesn't already exist
                //
                if (tvRoot != null)
                {
                    Console.WriteLine("TitleVault: [{0}]", tvRoot);
                    if (!Directory.Exists(tvRoot))
                    {
                        Console.WriteLine("          : Directory does not exist");
                        Directory.CreateDirectory(tvRoot);
                        Console.WriteLine("          : Directory created");
                    }
                    else
                    {
                        Console.WriteLine("          : Directory verified");
                    }
                }

                Console.WriteLine("\n");
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());

                //Console.ReadLine();
                return -1;
            }

            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xblob\regclient\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_regclientauto_none_12.4.56.0_none_c055a4aa31a1d73c
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=regclientauto
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.manifest
XP_MANIFEST_PATH=manifests\x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.cat
XP_CATALOG_PATH=manifests\x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924.cat
XP_PAYLOAD_PATH=x86_regclientauto_no-public-key_12.4.56.0_x-ww_4536e924
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=regclientauto,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xblob\serverprep\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xblobprep_none_12.4.56.0_none_4502b8ff8e42997a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblobprep
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98.manifest
XP_MANIFEST_PATH=manifests\x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98.cat
XP_CATALOG_PATH=manifests\x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98.cat
XP_PAYLOAD_PATH=x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblobprep,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xblob\serverprep\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xblobprep_none_12.4.56.0_none_4502b8ff8e42997a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblobprep
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98.manifest
XP_MANIFEST_PATH=manifests\x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98.cat
XP_CATALOG_PATH=manifests\x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98.cat
XP_PAYLOAD_PATH=x86_xblobprep_no-public-key_12.4.56.0_x-ww_77b88f98
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblobprep,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xlcatools\dll\CertMgr.h ===
//------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// CertMgr.h : Certificate Manager interface.
//
//------------------------------------------------------------------
#pragma once

//------------------------------------------------------------------
//  Includes
//------------------------------------------------------------------


//------------------------------------------------------------------
//  CCertMgr
//------------------------------------------------------------------
class CCertMgr
{
public:
    CCertMgr(void);
    ~CCertMgr(void);

    static HRESULT Add(    char* szStoreName, char* szStoreType, char* szFileName, char* szPassword);
    static HRESULT Remove( char* szStoreName, char* szStoreType, char* szFileName, char* szPassword);
    static HRESULT ViewStore( char* szStoreName );

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xlcatools\dll\CertMgr.cpp ===
//------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// CertMgr.cpp : Certificate Mgr class that calls into CAPICOM
//          To handle certificates.
//
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Includes
//------------------------------------------------------------------
#include "xlcastd.h"
#include "certmgr.h"

#include <atlbase.h>

#include <Userenv.h>

#pragma warning (disable : 4192)

//
// Import TLB from DLL 
//
// Note: Make sure either you have the DLL in the current directory, or point 
//       it to the correct directory on you drive.
//
#import "capicom.dll"

//
// Use CAPICOM namespace.
//
using namespace CAPICOM;

//------------------------------------------------------------------
//  Definitions
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Local Functions
//------------------------------------------------------------------
HRESULT LoadCertificate( BSTR bstrStoreName, BSTR bstrFileName, BSTR bstrPassword, ICertificate2Ptr pICert2 );


//------------------------------------------------------------------
//  CCertMgr
//------------------------------------------------------------------

CCertMgr::CCertMgr(void)
{
}

CCertMgr::~CCertMgr(void)
{
}

//------------------------------------------------------------------
//  Add:  Adds a certificate to the store.
//------------------------------------------------------------------
HRESULT CCertMgr::Add( char* szStoreName, char* szStoreType, char* szFileName, char* szPassword)
{
    HRESULT hr = S_OK;
    BSTR bstrStoreName= NULL;
    BSTR bstrFileName = NULL;
    BSTR bstrPassword = NULL;

    bool bUserStore =  _stricmp(szStoreType, "User") ? false : true;


    IStore2Ptr pIStore2(__uuidof(Store));

    _ASSERT( szStoreName != NULL );
    _ASSERT( szFileName != NULL );

    try
    {
        // allocate the bstrs
        bstrStoreName = SysAllocString( CA2W(szStoreName) );
        if ( bstrStoreName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        bstrFileName = SysAllocString( CA2W(szFileName) );
        if ( bstrFileName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        if ( szPassword != NULL )
        {
            bstrPassword = SysAllocString( CA2W(szPassword) );
            if ( bstrPassword == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        }
        else
        {
            bstrPassword = NULL;
        }
        
        if (FAILED(hr = pIStore2->Open( bUserStore ? CAPICOM_CURRENT_USER_STORE : CAPICOM_LOCAL_MACHINE_STORE,
                                        bstrStoreName, 
                                        CAPICOM_STORE_OPEN_READ_WRITE)))
        {
            goto Exit;
        }

        
        // load the certificate from the file.
        hr = pIStore2->Load( bstrFileName, bstrPassword, CAPICOM_KEY_STORAGE_DEFAULT );
        if ( FAILED(hr) )
        {
            goto Exit;
        }

    }
    catch (_com_error e) 
    {
        hr = e.Error();
    }
    catch(...)
    {
        hr = CAPICOM_E_UNKNOWN;
    }

Exit:
    SysFreeString( bstrStoreName );
    SysFreeString( bstrFileName );

    // really clean up the password.
    SecureZeroMemory( bstrPassword, SysStringByteLen(bstrPassword) );
    SysFreeString( bstrPassword );

    if ( pIStore2 )
    {
        pIStore2.Release();
    }

    return hr;
}

//------------------------------------------------------------------
//  Remove:  Removes a certificate from the store if it exists.
//------------------------------------------------------------------
HRESULT CCertMgr::Remove(char* szStoreName, char* szStoreType, char* szFileName, char* szPassword )
{
    HRESULT hr = S_OK;
    IStore2Ptr pIStore2(__uuidof(Store));
    ICertificate2Ptr pICert2(__uuidof(Certificate));
    BSTR bstrStoreName= NULL;
    BSTR bstrFileName = NULL;
    BSTR bstrPassword = NULL;

    bool bUserStore =  _stricmp(szStoreType, "User") ? false : true;

    _ASSERT( szStoreName != NULL );
    _ASSERT( szFileName != NULL );

    try
    {
        // allocate the bstrs
        bstrStoreName = SysAllocString( CA2W(szStoreName) );
        if ( bstrStoreName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        bstrFileName = SysAllocString( CA2W(szFileName) );
        if ( bstrFileName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        if ( szPassword == NULL )
        {
            bstrPassword = NULL;
        }
        else
        {
            bstrPassword = SysAllocString( CA2W(szPassword) );
            if ( bstrPassword == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
        }


        //  open the certificate store.
        if (FAILED(hr = pIStore2->Open( bUserStore ? CAPICOM_CURRENT_USER_STORE : CAPICOM_LOCAL_MACHINE_STORE,
                                        bstrStoreName, 
                                      CAPICOM_STORE_OPEN_READ_WRITE)))
        {
            goto Exit;
        }

        
        // load the certificate
        hr = LoadCertificate( bstrStoreName, bstrFileName, bstrPassword, pICert2 );
        if ( FAILED(hr) )
        {
            goto Exit;
        }

        // load the certificate from the file.
        hr = pIStore2->Remove( pICert2 );
        if ( FAILED(hr) )
        {
            goto Exit;
        }

    }
    catch (_com_error e) 
    {
        hr = e.Error();
    }
    catch(...)
    {
        hr = CAPICOM_E_UNKNOWN;
    }

Exit:
    SysFreeString( bstrStoreName );
    SysFreeString( bstrFileName );

    // really clean up the password.
    SecureZeroMemory( bstrPassword, SysStringByteLen(bstrPassword) );
    SysFreeString( bstrPassword );

    if ( pIStore2 )
    {
        pIStore2.Release();
    }

    if ( pICert2 )
    {
        pICert2.Release();
    }

    return hr;
}

//------------------------------------------------------------------
//  ViewStore:  Displays all the certificates in the store.
//------------------------------------------------------------------
HRESULT CCertMgr::ViewStore( char* szStoreName )
{
    HRESULT hr = S_OK;
    IStorePtr pIStore(__uuidof(Store));
    BSTR bstrStoreName= NULL;

    _ASSERT( szStoreName != NULL );

    try
    {
        bstrStoreName = SysAllocString( CA2W(szStoreName) );
        if ( bstrStoreName == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }


        if (FAILED(hr = pIStore->Open(CAPICOM_CURRENT_USER_STORE,
                                      bstrStoreName, 
                                      CAPICOM_STORE_OPEN_READ_ONLY)))
        {
            goto Exit;  
        }

        //
        // Display all certificate in the store.
        //
        IUnknownPtr     pIUnknown;
        IEnumVARIANTPtr pIEnum;
        _variant_t      pDisp;
        ULONG           ulFetched;

        //
        // Get _NewEnum of Certificates collection.
        //
        if (FAILED(hr = pIStore->Certificates->get__NewEnum(&pIUnknown)))
        {
            goto Exit;  
        }

        //
        // Get IEnumVARIANT interface of _NewEnum.
        //
        if (FAILED(hr = pIUnknown->QueryInterface(IID_IEnumVARIANT, (void **) &pIEnum)))
        {
            goto Exit;  
        }

        //
        // Now loop through all items in the collection.
        //
        while (pIEnum->Next(1, &pDisp, &ulFetched) == S_OK)
        {
            //
            // Display the certificate.
            //
            if (FAILED(hr = ((ICertificatePtr) pDisp.pdispVal)->Display()))
            {
                goto Exit;  
            }

            pDisp.Clear();
        }
    }
    catch (_com_error e) 
    {
        hr = e.Error();
    }
    catch(...)
    {
        hr = CAPICOM_E_UNKNOWN;
    }

Exit:
    if ( pIStore )
    {
        pIStore.Release();
    }

    return (int) hr;

}

//------------------------------------------------------------------
//  LoadCertificate:  Loads a certificate from file into the
//      given cert object.
//      Note:  The object must exists first.
//------------------------------------------------------------------
HRESULT LoadCertificate( BSTR bstrStoreName, BSTR bstrFileName, BSTR bstrPassword, ICertificate2Ptr pICert2 )
{
    HRESULT hr = S_OK;

    _ASSERT( bstrStoreName != NULL );
    _ASSERT( bstrFileName != NULL );
    _ASSERT( pICert2 != NULL );

    try
    {
        // load the certificate from the file.
        hr = pICert2->Load( bstrFileName, bstrPassword, CAPICOM_KEY_STORAGE_DEFAULT , CAPICOM_CURRENT_USER_KEY );
        if ( FAILED(hr) )
        {
            goto Exit;
        }

    }
    catch (_com_error e) 
    {
        hr = e.Error();
    }
    catch(...)
    {
        hr = CAPICOM_E_UNKNOWN;
    }

Exit:
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xlcatools\dll\xlcastd.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// XLCATools.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xlcatools\dll\XLCATools.h ===
//------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// XLCATools.h : Interface for the entry point for the DLL application.
//
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Includes
//------------------------------------------------------------------
#include <msi.h>

// brings up a file browse window on call.
UINT __stdcall FileBrowse(MSIHANDLE hInstall);

// manage certificate tags.
UINT __stdcall ConfigureCerts(MSIHANDLE hInstall);
UINT __stdcall InstallCerts(MSIHANDLE hInstall);
UINT __stdcall RollbackCerts(MSIHANDLE hInstall);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xlcatools\dll\xlcastd.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once


// Windows Header Files:
#include <windows.h>

#include <tchar.h>
#include <shellapi.h>
#include <shlobj.h>
#include <msiquery.h>
#include <crtdbg.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xlcatools\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xlcatools_none_12.4.56.0_none_5b7f492268215fc5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlcatools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f.manifest
XP_MANIFEST_PATH=manifests\x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f.cat
XP_CATALOG_PATH=manifests\x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f.cat
XP_PAYLOAD_PATH=x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlcatools,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xlcatools\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xlcatools_none_12.4.56.0_none_5b7f492268215fc5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xlcatools
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f.manifest
XP_MANIFEST_PATH=manifests\x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f.cat
XP_CATALOG_PATH=manifests\x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f.cat
XP_PAYLOAD_PATH=x86_xlcatools_no-public-key_12.4.56.0_x-ww_8279ea1f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xlcatools,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\msi\xlcatools\dll\XLCATools.cpp ===
//------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// XLCATools.cpp : Defines the entry point for the DLL application.
//
//------------------------------------------------------------------


//------------------------------------------------------------------
//  Includes
//------------------------------------------------------------------
#include "xlcastd.h"
#include "XLCATools.h"
#include "certmgr.h"
#include <atlbase.h>


#include <strsafe.h>
#include <msidefs.h>

#include <Lm.h>
#include <Userenv.h>

//------------------------------------------------------------------
//  Definitions
//------------------------------------------------------------------
#define ExitOnErrorLog( x, y ) { if ( x != ERROR_SUCCESS ) { PrintLog( hInstall, INSTALLMESSAGE_ERROR, y, x ); x=ERROR_INSTALL_FAILURE; goto Exit; } }
#define ExitOnError( x ) { if ( x != ERROR_SUCCESS ) { x=ERROR_INSTALL_FAILURE; goto Exit; } }

//------------------------------------------------------------------
// Local Types 
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Local functions declaration
//------------------------------------------------------------------
void PrintLog(MSIHANDLE hInstall, INSTALLMESSAGE eMessageType, const char* fmt, ...);
UINT MSIGetString( MSIHANDLE hInstall, MSIHANDLE hRecHandle, int nFieldIdx, char** pszBuffer, DWORD* pcchBuffer );
UINT MSIGetProperty( MSIHANDLE hInstall, char* szPropertyName, char** pszBuffer, DWORD* pcchBuffer );
UINT ParserCertCustomData(MSIHANDLE hInstall, char* szCustomData, char** pszCertificate, char** pszStoreName, char** pszStoreType, char** pszUser, char** pszUserPassword, char** pszPfxPassword );
UINT MSICheckIfPropertyValue( MSIHANDLE hInstall, char** pszBuffer, DWORD* pcchBuffer );
HRESULT ModifyGroupMembership( char* szUser, char* szGroup, BOOL bAddUser );


//------------------------------------------------------------------
//  Local Constants
//------------------------------------------------------------------
const char c_szSQL[]            = "SELECT `CertificatePath`, `StoreName`, `StoreType`, `User`, `UserPassword`, `PFXPassword` FROM `SpecialCertificate`";
const char c_szCertTableName[]  = "SpecialCertificate";
const char c_chSep              = '\001';
const char c_szSep[]            = "\1\0";
const char c_szCreateCA[]       = "InstallCerts";
const char c_szRollbackCA[]     = "RollbackCerts";
const char c_szCustomDataPropertyName[] = "CustomActionData";

// Enumeration used to specify when and where your output will 
// be displayed.  All log output goes to debug trace when tracing 
// is active.
const int c_iLogBuffer          = 2048;

//------------------------------------------------------------------
//  DllMain -- main entry point for dll.
//------------------------------------------------------------------
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}


//------------------------------------------------------------------
//  DLL Functions
//------------------------------------------------------------------

//------------------------------------------------------------------
//  FileBrowse:  Displays a file browse window in MSI.
//      Relies on FILEPATH property to set file location.
//      Relies on FILTERS to get file extension.
//      FILTER FORMAT: "<File extension filter name>|<File extensiion>|"
//          Ex. "Text Files (*.txt)|*.txt|All Files (*.*)|*.*||"
//------------------------------------------------------------------
UINT __stdcall FileBrowse(MSIHANDLE hInstall)
{
    TCHAR szOriginalPath[MAX_PATH];
    TCHAR szNewPath[MAX_PATH];
    TCHAR szFilters[MAX_PATH];
    DWORD cchOriginalPath   = sizeof(szOriginalPath)/sizeof(TCHAR);
    DWORD cchNewPath        = sizeof(szNewPath)/sizeof(TCHAR);
    DWORD cchFilters        = sizeof(szFilters)/sizeof(TCHAR);
    DWORD dwX = 0;
    
    // clear memory.
    ZeroMemory(szOriginalPath, sizeof(szOriginalPath));
    ZeroMemory(szNewPath,      sizeof(szNewPath));
    ZeroMemory(szFilters,      sizeof(szFilters));

    // Get FILEPATH
    MsiGetProperty(hInstall, TEXT("FILEPATH"), szOriginalPath, &cchOriginalPath);
    MsiGetProperty(hInstall, TEXT("FILTERS"),  szFilters, &cchFilters);

    // the filter separator in our msi implementation is |  
    //  we need it to be '\0' for OPENFILENAME
    for ( dwX = 0; dwX < cchFilters; dwX++ )
    {
        if ( szFilters[dwX] == '|' )
        {
            szFilters[dwX] = 0;
        }
    }

    long    lErrMsg = 0;
    OPENFILENAME openFileName;

    ZeroMemory(&openFileName, sizeof(openFileName));

    // Initialize OPENFILENAME structure.
    openFileName.lStructSize = sizeof(openFileName);
    openFileName.hwndOwner = GetForegroundWindow();
    openFileName.lpstrFile = szNewPath;
    openFileName.nMaxFile = sizeof(szNewPath);
    openFileName.lpstrFilter = szFilters;
    openFileName.nFilterIndex = 1;
    openFileName.lpstrFileTitle = NULL;
    openFileName.nMaxFileTitle = 0;
    openFileName.lpstrInitialDir = szOriginalPath;
    openFileName.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    // open the window.
    if (GetOpenFileName(&openFileName))
    {
        // if successful... set the property.
        MsiSetProperty(hInstall, TEXT("FILEPATH"), szNewPath);
    }
    return ERROR_SUCCESS;
}


//------------------------------------------------------------------
//  ConfigureCerts:  Configures Certificates to install via 
//      a defered custom action in MSI.
//------------------------------------------------------------------
UINT __stdcall ConfigureCerts(MSIHANDLE hInstall)
{
    HRESULT hr = S_OK;
    UINT uiStat = ERROR_SUCCESS;
    MSIHANDLE hDatabase = NULL;
    MSIHANDLE hView = NULL;
    MSIHANDLE hRecFetch = NULL;
    char* szDeferAction = NULL;
    DWORD cchDeferAction = 0;
    char* szCertificate = NULL;
    DWORD cchCertificate = 0;
    char* szStoreName = NULL;
    DWORD cchStoreName = 0;
    char* szStoreType = NULL;
    DWORD cchStoreType = 0;
    char* szUser = NULL;
    DWORD cchUser = 0;
    char* szUserPassword = NULL;
    DWORD cchUserPassword = 0;
    char* szPfxPassword = NULL;
    DWORD cchPfxPassword = 0;

    // get a database handle
    hDatabase = MsiGetActiveDatabase(hInstall);
    if ( !hDatabase )
    {        
        uiStat = ERROR_INSTALL_FAILURE;
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to get a handle to the MSI database.");
        goto Exit;
    }

    // open the database to view.
    if (ERROR_SUCCESS != (uiStat = MsiDatabaseOpenViewA(hDatabase, c_szSQL, &hView)))
    {
        if ( ERROR_BAD_QUERY_SYNTAX == uiStat && 
            MSICONDITION_NONE == MsiDatabaseIsTablePersistentA(hDatabase, c_szCertTableName))
        {
            uiStat = ERROR_NO_MORE_ITEMS;
            goto Exit;
        }
        else
        {
            PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to open a view to the %s database.  Result = 0x%X", c_szCertTableName , uiStat );
            uiStat = ERROR_INSTALL_FAILURE;
            goto Exit;
        }
    }

    // execute the query.
    uiStat = MsiViewExecute(hView, 0);
    ExitOnErrorLog( uiStat, "Failed to execute query to the %s database.  Result = 0x%X" );

    // Fetch all entries from the SpecialCertificate table
    while (ERROR_SUCCESS == (uiStat = MsiViewFetch(hView, &hRecFetch)))
    {
        char *szBuf = NULL;
        DWORD cchBuf = 0;

        // get certificate path.
        uiStat = MSIGetString( hInstall, hRecFetch, 1, &szCertificate, &cchCertificate );
        ExitOnErrorLog( uiStat, "Failed to read certificate path.  Result = 0x%X" );        

        // check if it's a property
        uiStat = MSICheckIfPropertyValue( hInstall, &szCertificate, &cchCertificate );
        ExitOnError( uiStat );

        // get store name.
        uiStat = MSIGetString( hInstall, hRecFetch, 2, &szStoreName, &cchStoreName );
        ExitOnErrorLog( uiStat, "Failed to read the store name.  Result = 0x%X" );

        // check if it's a property
        uiStat = MSICheckIfPropertyValue( hInstall, &szStoreName, &cchStoreName );
        ExitOnError( uiStat );

        // get store type.
        uiStat = MSIGetString( hInstall, hRecFetch, 3, &szStoreType, &cchStoreType );
        ExitOnErrorLog( uiStat, "Failed to read the store type.  Result = 0x%X" );

        // check if it's a property
        uiStat = MSICheckIfPropertyValue( hInstall, &szStoreType, &cchStoreType );
        ExitOnError( uiStat );

        // get Store location or user name.
        uiStat = MSIGetString( hInstall, hRecFetch, 4, &szUser, &cchUser );
        ExitOnErrorLog( uiStat, "Failed to read store location path.  Result = 0x%X" );

        // check if it's a property
        uiStat = MSICheckIfPropertyValue( hInstall, &szUser, &cchUser );
        ExitOnError( uiStat );

        // get passwords... 
        // get store password if User account.
        uiStat = MSIGetString( hInstall, hRecFetch, 5, &szUserPassword, &cchUserPassword );
        ExitOnErrorLog( uiStat, "Failed to read user password path from %s.  Result = 0x%X" );
        uiStat = MSICheckIfPropertyValue( hInstall, &szUserPassword, &cchUserPassword );
        ExitOnError( uiStat );

        // get pfx password.
        uiStat = MSIGetString( hInstall, hRecFetch, 6, &szPfxPassword, &cchPfxPassword );
        ExitOnErrorLog( uiStat, "Failed to read pfx Password path from %s.  Result = 0x%X" );
        uiStat = MSICheckIfPropertyValue( hInstall, &szPfxPassword, &cchPfxPassword );
        ExitOnError( uiStat );

        // create the buffer for stored information.
        DWORD cchDeferAction = cchCertificate + cchStoreName + cchStoreType + cchUser + cchUserPassword + cchPfxPassword + 6;  // 5 for the extra characters
        szDeferAction = new char[ cchDeferAction ];
        if ( szDeferAction == NULL )
        {
            PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Ran out of memory constructing deferred action." );
            uiStat = ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        //  construct the params buffer for the custom actions.
        hr = StringCchPrintfA( szDeferAction, cchDeferAction, "%s%c%s%c%s%c%s%c%s%c%s", 
                                szCertificate,  c_chSep,
                                szStoreName,    c_chSep,
                                szStoreType,    c_chSep,
                                szUser,         c_chSep,
                                szUserPassword, c_chSep,
                                szPfxPassword );
        if ( FAILED(hr) )
        {
            PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to compose the necessary custom action string.  Result=0x%X", hr );
            uiStat = ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        // Rollback custom action goes first
        // Create a rollback custom action (in case install is stopped and rolls back)
        // Rollback custom action can't read tables, so we have to set a property
        UINT uiValidate1 = ERROR_SUCCESS;
        UINT uiValidate2 = ERROR_SUCCESS;
        UINT uiValidate3 = ERROR_SUCCESS;
        if (   ERROR_SUCCESS != ( uiValidate1 = MsiSetPropertyA(hInstall, c_szRollbackCA, szDeferAction) )
            || ERROR_SUCCESS != ( uiValidate2 = MsiDoActionA(hInstall, c_szRollbackCA) ) 
            || ERROR_SUCCESS != ( uiValidate3 = MsiSetPropertyA(hInstall, c_szRollbackCA, "")) )
        {
            PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to add defered action for %s. Result: 0x%X, 0x%X, 0x%X", c_szRollbackCA, uiValidate1, uiValidate2 ,uiValidate3 );
            uiStat = ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        // Create a deferred custom action (gives us the right priviledges to create the user account)
        // Deferred custom actions can't read tables, so we have to set a property
        if (   ERROR_SUCCESS != ( uiValidate1 = MsiSetPropertyA(hInstall, c_szCreateCA, szDeferAction))
            || ERROR_SUCCESS != ( uiValidate2 = MsiDoActionA(hInstall, c_szCreateCA))
            || ERROR_SUCCESS != ( uiValidate3 = MsiSetPropertyA(hInstall, c_szCreateCA, "")))
        {
            PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to add deferred action for %s. Result: 0x%X, 0x%X, 0x%X", c_szCreateCA, uiValidate1, uiValidate2 ,uiValidate3 );
            uiStat = ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        // delete the buffer so we can do this again.
        SecureZeroMemory( szDeferAction, cchDeferAction * sizeof(char) );
        delete [] szDeferAction;
        szDeferAction = NULL;
        delete [] szCertificate;
        szCertificate = NULL;
        delete [] szStoreName;
        szStoreName = NULL;
        delete [] szStoreType;
        szStoreType = NULL;
        delete [] szUser;
        szUser = NULL;
        SecureZeroMemory( szUserPassword, cchUserPassword * sizeof(char) );
        delete [] szUserPassword;
        szUserPassword = NULL;
        SecureZeroMemory( szPfxPassword, cchPfxPassword * sizeof(char) );
        delete [] szPfxPassword;
        szPfxPassword = NULL;
        MsiCloseHandle( hRecFetch );
        hRecFetch = 0;
    }

Exit:
    if ( szDeferAction )
    {
        SecureZeroMemory( szDeferAction, cchDeferAction * sizeof(char) );
        delete [] szDeferAction;
    }

    if ( szCertificate )
    {
        delete [] szCertificate;
    }

    if ( szStoreName )
    {
        delete [] szStoreName;
    }

    if ( szStoreType )
    {
        delete [] szStoreType;
    }

    if ( szUser )
    {
        delete [] szUser;
    }

    if ( szUserPassword )
    {
        SecureZeroMemory( szUserPassword, cchUserPassword * sizeof(char) );
        delete [] szUserPassword;
    }

    if ( szPfxPassword )
    {
        SecureZeroMemory( szPfxPassword, cchPfxPassword * sizeof(char) );
        delete [] szPfxPassword;
    }

    // we may still have a outstanding handle... wipe it.
    if ( hRecFetch != NULL )
    {
        MsiCloseHandle( hRecFetch );
        hRecFetch = NULL;
    }

    if ( hView != NULL )
    {
        MsiCloseHandle( hView );
        hView = NULL;
    }

    if ( hDatabase != NULL )
    {
        MsiCloseHandle( hDatabase );
        hDatabase = NULL;
    }

    return (ERROR_NO_MORE_ITEMS != uiStat) ? ERROR_INSTALL_FAILURE : ERROR_SUCCESS;
}





//------------------------------------------------------------------
//  InstallCerts:  Installs deferred custom action certificates
//          into desired store.
//------------------------------------------------------------------
UINT __stdcall InstallCerts(MSIHANDLE hInstall)
{
    UINT uiRes = ERROR_SUCCESS;
    char* szCustomData = NULL;
    DWORD cchCustomData = 0;
    char* szCertificate = NULL;
    char* szStoreName = NULL;
    char* szStoreType = NULL;
    char* szUser = NULL;
    char* szUserPassword = NULL;
    char* szPfxPassword = NULL;
    BOOL userLoggedOn = FALSE;
    HANDLE logonToken = NULL;
    BOOL bLoadedUserProfile = FALSE;
    PROFILEINFOA profile;
    HRESULT hr = S_OK;
    CHAR szLog[10000];

    //
    // Initialize COM library.
    //
    CoInitialize(0);

    // get our custom data.
	PrintLog(hInstall, INSTALLMESSAGE_INFO, "get custom data");
    uiRes = MSIGetProperty( hInstall, (char*)c_szCustomDataPropertyName, &szCustomData, &cchCustomData );
    if ( uiRes != ERROR_SUCCESS )
    {
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to attain Custom data for this action.  Result = 0x%X", uiRes );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // parse the custom action data.
	PrintLog(hInstall, INSTALLMESSAGE_INFO, "parse custom action data");
    uiRes =  ParserCertCustomData(hInstall,
                                  szCustomData, 
                                  &(szCertificate), 
                                  &(szStoreName), 
                                  &(szStoreType), 
                                  &szUser, 
                                  &szUserPassword, 
                                  &szPfxPassword );
    if ( uiRes != ERROR_SUCCESS )
    {
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to parse custom action data for certificate management.  Result = 0x%X", uiRes );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // logon the user, local domain only.
	PrintLog(hInstall, INSTALLMESSAGE_INFO, "logon the user local domain only");
    if (! LogonUserA( szUser, ".", szUserPassword, LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, &logonToken ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to logon user %s. Result=0x%X", szUser, hr );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // check the token.
	PrintLog(hInstall, INSTALLMESSAGE_INFO, "check the token");
    if ( logonToken == NULL )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "The user logon token is invalid for user %s.  Result=0x%X", szUser, hr );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // set up profile object.
	PrintLog(hInstall, INSTALLMESSAGE_INFO, "set up profile object");
    ZeroMemory( &profile, sizeof(PROFILEINFO) );
    profile.dwSize = sizeof(PROFILEINFO);
    profile.lpUserName = szUser;

    // load the users profile.
	PrintLog(hInstall, INSTALLMESSAGE_INFO, "load the user\'s profile");
    if (! LoadUserProfileA( logonToken, &profile ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to load user profile for user %s.  Result=0x%X", szUser, hr );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    bLoadedUserProfile = TRUE;

	PrintLog(hInstall, INSTALLMESSAGE_INFO, "Impersonate");
    if (! ImpersonateLoggedOnUser( logonToken ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to impersonate user %s.  Result=0x%X", szUser, hr );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

	PrintLog(hInstall, INSTALLMESSAGE_INFO, "CAPICOM: CCertMgr::Add");
	__try
	{
		hr = CCertMgr::Add( szStoreName, szStoreType, szCertificate, szPfxPassword);
	
		if ( FAILED(hr) )
		{
			PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to add certificate \"%s\" for user %s.  Result=0x%X", szCertificate, szUser, hr );
			uiRes = ERROR_INSTALL_FAILURE;
			goto Exit;
		}
		else
		{
			PrintLog(hInstall, INSTALLMESSAGE_INFO, "Certificate %s installed succesfully for %s", szCertificate, szUser);
		}
	} 
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		PrintLog(hInstall, INSTALLMESSAGE_INFO, "Failed to Add Certificate to Store. Check if CAPICOM is installed.");
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
	}
	

	PrintLog(hInstall, INSTALLMESSAGE_INFO, "Done.");
Exit:
    // if we're logged in... log us off.
    if ( userLoggedOn )
    {
        // unload the user.
        if ( bLoadedUserProfile )
        {
            UnloadUserProfile( logonToken, profile.hProfile );
        }

        // end impersonation.
        RevertToSelf();

        // release the logon token
        if ( logonToken != INVALID_HANDLE_VALUE )
        {
            CloseHandle( logonToken );
        }

    }

    if ( szCustomData )
    {
        SecureZeroMemory( szCustomData, cchCustomData );
        delete []szCustomData;
    }

    CoUninitialize();

    return uiRes;
}

//------------------------------------------------------------------
//  RollbackCerts:  Remove installed custom action certificates
//          from store.
//------------------------------------------------------------------
UINT __stdcall RollbackCerts(MSIHANDLE hInstall)
{
    UINT uiRes = ERROR_SUCCESS;
    char* szCustomData = NULL;
    DWORD cchCustomData = 0;
    char* szCertificate = NULL;
    char* szStoreName = NULL;
    char* szStoreType = NULL;
    char* szUser = NULL;
    char* szUserPassword = NULL;
    char* szPfxPassword = NULL;
    BOOL userLoggedOn = FALSE;
    HANDLE logonToken = NULL;
    BOOL bLoadedUserProfile = FALSE;
    PROFILEINFOA profile;
    HRESULT hr = S_OK;

	PrintLog(hInstall, INSTALLMESSAGE_INFO, "RollbackCerts: Started.");
	//
    // Initialize COM library.
    //
    CoInitialize(0);

    // get our custom data.
    uiRes = MSIGetProperty( hInstall, (char*)c_szCustomDataPropertyName, &szCustomData, &cchCustomData );
    if ( uiRes != ERROR_SUCCESS )
    {
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to attain Custom data for this action.  Result = 0x%X", uiRes );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // parse the custom action data.
    uiRes =  ParserCertCustomData(hInstall,
                                  szCustomData, 
                                  &szCertificate, 
                                  &szStoreName, 
                                  &szStoreType, 
                                  &szUser, 
                                  &szUserPassword, 
                                  &szPfxPassword );
    if ( uiRes != ERROR_SUCCESS )
    {
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to parse custom action data for certificate management.  Result = 0x%X", uiRes );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // logon the user 
    if (! LogonUserA( szUser, ".", szUserPassword, LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, &logonToken ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to logon user %s. Result=0x%X", szUser, hr );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // check the token.
    if ( logonToken == NULL )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "The user logon token is invalid for user %s.  Result=0x%X", szUser, hr );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // set up profile object.
    ZeroMemory( &profile, sizeof(PROFILEINFO) );
    profile.dwSize = sizeof(PROFILEINFO);
    profile.lpUserName = szUser;

    // load the users profile.
    if (! LoadUserProfileA( logonToken, &profile ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to load user profile for user %s.  Result=0x%X", szUser, hr );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    bLoadedUserProfile = TRUE;

    if (! ImpersonateLoggedOnUser( logonToken ) )
    {
        hr = MAKE_HRESULT( 1, FACILITY_WIN32, GetLastError() );
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to impersonate user %s.  Result=0x%X", szUser, hr );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // remove the existing certificate.
    hr = CCertMgr::Remove( szStoreName, szStoreType, szCertificate, szPfxPassword);
    if ( FAILED(hr) )
    {
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to add certificate \"%s\" for user user %s.  Result=0x%X", szCertificate, szUser, hr );
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

Exit:
    // if we're logged in... log us off.
    if ( userLoggedOn )
    {
        // unload the user.
        if ( bLoadedUserProfile )
        {
            UnloadUserProfile( logonToken, profile.hProfile );
        }

        // end impersonation.
        RevertToSelf();

        // release the logon token
        if ( logonToken != INVALID_HANDLE_VALUE )
        {
            CloseHandle( logonToken );
        }

    }

    if ( szCustomData )
    {
        SecureZeroMemory( szCustomData, cchCustomData );
        delete []szCustomData;
    }

    CoUninitialize();

    return uiRes;
}

//------------------------------------------------------------------
//  Local Functions
//------------------------------------------------------------------

//------------------------------------------------------------------
// ParserCustomData:  Parse the known custom action data.
//------------------------------------------------------------------
UINT ParserCertCustomData(MSIHANDLE hInstall, char* szCustomData, char** pszCertificate, char** pszStoreName, char** pszStoreType, char** pszUser, char** pszUserPassword, char** pszPfxPassword )
{
    UINT uiRes = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    size_t cchBufSize = 0;
    _ASSERT( pszCertificate != NULL );
    _ASSERT( pszStoreName != NULL );
    _ASSERT( pszStoreType != NULL );
    _ASSERT( pszUser != NULL );
    _ASSERT( pszUserPassword != NULL );
    _ASSERT( pszPfxPassword != NULL );

    PrintLog(hInstall, INSTALLMESSAGE_INFO, "Parsing cert custom data. szCustomData=%s", szCustomData);

    // parse the custom data.
    *pszCertificate = strtok(szCustomData, c_szSep);
    if ( *pszCertificate == NULL )
    {
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    PrintLog(hInstall, INSTALLMESSAGE_INFO, "pszCertificate=%s, szCustomData=%s", *pszCertificate, szCustomData);


    *pszStoreName   = strtok(NULL, c_szSep );
    if ( *pszStoreName == NULL )
    {
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    PrintLog(hInstall, INSTALLMESSAGE_INFO, "pszStoreName=%s, szCustomData=%s", *pszStoreName, szCustomData);


    *pszStoreType   = strtok(NULL, c_szSep );
    if ( *pszStoreType == NULL )
    {
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    PrintLog(hInstall, INSTALLMESSAGE_INFO, "pszStoreType=%s, szCustomData=%s", *pszStoreType, szCustomData);
    

    *pszUser   = strtok(NULL, c_szSep );
    if ( *pszUser == NULL)
    {
        uiRes = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    PrintLog(hInstall, INSTALLMESSAGE_INFO, "pszUser=%s, szCustomData=%s", *pszUser, szCustomData);


    *pszUserPassword  = strtok(NULL, c_szSep );
    
    PrintLog(hInstall, INSTALLMESSAGE_INFO, "pszUserPassword=%s, szCustomData=%s", *pszUserPassword, szCustomData);
    
    *pszPfxPassword   = strtok(NULL, c_szSep );
    
    PrintLog(hInstall, INSTALLMESSAGE_INFO, "pszPfxPassword=%s, szCustomData=%s", *pszPfxPassword, szCustomData);

    // check the password length.  If 0 then dont' pass a password.
    if ( *pszUserPassword != NULL )
    {
        hr = StringCchLengthA( *pszUserPassword, STRSAFE_MAX_CCH, &cchBufSize );
        if ( FAILED(hr) )
        {
            PrintLog(hInstall, INSTALLMESSAGE_INFO, "Failed to get user password length");
            uiRes = ERROR_INSTALL_FAILURE;
            goto Exit;
        }
        if ( cchBufSize == 0 )
        {
            *pszUserPassword = NULL;
        }
    }

    if ( *pszPfxPassword != NULL )
    {
        hr = StringCchLengthA( *pszPfxPassword, STRSAFE_MAX_CCH, &cchBufSize );
        if ( FAILED(hr) )
        {
            PrintLog(hInstall, INSTALLMESSAGE_INFO, "Failed to get pfx password length");
            uiRes = ERROR_INSTALL_FAILURE;
            goto Exit;
        }
        if ( cchBufSize == 0 )
        {
            *pszPfxPassword = NULL;
        }
    }

Exit:
    return uiRes;
}


//------------------------------------------------------------------
//    PrintLog
//    
//------------------------------------------------------------------
void PrintLog(MSIHANDLE hInstall, INSTALLMESSAGE eMessageType, const char* fmt, ...)
{
    UINT errRes = ERROR_SUCCESS;
    static char szFmt[c_iLogBuffer];
    static char szBuf[c_iLogBuffer];

    va_list args; 
    va_start(args, fmt);

    const char* c_szLogName = "Xbox Live Custom Action Toolset";
    StringCchPrintfA(szFmt, sizeof(szFmt), "%s:  %s", c_szLogName, fmt);

    StringCchVPrintfA(szBuf, sizeof(szBuf), szFmt, args);
    va_end(args);

#if 0
    MessageBoxA( NULL, szBuf, c_szLogName, MB_ICONERROR | MB_OK );

    StringCchCatA(szBuf, sizeof(szBuf), "\n");
    OutputDebugStringA(szBuf);
#else
    PMSIHANDLE hrec = MsiCreateRecord(1);

    MsiRecordSetStringA(hrec, 0, szBuf);
    MsiProcessMessage( hInstall, eMessageType, hrec);

#endif

}




//------------------------------------------------------------------
//  MSICheckIfPropertyValue:  Reads a string from the property if
//    it is a property... swap the value if it is... otherwise just
//    continue.
//------------------------------------------------------------------
UINT MSICheckIfPropertyValue( MSIHANDLE hInstall, char** pszBuffer, DWORD* pcchBuffer )
{
    UINT rc             = ERROR_SUCCESS;
    char *pbPropValue   = NULL;
    DWORD cbPropValue   = 0;

    char *pNewBuffer    = NULL;

    while (char *pLeft = strchr(*pszBuffer, '['))   // intentional assignment
    {
        if (char *pRight = strchr(pLeft, ']'))      // intentional assignment
        {
            char *pOldBuffer = *pszBuffer;

            // if we find a left bracket and a right bracket afterwards, then we're going to assume
            // it's a property specification which means we need to chop up our source string and 
            // replace it with a token replaced one.  To work efficiently, we're going to start
            // hacking up the source strings
            *pLeft++   = 0;
            *pRight++  = 0;

            rc = MSIGetProperty( hInstall, pLeft, &pbPropValue, &cbPropValue );        
            if ( rc != ERROR_SUCCESS )
            {
                PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Failed to resolve property: %s.  Result = 0x%X", pLeft, rc );
                goto Exit;
            }


            //-----------------------------------------------------------------
            // Reallocate a new buffer to hold the token replaced string and
            // piece together the left and right pieces with the middle
            // replaced by the retrieved property value
            //
            DWORD newlen = strlen(pOldBuffer) + strlen(pbPropValue) + strlen(pRight) + 1;

            pNewBuffer = new char[newlen];

            // strncpy is considered a generally unsafe function because it doesn't gaurantee
            // that pNewBuffer will be null-terminated. However, I have carefully reviewed this
            // particular usage of it and it is definitely null-terminated in this case.
            // TobiasB
            strncpy(pNewBuffer, pOldBuffer,  strlen(pOldBuffer)+1);
#pragma warning (push)
#pragma warning (disable : 6053)
            strncat(pNewBuffer, pbPropValue, strlen(pbPropValue)+1);
#pragma warning (pop)
            strncat(pNewBuffer, pRight,      strlen(pRight)+1);


            //-----------------------------------------------------------------
            // Clean up by deleting the old buffer and reassigning the new
            // one as the return value
            //
            delete [] pOldBuffer;           // free up the old buffer
            
            *pszBuffer  = pNewBuffer;       // Setup return parameters
            *pcchBuffer = newlen;

            pNewBuffer  = NULL;             // This signifies that responsibility 
                                            // for this buffer is no longer local
                                            // (it's the caller's problem now)
            
                        
            //-----------------------------------------------------------------
            // We're done with the substitution buffer, so free up the memory
            // 
            SecureZeroMemory(pbPropValue, cbPropValue);
            delete [] pbPropValue;

            pbPropValue = NULL;
            cbPropValue = 0;
        }
    }
    
Exit:
    if (pNewBuffer)
    {
        delete [] pNewBuffer;
        pNewBuffer = NULL;
    }

    if (pbPropValue)
    {
        delete [] pbPropValue;
        pbPropValue = NULL;
    }

    return rc;
}




//------------------------------------------------------------------
//  MSIGetString:  Reads a string from the database and give the
//      Memory back to the user.
//------------------------------------------------------------------
UINT MSIGetString( MSIHANDLE hInstall, MSIHANDLE hRecHandle, int nFieldIdx, char** pszBuffer, DWORD* pcchBuffer )
{
    UINT uiRes = ERROR_SUCCESS;
    DWORD cchVal = 0;
    HRESULT hr = S_OK;

    _ASSERT( pszBuffer != NULL );
    _ASSERT( pcchBuffer != NULL );

    *pcchBuffer = 0;
    *pszBuffer = NULL;

    // get the record.
    if (ERROR_MORE_DATA != ( uiRes = MsiRecordGetStringA( hRecHandle, nFieldIdx, "", pcchBuffer)) )
    {
        *pcchBuffer = 0;
        goto Exit;
    }

    // create a buffer to pass on...
    *pszBuffer = new char[++(*pcchBuffer)];
    if ( *pszBuffer == NULL )
    {
        uiRes = E_OUTOFMEMORY; // out of memory
        goto Exit;
    }
    ZeroMemory( *pszBuffer, *pcchBuffer );

    // copy the string into our buffer.
    if (ERROR_SUCCESS != ( uiRes = MsiRecordGetStringA( hRecHandle, nFieldIdx, *pszBuffer, pcchBuffer)) )
    {
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "This value is invalid for this implementation.  This is due to MSI settings not user input." );
        goto Exit;
    }

Exit:

    return uiRes;
}

//------------------------------------------------------------------
//  MSIGetPropertyW:  Reads a string from the database and give the
//      Memory back to the user.
//------------------------------------------------------------------
UINT MSIGetProperty( MSIHANDLE hInstall, char* szPropertyName, char** pszBuffer, DWORD* pcchBuffer )
{
    UINT uiRes = ERROR_SUCCESS;

    _ASSERT( pszBuffer != NULL );
    _ASSERT( *pszBuffer == NULL );
    _ASSERT( pcchBuffer != NULL );

    *pcchBuffer = 0;
    *pszBuffer = NULL;

    // get the size of the record
    if (ERROR_MORE_DATA != (uiRes = MsiGetPropertyA(hInstall, szPropertyName, "", pcchBuffer)) )
    {
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Property %s produced %d.", szPropertyName, uiRes );
        goto Exit;
    }

    // create a buffer to pass on...
    *pszBuffer = new char[++(*pcchBuffer)];
    if ( *pszBuffer == NULL )
    {
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Out of Memory." );
        uiRes = E_OUTOFMEMORY; // out of memory
        *pcchBuffer = 0;
        *pszBuffer = NULL;
        goto Exit;
    }
    ZeroMemory( *pszBuffer, *pcchBuffer );

    // get the record.
    if (ERROR_SUCCESS != (uiRes = MsiGetPropertyA(hInstall, szPropertyName, *pszBuffer, pcchBuffer)) )
    {
        PrintLog( hInstall, INSTALLMESSAGE_ERROR, "Property %s failed.  Result= %d.", szPropertyName, uiRes );
        delete [] *pszBuffer;
        *pcchBuffer = 0;
        *pszBuffer = NULL;
        goto Exit;
    }

    PrintLog(hInstall, INSTALLMESSAGE_INFO, "Retrieved property %s: (%u) %s", szPropertyName, *pcchBuffer, *pszBuffer);

Exit:

    return uiRes;
}

//------------------------------------------------------------------
//  ModifyGroupMembership:  Modifies a users membership to a group.
//------------------------------------------------------------------
HRESULT ModifyGroupMembership( char* szUser, char* szGroup, BOOL bAddUser )
{
    HRESULT hr = S_OK;
    NET_API_STATUS netstatus = 0;
    LOCALGROUP_MEMBERS_INFO_3 localGroupInfo3;

    ZeroMemory( &localGroupInfo3, sizeof(localGroupInfo3) );
    
    // assign the user pointer into the local grouup struct.
    localGroupInfo3.lgrmi3_domainandname = CA2W(szUser);

    // check the action we're suppose to perform.
    if ( bAddUser )
    {
        // we're only adding to the local machine with the function.
        netstatus = NetLocalGroupAddMembers( NULL, CA2W(szGroup), 3, (LPBYTE)&localGroupInfo3, 1 );
        if ( netstatus != 0 && netstatus != ERROR_MEMBER_IN_ALIAS )
        {
            hr = MAKE_HRESULT( 1, 0, netstatus );
            goto Exit;
        }            
    }
    else
    {
        // if we're not adding then we're deleting.
        netstatus = NetLocalGroupDelMembers( NULL, CA2W(szGroup), 3, (LPBYTE)&localGroupInfo3, 1 );
        if ( netstatus != 0 && netstatus != ERROR_MEMBER_NOT_IN_ALIAS )
        {
            hr = MAKE_HRESULT( 1, 0, netstatus );
            goto Exit;
        }            

    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\ems\makefile.inc ===
COPYFILES:
    -robocopy $(XONEXTPATH)\ems $(_NTTREE)\msi\ems /E /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\ems\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__ems_2_none_12.4.56.0_none_e89310fb8a770d0d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_ems_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.manifest
XP_MANIFEST_PATH=manifests\x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.cat
XP_CATALOG_PATH=manifests\x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.cat
XP_PAYLOAD_PATH=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_ems_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\ems\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__ems_2_none_12.4.56.0_none_e89310fb8a770d0d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_ems_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.manifest
XP_MANIFEST_PATH=manifests\x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.cat
XP_CATALOG_PATH=manifests\x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.cat
XP_PAYLOAD_PATH=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_ems_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\MSCOMGeoInfo\makefile.inc ===
COPYFILES:
    -robocopy $(EXTPATH)\MSCOMGeoInfo\1.1.0.0\MSI $(_NTTREE)\MSCOMGeoInfo /MIR /R:0 /NP /NJH /NJS /A-:R
    -robocopy $(EXTPATH)\MSCOMGeoInfo\1.1.0.0\GeoEventing $(_NTTREE)\MSCOMGeoInfo GeoEventing.* /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\MSCOMGeoInfo\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__mscomgeoinfo_2_none_12.4.56.0_none_504a61c7a715d5f4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_mscomgeoinfo_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c.manifest
XP_MANIFEST_PATH=manifests\x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c.cat
XP_CATALOG_PATH=manifests\x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c.cat
XP_PAYLOAD_PATH=x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_mscomgeoinfo_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\MSCOMGeoInfo\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__mscomgeoinfo_2_none_12.4.56.0_none_504a61c7a715d5f4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_mscomgeoinfo_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c.manifest
XP_MANIFEST_PATH=manifests\x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c.cat
XP_CATALOG_PATH=manifests\x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c.cat
XP_PAYLOAD_PATH=x86__mscomgeoinfo_2_no-public-key_12.4.56.0_x-ww_a587fa0c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_mscomgeoinfo_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\reporting\makefile.inc ===
COPYFILES:
    -robocopy $(INETROOT)\private\ops\opstools\SQL\AgentAdminJobs\reportingdb $(_NTTREE)\tools\xereports\AgentAdminJobs\reportingdb /MIR /R:0 /NP /NJH /NJS /A-:R
    -robocopy $(INETROOT)\private\ops\opstools\SQL\AgentAdminJobs\filterdb $(_NTTREE)\tools\xereports\AgentAdminJobs\filterdb /MIR /R:0 /NP /NJH /NJS /A-:R
    -robocopy $(INETROOT)\private\ops\sitecfg\Partnernet\reporting\AgentAdminJobs\reportingdb $(_NTTREE)\tools\xereports\AgentAdminJobs\Parternet\reportingdb /MIR /R:0 /NP /NJH /NJS /A-:R
    -robocopy $(INETROOT)\private\ops\sitecfg\Prodnet\reporting\AgentAdminJobs\reportingdb $(_NTTREE)\tools\xereports\AgentAdminJobs\Prodnet\reportingdb /MIR /R:0 /NP /NJH /NJS /A-:R
    -robocopy $(INETROOT)\private\ops\sitecfg\xeTestNet\reporting\AgentAdminJobs\reportingdb $(_NTTREE)\tools\xereports\AgentAdminJobs\xeTestNet\reportingdb /MIR /R:0 /NP /NJH /NJS /A-:R
    -robocopy $(INETROOT)\private\ops\sitecfg\Prodnet\reporting\Olap $(_NTTREE)\tools\xereports\Olap\Prodnet /MIR /R:0 /NP /NJH /NJS /A-:R
    -robocopy $(INETROOT)\private\ops\sitecfg\xeTestNet\reporting\Olap $(_NTTREE)\tools\xereports\Olap\xeTestNet /MIR /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\reporting\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__reporting_2_none_12.4.56.0_none_ab3981ad7068df94
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_reporting_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8.manifest
XP_MANIFEST_PATH=manifests\x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8.cat
XP_CATALOG_PATH=manifests\x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8.cat
XP_PAYLOAD_PATH=x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_reporting_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\reporting\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__reporting_2_none_12.4.56.0_none_ab3981ad7068df94
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_reporting_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8.manifest
XP_MANIFEST_PATH=manifests\x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8.cat
XP_CATALOG_PATH=manifests\x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8.cat
XP_PAYLOAD_PATH=x86__reporting_2_no-public-key_12.4.56.0_x-ww_5e78e9f8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_reporting_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\sps\makefile.inc ===
COPYFILES:
    -robocopy $(_NTROOT)\public\ext\xonline-ext\SPS\XR3\bin $(_NTTREE)\sps25 /MIR /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\sps\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__sps_4_none_12.4.56.0_none_a9546c0ef19d8476
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_sps_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182.manifest
XP_MANIFEST_PATH=manifests\x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182.cat
XP_CATALOG_PATH=manifests\x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182.cat
XP_PAYLOAD_PATH=x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_sps_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\binplacebins\sps\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__sps_4_none_12.4.56.0_none_a9546c0ef19d8476
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_sps_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182.manifest
XP_MANIFEST_PATH=manifests\x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182.cat
XP_CATALOG_PATH=manifests\x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182.cat
XP_PAYLOAD_PATH=x86__sps_4_no-public-key_12.4.56.0_x-ww_28f84182
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_sps_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\checklist\Includes\adovbs.inc ===
<%
'--------------------------------------------------------------------
' Microsoft ADO
'
' Copyright (c) 1996-1998 Microsoft Corporation.
'
'
'
' ADO constants include file for VBScript
'
'--------------------------------------------------------------------

'---- CursorTypeEnum Values ----
Const adOpenForwardOnly = 0
Const adOpenKeyset = 1
Const adOpenDynamic = 2
Const adOpenStatic = 3

'---- CursorOptionEnum Values ----
Const adHoldRecords = &H00000100
Const adMovePrevious = &H00000200
Const adAddNew = &H01000400
Const adDelete = &H01000800
Const adUpdate = &H01008000
Const adBookmark = &H00002000
Const adApproxPosition = &H00004000
Const adUpdateBatch = &H00010000
Const adResync = &H00020000
Const adNotify = &H00040000
Const adFind = &H00080000
Const adSeek = &H00400000
Const adIndex = &H00800000

'---- LockTypeEnum Values ----
Const adLockReadOnly = 1
Const adLockPessimistic = 2
Const adLockOptimistic = 3
Const adLockBatchOptimistic = 4

'---- ExecuteOptionEnum Values ----
Const adAsyncExecute = &H00000010
Const adAsyncFetch = &H00000020
Const adAsyncFetchNonBlocking = &H00000040
Const adExecuteNoRecords = &H00000080
Const adExecuteStream = &H00000400

'---- ConnectOptionEnum Values ----
Const adAsyncConnect = &H00000010

'---- ObjectStateEnum Values ----
Const adStateClosed = &H00000000
Const adStateOpen = &H00000001
Const adStateConnecting = &H00000002
Const adStateExecuting = &H00000004
Const adStateFetching = &H00000008

'---- CursorLocationEnum Values ----
Const adUseServer = 2
Const adUseClient = 3

'---- DataTypeEnum Values ----
Const adEmpty = 0
Const adTinyInt = 16
Const adSmallInt = 2
Const adInteger = 3
Const adBigInt = 20
Const adUnsignedTinyInt = 17
Const adUnsignedSmallInt = 18
Const adUnsignedInt = 19
Const adUnsignedBigInt = 21
Const adSingle = 4
Const adDouble = 5
Const adCurrency = 6
Const adDecimal = 14
Const adNumeric = 131
Const adBoolean = 11
Const adError = 10
Const adUserDefined = 132
Const adVariant = 12
Const adIDispatch = 9
Const adIUnknown = 13
Const adGUID = 72
Const adDate = 7
Const adDBDate = 133
Const adDBTime = 134
Const adDBTimeStamp = 135
Const adBSTR = 8
Const adChar = 129
Const adVarChar = 200
Const adLongVarChar = 201
Const adWChar = 130
Const adVarWChar = 202
Const adLongVarWChar = 203
Const adBinary = 128
Const adVarBinary = 204
Const adLongVarBinary = 205
Const adChapter = 136
Const adFileTime = 64
Const adPropVariant = 138
Const adVarNumeric = 139
Const adArray = &H2000

'---- FieldAttributeEnum Values ----
Const adFldMayDefer = &H00000002
Const adFldUpdatable = &H00000004
Const adFldUnknownUpdatable = &H00000008
Const adFldFixed = &H00000010
Const adFldIsNullable = &H00000020
Const adFldMayBeNull = &H00000040
Const adFldLong = &H00000080
Const adFldRowID = &H00000100
Const adFldRowVersion = &H00000200
Const adFldCacheDeferred = &H00001000
Const adFldIsChapter = &H00002000
Const adFldNegativeScale = &H00004000
Const adFldKeyColumn = &H00008000
Const adFldIsRowURL = &H00010000
Const adFldIsDefaultStream = &H00020000
Const adFldIsCollection = &H00040000

'---- EditModeEnum Values ----
Const adEditNone = &H0000
Const adEditInProgress = &H0001
Const adEditAdd = &H0002
Const adEditDelete = &H0004

'---- RecordStatusEnum Values ----
Const adRecOK = &H0000000
Const adRecNew = &H0000001
Const adRecModified = &H0000002
Const adRecDeleted = &H0000004
Const adRecUnmodified = &H0000008
Const adRecInvalid = &H0000010
Const adRecMultipleChanges = &H0000040
Const adRecPendingChanges = &H0000080
Const adRecCanceled = &H0000100
Const adRecCantRelease = &H0000400
Const adRecConcurrencyViolation = &H0000800
Const adRecIntegrityViolation = &H0001000
Const adRecMaxChangesExceeded = &H0002000
Const adRecObjectOpen = &H0004000
Const adRecOutOfMemory = &H0008000
Const adRecPermissionDenied = &H0010000
Const adRecSchemaViolation = &H0020000
Const adRecDBDeleted = &H0040000

'---- GetRowsOptionEnum Values ----
Const adGetRowsRest = -1

'---- PositionEnum Values ----
Const adPosUnknown = -1
Const adPosBOF = -2
Const adPosEOF = -3

'---- BookmarkEnum Values ----
Const adBookmarkCurrent = 0
Const adBookmarkFirst = 1
Const adBookmarkLast = 2

'---- MarshalOptionsEnum Values ----
Const adMarshalAll = 0
Const adMarshalModifiedOnly = 1

'---- AffectEnum Values ----
Const adAffectCurrent = 1
Const adAffectGroup = 2
Const adAffectAllChapters = 4

'---- ResyncEnum Values ----
Const adResyncUnderlyingValues = 1
Const adResyncAllValues = 2

'---- CompareEnum Values ----
Const adCompareLessThan = 0
Const adCompareEqual = 1
Const adCompareGreaterThan = 2
Const adCompareNotEqual = 3
Const adCompareNotComparable = 4

'---- FilterGroupEnum Values ----
Const adFilterNone = 0
Const adFilterPendingRecords = 1
Const adFilterAffectedRecords = 2
Const adFilterFetchedRecords = 3
Const adFilterConflictingRecords = 5

'---- SearchDirectionEnum Values ----
Const adSearchForward = 1
Const adSearchBackward = -1

'---- PersistFormatEnum Values ----
Const adPersistADTG = 0
Const adPersistXML = 1

'---- StringFormatEnum Values ----
Const adClipString = 2

'---- ConnectPromptEnum Values ----
Const adPromptAlways = 1
Const adPromptComplete = 2
Const adPromptCompleteRequired = 3
Const adPromptNever = 4

'---- ConnectModeEnum Values ----
Const adModeUnknown = 0
Const adModeRead = 1
Const adModeWrite = 2
Const adModeReadWrite = 3
Const adModeShareDenyRead = 4
Const adModeShareDenyWrite = 8
Const adModeShareExclusive = &Hc
Const adModeShareDenyNone = &H10
Const adModeRecursive = &H400000

'---- RecordCreateOptionsEnum Values ----
Const adCreateCollection = &H00002000
Const adCreateStructDoc = &H80000000
Const adCreateNonCollection = &H00000000
Const adOpenIfExists = &H02000000
Const adCreateOverwrite = &H04000000
Const adFailIfNotExists = -1

'---- RecordOpenOptionsEnum Values ----
Const adOpenRecordUnspecified = -1
Const adOpenOutput = &H00800000
Const adOpenAsync = &H00001000
Const adDelayFetchStream = &H00004000
Const adDelayFetchFields = &H00008000
Const adOpenExecuteCommand = &H00010000

'---- IsolationLevelEnum Values ----
Const adXactUnspecified = &Hffffffff
Const adXactChaos = &H00000010
Const adXactReadUncommitted = &H00000100
Const adXactBrowse = &H00000100
Const adXactCursorStability = &H00001000
Const adXactReadCommitted = &H00001000
Const adXactRepeatableRead = &H00010000
Const adXactSerializable = &H00100000
Const adXactIsolated = &H00100000

'---- XactAttributeEnum Values ----
Const adXactCommitRetaining = &H00020000
Const adXactAbortRetaining = &H00040000

'---- PropertyAttributesEnum Values ----
Const adPropNotSupported = &H0000
Const adPropRequired = &H0001
Const adPropOptional = &H0002
Const adPropRead = &H0200
Const adPropWrite = &H0400

'---- ErrorValueEnum Values ----
Const adErrProviderFailed = &Hbb8
Const adErrInvalidArgument = &Hbb9
Const adErrOpeningFile = &Hbba
Const adErrReadFile = &Hbbb
Const adErrWriteFile = &Hbbc
Const adErrNoCurrentRecord = &Hbcd
Const adErrIllegalOperation = &Hc93
Const adErrCantChangeProvider = &Hc94
Const adErrInTransaction = &Hcae
Const adErrFeatureNotAvailable = &Hcb3
Const adErrItemNotFound = &Hcc1
Const adErrObjectInCollection = &Hd27
Const adErrObjectNotSet = &Hd5c
Const adErrDataConversion = &Hd5d
Const adErrObjectClosed = &He78
Const adErrObjectOpen = &He79
Const adErrProviderNotFound = &He7a
Const adErrBoundToCommand = &He7b
Const adErrInvalidParamInfo = &He7c
Const adErrInvalidConnection = &He7d
Const adErrNotReentrant = &He7e
Const adErrStillExecuting = &He7f
Const adErrOperationCancelled = &He80
Const adErrStillConnecting = &He81
Const adErrInvalidTransaction = &He82
Const adErrUnsafeOperation = &He84
Const adwrnSecurityDialog = &He85
Const adwrnSecurityDialogHeader = &He86
Const adErrIntegrityViolation = &He87
Const adErrPermissionDenied = &He88
Const adErrDataOverflow = &He89
Const adErrSchemaViolation = &He8a
Const adErrSignMismatch = &He8b
Const adErrCantConvertvalue = &He8c
Const adErrCantCreate = &He8d
Const adErrColumnNotOnThisRow = &He8e
Const adErrURLIntegrViolSetColumns = &He8f
Const adErrURLDoesNotExist = &He8f
Const adErrTreePermissionDenied = &He90
Const adErrInvalidURL = &He91
Const adErrResourceLocked = &He92
Const adErrResourceExists = &He93
Const adErrCannotComplete = &He94
Const adErrVolumeNotFound = &He95
Const adErrOutOfSpace = &He96
Const adErrResourceOutOfScope = &He97
Const adErrUnavailable = &He98
Const adErrURLNamedRowDoesNotExist = &He99
Const adErrDelResOutOfScope = &He9a
Const adErrPropInvalidColumn = &He9b
Const adErrPropInvalidOption = &He9c
Const adErrPropInvalidValue = &He9d
Const adErrPropConflicting = &He9e
Const adErrPropNotAllSettable = &He9f
Const adErrPropNotSet = &Hea0
Const adErrPropNotSettable = &Hea1
Const adErrPropNotSupported = &Hea2
Const adErrCatalogNotSet = &Hea3
Const adErrCantChangeConnection = &Hea4
Const adErrFieldsUpdateFailed = &Hea5
Const adErrDenyNotSupported = &Hea6
Const adErrDenyTypeNotSupported = &Hea7
Const adErrProviderNotSpecified = &Hea9

'---- ParameterAttributesEnum Values ----
Const adParamSigned = &H0010
Const adParamNullable = &H0040
Const adParamLong = &H0080

'---- ParameterDirectionEnum Values ----
Const adParamUnknown = &H0000
Const adParamInput = &H0001
Const adParamOutput = &H0002
Const adParamInputOutput = &H0003
Const adParamReturnValue = &H0004

'---- CommandTypeEnum Values ----
Const adCmdUnknown = &H0008
Const adCmdText = &H0001
Const adCmdTable = &H0002
Const adCmdStoredProc = &H0004
Const adCmdFile = &H0100
Const adCmdTableDirect = &H0200

'---- EventStatusEnum Values ----
Const adStatusOK = &H0000001
Const adStatusErrorsOccurred = &H0000002
Const adStatusCantDeny = &H0000003
Const adStatusCancel = &H0000004
Const adStatusUnwantedEvent = &H0000005

'---- EventReasonEnum Values ----
Const adRsnAddNew = 1
Const adRsnDelete = 2
Const adRsnUpdate = 3
Const adRsnUndoUpdate = 4
Const adRsnUndoAddNew = 5
Const adRsnUndoDelete = 6
Const adRsnRequery = 7
Const adRsnResynch = 8
Const adRsnClose = 9
Const adRsnMove = 10
Const adRsnFirstChange = 11
Const adRsnMoveFirst = 12
Const adRsnMoveNext = 13
Const adRsnMovePrevious = 14
Const adRsnMoveLast = 15

'---- SchemaEnum Values ----
Const adSchemaProviderSpecific = -1
Const adSchemaAsserts = 0
Const adSchemaCatalogs = 1
Const adSchemaCharacterSets = 2
Const adSchemaCollations = 3
Const adSchemaColumns = 4
Const adSchemaCheckConstraints = 5
Const adSchemaConstraintColumnUsage = 6
Const adSchemaConstraintTableUsage = 7
Const adSchemaKeyColumnUsage = 8
Const adSchemaReferentialConstraints = 9
Const adSchemaTableConstraints = 10
Const adSchemaColumnsDomainUsage = 11
Const adSchemaIndexes = 12
Const adSchemaColumnPrivileges = 13
Const adSchemaTablePrivileges = 14
Const adSchemaUsagePrivileges = 15
Const adSchemaProcedures = 16
Const adSchemaSchemata = 17
Const adSchemaSQLLanguages = 18
Const adSchemaStatistics = 19
Const adSchemaTables = 20
Const adSchemaTranslations = 21
Const adSchemaProviderTypes = 22
Const adSchemaViews = 23
Const adSchemaViewColumnUsage = 24
Const adSchemaViewTableUsage = 25
Const adSchemaProcedureParameters = 26
Const adSchemaForeignKeys = 27
Const adSchemaPrimaryKeys = 28
Const adSchemaProcedureColumns = 29
Const adSchemaDBInfoKeywords = 30
Const adSchemaDBInfoLiterals = 31
Const adSchemaCubes = 32
Const adSchemaDimensions = 33
Const adSchemaHierarchies = 34
Const adSchemaLevels = 35
Const adSchemaMeasures = 36
Const adSchemaProperties = 37
Const adSchemaMembers = 38
Const adSchemaTrustees = 39
Const adSchemaFunctions = 40
Const adSchemaActions = 41
Const adSchemaCommands = 42
Const adSchemaSets = 43

'---- FieldStatusEnum Values ----
Const adFieldOK = 0
Const adFieldCantConvertValue = 2
Const adFieldIsNull = 3
Const adFieldTruncated = 4
Const adFieldSignMismatch = 5
Const adFieldDataOverflow = 6
Const adFieldCantCreate = 7
Const adFieldUnavailable = 8
Const adFieldPermissionDenied = 9
Const adFieldIntegrityViolation = 10
Const adFieldSchemaViolation = 11
Const adFieldBadStatus = 12
Const adFieldDefault = 13
Const adFieldIgnore = 15
Const adFieldDoesNotExist = 16
Const adFieldInvalidURL = 17
Const adFieldResourceLocked = 18
Const adFieldResourceExists = 19
Const adFieldCannotComplete = 20
Const adFieldVolumeNotFound = 21
Const adFieldOutOfSpace = 22
Const adFieldCannotDeleteSource = 23
Const adFieldReadOnly = 24
Const adFieldResourceOutOfScope = 25
Const adFieldAlreadyExists = 26
Const adFieldPendingInsert = &H10000
Const adFieldPendingDelete = &H20000
Const adFieldPendingChange = &H40000
Const adFieldPendingUnknown = &H80000
Const adFieldPendingUnknownDelete = &H100000

'---- SeekEnum Values ----
Const adSeekFirstEQ = &H1
Const adSeekLastEQ = &H2
Const adSeekAfterEQ = &H4
Const adSeekAfter = &H8
Const adSeekBeforeEQ = &H10
Const adSeekBefore = &H20

'---- ADCPROP_UPDATECRITERIA_ENUM Values ----
Const adCriteriaKey = 0
Const adCriteriaAllCols = 1
Const adCriteriaUpdCols = 2
Const adCriteriaTimeStamp = 3

'---- ADCPROP_ASYNCTHREADPRIORITY_ENUM Values ----
Const adPriorityLowest = 1
Const adPriorityBelowNormal = 2
Const adPriorityNormal = 3
Const adPriorityAboveNormal = 4
Const adPriorityHighest = 5

'---- ADCPROP_AUTORECALC_ENUM Values ----
Const adRecalcUpFront = 0
Const adRecalcAlways = 1

'---- ADCPROP_UPDATERESYNC_ENUM Values ----

'---- ADCPROP_UPDATERESYNC_ENUM Values ----

'---- MoveRecordOptionsEnum Values ----
Const adMoveUnspecified = -1
Const adMoveOverWrite = 1
Const adMoveDontUpdateLinks = 2
Const adMoveAllowEmulation = 4

'---- CopyRecordOptionsEnum Values ----
Const adCopyUnspecified = -1
Const adCopyOverWrite = 1
Const adCopyAllowEmulation = 4
Const adCopyNonRecursive = 2

'---- StreamTypeEnum Values ----
Const adTypeBinary = 1
Const adTypeText = 2

'---- LineSeparatorEnum Values ----
Const adLF = 10
Const adCR = 13
Const adCRLF = -1

'---- StreamOpenOptionsEnum Values ----
Const adOpenStreamUnspecified = -1
Const adOpenStreamAsync = 1
Const adOpenStreamFromRecord = 4

'---- StreamWriteEnum Values ----
Const adWriteChar = 0
Const adWriteLine = 1

'---- SaveOptionsEnum Values ----
Const adSaveCreateNotExist = 1
Const adSaveCreateOverWrite = 2

'---- FieldEnum Values ----
Const adDefaultStream = -1
Const adRecordURL = -2

'---- StreamReadEnum Values ----
Const adReadAll = -1
Const adReadLine = -2

'---- RecordTypeEnum Values ----
Const adSimpleRecord = 0
Const adCollectionRecord = 1
Const adStructDoc = 2
%>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\ems\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__ems_2_none_12.4.56.0_none_e89310fb8a770d0d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_ems_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.manifest
XP_MANIFEST_PATH=manifests\x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.cat
XP_CATALOG_PATH=manifests\x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.cat
XP_PAYLOAD_PATH=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_ems_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\ems\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__ems_2_none_12.4.56.0_none_e89310fb8a770d0d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_ems_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.manifest
XP_MANIFEST_PATH=manifests\x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.cat
XP_CATALOG_PATH=manifests\x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5.cat
XP_PAYLOAD_PATH=x86__ems_2_no-public-key_12.4.56.0_x-ww_2f1df3b5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_ems_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\ems\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

#no trailing \ since build interprets this as a line continuation... 

FILETARGET:
	-FOR /D %d in (xblob) DO robocopy %d %_NT386TREE%\ems\%d /E /XX /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\MARKETPLACE\FFFE0812\FFFE0812.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFE0812.spa.h
//
// Auto-generated on Wednesday, 09 April 2008 at 11:36:45
// XLAST project version 1.0.8.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_GAME_FFFE0812_SPA_H__
#define __MKP_GAME_FFFE0812_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_GAME_FFFE0812                   0xFFFE0812

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_RICH_PRESENCE              0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_PROPERTY                           0x30000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//


//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards


//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//


//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 1


#ifdef __cplusplus
}
#endif

#endif // __MKP_GAME_FFFE0812_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\MARKETPLACE\FFFE0813\FFFE0813.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFE0813.spa.h
//
// Auto-generated on Wednesday, 09 April 2008 at 11:38:08
// XLAST project version 1.0.9.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_GAME_FFFE0813_SPA_H__
#define __MKP_GAME_FFFE0813_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_GAME_FFFE0813                   0xFFFE0813

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENCE_1                 0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RATING                             0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//


//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADERBORAD                      2

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADERBORAD


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_MATCH_QUERY             0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 1


#ifdef __cplusplus
}
#endif

#endif // __MKP_GAME_FFFE0813_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\MARKETPLACE\FFFE0814\fffe0814.spa.h ===
////////////////////////////////////////////////////////////////////
//
// fffe0814.spa.h
//
// Auto-generated on Wednesday, 09 April 2008 at 12:15:44
// XLAST project version 1.0.6.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_GAME_FFFE0814_SPA_H__
#define __MKP_GAME_FFFE0814_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_GAME_FFFE0814                   0xFFFE0814

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENCE                   0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RATING                             0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//


//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADER_BOARD                     1

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADER_BOARD


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_MATCH_QUERY             0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GP2                           1


#ifdef __cplusplus
}
#endif

#endif // __MKP_GAME_FFFE0814_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\MARKETPLACE\FFFE0816\FFFE0816.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFE0816.spa.h
//
// Auto-generated on Wednesday, 09 April 2008 at 11:41:54
// XLAST project version 1.0.10.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_GAME_FFFE0816_SPA_H__
#define __MKP_GAME_FFFE0816_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_GAME_FFFE0816                   0xFFFE0816

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENCE_1                 0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RATING                             0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A2                              2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5
#define ACHIEVEMENT_A6                              6
#define ACHIEVEMENT_A7                              7
#define ACHIEVEMENT_A8                              8
#define ACHIEVEMENT_A9                              9
#define ACHIEVEMENT_A10                             10
#define ACHIEVEMENT_A11                             11
#define ACHIEVEMENT_A12                             12

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADERBOARD                      3

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADERBOARD


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_MATCH_QUERY             0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 2


#ifdef __cplusplus
}
#endif

#endif // __MKP_GAME_FFFE0816_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\MARKETPLACE\FFFE0815\FFFE0815.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFE0815.spa.h
//
// Auto-generated on Wednesday, 09 April 2008 at 11:41:04
// XLAST project version 1.0.23.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_GAME_FFFE0815_SPA_H__
#define __MKP_GAME_FFFE0815_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_GAME_FFFE0815                   0xFFFE0815

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//

#define CONTEXT_DEFAULT                             0

//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for CONTEXT_DEFAULT

#define CONTEXT_DEFAULT_ACTIVE_CONTEXT              0

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENCE                   0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RATING                             0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A2                              2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5
#define ACHIEVEMENT_A6                              6
#define ACHIEVEMENT_A7                              7
#define ACHIEVEMENT_A8                              8
#define ACHIEVEMENT_A9                              9
#define ACHIEVEMENT_A10                             10
#define ACHIEVEMENT_A11                             11
#define ACHIEVEMENT_A12                             12

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADERBOARD                      2

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADERBOARD


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_MATCH_QUERY             0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 13


#ifdef __cplusplus
}
#endif

#endif // __MKP_GAME_FFFE0815_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\MARKETPLACE\FFFE0818\FFFE0818.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFE0818.spa.h
//
// Auto-generated on Wednesday, 09 April 2008 at 16:52:11
// XLAST project version 1.0.6.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_GAME_FFFE0818_SPA_H__
#define __MKP_GAME_FFFE0818_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_GAME_FFFE0818                   0xFFFE0818

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENCE                   0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RANKING                            0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A2                              2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5
#define ACHIEVEMENT_A6                              6
#define ACHIEVEMENT_A7                              7
#define ACHIEVEMENT_A8                              8
#define ACHIEVEMENT_A9                              9
#define ACHIEVEMENT_A10                             10
#define ACHIEVEMENT_A11                             11
#define ACHIEVEMENT_A12                             12

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADER_BOARD                     1

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADER_BOARD


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_MATCH_QUERY             0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_NEW_GP                        1


#ifdef __cplusplus
}
#endif

#endif // __MKP_GAME_FFFE0818_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\MARKETPLACE\FFFE0817\FFFE0817.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFE0817.spa.h
//
// Auto-generated on Wednesday, 09 April 2008 at 16:15:00
// XLAST project version 1.0.6.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_GAME_FFFE0817_SPA_H__
#define __MKP_GAME_FFFE0817_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_GAME_FFFE0817                   0xFFFE0817

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENCE                   0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RANKING                            0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A2                              2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5
#define ACHIEVEMENT_A6                              6
#define ACHIEVEMENT_A7                              7
#define ACHIEVEMENT_A8                              8
#define ACHIEVEMENT_A9                              9
#define ACHIEVEMENT_A10                             10
#define ACHIEVEMENT_A11                             11
#define ACHIEVEMENT_A12                             12

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADER_BOARD                     1

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADER_BOARD


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_MATCH_QUERY             0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 1


#ifdef __cplusplus
}
#endif

#endif // __MKP_GAME_FFFE0817_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\MARKETPLACE\FFFE0819\FFFE0819.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFE0819.spa.h
//
// Auto-generated on Wednesday, 09 April 2008 at 13:39:05
// XLAST project version 1.0.12.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_GAME_FFFE0819_SPA_H__
#define __MKP_GAME_FFFE0819_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_GAME_FFFE0819                   0xFFFE0819

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENSE                   0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RATING                             0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A2                              2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5
#define ACHIEVEMENT_A6                              6
#define ACHIEVEMENT_A7                              7
#define ACHIEVEMENT_A8                              8
#define ACHIEVEMENT_A9                              9
#define ACHIEVEMENT_A10                             10
#define ACHIEVEMENT_A11                             11
#define ACHIEVEMENT_A12                             12

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADER_BOARD                     1

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADER_BOARD


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_MATCH_QUERY             0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 1


#ifdef __cplusplus
}
#endif

#endif // __MKP_GAME_FFFE0819_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\migration\makefile.inc ===
RobocopyScripts : 
    -robocopy . $(_NT386TREE)\msi\esp\migration /X /A-:R /E /R:0 /NP /NJH /NJS /XO /XX /XF build.log build.err build.wrn buildd.log buildd.err buildd.wrn sources makefile makefile.inc /XD obj objd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\MARKETPLACE\FFFE081A\FFFE081A.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFE081A.spa.h
//
// Auto-generated on Wednesday, 09 April 2008 at 11:35:20
// XLAST project version 1.0.8.0
// SPA Compiler version 2.0.7116.0
//
////////////////////////////////////////////////////////////////////

#ifndef __MKP_GMAE_FFFE081A_SPA_H__
#define __MKP_GMAE_FFFE081A_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_MKP_GMAE_FFFE081A                   0xFFFE081A

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_PRESENCE                   0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_DEFAULT                   0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_RANKING                            0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A2                              2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5
#define ACHIEVEMENT_A6                              6
#define ACHIEVEMENT_A7                              7
#define ACHIEVEMENT_A8                              8
#define ACHIEVEMENT_A9                              9
#define ACHIEVEMENT_A10                             10
#define ACHIEVEMENT_A11                             11
#define ACHIEVEMENT_A12                             12

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_DEFAULT             0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_DEFAULT           0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADERBOARD                      1

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADERBOARD


//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//

#define SESSION_MATCH_QUERY_MATCH_QUERRY            0

//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//

#define GAMER_PICTURE_GAMER_PICTURE                 13


#ifdef __cplusplus
}
#endif

#endif // __MKP_GMAE_FFFE081A_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\migration\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__sitecfg_2_none_12.4.56.0_none_03f06a47e382ba11
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_sitecfg_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.manifest
XP_MANIFEST_PATH=manifests\x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.cat
XP_CATALOG_PATH=manifests\x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.cat
XP_PAYLOAD_PATH=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_sitecfg_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\migration\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__sitecfg_2_none_12.4.56.0_none_03f06a47e382ba11
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_sitecfg_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.manifest
XP_MANIFEST_PATH=manifests\x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.cat
XP_CATALOG_PATH=manifests\x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.cat
XP_PAYLOAD_PATH=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_sitecfg_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\setup\makefile.inc ===
SetupCopy : makefile.inc
    -robocopy ..\setup $(_NT386TREE)\setup /MIR /R:0 /NP /NJH /NJS /A-:R /XF makefile makefile.inc sources /XD obj objd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\setup\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__setup_0_none_12.4.56.0_none_58fe30c1f6690f8b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_setup_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85.manifest
XP_MANIFEST_PATH=manifests\x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85.cat
XP_CATALOG_PATH=manifests\x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85.cat
XP_PAYLOAD_PATH=x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_setup_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\setup\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__setup_0_none_12.4.56.0_none_58fe30c1f6690f8b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_setup_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85.manifest
XP_MANIFEST_PATH=manifests\x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85.cat
XP_CATALOG_PATH=manifests\x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85.cat
XP_PAYLOAD_PATH=x86__setup_0_no-public-key_12.4.56.0_x-ww_51025d85
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_setup_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\sitecfg\makefile.inc ===
SitecfgCopy : 
    -robocopy . $(_NT386TREE)\sitecfg /X /A-:R /E /R:0 /NP /NJH /NJS /XO /XX /XF build.log build.err build.wrn buildd.log buildd.err buildd.wrn sources makefile makefile.inc /XD obj objd

    for /d %h in (*) do  \
    (\
      (\
        if exist %h\storage_deploy_template.xml \
        (\
          type %h\storage_deploy_template.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/;s/\<\<WSTAPPNAME\>\>/StoreDB/g"  > $(_NT386TREE)\sitecfg\%h\StoreDB_deploy.xml && \
          type %h\storage_deploy_template.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/;s/\<\<WSTAPPNAME\>\>/TitleDB/g"  > $(_NT386TREE)\sitecfg\%h\TitleDB_deploy.xml && \
          type %h\storage_deploy_template.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/;s/\<\<WSTAPPNAME\>\>/TUserDB/g"  > $(_NT386TREE)\sitecfg\%h\TUserDB_deploy.xml && \
          type %h\storage_deploy_template.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/;s/\<\<WSTAPPNAME\>\>/TTeamDB/g"  > $(_NT386TREE)\sitecfg\%h\TTeamDB_deploy.xml && \
          type %h\storage_deploy_template.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/;s/\<\<WSTAPPNAME\>\>/MsgDB/g"    > $(_NT386TREE)\sitecfg\%h\MsgDB_deploy.xml \
        )\
      )\
      &&\
      (\
        if exist %h\uodb_deploy.xml \
        (\
          type %h\uodb_deploy.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/"  > $(_NT386TREE)\sitecfg\%h\UODB_deploy.xml \
        )\
      )\
      &&\
      (\
        if exist %h\eventsysdb_deploy.xml \
        (\
          type %h\eventsysdb_deploy.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/"  > $(_NT386TREE)\sitecfg\%h\eventsysdb_deploy.xml \
        )\
      )\
      &&\
      (\
        if exist %h\StoreDB_deploy.xml \
        (\
          type %h\StoreDB_deploy.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/"  > $(_NT386TREE)\sitecfg\%h\StoreDB_deploy.xml \
        )\
      )\
      &&\
      (\
        if exist %h\TitleDB_deploy.xml \
        (\
          type %h\TitleDB_deploy.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/"  > $(_NT386TREE)\sitecfg\%h\TitleDB_deploy.xml \
        )\
      )\
      &&\
      (\
        if exist %h\TUserDB_deploy.xml \
        (\
          type %h\TUserDB_deploy.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/"  > $(_NT386TREE)\sitecfg\%h\TUserDB_deploy.xml \
        )\
      )\
      &&\
      (\
        if exist %h\TTeamDB_deploy.xml \
        (\
          type %h\TTeamDB_deploy.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/"  > $(_NT386TREE)\sitecfg\%h\TTeamDB_deploy.xml \
        )\
      )\
      &&\
      (\
        if exist %h\MsgDB_deploy.xml \
        (\
          type %h\MsgDB_deploy.xml | perl -pe "s/\<\<BUILDNUMBER\>\>/%_BLDVERMAJOR%.%_BLDVERMINOR%.%_BLDNUMMAJOR%.%_BLDNUMMINOR%/"  > $(_NT386TREE)\sitecfg\%h\MsgDB_deploy.xml \
        )\
      )\
    )\
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\sitecfg\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__sitecfg_2_none_12.4.56.0_none_03f06a47e382ba11
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_sitecfg_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.manifest
XP_MANIFEST_PATH=manifests\x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.cat
XP_CATALOG_PATH=manifests\x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.cat
XP_PAYLOAD_PATH=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_sitecfg_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\sitecfg\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__sitecfg_2_none_12.4.56.0_none_03f06a47e382ba11
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_sitecfg_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.manifest
XP_MANIFEST_PATH=manifests\x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.cat
XP_CATALOG_PATH=manifests\x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87.cat
XP_PAYLOAD_PATH=x86__sitecfg_2_no-public-key_12.4.56.0_x-ww_1fa6be87
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_sitecfg_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\AgentJobs\RPRT\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

SQLTARGET:
    -md %_NT386TREE%\xdb\dbupgrade\reporting

    -robocopy . $(_NT386TREE)\xdb\dbupgrade\reporting *.sql *.bat /R:0 /NP /NJS /NJH /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\AgentJobs\RPRT\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__rprt_3_none_12.4.56.0_none_9507197598a9c859
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_rprt_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9.manifest
XP_MANIFEST_PATH=manifests\x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9.cat
XP_CATALOG_PATH=manifests\x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9.cat
XP_PAYLOAD_PATH=x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_rprt_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\AgentJobs\RPRT\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__rprt_3_none_12.4.56.0_none_9507197598a9c859
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_rprt_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9.manifest
XP_MANIFEST_PATH=manifests\x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9.cat
XP_CATALOG_PATH=manifests\x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9.cat
XP_PAYLOAD_PATH=x86__rprt_3_no-public-key_12.4.56.0_x-ww_24e603a9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_rprt_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\AU\Main.cs ===
using System;
using xonline.ops.tools.datawarehouse.capacity.models;
using System.Xml;

namespace xonline.ops.tools.datawarehouse.capacity.au 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Console
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{

			/*
			Nnls nnls = new Nnls(4);

			XmlDocument doc = new XmlDocument();
      
			XmlNode node = nnls.toXml(doc, new string[]{"x1","x2","x3","x4"});

			System.Console.WriteLine(node.OuterXml.ToString());

			return;*/

			/*
			 *  TEST:
				Dataset Name:  Longley (Longley.dat)

				File Format:   ASCII
							Certified Values  (lines 31 to 51)
							Data              (lines 61 to 76)

				Procedure:     Linear Least Squares Regression

				Reference:     Longley, J. W. (1967).  
							An Appraisal of Least Squares Programs for the 
							Electronic Computer from the Viewpoint of the User.
							Journal of the American Statistical Association, 62, pp. 819-841.
			  				
				Data:       1 Response Variable (y)
							6 Predictor Variable (x)
							16 Observations
							Higher Level of Difficulty
							Observed Data

				Model:         Polynomial Class
							7 Parameters (B0,B1,...,B7)

							y = B0 + B1*x1 + B2*x2 + B3*x3 + B4*x4 + B5*x5 + B6*x6 + e

							Certified Regression Statistics

														Standard Deviation
					Parameter         Estimate              of Estimate

						B0       -3482258.63459582         890420.383607373
						B1        15.0618722713733         84.9149257747669
						B2       -0.358191792925910E-01    0.334910077722432E-01
						B3       -2.02022980381683         0.488399681651699
						B4       -1.03322686717359         0.214274163161675
						B5       -0.511041056535807E-01    0.226073200069370
						B6        1829.15146461355         455.478499142212

					Residual
					Standard Deviation   304.854073561965

					R-Squared            0.995479004577296


							Certified Analysis of Variance Table

				Source of Degrees of     Sums of             Mean  
				Variation  Freedom       Squares            Squares          F Statistic
				              
				Regression    6      184172401.944494   30695400.3240823   330.285339234588
				Residual      9      836424.055505915   92936.0061673238
				
				Data:     y       x1      x2      x3       x4       x5     x6
						60323    83.0   234289   2356     1590    107608  1947
						61122    88.5   259426   2325     1456    108632  1948
						60171    88.2   258054   3682     1616    109773  1949
						61187    89.5   284599   3351     1650    110929  1950
						63221    96.2   328975   2099     3099    112075  1951
						63639    98.1   346999   1932     3594    113270  1952
						64989    99.0   365385   1870     3547    115094  1953
						63761   100.0   363112   3578     3350    116219  1954
						66019   101.2   397469   2904     3048    117388  1955
						67857   104.6   419180   2822     2857    118734  1956
						68169   108.4   442769   2936     2798    120445  1957
						66513   110.8   444546   4681     2637    121950  1958
						68655   112.6   482704   3813     2552    123366  1959
						69564   114.2   502601   3931     2514    125368  1960
						69331   115.7   518173   4806     2572    127852  1961
						70551   116.9   554894   4007     2827    130081  1962
				
			


            
            Perceptron tron = new Perceptron(6, true, 10000, 0.0015, true);
			//MultiVarLinearRegression tron = new MultiVarLinearRegression(6);

			double[] outputs = new double[]{60323,61122,60171,61187,63221,63639,64989,63761,66019,67857,68169,66513,68655,69564,69331,70551};

			double[][] inputs = new double[][]{
											new double[]{83.0,	234289,	2356,	1590,	107608,	1947},
											new double[]{88.5,	259426,	2325,	1456,	108632,	1948},
											new double[]{88.2,	258054,	3682,	1616,	109773,	1949},
											new double[]{89.5,	284599,	3351,	1650,	110929,	1950},
											new double[]{96.2,	328975,	2099,	3099,	112075,	1951},
											new double[]{98.1,	346999,	1932,	3594,	113270,	1952},
											new double[]{99.0,	365385,	1870,	3547,	115094,	1953},
											new double[]{100.0,	363112,	3578,	3350,	116219,	1954},
											new double[]{101.2,	397469,	2904,	3048,	117388,	1955},
											new double[]{104.6,	419180,	2822,	2857,	118734,	1956},
											new double[]{108.4,	442769,	2936,	2798,	120445,	1957},
											new double[]{110.8,	444546,	4681,	2637,	121950,	1958},
											new double[]{112.6,	482704,	3813,	2552,	123366,	1959},
											new double[]{114.2,	502601,	3931,	2514,	125368,	1960},
											new double[]{115.7,	518173,	4806,	2572,	127852,	1961},
											new double[]{116.9,	554894,	4007,	2827,	130081,	1962}
								};

			for(int i = 0; i < outputs.Length; i++)
			{
				tron.add(inputs[i], outputs[i]);
			}
            
            XmlDocument doc = new XmlDocument();
      
			XmlNode node = tron.toXml(doc, new string[]{"x1","x2","x3","x4","x5","x6"});

			System.Console.WriteLine(node.OuterXml.ToString());

			// outputs:
			for(int i = 0; i < outputs.Length; i++)
			{
				System.Console.WriteLine("Inputs: {0}   Output: {1}, Real {2}", inputs[i].ToString(), tron.compute(inputs[i]), outputs[i]);
			}

            return;
			*/


            if(args.Length >= 4)
            {
                Controller controller = new Controller(args[0], args[1], Convert.ToDateTime(args[2]), Convert.ToDateTime(args[3]));
                controller.makeModels();
            }
            else
                System.Console.WriteLine("Need args: inputXml outputXml startTime endTime");
                //throw new Exception("Need args: inputXml outputXml startTime endTime");
                
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\MatrixAlgebra\IllegalDimension.cs ===
using System;
using System.Diagnostics;

namespace xonline.ops.tools.datawarehouse.capacity.matrixalgebra 
{

	
    ///<summary>
    /// Exception thrown in case an illegal matrix or vector dimension is given to
    /// one of the Matrix classes.
    ///</summary>
	 
	
    public class IllegalDimension : System.Exception 
    {
	
        ///<summary>
        ///  IllegalDimension constructor comment.
        ///</summary>
        public IllegalDimension() : base() 
        {
		
        }

        ///<summary>
        ///  IllegalDimension constructor comment. 
        ///</summary>
        ///<param name="s">Description </param>
        public IllegalDimension(System.String s) : base(s) 
        {
		
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\AU\Controller.cs ===
using System;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.Configuration;
using System.IO;
using System.Collections;
using xonline.ops.tools.datawarehouse.capacity.models;

namespace xonline.ops.tools.datawarehouse.capacity.au 
{
	/// <summary>
	/// The controller takes the config.xml and creates a DataServer
	/// to feed the Models.
	/// </summary>
	public class Controller
	{
        private string _pathConfigXml;
        private string _outputXml;
        private DateTime _start;
        private DateTime _end;
        private string _outXmlTemplate = 
                    "<Models>\n" + 
                    "   <properties start=\"\" end=\"\" connectionString=\"\" />" + 
                    "   <models>\n" +
                    "   </models>\n" +
                    "   <clusters>\n" + 
                    "   </clusters>\n" + 
                    "</Models>";
        private XmlDocument _outXml = new XmlDocument();

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="pathConfigXml"></param>
        /// <param name="outputXml"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
		public Controller(string pathConfigXml, string outputXml, DateTime start, DateTime end)
		{
		    _pathConfigXml = pathConfigXml;
            _outputXml = outputXml;

            _start = start;
            _end = end;   

            fixOutXml();
		}

        private void fixOutXml()
        {
            _outXml.LoadXml(_outXmlTemplate);
    
            Utils.addAttr(_outXml.SelectSingleNode("/Models/properties"), "start", _start.ToString());
            Utils.addAttr(_outXml.SelectSingleNode("/Models/properties"), "end", _end.ToString());
        }

        struct ModelParams
        {
            public LinearModel model;
            public string sproc;
            public string predictor;

            public ModelParams(LinearModel m, string sp, string pred)
            {
                model = m; sproc = sp; predictor = pred;
            }
        }

        /// <summary>
        /// Given an XmlNodeList of models it fills in the models Hashtable and the Games string array.
        /// The models hashtable will be modelName -> ModelParams structure.
        /// </summary>
        /// <param name="xmlModels"></param>
        /// <param name="models"></param>
        /// <param name="Games"></param>
        private void makeModels(XmlNodeList xmlModels, ref Hashtable models, ref string[] Games, string connectionString)
        {
            foreach(XmlNode model in xmlModels)
            {
                if(model.Attributes["model"].Value == "UniLinear")
                {
                    ModelParams p = new ModelParams(
                        new LinearRegression(), 
                        model.Attributes["sproc"].Value, 
                        model.Attributes["predictor"] != null ? model.Attributes["predictor"].Value : null
                        );
                    
                    models[model.Name] = p;
                }

                if(model.Attributes["model"].Value == "MultiLinear")
                {
                    if(Games == null)
                        Games = topGames(connectionString);

                    ModelParams p = new ModelParams(
                        new MultiVarLinearRegression(Games.Length), 
                        model.Attributes["sproc"].Value, 
                        model.Attributes["predictor"] != null ? model.Attributes["predictor"].Value : null
                        );
                    
                    models[model.Name] = p;
                }

                if(model.Attributes["model"].Value == "Perceptron")
                {
                    if(Games == null)
                        Games = topGames(connectionString);

                    ModelParams p = new ModelParams(
                        new Perceptron(
                        Games.Length, 
                        Convert.ToBoolean(model.Attributes["constant"].Value), 
                        Convert.ToInt32(model.Attributes["epochs"].Value), 
                        Convert.ToDouble(model.Attributes["learningConstant"].Value), 
                        Convert.ToBoolean(model.Attributes["forcepositive"].Value)
                        ), 
                        model.Attributes["sproc"].Value, 
                        model.Attributes["predictor"] != null ? model.Attributes["predictor"].Value : null
                        );

                    models[model.Name] = p;
                }
            }
        }
      
        /// <summary>
        /// Goes through the xml configuration file feeding each model as it is needed.
        /// When it is done feeding a model it saves the results to outputXml
        /// </summary>
        public void makeModels()
        {
            // load the config file
            XmlDocument config = new XmlDocument();

            // TODO: error in xml?
            config.Load(_pathConfigXml);


            //
            // make the commonCounters 
            //
            Hashtable commonCounters = new Hashtable();
            foreach(XmlNode common in config.SelectNodes("/ModelsConfig/commons/*"))
            {
                commonCounters[common.Name] = common;
            }


            //
            // get the ConnectionString
            //
            XmlNode temp = config.SelectSingleNode("/ModelsConfig/connectionString");
            string connectionString = "";

            if(temp != null)
                connectionString = temp.Attributes["value"].Value;
            else
            {
                throw new Exception("<connectionString> Node not set correctly in " + _pathConfigXml);
            }

            //
            // get the QueryTimeOut
            //
            temp = config.SelectSingleNode("/ModelsConfig/queryTimeOut");

            int queryTimeOut = 180;

            if(temp != null)
                queryTimeOut = Convert.ToInt32(temp.Attributes["value"].Value);
           

            //
            // fix the OutXml
            //
            Utils.addAttr(_outXml.SelectSingleNode("/Models/properties"), "connectionString", connectionString);

            //
            // add the models configuration
            //
            _outXml.SelectSingleNode("/Models/models").InnerXml = config.SelectSingleNode("/ModelsConfig/models").InnerXml;


            //
            // get the model nodes to see which models we are using
            //
            string[] Games = null;             
            Hashtable models = new Hashtable();
            makeModels(config.SelectNodes("/ModelsConfig/models/*"), ref models, ref Games, connectionString);

            //
            // go through the clusters and process the models for each counter
            //
            foreach(XmlNode cluster in config.SelectNodes("/ModelsConfig/clusters/*"))
            {
                foreach(XmlNode y in cluster.ChildNodes) // for each counter or common
                {
                    if(commonCounters[y.Name] != null)
                    {                        
                        // go through all the commonYs
                        foreach(XmlNode cy in ((XmlNode)commonCounters[y.Name]).ChildNodes)
                        {
                            if(cy.Name == "counter")
                            {
                                // go through all the models specified for this output 
                                string[] modelsToUse = cy.Attributes["models"].Value.Split(new char[] {','});
                                foreach(string thisModel in modelsToUse)
                                {          
                                    {
                                        // TODO: check to see if the model actually exists!
                                        ModelParams p = (ModelParams)models[thisModel];
                                        LinearModel model = p.model;
                                        processAndSaveModel(
                                            ref model,
                                            connectionString, 
                                            cluster.Name, 
                                            cy.Attributes["output"].Value, 
                                            cy.Attributes["sproc"] != null ? cy.Attributes["sproc"].Value : p.sproc,
                                            cy.Attributes["counters"] != null ? cy.Attributes["counters"].Value : null,
                                            queryTimeOut,
                                            Games,
                                            cy.Attributes["predictor"] != null ? cy.Attributes["predictor"].Value : p.predictor,
                                            thisModel
                                            );  
                                    }
                                }
                            }
                        }
                    }
                    else if(y.Name == "counter")
                    {
                        // go through all the models specified for this output 
                        string[] modelsToUse = y.Attributes["models"].Value.Split(new char[] {','});
                        foreach(string thisModel in modelsToUse)
                        {          
                            {
                                // TODO: check to see if the model actually exists!
                                ModelParams p = (ModelParams)models[thisModel];
                                LinearModel model = p.model;
                                processAndSaveModel(
                                    ref model,
                                    connectionString,
                                    cluster.Name, 
                                    y.Attributes["output"].Value,
                                    y.Attributes["sproc"] != null ? y.Attributes["sproc"].Value : p.sproc,
                                    y.Attributes["counters"] != null ? y.Attributes["counters"].Value : null,
                                    queryTimeOut,
                                    Games,
                                    y.Attributes["predictor"] != null ? y.Attributes["predictor"].Value : p.predictor,
                                    thisModel
                                    );  
                            }
                        }                   
                    }
                    else if(y.NodeType == XmlNodeType.Element)
                    {                        
                        System.Console.WriteLine("Invalid node inside: " + cluster.Name + "\n Must be either commonYs or y.");
                        return;
                    }
                }
            }
        }
        
        /// <summary>
        /// Saves the OutPutXml file to the path given.
        /// </summary>
        private void saveOutXml()
        {
            _outXml.Save(this._outputXml);
        }

 
        private void processAndSaveModel(ref LinearModel model, 
                                            string connectionString, 
                                            string cluster, 
                                            string output,                                            
                                            string sproc, 
                                            string counters,
                                            int timeout, 
                                            string[] Games, // hack for G1,G2,G3...
                                            string predictor,
                                            string modelName
                                        )
        {

            // must do!
            model.variables = predictor.Split(new char[] {','}).Length;
            model.reset();             

            if(model is MultiVarLinearRegression || model is Perceptron)
            {
                processMultiLinearModel(
                        new DataServer(connectionString, timeout),
                        ref model, 
                        cluster,
                        sproc,
                        counters != null ? counters : output,                         
                        predictor,
                        output
                    );            
            }
            else if(model is LinearRegression)
            {
                processUniLinearModel(
                        new DataServer(connectionString, timeout), 
                        ref model, 
                        cluster,                         
                        sproc,
                        predictor,
                        output
                    );        
            }

            model.modelName = modelName;
            
            // check to see if predictor is of G1,G2,G3...,other
            // if so send in the Games[] instead
            string[] games = predictor.Split(new Char[]{','});
            if(games.Length > 0 && games[0] == "G1")
            {
                predictor = "";
                for(int i = 0; i < Games.Length; i++)
                {
                    if(i != 0)
                        predictor += ",";
                    predictor += Games[i];
                }
            }
            
            addModel(ref model, cluster, output, predictor);
            saveOutXml();

			// save to DB
			DataServer db = new DataServer(connectionString, timeout);			
			db.modelToDB(ref model, _start, _end, cluster, predictor, output);

            System.Console.WriteLine(model.modelName + " Model Done for: [" + cluster+ "] predictor[s] = " + predictor + ", output = " + output);
        }


        /// <summary>
        /// Returns the top games in order of rank including other which includes all the other games.
        /// </summary>
        /// <param name="connectionString">The DB connection string</param>
        /// <returns></returns>
        private string[] topGames(string connectionString)
        {
            SqlConnection conn = new SqlConnection(connectionString);
            conn.Open();

            string cmdStr = "exec sp_GetTop15Games" + " '" + _start + "', " + "'" + _end + "' ";
 
            SqlDataAdapter  cmd = new SqlDataAdapter (cmdStr, conn);	

            DataSet ds = new DataSet();
            cmd.Fill(ds);            
            conn.Close();

            DataTable table = ds.Tables[0];

            string[] games = new string[table.Rows.Count + 1];

            int i = 0;
            foreach(DataRow row in table.Rows)
            {
                games[i++] = (string)row["vcTitleName"];
            }

            games[table.Rows.Count] = "other";

            return games;
        }

        /// <summary>
        /// Adds the model to the OutXml. (r^2, a, b, etc.)
        /// </summary>
        /// <param name="model">The model to add to the OutXml</param>
        private void addModel(ref LinearModel model, string clusterName, string output, string predictor)
        {
            // first add the node
            
            XmlNode clustersNode = _outXml.SelectSingleNode("/Models/clusters");
            XmlNode node = _outXml.SelectSingleNode("/Models/clusters/" + clusterName);

            if(node == null)
            {            
                node = _outXml.CreateElement(clusterName);
                clustersNode.AppendChild(node);        
            }

            XmlNode y = null;
            
            if(model is LinearRegression)
                y = model.toXml(_outXml, new string[] {"a"});
            else if(model is MultiVarLinearRegression || model is Perceptron)
            {
                string[] predictors = predictor.Split(new Char[]{','});
                y = model.toXml(_outXml, predictors);
            }

            Utils.addAttr(y, "output", output);
            Utils.addAttr(y, "predictor", predictor);            

            node.AppendChild(y);            
        }
        
        /// <summary>
        /// Given a DataServer and a Model, it feeds the data from the DataServer to
        /// the Model.  The Model then Models the data linearly using least squares.
        /// </summary>
        /// <param name="server"></param>
        /// <param name="model"></param>
        /// <param name="cluster">The cluster on which we are getting the counters for.</param>
        /// <param name="obj">The NT Performance Object Counter.</param>
        /// <param name="inst">The NT Performance Instance Counter.</param>
        private void processMultiLinearModel(DataServer server, ref LinearModel model, string cluster, string sproc, string counters, string predictor, string output)
        {
            //hack
            string[] cs = counters.Split(new Char[]{','});
            counters  = "";
            for(int i = 0; i < cs.Length; i++)
            {
                if(i != 0)
                    counters += ",";
                counters +=  cs[i].Trim();
            }

            DataTable table = server.getData(_start, _end, cluster, counters, sproc);
            
            // now go through the table and feed the data to the model
            foreach(DataRow row in table.Rows)
            {
                string[] predictors = predictor.Split(new char[]{','});
                double[] xs = new Double[predictors.Length]; // including other

                int i = 0;
                foreach(string pred in predictors)
                {
                    xs[i++] = Convert.ToDouble(row[pred]);
                }
                               
                model.add(xs, Convert.ToDouble(row[output]));
            }
        }

        /// <summary>
        /// Given a DataServer and a Model, it feeds the data from the DataServer to
        /// the Model.  The Model then Models the data linearly using least squares.
        /// </summary>
        /// <param name="server"></param>
        /// <param name="model"></param>
        /// <param name="cluster">The cluster on which we are getting the counters for.</param>
        /// <param name="obj">The NT Performance Object Counter.</param>
        /// <param name="inst">The NT Performance Instance Counter.</param>
        private void processUniLinearModel(DataServer server, ref LinearModel model, string cluster, string sproc, string predictor, string output)
        {
            // TODO: it better be a linear regression model!!!

            DataTable table = server.getData(_start, _end, cluster, output, sproc);

			ArrayList xs = new ArrayList();
			ArrayList ys = new ArrayList();

			double minY = System.Double.NaN, maxY = System.Double.NaN;
            
			//
            // Go through the  table and find the min and max Y
            foreach(DataRow row in table.Rows)
            {     
				xs.Add(Convert.ToDouble(row[predictor]));
				double y = Convert.ToDouble(row[output]);
				ys.Add(y);

				minY = y < minY || System.Double.IsNaN(minY) ? y : minY;
				maxY = y > maxY || System.Double.IsNaN(maxY) ? y : maxY;
            }

			//
			// build the histogram
			Histogram hist = new Histogram(minY, maxY, 15);
			foreach(double y in ys)
			{
				hist.add(y);
			}

			//
			// feed data to the model if it fits the filter condition
            for(int i = 0; i < ys.Count; i++)
			{
				if(hist.getBinSizeAt((double)ys[i]) > hist.average)
				{
					double[] x = new Double[1];
					x[0] = (double)xs[i];
					model.add(x, (double)ys[i]);
				}
			}            

        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\MatrixAlgebra\LinearEquations.cs ===
using System;
using System.Diagnostics;
using System.Collections;

namespace xonline.ops.tools.datawarehouse.capacity.matrixalgebra 
{

    ///<summary>
    /// Class representing a system of linear equations.  
    /// Uses backward substitution (pivoting) and Gaussian elimination to solve the system
    /// of linear equations.
    /// Adopted from H. Besset's book
    ///</summary>
    public class LinearEquations
    {
        ///<summary>
        ///  components is a matrix build from the system's matrix and  the constant vector
        ///</summary>	 	
        private double[][] _rows;

        ///<summary>
        ///  Array containing the solution vectors.
        ///</summary>	
        private ArrayList[] _solutions;
	        
        ///<summary>
        ///  Construct a system of linear equation Ax = y1, y2, y3...
        ///</summary>
        ///<param name="m"> double[][], the coefficients </param>
        ///<param name="c"> double[][], the Constants vectors (more than one vector of constants) </param>
        ///<exception cref="IllegalDimension"> If the system's matrix is not square or if constant dimension does not match that of the matrix</exception>
        public LinearEquations(double[][] m, double[][] c)
        {
            int n = m.Length;
            if ( m[0].Length != n )
                throw new IllegalDimension("Illegal system: a " + n + " by " + m[0].Length + " matrix is not a square matrix");

            if ( c[0].Length != n )
                throw new IllegalDimension("Illegal system: a " + n + " by " 
                                            + n + " matrix cannot build a system with a "
                                            + c[0].Length + " -dimensional vector"
                                           );

            _rows = new double[n][/*n+c.Length*/];
            for( int i = 0; i < n; i++)
                _rows[i] = new double[n+c.Length];

            for ( int i = 0; i < n; i++)
            {
                for ( int j = 0; j < n; j++)
                    _rows[i][j] = m[i][j];
                for ( int j = 0; j < c.Length; j++)
                    _rows[i][n+j] = c[j][i];
            }	
        }

        ///<summary>
        ///  Construct a system of linear equation Ax = y. 
        ///</summary>
        ///<param name="m"> double[][]	components of the system's matrix </param>
        ///<param name="c"> double[]	components of the constant vector </param>
        ///<exception cref="MatrixAlgebra.IllegalDimension"> If the system's matrix is not square or if constant dimension does not match that of the matrix</exception>
        public LinearEquations ( double[][] m, double[] c)
        {
            int n = m.Length;
            if ( m[0].Length != n )
                throw new IllegalDimension("Illegal system: a " + n + " by " + m[0].Length + " matrix is not a square matrix");

            if ( c.Length != n )
                throw new IllegalDimension("Illegal system: a " + n + " by " + n + " matrix cannot build a system with a "
                                            + c.Length+"-dimensional vector"
                                           );            

            _rows = new double[n][/* n + 1 */];
            for( int i = 0; i < n; i++)
                _rows[i] = new double[n+1];

            for ( int i = 0; i < n; i++)
            {
                for ( int j = 0; j < n; j++)
                    _rows[i][j] = m[i][j];
                _rows[i][n] = c[i];
            }	
        }

        ///<summary>
        ///  Computes the solution for constant vector p applying  backsubstitution. 
        ///</summary>
        ///<param name="p"> int </param>
        ///<exception ArithmeticException"> if one diagonal element of the triangle matrix is zero.</exception>
        private void backSubstitution (int p)
        {
            int n = _rows.Length;
            double [] answer = new double[n];
            double x;
            for ( int i = n - 1; i >= 0; i--)
            {
                x = _rows[i][n+p];
                for ( int j = i + 1; j < n; j++)
                    x -= answer[j] * _rows[i][j];
                answer[i] = x / _rows[i][i];
            }
            _solutions[p] = new ArrayList(answer);
            return;
        }

        ///<summary>
        ///  Finds the position of the largest pivot at step p. 
        ///</summary>
        ///<returns> int </returns>
        ///<param name="p"> int	step of pivoting.</param>
        private int largestPivot ( int p)
        {
            double pivot = Math.Abs(_rows[p][p]) ;
            int answer = p;
            double x;
            for ( int i = p + 1; i < _rows.Length; i++)
            {
                x = Math.Abs(_rows[i][p]);
                if ( x > pivot )
                {
                    answer = i;
                    pivot = x;
                }	
            }	
            return answer;
        }

        ///<summary>
        ///  Perform pivot operation at location p. 
        ///</summary>
        ///<param name="p"> int </param>
        ///<exception cref="ArithmeticException"> if the pivot element is zero.</exception>
        private void pivot ( int p)
        {
            double inversePivot = 1 / _rows[p][p];
            double r;
            int n = _rows.Length;
            int m = _rows[0].Length;
            for ( int i = p + 1; i < n; i++)
            {
                r = inversePivot * _rows[i][p];
                for ( int j = p; j < m; j++)
                    _rows[i][j] -= _rows[p][j] * r;
            }	
            return;
        }

        ///<summary>
        ///  Perform optimum pivot operation at location p. 
        ///</summary>
        ///<param name="p"> int</param>
        private void pivotingStep ( int p)
        {
            swap_rows( p, largestPivot( p));
            pivot(p);
            return;
        }

        ///<summary>
        /// 
        ///</summary>
        ///<returns> ArrayList solution for the 1st constant vector</returns>
        public  virtual ArrayList solution ( )
        {
            return solution(0);
        }

        ///<summary>
        ///  Return the vector solution of constants indexed by p. 
        ///</summary>
        ///<returns> MatrixAlgebra.DhbArrayList </returns>
        ///<param name="p"> int	index of the constant vector fed into the system. </param>
        ///<exception cref="ArithmeticException"> If the system cannot be solved.</exception>
        public  virtual ArrayList solution ( int p)
        {
            if ( _solutions == null )
                solve();
            if ( _solutions[p] == null )
                backSubstitution(p);
            return _solutions[p];
        }

        ///<summary>
        /// 
        ///</summary>
        ///<exception cref="ArithmeticException"> If the system cannot be solved.</exception>
        private void solve ( )
        {            
            int n = _rows.Length;
            
            for ( int i = 0; i < n; i++)
                pivotingStep(i);
            _solutions = new ArrayList[_rows[0].Length-n];
        }

        ///<summary>
        ///  Swaps rows p and q. 
        ///</summary>
        ///<param name="p"> int </param>
        ///<param name="q"> int</param>
        private void swap_rows ( int p, int q)
        {
            if (p != q)
            {
                double temp;
                int m = _rows[p].Length;
                for (int j = 0; j < m; j++)
                {
                    temp = _rows[p][j];
                    _rows[p][j] = _rows[q][j];
                    _rows[q][j] = temp;
                }	
            }	
            return;
        }

        ///<summary>
        ///  Returns a string1 representation of the system. 
        ///</summary>
        ///<returns> String </returns>
        public virtual System.String toString()
        {
            System.Text.StringBuilder sb = new  System.Text.StringBuilder();
            char[] separator = { '[', ' '};
            int n = _rows.Length;
            int m = _rows[0].Length;
            for ( int i = 0; i < n; i++)
            {
                separator[0] = '(';
                for ( int j = 0; j < n; j++)
                {
                    sb.Append(separator) ;
                    sb.Append(_rows[i][j]) ;
                    separator[0] = ',';
                }
                separator[0] = ':';
                for ( int j = n; j < m; j++)
                {
                    sb.Append(separator) ;
                    sb.Append(_rows[i][j]) ;
                    separator[0] = ',';
                }
                sb.Append(')');
                sb.Append('\n');
            }
            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\AU\DataServer.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using xonline.ops.tools.datawarehouse.capacity.models;

namespace xonline.ops.tools.datawarehouse.capacity.au 
{
	/// <summary>
	/// This class assumes that we are connecting to Datawarehouse database.
	/// 
	/// It caches the last getData query in its static table.
	/// </summary>
	public class DataServer
	{   
        private string _connectionString;
        private int _timeout;

		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="connectionString">The DB connection string.</param>
		/// <param name="timeout">Max Timeout for getData().</param>
		public DataServer(string connectionString, int timeout)
		{
            _connectionString = connectionString;
            _timeout = timeout;
		}

		/// <summary>
		/// Static DataTable that holds the data for the last query.
		/// The other static variables are holders for the query made.
		/// So if we see the same query being made again _table is returned.
		/// Otherwise another query is made.
		/// 
		/// It only holds the last query made, it doesn't keep a large cache. <-- TODO?
		/// </summary>
        static DataTable _table;
        static string _cluster;
        static string _counters;
        static string _sproc;
        static string _start;
        static string _end;

        /// <summary>
        /// Executes the given sproc with the given parameters.
        ///  Given a cluster, a time range, and perf counters the sproc returns the Counter Value at a certain Active Users number.
        ///  It really returns the max value at the active users number.
        /// </summary>
        /// <param name="start">The start time for which this model was made.</param>
        /// <param name="end">The end time for which this model was made.</param>
        /// <param name="cluster">Cluster that the model represents.</param>
        /// <param name="counters">The response variables.</param>
        /// <param name="sproc">Sproc to use to get the data.</param>
        /// <returns>A DataTable that holds the data.  Namely, predictor and response variables</returns>
        public DataTable getData(DateTime start, DateTime end, string cluster, string counters, string sproc)
        {
            if(cluster == _cluster && counters == _counters && sproc == _sproc
                && start.ToString() == _start && end.ToString() == _end
                )
            {
                return _table;
            }


            try
            {
                SqlConnection conn = new SqlConnection(_connectionString);
                conn.Open();

                string cmdStr = "exec "  + sproc
                    + " '" + start + "', "
                    + "'" + end + "', "
                    + "'" + cluster + "', "
                    + "'" + counters + "'";                
 
                SqlCommand   cmd = new SqlCommand (cmdStr, conn);	
                cmd.CommandTimeout = _timeout;

                DataSet ds = new DataSet();
                SqlDataAdapter d = new SqlDataAdapter(cmd);
                d.Fill(ds);
            
                conn.Close();

                _table = ds.Tables[0];
                _cluster = cluster;
                _counters = counters;
                _sproc = sproc;

                _start = start.ToString();
                _end = end.ToString();

                return ds.Tables[0];
            }
            catch(Exception e)
            {
                System.Console.WriteLine(e);
                throw e;
            }            
        }

		/// <summary>
		/// Calls sp_InsertModel which inserts the model to the DB.
		/// sp_InsertModel also creates a modelstate row which tells us if there
		/// was an anomaly or not.
		/// </summary>
		/// <param name="model">The model to save to the DB.</param>
		/// <param name="start">The start time for which this model was made.</param>
		/// <param name="end">The end time for which this model was made.</param>
		/// <param name="cluster">Cluster that the model represents.</param>
		/// <param name="predictor">The predictor[s] variable.</param>
		/// <param name="output">The response variable.</param>
		public void modelToDB(ref LinearModel model, DateTime start, DateTime end, string cluster, string predictor, string output)
		{
			
			// connect to DB
			try
			{
				SqlConnection conn = new SqlConnection(_connectionString);
				conn.Open();

				// construct a string with commmas.
				string modelParameters = "";
				double[] p = model.getParameters();
				
				for(int i = 0; i < p.Length; i++)
				{
					if(i != 0)
						modelParameters += ",";

					modelParameters += p[i];
				}

				string cmdStr = "exec sp_InsertModel "
					+ helper_add(start.ToString())
					+ helper_add(end.ToString())
					+ helper_add(output)
					+ helper_add(model.modelName)
					+ helper_add(cluster)
					+ helper_add(predictor)
					+ model.variables.ToString() + ',' 
					+ helper_add(modelParameters)
					+ model.getConstant().ToString()
					+ ',' + (System.Double.IsNaN(model.getRSquared()) ? "0" : model.getRSquared().ToString());


 
				SqlCommand   cmd = new SqlCommand (cmdStr, conn);	
				
				// should I?
				//cmd.CommandTimeout = _timeout;

				cmd.ExecuteNonQuery();
            
				
				conn.Close();				
			}
			catch(Exception e)
			{
				System.Console.WriteLine(e);
				throw e; // i still throw the exception!
			}
		}
		
		private string helper_add(string str)
		{
			return " '" + str + "', ";               
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\Models\LinearRegression.cs ===
using System;
using System.Diagnostics;


namespace xonline.ops.tools.datawarehouse.capacity.models 
{
	
	 ///<summary>
	 /// linear regression  
	 /// Adopted from H. Besset's book
	 ///</summary>
	 
	
	public class LinearRegression : LinearModel
	{
        ///<summary>
        ///  Number of accumulated points
        ///</summary> 
        private int _sum1;

        ///<summary>
        ///  Sum of X
        ///</summary>
        private double _sumX;

        ///<summary>
        ///  Sum of XX
        ///</summary>
        private double _sumXX;

        ///<summary>
        ///  Sum of XY
        ///</summary>
        private double _sumXY;

        ///<summary>
        ///  Sum of YY
        ///</summary> 
        private double _sumYY;

        ///<summary>
        ///  Constructor method.
        ///</summary>
        public LinearRegression()
        {
            _useConstant = true;
            _variables = 1;
            this.modelName = "UniLinear";
	        reset();
        }
        
	    /// <summary>
	    /// 
	    /// </summary>
	    /// <param name="x"> double </param>
	    /// <param name="y"> double</param>        	
        protected override void helper_add( double[] xs, double y)
        {
	        addWeighted( xs[0], y, 1);
        }

	    ///<summary>
	    /// 
	    ///</summary>
	    ///<param name="x"> double </param>
	    ///<param name="y"> double </param>
	    ///<param name="w"> double</param>      	
        public void addWeighted( double x, double y, double w)
        {
	        double wx = w * x;
	        double wy = w * y;
	        _sum1 += (int)w;
	        _sumX += wx;

	        //_sumY += wy; taken care of by LinearModel in add()
	        _sumXX += wx * x;
	        _sumYY += wy * y;
	        _sumXY += wx * y;
	        resetResults();
        }


        /// <summary>
        /// Use linear regression to find the parameter[s], a and b.
        /// </summary>
        protected override void train()
        {
	        double xNorm = _sumXX * _sum1 - _sumX * _sumX;
	        double xyNorm = _sumXY * _sum1 - _sumX * _sumY;

            this._parameters[0] = xyNorm / xNorm;
            this._constant = (_sumXX * _sumY - _sumXY * _sumX) / xNorm;
            this._RSquared =  xyNorm / Math.Sqrt(xNorm *( _sumYY * _sum1 - _sumY * _sumY));
        }

        protected override double computeR2() { 
            if( System.Double.IsNaN(_RSquared)  )
                train();
            return _RSquared; 
        }

	    ///<summary>
	    /// remove a point.
	    ///</summary>
	    ///<param name="x"> double </param>
	    ///<param name="y"> double</param>       	
        public void remove( double x, double y)
        {
	        _sum1 -= 1;
	        _sumX -= x;
	        _sumY -= y;
	        _sumXX -= x * x;
	        _sumYY -= y * y;
	        _sumXY -= x * y;
	        resetResults();
        }

        /// <summary>
        /// Override reset.
        /// </summary>
        public override void reset()
        {
            base.reset();
	        _sum1 = 0;
	        _sumX = 0;
	        _sumY = 0;
	        _sumXX = 0;
	        _sumYY = 0;
	        _sumXY = 0;
	        resetResults();
        }

        private void resetResults()
        {
            _parameters[0] = System.Double.NaN;
            _constant = System.Double.NaN;
            _RSquared = System.Double.NaN;
        }


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\Models\Histogram.cs ===
using System;
using System.Collections;

namespace xonline.ops.tools.datawarehouse.capacity.models 
{
	/// <summary>
	/// Used as a filter to remove outliers when feeding a model.
	/// Note that this filter works very differntly with a different number
	/// of buckets.
	/// </summary>
	public class Histogram
	{
		/// <summary>
		/// The minimum value of all the datapoints that are added to the Histogram
		/// </summary>
		private double _min;

		/// <summary>
		/// The max value of all the datapoints that are added to the Histogram
		/// </summary>
		private double _max;
		private int _numBuckets;

		/// <summary>
		/// Bucket or bin width
		/// </summary>
		private double _binWidth;

		/// <summary>
		/// Bucket array.  Each element holds the number of datapoints that it holds.
		/// </summary>
		private int[] _buckets;

		private double _averageBucketSize = -1;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="min">The minimum value of all the datapoints that are added to the Histogram</param>
		/// <param name="max">The maximum value of all the datapoints that are added to the Histogram</param>
		/// <param name="buckets">number of buckets</param>
		public Histogram(double min, double max, int buckets)
		{
			_min = min;
			_max = max;
			_numBuckets = buckets;

			_binWidth = (_max - _min) / (double)buckets;

			_buckets = new int[buckets + 1];
		}

		/// <summary>
		/// Adds a datapoint to the histogram and puts it in the appropriate bin.
		/// </summary>
		/// <param name="x">data point</param>
		public void add(double x)
		{
			_buckets[getBucket(x)]++;
		}

		/// <summary>
		/// Returns the number of datapoints in the bin where this
		/// datapoint lies.
		/// </summary>
		/// <param name="x">the datapoint</param>
		/// <returns>number of datapoints at x</returns>
		public int getBinSizeAt(double x)
		{
			return _buckets[getBucket(x)];
		}


		/// <summary>
		/// Returns which bucket the datapoint lies in.
		/// </summary>
		/// <param name="x">datapoint</param>
		/// <returns>bucket number</returns>
		private int getBucket(double x)
		{
			return (int)((x - _min) / _binWidth);
		}

		/// <summary>
		/// Calculates the bucket average.
		/// </summary>
		/// <returns></returns>
		public double calcBucketAverage()
		{
			int sum = 0;
			int i = 0;
			foreach(int b in _buckets)
			{				
				if(b > 0)
				{
					i++;
					sum += b;
				}
			}	
		
			_averageBucketSize = sum / i;

			return _averageBucketSize;
		}

		/// <summary>
		/// gets the average bucket size.  
		/// Note: This property value does not change if another data point is added.  
		/// In order for it to change you have to call calcBucketSize()
		/// </summary>
		public double average
		{
			get
			{
				if(_averageBucketSize < 0)
					return calcBucketAverage();

				return _averageBucketSize;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\Models\nnls.cc ===
// 	$Id: nnls.cc,v 1.1.2.1 2003/03/06 16:28:07 suvrit Exp $	
// File: nnls.cc
// Implements the Lawson-Hanson NNLS algorithm

#include "nnls.h"

double d_sign(double& a, double& b)
{
  double x;
  x = (a >= 0 ? a : - a);
  return (b >= 0 ? x : -x);
}
 
/* Table of constant values */
 
int c__1 = 1;
int c__0 = 0;
int c__2 = 2;


int nnls(double* a,  int mda,  int m,  int n, double* b, 
	 double* x, double* rnorm, double* w, double* zz, int* index, 
	 int* mode)
{
  /* System generated locals */
  int a_dim1, a_offset, idx1, idx2;
  double d1, d2;
 
 
  /* Local variables */
  static int iter;
  static double temp, wmax;
  static int i__, j, l;
  static double t, alpha, asave;
  static int itmax, izmax, nsetp;
  static double unorm, ztest, cc;
  double dummy[2];
  static int ii, jj, ip;
  static double sm;
  static int iz, jz;
  static double up, ss;
  static int rtnkey, iz1, iz2, npp1;
 
  /*     ------------------------------------------------------------------ 
   */
  /*     int INDEX(N) */
  /*     double precision A(MDA,N), B(M), W(N), X(N), ZZ(M) */
  /*     ------------------------------------------------------------------ 
   */
  /* Parameter adjustments */
  a_dim1 = mda;
  a_offset = a_dim1 + 1;
  a -= a_offset;
  --b;
  --x;
  --w;
  --zz;
  --index;
 
  /* Function Body */
  *mode = 1;
  if (m <= 0 || n <= 0) {
    *mode = 2;
    return 0;
  }
  iter = 0;
  itmax = n * 3;
 
  /*                    INITIALIZE THE ARRAYS INDEX() AND X(). */
 
  idx1 = n;
  for (i__ = 1; i__ <= idx1; ++i__) {
    x[i__] = 0.;
    /* L20: */
    index[i__] = i__;
  }
 
  iz2 = n;
  iz1 = 1;
  nsetp = 0;
  npp1 = 1;
  /*                             ******  MAIN LOOP BEGINS HERE  ****** */
 L30:
  /*                  QUIT IF ALL COEFFICIENTS ARE ALREADY IN THE SOLUTION. 
   */
  /*                        OR IF M COLS OF A HAVE BEEN TRIANGULARIZED. */
 
  if (iz1 > iz2 || nsetp >= m) {
    goto L350;
  }
 
  /*         COMPUTE COMPONENTS OF THE DUAL (NEGATIVE GRADIENT) VECTOR W(). 
   */
 
  idx1 = iz2;
  for (iz = iz1; iz <= idx1; ++iz) {
    j = index[iz];
    sm = 0.;
    idx2 = m;
    for (l = npp1; l <= idx2; ++l) {
      /* L40: */
      sm += a[l + j * a_dim1] * b[l];
    }
    w[j] = sm;
    /* L50: */
  }
  /*                                   FIND LARGEST POSITIVE W(J). */
 L60:
  wmax = 0.;
  idx1 = iz2;
  for (iz = iz1; iz <= idx1; ++iz) {
    j = index[iz];
    if (w[j] > wmax) {
      wmax = w[j];
      izmax = iz;
    }
    /* L70: */
  }
 
  /*             IF WMAX .LE. 0. GO TO TERMINATION. */
  /*             THIS INDICATES SATISFACTION OF THE KUHN-TUCKER CONDITIONS. 
   */
 
  if (wmax <= 0.) {
    goto L350;
  }
  iz = izmax;
  j = index[iz];
 
  /*     THE SIGN OF W(J) IS OK FOR J TO BE MOVED TO SET P. */
  /*     BEGIN THE TRANSFORMATION AND CHECK NEW DIAGONAL ELEMENT TO AVOID */
  /*     NEAR LINEAR DEPENDENCE. */
 
  asave = a[npp1 + j * a_dim1];
  idx1 = npp1 + 1;
  h12(c__1, &npp1, &idx1, m, &a[j * a_dim1 + 1], &c__1, &up, dummy, &
      c__1, &c__1, &c__0);
  unorm = 0.;
  if (nsetp != 0) {
    idx1 = nsetp;
    for (l = 1; l <= idx1; ++l) {
      /* L90: */
      /* Computing 2nd power */
      d1 = a[l + j * a_dim1];
      unorm += d1 * d1;
    }
  }
  unorm = sqrt(unorm);
  d2 = unorm + (d1 = a[npp1 + j * a_dim1], nnls_abs(d1)) * .01;
  if ((d2- unorm) > 0.) {
 
    /*        COL J IS SUFFICIENTLY INDEPENDENT.  COPY B INTO ZZ, UPDATE Z
	      Z */
    /*        AND SOLVE FOR ZTEST ( = PROPOSED NEW VALUE FOR X(J) ). */
 
    idx1 = m;
    for (l = 1; l <= idx1; ++l) {
      /* L120: */
      zz[l] = b[l];
    }
    idx1 = npp1 + 1;
    h12(c__2, &npp1, &idx1, m, &a[j * a_dim1 + 1], &c__1, &up, (zz+1), &
	c__1, &c__1, &c__1);
    ztest = zz[npp1] / a[npp1 + j * a_dim1];
 
    /*                                     SEE IF ZTEST IS POSITIVE */
 
    if (ztest > 0.) {
      goto L140;
    }
  }
 
  /*     REJECT J AS A CANDIDATE TO BE MOVED FROM SET Z TO SET P. */
  /*     RESTORE A(NPP1,J), SET W(J)=0., AND LOOP BACK TO TEST DUAL */
  /*     COEFFS AGAIN. */
 
  a[npp1 + j * a_dim1] = asave;
  w[j] = 0.;
  goto L60;
 
  /*     THE INDEX  J=INDEX(IZ)  HAS BEEN SELECTED TO BE MOVED FROM */
  /*     SET Z TO SET P.    UPDATE B,  UPDATE INDICES,  APPLY HOUSEHOLDER */
  /*     TRANSFORMATIONS TO COLS IN NEW SET Z,  ZERO SUBDIAGONAL ELTS IN */
  /*     COL J,  SET W(J)=0. */
 
 L140:
  idx1 = m;
  for (l = 1; l <= idx1; ++l) {
    /* L150: */
    b[l] = zz[l];
  }
 
  index[iz] = index[iz1];
  index[iz1] = j;
  ++iz1;
  nsetp = npp1;
  ++npp1;
 
  if (iz1 <= iz2) {
    idx1 = iz2;
    for (jz = iz1; jz <= idx1; ++jz) {
      jj = index[jz];
      h12(c__2, &nsetp, &npp1, m, 
	  &a[j * a_dim1 + 1], &c__1, &up, 
	  &a[jj * a_dim1 + 1], &c__1, &mda, &c__1);
      /* L160: */
    }
  }
 
  if (nsetp != m) {
    idx1 = m;
    for (l = npp1; l <= idx1; ++l) {
      /* L180: */
      // SS: CHECK THIS DAMAGE....
      a[l + j * a_dim1] = 0.;
    }
  }
 
  w[j] = 0.;
  /*                                SOLVE THE TRIANGULAR SYSTEM. */
  /*                                STORE THE SOLUTION TEMPORARILY IN ZZ(). 
   */
  rtnkey = 1;
  goto L400;
 L200:
 
  /*                       ******  SECONDARY LOOP BEGINS HERE ****** */
 
  /*                          ITERATION COUNTER. */
 
 L210:
  ++iter;
  if (iter > itmax) {
    *mode = 3;
    /* The following lines were replaced after the f2c translation */
    /* s_wsfe(&io___22); */
    /* do_fio(&c__1, " NNLS quitting on iteration count.", 34L); */
    /* e_wsfe(); */
    fprintf(stdout, "\n NNLS quitting on iteration count.\n");
    fflush(stdout);
    goto L350;
  }
 
  /*                    SEE IF ALL NEW CONSTRAINED COEFFS ARE FEASIBLE. */
  /*                                  IF NOT COMPUTE ALPHA. */
 
  alpha = 2.;
  idx1 = nsetp;
  for (ip = 1; ip <= idx1; ++ip) {
    l = index[ip];
    if (zz[ip] <= 0.) {
      t = -x[l] / (zz[ip] - x[l]);
      if (alpha > t) {
	alpha = t;
	jj = ip;
      }
    }
    /* L240: */
  }
 
  /*          IF ALL NEW CONSTRAINED COEFFS ARE FEASIBLE THEN ALPHA WILL */
  /*          STILL = 2.    IF SO EXIT FROM SECONDARY LOOP TO MAIN LOOP. */
 
  if (alpha == 2.) {
    goto L330;
  }
 
  /*          OTHERWISE USE ALPHA WHICH WILL BE BETWEEN 0. AND 1. TO */
  /*          INTERPOLATE BETWEEN THE OLD X AND THE NEW ZZ. */
 
  idx1 = nsetp;
  for (ip = 1; ip <= idx1; ++ip) {
    l = index[ip];
    x[l] += alpha * (zz[ip] - x[l]);
    /* L250: */
  }
 
  /*        MODIFY A AND B AND THE INDEX ARRAYS TO MOVE COEFFICIENT I */
  /*        FROM SET P TO SET Z. */
 
  i__ = index[jj];
 L260:
  x[i__] = 0.;
 
  if (jj != nsetp) {
    ++jj;
    idx1 = nsetp;
    for (j = jj; j <= idx1; ++j) {
      ii = index[j];
      index[j - 1] = ii;
      g1(&a[j - 1 + ii * a_dim1], &a[j + ii * a_dim1], 
	 &cc, &ss, &a[j - 1 + ii * a_dim1]);
      // SS: CHECK THIS DAMAGE...
      a[j + ii * a_dim1] = 0.;
      idx2 = n;
      for (l = 1; l <= idx2; ++l) {
	if (l != ii) {
 
	  /*                 Apply procedure G2 (CC,SS,A(J-1,L),A(J,
			     L)) */
 
	  temp = a[j - 1 + l * a_dim1];
	  // SS: CHECK THIS DAMAGE
	  a[j - 1 + l * a_dim1] = cc * temp + ss * a[j + l * a_dim1];
	  a[j + l * a_dim1] = -ss * temp + cc * a[j + l * a_dim1];
	}
	/* L270: */
      }
 
      /*                 Apply procedure G2 (CC,SS,B(J-1),B(J)) */
 
      temp = b[j - 1];
      b[j - 1] = cc * temp + ss * b[j];
      b[j] = -ss * temp + cc * b[j];
      /* L280: */
    }
  }
 
  npp1 = nsetp;
  --nsetp;
  --iz1;
  index[iz1] = i__;
 
  /*        SEE IF THE REMAINING COEFFS IN SET P ARE FEASIBLE.  THEY SHOULD 
   */
  /*        BE BECAUSE OF THE WAY ALPHA WAS DETERMINED. */
  /*        IF ANY ARE INFEASIBLE IT IS DUE TO ROUND-OFF ERROR.  ANY */
  /*        THAT ARE NONPOSITIVE WILL BE SET TO ZERO */
  /*        AND MOVED FROM SET P TO SET Z. */
 
  idx1 = nsetp;
  for (jj = 1; jj <= idx1; ++jj) {
    i__ = index[jj];
    if (x[i__] <= 0.) {
      goto L260;
    }
    /* L300: */
  }
 
  /*         COPY B( ) INTO ZZ( ).  THEN SOLVE AGAIN AND LOOP BACK. */
 
  idx1 = m;
  for (i__ = 1; i__ <= idx1; ++i__) {
    /* L310: */
    zz[i__] = b[i__];
  }
  rtnkey = 2;
  goto L400;
 L320:
  goto L210;
  /*                      ******  END OF SECONDARY LOOP  ****** */
 
 L330:
  idx1 = nsetp;
  for (ip = 1; ip <= idx1; ++ip) {
    i__ = index[ip];
    /* L340: */
    x[i__] = zz[ip];
  }
  /*        ALL NEW COEFFS ARE POSITIVE.  LOOP BACK TO BEGINNING. */
  goto L30;
 
  /*                        ******  END OF MAIN LOOP  ****** */
 
  /*                        COME TO HERE FOR TERMINATION. */
  /*                     COMPUTE THE NORM OF THE FINAL RESIDUAL VECTOR. */
 
 L350:
  sm = 0.;
  if (npp1 <= m) {
    idx1 = m;
    for (i__ = npp1; i__ <= idx1; ++i__) {
      /* L360: */
      /* Computing 2nd power */
      d1 = b[i__];
      sm += d1 * d1;
    }
  } else {
    idx1 = n;
    for (j = 1; j <= idx1; ++j) {
      /* L380: */
      w[j] = 0.;
    }
  }
  *rnorm = sqrt(sm);
  return 0;
 
  /*     THE FOLLOWING BLOCK OF CODE IS USED AS AN INTERNAL SUBROUTINE */
  /*     TO SOLVE THE TRIANGULAR SYSTEM, PUTTING THE SOLUTION IN ZZ(). */
 
 L400:
  idx1 = nsetp;
  for (l = 1; l <= idx1; ++l) {
    ip = nsetp + 1 - l;
    if (l != 1) {
      idx2 = ip;
      for (ii = 1; ii <= idx2; ++ii) {
	zz[ii] -= a[ii + jj * a_dim1] * zz[ip + 1];
	/* L410: */
      }
    }
    jj = index[ip];
    zz[ip] /= a[ip + jj * a_dim1];
    /* L430: */
  }
  switch ((int)rtnkey) {
  case 1:  goto L200;
  case 2:  goto L320;
  }
 
  /* The next line was added after the f2c translation to keep
     compilers from complaining about a void return from a non-void
     function. */
  return 0;
 
} /* nnls_ */


int g1(double* a, double* b, double* cterm, double* sterm, double* sig)
{
  /* System generated locals */
  double d;
 
  static double xr, yr;
 
 
  if (nnls_abs(*a) > nnls_abs(*b)) {
    xr = *b / *a;
    /* Computing 2nd power */
    d = xr;
    yr = sqrt(d * d + 1.);
    d = 1. / yr;
    *cterm = d_sign(d, *a);
    *sterm = *cterm * xr;
    *sig = nnls_abs(*a) * yr;
    return 0;
  }
  if (*b != 0.) {
    xr = *a / *b;
    /* Computing 2nd power */
    d = xr;
    yr = sqrt(d * d + 1.);
    d = 1. / yr;
    *sterm = d_sign(d, *b);
    *cterm = *sterm * xr;
    *sig = nnls_abs(*b) * yr;
    return 0;
  }
  *sig = 0.;
  *cterm = 0.;
  *sterm = 1.;
  return 0;
} /* g1_ */
 

/* See nnls.h for explanation */
int h12(int mode, int* lpivot, int* l1, 
	int m, double* u, int* iue, double* up, double* c__, 
	int* ice, int* icv, int* ncv)
{
  /* System generated locals */
  int u_dim1, u_offset, idx1, idx2;
  double d, d2;
 
  /* Builtin functions */
  /* The following line was commented out after the f2c translation */
  /* double sqrt(); */
 
  /* Local variables */
  static int incr;
  static double b;
  static int i__, j;
  static double clinv;
  static int i2, i3, i4;
  static double cl, sm;
 
  /*     ------------------------------------------------------------------ 
   */
  /*     double precision U(IUE,M) */
  /*     ------------------------------------------------------------------ 
   */
  /* Parameter adjustments */
  u_dim1 = *iue;
  u_offset = u_dim1 + 1;
  u -= u_offset;
  --c__;
 
  /* Function Body */
  if (0 >= *lpivot || *lpivot >= *l1 || *l1 > m) {
    return 0;
  }
  cl = (d = u[*lpivot * u_dim1 + 1], nnls_abs(d));
  if (mode == 2) {
    goto L60;
  }
  /*                            ****** CONSTRUCT THE TRANSFORMATION. ****** 
   */
  idx1 = m;
  for (j = *l1; j <= idx1; ++j) {
    /* L10: */
    /* Computing MAX */
    d2 = (d = u[j * u_dim1 + 1], nnls_abs(d));
    cl = nnls_max(d2,cl);
  }
  if (cl <= 0.) {
    goto L130;
  } else {
    goto L20;
  }
 L20:
  clinv = 1. / cl;
  /* Computing 2nd power */
  d = u[*lpivot * u_dim1 + 1] * clinv;
  sm = d * d;
  idx1 = m;
  for (j = *l1; j <= idx1; ++j) {
    /* L30: */
    /* Computing 2nd power */
    d = u[j * u_dim1 + 1] * clinv;
    sm += d * d;
  }
  cl *= sqrt(sm);
  if (u[*lpivot * u_dim1 + 1] <= 0.) {
    goto L50;
  } else {
    goto L40;
  }
 L40:
  cl = -cl;
 L50:
  *up = u[*lpivot * u_dim1 + 1] - cl;
  u[*lpivot * u_dim1 + 1] = cl;
  goto L70;
  /*            ****** APPLY THE TRANSFORMATION  I+U*(U**T)/B  TO C. ****** 
   */
 
 L60:
  if (cl <= 0.) {
    goto L130;
  } else {
    goto L70;
  }
 L70:
  if (*ncv <= 0) {
    return 0;
  }
  b = *up * u[*lpivot * u_dim1 + 1];
  /*                       B  MUST BE NONPOSITIVE HERE.  IF B = 0., RETURN. 
   */
 
  if (b >= 0.) {
    goto L130;
  } else {
    goto L80;
  }
 L80:
  b = 1. / b;
  i2 = 1 - *icv + *ice * (*lpivot - 1);
  incr = *ice * (*l1 - *lpivot);
  idx1 = *ncv;
  for (j = 1; j <= idx1; ++j) {
    i2 += *icv;
    i3 = i2 + incr;
    i4 = i3;
    sm = c__[i2] * *up;
    idx2 = m;
    for (i__ = *l1; i__ <= idx2; ++i__) {
      sm += c__[i3] * u[i__ * u_dim1 + 1];
      /* L90: */
      i3 += *ice;
    }
    if (sm != 0.) {
      goto L100;
    } else {
      goto L120;
    }
  L100:
    sm *= b;
    c__[i2] += sm * *up;
    idx2 = m;
    for (i__ = *l1; i__ <= idx2; ++i__) {
      c__[i4] += sm * u[i__ * u_dim1 + 1];
      /* L110: */
      i4 += *ice;
    }
  L120:
    ;
  }
 L130:
  return 0;
} /* h12 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\Models\main.cc ===
#include <iostream>
#include "nnls.h"

using namespace std;

int main()
{
	
	// Using column major for results....
	/*
	double a[] = {1, 4, 5, 10,
		5, 1, 4, 1,
		9, 10, 12, 20};
		*/

	double a[] = {
		0.949425415,0.079389733,0.395365642,0.151325039,0.274556446,
		0.518330962,0.897895826,0.097301761,0.374535338,0.630180126,
		0.739705618,0.446230778,0.811923362,0.522885967,0.21034813,
		0.86019892,0.6437977,0.11066775,0.47441034,0.04031565
	};

	double b[] = {
		1.70416717,3.23634261,0.30886228,1.23015087,2.518542338
	};
		

	int    mda = 5;
	int    m = 5, n = 4;
	//double b[] = {1, 3, 4, 1};
	double x[] = {1,1,1,1,1};
	
	/*
	i.e. nnls will give NNLS solution for:

	[ 1 10 4 10]    [1]
	[ 4 5  1 12]x - [3]
	[ 5 1  9 20]    [4]
	
	

	int    mda = 3;
	int    m = 3, n = 4;
	double b[] = {1, 3, 4, 1};
	double x[] = {1,1,1,1 ,1};
	


	//double a[] = {0.0372, 0.6861, 0.6233, 0.6344, 0.2869, 0.7071, 0.6245, 0.6170};
	

	/*
	i.e. nnls will give NNLS solution for:

	[0.0372    0.2869]		[0.8587]
    [0.6861    0.7071]		[0.1781]
    [0.6233    0.6245] x -	[0.0747]
    [0.6344    0.6170]		[0.8405]
	
	
	

	int    mda = 4;
	int    m = 4, n = 2;
	double b[] = {0.8587, 0.1781, 0.0747, 0.8405};
	//double b[] = {0.8405, 0.0747, 0.1781, 0.8587};
	double x[] = {1,1,1};*/



	//double a[] = {5, 4, 4, 3, 2, 1, 3, 12, 1, 4, 3, 2, 12, 2, 3, 2, 2, 41};
	//int    mda = 6;
	//int    m = 6, n = 3;
	//double b[] = {96, 69, 31, 34, 27, 254};
	//double x[] = {1,1,1};

	double rnorm;
	double w[4];
	double zz[4];
	int indx[5];
	int mode;
	int i;

	nnls(a, mda, m, n, b, x, &rnorm, w, zz, indx, &mode);
	for (i = 0; i < 5; i++)
		cout << x[i] << endl;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\Models\MultiVarLinearRegression.cs ===
using System;
using System.Collections;
using xonline.ops.tools.datawarehouse.capacity.matrixalgebra;

namespace xonline.ops.tools.datawarehouse.capacity.models 
{
	/// <summary>
	/// See the regression document to understand how parameters to the 
	/// multiple linear model are calculated. (http://sts/Xbox_Online/Tools/Forms/All%20Documents.aspx)
    /// It only requires one pass through the data and uses LinearEquations class to solve the 
    /// resulting Matrix.
	/// </summary>
	public class MultiVarLinearRegression : LinearModel
	{        
        private double[][]  _M;
        private double[]    _C;  

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="variables">Number of variables we are finding the parameters (coefficients) for.</param>
		public MultiVarLinearRegression(int variables)
		{
            this.modelName = "MultiLinear";
            _variables = variables;
            _useConstant = true;
            _M = new double[_variables + 1][];

            for(int i = 0; i < _variables + 1; i++)
                _M[i] = new double[_variables + 1];

            _C = new double[_variables + 1];

            initializeArrays();
		}
       

        /// <summary>
        /// The length of xs better be the same as the number of variables
        /// </summary>
        /// <param name="xs">observed x values</param>
        /// <param name="y">observed y value</param>
        protected override void helper_add( double[] xs, double y)
        {
            _inputs.Add(xs);
            _outputs.Add(y);

            for(int j = 0; j < _variables + 1; j++)
            {
                double x1 = j - 1 < 0 ? 1 : xs[j - 1];

                for(int k = 0; k < _variables + 1; k++)
                {                    
                    double x2 = k - 1 < 0 ? 1 : xs[k - 1];
                    
                    _M[j][k] += x1 * x2;                    
                }
                _C[j] += y * x1;
            }
        }

        /// <summary>
        /// Overrode reset so that we can reset _M and _C
        /// </summary>
        public override void reset()
        {
            base.reset();
            _M = new double[_variables + 1][];

            for(int i = 0; i < _variables + 1; i++)
                _M[i] = new double[_variables + 1];

            _C = new double[_variables + 1];
        }

        /// <summary>
        /// Solve the system of linear equations. 
        /// Matrices: _M * _P = _C
        /// </summary>
        protected override void train()
        {
            LinearEquations linear = new LinearEquations(_M, _C);
            
            ArrayList solution = linear.solution();

            this._constant = (double)solution[0];
                        
            for(int i = 1; i < solution.Count; i++)
                _parameters[i - 1] = (double)solution[i];
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\Models\nnls.h ===
#ifndef NNLS_H
#define NNLS_H

#include <stdio.h>
#include <math.h>
#define nnls_max(a,b) ((a) >= (b) ? (a) : (b))
#define nnls_abs(x) ((x) >= 0 ? (x) : -(x))

typedef int integer;
typedef double doublereal;

/*     SUBROUTINE NNLS  (A,MDA,M,N,B,X,RNORM,W,ZZ,INDEX,MODE) */
 
/*  Algorithm NNLS: NONNEGATIVE LEAST SQUARES */
 
/*  The original version of this code was developed by */
/*  Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory */
/*  1973 JUN 15, and published in the book */
/*  "SOLVING LEAST SQUARES PROBLEMS", Prentice-HalL, 1974. */
/*  Revised FEB 1995 to accompany reprinting of the book by SIAM. */
 
/*     GIVEN AN M BY N MATRIX, A, AND AN M-VECTOR, B,  COMPUTE AN */
/*     N-VECTOR, X, THAT SOLVES THE LEAST SQUARES PROBLEM */
 
/*                      A * X = B  SUBJECT TO X .GE. 0 */
/*     ------------------------------------------------------------------ */
/*                     Subroutine Arguments */
 
/*     A(),MDA,M,N     MDA IS THE FIRST DIMENSIONING PARAMETER FOR THE */
/*                     ARRAY, A().   ON ENTRY A() CONTAINS THE M BY N */
/*                     MATRIX, A.           ON EXIT A() CONTAINS */
/*                     THE PRODUCT MATRIX, Q*A , WHERE Q IS AN */
/*                     M BY M ORTHOGONAL MATRIX GENERATED IMPLICITLY BY */
/*                     THIS SUBROUTINE. */
/*     B()     ON ENTRY B() CONTAINS THE M-VECTOR, B.   ON EXIT B() CON- */
/*             TAINS Q*B. */
/*     X()     ON ENTRY X() NEED NOT BE INITIALIZED.  ON EXIT X() WILL */
/*             CONTAIN THE SOLUTION VECTOR. */
/*     RNORM   ON EXIT RNORM CONTAINS THE EUCLIDEAN NORM OF THE */
/*             RESIDUAL VECTOR. */
/*     W()     AN N-ARRAY OF WORKING SPACE.  ON EXIT W() WILL CONTAIN */
/*             THE DUAL SOLUTION VECTOR.   W WILL SATISFY W(I) = 0. */
/*             FOR ALL I IN SET P  AND W(I) .LE. 0. FOR ALL I IN SET Z */
/*     ZZ()     AN M-ARRAY OF WORKING SPACE. */
/*     INDEX()     AN INT WORKING ARRAY OF LENGTH AT LEAST N. */
/*                 ON EXIT THE CONTENTS OF THIS ARRAY DEFINE THE SETS */
/*                 P AND Z AS FOLLOWS.. */
 
/*                 INDEX(1)   THRU INDEX(NSETP) = SET P. */
/*                 INDEX(IZ1) THRU INDEX(IZ2)   = SET Z. */
/*                 IZ1 = NSETP + 1 = NPP1 */
/*                 IZ2 = N */
/*     MODE    THIS IS A SUCCESS-FAILURE FLAG WITH THE FOLLOWING */
/*             MEANINGS. */
/*             1     THE SOLUTION HAS BEEN COMPUTED SUCCESSFULLY. */
/*             2     THE DIMENSIONS OF THE PROBLEM ARE BAD. */
/*                   EITHER M .LE. 0 OR N .LE. 0. */
/*             3    ITERATION COUNT EXCEEDED.  MORE THAN 3*N ITERATIONS. */
 
/*     ------------------------------------------------------------------ */
/* Subroutine */ 
int nnls(double* a, int mda, int m, int n, 
	  double* b, double* x, double* rnorm, 
	  double* w, double* zz, int* index, int* mode);



/*     SUBROUTINE H12 (MODE,LPIVOT,L1,M,U,IUE,UP,C,ICE,ICV,NCV) */
 
/*  CONSTRUCTION AND/OR APPLICATION OF A SINGLE */
/*  HOUSEHOLDER TRANSFORMATION..     Q = I + U*(U**T)/B */
 
/*  The original version of this code was developed by */
/*  Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory */
/*  1973 JUN 12, and published in the book */
/*  "SOLVING LEAST SQUARES PROBLEMS", Prentice-HalL, 1974. */
/*  Revised FEB 1995 to accompany reprinting of the book by SIAM. */
/*     ------------------------------------------------------------------ */
/*                     Subroutine Arguments */
 
/*     MODE   = 1 OR 2   Selects Algorithm H1 to construct and apply a */
/*            Householder transformation, or Algorithm H2 to apply a */
/*            previously constructed transformation. */
/*     LPIVOT IS THE INDEX OF THE PIVOT ELEMENT. */
/*     L1,M   IF L1 .LE. M   THE TRANSFORMATION WILL BE CONSTRUCTED TO */
/*            ZERO ELEMENTS INDEXED FROM L1 THROUGH M.   IF L1 GT. M */
/*            THE SUBROUTINE DOES AN IDENTITY TRANSFORMATION. */
/*     U(),IUE,UP    On entry with MODE = 1, U() contains the pivot */
/*            vector.  IUE is the storage increment between elements. */
/*            On exit when MODE = 1, U() and UP contain quantities */
/*            defining the vector U of the Householder transformation. */
/*            on entry with MODE = 2, U() and UP should contain */
/*            quantities previously computed with MODE = 1.  These will */
/*            not be modified during the entry with MODE = 2. */
/*     C()    ON ENTRY with MODE = 1 or 2, C() CONTAINS A MATRIX WHICH */
/*            WILL BE REGARDED AS A SET OF VECTORS TO WHICH THE */
/*            HOUSEHOLDER TRANSFORMATION IS TO BE APPLIED. */
/*            ON EXIT C() CONTAINS THE SET OF TRANSFORMED VECTORS. */
/*     ICE    STORAGE INCREMENT BETWEEN ELEMENTS OF VECTORS IN C(). */
/*     ICV    STORAGE INCREMENT BETWEEN VECTORS IN C(). */
/*     NCV    NUMBER OF VECTORS IN C() TO BE TRANSFORMED. IF NCV .LE. 0 */
/*            NO OPERATIONS WILL BE DONE ON C(). */
/*     ------------------------------------------------------------------ */
/* Subroutine */ 
int h12(int mode, int* lpivot, int* l1, 
	 int m, double* u, int* iue, double* up, double* c__, 
	 int* ice, int* icv, int* ncv);


    /*     COMPUTE ORTHOGONAL ROTATION MATRIX.. */
 
    /*  The original version of this code was developed by */
    /*  Charles L. Lawson and Richard J. Hanson at Jet Propulsion Laboratory 
     */
    /*  1973 JUN 12, and published in the book */
    /*  "SOLVING LEAST SQUARES PROBLEMS", Prentice-HalL, 1974. */
    /*  Revised FEB 1995 to accompany reprinting of the book by SIAM. */
 
    /*     COMPUTE.. MATRIX   (C, S) SO THAT (C, S)(A) = (SQRT(A**2+B**2)) */
    /*                        (-S,C)         (-S,C)(B)   (   0          ) */
    /*     COMPUTE SIG = SQRT(A**2+B**2) */
    /*        SIG IS COMPUTED LAST TO ALLOW FOR THE POSSIBILITY THAT */
    /*        SIG MAY BE IN THE SAME LOCATION AS A OR B . */
int g1(double* a, double* b, double* cterm, double* sterm, double* sig);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\Models\LinearModel.cs ===
using System;
using System.Xml;
using System.Collections;

namespace xonline.ops.tools.datawarehouse.capacity.models 
{
	/// <summary>
	/// LinearModel.  All parameterized linear models inherit from this base class.
	/// This class has useful functions inherent in every linear model: 
	///     add(), computerR2, compute(), toXml(), accessor properties, ...
	/// 
	/// Some nomenclature:
	/// 
	/// A multivariable linear equation:
	///     y = a1x1 + a2x2 + a3x3 + ... + b
	///     
	/// y           := output variable, or just y
	/// a1,a2,a3... := parameters or the weights
	/// x1,x2,x3... := variables
	/// b           := constant
	/// 
	/// 
	/// In linear models we try to find the weights that best fit the data.
	/// Or that make R2 closer to 1.  (R2 is in [0,1], the closer it is to 1 the better
	/// it fits the data, the closer to 0 the worse).
	/// 
	/// </summary>
	public abstract class LinearModel
	{
        /// <summary>
        /// R squared. Or the correlation coefficient
        /// </summary>
        protected double _RSquared = System.Double.NaN;

        /// <summary>
        /// Used to calculated _RSquared in case _useConstant == true
        /// </summary>
        protected double _averageY = 0;

        /// <summary>
        /// Used to calculated _RSquared in case _useConstant == true
        /// </summary>
        protected double _sumY = 0;

        /// <summary>
        /// True if we add a constant to the equation.
        /// This effects how we compute R Squared.
        /// Ex: y = ax + b, or y = ax1 + bx2 + b
        /// </summary>
        protected bool _useConstant = false;

        /// <summary>
        /// The value of the computed constant.
        /// </summary>
        protected double _constant = 0;

        /// <summary>
        /// The number of input variables.
        /// </summary>
        protected int _variables;


        /// <summary>
        /// The parameters, or the weights. 
        /// !!!NOT INCLUDING THE CONSTANT!!!
        /// </summary>
        protected double[] _parameters;

        /// <summary>
        /// Only used in computeR2().  We save the inputs and outputs
        /// </summary>
        protected ArrayList _inputs; 

        /// <summary>
        /// Only used in computeR2().  We save the inputs and outputs
        /// </summary>
        protected ArrayList _outputs;

        
        private string _modelName = "LinearModel";

        /// <summary>
        /// True when the parameters are calculated.
        /// </summary>
        protected bool _trained = false;


        /// <summary>
        /// Adds the observed inputs and the observed output.
        /// </summary>
        /// <param name="xs">inputs</param>
        /// <param name="y">output</param>
        public void add(double[] xs, double y)
        {            
            helper_add(xs, y);         
            _sumY += y;
            _averageY = _sumY / _outputs.Count;
        }

        /// <summary>
        /// This is the function to override.
        /// </summary>
        /// <param name="xs"></param>
        /// <param name="y"></param>
        protected virtual void helper_add(double[] xs, double y)
        {
            _inputs.Add(xs);
            _outputs.Add(y);
        }


        protected virtual void initializeArrays()
        {
            _parameters = new double[_variables];
            _inputs = new ArrayList();
            _outputs = new ArrayList();      
        }
        
        /// <summary>
        /// Finds the parameters or the weights.
        /// If it is already trained then when called again it shouldn't do it again.
        /// </summary>
        protected abstract void train();
        

        /// <summary>
        /// Compute based on the trained parameters and these inputs
        /// </summary>
        /// <param name="xs">the inputs</param>
        /// <returns>the computed value</returns>
        public virtual double compute(double[] xs)
        {
            if(!_trained)
                train(); // gets us the parameters

            _trained = true;
            
            double sum = 0;
            for(int i = 0; i < _variables; i++)
            {
                sum += xs[i] * _parameters[i];                
            }

            return sum + _constant; // if the constant is not used then _constant == 0
        }

        
        public virtual double getRSquared()
        {
            if(System.Double.IsNaN(_RSquared)) computeR2();
            return _RSquared;
        }      
  
		public virtual double getConstant()
		{
			return _constant;
		}

        /// <summary>
        /// Returns the parameters.
        /// </summary>
        /// <returns></returns>
        public virtual double[] getParameters()
        {
            if(!_trained)
                train();

            _trained = true;

            return _parameters;
        }

        /// <summary>
        /// R2 is computed differently if we use a constant or not.
        /// </summary>
        /// <returns></returns>
        protected virtual double computeR2() {        
            if(!System.Double.IsNaN(_RSquared)) return _RSquared;
            
            // SSRes = Sum((actual y - calc y)^2)
            double SSres = 0;
            double SSTotal = 0; 
            
            for(int c = 0; c < _inputs.Count; c++)
            {
                double computed = compute((double[])_inputs[c]);
                SSres += (computed - ((double)_outputs[c])) * (computed - ((double)_outputs[c]));

                if(_useConstant)
                {
                    SSTotal += ( ((double)_outputs[c]) - _averageY ) * ( ((double)_outputs[c]) - _averageY );
                }
                else
                {
                    SSTotal += ((double)_outputs[c]) * ((double)_outputs[c]);
                }
            }

            double SSREG = SSTotal - SSres;

            _RSquared = SSREG / SSTotal;
            return _RSquared;
        }

        public virtual void reset()
        {
            initializeArrays();
            _constant = 0;
            _RSquared = System.Double.NaN;
            _averageY = 0;
            _sumY = 0;
            _trained = false;
        }

        /// <summary>
        /// Returns an Xml representation of this model.
        /// Associated with each ParamName is the param value.
        /// </summary>
        /// <param name="doc">The XmlDocument for which you want the returned XmlNode to fit in.</param>
        /// <param name="paramNames">Array of the parameter names.  Lenght better be equal to this.variables</param>
        /// <returns></returns>
        public virtual XmlNode toXml(XmlDocument doc, string[] paramNames)
        {
            if(!_trained)
                train();

            _trained = true;

            XmlNode n = doc.CreateElement(_modelName);
           
            XmlNode g = doc.CreateElement("constant");

            if(_useConstant)
            {
                Utils.addAttr(g, "value", _constant.ToString());
                n.AppendChild(g);
            }        

            for(int i = 0; i < _parameters.Length; i++)
            {
                g = doc.CreateElement(Utils.fixXmlNodeName(paramNames[i]));
                Utils.addAttr(g, "value", _parameters[i].ToString());

                n.AppendChild(g);
            }

            g = doc.CreateElement("R2");
            Utils.addAttr(g, "value", getRSquared().ToString());
            n.AppendChild(g);

            return n;
        }

        /// <summary>
        /// The name of the model.
        /// </summary>
        public string modelName
        {
            get
            {
                return _modelName;
            }
            set
            {
                _modelName = value;
            }
        }

        /// <summary>
        /// The number of variables for the model.
        /// Only set variables right after a reset
        /// </summary>
        public int variables
        {
            get
            {
                return _variables;
            } 
            set
            {
                _variables = value;
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\Models\Perceptron.cs ===
using System;
using System.Collections;


namespace xonline.ops.tools.datawarehouse.capacity.models 
{
	/// <summary>
	/// TODO: HAS A BUG THAT NEEDS TO BE FIXED:
	/// R2 is computed wrongly.  It uses the normalized inputs and outputs to compute R2 while
	/// it should use real inputs and outputs.
	/// 
    /// A single layer neural network that can force the weights to be positive.
    /// There is no activation function.  The activation function is thus just the identity.
    /// (Hence there is no threshold to exceed and so forth, the output is always the sum of 
    /// the weights times the inputs).
    /// 
    /// You can force the weights to be positive in training.  What happens is when a weight
    /// becomes less than zero the weight is set to 0.
    /// 
    /// Amazingly when forcing the weights to be positive, the R2 is much much better than that
    /// solved by multiple linear regression which allows the weights to be negative.  The R2 is also
    /// much better than the solution found using a perceptron while allowing the weights to be negative.
    /// 
    /// This may be due to the fact that we are solving an optimization problem by gradient descent. 
    /// (the problem is finding a vector of weights that minimize the error)
    /// 
    /// So when we set a weight to be 0 we are searching for a local minimum by randomization in conjunction
    /// with gradient descent and hence this becomes a better optimization search solution.  It may also be better just because we 
    /// are truly modeling the data (in our case) when forcing the weights to be positive. 
    /// (ex:
    ///     cpu = a1op1 + a2op2 +...
    ///     how could op1 negatively affect cpu?
    /// )
    /// 
    /// This perceptron can also find the constant by adding an extra input which is always 1.
    /// The weight then associated with that input (aka 1) is then the constant.
	/// </summary>
	public class Perceptron : LinearModel
	{
        /// <summary>
        /// Number of times to go through the inputs
        /// and adjust the weights.
        /// </summary>
        private int _epochs;

        /// <summary>
        /// Rate of learning, should be between 0 and 1 (ex: .0015)
        /// </summary>
        private double _learningRate;
        
        /// <summary>
        /// Force the weights to be positive if true
        /// </summary>
        private bool _positive;
        
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="numInputs">Or the number of parameters</param>
        /// <param name="numOutputs">For now only one output</param>
        /// <param name="epochs">Number of times to go through the inputs and adjust the weights</param>
        /// <param name="learningRate">should be between 0 and 1 (ex: .015) </param>
        /// <param name="positive">true to force the weights to be positive or zero otherwise some may be negative</param>
		public Perceptron(int numInputs, bool constant, int epochs, double learningRate, bool positive)
		{
            this.modelName = "Perceptron";
            _epochs = epochs;
            _learningRate = learningRate;
            _variables = numInputs;
            _positive = positive;

            _useConstant = constant;
            
            initializeArrays();      
		}

        /// <summary>
        /// Train() uses a slight variant to the perceptron learning rule by Frank Rosenblatt 1960
        /// Wi = Wi + learningConstant * Input * Err
        /// 
        /// He states that a system using the perceptron learning rule will converge to a
        /// set of weights that correctly represents the examples.
        /// 
        /// This is also a form of gradient descent search in the weight space.
        /// </summary>
        protected override void train()
        {            
            initializeWeights();

            // normalize
            normalize();
            
            int good = 0;                        

            _trained = true;

            for(int e = 0; e < _epochs; e++)
            {
                good = 0;                                

                // go through all the inputs
                for(int c = 0; c < _inputs.Count; c++)
                {
                    double computed = compute((double[])_inputs[c]);
                    double err = ((double)_outputs[c]) - computed;                    

                    if( Math.Abs(err) / ((double)_outputs[c]) > .10)
                    {
                        // adjust all the weights
                        for(int i = 0; i < _variables; i++)
                        {
                            _parameters[i] += _learningRate * ((double[])_inputs[c])[i] * err;

                            if(_useConstant)
                            {
                                _constant += _learningRate * 1 * err; // the constants input is always 1 !!!!!
                            }
                            
                            // this is where weights are forced to be positive if desired
                            if(_positive && (_parameters[i] < 0))
                            {
                                _parameters[i] = 0;
                            }
                        }
                    }
                    else if(good++ >= (_inputs.Count * 0.9)) // comes here if err / output < .10
                    {                        
                        return;
                    }
                }
            }
        }

        /// <summary>
        /// Normalize.  Finds the maximum accross all the inputs and outputs.
        /// Then divides everything by that maximum.
        /// 
        /// This helps to find a solution to the weights.
        /// </summary>
        private void normalize()
        {
            // find the largest
            bool first = true;
            double max = 0;
            foreach(double[] inputs in this._inputs)
            {
                foreach(double d in inputs)
                {
                    if(first)
                    {
                        max = d;
                        first = false;
                    }

                    if(d > max) max = d;
                }
            }

            foreach(double d in this._outputs)
            {
                if(d > max) max = d;
            }

            for(int k = 0; k < _inputs.Count; k++)
            {
                for(int i = 0; i < ((double[])_inputs[i]).Length; i++)
                    ((double[])_inputs[k])[i] = ((double[])_inputs[k])[i] / max;
            }

            for(int i = 0; i < _outputs.Count; i++)
                _outputs[i] = ((double)_outputs[i]) / max;
        }

        private void initializeWeights()
        {
            Random rnd = new Random();
            for(int i = 0; i < _variables; i++)
            {
                _parameters[i] = 0; //rnd.Next(-1, 1); TODO: find random variable [0,1]
            }
        }

        /// <summary>
        /// Number of times to go through the inputs
        /// and adjust the weights.
        /// </summary>
        public int epochs
        {
            get
            {
                return _epochs;
            }            
        }

        /// <summary>
        /// Rate of learning, should be between 0 and 1 (ex: .0015)
        /// </summary>
        public double learningRate
        {
            get
            {
                return _learningRate;
            }            
        }

        /// <summary>
        /// Force the weights to be positive if true
        /// </summary>
        public bool positive
        {
            get
            {
                return _positive;
            }            
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\capacity\Models\Utils.cs ===
using System;
using System.Xml;

namespace xonline.ops.tools.datawarehouse.capacity.models 
{
	/// <summary>
	/// Class with util functions.  Couldn't find a namespace to put this class in.
	/// </summary>
	public class Utils
	{
        public Utils() {}

        
        /// <summary>
        /// Adds an attribute to a node.  If the attribute exists, it replaces it.
        /// </summary>
        /// <param name="node">The node to add the attribute to.</param>
        /// <param name="name">Name of the attribute.</param>
        /// <param name="val">The value of the attribute.</param>
        public static void addAttr(XmlNode node, string name, string val)
        {
            XmlAttribute attr = node.OwnerDocument.CreateAttribute(name);
            attr.Value = val;

            node.Attributes.SetNamedItem(attr);
        }

        /// <summary>
        /// Removes unwanted characters from str and returns the string
        /// with the unwanted characters replaced by _
        /// </summary>
        /// <param name="str"></param>
        /// <returns></returns>
        public static string fixXmlNodeName(string str)
        {
            return str.Replace(" ", "_").Replace("(", "_").Replace(")", "_").Replace("!", "_").Replace(".", "_").Replace("\\", "_");
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\inventory\EditEqp.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;
using System.Configuration;
using System.Data.SqlTypes;

namespace xonline.ops.tools.inventory 
{
	/// <summary>
	/// Summary description for EditEqp.
	/// </summary>
	public class EditEqp : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.Label AssetTag;
        protected System.Web.UI.WebControls.TextBox SeralNumber;
        protected System.Web.UI.WebControls.TextBox Name;
        protected System.Web.UI.HtmlControls.HtmlSelect Site;
        protected System.Web.UI.HtmlControls.HtmlSelect Storage;
        protected System.Web.UI.WebControls.TextBox ShelfBegin;
        protected System.Web.UI.WebControls.TextBox ShelfEnd;
        protected System.Web.UI.WebControls.CheckBox IsStorage;
        protected System.Web.UI.WebControls.TextBox AssetTagEdit;
        protected System.Web.UI.WebControls.CheckBox InUse;
        protected System.Web.UI.WebControls.TextBox PurchasPrice;
        protected System.Web.UI.WebControls.TextBox ReplValue;
        protected System.Web.UI.WebControls.TextBox PurchaseDate;
        protected System.Web.UI.HtmlControls.HtmlGenericControl message;
        protected System.Web.UI.HtmlControls.HtmlSelect Model;
    
		private void Page_Load(object sender, System.EventArgs e)
		{
			// here we bind all the data in case AssetTag is not "new"           
            if(this.IsPostBack)
            {
                update(Request["AssetTag"]);
            }

            if(Request["AssetTag"] == "" || Request["AssetTag"] == null)
            {
                Response.End();
            }

            bindSites();
            bindModelSelect();
            bindStorage(Request["Site"]);

            if(Request["AssetTag"] != "new") 
            {
                // here we run all the queries to bind the data
                AssetTag.Text = Request["AssetTag"];
                getInfo(Request["AssetTag"]);
                getLocation(Request["AssetTag"]);
            }

            // show in which mode we are in
            if(Request["Alias"] != "''")
            {
                message.InnerText = Request["Alias"] + " Performing inventory...";
            }
            else
                message.InnerText = "Performing Editing...";

        }

        /// <summary>
        /// Update the equipment info
        /// </summary>
        /// <param name="assetTag"></param>
        private void update(string assetTag)
        {
            
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();
            string cmdStr = "exec p_UpdateEqp " 
                    + "'" + assetTag + "' "
                    + ", NULL" 
                    + ", NULL"
                    + ", NULL"
                + add(Request.Form["Site"])
                + add(this.SeralNumber.Text)
                + add(this.Name.Text)
                + add(this.PurchaseDate.Text)
                + add(this.PurchasPrice.Text)
                + add(Convert.ToString(Convert.ToInt32(this.InUse.Checked)))
                + add(this.ReplValue.Text)
                + add(Request.Form["Model"])
                + add(Convert.ToString(Convert.ToInt32(this.IsStorage.Checked)))
                + add(Request.Form["Storage"])
                + add(this.ShelfBegin.Text)
                + add(this.ShelfEnd.Text);

            if(Request["Alias"] != "''" && Request["Alias"] != null)
            {
                // if this is an inventory
                cmdStr = "exec p_UpdateEqp " 
                    + "'" + assetTag + "' "
                    + add(DateTime.Now.ToString())
                    + ", " + Request["Alias"] 
                    + ", " + Request["Inventory"] 
                    + add(Request.Form["Site"])
                    + add(this.SeralNumber.Text)
                    + add(this.Name.Text)
                    + add(this.PurchaseDate.Text)
                    + add(this.PurchasPrice.Text)
                    + add(Convert.ToString(Convert.ToInt32(this.InUse.Checked)))
                    + add(this.ReplValue.Text)
                    + add(Request.Form["Model"])
                    + add(Convert.ToString(Convert.ToInt32(this.IsStorage.Checked)))
                    + add(Request.Form["Storage"])
                    + add(this.ShelfBegin.Text)
                    + add(this.ShelfEnd.Text);
            }

            SqlCommand  cmd = new SqlCommand (cmdStr, conn);

            cmd.CommandType = CommandType.Text;
            cmd.ExecuteNonQuery();           

            conn.Close();            
        }

        private string add(string first)
        {
            if(first != "")
                return ", '" + first + "' ";
            else
                return ", NULL ";
        }

        private void getInfo(string assetTag)
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();
            SqlDataAdapter  cmd = new SqlDataAdapter ("select " +
                "Edited, AssetTag, SerialNumber, SiteID, RTRIM(Name) as Name, " + 
                " cast(DATEPART(mm, PurchaseDate) as char(2)) + '-' + cast(DATEPART(dd, PurchaseDate) as char(2)) + '-' + cast(DATEPART(yy, PurchaseDate) as char(4)) as PurchaseDate,  " +                
                " PurchasePrice, InUse, ReplValue, " +
                "uModelID, IsStorage  " +
                "from  " +
                "Equipment where  AssetTag = '" + assetTag + "'", conn);
		    

            DataSet ds = new DataSet();
            cmd.Fill(ds);
		    
            SeralNumber.Text = ds.Tables[0].Rows[0]["SerialNumber"].ToString();
            this.Site.Value = ds.Tables[0].Rows[0]["SiteID"].ToString();
            this.Name.Text = ds.Tables[0].Rows[0]["Name"].ToString();
            this.PurchaseDate.Text = ds.Tables[0].Rows[0]["PurchaseDate"].ToString();
            this.PurchasPrice.Text = ds.Tables[0].Rows[0]["PurchasePrice"].ToString();
            this.InUse.Checked = Convert.ToBoolean(ds.Tables[0].Rows[0]["InUse"].ToString());
            this.ReplValue.Text = ds.Tables[0].Rows[0]["ReplValue"].ToString();
            this.Model.Value = ds.Tables[0].Rows[0]["uModelID"].ToString();
            this.IsStorage.Checked = Convert.ToBoolean(ds.Tables[0].Rows[0]["IsStorage"].ToString());
            
            conn.Close();
        }

        /// <summary>
        /// Bind the storage list box and the ShelfBegin and ShelfEnd text boxes.
        /// </summary>
        /// <param name="assetTag"></param>
        private void getLocation(string assetTag)
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();
            SqlDataAdapter  cmd = new SqlDataAdapter ("select ShelfBegin, ShelfEnd, B.AssetTag " + 
                    " from Equipment A join Locations B on A.LocationID = B.LocationID " +
                    " where A.AssetTag = '" + assetTag + "'", conn);
		    

            DataSet ds = new DataSet();
            int i = cmd.Fill(ds);
  

            if(i != 0)
            {
                this.Storage.Value = ds.Tables[0].Rows[0]["AssetTag"].ToString();
                this.ShelfBegin.Text = ds.Tables[0].Rows[0]["ShelfBegin"].ToString();
                this.ShelfEnd.Text = ds.Tables[0].Rows[0]["ShelfEnd"].ToString();
            }

            
            conn.Close();
        }

        /// <summary>
        /// Bind the Sites listbox.
        /// </summary>
        private void bindSites()
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();
            string cmdStr = "select * from Sites";

            SqlDataAdapter  cmd = new SqlDataAdapter(cmdStr, conn);
		    

            Site.DataTextField = "ShortSiteName";
            Site.DataValueField = "SiteID";
            DataSet ds = new DataSet();
            cmd.Fill(ds);
            Site.DataSource = ds;
            Site.DataBind();
            
            conn.Close();            
        }

        /// <summary>
        /// Bind the storage listbox, any Equipment that has IsStorage = 1 and and the same Site as 
        /// the one we are looking at will show up here.
        /// </summary>
        /// <param name="site"></param>
        private void bindStorage(string site)
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            string cmdStr = "select Name, RTRIM(AssetTag) as AssetTag from Equipment where SiteID = " 
                            + site + " and IsStorage = '1' or SiteID = '14'";

            SqlDataAdapter  cmd = new SqlDataAdapter(cmdStr, conn);
		    

            Storage.DataTextField = "Name";
            Storage.DataValueField = "AssetTag";
            DataSet ds = new DataSet();
            cmd.Fill(ds);
            Storage.DataSource = ds;
            Storage.DataBind();
            
            conn.Close();            
        }

        /// <summary>
        /// Bind the models list box
        /// </summary>
        private void bindModelSelect()
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();
            string cmdStr = "select '[' + B.Type + '] ' + A.Model  as Model, A.uModelID as ModelID " +
                            " from Models  A join EqpTypes B on A.EquipTypeID = B.EquipTypeID order by Model";

            SqlDataAdapter  cmd = new SqlDataAdapter(cmdStr, conn);
		    

            Model.DataTextField = "Model";           
            Model.DataValueField = "ModelID";
            DataSet ds = new DataSet();
            cmd.Fill(ds);
            Model.DataSource = ds;
            Model.DataBind();
            
            conn.Close();            
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\inventory\default.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Configuration;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Security.Principal;

namespace xonline.ops.tools.inventory 
{
	/// <summary>
	/// Summary description for _default.
	/// </summary>
	public class _default : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.TextBox Alias;
        protected System.Web.UI.HtmlControls.HtmlSelect Site;
        protected System.Web.UI.HtmlControls.HtmlSelect editSite;
        protected System.Web.UI.HtmlControls.HtmlSelect editInventory;
        protected System.Web.UI.HtmlControls.HtmlTextArea Assets;
        protected System.Web.UI.HtmlControls.HtmlSelect ReportSite;
        protected System.Web.UI.HtmlControls.HtmlSelect Inventory2;
        protected System.Web.UI.HtmlControls.HtmlSelect Inventory1;
        protected System.Web.UI.WebControls.TextBox assetTag;
        protected System.Web.UI.HtmlControls.HtmlInputHidden SubmitType;
        protected System.Web.UI.HtmlControls.HtmlSelect Select2;
        protected System.Web.UI.WebControls.TextBox name;
        protected System.Web.UI.WebControls.TextBox serialNum;
        protected System.Web.UI.HtmlControls.HtmlSelect Inventory;
    
		private void Page_Load(object sender, System.EventArgs e)
		{
            // Just do some bindings
            bindSites(Site);
            bindSites(editSite);
            bindInventory(Inventory);
            bindInventory(editInventory);

            bindSites(ReportSite);
            bindInventory(Inventory2);
            bindInventory(Inventory1);

            Alias.Text = removeDomain(Request["AUTH_USER"]);

            if(this.IsPostBack)
            {
                // if this is a post back then it must
                // be from the doing inventory part.

                switch(Request["SubmitType"])
                {
                    case "report":
                        Response.Redirect("report.aspx?alias=" + Alias.Text 
                            + "&Site=" + Request.Form["ReportSite"] 
                            + "&Inventory2=" + Request.Form["Inventory2"]
                            + "&Inventory1=" + Request.Form["Inventory1"]
                            );
                        break;
                    case "name":                
                        Response.Redirect("EqpSearch.aspx?name=" + Request["name"]);
                        break;
                    case "asset":
                        Response.Redirect("EqpSearch.aspx?asset=" + Request["assetTag"]);
                        break;                        
                    case "serial":
                        Response.Redirect("EqpSearch.aspx?serial=" + Request["serialNum"]);
                        break;
                    case "edit":
                        Response.Redirect("view.aspx?alias="
                            + "&site=" + Request.Form["editSite"] 
                            + "&inventory=" + Request.Form["editInventory"]);
                        break;
                    case "inventory":
                        string assets = Request.Form["Assets"];
                        submitAssets(assets);
                        Response.Redirect("view.aspx?alias=" + Alias.Text 
                            + "&site=" + Request.Form["site"] 
                            + "&inventory=" + Request.Form["Inventory"]);
                        break;
                }
            }
        }  
  
        private string removeDomain(string str)
        {
            string[] arr = str.Split(new Char[]{'\\'});

            if(arr.Length > 1)
                return arr[1];

            return "";
        }
             

        /// <summary>
        /// Here we just go through the assets list and call p_Surveyed for each asset
        /// The list should look something like:
        /// E226143,1
        /// E226145,1
        /// E226149,1
        /// E140160,1
        /// </summary>
        /// <param name="assets"></param>
        private void submitAssets(string assets)
        {
            // parse the string
            string[] parts = assets.Split(new Char[] {',', '\n'});

            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();

            for(int i = 0; i < parts.Length; i+=2)
            {
                if(parts[i].Trim() == "")
                    continue;

                string cmdStr = "exec p_Surveyed " 
                    + "'" + parts[i].Trim() + "' "
                    + add(DateTime.Now.ToString()) 
                    + add(Alias.Text.Trim())
                    + add(Request.Form["Inventory"].Trim())
                    + add(Request.Form["Site"].Trim());

                SqlCommand  cmd = new SqlCommand (cmdStr, conn);

                cmd.CommandType = CommandType.Text;
                cmd.ExecuteNonQuery();           
            }

            conn.Close();            
        }

        /// <summary>
        /// Just a helper function.
        /// </summary>
        /// <param name="first"></param>
        /// <returns></returns>
        private string add(string first)
        {
            if(first != "")
                return ", '" + first + "' ";
            else
                return ", NULL ";
        }

        /// <summary>
        /// Binds the inventories to the HtmlSelect listbox.
        /// </summary>
        /// <param name="s"></param>
        private void bindInventory(HtmlSelect s)
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();
            string cmdStr = "select  " +
                "cast(DATEPART(mm, InvDate) as char(2)) + '-' + cast(DATEPART(dd, InvDate) as char(2)) + '-' + cast(DATEPART(yy, InvDate) as char(4)) as InvDate " +
                " , InventoryID from Inventories";

            SqlDataAdapter  cmd = new SqlDataAdapter(cmdStr, conn);
		    

            s.DataTextField = "InvDate";
            s.DataValueField = "InventoryID";
            DataSet ds = new DataSet();
            cmd.Fill(ds);
            s.DataSource = ds;
            s.DataBind();
            
            conn.Close();            
        }

        /// <summary>
        /// Binds the sites to the HtmlSelct list box.
        /// </summary>
        /// <param name="s"></param>
        private void bindSites(HtmlSelect s)
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();
            string cmdStr = "select * from Sites";

            SqlDataAdapter  cmd = new SqlDataAdapter(cmdStr, conn);
		    

            s.DataTextField = "ShortSiteName";
            s.DataValueField = "SiteID";
            DataSet ds = new DataSet();
            cmd.Fill(ds);
            s.DataSource = ds;
            s.DataBind();
            
            conn.Close();            
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\datawarehouse\CricketToDB\CricketToDB.cs ===
using System;
using System.Collections;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.Configuration;
using System.IO;
using System.Diagnostics;


namespace xonline.ops.tools.datawarehouse.crickettodb 
{
	/// <summary>
	/// Summary description for CricketToDB.
	/// </summary>
    class CricketToDB
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] args)
        {       
            string errorEmail = "a-tewfz@microsoft.com";     

            try
            {
                string server = args[0];
                string db = args[1];

                StringReader reader = getReader(args[2]);

                if(reader != null)
                {
                    string machine, obj;
                    machine = obj = "";

                    getMacObj(ref machine, ref obj, reader);

                    ArrayList dses = getDSids(server, db, machine, obj, getDSes(reader));

                    toDB(server, db, reader, dses, args[2]);
                }
            }
            catch(Exception e)
            {
                // get reference to the source of the exception chain
                Exception ex = e;

                string str = "\nDatawarehouse rrd perfData parser\n" + args[2] + 
                    "MESSAGE: " + ex.Message + "\n" +  
                    "\nSOURCE: " + ex.Source +"\n" + 
                    "\nSTACKTRACE: \n" + ex.StackTrace;

                //sendMail("ERROR in Datawarehouse rrd perfData parser", str, errorEmail, errorEmail);
                Console.WriteLine(str);
            
                EventLog.WriteEntry("Datawarehouse rrd perfData parser", str, EventLogEntryType.Error, 1);
            }

            return;
        }

        static void getMacObj(ref string  mac, ref string obj, StringReader r)
        {
            string line = r.ReadLine();

            string[] arr = line.Split(new char[]{';', '='});

            if(arr.Length >= 2 && arr[0].Trim() == "MachineName")
            {
                mac = arr[1].Trim();
            }

            if(arr.Length >= 4 && arr[2].Trim() == "ObjectName")
            {
                obj = arr[3].Trim();
            }
        }

        static string getDSes(StringReader r)
        {
            string dsLine = r.ReadLine();
            string[] arr = dsLine.Split(new char[]{'d'});
        
            string ret = "";
            bool bFirst = true;

            for(int i = 0; i < arr.Length; i++)
            {
                if(arr[i].IndexOf('s') != -1)
                {
                    if(bFirst)
                        ret += "d" + arr[i].Trim();
                    else
                        ret += ",d" + arr[i].Trim();

                    bFirst = false;
                }
            }

            return ret;
        }

        static StringReader getReader(string filePath)
        {
            try
            {
                StreamReader srReadLine = new StreamReader(
                    (System.IO.Stream)File.OpenRead(filePath),         
                    System.Text.Encoding.ASCII);

                return new StringReader(srReadLine.ReadToEnd());
            }
            catch(Exception e)
            {
                Console.Write(e);
            }

            return null;
        }

        static void toDB(string server, string db, StringReader r, ArrayList dsIDs, string file)
        {

            string filePath = file + ".bulk";

            // delete the file if it exists
            FileInfo logFile = new FileInfo(filePath);
            if (logFile.Exists)
            {
                File.Delete(filePath);
            }

            string bulk = enumRows(dsIDs, r);

            // do the write!
            FileStream f = File.OpenWrite(filePath);
            StreamWriter sf = new StreamWriter(f);
            sf.Write(bulk);
            sf.Flush();
            sf.Close();

            // TODO: remember to report ERRORS!!!!
            logFile = new FileInfo(filePath);                
            bulkInsert(server, db, logFile.FullName);

        }

        static void bulkInsert(string server, string db, string file)
        {
            SqlConnection conn = new SqlConnection("data source=" + server + "; Initial Catalog=" + db + "; Integrated Security=SSPI");

            conn.Open();
            string cmdStr = 
                "if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[tempData]') and OBJECTPROPERTY(id, N'IsUserTable') = 1) \n" +  
                "drop table [dbo].[tempData] \n" +
                "CREATE TABLE [dbo].[tempData] ( \n" +
                "	[CounterID] [int] NOT NULL , \n" +
                "	[SampleTime] [datetime] NOT NULL , \n" +
                "	[Value] [float] NOT NULL  \n" +
                ") \n" +
                " \n" +
                " \n" +
                "bulk insert tempData from '" + file + "'  \n" +
                "with (FIELDTERMINATOR = ',', ROWTERMINATOR = ';') \n" +
                " \n" +
                "insert into CounterData  \n" +
                "select * from tempData T  \n" +
                "where 0 =  (select count(*) from CounterData C where T.CounterID = C.CounterID and T.SampleTime = C.DateTime)";

        
            SqlCommand  cmd = new SqlCommand (cmdStr, conn);

            cmd.CommandType = CommandType.Text;
            cmd.ExecuteNonQuery();           

            conn.Close();  
            
        }


        static string enumRows(ArrayList dsIDs, StringReader reader)
        {
            string toEnd = reader.ReadToEnd();
            string[] lines = toEnd.Split(new Char[]{'\n'}); // <--- prone to error
            string retStr = "";

            bool before = false;

            for(int line = 0; line < lines.Length; line++)
            {
                // get the time
                string[] two = lines[line].Split(new char[]{':'});

                if(two.Length >= 2)
                {
                    string time = two[0].Trim();
                    DateTime beg = new DateTime(1970, 1, 1);
                    DateTime end = beg.Add(new TimeSpan(0, 0, Convert.ToInt32(time)));
                    time = end.ToString();
                    
                    string[] values = two[1].Trim().Split(new char[]{' '});
                    for(int v = 0; v < values.Length; v++)
                    {
                        string val = null;                        
                        try 
                        {
                            val = Convert.ToDouble(values[v].Trim()).ToString();
                        }
                        catch(Exception e){}   
                     
                        if(values[v].Trim() != "" && val != null)
                        {
                            if(before)
                                retStr += ";\n";
                        
                            retStr += dsIDs[v] + "," + time + "," + Convert.ToDouble(values[v].Trim());
                            before = true;
                        }
                    }
                }
            }
            return retStr;            
        }

        static ArrayList getDSids(string server, string db, string mac, string obj, string counters)
        {

            SqlConnection conn = new SqlConnection("data source=" + server + "; Initial Catalog=" + db + "; Integrated Security=SSPI");
            
            conn.Open();

            SqlCommand cmd = new SqlCommand("sp_getCricketCounterID", conn);
            cmd.CommandType = CommandType.StoredProcedure;

            cmd.Parameters.Add("@Machine", mac);
            cmd.Parameters.Add("@Obj", obj);
            cmd.Parameters.Add("@Counters", counters);

            SqlDataAdapter adap = new SqlDataAdapter(cmd);                    

            
            DataSet ds = new DataSet();
            adap.Fill(ds);
            //object[] obj = ds.Tables[0].Rows[0].ItemArray;

            ArrayList arr = new ArrayList();
            //            Object[] objs = ds.Tables[0].Rows[ds.Tables[0].Columns.IndexOf("CounterID")].ItemArray;
            foreach(DataRow d in ds.Tables[0].Rows)
            {
                arr.Add(d["CounterID"]);
            }
            
            conn.Close();

            return arr;
        }

//        static void sendMail(string title, string body, string to, string from)
//        {
//            MailMessage mail = new MailMessage();
//            mail.From = from;
//            mail.To = to;
//            mail.Subject = title;
//            mail.Body = body;
//            mail.BodyFormat = MailFormat.Text;
//            SmtpMail.SmtpServer = "smtphost";
//            SmtpMail.Send(mail);    
//        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\findevents\FindForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.IO;
using System.Diagnostics;

namespace xonline.ops.tools.findevents 
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class FindForm : System.Windows.Forms.Form
	{
		private ArrayList m_arrlinenums;
		private ArrayList m_arrcomments;
		private Hashtable m_htdefines;
		private Hashtable m_htdefusecount;
		private Process m_lastProcess;
		private StreamWriter m_strout;
		private System.Windows.Forms.Label labelRootDir;
		private System.Windows.Forms.TextBox textBoxLogFile;
		private System.Windows.Forms.GroupBox groupBoxExcluded;
		private System.Windows.Forms.Button buttonAdd;
		private System.Windows.Forms.Button buttonRemove;
		private System.Windows.Forms.Button buttonGo;
		private System.Windows.Forms.TextBox textBoxAdd;
		private System.Windows.Forms.Label labelLogFile;
		private System.Windows.Forms.TextBox textBoxRootDir;
		private System.Windows.Forms.ListBox listBoxExcluded;
		private System.Windows.Forms.CheckBox checkBoxLogFile;
		private System.Windows.Forms.Label labelHeaderFile;
		private System.Windows.Forms.TextBox textBoxHeader;
		private System.Windows.Forms.Button buttonHelp;
		private System.Windows.Forms.GroupBox groupBoxHeades;
		private System.Windows.Forms.Button buttonHeaderRemove;
		private System.Windows.Forms.Button buttonHeaderAdd;
		private System.Windows.Forms.TextBox textBoxHeaderAdd;
		private System.Windows.Forms.ListBox listBoxHeaders;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public FindForm()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();
	
			//fill in logfile path with defaults
			//==================================

			textBoxLogFile.Text = Environment.CurrentDirectory + "\\findevents.log";
			
			//fill in root directory with defaults
			//====================================

			string strDrive = Environment.GetEnvironmentVariable("_ntdrive");
			string strRoot = Environment.GetEnvironmentVariable("_ntroot");

			if (strDrive == null)
			{
				strDrive = "c:\\";
			}

			if (strRoot == null)
			{
				strRoot = "xonline";
			}

			textBoxRootDir.Text = strDrive + strRoot + "\\private\\";

			//fill in header file path
			//========================

			textBoxHeader.Text = textBoxRootDir.Text + "inc\\xeventids.h";
			textBoxHeader.Hide();
			labelHeaderFile.Hide();

			// fill in the header list
			listBoxHeaders.Items.Add(textBoxRootDir.Text + "inc\\xeventids.h");
			listBoxHeaders.Items.Add(textBoxRootDir.Text + "xcatref\\xcatrefmessages.mc");
			listBoxHeaders.Items.Add(textBoxRootDir.Text + "sg\\event\\sgevent.mc");
			listBoxHeaders.Items.Add(textBoxRootDir.Text + "KDCCore\\KDCCore\\ad-service\\kdcevent.mc");
			listBoxHeaders.Items.Add(textBoxRootDir.Text + "KDCCore\\KDCCore\\idl\\kdccoreevents.mc");
			listBoxHeaders.Items.Add(textBoxRootDir.Text + "common\\mc\\SPS25\\imperr\\bdkerror.mc");
			listBoxHeaders.Items.Add(strDrive + strRoot + "\\public\\wsdk\\inc\\oledberr.mc");

			//add a few folders to the excluded list
			//======================================

			listBoxExcluded.Items.Add("mgmt");
			listBoxExcluded.Items.Add("test");
			listBoxExcluded.Items.Add("tools");
			listBoxExcluded.Items.Add("deladmin");
			listBoxExcluded.Items.Add("genealogy");

			//create member objects
			//=====================

			m_arrlinenums = new ArrayList();
			m_arrcomments = new ArrayList();
			m_htdefines = new Hashtable();
			m_htdefusecount = new Hashtable();
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.textBoxRootDir = new System.Windows.Forms.TextBox();
			this.labelRootDir = new System.Windows.Forms.Label();
			this.buttonGo = new System.Windows.Forms.Button();
			this.labelLogFile = new System.Windows.Forms.Label();
			this.textBoxLogFile = new System.Windows.Forms.TextBox();
			this.groupBoxExcluded = new System.Windows.Forms.GroupBox();
			this.buttonRemove = new System.Windows.Forms.Button();
			this.buttonAdd = new System.Windows.Forms.Button();
			this.textBoxAdd = new System.Windows.Forms.TextBox();
			this.listBoxExcluded = new System.Windows.Forms.ListBox();
			this.checkBoxLogFile = new System.Windows.Forms.CheckBox();
			this.labelHeaderFile = new System.Windows.Forms.Label();
			this.textBoxHeader = new System.Windows.Forms.TextBox();
			this.buttonHelp = new System.Windows.Forms.Button();
			this.groupBoxHeades = new System.Windows.Forms.GroupBox();
			this.buttonHeaderRemove = new System.Windows.Forms.Button();
			this.buttonHeaderAdd = new System.Windows.Forms.Button();
			this.textBoxHeaderAdd = new System.Windows.Forms.TextBox();
			this.listBoxHeaders = new System.Windows.Forms.ListBox();
			this.groupBoxExcluded.SuspendLayout();
			this.groupBoxHeades.SuspendLayout();
			this.SuspendLayout();
			// 
			// textBoxRootDir
			// 
			this.textBoxRootDir.Location = new System.Drawing.Point(56, 16);
			this.textBoxRootDir.Name = "textBoxRootDir";
			this.textBoxRootDir.Size = new System.Drawing.Size(248, 20);
			this.textBoxRootDir.TabIndex = 0;
			this.textBoxRootDir.Text = "";
			// 
			// labelRootDir
			// 
			this.labelRootDir.Location = new System.Drawing.Point(8, 16);
			this.labelRootDir.Name = "labelRootDir";
			this.labelRootDir.Size = new System.Drawing.Size(48, 16);
			this.labelRootDir.TabIndex = 1;
			this.labelRootDir.Text = "RootDir";
			// 
			// buttonGo
			// 
			this.buttonGo.Location = new System.Drawing.Point(176, 112);
			this.buttonGo.Name = "buttonGo";
			this.buttonGo.Size = new System.Drawing.Size(56, 23);
			this.buttonGo.TabIndex = 2;
			this.buttonGo.Text = "Go!";
			this.buttonGo.Click += new System.EventHandler(this.buttonGo_Click);
			// 
			// labelLogFile
			// 
			this.labelLogFile.Location = new System.Drawing.Point(8, 80);
			this.labelLogFile.Name = "labelLogFile";
			this.labelLogFile.Size = new System.Drawing.Size(48, 23);
			this.labelLogFile.TabIndex = 3;
			this.labelLogFile.Text = "Log File";
			// 
			// textBoxLogFile
			// 
			this.textBoxLogFile.Location = new System.Drawing.Point(56, 80);
			this.textBoxLogFile.Name = "textBoxLogFile";
			this.textBoxLogFile.Size = new System.Drawing.Size(248, 20);
			this.textBoxLogFile.TabIndex = 4;
			this.textBoxLogFile.Text = "findevents.log";
			// 
			// groupBoxExcluded
			// 
			this.groupBoxExcluded.Controls.AddRange(new System.Windows.Forms.Control[] {
																						   this.buttonRemove,
																						   this.buttonAdd,
																						   this.textBoxAdd,
																						   this.listBoxExcluded});
			this.groupBoxExcluded.Location = new System.Drawing.Point(16, 144);
			this.groupBoxExcluded.Name = "groupBoxExcluded";
			this.groupBoxExcluded.Size = new System.Drawing.Size(288, 176);
			this.groupBoxExcluded.TabIndex = 6;
			this.groupBoxExcluded.TabStop = false;
			this.groupBoxExcluded.Text = "Excluded SubDirs";
			// 
			// buttonRemove
			// 
			this.buttonRemove.Location = new System.Drawing.Point(176, 128);
			this.buttonRemove.Name = "buttonRemove";
			this.buttonRemove.TabIndex = 2;
			this.buttonRemove.Text = "Remove =>";
			this.buttonRemove.Click += new System.EventHandler(this.buttonRemove_Click);
			// 
			// buttonAdd
			// 
			this.buttonAdd.Location = new System.Drawing.Point(176, 40);
			this.buttonAdd.Name = "buttonAdd";
			this.buttonAdd.TabIndex = 1;
			this.buttonAdd.Text = " <= Add";
			this.buttonAdd.Click += new System.EventHandler(this.buttonAdd_Click);
			// 
			// textBoxAdd
			// 
			this.textBoxAdd.Location = new System.Drawing.Point(168, 88);
			this.textBoxAdd.Name = "textBoxAdd";
			this.textBoxAdd.Size = new System.Drawing.Size(96, 20);
			this.textBoxAdd.TabIndex = 0;
			this.textBoxAdd.Text = "";
			// 
			// listBoxExcluded
			// 
			this.listBoxExcluded.Location = new System.Drawing.Point(16, 24);
			this.listBoxExcluded.Name = "listBoxExcluded";
			this.listBoxExcluded.Size = new System.Drawing.Size(136, 134);
			this.listBoxExcluded.TabIndex = 8;
			// 
			// checkBoxLogFile
			// 
			this.checkBoxLogFile.Checked = true;
			this.checkBoxLogFile.CheckState = System.Windows.Forms.CheckState.Checked;
			this.checkBoxLogFile.Location = new System.Drawing.Point(16, 112);
			this.checkBoxLogFile.Name = "checkBoxLogFile";
			this.checkBoxLogFile.Size = new System.Drawing.Size(160, 24);
			this.checkBoxLogFile.TabIndex = 7;
			this.checkBoxLogFile.Text = "Open log file when finished";
			// 
			// labelHeaderFile
			// 
			this.labelHeaderFile.Location = new System.Drawing.Point(8, 48);
			this.labelHeaderFile.Name = "labelHeaderFile";
			this.labelHeaderFile.Size = new System.Drawing.Size(48, 23);
			this.labelHeaderFile.TabIndex = 8;
			this.labelHeaderFile.Text = "Header";
			// 
			// textBoxHeader
			// 
			this.textBoxHeader.Location = new System.Drawing.Point(56, 48);
			this.textBoxHeader.Name = "textBoxHeader";
			this.textBoxHeader.Size = new System.Drawing.Size(248, 20);
			this.textBoxHeader.TabIndex = 9;
			this.textBoxHeader.Text = "";
			// 
			// buttonHelp
			// 
			this.buttonHelp.Location = new System.Drawing.Point(248, 112);
			this.buttonHelp.Name = "buttonHelp";
			this.buttonHelp.Size = new System.Drawing.Size(56, 23);
			this.buttonHelp.TabIndex = 10;
			this.buttonHelp.Text = "Help";
			this.buttonHelp.Click += new System.EventHandler(this.buttonHelp_Click);
			// 
			// groupBoxHeades
			// 
			this.groupBoxHeades.Controls.AddRange(new System.Windows.Forms.Control[] {
																						 this.buttonHeaderRemove,
																						 this.buttonHeaderAdd,
																						 this.textBoxHeaderAdd,
																						 this.listBoxHeaders});
			this.groupBoxHeades.Location = new System.Drawing.Point(16, 344);
			this.groupBoxHeades.Name = "groupBoxHeades";
			this.groupBoxHeades.Size = new System.Drawing.Size(288, 200);
			this.groupBoxHeades.TabIndex = 6;
			this.groupBoxHeades.TabStop = false;
			this.groupBoxHeades.Text = "Headers";
			// 
			// buttonHeaderRemove
			// 
			this.buttonHeaderRemove.Location = new System.Drawing.Point(176, 128);
			this.buttonHeaderRemove.Name = "buttonHeaderRemove";
			this.buttonHeaderRemove.TabIndex = 2;
			this.buttonHeaderRemove.Text = "Remove =>";
			this.buttonHeaderRemove.Click += new System.EventHandler(this.buttonHeaderRemove_Click);
			// 
			// buttonHeaderAdd
			// 
			this.buttonHeaderAdd.Location = new System.Drawing.Point(176, 40);
			this.buttonHeaderAdd.Name = "buttonHeaderAdd";
			this.buttonHeaderAdd.TabIndex = 1;
			this.buttonHeaderAdd.Text = " <= Add";
			this.buttonHeaderAdd.Click += new System.EventHandler(this.buttonHeaderAdd_Click);
			// 
			// textBoxHeaderAdd
			// 
			this.textBoxHeaderAdd.Location = new System.Drawing.Point(168, 88);
			this.textBoxHeaderAdd.Name = "textBoxHeaderAdd";
			this.textBoxHeaderAdd.Size = new System.Drawing.Size(96, 20);
			this.textBoxHeaderAdd.TabIndex = 0;
			this.textBoxHeaderAdd.Text = "";
			// 
			// listBoxHeaders
			// 
			this.listBoxHeaders.Location = new System.Drawing.Point(16, 24);
			this.listBoxHeaders.Name = "listBoxHeaders";
			this.listBoxHeaders.Size = new System.Drawing.Size(136, 134);
			this.listBoxHeaders.TabIndex = 8;
			// 
			// FindForm
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(312, 550);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.buttonHelp,
																		  this.textBoxHeader,
																		  this.labelHeaderFile,
																		  this.checkBoxLogFile,
																		  this.groupBoxExcluded,
																		  this.textBoxLogFile,
																		  this.labelLogFile,
																		  this.buttonGo,
																		  this.labelRootDir,
																		  this.textBoxRootDir,
																		  this.groupBoxHeades});
			this.MaximizeBox = false;
			this.Name = "FindForm";
			this.Text = "FindEvents";
			this.groupBoxExcluded.ResumeLayout(false);
			this.groupBoxHeades.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new FindForm());
		}

		private void buttonAdd_Click(object sender, System.EventArgs e)
		{	
			if (textBoxAdd.Text != "")
			{
				listBoxExcluded.Items.Add(textBoxAdd.Text);
			}
			textBoxAdd.Text = "";
		}

		private void buttonRemove_Click(object sender, System.EventArgs e)
		{
			if ( listBoxExcluded.Text != "")
			{
				textBoxAdd.Text = listBoxExcluded.Text;
				listBoxExcluded.Items.Remove(listBoxExcluded.Text);
			}
		}

		private void buttonGo_Click(object sender, System.EventArgs e)
		{
			try
			{
				m_strout = new StreamWriter( File.Open(textBoxLogFile.Text, FileMode.Create) );
			}

			catch (Exception)
			{
				MessageBox.Show("Error opening log file!", "FindEvents", MessageBoxButtons.OK);
				return;
			}
		
			try
			{
				Directory.GetFiles(textBoxRootDir.Text, "*.*");
			}

			catch (Exception)
			{
				MessageBox.Show("Error opening directory!", "FindEvents", MessageBoxButtons.OK);
				m_strout.Close();
				return;		
			}

			try
			{
				for( int i2 = 0; i2 < listBoxHeaders.Items.Count; i2++)
				{
					//form fully qualified directory path
					//===================================

					string str = listBoxHeaders.Items[i2].ToString();

					if( str.EndsWith(".h") )
					{
						StreamReader strin = new StreamReader( File.OpenRead( str ) );
						string strContents = strin.ReadToEnd();
						ReadHeader(strContents);
					}
					else if (str.EndsWith(".mc"))
					{
						StreamReader strin = new StreamReader( File.OpenRead( str) );
						ReadMC(strin);
					}
				}
			}

			catch (Exception e2)
			{
				e2.GetType();
				MessageBox.Show("Error opening header or .mc file!", "FindEvents", MessageBoxButtons.OK);
				m_strout.Close();	
				return;
			}

			textBoxRootDir.Enabled = false;
			textBoxLogFile.Enabled = false;
			buttonRemove.Enabled = false;
			buttonGo.Enabled = false;
			buttonAdd.Enabled = false;
			buttonHelp.Enabled = false;
			checkBoxLogFile.Enabled = false;
			buttonHeaderAdd.Enabled = false;
			buttonHeaderRemove.Enabled = false;

			SearchDirectories(textBoxRootDir.Text);

			ListMissingEvents();

			textBoxRootDir.Enabled = true;
			textBoxLogFile.Enabled = true;
			buttonRemove.Enabled = true;
			buttonGo.Enabled = true;
			buttonAdd.Enabled = true;
			buttonHelp.Enabled = true;
			checkBoxLogFile.Enabled = true;
			buttonHeaderAdd.Enabled = true;
			buttonHeaderRemove.Enabled = true;

			m_strout.Close();

			if (checkBoxLogFile.Checked)
			{
				if(m_lastProcess != null && !m_lastProcess.HasExited)
				{
					m_lastProcess.Kill();
				}

				m_lastProcess = Process.Start("notepad.exe", textBoxLogFile.Text);
				
				//TODO: how do I bring this window to the front?
			}
		}



		private void ReadHeader( string strContents )
		{
			int iBeginDefined=0, iEndDefined=0;
			int iBeginDefinition=0, iEndDefinition=0;
			int iBegin = 0;
			bool bFound;
			string strDefine = "#define";

			m_htdefines.Clear();
			m_htdefusecount.Clear();

			while(iBegin >= 0)
			{
				bFound = false;


				iBegin = strContents.IndexOf(strDefine,iBegin);
				if (iBegin >= 0)
				{
					int iHold = iBegin + strDefine.Length;
					
					//find the beginning of the defined
					//=================================

					while ( iHold != strContents.Length )
					{
						char ch = strContents[iHold];
						
						if ( ch != ' ')
						{
							iBeginDefined = iHold;
							bFound = true;
							break;
						}

						iHold++;
					}

					if (!bFound)
					{
						iBegin++;
						continue;
					}

					//TODO: make sure I'm not in commented out range


					//find the end of the defined
					//===========================
				
					bFound = false;
					iHold ++;
					while (strContents[iHold] != '\xd') 
					{
						if (strContents[iHold] == ' ')
						{
							iEndDefined = iHold;
							bFound = true;
							break;
						}
					
						iHold++;
					}

					if (!bFound)
					{
						iBegin++;
						continue;
					}

					//find begin of the definition
					//============================
					
					bFound = false;
					iHold ++;
					while (strContents[iHold] != '\xd') 
					{
						if (strContents[iHold] != ' ')
						{
							iBeginDefinition = iHold;
							bFound = true;
							break;
						}

						iHold++;
					}

					if (!bFound)
					{
						iBegin++;
						continue;
					}

					//find end of the definition
					//==========================

					while (strContents[iHold] != '\xd' & strContents[iHold] != ' ') 
					{
						iHold++;
					}

					iEndDefinition = iBegin = iHold;

					//add to the hash table
					//=====================

					string strDefined = strContents.Substring(iBeginDefined, iEndDefined - iBeginDefined);
					string strDefinition = strContents.Substring(iBeginDefinition, iEndDefinition - iBeginDefinition);
					
					m_htdefines[strDefined] = strDefinition;
					m_htdefusecount[strDefined] = 0;
					
				}

			}

		}
	

		private void ReadMC(StreamReader srContents)
		{
			string strMessageID = "MessageId";
			string strSymbolicName = "SymbolicName";
			string strLine;
			string strSymbolic = "";
			string strID = "";
			int nPosMessageID = -1;
			int nPosSymbolic = -1;
			int nPosEqual = -1;
			uint uFound = 0;

			strLine = srContents.ReadLine();

			while (strLine != null)
			{

				if ( strLine == "" || strLine[0].Equals('.') || strLine[0].Equals(';'))
				{
					nPosMessageID = -1;
					nPosSymbolic = -1;
					nPosEqual = -1;
					uFound = 0;
					strLine = srContents.ReadLine();
					continue;
				}

				// Find the MessageId key=value pair
				nPosMessageID = strLine.IndexOf(strMessageID);

				if (nPosMessageID > -1)
				{
					int nIndexNum = -1;
					int nEndIndexNum = -1;

					uFound |= 0x1;
					nPosEqual = strLine.IndexOf("=", nPosMessageID);

					if (nPosEqual > 0)
					{
						string strTest = "1234567890";
						char[] chTest = strTest.ToCharArray();

						nIndexNum = strLine.IndexOfAny(chTest, nPosEqual + 1);
					}

					strID = "undefined";

					if (nIndexNum > -1)
					{
						nEndIndexNum = strLine.IndexOf(' ', nIndexNum);
					}

					if (nEndIndexNum > -1 && nIndexNum > -1)
					{
						strID = strLine.Substring(nIndexNum, nEndIndexNum - nIndexNum);
					}
					else if (nIndexNum > -1)
					{
						strID = strLine.Substring(nIndexNum);
					}

				}

				// Find the SymbolicName key=value pair
				nPosSymbolic = strLine.IndexOf(strSymbolicName);

				if (nPosSymbolic > -1)
				{
					uFound |= 0x2;
					int nIndexSymbolic = -1;
					int nEndIndexSymbolic = -1;

					nPosEqual = strLine.IndexOf("=", nPosSymbolic);

					if (nPosEqual > -1)
					{
						int nTempIndex = -1;
						nTempIndex = strLine.IndexOf('(', nPosEqual + 1);

						string strTest = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
						char[] chTest = strTest.ToCharArray();

						nIndexSymbolic = strLine.IndexOfAny(chTest, nPosEqual + 1);
						
						if (nTempIndex > -1 && nIndexSymbolic > -1 && nTempIndex < nIndexSymbolic)
						{
							uFound -= 0x2;
							strLine = srContents.ReadLine();
							continue;
						}
					}

					if (nIndexSymbolic > -1)
					{
						nEndIndexSymbolic = strLine.IndexOf(' ', nIndexSymbolic);
					}

					if (nEndIndexSymbolic > -1 && nIndexSymbolic > -1)
					{
						strSymbolic = strLine.Substring(nIndexSymbolic, nEndIndexSymbolic - nIndexSymbolic);
					}
					else if (nIndexSymbolic > -1)
					{
						strSymbolic = strLine.Substring(nIndexSymbolic);
					}
				}

				if (uFound > 1)
				{
					// Reset our position markers
					nPosMessageID = -1;
					nPosSymbolic = -1;
					nPosEqual = -1;
					uFound = 0;

					m_htdefines[strSymbolic] = strID;
					m_htdefusecount[strSymbolic] = 0;

					// Sometimes we are missing events because when the code was written
					// a substring of the original event identifier was used. This code 
					// attempt to remedy some of these problems. If the way that the events
					// are used changes then this portion of the algorithm will need
					// to change.
					string strSub;
					int nSubIndex = -1;

					nSubIndex = strSymbolic.IndexOf('_');
					strSub = strSymbolic.Substring(nSubIndex);

					if (nSubIndex > 1)
					{
						m_htdefines[strSub] = strID;
						m_htdefines[strSub] = 0;
					}
				}
				strLine = srContents.ReadLine();
			}
				
		}

		private void SearchDirectories(string strDir)
		{
			SearchFiles(strDir);

			string []strSubDirs = Directory.GetDirectories(strDir);

			for(int i=0; i<strSubDirs.Length; i++)
			{
				bool bExcluded = false;

				for( int i2=0; i2 < listBoxExcluded.Items.Count; i2++)
				{
					//form fully qualified directory path
					//===================================

					string str = textBoxRootDir.Text;
					if( !str.EndsWith("\\") )
					{
						str += "\\";
					}
					str += listBoxExcluded.Items[i2].ToString();

					//compare for exclusion
					//=====================

					if (String.Compare(str, strSubDirs[i], true) == 0)
					{
						bExcluded = true;
					}
				}
				
				if (!bExcluded)
				{
					SearchDirectories(strSubDirs[i]);
				}
			}
		}



		private void SearchFiles(string strDir)
		{

			//search c++ files
			//================

			string []strFiles = Directory.GetFiles(strDir, "*.cpp"); 
			string []strCallsCpp = {Xom.NtEvent", "ReportEvent", "SgEvent", "SgEventSz",
									"SgEventSz1", "SgEventSz2", "SgEventSz3", "SgEventSz4",
									"SgEventSz5", "SgEventSz6", "SgEventSz7", "SgEventSz8",
									"SgEventSz9", "SgEventData", "SgEventData", "SgEventDataSz", 
									"SgEventDataSz1",  "SgEventDataSz2",  "SgEventDataSz3", 
									"SgEventDataSz4",  "SgEventDataSz5",  "SgEventDataSz6", 
									"SgEventDataSz7",  "SgEventDataSz8",  "SgEventDataSz9", 
									"SgLogEvent", "report" };

			for(int i=0; strFiles != null && i<strFiles.Length; i++)
			{
				SearchFile(strDir, strFiles[i], strCallsCpp);
			}

			string []strFiles2 = Directory.GetFiles(strDir, "*.h"); 

			for(int i=0; strFiles2 != null && i<strFiles2.Length; i++)
			{
				SearchFile(strDir, strFiles2[i], strCallsCpp);
			}

			//search cs files
			//===============

			string []strCallsCs = {Xom.NtEvent", "EventLog.WriteEntry" };
			string []strFiles3 = Directory.GetFiles(strDir, "*.cs"); 

			for(int i=0; strFiles3 != null && i<strFiles3.Length; i++)
			{
				SearchFile(strDir, strFiles3[i], strCallsCs);
			}


		}

		private void ListMissingEvents()
		{
			m_strout.WriteLine("");
			m_strout.WriteLine("");
			m_strout.WriteLine("Events not found in the source code:");
			m_strout.WriteLine("====================================");
			m_strout.WriteLine("");
			m_strout.WriteLine("");

			string []arr = new string[m_htdefusecount.Keys.Count]; 
 
			m_htdefusecount.Keys.CopyTo(arr, 0);

			for(int i=0; i<m_htdefusecount.Keys.Count; i++)
			{

				if ( (int)m_htdefusecount[ arr[i] ] == 0)
				{
					m_strout.WriteLine(arr[i]);
				}
			}
		}

		private void SearchFile(string strDir, string strFile, string []strCalls)
		{
			string strContents;
				
			try
			{
				StreamReader strin = new StreamReader( File.OpenRead(strFile) );
				strContents = strin.ReadToEnd();
			}

			catch(Exception)
			{
				m_strout.WriteLine("");
				m_strout.WriteLine("");
				string strError = "ERROR Opening: ";
				m_strout.WriteLine(strError + strFile);
				m_strout.WriteLine("");
				m_strout.WriteLine("");

				return;
			}

			m_arrlinenums.Clear(); //clear the line numbers from the previous file
			m_arrcomments.Clear(); //clear the comments from the previous file

			ArrayList arrlines = new ArrayList();

			//get all the calls
			//=================

			for(int i=0; i<strCalls.Length; i++)
			{
				FindLogs( strContents, strCalls[i], arrlines);
			}

			//write them to file
			//==================

			if (arrlines.Count > 0)
			{
				m_strout.WriteLine("");
				m_strout.WriteLine("");
				m_strout.WriteLine(strFile);
				m_strout.WriteLine("");
				m_strout.WriteLine("");
					
				for(int i2=0; i2 < arrlines.Count; i2++)
				{
					m_strout.WriteLine(arrlines[i2]);
					m_strout.WriteLine("");
				}
			}

		}


		private void FindLogs(string strContents, string strCall, ArrayList arrlines)
		{
			int iBegin = 0;

			bool bFound;
			string strDefine = "";

			//TODO: comments inside parenthesis can confuse me

			while(iBegin >= 0)
			{
				bFound = false;
				iBegin = strContents.IndexOf(strCall,iBegin);
				if (iBegin >= 0)
				{
					int iHold = iBegin + strCall.Length;
					
					//find the open parenthesis
					//=========================

					while ( iHold != strContents.Length )
					{
						char ch = strContents[iHold];
						
						if (ch == '(')
						{
							bFound = true;
							break;
						}

						if ( ch != ' ' && ( ch < '0' || ch > '9' ) )  
						{
							break;
						}

						iHold++;
					}

					if (!bFound)
					{
						iBegin++;
						continue;
					}

					//make sure I'm not in commented out range
					//========================================

					if (IsInsideComment(strContents, iBegin))
					{
						iBegin++;
						continue;
					}

					//find the close parenthesis
					//==========================

					iHold ++;
					bool bInString = false;
					bool bFoundFirstParam = false;
					int iFirstParam = 0;
					int iParenCount = 1;

					while (iHold != strContents.Length)
					{
						if (strContents[iHold] == '"')
						{
							bInString = !bInString;
						}
						else if (!bInString)
						{
							//find the beginning and end of the first param
							//=============================================

							//TODO: comments before,after first param can confuse me
							if (!bFoundFirstParam)
							{
								if ( iFirstParam == 0 && strContents[iHold] != ' ' && strContents[iHold] != '\xd' 
											&& strContents[iHold] != '\xa')
								{
									iFirstParam = iHold;
								}
								else if (iFirstParam != 0 && ( strContents[iHold] == ' ' | strContents[iHold] == ',' ) )
								{
									bFoundFirstParam = true;
									strDefine = strContents.Substring(iFirstParam, iHold-iFirstParam);									
								}
							}
					
							//look for close paren
							//====================

							 if (strContents[iHold] == '(')
							 {
								iParenCount++;
							 }
							 else if (strContents[iHold] == ')')
							 {
								 if ( 0 == --iParenCount )
								 {
									 break;
								 }
							 }
						}
					
						iHold++;
					}

					//found close parenthesis, add to array to be printed out
					//=======================================================

					if ( 0 == iParenCount)
					{
						string str = "Line ";
						str += FindLineNumber(strContents,iBegin);
						str +=":  ";

						if (m_htdefines.Contains(strDefine))
						{
							string strHex = ((string)m_htdefines[strDefine]).TrimEnd('L','l');

							str += "Hex EventID " + "(" + strHex + "), Decimal EventID (";
							
							//wrap this in try/catch because there were some typos in the header file(id numbers exceeded 32 bits)

							try
							{
								int nConvert = System.Convert.ToInt32(strHex, 16);
								str += nConvert;
								str += "), ";
							}

							catch
							{
							}
							
							m_htdefusecount[strDefine] = (int)m_htdefusecount[strDefine] +1;
						}

						str += strContents.Substring(iBegin,iHold-iBegin+1);
						arrlines.Add( str );
					}

					iBegin = iHold;
					
				}

			}
		}


		bool IsInsideComment(string strContents, int iWhere)
		{
			//cache comment, lines info the first time
			//========================================

			bool bInComment = false;
			bool bInLineComment = false;
			int iStart = 0;

			if (0 == m_arrlinenums.Count)
			{
				for ( int i=0; i < strContents.Length; i++)
				{
					if (bInComment)
					{
						if (strContents[i] == '/' && strContents[i-1] == '*' )
						{
							bInComment = false;
							m_arrcomments.Add(iStart);
							m_arrcomments.Add(i);
						}
					}
					else if (!bInLineComment)
					{
						if (strContents[i] == '*' && i != 0 && strContents[i-1] == '/' )
						{
							iStart = i;
							bInComment = true;
						}
						else if (strContents[i] == '/' && i != 0 && strContents[i-1] == '/' )
						{
							iStart = i;
							bInLineComment = true;
						}
					}
						 
					if (strContents[i] == 0xa)
					{
						m_arrlinenums.Add(i);
						
						if (bInLineComment)
						{
							bInLineComment = false;
							m_arrcomments.Add(iStart);
							m_arrcomments.Add(i);
						}
					}
				}
			}

			//adds the last line here
			m_arrlinenums.Add(strContents.Length); 

			//see if comment is inside the line
			//=================================

			for(int i=0 ; i < m_arrcomments.Count; i += 2 )
			{
				if ((int)m_arrcomments[i] > iWhere)
				{
					return false;
				}

				if ((int)m_arrcomments[i] < iWhere && iWhere < (int)m_arrcomments[i+1])
				{
					return true;
				}
			}

			return false;
		}


		int FindLineNumber(string strContents, int iWhere)
		{
			//find the line
			//=============

			for( int i=0; i < m_arrlinenums.Count; i++)
			{
				if ((int)m_arrlinenums[i] > iWhere)
				{
					return i+1;
				}
			}

			return 0; //should never reach here
		}

		private void buttonHelp_Click(object sender, System.EventArgs e)
		{
			string strHelpMsg = "   There is one proper way to raise NT events within the\n" +
								"xonline server source: callinXom.NtEvent with events ids\n" +
								"defined in the master events header file.\n\n" +
								"   FindEvents cross-references the master events header\n" +
						        "file with the actual use of the events within the xonline\n" +
						        "server code and generates a report.\n\n" +
								"   RootDir is the root of the xonline server code source.\n\n" +
								"   Header is where the master events header file lives.\n\n" +
								"   Excluded subdirectories are relative directories off of\n" +
								"the RootDir that will not be searched for event logs.\n\n" +
								"   Note: Although ReportEvent should not be called directly in\n" +
								"the server source, it is included as part of the report so we\n" +
								"can harass the dev team if they step out of line.";

			MessageBox.Show( strHelpMsg, "FindEvents" );
		}

		private void buttonHeaderAdd_Click(object sender, System.EventArgs e)
		{
			if (textBoxHeaderAdd.Text != "")
			{
				listBoxHeaders.Items.Add(textBoxHeaderAdd.Text);
			}
			textBoxHeaderAdd.Text = "";
		
		}

		private void buttonHeaderRemove_Click(object sender, System.EventArgs e)
		{
			if ( listBoxHeaders.Text != "")
			{
				textBoxHeaderAdd.Text = listBoxHeaders.Text;
				listBoxHeaders.Items.Remove(listBoxHeaders.Text);
			}
		
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\inventory\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace xonline.ops.tools.inventory  
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogAgreggator\ErrorRec.cs ===
using System;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.logagreggator 
{
    public class ErrorRec
    {
        int Batch ; 
        DateTime Timestamp ; 
        public string Message ;


        public ErrorRec ( int _Batch, string _Message )
        {
            Batch  = _Batch ; 
            Timestamp = DateTime.Now ; 
            Message = _Message ; 

            // Trim message to 255 chars 
            if ( Message.Length > 255 ) 
                Message = Message.Substring ( 0 , 255 ) ; 
        }


        public string ToSql ( ) 
        { 
            return 
                "INSERT INTO twAggErrors " + 
                " ( dtTimestamp , iBatchID, vcMessage, iCommentID ) " +
                " VALUES ( " + 
                Helper.ToSQL ( Timestamp ) + " , " + 
                Batch.ToString ( ) + " , " + 
                Helper.ToSQL ( Message ) + " , " + 
                "0 ) " ;  
        } 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogAgreggator\AggregatorDoc.cs ===
using System;
using System.IO;
using System.Collections;
using xonline.ops.tools.livereports.logparser.logparserlib;

namespace xonline.ops.tools.livereports.logparser.logagreggator 
{
	/// <summary>
	/// Summary description for AggregatorDoc.
	/// </summary>
	public class AggregatorDoc
	{
        DatabaseLoader m_loader = new DatabaseLoader();
        AggBatchRec m_Batch = new AggBatchRec();

		public AggregatorDoc()
		{
		}


        public bool Aggregate( string strServer, 
                               string strDatabase, 
                               string strUser,
                               string strPassword,
                               DateTime dtTime,
                               bool bDaily,
							   int nTimeout,
							   int nBackoff)
        {
            if ( bDaily )
            {
                Helper.LogMessage ( Helper.MsgType.Info, "Performing daily aggregation for day: " + dtTime ) ; 
            }
            else
            {
                Helper.LogMessage ( Helper.MsgType.Info, "Performing hourly aggregation for hour: " + dtTime ) ; 
            }

            //connect to the db first thing
            Helper.LogMessage ( Helper.MsgType.Info, "Connecting to Database..." ) ; 
            if ( ! m_loader.Connect ( strServer , strDatabase , strUser , strPassword ) ) 
            { 
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** Failed to connect to database." ) ; 
                //can't log to database here (obviously)

                return false; 
            } 

            //check the schema and create a batch record
            try
            {
				// Set the timeout and backoff timer values.
				Helper.LogMessage ( Helper.MsgType.Info, "Connected. Set the timeout and backoff timer values..." ) ; 
				
				if (60 <= nTimeout)
				{
					m_loader.TimeoutValue = nTimeout;
				}
				else
				{
					Helper.LogMessage ( Helper.MsgType.Info, "/TIMEOUT parameter less than sixty seconds. Defaulting timeout value to 300 seconds" ) ; 
				}

				if (60 <= nBackoff)
				{
					m_loader.BackoffValue = nBackoff;
				}
				else
				{
					Helper.LogMessage ( Helper.MsgType.Info, "/BACKOFF parameter less than sixty seconds. Defaulting back off value to 120 seconds" ) ; 
				}

                //check for the new database schema
                Helper.LogMessage ( Helper.MsgType.Info, "Connected. Checking database schema..." ) ; 

                if ( false == m_loader.DetectV4Schema() )
                {
                    // Cant log anything in this old database
                    Helper.LogMessage ( Helper.MsgType.Abort,  "** ERROR ** Obsolete database schema detected. Aborted." ) ; 
                    return false; 
                }

                // Generate the new batch record and get the Id number                
                Helper.LogMessage ( Helper.MsgType.Info, "Creating a new batch record..." ) ; 
                m_loader.Execute ( m_Batch.ToSqlInsertAgg ( dtTime, (bDaily) ? 'D' : 'H' ) ) ; 

                m_Batch.BatchId = m_loader.Scalar ( m_Batch.ToSqlSelect ( ) ) ;
                Helper.LogMessage ( Helper.MsgType.Info, "New Aggregation batch started with ID #" + m_Batch.Id.ToString ( ) ) ;
            }

            catch ( Exception e ) 
            {
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** Aborted! Exception thrown while checking schema/creating batch record: " + e.Message ) ; 
                return false;
            }

            //do data validation checks
            bool b = DoPreAggValidation( dtTime, bDaily );

            if ( false == b )
            {
                m_Batch.Update ( BatchRec.Phases.Aborted ) ; 
                m_loader.Execute ( m_Batch.ToSqlUpdate ( ) ) ; 
                return false;
            }

            
            //do the aggregation
            if ( bDaily ) 
            {
                return AggregateDay ( dtTime );
            }
            else
            {
                return AggregateHours ( dtTime );
            }
   
        } 


        private bool DoPreAggValidation( DateTime dtTime, bool bDaily )
        {
            //validation checks
            try
            {
                //different validation checks depending on whether this is hourly or daily
                if ( bDaily )
                {
                    //make sure there aren't any records for the day specified
                    if ( true == Reader.DetectExistingDailyError( m_loader, dtTime ) )
                    {
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, "** ERROR ** Aggregation records already exist for the specified day (" + dtTime + ") Aborted." );
                        Helper.LogMessage ( Helper.MsgType.Abort, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 

                        return false; 
                    }

                    //make sure there is at least one hourly record for every hour of the aggregation interval
                    if ( true == Reader.DetectMissingHourlyError( m_loader, dtTime ) )
                    {
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, "** ERROR ** Hourly records for all 24 hours are required to perform daily aggregation for " + dtTime +
                            ". One or more records for one or more hours was not found! Aborted!" );
                        Helper.LogMessage ( Helper.MsgType.Abort, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 

                        return false;
                    }
                    
                }
                else
                {
                    //make sure there aren't any records for the hour specified
                    if ( true == Reader.DetectExistingError( m_loader, dtTime ) )
                    {
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, "** ERROR ** Aggregation records already exist for the specified hour ( " + dtTime + " )  Aborted." );
                        Helper.LogMessage ( Helper.MsgType.Abort, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 

                        return false; 
                    }

                    //make sure there are presence records for the hour to be aggregated
                    if ( true == Reader.DetectMissingError( m_loader, dtTime, 1 ) ) 
                    {
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, "** ERROR ** No presence records found for the hour to be aggregated ( " + dtTime + " ) Aborted."  );
                        Helper.LogMessage ( Helper.MsgType.Abort, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 

                        return false;                     
                    }

                }
            }

            catch( Exception e )
            {
                ErrorRec Error = new ErrorRec( m_Batch.BatchId,  "** ERROR ** Aborted! Exception thrown during pre-aggregation validation checks." + e.Message );
                Helper.LogMessage ( Helper.MsgType.Abort, Error.Message  ) ;
                m_loader.Execute ( Error.ToSql ( ) ) ; 

                return false;
            }

            return true;
        }



        private bool AggregateHours( DateTime dtHour)
        {

            try
            {
                Hashtable htHourlyStats = new Hashtable();

                // load user session into memory
                Helper.LogMessage ( Helper.MsgType.Info, "Loading User Session Records in memory..." ) ; 
                ArrayList alUserSessions = Reader.GetUserSessions ( m_loader, dtHour ) ;  
            
                // load user games into memory
                Helper.LogMessage ( Helper.MsgType.Info, "Loading User Game Records in memory..." ) ; 
                ArrayList alUserGames = Reader.GetUserGames ( m_loader, dtHour ) ; 
    
                // load user session remnants
                Helper.LogMessage ( Helper.MsgType.Info, "Loading User Session Remnant Records in memory..." ) ; 
                Hashtable htUserSessRemnants = Reader.GetUserSessionsRemnants ( m_loader, dtHour, 1 ) ;
            
                // load user games remnants
                Helper.LogMessage ( Helper.MsgType.Info, "Loading User Game Remnant Records in memory..." ) ; 
                ArrayList alUserGameRemnants = Reader.GetUserGameRemnants ( m_loader, dtHour, 1 ) ;         

                m_Batch.Update ( AggBatchRec.Phases.Parsing ) ; 
                m_loader.Execute ( m_Batch.ToSqlUpdate() );

                //associate session remnant data with game remnant records and add game remnants to main game list
                Helper.LogMessage ( Helper.MsgType.Info, "Processing Game Remnant Records..." ) ;                
        
                foreach ( UserGame usergame in alUserGameRemnants )
                {
                    UserSession session = (UserSession)htUserSessRemnants [ usergame.m_lUserID ];

                    if ( null == session || session.m_dtSessStarted > usergame.m_dtGameStarted )
                    {
                        //no sess remnant found for a game remnant, throw error
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, "** ERROR ** Session remnant not found for game remnant with UserID: " + usergame.m_lUserID );
                        Helper.LogMessage ( Helper.MsgType.Err, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 
                    }
                    else
                    {
                        usergame.m_iCountry = session.m_iCountry;
                        usergame.m_iTitleID = session.m_iTitleID;

                        alUserGames.Add( usergame );
                    }
                }
                alUserGameRemnants.Clear();

                //add session remnants to main session lists
                ArrayList alUserSessRemnants = new ArrayList ( htUserSessRemnants );
               
                foreach ( DictionaryEntry de in alUserSessRemnants )
                {
                    alUserSessions.Add ( de.Value );
                }
                htUserSessRemnants.Clear();
                alUserSessRemnants.Clear();

                //aggregate all the game session information
                Helper.LogMessage ( Helper.MsgType.Info, "Aggregating " + alUserGames.Count +  " game records..." ) ; 
            
                foreach( UserGame usergame in alUserGames )
                {
                    //add game information to the hourly stats by individual country and title
                    HourlyStats hourly = (HourlyStats)htHourlyStats[ usergame.Hash() ];
                
                    if ( null == hourly )
                    {
                        hourly = new HourlyStats( m_Batch.BatchId,
                                                  usergame.m_iTitleID, 
                                                  usergame.m_iCountry, 
                                                  dtHour );
                 
                        hourly.Aggregate( usergame );

                        htHourlyStats.Add( usergame.Hash() , hourly );
                    }
                    else
                    {
                        hourly.Aggregate( usergame );
                    }

                    //add game information to the hourly stats summary for all countries
                    hourly = (HourlyStats)htHourlyStats[ usergame.HashAllCountries() ];
               
                    if ( null == hourly )
                    {                    
                        hourly = new HourlyStats( m_Batch.BatchId,
                                                  usergame.m_iTitleID, 
                                                  0, 
                                                  dtHour );
                    
                        hourly.Aggregate( usergame );

                        htHourlyStats.Add( usergame.HashAllCountries() , hourly );
                    }
                    else
                    {
                        hourly.Aggregate( usergame );
                    }

                    //add game information to the hourly stats for all titles
                    hourly = (HourlyStats)htHourlyStats[ usergame.HashAllTitles() ];
               
                    if ( null == hourly )
                    {                    
                        hourly = new HourlyStats( m_Batch.BatchId,
                                                  0, 
                                                  usergame.m_iCountry, 
                                                  dtHour );

                        hourly.Aggregate( usergame );

                        htHourlyStats.Add( usergame.HashAllTitles() , hourly );
                    }
                    else
                    {
                        hourly.Aggregate( usergame );
                    }

                    //add game information to the hourly stats total all countries and titles
                    hourly = (HourlyStats)htHourlyStats[ usergame.HashAll() ];
               
                    if ( null == hourly )
                    {                    
                        hourly = new HourlyStats( m_Batch.BatchId,
                                                  0, 
                                                  0, 
                                                  dtHour );
                    
                        hourly.Aggregate( usergame );

                        htHourlyStats.Add( usergame.HashAll() , hourly );
                    }
                    else
                    {
                        hourly.Aggregate( usergame );
                    }

                }
            

                //aggregate all the session info                 
                Helper.LogMessage ( Helper.MsgType.Info, "Aggregating " + alUserSessions.Count +  " session records..." ) ; 

                foreach ( UserSession session in alUserSessions )
                {

                    //add session info to the hourly stats by individual country and title
                    HourlyStats hourly = (HourlyStats)htHourlyStats[ session.Hash() ];
                
                    if ( null == hourly )
                    {
                        hourly = new HourlyStats( m_Batch.BatchId,
                                                  session.m_iTitleID, 
                                                  session.m_iCountry, 
                                                  dtHour );
                 
                        hourly.Aggregate( session );

                        htHourlyStats.Add( session.Hash() , hourly );
                    }
                    else
                    {
                        hourly.Aggregate( session );
                    }       

                    //add session info to the hourly stats summary for all countries
                    hourly = (HourlyStats)htHourlyStats[ session.HashAllCountries() ];
               
                    if ( null == hourly )
                    {                    
                        hourly = new HourlyStats( m_Batch.BatchId,
                                                  session.m_iTitleID, 
                                                  0, 
                                                  dtHour );
                    
                        hourly.Aggregate( session );

                        htHourlyStats.Add( session.HashAllCountries() , hourly );
                    }
                    else
                    {
                        hourly.Aggregate( session );
                    }

                    //add session info to the hourly stats for all titles
                    hourly = (HourlyStats)htHourlyStats[ session.HashAllTitles() ];
               
                    if ( null == hourly )
                    {                    
                        hourly = new HourlyStats( m_Batch.BatchId,
                                                  0, 
                                                  session.m_iCountry, 
                                                  dtHour );

                        hourly.Aggregate( session );

                        htHourlyStats.Add( session.HashAllTitles(), hourly );
                    }
                    else
                    {
                        hourly.Aggregate( session );
                    }

                    //add session info to the hourly stats total all countries and titles
                    hourly = (HourlyStats)htHourlyStats[ session.HashAll() ];
               
                    if ( null == hourly )
                    {                    
                        hourly = new HourlyStats( m_Batch.BatchId,
                                                  0, 
                                                  0, 
                                                  dtHour );
                    
                        hourly.Aggregate( session );

                        htHourlyStats.Add( session.HashAll() , hourly );
                    }
                    else
                    {
                        hourly.Aggregate( session );
                    }

                }

				// Check to see if we can find entries for each of the known TitleID CountryID pairs for this hour
				ArrayList alHourlyMatrix = Reader.GetTitleIDCountryIDMatrix(m_loader, m_Batch.BatchId, dtHour);

				foreach ( HourlyStats stats in alHourlyMatrix)
				{
					// Check for HourlyStats info in the hourly stats hash table by individual country and title
					HourlyStats hourly = (HourlyStats)htHourlyStats[ stats.Hash() ];
                
					if ( null == hourly )
					{

						Helper.LogMessage ( Helper.MsgType.Warn, "Inserting missing hourly stats by individual country and title for period:" + dtHour ) ; 
						htHourlyStats.Add( stats.Hash() , stats);
					}

					// Check for HourlyStats info in the hourly stats hash table by all countries
					hourly = (HourlyStats)htHourlyStats[ stats.HashAllCountries() ];
               
					if ( null == hourly )
					{                    

						Helper.LogMessage ( Helper.MsgType.Warn, "Inserting missing hourly stats by all countries for period:" + dtHour ) ; 
						htHourlyStats.Add( stats.HashAllCountries() , stats);
					}

					//Check for HourlyStats info in the hourly stats hash table by all titles
					hourly = (HourlyStats)htHourlyStats[ stats.HashAllTitles() ];
               
					if ( null == hourly )
					{                    
						Helper.LogMessage ( Helper.MsgType.Warn, "Inserting missing hourly stats by all titles for period:" + dtHour ) ; 
						htHourlyStats.Add( stats.HashAllTitles(), stats);
					}

					//Check for HourlyStats info in the hourly stats hash table by all countries and titles
					hourly = (HourlyStats)htHourlyStats[ stats.HashAll() ];
               
					if ( null == hourly )
					{                    
						Helper.LogMessage ( Helper.MsgType.Warn, "Inserting missing hourly stats by all countries and titles for period:" + dtHour ) ; 
						htHourlyStats.Add( stats.HashAll() , stats);
					}
				}

                //insert rows
                m_Batch.Update ( BatchRec.Phases.Inserting ) ;
                m_loader.Execute ( m_Batch.ToSqlUpdate() );
                
                ArrayList alHourlyStats = new ArrayList( htHourlyStats );
                Helper.LogMessage ( Helper.MsgType.Info, "Inserting " + alHourlyStats.Count +" HourlyStats records..." ) ; 

                foreach ( DictionaryEntry de in alHourlyStats )
                {
                    HourlyStats hourly = (HourlyStats) de.Value;

                    m_loader.Execute( hourly.ToSQL() );
                }

                //all done
                m_Batch.Update ( BatchRec.Phases.Completed ) ; 
                m_loader.Execute ( m_Batch.ToSqlUpdate() );
                
                Helper.LogMessage( Helper.MsgType.Summary, "");
                Helper.LogMessage ( Helper.MsgType.Info, "Hourly Aggregation complete. Process stopped." ) ; 
            }

            catch ( Exception e )
            {
                ErrorRec Error = new ErrorRec( m_Batch.BatchId, "** ERROR ** Hourly aggregation aborted! Exception thrown: " + e.Message );
                Helper.LogMessage ( Helper.MsgType.Abort, Error.Message  ) ;
                m_loader.Execute ( Error.ToSql ( ) ) ; 

                m_Batch.Update ( BatchRec.Phases.Aborted ) ; 
                m_loader.Execute ( m_Batch.ToSqlUpdate ( ) ) ; 

                return false;
            }

            return true;

        }



        //daily aggregations 
        private bool AggregateDay( DateTime dtDay )
        {
            try
            {
                Hashtable htDailyStats = new Hashtable();

                //get the daily records for the 24 hour period
                Helper.LogMessage ( Helper.MsgType.Info, "Loading Hourly Stats Records in memory..." ) ; 
                ArrayList alHourlyStats = Reader.GetHourlyStats ( m_loader, dtDay ) ;  
            
                //get the user session records (for unique user and session counts)
                Helper.LogMessage ( Helper.MsgType.Info, "Loading Session Records in memory..." ) ; 
                ArrayList alSessions = Reader.GetSessionsForDaily ( m_loader, dtDay ) ;  

                //get the user game records ( for unique game counts )
                Helper.LogMessage ( Helper.MsgType.Info, "Loading Game Records in memory..." ) ; 
                ArrayList alGames = Reader.GetUserGamesForDaily ( m_loader, dtDay ) ;  

                //get session remnants
                Helper.LogMessage ( Helper.MsgType.Info, "Loading Session Remnant Records in memory..." ) ; 
                Hashtable htUserSessRemnants = Reader.GetUserSessionsRemnants ( m_loader, dtDay, 24 ) ;  

                //get game remnants
                Helper.LogMessage ( Helper.MsgType.Info, "Loading Game Remnant Records in memory..." ) ; 
                ArrayList alGameRemnants = Reader.GetUserGameRemnants ( m_loader, dtDay, 24 ) ; 

                //associate session remnant data with game remnant records and add game remnants to main game list
                Helper.LogMessage ( Helper.MsgType.Info, "Processing Game Remnant Records..." ) ;                
        
                foreach ( UserGame usergame in alGameRemnants )
                {
                    UserSession session = (UserSession)htUserSessRemnants [ usergame.m_lUserID ];

                    if ( null == session || session.m_dtSessStarted > usergame.m_dtGameStarted )
                    {
                        //no sess remnant found for a game remnant, throw error
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, "**ERROR** Session remnant not found for game remnant. UserID: " + usergame.m_lUserID );
                        Helper.LogMessage ( Helper.MsgType.Err, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 
                    }
                    else
                    {
                        usergame.m_iCountry = session.m_iCountry;
                        usergame.m_iTitleID = session.m_iTitleID;

                        alGames.Add( usergame );
                    }
                }
                alGameRemnants.Clear();


                //add session remnants to main session lists
                ArrayList alUserSessRemnants = new ArrayList ( htUserSessRemnants );
               
                foreach ( DictionaryEntry de in alUserSessRemnants )
                {
                    alSessions.Add ( de.Value );
                }
                htUserSessRemnants.Clear();
                alUserSessRemnants.Clear();


                //aggregate for game time, online time, max/min concurrent users
                foreach ( HourlyStats hourly in alHourlyStats )
                {
                    DailyStats daily =(DailyStats)htDailyStats[ hourly.Hash() ];

                    if ( null == daily )
                    {
                        daily = new DailyStats ( m_Batch.BatchId,
                                                 hourly.m_iTitleID, 
                                                 hourly.m_iCountry,
                                                 dtDay ); 

                        daily.Aggregate ( hourly );

                        htDailyStats.Add( hourly.Hash(), daily );
                    }
                    else
                    {
                        daily.Aggregate ( hourly );
                    }
                }

                //aggregate for unique users and sessions
                foreach ( UserSession session in alSessions )
                {
                    //add unique user info to the daily stats by individual country and title
                    DailyStats daily =(DailyStats)htDailyStats[ session.Hash() ];

                    if ( null == daily )
                    {
                        //this should never happen
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, 
                                "** ERROR ** Missing HourlyStats record discovered while aggregating sessions for DailyStats! Hash: " + session.Hash() );
                        Helper.LogMessage ( Helper.MsgType.Err, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 
                    }
                    else
                    {
                        daily.Aggregate ( session );
                    }

                    //add unique user info to the daily stats summary for all countries
                    daily =(DailyStats)htDailyStats[ session.HashAllCountries() ];
               
                    if ( null == daily )
                    {                    
                        //this should never happen
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, 
                            "** ERROR ** Missing HourlyStats record discovered while aggregating sessions for DailyStats! Hash: " + session.HashAllCountries() );
                        Helper.LogMessage ( Helper.MsgType.Err, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 
                    }
                    else
                    {
                        daily.Aggregate( session );
                    }

                    //add unique user info to the daily stats for all titles
                    daily =(DailyStats)htDailyStats[ session.HashAllTitles() ];
               
                    if ( null == daily )
                    {                    
                        //this should never happen
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, 
                            "** ERROR ** Missing HourlyStats record discovered while aggregating sessions for DailyStats! Hash: " + session.HashAllTitles() );
                        Helper.LogMessage ( Helper.MsgType.Err, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 
                    }
                    else
                    {
                        daily.Aggregate( session );
                    }

                    //add unique user info to the daily stats total all countries and titles
                    daily =(DailyStats)htDailyStats[ session.HashAll() ];
               
                    if ( null == daily )
                    {                    
                        //this should never happen
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, 
                            "** ERROR ** Missing HourlyStats record discovered while aggregating sessions for DailyStats! Hash: " + session.HashAll() );
                        Helper.LogMessage ( Helper.MsgType.Err, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 
                    }
                    else
                    {
                        daily.Aggregate( session );
                    }
                }

                //aggregate for unique games
                foreach ( UserGame game in alGames )
                {
                    //add unique user info to the daily stats by individual country and title
                    DailyStats daily =(DailyStats)htDailyStats[ game.Hash() ];

                    if ( null == daily )
                    {
                        //this should never happen
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, 
                            "** ERROR ** Missing HourlyStats record discovered while aggregating games for DailyStats! Hash: " + game.Hash() );
                        Helper.LogMessage ( Helper.MsgType.Err, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 
                    }
                    else
                    {
                        daily.Aggregate ( game );
                    }

                    //add unique user info to the daily stats summary for all countries
                    daily =(DailyStats)htDailyStats[ game.HashAllCountries() ];
               
                    if ( null == daily )
                    {                    
                        //this should never happen
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, 
                            "** ERROR ** Missing HourlyStats record discovered while aggregating games for DailyStats! Hash: " + game.HashAllCountries() );
                        Helper.LogMessage ( Helper.MsgType.Err, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 
                    }
                    else
                    {
                        daily.Aggregate( game );
                    }

                    //add unique user info to the daily stats for all titles
                    daily =(DailyStats)htDailyStats[ game.HashAllTitles() ];
               
                    if ( null == daily )
                    {                    
                        //this should never happen
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, 
                            "** ERROR ** Missing HourlyStats record discovered while aggregating games for DailyStats! Hash: " + game.HashAllTitles() );
                        Helper.LogMessage ( Helper.MsgType.Err, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 
                    }
                    else
                    {
                        daily.Aggregate( game );
                    }

                    //add unique user info to the daily stats total all countries and titles
                    daily =(DailyStats)htDailyStats[ game.HashAll() ];
               
                    if ( null == daily )
                    {                    
                        //this should never happen
                        ErrorRec Error = new ErrorRec( m_Batch.BatchId, 
                            "** ERROR ** Missing HourlyStats record discovered while aggregating games for DailyStats! Hash: " + game.HashAll() );
                        Helper.LogMessage ( Helper.MsgType.Err, Error.Message  ) ;
                        m_loader.Execute ( Error.ToSql ( ) ) ; 
                    }
                    else
                    {
                        daily.Aggregate( game );
                    }
                }


                //do insertion
                m_Batch.Update ( BatchRec.Phases.Inserting ) ; 
                m_loader.Execute ( m_Batch.ToSqlUpdate() );

                ArrayList alDailyStats = new ArrayList( htDailyStats );
                Helper.LogMessage ( Helper.MsgType.Info, "Inserting " + alDailyStats.Count +" DailyStats records..." ) ; 

                foreach ( DictionaryEntry de in alDailyStats )
                {
                    DailyStats daily = (DailyStats) de.Value;

                    m_loader.Execute( daily.ToSQL() );
                }

                //all done
                m_Batch.Update ( BatchRec.Phases.Completed ) ; 
                m_loader.Execute ( m_Batch.ToSqlUpdate() );
                
                Helper.LogMessage( Helper.MsgType.Summary, "");
                Helper.LogMessage ( Helper.MsgType.Info, "Daily Aggregation complete. Process stopped." ) ; 

            }

                
            catch ( Exception e )
            {
                ErrorRec Error = new ErrorRec( m_Batch.BatchId, "** ERROR ** Daily aggregation aborted! Exception thrown: " + e.Message );
                Helper.LogMessage ( Helper.MsgType.Abort, Error.Message  ) ;
                m_loader.Execute ( Error.ToSql ( ) ) ; 

                m_Batch.Update ( BatchRec.Phases.Aborted ) ; 
                m_loader.Execute ( m_Batch.ToSqlUpdate ( ) ) ; 

                return false;
            }

            return true;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogAgreggator\Aggregator.cs ===
using System;
using System.IO ;
using System.Globalization;
using xonline.ops.tools.livereports.logparser.logparserlib;


namespace xonline.ops.tools.livereports.logparser.logagreggator 
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class Aggregator
	{
		private AggregatorDoc doc = new AggregatorDoc ( ) ;

        [STAThread]
        static void Main ( string [] args )
        {
            Aggregator TheApp = new Aggregator () ; 

            TheApp.Start( args );
        }

        string m_strLogPath = @"..\AggLogs\" ;
        string m_strServer = null; 
        string m_strDatabase = null; 
        string m_strUser = ""; 
        string m_strPassword = ""; 
        DateTime m_dtHour;
        bool m_bDaily = false;
		int m_nTimeout = -1;
		int m_nBackoff = -1;


        public int Start ( string[] args ) 
        { 
            Helper.strCaller = "LogAggregator";
            Helper.LogPath = m_strLogPath;

            bool bRet = LoadAppSettings ( args );
 
            if (bRet)
            {            
                Helper.LogPath = m_strLogPath;
                Helper.LogMessage ( Helper.MsgType.Info, "Log Aggregator - Version 4.0 - Started." ) ;


                bRet = doc.Aggregate ( m_strServer , 
                                       m_strDatabase , 
                                       m_strUser , 
                                       m_strPassword , 
                                       m_dtHour, 
                                       m_bDaily,
									   m_nTimeout,
									   m_nBackoff);

            } 

            return (bRet == true) ? 0 : -1;
        } 

        public bool LoadAppSettings ( string []args ) 
        { 
            string strDay = null;
            string strHour = null;

            for (int i = 0; i < args.Length; i++)
            {
                if ( args[i].ToUpper().StartsWith( "/HOURLY" ) )
                {
                    m_bDaily = false;
                }
                else if ( args[i].ToUpper().StartsWith( "/DAILY" ) )
                {
                    m_bDaily = true;
                }
                else if ( args[i].ToUpper().StartsWith( "/SERVER=" ) )
                {
                    m_strServer = args[i].Substring( "/SERVER=".Length ).ToLower();
                }
                else if ( args[i].ToUpper().StartsWith("/DATABASE="))
                {
                    m_strDatabase = args[i].Substring( "/DATABASE=".Length).ToLower();
                }
                else if ( args[i].ToUpper().StartsWith( "/USER=" ) )
                {
                    m_strUser = args[i].Substring( "/USER=".Length );
                }
                else if ( args[i].ToUpper().StartsWith("/PASSWORD="))
                {
                    m_strPassword = args[i].Substring( "/PASSWORD=".Length );
                }
                else if ( args[i].ToUpper().StartsWith("/LOGPATH="))
                {
                    m_strLogPath = args[i].Substring( "/LOGPATH=".Length ).ToLower();
                }
				else if ( args[i].ToUpper().StartsWith("/TIMEOUT="))
				{
					m_nTimeout = System.Convert.ToInt32(args[i].Substring( "/TIMEOUT=".Length )); 
				}                  
				else if ( args[i].ToUpper().StartsWith("/BACKOFF="))
				{
					m_nBackoff = System.Convert.ToInt32(args[i].Substring( "/BACKOFF=".Length )); 
				}                  
				else if ( args[i].ToUpper().StartsWith("/HOUR="))
                {
                    strHour = args[i].Substring( "/HOUR=".Length ); 
                }
                else if ( args[i].ToUpper().StartsWith("/DAY="))
                {
                    strDay = args[i].Substring( "/DAY=".Length ); 
                }                  
				else
                {
                    Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Unrecognized command-line parameter (" + args[i] + ") Aborted." ) ;
                    PrintUsage();
                    return false;
                }
            }

            //check for incomplete or invalid parameters
            if ( null == m_strServer )
            {
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Server must be specified on the command-line. Aborted." ) ;                
                PrintUsage();
                return false;
            }

            if ( null == m_strDatabase )
            {
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Database must be specified on the command-line. Aborted." ) ;
                PrintUsage();
                return false;
            }

            if ( m_bDaily )
            {
                if ( null == strDay )
                {
                    Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Day must be specified on the command-line for a daily aggregation. Aborted." ) ;
                    PrintUsage();
                    return false;
                }

                strHour = "00:00";
            }
            else
            {
                if ( null == strDay || null == strHour )
                {
                    Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Both Hour and Day must be specified on the command-line for an hourly aggregation. Aborted." ) ;
                    PrintUsage();
                    return false;
                }
            }

            //form the starting datetime and make sure it is on an hour boundary 
            DateTimeFormatInfo dtfi  = new DateTimeFormatInfo();
            dtfi.FullDateTimePattern = "MM/dd/yyyy HH:mm";

            try
            {
                m_dtHour = Convert.ToDateTime( strDay + " " + strHour, dtfi );
            }

            catch (Exception e)
            {
				string strMessage = e.Message;
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Hour and/or Day parameter formatted incorrectly. Aborted." ) ;
                PrintUsage();
                return false;             
            }

            //make sure the hour parameter passed in is on an hour boundary
            if ( m_dtHour.Second !=0 || m_dtHour.Minute !=0 || m_dtHour.Millisecond !=0 )
            {
                Helper.LogMessage ( Helper.MsgType.Abort, "** ERROR ** - Aggregation hour must be specified on an hour boundary. Aborted." ) ;
                PrintUsage();
                return false;
            }

            return true;
        }

        void PrintUsage()
        {
            Helper.LogMessage ( Helper.MsgType.Info, "" );
            Helper.LogMessage ( Helper.MsgType.Info, "Usage: logaggregator [ /SERVER=<servername> ] [ /DATABASE=<database> ] [ /HOUR=<HH:00> ] [ /DAY=<MM/DD/YY> ] " );
            Helper.LogMessage ( Helper.MsgType.Info, "                     [ /LOGPATH=<logpath> ] [ /USER=<username> ] [ /PASSWORD=<password> ] [/INTERVAL=<hours> ]" );
            Helper.LogMessage ( Helper.MsgType.Info, "                     [ /TIMEOUT=<seconds> ] [ /BACKOFF=<seconds> ] [ /HOURLY ] [ /DAILY ] " );
            Helper.LogMessage ( Helper.MsgType.Info, "" );
            Helper.LogMessage ( Helper.MsgType.Info, "Example: logaggregator /SERVER=infrdmg /DATABASE=lr /LOGPATH=e:\\applogs /HOUR=16:00 /DAY=11/21/99 /TIMEOUT=300 /BACKOFF=120" ); 
            Helper.LogMessage ( Helper.MsgType.Info, "Aggregation default to hourly, unless /DAILY is specified." ); 
            Helper.LogMessage ( Helper.MsgType.Info, "Note: Aggregation interval defaults to 12 hours. Do not change the default unless you are certain of what you are doing. " ); 

        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\inventory\EqpSearch.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;
using System.Configuration;

namespace xonline.ops.tools.inventory 
{
	/// <summary>
	/// Summary description for EqpSearch.
	/// </summary>
	public class EqpSearch : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.DataGrid SearchResults;
        protected System.Web.UI.HtmlControls.HtmlGenericControl searchFor;
    
        private int _total = 0;
    
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
            if(Request["asset"] != null )
            {
                bindByAsset(Request["asset"]);
                searchFor.InnerText = "Asset = " + Request["asset"];
            }
            else if(Request["name"] != null)
            {
                bindByName(Request["name"]);
                searchFor.InnerText = "Name = " + Request["name"];
            }
            else
            {
                bindBySerial(Request["serial"]);
                searchFor.InnerText = "Serial = " + Request["serial"];
            }
		}

        private void bindByName(string name)
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();

            // get all the pieces of equipment for this inventory and this site:
            string cmdStr = "select " +
                " distinct(RTRIM(A.AssetTag)) as AssetTag, Edited, SerialNumber, ShortSiteName, A.SiteID as site, Name, " + 
                " cast(DATEPART(mm, PurchaseDate) as char(2)) + '-' + cast(DATEPART(dd, PurchaseDate) as char(2)) + '-' + cast(DATEPART(yy, PurchaseDate) as char(4)) as PurchaseDate, " + 
                " PurchasePrice, InUse, ReplValue, " +
                " B.Model as ModelName, B.Manufacturer as Manufacturer, A.IsStorage, ShelfBegin, ShelfEnd, LocName  " +
                " from  " +
                " Equipment A join " +
                " Models B on A.uModelID = B.uModelID join " +
                " Sites C on C.SiteID = A.SiteID  join " +
                " Locations D on D.LocationID = A.LocationID join " +  
                " (select Name as LocName, AssetTag from Equipment) E on E.AssetTag = D.AssetTag join " +                                  
                " Surveyed F on F.AssetTag = A.AssetTag " +
                " where  " +
                " A.Name like '" + name + "'" +                
                " order by Name";

            SqlDataAdapter  cmd = new SqlDataAdapter (cmdStr, conn);
		    

            DataSet ds = new DataSet();
            cmd.Fill(ds);
		    
            SearchResults.DataSource = ds;

            SearchResults.DataBind();

            conn.Close();
        }

        private void bindByAsset(string asset)
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();

            // get all the pieces of equipment for this inventory and this site:
            string cmdStr = "select " +
                " distinct(RTRIM(A.AssetTag)) as AssetTag, Edited, SerialNumber, ShortSiteName, A.SiteID as site, Name, " + 
                " cast(DATEPART(mm, PurchaseDate) as char(2)) + '-' + cast(DATEPART(dd, PurchaseDate) as char(2)) + '-' + cast(DATEPART(yy, PurchaseDate) as char(4)) as PurchaseDate, " + 
                " PurchasePrice, InUse, ReplValue, " +
                " B.Model as ModelName, B.Manufacturer as Manufacturer, A.IsStorage, ShelfBegin, ShelfEnd, LocName  " +
                " from  " +
                " Equipment A join " +
                " Models B on A.uModelID = B.uModelID join " +
                " Sites C on C.SiteID = A.SiteID  join " +
                " Locations D on D.LocationID = A.LocationID join " +  
                " (select Name as LocName, AssetTag from Equipment) E on E.AssetTag = D.AssetTag join " +                                  
                " Surveyed F on F.AssetTag = A.AssetTag " +
                " where  " +
                " A.AssetTag like '" + asset + "'" +                
                " order by Name";

            SqlDataAdapter  cmd = new SqlDataAdapter (cmdStr, conn);
		    

            DataSet ds = new DataSet();
            cmd.Fill(ds);
		    
            SearchResults.DataSource = ds;

            SearchResults.DataBind();

            conn.Close();
        }

        
        private void bindBySerial(string serial)
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();

            // get all the pieces of equipment for this inventory and this site:
            string cmdStr = "select " +
                " distinct(RTRIM(A.AssetTag)) as AssetTag, Edited, SerialNumber, ShortSiteName, A.SiteID as site, Name, " + 
                " cast(DATEPART(mm, PurchaseDate) as char(2)) + '-' + cast(DATEPART(dd, PurchaseDate) as char(2)) + '-' + cast(DATEPART(yy, PurchaseDate) as char(4)) as PurchaseDate, " + 
                " PurchasePrice, InUse, ReplValue, " +
                " B.Model as ModelName, B.Manufacturer as Manufacturer, A.IsStorage, ShelfBegin, ShelfEnd, LocName  " +
                " from  " +
                " Equipment A join " +
                " Models B on A.uModelID = B.uModelID join " +
                " Sites C on C.SiteID = A.SiteID  join " +
                " Locations D on D.LocationID = A.LocationID join " +  
                " (select Name as LocName, AssetTag from Equipment) E on E.AssetTag = D.AssetTag join " +                                  
                " Surveyed F on F.AssetTag = A.AssetTag " +
                " where  " +
                " A.SerialNumber like '" + serial + "'" +                
                " order by Name";

            SqlDataAdapter  cmd = new SqlDataAdapter (cmdStr, conn);
		    

            DataSet ds = new DataSet();
            cmd.Fill(ds);
		    
            SearchResults.DataSource = ds;

            SearchResults.DataBind();

            conn.Close();
        }

        public void dgSearchResults_ItemDataBound(object sender, DataGridItemEventArgs e)
        {
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                _total++;
            } 

            if(e.Item.ItemType == ListItemType.Footer)
            {
                e.Item.Attributes.Add("align","Right");
                e.Item.CssClass = "CartListFooter";
                e.Item.Cells[0].Text="Number of Items: ";
                e.Item.Cells[1].Text = string.Format("{0:n0}", _total);
            }
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\inventory\view.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;
using System.Configuration;

namespace xonline.ops.tools.inventory 
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public class View : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.DataGrid dg1;
        protected System.Web.UI.HtmlControls.HtmlInputHidden hSite;
        protected System.Web.UI.HtmlControls.HtmlInputHidden hAlias;
        protected System.Web.UI.HtmlControls.HtmlInputHidden hInventory;

        private int _total = 0;
    
		private void Page_Load(object sender, System.EventArgs e)
		{
            hSite.Value = "'" + Request["site"] + "'";
            hInventory.Value = "'" + Request["inventory"] + "'";
            hAlias.Value= "'" + Request["alias"] + "'";

		    SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

		    conn.Open();

            // get all the pieces of equipment for this inventory and this site:
            string cmdStr = "select " +
                                                        " distinct(RTRIM(A.AssetTag)) as AssetTag, Edited, SerialNumber, ShortSiteName, Name, " + 
                                                        " cast(DATEPART(mm, PurchaseDate) as char(2)) + '-' + cast(DATEPART(dd, PurchaseDate) as char(2)) + '-' + cast(DATEPART(yy, PurchaseDate) as char(4)) as PurchaseDate, " + 
                                                        " PurchasePrice, InUse, ReplValue, " +
                                                        " B.Model as ModelName, B.Manufacturer as Manufacturer, A.IsStorage, ShelfBegin, ShelfEnd, LocName, cast(ShelfBegin as int) as O  " +
                                                        " from  " +
                                                        " Equipment A join " +
                                                        " Models B on A.uModelID = B.uModelID join " +
                                                        " Sites C on C.SiteID = A.SiteID  join " +
                                                        " Locations D on D.LocationID = A.LocationID join " +  
                                                        " (select Name as LocName, AssetTag from Equipment) E on E.AssetTag = D.AssetTag join " +                                  
                                                        " Surveyed F on F.AssetTag = A.AssetTag " +
                                                        " where  " +
                                                        " A.SiteID=" + hSite.Value +
                                                        " and F.InventoryID = " + hInventory.Value +
                                                        " order by LocName, O desc, Name";

		    SqlDataAdapter  cmd = new SqlDataAdapter (cmdStr, conn);
		    

		    DataSet ds = new DataSet();
		    cmd.Fill(ds);
		    
		    dg1.DataSource = ds;

		    dg1.DataBind();

		    conn.Close();
		}


        // this should be taken out after the first inventory
        // this is to help make sure that every piece of Equipment is edited, hence that it is checked and verified.
        public void dgVIEW_ItemDataBound(object sender, DataGridItemEventArgs e)
        {
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                if(e.Item.Cells[0].Text.Trim() == "False")
                {
                    e.Item.Cells[0].Text = "<label " + 
                            "title='Needs to be edited' style='FONT-WEIGHT: bold; COLOR: red; FONT-STYLE: normal; FONT-VARIANT: small-caps; TEXT-DECORATION: underline'>" +
                            "False</label>" ;

                    _total++;
                }                               
            } 

            if(e.Item.ItemType == ListItemType.Footer)
            {
                e.Item.Attributes.Add("align","Right");
                e.Item.CssClass = "CartListFooter";
                e.Item.Cells[0].Text="Number of Items: ";
                e.Item.Cells[1].Text = string.Format("{0:n0}", _total);
            }
        }      

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\inventory\Report.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;
using System.Configuration;

namespace xonline.ops.tools.inventory 
{
	/// <summary>
	/// Summary description for Report.
	/// </summary>
	public class Report : System.Web.UI.Page
	{
        protected System.Web.UI.WebControls.DataGrid NotCounted;
        protected System.Web.UI.WebControls.DataGrid newEqp;
        protected System.Web.UI.WebControls.DataGrid CountedFor;

        private int _totalNotCounted = 0;
        private int _totalnewEqp = 0;
        private int _totalCountedFor = 0;
    
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Just runs the p_Check* sprocs for the two inventories and sites
            bindNotCounted();
            bindCountedFor();
            bindNewEqp();
		}

        public void dgNotCounted_ItemDataBound(object sender, DataGridItemEventArgs e)
        {
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                _totalNotCounted++;
            } 

            if(e.Item.ItemType == ListItemType.Footer)
            {
                e.Item.Attributes.Add("align","Right");
                e.Item.CssClass = "CartListFooter";
                e.Item.Cells[0].Text="Number of Items: ";
                e.Item.Cells[1].Text = string.Format("{0:n0}", _totalNotCounted);
            }
        } 

        public void dgnewEqp_ItemDataBound(object sender, DataGridItemEventArgs e)
        {
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                _totalnewEqp++;
            } 

            if(e.Item.ItemType == ListItemType.Footer)
            {
                e.Item.Attributes.Add("align","Right");
                e.Item.CssClass = "CartListFooter";
                e.Item.Cells[0].Text="Number of Items: ";
                e.Item.Cells[1].Text = string.Format("{0:n0}", _totalnewEqp);
            }
        }

        public void dgCountedFor_ItemDataBound(object sender, DataGridItemEventArgs e)
        {
            if (e.Item.ItemType == ListItemType.Item || e.Item.ItemType == ListItemType.AlternatingItem)
            {
                _totalCountedFor++;
            } 

            if(e.Item.ItemType == ListItemType.Footer)
            {
                e.Item.Attributes.Add("align","Right");
                e.Item.CssClass = "CartListFooter";
                e.Item.Cells[0].Text="Number of Items: ";
                e.Item.Cells[1].Text = string.Format("{0:n0}", _totalCountedFor);
            }
        }

        private void bindNotCounted()
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();



            string cmdStr = "exec p_CheckNotAccounted " 
                + "'" + Request["Inventory2"] + "', "
                + "'" + Request["Inventory1"] + "' "
                + add(Request["Site"].Trim());
 
            SqlDataAdapter  cmd = new SqlDataAdapter (cmdStr, conn);	

            DataSet ds = new DataSet();
            cmd.Fill(ds);
		
            NotCounted.DataSource = ds;

            NotCounted.DataBind();

            conn.Close();  
        }

        private string add(string first)
        {
            if(first != "")
                return ", '" + first + "' ";
            else
                return ", NULL ";
        }

        private void bindCountedFor()
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();



            string cmdStr = "exec p_CheckAccountedFor " 
                + "'" + Request["Inventory2"] + "', "
                + "'" + Request["Inventory1"] + "' "
                + add(Request["Site"].Trim());

            SqlDataAdapter  cmd = new SqlDataAdapter (cmdStr, conn);	

            DataSet ds = new DataSet();
            cmd.Fill(ds);
		
            CountedFor.DataSource = ds;

            CountedFor.DataBind();

            conn.Close(); 
        }
        private void bindNewEqp()
        {
            SqlConnection conn = new SqlConnection(ConfigurationSettings.AppSettings["DB"]);

            conn.Open();



            string cmdStr = "exec p_CheckNew " 
                + "'" + Request["Inventory2"] + "', "
                + "'" + Request["Inventory1"] + "' "
                + add(Request["Site"].Trim());

            SqlDataAdapter  cmd = new SqlDataAdapter (cmdStr, conn);	

            DataSet ds = new DataSet();
            cmd.Fill(ds);
		
            newEqp.DataSource = ds;

            newEqp.DataBind();

            conn.Close(); 
        }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
            this.Load += new System.EventHandler(this.Page_Load);

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogAgreggator\Reader.cs ===
using System;
using System.Collections;
using System.Data.SqlClient ;
using xonline.ops.tools.livereports.logparser.logparserlib; 
using xonline.ops.tools.livereports.logparser.logagreggator;

namespace xonline.ops.tools.livereports.logparser.logagreggator 
{

    public class Reader
    {
        public Reader()
        {
        }
	
        static public bool DetectExistingError ( DatabaseLoader dbloader, DateTime dtHour )
        {
            return ( 0 <
                dbloader.Scalar( "Select count(*) from tcHourlyStats where iHourID = " + Helper.ToHourID(dtHour) ) );
        }

        static public bool DetectMissingError( DatabaseLoader dbloader, DateTime dtHour, uint uiHours )
        {
 
            string Sql = "SELECT 1 WHERE EXISTS ( SELECT * FROM tfUserSessions WHERE dtEnded >= " + Helper.ToSQL(dtHour) +
                " AND dtEnded < " + Helper.ToSQL(dtHour.AddHours(uiHours)) + ")";


            ArrayList al = new ArrayList();
            return ( 0 >= dbloader.Scalar( Sql ) );

        }

		static public ArrayList GetTitleIDCountryIDMatrix(DatabaseLoader dbloader, int nBatchID, DateTime dtHour)
		{
			ArrayList alTitleIDCountryID = new ArrayList();

			string Sql = "select iTitleID, iCountryID FROM tcHourlyStats where iTitleID > 10000 and iCountryID > 0 " + 
					"group by iTitleID, iCountryID order by iTitleID";

			SqlDataReader reader = dbloader.Reader( Sql ); 

			while( reader.Read( ) )
			{   
				int iTitle = ( int ) reader [ "iTitleID" ];
				int iCountry = ( int ) reader [ "iCountryID" ] ; 

				HourlyStats hsHour = new HourlyStats( (int)nBatchID, iTitle, iCountry, dtHour);

				alTitleIDCountryID.Add(hsHour);
                       
			}

			if ( null != reader )
			{
				reader.Close();
			}

			return alTitleIDCountryID;
		}

        static public ArrayList GetUserSessions( DatabaseLoader dbloader, DateTime dtStart )
        {
            ArrayList alUserSessions = new ArrayList();

            string Sql = "SELECT biUserID, iDNCountryID, iTitleID, dtStarted, dtEnded FROM tfUserSessions WHERE " +
                         "iOnlineTime > 0 AND " +
                         "( ( dtStarted <= " + Helper.ToSQL(dtStart) + " AND dtEnded >= " + Helper.ToSQL(dtStart) + " ) " +
                         "OR" +
                         "( dtStarted > " + Helper.ToSQL(dtStart) + " AND dtStarted < " + Helper.ToSQL(dtStart.AddHours(1)) +  
                         ") ) ";

            SqlDataReader reader = dbloader.Reader( Sql ); 

            while( reader.Read( ) )
            {   
                long lUserID = ( long ) reader [ "biUserID" ];
                int iCountry = ( int ) reader [ "iDNCountryID" ] ; 
                int iTitle = ( int ) reader [ "iTitleID" ];

                DateTime dtSessStart = ( DateTime ) reader [ "dtStarted" ] ; 
                DateTime dtSessEnd = ( DateTime ) reader [ "dtEnded" ] ; 

                UserSession session = new UserSession( lUserID,
                                                       iTitle, 
                                                       iCountry, 
                                                       dtSessStart, 
                                                       dtSessEnd );

                alUserSessions.Add( session );
                       
            }

            if ( null != reader )
            {
                reader.Close();
            }

            return alUserSessions;

        }


        static public ArrayList GetUserGames( DatabaseLoader dbloader, DateTime dtStart )
        {

            ArrayList alUserGames = new ArrayList();


            string Sql = "SELECT iDNCountryID, iDNTitleID, dtStarted, dtEnded FROM tfUserGames WHERE " +
                         "( ( dtStarted <= " + Helper.ToSQL(dtStart) + " AND dtEnded >= " + Helper.ToSQL(dtStart) + " ) " +
                         "OR" +
                         "( dtStarted > " + Helper.ToSQL(dtStart) + " AND dtStarted < " + Helper.ToSQL(dtStart.AddHours(1)) + 
                         ") ) ";

            SqlDataReader reader = dbloader.Reader( Sql ); 

            while( reader.Read( ) )
            {   
                int iCountry = ( int ) reader [ "iDNCountryID" ] ; 
                int iTitle = ( int ) reader [ "iDNTitleID" ];

                DateTime dtGameStart = ( DateTime ) reader [ "dtStarted" ] ; 
                DateTime dtGameEnd = ( DateTime ) reader [ "dtEnded" ] ; 

                UserGame usergame = new UserGame( iTitle, 
                                                  iCountry, 
                                                  dtGameStart, 
                                                  dtGameEnd );

                alUserGames.Add( usergame );
                       
            }

            if ( null != reader )
            {
                reader.Close();
            }

            return alUserGames;
        }


        static public Hashtable GetUserSessionsRemnants( DatabaseLoader dbloader, DateTime dtStart, uint uiInterval )
        {
            Hashtable htUserRemnantSessions = new Hashtable();

            string Sql = "SELECT biUserID, iCountryID, iTitleID, dtCreated FROM twSessRemnants " +
                         "WHERE bProcessed = 0 AND dtCreated < " + Helper.ToSQL(dtStart.AddHours(uiInterval)) +
                         " ORDER BY dtCreated";

            SqlDataReader reader = dbloader.Reader( Sql ); 

            while( reader.Read( ) )
            {   
                long lUserID = ( long ) reader [ "biUserID" ];
                int iCountry = ( int ) reader [ "iCountryID" ] ; 
                int iTitle = ( int ) reader [ "iTitleID" ];
                DateTime dtSessStart = ( DateTime ) reader [ "dtCreated" ] ; 

                UserSession session = new UserSession( lUserID,
                                                       iTitle, 
                                                       iCountry, 
                                                       dtSessStart, 
                                                       dtSessStart.AddYears(50) ); //arbitrarily distant end time

                
                if ( htUserRemnantSessions.ContainsKey ( session.m_lUserID ) )
                {
                    //discard older remnants duplicated for the same user. throw a warning here?
                    htUserRemnantSessions.Remove ( session.m_lUserID );
                }
                
                htUserRemnantSessions.Add ( session.m_lUserID, session );
                
            }

            if ( null != reader )
            {
                reader.Close();
            }

            return htUserRemnantSessions;

        }


        static public ArrayList GetUserGameRemnants( DatabaseLoader dbloader, DateTime dtStart, uint uiInterval )
        {

            ArrayList alUserGameRemnants = new ArrayList();

            string Sql = "SELECT  biUserID, dtStart, dtEnd FROM twGameRemnants WHERE " +
                "bProcessed = 0 AND " +
                "( ( dtStart <= " + Helper.ToSQL(dtStart) + " AND dtEnd >= " + Helper.ToSQL(dtStart) + " ) " +
                "OR" +
                "( dtStart > " + Helper.ToSQL(dtStart) + " AND dtStart < " + Helper.ToSQL(dtStart.AddHours(uiInterval)) + 
                ") ) ";

            SqlDataReader reader = dbloader.Reader( Sql ); 

            while( reader.Read( ) )
            {   

                long lUserPUID = ( long ) reader [ "biUserID" ];
                DateTime dtGameStart = ( DateTime ) reader [ "dtStart" ] ; 
                DateTime dtGameEnd = ( DateTime ) reader [ "dtEnd" ] ; 

                UserGame usergame = new UserGame( lUserPUID,
                                                  dtGameStart, 
                                                  dtGameEnd );

                alUserGameRemnants.Add( usergame );          
            }

            if ( null != reader )
            {
                reader.Close();
            }

            return alUserGameRemnants;
        }


        static public bool DetectExistingDailyError ( DatabaseLoader dbloader, DateTime dtStart )
        {
            return ( 0 <
                dbloader.Scalar( "Select count(*) from tcDailyStats where iDayID = " + Helper.ToDayID(dtStart) ) );
        }

        static public bool DetectMissingHourlyError( DatabaseLoader dbloader, DateTime dtStart )
        {
            string Sql = "SELECT count(DISTINCT(iHourID)) FROM tcHourlyStats WHERE iHourID >= " + Helper.ToHourID(dtStart) +
                " AND iHourID < " + Helper.ToHourID(dtStart.AddHours(24));

            int iHoursFound = dbloader.Scalar( Sql );

            return (iHoursFound != 24);
        }


        static public ArrayList GetHourlyStats( DatabaseLoader dbloader, DateTime dtStart )
        {
            ArrayList alHourlyStats = new ArrayList();


            string Sql = "SELECT iTitleID, iCountryID, iSessions, biOnlineTime, iGames, biPlayingTime, iMaxConcurrentUsers, " +
                         "iMinConcurrentUsers, dtMaxConcurrent, dtMinConcurrent FROM tcHourlyStats WHERE iHourID >= " + Helper.ToHourID(dtStart) +
                         " AND iHourID < " + Helper.ToHourID(dtStart.AddHours(24));

            SqlDataReader reader = dbloader.Reader( Sql ); 

            while( reader.Read( ) )
            {   
                int iTitle = ( int ) reader [ "iTitleID" ];
                int iCountry = ( int ) reader [ "iCountryID" ] ; 
                long lSessions = ( int ) reader [ "iSessions" ];
                long lOnlineTime = ( long ) reader [ "biOnlineTime" ];
                long lGames = ( int ) reader [ "iGames" ];
                long lPlayingTime = ( long ) reader [ "biPlayingTime" ];
                int iMaxConcurrent = ( int ) reader [ "iMaxConcurrentUsers" ];
                int iMinConcurrent = ( int ) reader [ "iMinConcurrentUsers" ];
				DateTime dtMaxConcurrent = (DateTime) reader ["dtMaxConcurrent"];
				DateTime dtMinConcurrent = (DateTime) reader ["dtMinConcurrent"];

                HourlyStats hourly = new HourlyStats( iTitle, 
                                                      iCountry, 
                                                      lSessions,
                                                      lOnlineTime,
                                                      lGames,
                                                      lPlayingTime,
                                                      iMaxConcurrent,
                                                      iMinConcurrent,
													  dtMaxConcurrent,
													  dtMinConcurrent);

                alHourlyStats.Add( hourly );
                       
            }

            if ( null != reader )
            {
                reader.Close();
            }

            return alHourlyStats;
        }

        static public ArrayList GetSessionsForDaily( DatabaseLoader dbloader, DateTime dtStart )
        {
            ArrayList alUserSessions = new ArrayList();

            string Sql = "SELECT biUserID, iDNCountryID, iTitleID FROM tfUserSessions WHERE " +
                "iOnlineTime > 0 " +
                "AND ( ( dtStarted <= " + Helper.ToSQL(dtStart) + " AND dtEnded >= " + Helper.ToSQL(dtStart) + " ) " +
                "OR" +
                "( dtStarted > " + Helper.ToSQL(dtStart) + " AND dtStarted < " + Helper.ToSQL(dtStart.AddHours(24)) + 
                ") ) ";

            SqlDataReader reader = dbloader.Reader( Sql ); 

            while( reader.Read( ) )
            {   
                long lUserID = ( long ) reader [ "biUserID" ];
                int iCountry = ( int ) reader [ "iDNCountryID" ] ; 
                int iTitle = ( int ) reader [ "iTitleID" ];

                UserSession session = new UserSession( lUserID,
                                                       iTitle, 
                                                       iCountry ); 

                alUserSessions.Add( session );
                       
            }

            if ( null != reader )
            {
                reader.Close();
            }

            return alUserSessions;

        }

        static public ArrayList GetUserGamesForDaily( DatabaseLoader dbloader, DateTime dtStart )
        {

            ArrayList alUserGames = new ArrayList();

            string Sql = "SELECT iDNCountryID, iDNTitleID FROM tfUserGames WHERE " +
                "( ( dtStarted <= " + Helper.ToSQL(dtStart) + " AND dtEnded >= " + Helper.ToSQL(dtStart) + " ) " +
                "OR" +
                "( dtStarted > " + Helper.ToSQL(dtStart) + " AND dtStarted < " + Helper.ToSQL(dtStart.AddHours(24)) + 
                ") ) ";

            SqlDataReader reader = dbloader.Reader( Sql ); 

            while( reader.Read( ) )
            {   
                int iCountry = ( int ) reader [ "iDNCountryID" ] ; 
                int iTitle = ( int ) reader [ "iDNTitleID" ];

                UserGame usergame = new UserGame( iTitle, iCountry);

                alUserGames.Add( usergame );
                       
            }

            if ( null != reader )
            {
                reader.Close();
            }

            return alUserGames;
        }


    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogAgreggator\Stats.cs ===
using System;
using System.Collections;
using xonline.ops.tools.livereports.logparser.logparserlib;


namespace xonline.ops.tools.livereports.logparser.logagreggator 
{

	public class HourlyStats 
	{
        public int m_iCountry;
        public int m_iTitleID;

        public int m_iBatchID;
        private DateTime m_dtHour;
        private int []m_aiMinutes;
        public long m_lGameTime;
        public long m_lGames;
        public long m_lSessions;
        public long m_lOnlineTime;

        public int m_iMaxConcurrent;
        public int m_iMinConcurrent;
		private DateTime m_dtMaxConcurrent;
		private DateTime m_dtMinConcurrent;

        private Hashtable m_htUniqueUsers = new Hashtable();


        public HourlyStats ( int iTitle, 
                             int iCountry, 
                             long lSessions, 
                             long lOnlineTime, 
                             long lGames, 
                             long lPlayingTime,
                             int iMaxConcurrent,
                             int iMinConcurrent,
							 DateTime dtMaxConcurrent,
							 DateTime dtMinConcurrent)
        {
            m_iTitleID = iTitle;
            m_iCountry = iCountry;
            m_lSessions = lSessions;
            m_lOnlineTime = lOnlineTime;
            m_lGames = lGames;
            m_lGameTime = lPlayingTime;
            m_iMaxConcurrent = iMaxConcurrent;
            m_iMinConcurrent = iMinConcurrent;
			m_dtMaxConcurrent = dtMaxConcurrent;
			m_dtMinConcurrent = dtMinConcurrent;
        }

		public HourlyStats( int iBatch, int iTitle, int iCountry, DateTime dtHour )
		{
            m_iBatchID = iBatch;
            m_iCountry = iCountry;
            m_iTitleID = iTitle;
            m_dtHour = dtHour;
            m_aiMinutes = new int[60];

            m_lSessions = 0;
            m_lOnlineTime = 0;
            m_lGames = 0;
            m_lGameTime = 0;
			m_iMaxConcurrent = 0;
			m_iMinConcurrent = 0;
			m_dtMaxConcurrent = dtHour;
			m_dtMinConcurrent = dtHour;

		}

        public void Aggregate( UserGame game )
        {
            //increment game counter
            m_lGames ++;

            //find the game time interval for this hour              
            long lStart = (long)(game.m_dtGameStarted - m_dtHour).TotalSeconds; 
            
            if ( lStart < 0 )
            {
                lStart = 0;
            }

            long lEnd = (long)(game.m_dtGameEnded - m_dtHour).TotalSeconds;

            if ( lEnd > 3600 )
            {
                lEnd = 3600;
            }

            //add the game time
            m_lGameTime += (lEnd - lStart);
            
        }

        public void Aggregate( UserSession session )
        {
            //increment session counter
            m_lSessions ++;
            
            //find the game time interval for this hour              
            long lStart = (long)(session.m_dtSessStarted - m_dtHour).TotalSeconds; 
            long lStartMin = (long)(session.m_dtSessStarted - m_dtHour).TotalMinutes;

            if ( lStart < 0 )
            {
                lStart = 0;
                lStartMin = 0;
            }

            long lEnd = (long)(session.m_dtSessEnded - m_dtHour).TotalSeconds;
            long lEndMin = (long)(session.m_dtSessEnded - m_dtHour).TotalMinutes;

            if ( lEnd > 3600 )
            {
                lEnd = 3600;
                lEndMin = 60;
            }

            //add to the session time
            m_lOnlineTime += (lEnd - lStart);

            //add to the minute-tracking array
            for( long l=lStartMin; l < lEndMin; l++ )
            {
                m_aiMinutes[l]++;
            }

            //add to the unique user hash table once for each user
            if ( !m_htUniqueUsers.Contains( session.m_lUserID ) )
            {
                m_htUniqueUsers.Add( session.m_lUserID, session.m_lUserID );
            }

        }


        public ulong Hash()
        {
			ulong iTitleID = ((ulong)m_iTitleID) << 32;
			ulong iCountry = (ulong)(m_iCountry + 100);
			return iTitleID | iCountry;
			
			//return ((ulong)m_iTitleID) << 32 | (ulong)(m_iCountry+100);
        }

		public ulong HashAllCountries()
		{
			return ((ulong)m_iTitleID)<< 32 | 100;
		}

		public ulong HashAllTitles()
		{
			return (ulong)(m_iCountry+100);
		}

		public ulong HashAll()
		{
			return 100;
		}

        public string ToSQL()
        {
            //find min and max concurrent just before insertion
            m_iMinConcurrent = 0x7FFFFFFF; //MAXINT in C#?
            m_iMaxConcurrent = 0;

            for(int i=0; i<60; i++)
            {
                if ( m_iMinConcurrent > m_aiMinutes[i] )
                {
                    m_iMinConcurrent = m_aiMinutes[i];
					m_dtMinConcurrent = m_dtHour.AddMinutes(i);
                }

                if ( m_iMaxConcurrent < m_aiMinutes[i] )
                {
                    m_iMaxConcurrent = m_aiMinutes[i];
					m_dtMaxConcurrent = m_dtHour.AddMinutes(i);
                }
            }


            string str = "INSERT INTO tcHourlyStats "+
                         "( iHourID, iTitleID, iCountryID, iBatchID, iSessions, biOnlineTime, iGames, biPlayingTime, iUniqueUsersPerHour, " +
                         "iMaxConcurrentUsers, iMinConcurrentUsers, dtMaxConcurrent, dtMinConcurrent ) VALUES ( " +
                         Helper.ToHourID( m_dtHour ) + ", " +
                         m_iTitleID + ", " +
                         m_iCountry + ", " +
                         m_iBatchID + ", " +
                         m_lSessions + ", " +
                         m_lOnlineTime + ", " +
                         m_lGames + ", " +
                         m_lGameTime + ", " +
                         m_htUniqueUsers.Count + ", " +
                         m_iMaxConcurrent + ", " +
                         m_iMinConcurrent + ", " +
                         Helper.ToSQL(m_dtMaxConcurrent) + ", " +
                         Helper.ToSQL(m_dtMinConcurrent) + ")";

            return str;
        }

		public DateTime dtMaxConcurrent
		{
			get
			{
				return m_dtMaxConcurrent;
			}
		}

		public DateTime dtMinConcurrent
		{
			get
			{
				return m_dtMinConcurrent;
			}
		}

	}

    public class DailyStats
    {
        private int m_iBatch;
        private int m_iCountry;
        private int m_iTitle;
        private DateTime m_dtDay;

        private long m_lGameTime;
        private long m_lGames;
        private long m_lSessions;
        private long m_lOnlineTime;

        private int m_iMaxConcurrent;
        private int m_iMinConcurrent;
		private DateTime m_dtMaxConcurrent;
		private DateTime m_dtMinConcurrent;

        private  Hashtable m_htUniqueUsers;

        public DailyStats( int iBatch, int iTitle, int iCountry, DateTime dtDay )
        {
            m_iBatch = iBatch;
            m_iCountry = iCountry; 
            m_iTitle = iTitle;
            m_dtDay = dtDay;

            m_lGameTime = 0;
            m_lGames = 0;
            m_lSessions = 0;
            m_lOnlineTime = 0;
            
            m_iMinConcurrent = 0x7FFFFFFF; //MAXINT in C#?
            m_iMaxConcurrent = 0;
			m_dtMaxConcurrent = dtDay;
			m_dtMinConcurrent = dtDay;

            m_htUniqueUsers = new Hashtable();

        }

        public void Aggregate ( HourlyStats hourly )
        {
            //cannot add up unique games and sessions here to come up with the daily unique counts
            m_lGameTime += hourly.m_lGameTime;
            m_lOnlineTime += hourly.m_lOnlineTime;

            if ( m_iMaxConcurrent < hourly.m_iMaxConcurrent )
            {
                m_iMaxConcurrent = hourly.m_iMaxConcurrent;
				m_dtMaxConcurrent = hourly.dtMaxConcurrent;
            }

            if ( m_iMinConcurrent > hourly.m_iMinConcurrent )
            {
                m_iMinConcurrent = hourly.m_iMinConcurrent;
				m_dtMinConcurrent = hourly.dtMinConcurrent;
            }
                                                   
        }

        public void Aggregate ( UserSession session )
        {
            m_lSessions ++;

            //add to the unique user hash table once for each user
            if ( !m_htUniqueUsers.Contains( session.m_lUserID ) )
            {
                m_htUniqueUsers.Add( session.m_lUserID, session.m_lUserID );
            }
        }

        public void Aggregate ( UserGame game )
        {
            m_lGames ++;
        }

        public string ToSQL()
        {
            string str = "INSERT INTO tcDailyStats "+
                "( iDayID, iTitleID, iCountryID, iBatchID, iSessions, biOnlineTime, iGames, biPlayingTime, iUniqueUsersPerDay, " +
                "iMaxConcurrentUsers, iMinConcurrentUsers, dtMaxConcurrent, dtMinConcurrent ) VALUES ( " +
                Helper.ToDayID( m_dtDay ) + ", " +
                m_iTitle + ", " +
                m_iCountry + ", " +
                m_iBatch + ", " +
                m_lSessions + ", " +
                m_lOnlineTime + ", " +
                m_lGames + ", " +
                m_lGameTime + ", " +
                m_htUniqueUsers.Count + ", " +
                m_iMaxConcurrent + ", " +
				m_iMinConcurrent + ", " +
				Helper.ToSQL(m_dtMaxConcurrent) + ", " +
				Helper.ToSQL(m_dtMinConcurrent) + ")";

            return str;
        }

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogAgreggator\Sessions.cs ===
using System;

namespace xonline.ops.tools.livereports.logparser.logagreggator 
{

    public class UserSession
    {
        public long m_lUserID;
        public int m_iTitleID;
        public int m_iCountry;
        public DateTime m_dtSessStarted;
        public DateTime m_dtSessEnded;

        public UserSession ( long lUserID,
                             int iTitleID,
                             int iCountry )
        {
            m_lUserID = lUserID;
            m_iTitleID = iTitleID;
            m_iCountry = iCountry;
        }

        public UserSession( long lUserID,
                            int iTitleID, 
                            int iCountry, 
                            DateTime dtStarted, 
                            DateTime dtEnded )
        {
            m_lUserID = lUserID;
            m_iTitleID = iTitleID;
            m_iCountry = iCountry;
            m_dtSessStarted = dtStarted;
            m_dtSessEnded = dtEnded;
        }

        public ulong Hash()
        {
			ulong iTitleID = ((ulong)m_iTitleID) << 32;
			ulong iCountry = (ulong)(m_iCountry + 100);
			return iTitleID | iCountry;

            //return ((ulong)m_iTitleID) << 32 | (ulong)(m_iCountry+100);
        }

        public ulong HashAllCountries()
        {
            return ((ulong)m_iTitleID)<< 32 | 100;
        }

        public ulong HashAllTitles()
        {
            return (ulong)(m_iCountry+100);
        }

        public ulong HashAll()
        {
            return 100;
        }

    }



    public class UserGame
    {
        public long m_lUserID;
        public int m_iTitleID;
        public int m_iCountry;
        public DateTime m_dtGameStarted;
        public DateTime m_dtGameEnded;

       
        
        //for daily
        public UserGame( int iTitleID, 
                         int iCountry )
        {
            m_iTitleID = iTitleID;
            m_iCountry = iCountry;
        }

        //for hourly
        public UserGame( int iTitleID, 
                         int iCountry, 
                         DateTime dtGameStarted, 
                         DateTime dtGameEnded )
        {
            m_iTitleID = iTitleID;
            m_iCountry = iCountry;
            m_dtGameStarted = dtGameStarted;
            m_dtGameEnded = dtGameEnded;
        }

        //for hourly remnant
        public UserGame( long lUserID,
                         DateTime dtGameStarted, 
                         DateTime dtGameEnded  )
        {
            m_lUserID = lUserID;
            m_dtGameStarted = dtGameStarted;
            m_dtGameEnded = dtGameEnded;
        }

        public ulong Hash()
        {
			ulong iTitleID = ((ulong)m_iTitleID) << 32;
			ulong iCountry = (ulong)(m_iCountry + 100);
			return iTitleID | iCountry;
			
			//return ((ulong)m_iTitleID)<< 32 | (ulong)(m_iCountry+100);
        }

        public ulong HashAllCountries()
        {
            return ((ulong)m_iTitleID)<< 32 | 100 ;
        }

        public ulong HashAllTitles()
        {
            return (ulong)(m_iCountry+100);
        }

        public ulong HashAll()
        {
            return 100;
        }

    }

	



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogUserMonEx\LogUserMonEx.cpp ===
// LogUserMonEx.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "ParsePresenceFile.h"

string g_strPath;

void ParseCommandLine(int argc, TCHAR* argv[])
{
	for (int i = 1; i < argc; i++)
	{
		TCHAR* pszParam = argv[i];
		bool bFlag = false;
		bool bLast = ((i + 1) == argc);
		if (pszParam[0] == '-' || pszParam[0] == '/')
		{
			// remove flag specifier
			bFlag = true;
			++pszParam;
		}

		char* pszToken = NULL;
		char szName[50];
		string strValue;

		memset(szName, 0, sizeof(char) * 50);

		pszToken = strtok(pszParam, "=");

		if (NULL != pszToken)
		{
			strncpy(szName, pszToken, strlen(pszToken));
			pszToken = strtok(NULL, "=");
			strValue = pszToken;
		}


		if (0 == strcmp(szName, "Path"))
		{
			g_strPath = strValue;
		}

	}
}

int _tmain(int argc, _TCHAR* argv[])
{
	ParseCommandLine(argc, argv);

	if (true == g_strPath.empty())
	{
		cout << "Usage: LogUserMonEx -Path=value\n" << endl;
		return -1;
	}

	bool fIsFile = false;
	ifstream ifsFile;

	ifsFile.open(g_strPath.c_str());

	if (0 != ifsFile.is_open())
	{
		fIsFile = true;
		ifsFile.close();
	}

	CParsePresenceFile cpfLogs;
	bool fSuccess = true;

	if (true == fIsFile)
	{
		cpfLogs.SetFile(g_strPath);
		fSuccess = cpfLogs.ParseFile();
	}
	else
	{
		fSuccess = cpfLogs.ProcessDirectory(g_strPath);
	}
	
	CParsePresenceFile::STATS PresStats;
	
	if (true == fSuccess && true == fIsFile)
	{

		cpfLogs.GetStats(PresStats);
		cout << "Stats for file:" << g_strPath << endl;
		cout << "Alive: " << PresStats.m_ulTotalAlive << endl;
		cout << "Killed: " << PresStats.m_ulTotalKilled << endl;
		cout << "Currently Alive: " << PresStats.m_lAlive << endl;
		cout << endl;
	}
	else if (true == fSuccess)
	{
		for ( int nHour = 0; nHour < 24; ++nHour)
		{
			for (int nMinute = 0; nMinute < 60; ++nMinute)
			{
				cpfLogs.GetMinutesStats(PresStats, nHour, nMinute);
				cout << "Stats for hour: " << nHour << " minute: " << nMinute << endl;
				cout << "Total Alive: " << PresStats.m_ulTotalAlive << endl;
				cout << "Total Killed: " << PresStats.m_ulTotalKilled << endl;
				cout << "Currently Alive: " << PresStats.m_lAlive << endl;
				cout << endl;
			}
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogUserMonEx\ParsePresenceFile.cpp ===
#include "stdafx.h"
#include "parsepresencefile.h"

CParsePresenceFile::CParsePresenceFile(void)
{
	Init();
}

CParsePresenceFile::CParsePresenceFile(string strFilename)
{
	m_strFilename = strFilename;
	Init();
}

CParsePresenceFile::~CParsePresenceFile(void)
{
}

void CParsePresenceFile::Init()
{
	m_Stats.m_ulTotalAlive = 0;
	m_Stats.m_ulTotalKilled = 0;
	m_Stats.m_lAlive = 0;
	m_Stats.m_lMax = -9999999;
	m_Stats.m_lMin = 9999999;

	for ( int nHour = 0; nHour < 24; ++nHour)
	{
		for (int nMinute = 0; nMinute < 60; ++nMinute)
		{
			m_MinutesStats[nHour][nMinute].m_ulTotalAlive = 0;
			m_MinutesStats[nHour][nMinute].m_ulTotalKilled = 0;
			m_MinutesStats[nHour][nMinute].m_lAlive = 0;
			m_MinutesStats[nHour][nMinute].m_lMax = -9999999;
			m_MinutesStats[nHour][nMinute].m_lMin = 9999999;
		}
	}
}

void CParsePresenceFile::Term()
{
	if (0 != m_Input.is_open())
	{
		m_Input.close();
	}
}

bool CParsePresenceFile::OpenLogFile()
{
	bool fReturn = true;

	Term();

	if (false == m_strFilename.empty())
	{
		m_Input.open(m_strFilename.c_str());
	}
	else
	{
		fReturn = false;
	}

	if (0 == m_Input.is_open())
	{
		fReturn = false;
	}

	return fReturn;

}

bool CParsePresenceFile::ParseFile()
{
	bool fReturn = true;

	if (0 == m_Input.is_open())
	{
		fReturn = OpenLogFile();
	}

	if (true == fReturn )
	{
		string strLine;

		while (!m_Input.eof())
		{
			char line[500];

			memset(line, 0, sizeof(char) * 500);
			m_Input.getline(line, 500);

			ParseLine(line);
		}
	}
	else
	{
		fReturn = false;
	}

	return fReturn;
}

bool CParsePresenceFile::ParseLine(char* szLine)
{
	bool fReturn = true;

	if (NULL == szLine)
	{
		return false;
	}

	int nTokenNum = 0;
	char *pszToken = NULL;
	string strTime;
	string strLineType;
	string strLineDesc;

	pszToken = strtok(szLine, "|");

	while (NULL != pszToken)
	{
		switch(nTokenNum)
		{
			case  0 : 
				strTime = pszToken; 
				break;
			case  1 : /* skip line type */  
				strLineType = pszToken;
				break;
			case  2 : /* skip line description */ 
				strLineDesc = pszToken;
				break;
			case  3 : /*SG = strItem ;*/ 
				break;
			case  4 : /*SGInt  = Helper.ToInt ( strItem ) ;*/ 
				break;
			case  5 : /*spi  = Helper.ToInt ( strItem ) ;*/ 
				break;
			case  6 : /* skip Xbox ID */
				break;
			case  7 : /* skip user PUID */
				break;
			case  8 : /* skip TitleID */
				break;
			case  9 : /*State = Helper.ToInt ( strItem ) ;*/ 
				break;
			case 10 : /*MatchSessionID = Helper.ToLong ( strItem ) ;*/ 
				break;
			case 11 : /* skip hr */
				break;
			default:
				break;
		}
		
		pszToken = strtok(NULL, "|");
		++nTokenNum;
	}

	if (strLineType == "102" && strLineDesc == "ALIVE")
	{
		m_Stats.m_lAlive++;
		m_Stats.m_ulTotalAlive++;
	}

	if(strLineType == "103" && strLineDesc == "KILLED")
	{
		m_Stats.m_ulTotalKilled++;
		m_Stats.m_lAlive--;
	}

	SYSTEMTIME stDate;

	fReturn = ParseDate(const_cast<char*>(strTime.c_str()), stDate);

	if (true == fReturn)
	{
		
		if (strLineType == "102" && strLineDesc == "ALIVE")
		{
			m_MinutesStats[stDate.wHour][stDate.wMinute].m_lAlive++;
			m_MinutesStats[stDate.wHour][stDate.wMinute].m_ulTotalAlive++;
		}

		if(strLineType == "103" && strLineDesc == "KILLED")
		{
			m_MinutesStats[stDate.wHour][stDate.wMinute].m_ulTotalKilled++;
			m_MinutesStats[stDate.wHour][stDate.wMinute].m_lAlive--;
		}
	}
		
	return fReturn;
}

void CParsePresenceFile::GetStats(STATS &otherStats)
{
	otherStats.m_lMax = m_Stats.m_lMax;
	otherStats.m_lMin = m_Stats.m_lMin;
	otherStats.m_ulTotalAlive = m_Stats.m_ulTotalAlive;
	otherStats.m_ulTotalKilled = m_Stats.m_ulTotalKilled;
	otherStats.m_lAlive = m_Stats.m_lAlive;
}


void CParsePresenceFile::GetMinutesStats(STATS &otherStats, int nHour, int nMinute)
{
	otherStats.m_lMax = m_MinutesStats[nHour][nMinute].m_lMax;
	otherStats.m_lMin = m_MinutesStats[nHour][nMinute].m_lMin;
	otherStats.m_ulTotalAlive = m_MinutesStats[nHour][nMinute].m_ulTotalAlive;
	otherStats.m_ulTotalKilled = m_MinutesStats[nHour][nMinute].m_ulTotalKilled;
	otherStats.m_lAlive = m_MinutesStats[nHour][nMinute].m_lAlive;
}

bool CParsePresenceFile::SetFile(string strFilename)
{
	bool fReturn = true;

	Term();
	m_strFilename = strFilename;

	return fReturn;
}

bool CParsePresenceFile::ProcessDirectory(string strDirectory, bool fReportAfterEachFile)
{
    WIN32_FIND_DATA wfd;
    HANDLE hFind;
	bool fReturn = true;

	if (true == strDirectory.empty())
	{
		return false;
	}

	string strFind = strDirectory;
	
	strFind += "\\*.log";

    // Start the find and check for failure.
	hFind = FindFirstFile( strFind.c_str(), &wfd );

    if( INVALID_HANDLE_VALUE == hFind )
    {
        OutputDebugString( "FindFirstFile failed." );
    }
    else
    {
        // Display each file and ask for the next.
        do
        {
			string strPath = strDirectory;

            OutputDebugString( wfd.cFileName );
			strPath += "\\";
			strPath += wfd.cFileName;
			SetFile(strPath);
			fReturn = ParseFile();

			if (true == fReturn && true == fReportAfterEachFile)
			{
				cout << "Stats for file:" << strPath << endl;
				cout << "Total Alive: " << m_Stats.m_ulTotalAlive << endl;
				cout << "Total Killed: " << m_Stats.m_ulTotalKilled << endl;
				cout << "Currently Alive: " << m_Stats.m_lAlive << endl;
				cout << endl;
			}
        } while( true == fReturn && FindNextFile( hFind, &wfd ) );

        // Close the find handle.
        FindClose( hFind );
    }

	return fReturn;
}

bool CParsePresenceFile::ParseDate(char *szDate, SYSTEMTIME &stDate)
{
	if (NULL == szDate)
	{
		return false;
	}

	bool fReturn = true;

	char szYear[5];
	char szMonth[3];
	char szDay[3];
	char szHours[3];
	char szMinutes[3];
	char szSeconds[3];
	char szMiliSeconds[4];

	memset(szYear, 0, sizeof(char) * 5);
	memset(szMonth, 0, sizeof(char) * 3);
	memset(szDay, 0, sizeof(char) * 3);
	memset(szHours, 0, sizeof(char) * 3);
	memset(szMinutes, 0, sizeof(char) * 3);
	memset(szSeconds, 0, sizeof(char) * 3);
	memset(szMiliSeconds, 0, sizeof(char) * 4);

	int nToken = 0;
	char *pszToken = strtok(szDate, "/:. ");

	while (NULL != pszToken)
	{
		switch(nToken)
		{
		case 0:
			strncpy(szYear, pszToken, strlen(pszToken));
			break;
		case 1:
			strncpy(szMonth, pszToken, strlen(pszToken));
			break;
		case 2:
			strncpy(szDay, pszToken, strlen(pszToken));
			break;
		case 3:
			strncpy(szHours, pszToken, strlen(pszToken));
			break;
		case 4:
			strncpy(szMinutes, pszToken, strlen(pszToken));
			break;
		case 5:
			strncpy(szSeconds, pszToken, strlen(pszToken));
			break;
		case 6:
			strncpy(szMiliSeconds, pszToken, strlen(pszToken));
			break;
		default:
			break;
		}

		pszToken = strtok(NULL, "/:. ");
		++nToken;
	}

	stDate.wYear = atoi(szYear);
	stDate.wMonth = atoi(szMonth);
	stDate.wDay = atoi(szDay);
	stDate.wHour = atoi(szHours);
	stDate.wMinute = atoi(szMinutes);
	stDate.wSecond = atoi(szSeconds);
	stDate.wMilliseconds = atoi(szMiliSeconds);

	return fReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogParserlib\Tools.cs ===
using System;
using System.Collections;
using System.IO ;
//using System.Text ;
using System.Globalization; 
using System.Diagnostics;

namespace xonline.ops.tools.livereports.logparser.logparserlib 
{
    //base interface for log encapsulating classes
    public interface IXLAppLog
    {
        string ToSqlRaw();
    }

    //helper class for parsing
	public class Tokens : IEnumerable
	{
		private string[] elements;

		public Tokens(string source, char[] delimiters)
		{
			// Parse the string into tokens:
			elements = source.Split(delimiters);
		}

		// IEnumerable Interface Implementation:
		//   Declaration of the GetEnumerator() method required by IEnumerable
		public IEnumerator GetEnumerator()
		{
			return new TokenEnumerator(this);
		}

		// Inner class implements IEnumerator interface:
		private class TokenEnumerator : IEnumerator
		{
			private int position = -1;
			private Tokens t;

			public TokenEnumerator(Tokens t)
			{
				this.t = t;
			}

			// Declare the MoveNext method required by IEnumerator:
			public bool MoveNext()
			{
				if (position < t.elements.Length - 1)
				{
					position++;
					return true;
				}
				else
				{
					return false;
				}
			}

			// Declare the Reset method required by IEnumerator:
			public void Reset()
			{
				position = -1;
			}

			// Declare the Current property required by IEnumerator:
			public object Current
			{
				get
				{
					return t.elements[position];
				}
			}
		}
	}

    //provides miscellaneous services for the library
    public class Helper
    {
        //TODO: link with xeventids.h
        static int i = 0xD034;
        static int i = 0xD035;
        static int i = 0xD036;
        static int i = 0xD037;
        static int i = 0xD038;

        public enum MsgType { Info=0, Warn=1, Err=2, Abort=3, Summary=4 };

        private static int iWarnCount = 0;
        private static int iErrCount = 0;

        private static string m_Filename="";

        public static string LogPath = "";
        public static string strCaller = "";

        // Time Origin for Week number 
        public static DateTime Week_0 = new DateTime ( 2002, 7, 21 ) ; 
        // Handy string for SQL statements 
        public const string SQ = "'" ; 

        public static bool IsNumeric ( char c ) 
        {
            return ( ( c >= '0' ) && ( c <= '9' ) ) ; 
        } 

        public static int ToHourID ( DateTime dt ) 
        { 
            return 
                100 * ( 100 * ( 100 * ( dt.Year - 2000 ) + dt.Month ) + dt.Day ) + dt.Hour ; 
        } 

        public static int ToDayID ( DateTime dt ) 
        { 
            return 
                100 * ( 100 * ( 100 * ( dt.Year - 2000 ) + dt.Month ) + dt.Day ) + 99 ; 
        } 

        public static string ToSQL ( DateTime dt ) 
        {   //I couldn't find an DateTimeFormatInfo that includes millisecond, so I did it myself
            return Helper.SQ + dt.ToString ( "G" , DateTimeFormatInfo.InvariantInfo ) + ":" + dt.Millisecond + Helper.SQ ; 
        }
        
        public static string ToBulk ( DateTime dt ) 
        {   //I couldn't find an DateTimeFormatInfo that includes millisecond, so I did it myself
            return dt.ToString ( "G" , DateTimeFormatInfo.InvariantInfo ) + ":" + dt.Millisecond; 
        } 


        public static string ToSQL ( string s ) 
        { 
            if ( s.IndexOf ( "'" ) != -1 ) 
            { 
                s = s.Replace ( "'" , "''" ) ; 
            } ;
            return Helper.SQ + s + Helper.SQ ; 
        } 

        public static int ToInt ( string strItem ) 
        {
            if ( strItem == "" ) 
                return 0 ; 
            else 
            { 
                if ( strItem [ 0 ] == '-' ) 
                    return Convert.ToInt32 ( strItem ) ; 
                else 
                    return ( int ) Convert.ToUInt32 ( strItem ) ; 
            } ; 
        } 

        public static long ToLong ( string strItem ) 
        {
            if ( strItem == "" ) 
                return 0 ; 
            else 
            { 
                if ( strItem [ 0 ] == '-' ) 
                    return Convert.ToInt64 ( strItem ) ; 
                else 
                    return ( long ) Convert.ToUInt64 ( strItem ) ; 
            } ; 
        } 

        public static void LogMessage ( MsgType msgtype, string Message  ) 
        { 
            //write to event logs on first warning, first error, abortive error, and error,warning summary
            unchecked
            {            
                if (msgtype == MsgType.Warn)
                {
                    if ( 0 == iWarnCount++ && 0 == iErrCount )
                    {
                        EventLog.WriteEntry( strCaller, Message, EventLogEntryType.Warning, i );  
                    }
                }
                else if (msgtype == MsgType.Err)
                {
                    if ( 0 == iErrCount++)
                    {
                        EventLog.WriteEntry( strCaller, Message, EventLogEntryType.Error, i ); 
                    }
                }
                else if (msgtype == MsgType.Abort)
                {
                    iErrCount++;

                    string str = strCaller + " aborted on the following non-recoverable error:\r\n";
                    EventLog.WriteEntry( strCaller, str + Message, EventLogEntryType.Error, i );
                }
                else if (msgtype == MsgType.Summary)
                {
                    if ( iWarnCount > 0 || iErrCount > 0 )
                    {
                        string str = strCaller + " completed, but with warnings and/or errors.\r\n" +
                            "Warning(s): " + iWarnCount + "\r\n" +
                            "Error(s): " + iErrCount + "\r\n\r\n" +
                            "An investigation is required!";

                        if ( iErrCount > 0 )
                        {
                            EventLog.WriteEntry( strCaller, 
                                str, 
                                EventLogEntryType.Error,
                                i ); 
                        }
                        else
                        {
                            EventLog.WriteEntry( strCaller, 
                                str, 
                                EventLogEntryType.Warning, 
                                i ); 
                        }
                    }

                    return;
                }
            }
            
            // Prepend date and time to message.
            DateTime now = DateTime.Now ;
            string LoggedMessage = now.ToString ( ) + " - " + Message ; 

            if ( "" == m_Filename )
            {
                Directory.CreateDirectory(Helper.LogPath);

                m_Filename = 
                    Helper.LogPath +
                    "Parser_" + 
                    now.Year.ToString ( "0000" ) + "_" +
                    now.Month.ToString ( "00" ) + "_" + 
                    now.Day.ToString ( "00" ) + "_" + 
                    now.Hour.ToString ( "00" ) + "_" +
                    now.Minute.ToString( "00" ) + "_" +
                    now.Millisecond.ToString ( "00" ) +
                    ".log"; 
            }

            StreamWriter log = null ; 
            try 
            { 
                log = new StreamWriter ( m_Filename , true ) ; 
                log.WriteLine ( LoggedMessage ) ; 
            } 
            catch ( Exception e ) 
            { 
                // If we get an exception here, we wont be able to log it.
                Console.WriteLine ( e.Message ) ;
            }
            finally 
            { 
                if ( log != null ) 
                    log.Close ( ) ; 
            } ; 

            Console.WriteLine ( LoggedMessage ) ; 
        } 

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogUserMonEx\ParsePresenceFile.h ===
#pragma once
#include "stdafx.h"

class CParsePresenceFile
{
public:
	typedef struct 
	{
		unsigned long m_ulTotalAlive;
		unsigned long m_ulTotalKilled;
		long m_lAlive;
		long m_lMax;
		long m_lMin;
	}STATS;

public:
	CParsePresenceFile(void);
	CParsePresenceFile(string strFilename);
	~CParsePresenceFile(void);

	bool ParseFile();
	bool ProcessDirectory(string strDirectory, bool fReportAfterEachFile = true);
	bool SetFile(string Filename);
	void GetStats(STATS &otherStats);
	void GetMinutesStats(STATS &otherStats, int nHour, int nMinute);

protected:
	void Init();
	void Term();
	bool ParseLine(char *szLine);
	bool ParseDate(char *szDate, SYSTEMTIME &stDate);
	bool OpenLogFile();
	string m_strFilename;
	ifstream m_Input;

private:
	STATS m_Stats;
	STATS m_MinutesStats[24][60];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogParserlib\BatchRec.cs ===
using System;
using System.Globalization; 

namespace xonline.ops.tools.livereports.logparser.logparserlib 
{
	/// <summary>
	/// Summary description for BatchRec.
	/// </summary>
	public abstract class BatchRec 
	{
		public enum Phases { Started = 0 , Parsing , Inserting , Completed , Aborted, RolledBack } ; 
		public int	BatchId ; 
		DateTime	TimeStamp ; 
		Phases		Phase ; 
        protected string      strTableName;

		public BatchRec( )
		{
			BatchId   = -1 ; 
			TimeStamp = DateTime.Now ; 
			Phase	  = Phases.Started ; 
		}

		public int Id
		{
			get
			{
				return BatchId ;
			}
		}

		public bool Aborted
		{
			get
			{
				return Phase == Phases.Aborted ;
			}
		}

		public void Update ( Phases _Phase )
		{
			TimeStamp = DateTime.Now ; 
			Phase	  = _Phase ; 
		}

		public string ToSqlInsert ( ) 
		{ 
			return 
				"INSERT INTO " + strTableName + " ( dtTimeStamp, iPhase ) " +
				"VALUES ( " + Helper.ToSQL( TimeStamp ) + " , " + ( ( int ) Phase ).ToString ( ) + " ) " ; 
		} 

        public string ToSqlInsertAgg ( DateTime dtAggStart, char cPeriod )
        {
            return 
                "INSERT INTO " + strTableName + " ( dtTimeStamp, iPhase, dtAggStart, cAggPeriod ) " +
                "VALUES ( " + Helper.ToSQL( TimeStamp ) + " , " +
                ( ( int ) Phase ).ToString ( ) + ", " +
                Helper.ToSQL(dtAggStart) + ", " +
                "'" + cPeriod + "' ) " ; 
        }

		public string ToSqlSelect ( ) 
		{ 
			return 
				"SELECT iBatchID FROM " + strTableName + " " +
				"WHERE ( dtTimeStamp = " + Helper.ToSQL( TimeStamp ) + " ) " ; 
		} 

		public string ToSqlVerify ( int BatchId ) 
		{ 
			return 
				"SELECT COUNT ( * ) FROM " + strTableName + " " +
				"WHERE ( iBatchID = " + BatchId.ToString ( ) + " ) " ; 
		} 

		public string ToSqlVerifyFiles ( int BatchId ) 
		{ 
			return 
				" SELECT COUNT ( twFiles.iFileID ) AS FileCount " +
				" FROM  " + strTableName + " INNER JOIN twFiles " + 
				" ON twBatches.iBatchID = twFiles.iBatchID " + 
				" WHERE ( twBatches.iBatchID = " + BatchId.ToString ( ) + " ) " ; 
		} 

		public string ToSqlUpdate ( ) 
		{ 
			return 
				"UPDATE " + strTableName +
				" SET dtTimeStamp = " + Helper.ToSQL( TimeStamp ) + " , " + 
				"     iPhase  = " + ( ( int ) Phase ).ToString ( ) + " " + 
				" WHERE ( iBatchID = " + Id.ToString ( ) + " ) " ; 
		} 

	}

    public class AggBatchRec : BatchRec
    {
        public AggBatchRec()
        {
            strTableName = "twAggBatches";
        }
    }

    public class ParserBatchRec : BatchRec
    {
        public ParserBatchRec()
        {
            strTableName = "twParserBatches";
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\ops\tools\livereports\logparser\LogParserlib\DatabaseLoader.cs ===
using System;
using System.Text;
using System.Collections;
using System.IO;
using System.Data.SqlClient; 
using System.Threading;


namespace xonline.ops.tools.livereports.logparser.logparserlib 
{
	/// <summary>
	/// Summary description for DatabaseLoader.
	/// </summary>
	public class DatabaseLoader
	{
		public bool Connected = false ; 
		private int m_nTimeoutValue = 300;
		private int m_nBackoffValue = 60;
		System.Data.SqlClient.SqlConnection connection = null ; 

		public DatabaseLoader( )
		{
		}

		public void Execute ( string SqlStatement ) 
		{ 
			// Simple utility to run a DML statement 
			if ( ( ! Connected ) || ( connection == null ) ) 
			{
				return; 
			}

			bool fContinue = true;
			SqlCommand cmd = new SqlCommand( ) ;
			cmd.CommandText = SqlStatement ;
			cmd.Connection = connection ;
			cmd.CommandTimeout = 300;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{
				try
				{
					cmd.CommandTimeout *= i;
					cmd.ExecuteNonQuery();
				}

				catch (SqlException e) 
				{
					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat("Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat("Class: {0}", e.Class);
					sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat("Neither record was written to database.");
					sbErrMsg.AppendFormat("Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;

					}
					else
					{
						fContinue = true;
						Thread.Sleep(m_nBackoffValue * 1000 * i);
					}

					if (false == fContinue)
					{
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher in the call stack as a critical error.
						throw e;
					}

					Helper.LogMessage(Helper.MsgType.Err, sbErrMsg.ToString());
				}

			}
		} 

		public int Scalar ( string SqlStatement ) 
		{ 
			// Simple utility to run a DML statement 
			if ( ( ! Connected ) || ( connection == null ) ) 
			{
				return -1;
			}

			bool fContinue = true;
			SqlCommand cmd = new SqlCommand( ) ;
			cmd.CommandText = SqlStatement ;
			cmd.Connection = connection ;
			cmd.CommandTimeout = m_nTimeoutValue;

			for (int i = 1; true == fContinue && i <= 3; ++i)
			{
				try
				{
					cmd.CommandTimeout *= i;
					object o = cmd.ExecuteScalar( ) ; 
				
					if ( null == o ) // no data 
					{
						return -1;
					}

					return ( int ) ( o );
				}

				catch (SqlException e) 
				{
					SqlErrorCollection myErrors = e.Errors;
					StringBuilder sbErrMsg = new StringBuilder(255);

					sbErrMsg.AppendFormat("Sql statement execution attempt #{0}", i);
					sbErrMsg.AppendFormat("Class: {0}", e.Class);
					sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}." , e.Number, e.Message, e.LineNumber);
					sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", e.Source, e.Server);
					sbErrMsg.AppendFormat("Neither record was written to database.");
					sbErrMsg.AppendFormat("Errors collection contains:");

					if (e.Number > 19 || i > 2)
					{
						for (int nIndex = 0; nIndex < myErrors.Count; nIndex++) 
						{
							sbErrMsg.AppendFormat("Class: {0}", myErrors[nIndex].Class);
							sbErrMsg.AppendFormat("Error #{0}: {1} on line {2}.", myErrors[nIndex].Number, myErrors[nIndex].Message, myErrors[nIndex].LineNumber);
							sbErrMsg.AppendFormat("Error reported by {0} while connected to {1}.", myErrors[nIndex].Source, myErrors[nIndex].Server);
						}

						fContinue = false;
					}
					else
					{
						fContinue = true;
						Thread.Sleep(m_nBackoffValue * 1000 * i);
					}

					Helper.LogMessage(Helper.MsgType.Err, sbErrMsg.ToString());

					if (false == fContinue)
					{
						// We could not complete the action. We will rethrow the exception so
						// that it is handle up futher 