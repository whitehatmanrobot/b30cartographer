-------------------------------

DWORD
DfspCreateFtDfs(
    LPWSTR wszServerName,
    LPWSTR wszDcName,
    BOOLEAN fIsPdc,
    LPWSTR wszRootShare,
    LPWSTR wszFtDfsName,
    LPWSTR wszComment,
    DWORD  dwFlags)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwErr2 = ERROR_SUCCESS;
    DWORD i, j;

    LPWSTR wszDfsConfigDN = NULL;
    LPWSTR wszConfigurationDN = NULL;
    PDFSM_ROOT_LIST RootList = NULL;

    LDAP *pldap = NULL;
    PLDAPMessage pMsg = NULL;

    LDAPModW ldapModClass, ldapModCN, ldapModPkt, ldapModPktGuid, ldapModServer;
    LDAP_BERVAL ldapPkt, ldapPktGuid;
    PLDAP_BERVAL rgModPktVals[2];
    PLDAP_BERVAL rgModPktGuidVals[2];
    LPWSTR rgModClassVals[2];
    LPWSTR rgModCNVals[2];
    LPWSTR rgModServerVals[5];
    LPWSTR rgAttrs[5];
    PLDAPModW rgldapMods[6];
    BOOLEAN fNewFTDfs = FALSE;

    LDAPMessage *pmsgServers;
    PWCHAR *rgServers;
    DWORD cServers;
    ULONG Size;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspCreateFtDfs(%ws,%ws,%s,%ws,%ws,%ws,%d)\n",
                    wszServerName,
                    wszDcName,
                    fIsPdc ? "TRUE" : "FALSE",
                    wszRootShare,
                    wszFtDfsName,
                    wszComment,
                    dwFlags);
#endif

    dwErr = DfspLdapOpen(
                wszDcName,
                &pldap,
                &wszConfigurationDN);
    if (dwErr != ERROR_SUCCESS) {

        goto Cleanup;

    }

    //
    // See if the DfsConfiguration object exists; if not and this is the 
    // PDC, create it.
    //

    rgAttrs[0] = L"cn";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_sW(
                pldap,
                wszConfigurationDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (pMsg != NULL) {
        ldap_msgfree(pMsg);
        pMsg = NULL;
    }

#if DBG
    if (DfsDebug)
        DbgPrint("ldap_search_sW(1) returned 0x%x\n", dwErr);
#endif

    if (dwErr == LDAP_NO_SUCH_OBJECT && fIsPdc == TRUE) {

        rgModClassVals[0] = L"dfsConfiguration";
        rgModClassVals[1] = NULL;

        ldapModClass.mod_op = LDAP_MOD_ADD;
        ldapModClass.mod_type = L"objectClass";
        ldapModClass.mod_vals.modv_strvals = rgModClassVals;

        rgModCNVals[0] = L"Dfs-Configuration";
        rgModCNVals[1] = NULL;

        ldapModCN.mod_op = LDAP_MOD_ADD;
        ldapModCN.mod_type = L"cn";
        ldapModCN.mod_vals.modv_strvals = rgModCNVals;

        rgldapMods[0] = &ldapModClass;
        rgldapMods[1] = &ldapModCN;
        rgldapMods[2] = NULL;

        dwErr = ldap_add_sW(
                    pldap,
                    wszConfigurationDN,
                    rgldapMods);

#if DBG
        if (DfsDebug)
            DbgPrint("ldap_add_sW(1) returned 0x%x\n", dwErr);
#endif

    }

    if (dwErr != LDAP_SUCCESS) {

        dwErr = LdapMapErrorToWin32(dwErr);
        goto Cleanup;

    }

    //
    // Check to see if we are joining an FTDfs or creating a new one.
    //

    Size =  wcslen(L"CN=") +
               wcslen(wszFtDfsName) +
                   wcslen(L",") +
                       wcslen(wszConfigurationDN);
    if (Size > MAX_PATH) {
        dwErr = ERROR_DS_NAME_TOO_LONG;
        goto Cleanup;
    }
    wszDfsConfigDN = malloc((Size+1) * sizeof(WCHAR));
    if (wszDfsConfigDN == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    wcscpy(wszDfsConfigDN,L"CN=");
    wcscat(wszDfsConfigDN,wszFtDfsName);
    wcscat(wszDfsConfigDN,L",");
    wcscat(wszDfsConfigDN,wszConfigurationDN);

    rgAttrs[0] = L"remoteServerName";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

#if DBG
    if (DfsDebug)
        DbgPrint("ldap_search_sW(2) returned 0x%x\n", dwErr);
#endif

    if (dwErr == LDAP_NO_SUCH_OBJECT) {

        GUID idPkt;
        DWORD dwPktVersion = 1;

        //
        // We are creating a new FTDfs, create a container to hold the Dfs
        // configuration for it.
        //

        fNewFTDfs = TRUE;

        //
        // Generate the class and CN attributes
        //

        rgModClassVals[0] = L"ftDfs";
        rgModClassVals[1] = NULL;

        ldapModClass.mod_op = LDAP_MOD_ADD;
        ldapModClass.mod_type = L"objectClass";
        ldapModClass.mod_vals.modv_strvals = rgModClassVals;

        rgModCNVals[0] = wszFtDfsName;
        rgModCNVals[1] = NULL;

        ldapModCN.mod_op = LDAP_MOD_ADD;
        ldapModCN.mod_type = L"cn";
        ldapModCN.mod_vals.modv_strvals = rgModCNVals;

        //
        // Generate the null PKT attribute
        //

        ldapPkt.bv_len = sizeof(DWORD);
        ldapPkt.bv_val = (PCHAR) &dwPktVersion;

        rgModPktVals[0] = &ldapPkt;
        rgModPktVals[1] = NULL;

        ldapModPkt.mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
        ldapModPkt.mod_type = L"pKT";
        ldapModPkt.mod_vals.modv_bvals = rgModPktVals;

        //
        // Generate a PKT Guid attribute
        //

        UuidCreate( &idPkt );

        ldapPktGuid.bv_len = sizeof(GUID);
        ldapPktGuid.bv_val = (PCHAR) &idPkt;

        rgModPktGuidVals[0] = &ldapPktGuid;
        rgModPktGuidVals[1] = NULL;

        ldapModPktGuid.mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
        ldapModPktGuid.mod_type = L"pKTGuid";
        ldapModPktGuid.mod_vals.modv_bvals = rgModPktGuidVals;

        //
        // Generate a Remote-Server-Name attribute
        //

        rgModServerVals[0] = L"*";
        rgModServerVals[1] = NULL;

        ldapModServer.mod_op = LDAP_MOD_ADD;
        ldapModServer.mod_type = L"remoteServerName";
        ldapModServer.mod_vals.modv_strvals = rgModServerVals;

        //
        // Assemble all the LDAPMod structures
        //

        rgldapMods[0] = &ldapModClass;
        rgldapMods[1] = &ldapModCN;
        rgldapMods[2] = &ldapModPkt;
        rgldapMods[3] = &ldapModPktGuid;
        rgldapMods[4] = &ldapModServer;
        rgldapMods[5] = NULL;

        //
        // Create the Dfs metadata object.
        //

        dwErr = ldap_add_sW( pldap, wszDfsConfigDN, rgldapMods );

#if DBG
        if (DfsDebug)
            DbgPrint("ldap_add_sW(2) returned 0x%x\n", dwErr);
#endif


    }

    if (dwErr != LDAP_SUCCESS) {
        dwErr = LdapMapErrorToWin32(dwErr);
        goto Cleanup;
    }

    //
    // Create a machine ACE
    //

    dwErr = DfsAddMachineAce(
                pldap,
                wszDcName,
                wszDfsConfigDN,
                wszServerName);

    if (dwErr != ERROR_SUCCESS) 
    {
        goto Cleanup;
    }
    //
    // Tell the server to add itself to the object
    //

    dwErr = DfspBindToServer( wszServerName, &netdfs_bhandle );

#if DBG
    if (DfsDebug)
        DbgPrint("DfspBindToServer returned %d\n", dwErr);
#endif

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsAddFtRoot(
                        wszServerName,
                        wszDcName,
                        wszRootShare,
                        wszFtDfsName,
                        (wszComment != NULL) ? wszComment : L"",
                        wszDfsConfigDN,
                        fNewFTDfs,
                        dwFlags,
                        &RootList);

#if DBG
            if (DfsDebug)
                DbgPrint("NetrDfsAddFtRoot returned %d\n", dwErr);
#endif

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }

#if DBG
    if (DfsDebug) {
        if (dwErr == ERROR_SUCCESS && RootList != NULL) {
            ULONG n;

            DbgPrint("cEntries=%d\n", RootList->cEntries);
            for (n = 0; n < RootList->cEntries; n++)
                DbgPrint("[%d]%ws\n", n, RootList->Entry[n].ServerShare);
        }
    }
#endif

    if (dwErr == ERROR_SUCCESS && RootList != NULL) {
        ULONG n;

        for (n = 0; n < RootList->cEntries; n++) {
            DfspNotifyFtRoot(
                RootList->Entry[n].ServerShare,
                wszDcName);
        }
        NetApiBufferFree(RootList);
    }

    if (dwErr == ERROR_ALREADY_EXISTS) {
        goto Cleanup;
    } else if (dwErr != ERROR_SUCCESS) {
        goto TearDown;
    }

    //
    // Have the DC flush the Ft table
    //

    DfspFlushFtTable(
        wszDcName,
        wszFtDfsName);

    //
    // Flush the local Pkt
    //

    DfspFlushPkt(NULL);

    goto Cleanup;

TearDown:

    //
    // At this point we have added an ACE to the acl list to allow
    // this machine to write the Dfs BLOB.  But the add failed, so we
    // need to remove the ACE we set earlier.  If this fails we continue
    // on anyway.
    //
    dwErr2 = DfsRemoveMachineAce(
                pldap,
                wszDcName,
                wszDfsConfigDN,
                wszServerName);

    rgAttrs[0] = L"remoteServerName";
    rgAttrs[1] = NULL;

    if (pMsg != NULL) {
        ldap_msgfree(pMsg);
        pMsg = NULL;
    }

    dwErr2 = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr2 != LDAP_SUCCESS) {
        dwErr2 = LdapMapErrorToWin32(dwErr2);
        goto Cleanup;
    }

    dwErr2 = ERROR_SUCCESS;

    pmsgServers = ldap_first_entry(pldap, pMsg);

    if (pmsgServers != NULL) {

        rgServers = ldap_get_valuesW(
                        pldap,
                        pmsgServers,
                        L"remoteServerName");

        if (rgServers != NULL) {
            cServers = ldap_count_valuesW( rgServers );
            if (cServers == 1) {
                //
                // Delete the Dfs metadata object.
                //
                ULONG RetryCount = MAX_DFS_LDAP_RETRY;

                do
                {
                    dwErr2 = ldap_delete_sW( pldap, wszDfsConfigDN);
#if DBG
                    if (dwErr2 == LDAP_BUSY)
                    {
                        if (DfsDebug)
                            DbgPrint("delete object returning %d\n", dwErr2);
                    }
#endif
                } while ( RetryCount-- && (dwErr2 == LDAP_BUSY) );
            }
            ldap_value_freeW( rgServers );
        } else {
            dwErr2 = ERROR_OUTOFMEMORY;
        }
    } else {
        dwErr2 = ERROR_OUTOFMEMORY;
    }

    if (dwErr2 != ERROR_SUCCESS) {
        goto Cleanup;
    }

    ldap_msgfree(pMsg);
    pMsg = NULL;

Cleanup:

    if (pMsg != NULL)
        ldap_msgfree(pMsg);

    if (pldap != NULL)
        ldap_unbind( pldap );

    if (wszConfigurationDN != NULL)
        free(wszConfigurationDN);

    if (wszDfsConfigDN != NULL)
        free(wszDfsConfigDN);

#if DBG
    if (DfsDebug)
        DbgPrint("DfspCreateFtDfs returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspTearDownFtDfs
//
//  Synopsis:   Updates/deletes the Ds object representing the FtDfs
//
//  Arguments:  wszServerName - Name of server we're removing
//              wszDcName - DC to use
//              wszRootShare - Root share
//              wszFtDfsName - Name of FtDfs we are modifying
//              dwFlags - 0
//
//  Returns:    NTSTATUS of the call (STATUS_SUCCESS or error)
//
//-----------------------------------------------------------------------------

DWORD
DfspTearDownFtDfs(
    IN LPWSTR wszServerName,
    IN LPWSTR wszDcName,
    IN LPWSTR wszRootShare,
    IN LPWSTR wszFtDfsName,
    IN DWORD  dwFlags)
{
    DWORD dwErr = ERROR_SUCCESS;

    LPWSTR wszDfsConfigDN = NULL;
    LPWSTR wszConfigurationDN = NULL;
    PDFSM_ROOT_LIST RootList = NULL;

    LDAP *pldap = NULL;
    PLDAPMessage pMsg = NULL;

    LDAPModW ldapModServer;
    LPWSTR rgAttrs[5];
    PLDAPModW rgldapMods[6];

    LDAPMessage *pmsgServers;
    PWCHAR *rgServers;
    DWORD cServers;
    ULONG Size;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspTearDownFtDfs(%ws,%ws,%ws,%ws,%d)\n",
                    wszServerName,
                    wszDcName,
                    wszRootShare,
                    wszFtDfsName,
                    dwFlags);
#endif

    dwErr = DfspLdapOpen(
                wszDcName,
                &pldap,
                &wszConfigurationDN);

    if (dwErr != ERROR_SUCCESS) {

        goto Cleanup;

    }

    if ((dwFlags & DFS_FORCE_REMOVE) != 0) {

        dwErr = DfspBindToServer(wszDcName, &netdfs_bhandle);

    } else {

        dwErr = DfspBindToServer(wszServerName, &netdfs_bhandle);

    }

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsRemoveFtRoot(
                        wszServerName,
                        wszDcName,
                        wszRootShare,
                        wszFtDfsName,
                        dwFlags,
                        &RootList);


#if DBG
            if (DfsDebug)
                DbgPrint("NetrDfsRemoveFtRoot returned %d\n", dwErr);
#endif

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }


#if DBG
    if (DfsDebug) {
        if (dwErr == ERROR_SUCCESS && RootList != NULL) {
            ULONG n;

            DbgPrint("cEntries=%d\n", RootList->cEntries);
            for (n = 0; n < RootList->cEntries; n++)
                DbgPrint("[%d]%ws\n", n, RootList->Entry[n].ServerShare);
        }
    }
#endif


    if (dwErr == ERROR_SUCCESS && RootList != NULL) {

        ULONG n;

        for (n = 0; n < RootList->cEntries; n++) {

            DfspNotifyFtRoot(
                RootList->Entry[n].ServerShare,
                wszDcName);

        }

        NetApiBufferFree(RootList);

    }


    if (dwErr != ERROR_SUCCESS) {

        goto Cleanup;

    }



    //
    // Build the name of the object representing the FtDfs
    //

    Size =  wcslen(L"CN=") +
               wcslen(wszFtDfsName) +
                   wcslen(L",") + 
                       wcslen(wszConfigurationDN);
    if (Size > MAX_PATH) {
        dwErr = ERROR_DS_NAME_TOO_LONG;
        goto Cleanup;
    }
    wszDfsConfigDN = malloc((Size+1) * sizeof(WCHAR));
    if (wszDfsConfigDN == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    wcscpy(wszDfsConfigDN,L"CN=");
    wcscat(wszDfsConfigDN,wszFtDfsName);
    wcscat(wszDfsConfigDN,L",");
    wcscat(wszDfsConfigDN,wszConfigurationDN);

    //
    // Remove machine ACE
    //

    dwErr = DfsRemoveMachineAce(
                pldap,
                wszDcName,
                wszDfsConfigDN,
                wszServerName);

    //
    // If this was the last root, remove DS obj representing this FtDfs
    //

    rgAttrs[0] = L"remoteServerName";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_sW(
                pldap,
                wszDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr != LDAP_SUCCESS) {

        dwErr = LdapMapErrorToWin32(dwErr);

        goto Cleanup;

    }

    dwErr = ERROR_SUCCESS;

    pmsgServers = ldap_first_entry(pldap, pMsg);

    if (pmsgServers != NULL) {

        rgServers = ldap_get_valuesW(
                        pldap,
                        pmsgServers,
                        L"remoteServerName");

        if (rgServers != NULL) {

            cServers = ldap_count_valuesW( rgServers );

            if (cServers == 1) {
                //
                // Delete the Dfs metadata object.
                //
                ULONG RetryCount = MAX_DFS_LDAP_RETRY;

                do
                {
                    dwErr = ldap_delete_sW( pldap, wszDfsConfigDN);
#if DBG
                    if (dwErr == LDAP_BUSY)
                    {
                        if (DfsDebug)
                            DbgPrint("delete object returning %d\n", dwErr);
                    }
#endif
                } while ( RetryCount-- && (dwErr == LDAP_BUSY) );

                if (dwErr != LDAP_SUCCESS) {
                    dwErr = LdapMapErrorToWin32(dwErr);

                } else {
                    dwErr = ERROR_SUCCESS;
                }
            }

            ldap_value_freeW( rgServers );

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    ldap_msgfree( pMsg );
    pMsg = NULL;

    if (dwErr != ERROR_SUCCESS) {

        goto Cleanup;

    }

    //
    // Have the DC flush the Ft table
    //

    DfspFlushFtTable(
        wszDcName,
        wszFtDfsName);

    //
    // Flush the local Pkt
    //

    DfspFlushPkt(NULL);

Cleanup:

#if DBG
    if (DfsDebug)
        DbgPrint("DfspTearDownFtDfs at Cleanup:\n");
#endif

    if (pMsg != NULL)
        ldap_msgfree( pMsg );

    if (pldap != NULL)
        ldap_unbind( pldap );

    if (wszConfigurationDN != NULL)
        free(wszConfigurationDN);

    if (wszDfsConfigDN != NULL)
        free(wszDfsConfigDN);

#if DBG
    if (DfsDebug)
        DbgPrint("DfspTearDownFtDfs returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspFlushFtTable
//
//  Synopsis:   Goes to a DC and flushes an entry from its FtDfs name cache
//
//  Arguments:  wszDcName - Name of DC
//              wszFtDfsName - The FtDfs name to flush
//
//  Returns:    NTSTATUS of the call (STATUS_SUCCESS or error)
//
//-----------------------------------------------------------------------------

VOID
DfspFlushFtTable(
    LPWSTR wszDcName,
    LPWSTR wszFtDfsName)
{
    DWORD dwErr;

    //
    // We should have a valid ServerName. Lets try to bind to it,
    // and call the server.
    //

    dwErr = DfspBindToServer( wszDcName, &netdfs_bhandle );

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsFlushFtTable(
                        wszDcName,
                        wszFtDfsName);

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspSetDomainToDc
//
//  Synopsis:   Sets a DC in the special table to 'active'.
//
//  Arguments:  DomainName -- Domain of DC to set active
//              DcName -- Dc to make active
//
//  Returns:    NTSTATUS of the call (STATUS_SUCCESS or error)
//
//-----------------------------------------------------------------------------
NTSTATUS
DfspSetDomainToDc(
    LPWSTR DomainName,
    LPWSTR DcName)
{
    PDFS_SPECIAL_SET_DC_INPUT_ARG arg = NULL;
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    PDFS_IS_VALID_PREFIX_ARG pPrefixArg = NULL;
    PCHAR cp;
    ULONG Size;

    if (DomainName == NULL || DcName == NULL) {

        NtStatus = STATUS_INVALID_PARAMETER;
        goto exit_with_status;

    }

    Size = sizeof(DFS_SPECIAL_SET_DC_INPUT_ARG) +
                wcslen(DomainName) * sizeof(WCHAR) +
                    wcslen(DcName) * sizeof(WCHAR);

    arg = (PDFS_SPECIAL_SET_DC_INPUT_ARG) malloc(Size);

    if (arg == NULL) {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_with_status;

    }

    RtlZeroMemory(arg, Size);

    arg->SpecialName.Length = wcslen(DomainName) * sizeof(WCHAR);
    arg->SpecialName.MaximumLength = arg->SpecialName.Length;

    arg->DcName.Length = wcslen(DcName) * sizeof(WCHAR);
    arg->DcName.MaximumLength = arg->DcName.Length;

    cp = (PCHAR)arg + sizeof(DFS_SPECIAL_SET_DC_INPUT_ARG);

    arg->SpecialName.Buffer = (WCHAR *)cp;
    RtlCopyMemory(cp, DomainName, arg->SpecialName.Length);
    cp += arg->SpecialName.Length;

    arg->DcName.Buffer = (WCHAR *)cp;
    RtlCopyMemory(cp, DcName, arg->DcName.Length);

    POINTER_TO_OFFSET(arg->SpecialName.Buffer, arg);
    POINTER_TO_OFFSET(arg->DcName.Buffer, arg);

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtFsControlFile(
                       DriverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_SPECIAL_SET_DC,
                       arg,
                       Size,
                       NULL,
                       0);

        NtClose(DriverHandle);

    }

exit_with_status:

    if (arg != NULL) {

        free(arg);

    }

    return NtStatus;

}

//+----------------------------------------------------------------------------
//
//  Function:   I_NetDfsIsThisADomainName
//
//  Synopsis:   Checks the special name table to see if the
//              name matches a domain name.
//
//  Arguments:  [wszName] -- Name to check
//
//  Returns:    [ERROR_SUCCESS] -- Name is indeed a domain name.
//
//              [ERROR_FILE_NOT_FOUND] -- Name is not a domain name
//
//-----------------------------------------------------------------------------

DWORD
I_NetDfsIsThisADomainName(
    LPWSTR wszName)
{
    DWORD dwErr;
    PWCHAR DCList = NULL;

    dwErr = DfspIsThisADomainName(
                wszName,
                &DCList);

    if (DCList != NULL) {

        free(DCList);

    }

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspNotifyFtRoot
//
//  Synopsis:   Rpc's to a supposed FtDfs root
//              and tells it a DC to reinit from.
//
//  Arguments:  wszServerShare - The server to go to, in a form of \\server\share
//              wszDcName - DC to use
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfspNotifyFtRoot(
    LPWSTR wszServerShare,
    LPWSTR wszDcName)
{
    DWORD dwErr;
    ULONG i;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspNotifyFtRoot(%ws,%ws)\n",
                wszServerShare,
                wszDcName);
#endif

    if (wszServerShare == NULL || wszServerShare[1] != L'\\') {

        return;

    }

    for (i = 2; wszServerShare[i] != UNICODE_NULL && wszServerShare[i] != L'\\'; i++) {

        NOTHING;

    }

    if (wszServerShare[i] == L'\\') {

        wszServerShare[i] = UNICODE_NULL;
        //
        // We should have a valid ServerName. Lets try to bind to it,
        // and call the server.
        //

        dwErr = DfspBindToServer( &wszServerShare[2], &netdfs_bhandle );

        if (dwErr == NERR_Success) {

            RpcTryExcept {

                dwErr = NetrDfsSetDcAddress(
                            &wszServerShare[2],
                            wszDcName,
                            60 * 60 * 2,    // 2 hours
                            (NET_DFS_SETDC_TIMEOUT | NET_DFS_SETDC_INITPKT)
                            );


            } RpcExcept(1) {

                dwErr = RpcExceptionCode();

            } RpcEndExcept;

            DfspFreeBinding( netdfs_bhandle );

        }

        wszServerShare[i] = L'\\';

    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfspNotifyFtRoot dwErr=%d\n", dwErr);
#endif

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspIsThisADomainName
//
//  Synopsis:   Calls the mup to have it check the special name table to see if the
//              name matches a domain name.  Returns a list of DC's in the domain,
//              as a list of strings.  The list is terminated with a double-null.
//
//  Arguments:  [wszName] -- Name to check
//              [ppList]  -- Pointer to pointer for results.
//
//  Returns:    [ERROR_SUCCESS] -- Name is indeed a domain name.
//
//              [ERROR_FILE_NOT_FOUND] -- Name is not a domain name
//
//-----------------------------------------------------------------------------

DWORD
DfspIsThisADomainName(
    LPWSTR wszName,
    PWCHAR *ppList)
{
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    HANDLE DriverHandle = NULL;
    DWORD dwErr;
    PCHAR OutBuf = NULL;
    ULONG Size = 0x100;
    ULONG Count = 0;

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                );

    if (!NT_SUCCESS(NtStatus)) {
        return ERROR_FILE_NOT_FOUND;
    }

Retry:

    OutBuf = malloc(Size);

    if (OutBuf == NULL) {

        NtClose(DriverHandle);
        return ERROR_NOT_ENOUGH_MEMORY;

    }

    NtStatus = NtFsControlFile(
                   DriverHandle,
                   NULL,       // Event,
                   NULL,       // ApcRoutine,
                   NULL,       // ApcContext,
                   &IoStatusBlock,
                   FSCTL_DFS_GET_SPC_TABLE,
                   wszName,
                   (wcslen(wszName) + 1) * sizeof(WCHAR),
                   OutBuf,
                   Size
               );

    if (NtStatus == STATUS_SUCCESS) {

        dwErr = ERROR_SUCCESS;

    } else if (NtStatus == STATUS_BUFFER_OVERFLOW && ++Count < 5) {

        Size = *((ULONG *)OutBuf);
        free(OutBuf);
        goto Retry;
    
    } else {

        dwErr = ERROR_FILE_NOT_FOUND;

    }

    NtClose(DriverHandle);

    *ppList = (WCHAR *)OutBuf;

    return dwErr;
}

DWORD
DfspLdapOpen(
    LPWSTR wszDcName,
    LDAP **ppldap,
    LPWSTR *pwszObjectName)
{
    DWORD dwErr;
    DWORD i;
    ULONG Size;
    ULONG Len;

    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    PLDAPMessage pMsg = NULL;

    LDAP *pldap = NULL;

    LPWSTR wszConfigurationDN = NULL;

    LPWSTR rgAttrs[5];

    if (wszDcName == NULL ||
        wcslen(wszDcName) == 0 ||
        ppldap == NULL ||
        pwszObjectName == NULL
    ) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfspLdapOpen(%ws)\n", wszDcName);
#endif
    pldap = ldap_init(wszDcName, LDAP_PORT);

    if (pldap == NULL) {

#if DBG
        if (DfsDebug)
            DbgPrint("DfspLdapOpen:ldap_init failed\n");
#endif
        dwErr = ERROR_INVALID_NAME;
        goto Cleanup;

    }

    dwErr = ldap_set_option(pldap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
	    
    if (dwErr != LDAP_SUCCESS) {
	pldap = NULL;
	goto Cleanup;
    }

    dwErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_SSPI);

    if (dwErr != LDAP_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint("ldap_bind_s failed with ldap error %d\n", dwErr);
#endif
        pldap = NULL;
        dwErr = LdapMapErrorToWin32(dwErr);
        goto Cleanup;
    }

    //
    // Get attribute "defaultNameContext" containing name of entry we'll be
    // using for our DN
    //

    rgAttrs[0] = L"defaultnamingContext";
    rgAttrs[1] = NULL;

    dwErr = ldap_search_s(
                pldap,
                L"",
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    if (dwErr == LDAP_SUCCESS) {

        PLDAPMessage pEntry = NULL;
        PWCHAR *rgszNamingContexts = NULL;
        DWORD i, cNamingContexts;

        dwErr = ERROR_SUCCESS;

        if ((pEntry = ldap_first_entry(pldap, pMsg)) != NULL &&
                (rgszNamingContexts = ldap_get_values(pldap, pEntry, rgAttrs[0])) != NULL &&
                    (cNamingContexts = ldap_count_values(rgszNamingContexts)) > 0) {

            wszConfigurationDN = malloc((wcslen(rgszNamingContexts[0]) + 1) * sizeof(WCHAR));
            if (wszConfigurationDN != NULL)
                wcscpy( wszConfigurationDN, rgszNamingContexts[0]);
            else
                dwErr = ERROR_OUTOFMEMORY;
        } else {
            dwErr = ERROR_UNEXP_NET_ERR;
        }

        if (rgszNamingContexts != NULL)
            ldap_value_free( rgszNamingContexts );

    } else {

        dwErr = LdapMapErrorToWin32(dwErr);

    }

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint("Unable to find Configuration naming context\n");
#endif
        goto Cleanup;
    }

    //
    // Create string with full object name
    //

    Size = wcslen(DfsConfigContainer) * sizeof(WCHAR) +
                sizeof(WCHAR) +
                    wcslen(wszConfigurationDN) * sizeof(WCHAR) +
                        sizeof(WCHAR);

    *pwszObjectName = malloc(Size);

    if (*pwszObjectName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
     }

    wcscpy(*pwszObjectName,DfsConfigContainer);
    wcscat(*pwszObjectName,L",");
    wcscat(*pwszObjectName,wszConfigurationDN);

#if DBG
    if (DfsDebug)
        DbgPrint("DfsLdapOpen:object name=[%ws]\n", *pwszObjectName);
#endif

Cleanup:

    if (pDCInfo != NULL)
        NetApiBufferFree( pDCInfo );

    if (dwErr != ERROR_SUCCESS) {
        ldap_unbind( pldap );
        pldap = NULL;
    }

    if (wszConfigurationDN != NULL)
        free(wszConfigurationDN);

    if (pMsg != NULL)
        ldap_msgfree(pMsg);

    *ppldap = pldap;

#if DBG
    if (DfsDebug)
        DbgPrint("DfsLdapOpen:returning %d\n", dwErr);
#endif
    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspIsInvalidName, local
//
//  Synopsis:   Sees if a DomDfs name is Invalid
//
//  Arguments:  [DomDfsName] -- Name test.
//
//  Returns:    TRUE if invalid, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOLEAN
DfspIsInvalidName(
    LPWSTR ShareName)
{
    ULONG i;

    for (i = 0; InvalidNames[i] != NULL; i++) {

        if (_wcsicmp(InvalidNames[i], ShareName) == 0) {
            return TRUE;
        }

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\ccfapi.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   ccfapi.cpp

Abstract:

   Implementation of CCcfApiApp, the MFC application object for CCFAPI32.DLL.

Author:

   Jeff Parham (jeffparh) 13-Dec-1995

Revision History:

--*/

#include "stdafx.h"
#include <lmerr.h>

#include "ccfapi.h"
#include "source.h"
#include "imagelst.h"
#include "remdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCcfApiApp theApp;   // The one and only CCcfApiApp object


BEGIN_MESSAGE_MAP(CCcfApiApp, CWinApp)
   //{{AFX_MSG_MAP(CCcfApiApp)
      // NOTE - the ClassWizard will add and remove mapping macros here.
      //    DO NOT EDIT what you see in these blocks of generated code!
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CCcfApiApp::CCcfApiApp()

/*++

Routine Description:

   Constructor for CCF API application.

Arguments:

   None.

Return Values:

   None.

--*/

{
   AFX_MANAGE_STATE( AfxGetStaticModuleState() );

   m_LastError    = 0;
   m_LastLlsError = 0;

   LPTSTR pszHelpFileName = m_strHelpFileName.GetBuffer( MAX_PATH );

   if ( NULL != pszHelpFileName )
   {
      BOOL ok = GetSystemDirectory( pszHelpFileName, MAX_PATH );
      m_strHelpFileName.ReleaseBuffer();

      if ( ok )
      {
         m_strHelpFileName += TEXT( "\\" );
      }

      m_strHelpFileName += TEXT( "ccfapi.hlp" );
   }
}


void CCcfApiApp::DisplayLastError()

/*++

Routine Description:

    Displays a message corresponding to the last error encountered.

Arguments:

    None.

Return Values:

    None.

--*/

{
   CString  strLastError;
   CString  strErrorCaption;

   strLastError = GetLastErrorString();

   AfxMessageBox( strLastError, MB_ICONSTOP | MB_OK );
}


CString CCcfApiApp::GetLastErrorString()

/*++

Routine Description:

    Retrieves string for last error.

    (Routine stolen from winsadmn...).

    (And that routine stolen from LlsMgr...).

Arguments:

    None.

Return Values:

    CString.

--*/

{
   CString        strLastError;
   DWORD          nId = m_LastError;
   const int      cchLastErrorSize = 512;
   LPTSTR         pszLastError;
   DWORD          cchLastError;

   if (((long)nId == RPC_S_CALL_FAILED) || 
       ((long)nId == RPC_NT_SS_CONTEXT_MISMATCH))
   {
      strLastError.LoadString(IDS_ERROR_DROPPED_LINK);        
   }
   else if (((long)nId == RPC_S_SERVER_UNAVAILABLE) || 
            ((long)nId == RPC_NT_SERVER_UNAVAILABLE))
   {
      strLastError.LoadString(IDS_ERROR_NO_RPC_SERVER);
   }
   else if ((long)nId == STATUS_INVALID_LEVEL)
   {
      strLastError.LoadString(IDS_ERROR_DOWNLEVEL_SERVER);
   }
   else if (((long)nId == ERROR_ACCESS_DENIED) ||
            ((long)nId == STATUS_ACCESS_DENIED))
   {
      strLastError.LoadString(IDS_ERROR_ACCESS_DENIED);
   }
   else if ((long)nId == STATUS_ACCOUNT_EXPIRED)
   {
      strLastError.LoadString(IDS_ERROR_CERTIFICATE_EXPIRED);
   }
   else
   {
      HINSTANCE hinstDll = NULL;

      if ((nId >= NERR_BASE) && (nId <= MAX_NERR))
      {
         hinstDll = ::LoadLibrary( _T( "netmsg.dll" ) );
      }
      else if (nId >= 0x4000000)
      {
         hinstDll = ::LoadLibrary( _T( "ntdll.dll" ) );
      }

      cchLastError = 0;
      pszLastError = strLastError.GetBuffer( cchLastErrorSize );

      if ( NULL != pszLastError )
      {
         DWORD dwFlags =   FORMAT_MESSAGE_IGNORE_INSERTS
                         | FORMAT_MESSAGE_MAX_WIDTH_MASK
                         | ( hinstDll ? FORMAT_MESSAGE_FROM_HMODULE
                                      : FORMAT_MESSAGE_FROM_SYSTEM );

         cchLastError = ::FormatMessage( dwFlags,
                                         hinstDll,
                                         nId,
                                         0,
                                         pszLastError,
                                         cchLastErrorSize,
                                         NULL );

         strLastError.ReleaseBuffer();
      }

      if ( hinstDll )
      {
         ::FreeLibrary( hinstDll );
      }

      if ( 0 == cchLastError )
      {
         strLastError.LoadString( IDS_ERROR_UNSUCCESSFUL );
      }
   }

   return strLastError;
}

//////////////////////////////////////////////////////////////////////////////
//  CCF API  //
///////////////

DWORD CCcfApiApp::CertificateEnter( HWND hWndParent, LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags, LPCSTR pszSourceToUse )

/*++

Routine Description:

   Display a dialog allowing the user to enter a license certificate
   into the system.

Arguments:

   hWndParent (HWND)
      HWND to the client's main window, for use as the parent window to any
      opened dialogs.  May be NULL.
   pszServerName (LPCSTR)
      Name of the server for which licenses are to be installed.  Note that
      this may not be the same as the server on which licenses are actually
      installed, as, for example, per seat licenses are always installed on
      the enterprise server.  A NULL value indicates the local server.
   pszProductName (LPCSTR)
      Product for which licenses are to be installed.  A NULL value indicates
      that the user should be allowed to choose.
   pszVendor (LPCSTR)
      Name of the vendor of the product.  This value should be NULL if
      pszProductName is NULL, and should be non-NULL if pszProductName is
      non-NULL.
   dwFlags (DWORD)
      A bitfield containing one or more of the following:
         CCF_ENTER_FLAG_PER_SEAT_ONLY
            Allow the user to enter only per seat licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SERVER_ONLY.
         CCF_ENTER_FLAG_PER_SERVER_ONLY
            Allow the user to enter only per server licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SEAT_ONLY.
   pszSourceToUse (LPCSTR)
      Name of the secure certificate source to use to install the certificate,
      e.g., "Paper".  A NULL value indicates that the user should be allowed
      to choose.

Return Value:

   ERROR_SUCCESS     (A certificate was successfully entered into the system.)
   ERROR_CANCELLED   (The user cancelled without installing a certificate.)
   other Win error

--*/

{
   CCertSourceSelectDlg    srcDlg( CWnd::FromHandle( hWndParent ) );
   LPCSTR                  pszNetServerName = NULL;
   CHAR                    szNetServerName[ 2 + MAX_PATH ] = "\\\\";

   // make sure server name, if specified, is in the form \\server
   if ( NULL != pszServerName ) 
   {
      if ( ( pszServerName[0] != '\\' ) || ( pszServerName[1] != '\\' ) )
      {
         // is not prefixed with backslashes
         lstrcpynA( szNetServerName + 2, pszServerName, sizeof( szNetServerName ) - 3 );
         pszNetServerName = szNetServerName;
      }
      else
      {
         // is prefixed with backslashes
         pszNetServerName = pszServerName;
      }
   }

   return srcDlg.CertificateEnter( hWndParent, pszNetServerName, pszProductName, pszVendor, dwFlags, pszSourceToUse );
}


DWORD CCcfApiApp::CertificateRemove( HWND hWndParent, LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags, LPCSTR pszSourceToUse )

/*++

Routine Description:

   Display a dialog allowing the user to remove one or more license
   certificates from the system.

Arguments:

   hWndParent (HWND)
      HWND to the client's main window, for use as the parent window to any
      opened dialogs.  May be NULL.
   pszServerName (LPCSTR)
      Name of the server on which licenses are to be removed.  A NULL value
      indicates the local server.
   pszProductName (LPCSTR)
      Product for which licenses are to be removed.  A NULL value indicates
      that the user should be allowed to remove licenses from any product.
   pszVendor (LPCSTR)
      Name of the vendor of the product.  This value should be NULL if
      pszProductName is NULL, and should be non-NULL if pszProductName is
      non-NULL.
   dwFlags (DWORD)
      Certificate removal options.  As of this writing, no flags are
      supported.
   pszSourceToUse (LPCSTR)
      Name of the secure certificate source by which licenses are to be
      removed, e.g., "Paper".  A NULL value indicates that the user should
      be allowed to remove licenses that were installed with any source.

Return Value:

   ERROR_SUCCESS
   Win error

--*/

{
   CCertRemoveSelectDlg    remDlg( CWnd::FromHandle( hWndParent ) );
   LPCSTR                  pszNetServerName = NULL;
   CHAR                    szNetServerName[ 2 + MAX_PATH ] = "\\\\";

   // make sure server name, if specified, is in the form \\server
   if ( NULL != pszServerName ) 
   {
      if ( ( pszServerName[0] != '\\' ) || ( pszServerName[1] != '\\' ) )
      {
         // is not prefixed with backslashes
         lstrcpynA( szNetServerName + 2, pszServerName, sizeof( szNetServerName ) - 3 );
         pszNetServerName = szNetServerName;
      }
      else
      {
         // is prefixed with backslashes
         pszNetServerName = pszServerName;
      }
   }

   return remDlg.CertificateRemove( pszNetServerName, pszProductName, pszVendor, dwFlags, pszSourceToUse );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\imagelst.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    imagelst.h

Abstract:

    Constants for shared image list. 

Author:

    Don Ryan (donryan) 12-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 12-Nov-1995
        Copied from LLSMGR and modified for CCFApi bitmaps.

--*/

#ifndef _IMAGELST_H_
#define _IMAGELST_H_

#define BMPI_RGB_BKGND (RGB(0,255,0))   // green mask...

#define BMPI_CERTIFICATE            0             

#define BMPI_SMALL_SIZE             18  // one bit border...
#define BMPI_LARGE_SIZE             34  // one bit border...

#endif // _IMAGELST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\exports.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   exports.cpp

Abstract:

   Provides APIs to enter and remove license certificates from the system.
   The clientele consists of LICCPA.CPL (the licensing control panel applet)
   and LLSMGR.EXE (License Manager), and it may also be used directly by setup
   programs.

Author:

   Jeff Parham (jeffparh) 13-Dec-1995

Revision History:

--*/

#include "stdafx.h"
#include "ccfapi.h"

#ifdef OBSOLETE
#include "paper.h"
#endif // OBSOLETE
#include "nlicdlg.h"


///////////////////////////////////////////////////////////////////////////////
//  CCF API  //
///////////////

DWORD APIENTRY CCFCertificateEnterUI( HWND hWndParent, LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags, LPCSTR pszSourceToUse )

/*++

Routine Description:

   Display a dialog allowing the user to enter a license certificate
   into the system.

Arguments:

   hWndParent (HWND)
      HWND to the client's main window, for use as the parent window to any
      opened dialogs.  May be NULL.
   pszServerName (LPCSTR)
      Name of the server for which licenses are to be installed.  Note that
      this may not be the same as the server on which licenses are actually
      installed, as, for example, per seat licenses are always installed on
      the enterprise server.  A NULL value indicates the local server.
   pszProductName (LPCSTR)
      Product for which licenses are to be installed.  A NULL value indicates
      that the user should be allowed to choose.
   pszVendor (LPCSTR)
      Name of the vendor of the product.  This value should be NULL if
      pszProductName is NULL, and should be non-NULL if pszProductName is
      non-NULL.
   dwFlags (DWORD)
      A bitfield containing one or more of the following:
         CCF_ENTER_FLAG_PER_SEAT_ONLY
            Allow the user to enter only per seat licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SERVER_ONLY.
         CCF_ENTER_FLAG_PER_SERVER_ONLY
            Allow the user to enter only per server licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SEAT_ONLY.
   pszSourceToUse (LPCSTR)
      Name of the secure certificate source to use to install the certificate,
      e.g., "Paper".  A NULL value indicates that the user should be allowed
      to choose.

Return Value:

   ERROR_SUCCESS     (A certificate was successfully entered into the system.)
   ERROR_CANCELLED   (The user cancelled without installing a certificate.)
   other Win error

--*/

{
   AFX_MANAGE_STATE( AfxGetStaticModuleState() );

   DWORD    dwError;

   dwError = theApp.CertificateEnter( hWndParent, pszServerName, pszProductName, pszVendor, dwFlags, pszSourceToUse );

   return dwError;
}


//////////////////////////////////////////////////////////////////////////////
DWORD APIENTRY CCFCertificateRemoveUI( HWND hWndParent, LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags, LPCSTR pszSourceToUse )

/*++

Routine Description:

   Display a dialog allowing the user to remove one or more license
   certificates from the system.

Arguments:

   hWndParent (HWND)
      HWND to the client's main window, for use as the parent window to any
      opened dialogs.  May be NULL.
   pszServerName (LPCSTR)
      Name of the server on which licenses are to be removed.  A NULL value
      indicates the local server.
   pszProductName (LPCSTR)
      Product for which licenses are to be removed.  A NULL value indicates
      that the user should be allowed to remove licenses from any product.
   pszVendor (LPCSTR)
      Name of the vendor of the product.  This value should be NULL if
      pszProductName is NULL, and should be non-NULL if pszProductName is
      non-NULL.
   dwFlags (DWORD)
      Certificate removal options.  As of this writing, no flags are
      supported.
   pszSourceToUse (LPCSTR)
      Name of the secure certificate source by which licenses are to be
      removed, e.g., "Paper".  A NULL value indicates that the user should
      be allowed to remove licenses that were installed with any source.

Return Value:

   ERROR_SUCCESS
   Win error

--*/

{
   AFX_MANAGE_STATE( AfxGetStaticModuleState() );

   DWORD    dwError;

   dwError = theApp.CertificateRemove( hWndParent, pszServerName, pszProductName, pszVendor, dwFlags, pszSourceToUse );

   return dwError;
}

///////////////////////////////////////////////////////////////////////////////
//  Certificate Source -- No Certificate  //
////////////////////////////////////////////

DWORD APIENTRY NoCertificateEnter(  HWND     hWnd,
                                    LPCSTR   pszServerName,
                                    LPCSTR   pszProductName,
                                    LPCSTR   pszVendor,
                                    DWORD    dwFlags )

/*++

Routine Description:

   Display a dialog allowing the user to enter a license certificate
   into the system with no certificate (3.51-style).

Arguments:

   hWndParent (HWND)
      HWND to the client's main window, for use as the parent window to any
      opened dialogs.  May be NULL.
   pszServerName (LPCSTR)
      Name of the server for which licenses are to be installed.  Note that
      this may not be the same as the server on which licenses are actually
      installed, as, for example, per seat licenses are always installed on
      the enterprise server.  A NULL value indicates the local server.
   pszProductName (LPCSTR)
      Product for which licenses are to be installed.  A NULL value indicates
      that the user should be allowed to choose.
   pszVendor (LPCSTR)
      Name of the vendor of the product.  This value should be NULL if
      pszProductName is NULL, and should be non-NULL if pszProductName is
      non-NULL.
   dwFlags (DWORD)
      A bitfield containing one or more of the following:
         CCF_ENTER_FLAG_PER_SEAT_ONLY
            Allow the user to enter only per seat licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SERVER_ONLY.
         CCF_ENTER_FLAG_PER_SERVER_ONLY
            Allow the user to enter only per server licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SEAT_ONLY.

Return Value:

   ERROR_SUCCESS     (A certificate was successfully entered into the system.)
   ERROR_CANCELLED   (The user cancelled without installing a certificate.)
   other Win error

--*/

{
   AFX_MANAGE_STATE( AfxGetStaticModuleState() );

   CNewLicenseDialog dlg( CWnd::FromHandle( hWnd ) );
   return dlg.CertificateEnter( pszServerName, pszProductName, pszVendor, dwFlags );
}


//////////////////////////////////////////////////////////////////////////////
DWORD APIENTRY NoCertificateRemove( HWND     hWnd,
                                    LPCSTR   pszServerName,
                                    DWORD    dwFlags,
                                    DWORD    dwLicenseLevel,
                                    LPVOID   pvLicenseInfo )

/*++

Routine Description:

   Remove licenses previously installed via 3.51 or NoCertificateEnter().

Arguments:

   hWndParent (HWND)
      HWND to the client's main window, for use as the parent window to any
      opened dialogs.  May be NULL.
   pszServerName (LPCSTR)
      Name of the server on which licenses are to be removed.  A NULL value
      indicates the local server.
   dwFlags (DWORD)
      Certificate removal options.  As of this writing, no flags are
      supported.
   dwLicenseLevel (DWORD)
      Level of the LLS_LICENSE_INFO_X structure pointed to by pvLicenseInfo.
   pvLicenseInfo (LPVOID)
      Points to a LLS_LICENSE_INFO_X (where X is determined by dwLicenseLevel)
      describing the licenses to be removed.

Return Value:

   ERROR_SUCCESS
   Win error

--*/

{
   AFX_MANAGE_STATE( AfxGetStaticModuleState() );

   DWORD dwError;

   if ( 1 != dwLicenseLevel )
   {
      dwError = ERROR_INVALID_LEVEL;
   }
   else
   {
      CNewLicenseDialog dlg( CWnd::FromHandle( hWnd ) );
      dwError = dlg.CertificateRemove( pszServerName, dwFlags, (PLLS_LICENSE_INFO_1) pvLicenseInfo );
   }

   return dwError;
}

#ifdef OBSOLETE

///////////////////////////////////////////////////////////////////////////////
//  Certificate Source -- Paper Certificate  //
///////////////////////////////////////////////

DWORD APIENTRY PaperCertificateEnter(  HWND     hWnd,
                                       LPCSTR   pszServerName,
                                       LPCSTR   pszProductName,
                                       LPCSTR   pszVendor,
                                       DWORD    dwFlags )

/*++

Routine Description:

   Display a dialog allowing the user to enter a license certificate
   into the system with a paper certificate.

Arguments:

   hWndParent (HWND)
      HWND to the client's main window, for use as the parent window to any
      opened dialogs.  May be NULL.
   pszServerName (LPCSTR)
      Name of the server for which licenses are to be installed.  Note that
      this may not be the same as the server on which licenses are actually
      installed, as, for example, per seat licenses are always installed on
      the enterprise server.  A NULL value indicates the local server.
   pszProductName (LPCSTR)
      Product for which licenses are to be installed.  A NULL value indicates
      that the user should be allowed to choose.
   pszVendor (LPCSTR)
      Name of the vendor of the product.  This value should be NULL if
      pszProductName is NULL, and should be non-NULL if pszProductName is
      non-NULL.
   dwFlags (DWORD)
      A bitfield containing one or more of the following:
         CCF_ENTER_FLAG_PER_SEAT_ONLY
            Allow the user to enter only per seat licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SERVER_ONLY.
         CCF_ENTER_FLAG_PER_SERVER_ONLY
            Allow the user to enter only per server licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SEAT_ONLY.

Return Value:

   ERROR_SUCCESS     (A certificate was successfully entered into the system.)
   ERROR_CANCELLED   (The user cancelled without installing a certificate.)
   other Win error

--*/

{
   AFX_MANAGE_STATE( AfxGetStaticModuleState() );

   DWORD    dwError;

   if ( !!pszProductName != !!pszVendor )
   {
      // they must both be NULL or both have values
      dwError = ERROR_INVALID_PARAMETER;
   }
   else
   {
      CPaperSourceDlg  dlg( CWnd::FromHandle( hWnd ) );
      dwError = dlg.CertificateEnter( pszServerName, pszProductName, pszVendor, dwFlags );
   }

   return dwError;
}


//////////////////////////////////////////////////////////////////////////////
DWORD APIENTRY PaperCertificateRemove( HWND     hWnd,
                                       LPCSTR   pszServerName,
                                       DWORD    dwFlags,
                                       DWORD    dwLicenseLevel,
                                       LPVOID   pvLicenseInfo )

/*++

Routine Description:

   Remove licenses previously installed via PaperCertificateEnter().

Arguments:

   hWndParent (HWND)
      HWND to the client's main window, for use as the parent window to any
      opened dialogs.  May be NULL.
   pszServerName (LPCSTR)
      Name of the server on which licenses are to be removed.  A NULL value
      indicates the local server.
   dwFlags (DWORD)
      Certificate removal options.  As of this writing, no flags are
      supported.
   dwLicenseLevel (DWORD)
      Level of the LLS_LICENSE_INFO_X structure pointed to by pvLicenseInfo.
   pvLicenseInfo (LPVOID)
      Points to a LLS_LICENSE_INFO_X (where X is determined by dwLicenseLevel)
      describing the licenses to be removed.

Return Value:

   ERROR_SUCCESS
   Win error

--*/

{
   AFX_MANAGE_STATE( AfxGetStaticModuleState() );

   DWORD dwError;

   if ( 1 != dwLicenseLevel )
   {
      dwError = ERROR_INVALID_LEVEL;
   }
   else
   {
      CPaperSourceDlg  dlg( CWnd::FromHandle( hWnd ) );
      dwError = dlg.CertificateRemove( pszServerName, dwFlags, (PLLS_LICENSE_INFO_1) pvLicenseInfo );
   }

   return dwError;
}

#endif // OBSOLETE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\ccfapi.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   ccfapi.cpp

Abstract:

   Prototype of CCcfApiApp, the MFC application object for CCFAPI32.DLL.

Author:

   Jeff Parham (jeffparh) 13-Dec-1995

Revision History:

--*/

#ifndef __AFXWIN_H__
   #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"      // main symbols

class CCcfApiApp : public CWinApp
{
public:
   // constructor
   CCcfApiApp();

   // error API
   void        SetLastError( DWORD dwLastError );
   DWORD       GetLastError();

   void        SetLastLlsError( NTSTATUS nt );
   DWORD       GetLastLlsError();
   BOOL        IsConnectionDropped();

   CString     GetLastErrorString();
   void        DisplayLastError();

   // help API
   LPCTSTR     GetHelpFileName();

   // CCF API
   DWORD       CertificateEnter(  HWND hWndParent, LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags, LPCSTR pszSourceToUse );
   DWORD       CertificateRemove( HWND hWndParent, LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags, LPCSTR pszSourceToUse );

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CCcfApiApp)
   //}}AFX_VIRTUAL

   //{{AFX_MSG(CCcfApiApp)
      // NOTE - the ClassWizard will add and remove member functions here.
      //    DO NOT EDIT what you see in these blocks of generated code !
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

private:
   DWORD       m_LastError;
   NTSTATUS    m_LastLlsError;
   CString     m_strHelpFileName;
};

// return the name of the CCF UI help file
inline LPCTSTR CCcfApiApp::GetHelpFileName()
   {  return m_strHelpFileName;  }

// set last general error
inline void CCcfApiApp::SetLastError( DWORD dwLastError )
   {  m_LastError = dwLastError; }

// get last general error
inline DWORD CCcfApiApp::GetLastError()
   {  return m_LastError;  }

// set last license server API error
inline void CCcfApiApp::SetLastLlsError( NTSTATUS nt )
   {  m_LastLlsError = nt; m_LastError = (DWORD) nt;  }

// get last license server API error
inline DWORD CCcfApiApp::GetLastLlsError()
   {  return m_LastLlsError;  }

// did the last license server call fail because of a lack of connectivity?
inline BOOL CCcfApiApp::IsConnectionDropped()
   {  return ( (m_LastLlsError == STATUS_INVALID_HANDLE)      ||
               (m_LastLlsError == RPC_NT_SERVER_UNAVAILABLE)  ||
               (m_LastLlsError == RPC_NT_SS_CONTEXT_MISMATCH) ||
               (m_LastLlsError == RPC_S_SERVER_UNAVAILABLE)   ||
               (m_LastLlsError == RPC_S_CALL_FAILED) );           }

/////////////////////////////////////////////////////////////////////////////

// maximum amount of data to request at a time from license server
#define  LLS_PREFERRED_LENGTH    ((DWORD)-1L)

extern CCcfApiApp theApp;


extern "C"
{
   DWORD APIENTRY NoCertificateEnter(     HWND hWnd, LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags );
   DWORD APIENTRY NoCertificateRemove(    HWND hWnd, LPCSTR pszServerName, DWORD dwFlags, DWORD dwLicenseLevel, LPVOID pvLicenseInfo );
#ifdef OBSOLETE
   DWORD APIENTRY PaperCertificateEnter(  HWND hWnd, LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags );
   DWORD APIENTRY PaperCertificateRemove( HWND hWnd, LPCSTR pszServerName, DWORD dwFlags, DWORD dwLicenseLevel, LPVOID pvLicenseInfo );
#endif // OBSOLETE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\licobj.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    licobj.h

Abstract:

    License object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 12-Nov-1995
        Copied from LLSMGR, converted to handle level 1 licenses,
        removed OLE support.

--*/

#ifndef _LICOBJ_H_
#define _LICOBJ_H_

class CLicense : public CObject
{
   DECLARE_DYNCREATE(CLicense)

public:
   CString     m_strAdmin;
   CString     m_strProduct;
   CString     m_strVendor;
   CString     m_strDescription;
   CString     m_strSource;
   long        m_lQuantity;
   DWORD       m_dwAllowedModes;
   DWORD       m_dwCertificateID;
   DWORD       m_dwPurchaseDate;
   DWORD       m_dwExpirationDate;
   DWORD       m_dwMaxQuantity;
   DWORD       m_adwSecrets[ LLS_NUM_SECRETS ];

   // cache for derived values
   CString     m_strSourceDisplayName;
   CString     m_strAllowedModes;

public:
   CLicense( LPCTSTR     pProduct         = NULL,
             LPCTSTR     pVendor          = NULL,
             LPCTSTR     pAdmin           = NULL,
             DWORD       dwPurchaseDate   = 0,
             long        lQuantity        = 0,
             LPCTSTR     pDescription     = NULL,
             DWORD       dwAllowedModes   = LLS_LICENSE_MODE_ALLOW_PER_SEAT,
             DWORD       dwCertificateID  = 0,
             LPCTSTR     pSource          = TEXT("None"),
             DWORD       dwExpirationDate = 0,
             DWORD       dwMaxQuantity    = 0,
             LPDWORD     pdwSecrets       = NULL );

   CString  GetSourceDisplayName();
   CString  GetAllowedModesString();

   DWORD CreateLicenseInfo( PLLS_LICENSE_INFO_1 pLicInfo );
   void DestroyLicenseInfo( PLLS_LICENSE_INFO_1 pLicInfo );

};

#endif // _LICOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\licobj.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    licobj.cpp

Abstract:

    License object implementation.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 12-Nov-1995
        Copied from LLSMGR, converted to handle level 1 licenses,
        removed OLE support.

--*/

#include "stdafx.h"
#include "ccfapi.h"
#include "licobj.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CLicense, CObject)

CLicense::CLicense( LPCTSTR     pProduct         /* = NULL */,
                    LPCTSTR     pVendor          /* = NULL */,
                    LPCTSTR     pAdmin           /* = NULL */,
                    DWORD       dwPurchaseDate   /* = 0 */,
                    long        lQuantity        /* = 0 */,
                    LPCTSTR     pDescription     /* = NULL */,
                    DWORD       dwAllowedModes   /* = LLS_LICENSE_MODE_ALLOW_PER_SEAT */,
                    DWORD       dwCertificateID  /* = 0 */,
                    LPCTSTR     pSource          /* = TEXT("None") */,
                    DWORD       dwExpirationDate /* = 0 */,
                    DWORD       dwMaxQuantity    /* = 0 */,
                    LPDWORD     pdwSecrets       /* = NULL */ )

/*++

Routine Description:

   Constructor for CLicense object.

Arguments:

   None.

Return Values:

   None.

--*/

{
   ASSERT(pProduct && *pProduct);

   m_strAdmin           = pAdmin;
   m_strVendor          = pVendor;
   m_strProduct         = pProduct;
   m_strDescription     = pDescription;
   m_strSource          = pSource;
   m_lQuantity          = lQuantity;
   m_dwAllowedModes     = dwAllowedModes;
   m_dwCertificateID    = dwCertificateID;
   m_dwPurchaseDate     = dwPurchaseDate;
   m_dwExpirationDate   = dwExpirationDate;
   m_dwMaxQuantity      = dwMaxQuantity;

   if ( NULL == pdwSecrets )
   {
      ZeroMemory( m_adwSecrets, sizeof( m_adwSecrets ) );
   }
   else
   {
      memcpy( m_adwSecrets, pdwSecrets, sizeof( m_adwSecrets ) );
   }

   m_strSourceDisplayName  = TEXT("");
   m_strAllowedModes       = TEXT("");
}


CString CLicense::GetSourceDisplayName()

/*++

Routine Description:

   Retrieve the display name for the certificate source that was used to
   install these licenses.  Note that if the source that was used is not
   installed locally, the display name is not retrievable, and the source
   name will be returned instead.

Arguments:

   None.

Return Values:

   CString.

--*/

{
   if ( m_strSourceDisplayName.IsEmpty() )
   {
      if ( !m_strSource.CompareNoCase( TEXT( "None" ) ) )
      {
         m_strSourceDisplayName.LoadString( IDS_SOURCE_NONE );
      }
      else
      {
         LONG     lError;
         CString  strKeyName =   TEXT( "Software\\LSAPI\\Microsoft\\CertificateSources\\" )
                               + m_strSource;
         HKEY     hKeySource;

         lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, strKeyName, 0, KEY_READ, &hKeySource );
   
         if ( ERROR_SUCCESS == lError )
         {
            const DWORD cchSourceDisplayName = 80;
            DWORD       cbSourceDisplayName = sizeof( TCHAR ) * cchSourceDisplayName;
            LPTSTR      pszSourceDisplayName;
            DWORD       dwType;
   
            pszSourceDisplayName = m_strSourceDisplayName.GetBuffer( cchSourceDisplayName );
   
            if ( NULL != pszSourceDisplayName )
            {
               lError = RegQueryValueEx( hKeySource, REG_VALUE_NAME, NULL, &dwType, (LPBYTE) pszSourceDisplayName, &cbSourceDisplayName );
   
               m_strSourceDisplayName.ReleaseBuffer();
            }
               
            RegCloseKey( hKeySource );
         }

         if ( ( ERROR_SUCCESS != lError ) || m_strSourceDisplayName.IsEmpty() )
         {
            m_strSourceDisplayName = m_strSource;
         }
      }
   }

   return m_strSourceDisplayName;
}


DWORD CLicense::CreateLicenseInfo( PLLS_LICENSE_INFO_1 pLicInfo1 )

/*++

Routine Description:

   Create a LLS_LICENSE_INFO_1 structure corresponding to this object.

Arguments:

   pLicInfo1 (PLLS_LICENSE_INFO_1)
      On return, holds the created structure.

Return Values:

   ERROR_SUCCESS or ERROR_NOT_ENOUGH_MEMORY.

--*/

{
   DWORD dwError;

   pLicInfo1->Product = (LPTSTR) LocalAlloc( LMEM_FIXED, sizeof( TCHAR ) * ( 1 + m_strProduct.GetLength()     ) );
   pLicInfo1->Vendor  = (LPTSTR) LocalAlloc( LMEM_FIXED, sizeof( TCHAR ) * ( 1 + m_strVendor.GetLength()      ) );
   pLicInfo1->Admin   = (LPTSTR) LocalAlloc( LMEM_FIXED, sizeof( TCHAR ) * ( 1 + m_strAdmin.GetLength()       ) );
   pLicInfo1->Comment = (LPTSTR) LocalAlloc( LMEM_FIXED, sizeof( TCHAR ) * ( 1 + m_strDescription.GetLength() ) );
   pLicInfo1->Source  = (LPTSTR) LocalAlloc( LMEM_FIXED, sizeof( TCHAR ) * ( 1 + m_strSource.GetLength()      ) );

   if (    ( NULL == pLicInfo1->Product )
        || ( NULL == pLicInfo1->Vendor  )
        || ( NULL == pLicInfo1->Admin   )
        || ( NULL == pLicInfo1->Comment )
        || ( NULL == pLicInfo1->Source  ) )
   {
      dwError = ERROR_NOT_ENOUGH_MEMORY;
   }
   else
   {
      lstrcpy( pLicInfo1->Product, m_strProduct     );
      lstrcpy( pLicInfo1->Vendor,  m_strVendor      );
      lstrcpy( pLicInfo1->Admin,   m_strAdmin       );
      lstrcpy( pLicInfo1->Comment, m_strDescription );
      lstrcpy( pLicInfo1->Source,  m_strSource      );

      pLicInfo1->Quantity        = m_lQuantity;
      pLicInfo1->MaxQuantity     = m_dwMaxQuantity;
      pLicInfo1->Date            = m_dwPurchaseDate;
      pLicInfo1->AllowedModes    = m_dwAllowedModes;
      pLicInfo1->CertificateID   = m_dwCertificateID;
      pLicInfo1->ExpirationDate  = m_dwExpirationDate;
      memcpy( pLicInfo1->Secrets, m_adwSecrets, sizeof( m_adwSecrets ) );

      dwError = ERROR_SUCCESS;
   }

   if ( ERROR_SUCCESS != dwError )
   {
      if ( NULL != pLicInfo1->Product )  LocalFree( pLicInfo1->Product );
      if ( NULL != pLicInfo1->Vendor  )  LocalFree( pLicInfo1->Vendor  );
      if ( NULL != pLicInfo1->Admin   )  LocalFree( pLicInfo1->Admin   );
      if ( NULL != pLicInfo1->Comment )  LocalFree( pLicInfo1->Comment );
      if ( NULL != pLicInfo1->Source  )  LocalFree( pLicInfo1->Source  );

      ZeroMemory( pLicInfo1, sizeof( *pLicInfo1 ) );
   }

   return dwError;
}


void CLicense::DestroyLicenseInfo( PLLS_LICENSE_INFO_1 pLicInfo1 )

/*++

Routine Description:

   Frees a license structure previously created by CreateLicenseInfo().

Arguments:

   pLicInfo1 (PLLS_LICENSE_INFO_1)
      The structure previously created by CreateLicenseInfo().

Return Values:

   None.

--*/

{
   if ( NULL != pLicInfo1->Product )  LocalFree( pLicInfo1->Product );
   if ( NULL != pLicInfo1->Vendor  )  LocalFree( pLicInfo1->Vendor  );
   if ( NULL != pLicInfo1->Admin   )  LocalFree( pLicInfo1->Admin   );
   if ( NULL != pLicInfo1->Comment )  LocalFree( pLicInfo1->Comment );
   if ( NULL != pLicInfo1->Source  )  LocalFree( pLicInfo1->Source  );
}


CString CLicense::GetAllowedModesString()

/*++

Routine Description:

   Get a string corresponding to the license mode(s) for which this license
   was installed.

Arguments:

   None.

Return Values:

   CString.

--*/

{
   if ( m_strAllowedModes.IsEmpty() )
   {
      UINT  uStringID;

      switch ( m_dwAllowedModes & ( LLS_LICENSE_MODE_ALLOW_PER_SEAT | LLS_LICENSE_MODE_ALLOW_PER_SERVER ) )
      {
      case ( LLS_LICENSE_MODE_ALLOW_PER_SEAT | LLS_LICENSE_MODE_ALLOW_PER_SERVER ):
         uStringID = IDS_LICENSE_MODE_EITHER;
         break;
      case LLS_LICENSE_MODE_ALLOW_PER_SEAT:
         uStringID = IDS_LICENSE_MODE_PER_SEAT;
         break;
      case LLS_LICENSE_MODE_ALLOW_PER_SERVER:
         uStringID = IDS_LICENSE_MODE_PER_SERVER;
         break;
      default:
         uStringID = IDS_LICENSE_MODE_UNKNOWN;
         break;
      }

      m_strAllowedModes.LoadString( uStringID );
   }

   return m_strAllowedModes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\nlicdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    nlicdlg.h

Abstract:

    New license dialog implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

   Jeff Parham (jeffparh) 14-Dec-1995
      Moved over from LLSMGR, added ability to purchase per server licenses,
      added license removal functionality.

--*/

#ifndef _NLICDLG_H_
#define _NLICDLG_H_

class CNewLicenseDialog : public CDialog
{
private:
    BOOL             m_bAreCtrlsInitialized;

public:
    CString          m_strServerName;

    LLS_HANDLE       m_hLls;
    LLS_HANDLE       m_hEnterpriseLls;

    DWORD            m_dwEnterFlags;

    //{{AFX_DATA(CNewLicenseDialog)
    enum { IDD = IDD_NEW_LICENSE };
    CEdit            m_comEdit;
    CEdit            m_licEdit;
    CSpinButtonCtrl  m_spinCtrl;
    CComboBox        m_productList;
    CString          m_strComment;
    long             m_nLicenses;
    long             m_nLicensesMin;
    CString          m_strProduct;
    int              m_nLicenseMode;
    //}}AFX_DATA

public:
    CNewLicenseDialog(CWnd* pParent = NULL);
    ~CNewLicenseDialog();

    // CCF API
    DWORD      CertificateEnter(  LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags );
    DWORD      CertificateRemove( LPCSTR pszServerName, DWORD dwFlags, PLLS_LICENSE_INFO_1 pLicenseInfo );

    NTSTATUS   ConnectTo( BOOL bUseEnterprise, LPTSTR pszServerName, PLLS_HANDLE phLls );
    BOOL       ConnectServer();
    BOOL       ConnectEnterprise();

    void       GetProductList();
    NTSTATUS   AddLicense();

    void AbortDialogIfNecessary();
    void AbortDialog();

    void InitCtrls();
    BOOL RefreshCtrls();

    BOOL IsQuantityValid();

    //{{AFX_VIRTUAL(CNewLicenseDialog)
    public:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CNewLicenseDialog)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();
    afx_msg void OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnUpdateQuantity();
    afx_msg void OnHelp();
    afx_msg void OnPerSeat();
    afx_msg void OnPerServer();
    afx_msg LRESULT OnHelpCmd( WPARAM , LPARAM );

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _NLICDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\paper.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   paper.cpp

Abstract:

   Paper certificate dialog implementation.

Author:

   Jeff Parham (jeffparh) 13-Dec-1995

Revision History:

--*/


#include "stdafx.h"
#include <stdlib.h>

#include "resource.h"
#include "ccfapi.h"
#include "paper.h"
#include "md4.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


static void MD4UpdateDword( MD4_CTX * pCtx, DWORD dwValue );


CPaperSourceDlg::CPaperSourceDlg(CWnd* pParent /*=NULL*/)
   : CDialog(CPaperSourceDlg::IDD, pParent)

/*++

Routine Description:

   Constructor for dialog.

Arguments:

   pParent - owner window.

Return Values:

   None.

--*/

{
   //{{AFX_DATA_INIT(CPaperSourceDlg)
   m_strActivationCode        = _T("");
   m_strKeyCode               = _T("");
   m_strSerialNumber          = _T("");
   m_strVendor                = _T("");
   m_strProductName           = _T("");
   m_strComment               = _T("");
   m_nDontInstallAllLicenses  = -1;
   m_nLicenses                = 0;
   m_nLicenseMode             = -1;
   //}}AFX_DATA_INIT

   m_bProductListRetrieved    = FALSE;
   m_hLls                     = NULL;
   m_hEnterpriseLls           = NULL;
   m_dwEnterFlags             = 0;

   m_nLicenses                = 1;
   m_nDontInstallAllLicenses  = 0;

   m_strServerName            = _T("");
}


CPaperSourceDlg::~CPaperSourceDlg()

/*++

Routine Description:

   Destructor for dialog.

Arguments:

   None.

Return Values:

   None.

--*/

{
   if ( NULL != m_hLls )
   {
      LlsClose( m_hLls );
   }

   if ( NULL != m_hEnterpriseLls )
   {
      LlsClose( m_hEnterpriseLls );
   }
}


void CPaperSourceDlg::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

   Called by framework to exchange dialog data.

Arguments:

   pDX - data exchange object.

Return Values:

   None.

--*/

{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CPaperSourceDlg)
   DDX_Control(pDX, IDC_SPIN_LICENSES, m_spinLicenses);
   DDX_Control(pDX, IDC_PRODUCT_NAME, m_cboxProductName);
   DDX_Text(pDX, IDC_ACTIVATION_CODE, m_strActivationCode);
   DDX_Text(pDX, IDC_KEY_CODE, m_strKeyCode);
   DDX_Text(pDX, IDC_SERIAL_NUMBER, m_strSerialNumber);
   DDX_Text(pDX, IDC_VENDOR, m_strVendor);
   DDX_CBString(pDX, IDC_PRODUCT_NAME, m_strProductName);
   DDX_Text(pDX, IDC_COMMENT, m_strComment);
   DDX_Radio(pDX, IDC_ALL_LICENSES, m_nDontInstallAllLicenses);
   DDX_Text(pDX, IDC_NUM_LICENSES, m_nLicenses);
   DDX_Radio(pDX, IDC_PER_SEAT, m_nLicenseMode);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPaperSourceDlg, CDialog)
   //{{AFX_MSG_MAP(CPaperSourceDlg)
   ON_EN_UPDATE(IDC_ACTIVATION_CODE, OnUpdateActivationCode)
   ON_EN_UPDATE(IDC_KEY_CODE, OnUpdateKeyCode)
   ON_EN_UPDATE(IDC_VENDOR, OnUpdateVendor)
   ON_EN_UPDATE(IDC_SERIAL_NUMBER, OnUpdateSerialNumber)
   ON_CBN_EDITUPDATE(IDC_PRODUCT_NAME, OnUpdateProductName)
   ON_CBN_DROPDOWN(IDC_PRODUCT_NAME, OnDropDownProductName)
   ON_BN_CLICKED(IDC_MY_HELP, OnHelp)
   ON_WM_DESTROY()
   ON_BN_CLICKED(IDC_ALL_LICENSES, OnAllLicenses)
   ON_BN_CLICKED(IDC_SOME_LICENSES, OnSomeLicenses)
   ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LICENSES, OnDeltaPosSpinLicenses)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CPaperSourceDlg::OnUpdateActivationCode() 

/*++

Routine Description:

   Message handler for EN_UPDATE of activation code.

Arguments:

   None.

Return Values:

   None.

--*/

{
   EnableOrDisableOK(); 
}


void CPaperSourceDlg::OnUpdateKeyCode() 

/*++

Routine Description:

    Message handler for EN_UPDATE of key code.

Arguments:

    None.

Return Values:

    None.

--*/

{
   EnableOrDisableOK(); 
}


void CPaperSourceDlg::OnUpdateProductName() 

/*++

Routine Description:

    Message handler for EN_UPDATE of product name.

Arguments:

    None.

Return Values:

    None.

--*/

{
   EnableOrDisableOK(); 
}


void CPaperSourceDlg::OnUpdateSerialNumber() 

/*++

Routine Description:

    Message handler for EN_UPDATE of serial number.

Arguments:

    None.

Return Values:

    None.

--*/

{
   EnableOrDisableOK(); 
}


void CPaperSourceDlg::OnUpdateVendor() 

/*++

Routine Description:

    Message handler for EN_UPDATE of vendor.

Arguments:

    None.

Return Values:

    None.

--*/

{
   EnableOrDisableOK(); 
}


void CPaperSourceDlg::EnableOrDisableOK()

/*++

Routine Description:

   Enable or diable OK button depending upon whether all necessary dialog data
   has been supplied by the user.

Arguments:

   None.

Return Values:

   None.

--*/

{
   BOOL     bEnableOK;

   UpdateData( TRUE );

   bEnableOK =    !m_strActivationCode.IsEmpty()
               && !m_strKeyCode.IsEmpty()
               && !m_strProductName.IsEmpty()
               && !m_strSerialNumber.IsEmpty()
               && !m_strVendor.IsEmpty()
               && (    ( 0 == m_nLicenseMode )
                    || ( 1 == m_nLicenseMode ) );

   GetDlgItem( IDOK )->EnableWindow( bEnableOK );
}


BOOL CPaperSourceDlg::OnInitDialog() 

/*++

Routine Description:

   Handler for WM_INITDIALOG.

Arguments:

   None.

Return Values:

   Returns false if focus set manually.

--*/

{
   CDialog::OnInitDialog();

   EnableOrDisableOK();

   if ( m_nDontInstallAllLicenses )
   {
      OnSomeLicenses();
   }
   else
   {
      OnAllLicenses();
   }

   m_spinLicenses.SetRange( 1, MAX_NUM_LICENSES );

   // ghost out items that were passed to us from the application
   if ( !m_strProductName.IsEmpty() )
      GetDlgItem( IDC_PRODUCT_NAME )->EnableWindow( FALSE );
   if ( !m_strVendor.IsEmpty() )
      GetDlgItem( IDC_VENDOR       )->EnableWindow( FALSE );

   // if license mode set by application, don't let user change it
   if ( m_dwEnterFlags & ( CCF_ENTER_FLAG_PER_SEAT_ONLY | CCF_ENTER_FLAG_PER_SERVER_ONLY ) )
   {
      m_nLicenseMode = ( m_dwEnterFlags & CCF_ENTER_FLAG_PER_SEAT_ONLY ) ? 0 : 1;
      GetDlgItem( IDC_PER_SERVER )->EnableWindow( FALSE );
      GetDlgItem( IDC_PER_SEAT   )->EnableWindow( FALSE );
      UpdateData( FALSE );
   }

   return TRUE;
}


void CPaperSourceDlg::OnOK() 

/*++

Routine Description:

   Creates a new license for product.

Arguments:

   None.

Return Values:

   None.

--*/

{
   NTSTATUS    nt;

   if( UpdateData( TRUE ) )
   {
      // verify activation code
      DWORD nActivationCode = wcstoul( m_strActivationCode, NULL, 16 );

      if ( nActivationCode != ComputeActivationCode() )
      {
         AfxMessageBox( IDS_BAD_ACTIVATION_CODE, MB_ICONEXCLAMATION | MB_OK, 0 );
      }
      else if ( ( m_nLicenses < 1 ) || ( m_nLicenses > MAX_NUM_LICENSES ) )
      {
         AfxMessageBox( IDS_INVALID_NUM_LICENSES, MB_ICONEXCLAMATION | MB_OK, 0 );

         GetDlgItem( IDC_NUM_LICENSES )->SetActiveWindow();
      }
      else
      {
         DWORD dwKeyCode = KEY_CODE_MASK ^ wcstoul( m_strKeyCode, NULL, 10 );
   
         if (    m_nDontInstallAllLicenses
              && ( (DWORD)m_nLicenses > KeyCodeToNumLicenses( dwKeyCode ) ) )
         {
            // can't install more licenses than are in the certificate
            AfxMessageBox( IDS_NOT_ENOUGH_LICENSES_ON_CERTIFICATE, MB_ICONEXCLAMATION | MB_OK, 0 );

            GetDlgItem( IDC_NUM_LICENSES )->SetActiveWindow();
         }
         else if ( !( ( 1 << m_nLicenseMode ) & KeyCodeToModesAllowed( dwKeyCode ) ) )
         {
            // can't install certificate in a mode that's not allowed by the key code
            AfxMessageBox( IDS_LICENSE_MODE_NOT_ALLOWED, MB_ICONEXCLAMATION | MB_OK, 0 );

            GetDlgItem( IDC_PER_SEAT )->SetActiveWindow();
         }
         else
         {
            nt = AddLicense();
   
            if ( STATUS_SUCCESS == nt )
            {
               CDialog::OnOK();
            }
            else if ( ( ERROR_CANCELLED != nt ) && ( STATUS_CANCELLED != nt ) )
            {
               AbortDialogIfNecessary();
            }
         }
      }
   }
}


void CPaperSourceDlg::GetProductList()

/*++

Routine Description:

   Retrieves the list of installed product from the license server.

Arguments:

   None.

Return Values:

   None.

--*/

{
   if ( ConnectServer() )
   {
      // save edit selection
      UpdateData( TRUE );

      // get list of products from license server, inserting into listbox
      m_cboxProductName.ResetContent();

      DWORD       dwResumeHandle = 0;
      DWORD       dwTotalEntries;
      DWORD       dwEntriesRead;
      NTSTATUS    nt;

      do
      {
         LPBYTE      pReturnBuffer = NULL;

         nt = ::LlsProductEnum( m_hLls,
                                0,
                                &pReturnBuffer,
                                LLS_PREFERRED_LENGTH,
                                &dwEntriesRead,
                                &dwTotalEntries,
                                &dwResumeHandle );
         theApp.SetLastLlsError( nt );

         if ( ( STATUS_SUCCESS == nt ) || ( STATUS_MORE_ENTRIES == nt ) )
         {
            LLS_PRODUCT_INFO_0 *    pProductInfo = (LLS_PRODUCT_INFO_0 *) pReturnBuffer;

            for ( DWORD i=0; i < dwEntriesRead; i++ )
            {
               m_cboxProductName.AddString( pProductInfo[i].Product );

               ::LlsFreeMemory( pProductInfo->Product );
            }

            ::LlsFreeMemory( pProductInfo );
         }

      } while ( STATUS_MORE_ENTRIES == nt );

      if ( STATUS_SUCCESS != nt )
      {
         // still connected?
         AbortDialogIfNecessary();
      }

      // restore previous edit selection
      UpdateData( FALSE );
   }
}


void CPaperSourceDlg::OnDropDownProductName() 

/*++

Routine Description:

   Handler for CBN_DROPDOWN of product name combo box.

Arguments:

   None.

Return Values:

   None.

--*/

{
   if ( !m_bProductListRetrieved )
   {
      BeginWaitCursor();
      GetProductList();
      EndWaitCursor();

      m_bProductListRetrieved = TRUE;
   }
}


BOOL CPaperSourceDlg::ConnectServer()

/*++

Routine Description:

   Establish a connection to the license service on the target server.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   if ( NULL == m_hLls )
   {
      ConnectTo( FALSE, m_strServerName, &m_hLls );

      if ( !LlsCapabilityIsSupported( m_hLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
      {
         // we connected to the machine, but it doesn't support secure certificates
         // we should not get here under normal circumstances, since the select
         // source dialog should not allow the user to choose the paper source
         // under such circumstances
         LlsClose( m_hLls );
         m_hLls = NULL;

         theApp.SetLastLlsError( STATUS_INVALID_LEVEL );
      }

      if ( NULL == m_hLls )
      {
         theApp.DisplayLastError();
         EndDialog( IDABORT );
      }
   }

   return ( NULL != m_hLls );
}


BOOL CPaperSourceDlg::ConnectEnterprise()

/*++

Routine Description:

   Establish a connection to the license service on the enterprise server
   of the target server.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   if ( NULL == m_hEnterpriseLls )
   {
      ConnectTo( !( m_dwEnterFlags & CCF_ENTER_FLAG_SERVER_IS_ES ), m_strServerName, &m_hEnterpriseLls );

      if ( NULL == m_hEnterpriseLls )
      {
         theApp.DisplayLastError();
      }
   }

   return ( NULL != m_hEnterpriseLls );
}


NTSTATUS CPaperSourceDlg::ConnectTo( BOOL bUseEnterprise, CString strServerName, PLLS_HANDLE phLls )

/*++

Routine Description:

   Establish a connection to the license service on the given server or that
   on the given server's enterprise server.

Arguments:

   bUseEnterprise (BOOL)
      If TRUE, connect to the enterprise server of the target server, not to
      the target server itself. 
   pszServerName (CString)
      The target server.  An empty value indicates the local server.
   phLls (PLLS_HANDLE)
      On return, holds the handle to the standard LLS RPC.

Return Values:

   STATUS_SUCCESS or NT status code.

--*/

{
   NTSTATUS    nt = STATUS_SUCCESS;
   LPTSTR      pszServerName = NULL;
   
   if ( !strServerName.IsEmpty() )
   {
      pszServerName = strServerName.GetBuffer(0);

      if ( NULL == pszServerName )
      {
         nt = ERROR_NOT_ENOUGH_MEMORY;
      }
   }

   if ( STATUS_SUCCESS == nt )
   {
      if ( !bUseEnterprise )
      {
         nt = ::LlsConnect( pszServerName, phLls );
      }
      else
      {
         PLLS_CONNECT_INFO_0  pConnect = NULL;

         nt = ::LlsConnectEnterprise( pszServerName, phLls, 0, (LPBYTE *) &pConnect );

         if ( STATUS_SUCCESS == nt )
         {
            ::LlsFreeMemory( pConnect );
         }
      }

      theApp.SetLastLlsError( nt );
   }

   if ( STATUS_SUCCESS != nt )
   {
      *phLls = NULL;
   }

   return nt;
}


void CPaperSourceDlg::OnHelp() 

/*++

Routine Description:

   Handler for help button click.

Arguments:

   None.

Return Values:

   None.

--*/

{
   WinHelp( IDD, HELP_CONTEXT );
}


void CPaperSourceDlg::WinHelp(DWORD dwData, UINT nCmd) 

/*++

Routine Description:

   Call WinHelp for this dialog.

Arguments:

   dwData (DWORD)
   nCmd (UINT)

Return Values:

   None.

--*/

{
   ::HtmlHelp(m_hWnd, L"liceconcepts.chm", HH_DISPLAY_TOPIC,0);
/*
   BOOL ok = ::WinHelp( m_hWnd, theApp.GetHelpFileName(), nCmd, dwData );
   ASSERT( ok );
*/
}


void CPaperSourceDlg::OnDestroy() 

/*++

Routine Description:

   Handler for WM_DESTROY.

Arguments:

   None.

Return Values:

   None.

--*/

{
   ::WinHelp( m_hWnd, theApp.GetHelpFileName(), HELP_QUIT, 0 );
   
   CDialog::OnDestroy();
}


void CPaperSourceDlg::AbortDialogIfNecessary()

/*++

Routine Description:

   Displays status and aborts if connection lost.

Arguments:

   None.

Return Values:

   None.

--*/

{
   theApp.DisplayLastError();

   if ( theApp.IsConnectionDropped() )
   {
      EndDialog( IDABORT );
   }
}


DWORD CPaperSourceDlg::ComputeActivationCode()

/*++

Routine Description:

   Return the computed activation code corresponding to the entered
   certificate.

Arguments:

   None.

Return Values:

   DWORD.

--*/

{
   MD4_CTX     ctx;
   DWORD       dw;
   UCHAR       digest[ 16 ];
   DWORD       adwCodeSeg[ sizeof( digest ) / sizeof( DWORD ) ];
   int         nCodeSeg;
   int         nCodeSegByte;
   DWORD       dwActivationCode ;
   CHAR        szAnsiName[ 128 ];

   MD4Init( &ctx );

   ZeroMemory( szAnsiName, sizeof( szAnsiName ) );
   wcstombs( szAnsiName, m_strProductName, sizeof( szAnsiName ) - 1 );
   MD4Update( &ctx, (LPBYTE)szAnsiName, strlen( szAnsiName ) );

   ZeroMemory( szAnsiName, sizeof( szAnsiName ) );
   wcstombs( szAnsiName, m_strVendor, sizeof( szAnsiName ) - 1 );
   MD4Update( &ctx, (LPBYTE)szAnsiName, strlen( szAnsiName ) );

   MD4UpdateDword( &ctx, 14721776 );
   MD4UpdateDword( &ctx, wcstoul( m_strSerialNumber, NULL, 10 ) );
   MD4UpdateDword( &ctx, 19721995 );
   MD4UpdateDword( &ctx, KEY_CODE_MASK ^ wcstoul( m_strKeyCode, NULL, 10 ) );

   MD4Final( &ctx );
   CopyMemory( digest, ctx.digest, 16 );

   // convert digest into platform-independent array of DWORDs
   for ( nCodeSeg=0; nCodeSeg < sizeof( adwCodeSeg ) / sizeof( *adwCodeSeg ); nCodeSeg++ )
   {
      adwCodeSeg[ nCodeSeg ] = 0;

      for ( nCodeSegByte=0; nCodeSegByte < sizeof( *adwCodeSeg ); nCodeSegByte++ )
      {
         adwCodeSeg[ nCodeSeg ] <<= 8;
         adwCodeSeg[ nCodeSeg ] |=  digest[ nCodeSeg * sizeof( *adwCodeSeg ) + nCodeSegByte ];
      }
   }

   dwActivationCode = ( adwCodeSeg[ 0 ] + adwCodeSeg[ 1 ] ) ^ ( adwCodeSeg[ 2 ] - adwCodeSeg[ 3 ] );

   return dwActivationCode;
}


NTSTATUS CPaperSourceDlg::AddLicense()

/*++

Routine Description:

   Enter a new license into the system.

Arguments:

   None.

Return Values:

   STATUS_SUCCESS
   ERROR_NOT_ENOUGH_MEMORY
   ERROR_CANCELLED
   NT status code
   Win error

--*/

{
   NTSTATUS    nt;

   if ( !ConnectServer() )
   {
      nt = ERROR_CANCELLED;
   }
   else
   {
      LPTSTR   pszProductName = m_strProductName.GetBuffer(0);
      LPTSTR   pszServerName  = m_strServerName.GetBuffer(0);
      LPTSTR   pszComment     = m_strComment.GetBuffer(0);
      LPTSTR   pszVendor      = m_strVendor.GetBuffer(0);

      if ( ( NULL == pszProductName ) || ( NULL == pszServerName ) || ( NULL == pszComment ) || ( NULL == pszVendor ) )
      {
         nt = ERROR_NOT_ENOUGH_MEMORY;
      }
      else
      {
         // handles for LLS on machine to receive licenses
         // (if per seat, these will be changed to correspond to the enterprise server)
         LLS_HANDLE  hLls   = NULL;

         if ( 0 == m_nLicenseMode )
         {
            // per seat mode; install on enterprise server
            BeginWaitCursor();
            BOOL ok = ConnectEnterprise();
            EndWaitCursor();

            if ( !ok )
            {
               // can't connect to enterprise server
               nt = ERROR_CANCELLED;
            }
            else if ( !LlsCapabilityIsSupported( m_hEnterpriseLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
            {
               // enterprise server doesn't support secure certificates
               AfxMessageBox( IDS_ENTERPRISE_SERVER_BACKLEVEL_CANT_ADD_CERT, MB_ICONSTOP | MB_OK, 0 );
               nt = ERROR_CANCELLED;
            }
            else
            {
               hLls = m_hEnterpriseLls;
               nt = STATUS_SUCCESS;
            }
         }
         else
         {
            // per server mode; install on target server
            hLls   = m_hLls;
            nt = STATUS_SUCCESS;
         }

         if ( STATUS_SUCCESS == nt )
         {
            TCHAR       szUserName[ 64 ];
            DWORD       cchUserName;
            BOOL        ok;

            cchUserName = sizeof( szUserName ) / sizeof( *szUserName );
            ok = GetUserName( szUserName, &cchUserName );
   
            if ( !ok )
            {
               nt = GetLastError();
            }
            else
            {
               // enter certificate into system
               DWORD nKeyCode = KEY_CODE_MASK ^ wcstoul( m_strKeyCode, NULL, 10 );
      
               // --------- fill in certificate info ---------
               LLS_LICENSE_INFO_1   lic;
      
               ZeroMemory( &lic, sizeof( lic ) );
   
               lic.Product        = pszProductName;
               lic.Vendor         = pszVendor;
               lic.Comment        = pszComment;
               lic.Admin          = szUserName;
               lic.Quantity       = m_nDontInstallAllLicenses ? m_nLicenses : KeyCodeToNumLicenses( nKeyCode );
               lic.Date           = 0;
               lic.AllowedModes   = 1 << m_nLicenseMode;
               lic.CertificateID  = wcstoul( m_strSerialNumber, NULL, 10 );
               lic.Source         = TEXT("Paper");
               lic.ExpirationDate = KeyCodeToExpirationDate( nKeyCode );
               lic.MaxQuantity    = KeyCodeToNumLicenses( nKeyCode );

               BeginWaitCursor();

               nt = ::LlsLicenseAdd( hLls, 1, (LPBYTE) &lic );
               theApp.SetLastLlsError( nt );

               EndWaitCursor();

               if (    ( STATUS_OBJECT_NAME_EXISTS == nt )
                    || ( STATUS_ALREADY_COMMITTED == nt ) )
               {
                  LLS_HANDLE  hLlsForTargets = NULL;

                  // too many licenses of this certificate
                  if ( STATUS_OBJECT_NAME_EXISTS == nt )
                  {
                     // denied by target's local database
                     hLlsForTargets = hLls;
                  }
                  else if ( ConnectEnterprise() )
                  {
                     // denied by target's enterprise server; we're connected!
                     hLlsForTargets = m_hEnterpriseLls;
                  }

                  if ( NULL == hLlsForTargets )
                  {
                     // denied by enterprise server, and can't connect to it (?!)
                     AfxMessageBox( IDS_NET_LICENSES_ALREADY_INSTALLED, MB_ICONSTOP | MB_OK, 0 );
                  }
                  else
                  {
                     // too many licenses of this certificate exist in the enterprise
                     LPBYTE                           ReturnBuffer = NULL;
                     DWORD                            dwNumTargets = 0;

                     // get list of machines on which licenses from this certificate have been installed
                     nt = ::LlsCertificateClaimEnum( hLlsForTargets, 1, (LPBYTE) &lic, 0, &ReturnBuffer, &dwNumTargets );

                     if ( ( STATUS_SUCCESS == nt ) && ( dwNumTargets > 0 ) )
                     {
                        PLLS_CERTIFICATE_CLAIM_INFO_0    pTarget = (PLLS_CERTIFICATE_CLAIM_INFO_0) ReturnBuffer;
                        CString                          strLicenses;
                        CString                          strTarget;
                        CString                          strTargetList;

                        while ( dwNumTargets-- )
                        {
                           strLicenses.Format( TEXT("%d"), pTarget->Quantity );
                           AfxFormatString2( strTarget, IDS_NET_CERTIFICATE_TARGET_ENTRY, pTarget->ServerName, strLicenses );
                        
                           strTargetList = strTargetList.IsEmpty() ? strTarget : ( TEXT("\n") + strTarget );

                           pTarget++;
                        }

                        CString     strMessage;

                        AfxFormatString1( strMessage, IDS_NET_LICENSES_ALREADY_INSTALLED_ON, strTargetList );
                        AfxMessageBox( strMessage, MB_ICONSTOP | MB_OK );
                     }
                     else
                     {
                        AfxMessageBox( IDS_NET_LICENSES_ALREADY_INSTALLED, MB_ICONSTOP | MB_OK, 0 );
                     }

                     if ( STATUS_SUCCESS == nt )
                     {
                        ::LlsFreeMemory( ReturnBuffer );
                     }
                  }

                  nt = ERROR_CANCELLED;
               }
            }
         }
      }

      // don't set if !ConnectServer() -- otherwise we'll clobber the LLS error
      theApp.SetLastError( nt );

      if ( NULL != pszProductName )
         m_strProductName.ReleaseBuffer();
      if ( NULL != pszServerName )
         m_strServerName.ReleaseBuffer();
      if ( NULL != pszComment )
         m_strComment.ReleaseBuffer();
      if ( NULL != pszVendor )
         m_strVendor.ReleaseBuffer();
   }

   return nt;
}


DWORD CPaperSourceDlg::KeyCodeToExpirationDate( DWORD dwKeyCode )

/*++

Routine Description:

   Derive the license expiration date from the key code.

Arguments:

   dwKeyCode (DWORD)

Return Values:

   DWORD.

--*/

{
   DWORD    dwExpirationDate = 0;
   USHORT   usWinDate = (USHORT)( ( dwKeyCode >> 12 ) & 0x0000FFFF );

   if ( 0 != usWinDate )
   {
      TIME_FIELDS    tf;
      LARGE_INTEGER  li;

      ZeroMemory( &tf, sizeof( tf ) );

      tf.Year   = 1980 + ( usWinDate & 0x7F );
      tf.Month  = ( ( usWinDate >> 7 ) & 0x0F );
      tf.Day    = ( usWinDate >> 11 );
      tf.Hour   = 23;
      tf.Minute = 59;
      tf.Second = 59;

      BOOL ok;

      ok = RtlTimeFieldsToTime( &tf, &li );
      ASSERT( ok );

      if ( ok )
      {
         ok = RtlTimeToSecondsSince1980( &li, &dwExpirationDate );
         ASSERT( ok );
      }
   }

   return dwExpirationDate;
}


void CPaperSourceDlg::OnAllLicenses() 

/*++

Routine Description:

   Handler for BN_CLICKED of "install all licenses".

Arguments:

   None.

Return Values:

   None.

--*/

{
   GetDlgItem( IDC_NUM_LICENSES  )->EnableWindow( FALSE );
   GetDlgItem( IDC_SPIN_LICENSES )->EnableWindow( FALSE );
}


void CPaperSourceDlg::OnSomeLicenses() 

/*++

Routine Description:

   Handler for BN_CLICKED of "install only x licenses".

Arguments:

   None.

Return Values:

   None.

--*/

{
   GetDlgItem( IDC_NUM_LICENSES  )->EnableWindow( TRUE );
   GetDlgItem( IDC_SPIN_LICENSES )->EnableWindow( TRUE );
}


void CPaperSourceDlg::OnDeltaPosSpinLicenses(NMHDR* pNMHDR, LRESULT* pResult) 

/*++

Routine Description:

   Handler for UDN_DELTAPOS of number of licenses.

Arguments:

   pNMHDR (NMHDR*)
   pResult (LRESULT*)

Return Values:

   None.

--*/

{
   if ( UpdateData(TRUE) )   // get data
   {   
      m_nLicenses += ((NM_UPDOWN*)pNMHDR)->iDelta;

      if (m_nLicenses < 1)
      {
         m_nLicenses = 1;

         ::MessageBeep(MB_OK);
      }
      else if (m_nLicenses > MAX_NUM_LICENSES )
      {
         m_nLicenses = MAX_NUM_LICENSES;

         ::MessageBeep(MB_OK);
      }

      UpdateData(FALSE);  // set data
   }

   *pResult = 1;   // handle ourselves...
}


DWORD CPaperSourceDlg::CertificateEnter( LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags )

/*++

Routine Description:

   Display a dialog allowing the user to enter a license certificate
   into the system with a paper certificate.

Arguments:

   pszServerName (LPCSTR)
      Name of the server for which licenses are to be installed.  Note that
      this may not be the same as the server on which licenses are actually
      installed, as, for example, per seat licenses are always installed on
      the enterprise server.  A NULL value indicates the local server.
   pszProductName (LPCSTR)
      Product for which licenses are to be installed.  A NULL value indicates
      that the user should be allowed to choose.
   pszVendor (LPCSTR)
      Name of the vendor of the product.  This value should be NULL if
      pszProductName is NULL, and should be non-NULL if pszProductName is
      non-NULL.
   dwFlags (DWORD)
      A bitfield containing one or more of the following:
         CCF_ENTER_FLAG_PER_SEAT_ONLY
            Allow the user to enter only per seat licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SERVER_ONLY.
         CCF_ENTER_FLAG_PER_SERVER_ONLY
            Allow the user to enter only per server licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SEAT_ONLY.

Return Value:

   ERROR_SUCCESS     (A certificate was successfully entered into the system.)
   ERROR_CANCELLED   (The user cancelled without installing a certificate.)
   other Win error

--*/

{
   DWORD dwError;

   m_strServerName  = pszServerName  ? pszServerName  : "";
   m_strProductName = pszProductName ? pszProductName : "";
   m_strVendor      = pszVendor      ? pszVendor      : "";
   m_dwEnterFlags   = dwFlags;

   if ( IDOK == DoModal() )
   {
      dwError = ERROR_SUCCESS;
   }
   else
   {
      dwError = ERROR_CANCELLED;
   }

   return dwError;
}


DWORD CPaperSourceDlg::CertificateRemove( LPCSTR pszServerName, DWORD dwFlags, PLLS_LICENSE_INFO_1 pLicenseInfo )

/*++

Routine Description:

   Remove licenses previously installed via PaperCertificateEnter().

Arguments:

   hWndParent (HWND)
      HWND to the client's main window, for use as the parent window to any
      opened dialogs.  May be NULL.
   pszServerName (LPCSTR)
      Name of the server on which licenses are to be removed.  A NULL value
      indicates the local server.
   dwFlags (DWORD)
      Certificate removal options.  As of this writing, no flags are
      supported.
   dwLicenseLevel (DWORD)
      Level of the LLS_LICENSE_INFO_X structure pointed to by pvLicenseInfo.
   pvLicenseInfo (LPVOID)
      Points to a LLS_LICENSE_INFO_X (where X is determined by dwLicenseLevel)
      describing the licenses to be removed.

Return Value:

   ERROR_SUCCESS
   Win error

--*/

{
   DWORD    dwError;

   // dwFlags unused

   m_strServerName  = pszServerName  ? pszServerName  : "";
   m_strProductName = pLicenseInfo->Product;

   if ( !ConnectServer() )
   {
      dwError = theApp.GetLastError();
      // error message already displayed
   }
   else
   {
      CString  strComment;
      strComment.LoadString( IDS_PAPER_REMOVE_COMMENT );

      LPTSTR   pszComment = strComment.GetBuffer(0);

      if ( NULL == pszComment )
      {
         dwError = ERROR_NOT_ENOUGH_MEMORY;
      }
      else
      {
         TCHAR szUserName[ 256 ];
         DWORD cchUserName = sizeof( szUserName ) / sizeof( *szUserName );

         BOOL  ok = GetUserName( szUserName, &cchUserName );

         if ( !ok )
         {
            dwError = GetLastError();
         }
         else
         {
            NTSTATUS             nt;
            LLS_LICENSE_INFO_1   lic;

            memcpy( &lic, pLicenseInfo, sizeof( lic ) );
            lic.Admin     = szUserName;
            lic.Comment   = pszComment;
            lic.Date      = 0;
            lic.Quantity  = -pLicenseInfo->Quantity;

            BeginWaitCursor();

            nt = ::LlsLicenseAdd( m_hLls, 1, (LPBYTE) &lic );
            theApp.SetLastLlsError( nt );

            EndWaitCursor();

            dwError = (DWORD) nt;
         }
      }

      strComment.ReleaseBuffer();

      if ( ( ERROR_SUCCESS != dwError ) && ( ERROR_CANCELLED != dwError ) )
      {
         theApp.SetLastError( dwError );
         theApp.DisplayLastError();
      }
   }

   return dwError;
}

// MD4Update on a DWORD that is platform-independent
static void MD4UpdateDword( MD4_CTX * pCtx, DWORD dwValue )
{
   BYTE  b;

   b = (BYTE) ( ( dwValue & 0xFF000000 ) >> 24 );
   MD4Update( pCtx, &b, 1 );

   b = (BYTE) ( ( dwValue & 0x00FF0000 ) >> 16 );
   MD4Update( pCtx, &b, 1 );

   b = (BYTE) ( ( dwValue & 0x0000FF00 ) >> 8  );
   MD4Update( pCtx, &b, 1 );

   b = (BYTE) ( ( dwValue & 0x000000FF )       );
   MD4Update( pCtx, &b, 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\nlicdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    nlicdlg.cpp

Abstract:

    3.51-style license dialog implementation.

Author:

    Don Ryan (donryan) 02-Feb-1995

Environment:

    User Mode - Win32

Revision History:

   Jeff Parham (jeffparh) 14-Dec-1995
      Moved over from LLSMGR, added ability to purchase per server licenses,
      added license removal functionality.

--*/

#include "stdafx.h"
#include "ccfapi.h"
#include "nlicdlg.h"
#include "pseatdlg.h"
#include "psrvdlg.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CNewLicenseDialog, CDialog)
   //{{AFX_MSG_MAP(CNewLicenseDialog)
   ON_NOTIFY(UDN_DELTAPOS, IDC_NEW_LICENSE_SPIN, OnDeltaPosSpin)
   ON_EN_UPDATE(IDC_NEW_LICENSE_QUANTITY, OnUpdateQuantity)
   ON_BN_CLICKED(IDC_MY_HELP, OnHelp)
   ON_BN_CLICKED(IDC_PER_SEAT, OnPerSeat)
   ON_BN_CLICKED(IDC_PER_SERVER, OnPerServer)   
   ON_MESSAGE( WM_HELP , OnHelpCmd )
   ON_WM_DESTROY()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CNewLicenseDialog::CNewLicenseDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CNewLicenseDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CNewLicenseDialog)
    m_strComment = _T("");
    m_nLicenses = 0;
    m_nLicensesMin = 0;
    m_strProduct = _T("");
    m_nLicenseMode = -1;
    //}}AFX_DATA_INIT

    m_strServerName        = _T("");
    m_strProduct           = _T("");
    m_dwEnterFlags         = 0;
    m_nLicenseMode         = 0; // per seat

    m_bAreCtrlsInitialized = FALSE;

    m_hLls                 = NULL;
    m_hEnterpriseLls       = NULL;
}

CNewLicenseDialog::~CNewLicenseDialog()
{
   if ( NULL != m_hLls )
   {
      LlsClose( m_hLls );
   }

   if ( NULL != m_hEnterpriseLls )
   {
      LlsClose( m_hEnterpriseLls );
   }
}

void CNewLicenseDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewLicenseDialog)
    DDX_Control(pDX, IDC_NEW_LICENSE_COMMENT, m_comEdit);
    DDX_Control(pDX, IDC_NEW_LICENSE_QUANTITY, m_licEdit);
    DDX_Control(pDX, IDC_NEW_LICENSE_SPIN, m_spinCtrl);
    DDX_Control(pDX, IDC_NEW_LICENSE_PRODUCT, m_productList);
    DDX_Text(pDX, IDC_NEW_LICENSE_COMMENT, m_strComment);
    DDX_Text(pDX, IDC_NEW_LICENSE_QUANTITY, m_nLicenses);
    DDV_MinMaxLong(pDX, m_nLicenses, m_nLicensesMin, 999999);
    DDX_CBString(pDX, IDC_NEW_LICENSE_PRODUCT, m_strProduct);
    DDX_Radio(pDX, IDC_PER_SEAT, m_nLicenseMode);
   //}}AFX_DATA_MAP
}

LRESULT CNewLicenseDialog::OnHelpCmd( WPARAM , LPARAM )
{
    OnHelp( );

    return 0;
}

void CNewLicenseDialog::InitCtrls()

/*++

Routine Description:

    Initializes dialog controls.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_licEdit.SetFocus();
    m_licEdit.SetSel(0,-1);
    m_licEdit.LimitText(6);
    
    m_comEdit.LimitText(256);

    m_spinCtrl.SetRange(0, UD_MAXVAL);

    // if license mode set by application, don't let user change it
    if ( m_dwEnterFlags & ( CCF_ENTER_FLAG_PER_SEAT_ONLY | CCF_ENTER_FLAG_PER_SERVER_ONLY ) )
    {
       if ( m_dwEnterFlags & CCF_ENTER_FLAG_PER_SEAT_ONLY )
       {
           m_nLicenseMode = 0;
           OnPerSeat();
       }
       else
       {
           m_nLicenseMode = 1;
           OnPerServer();
       }

       GetDlgItem( IDC_PER_SERVER )->EnableWindow( FALSE );
       GetDlgItem( IDC_PER_SEAT   )->EnableWindow( FALSE );
       UpdateData( FALSE );
    }

    if( m_nLicenses == 0 )
    {
        GetDlgItem( IDOK )->EnableWindow( FALSE );
    }

    m_bAreCtrlsInitialized = TRUE;
}


void CNewLicenseDialog::AbortDialogIfNecessary()

/*++

Routine Description:

    Displays status and aborts if connection lost.

Arguments:

    None.

Return Values:

    None.

--*/

{
    theApp.DisplayLastError();

    if ( theApp.IsConnectionDropped() )
    {
        AbortDialog(); // bail...
    }
}


void CNewLicenseDialog::AbortDialog()

/*++

Routine Description:

    Aborts dialog.

Arguments:

    None.

Return Values:

    None.

--*/

{
    EndDialog(IDABORT); 
}


BOOL CNewLicenseDialog::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    CDialog::OnInitDialog();
    
    if (!m_bAreCtrlsInitialized)
    {
        InitCtrls();  
         
        if (!RefreshCtrls())
        {
            AbortDialogIfNecessary(); // display error...
        }
    }

    return TRUE;   
}


void CNewLicenseDialog::OnOK() 

/*++

Routine Description:

    Creates a new license for product.

Arguments:

    None.

Return Values:

    None.

--*/

{
    if ( ConnectServer() )
    {
        if (!IsQuantityValid())
            return;

        if (m_strProduct.IsEmpty())
            return;

        if ( m_nLicenseMode )
        {
            CPerServerLicensingDialog psLicDlg;
            psLicDlg.m_strProduct = m_strProduct;
            psLicDlg.m_strLicenses.Format( TEXT( "%u" ), m_nLicenses );

            if ( psLicDlg.DoModal() != IDOK ) 
                return;
        }
        else
        {
            CPerSeatLicensingDialog psLicDlg;
            psLicDlg.m_strProduct = m_strProduct;

            if ( psLicDlg.DoModal() != IDOK ) 
                return;
        }

        NTSTATUS NtStatus = AddLicense();

        if ( STATUS_SUCCESS == NtStatus )                             
        {                                                     
            EndDialog(IDOK);
        }                                                     
        else if ( ( ERROR_CANCELLED != NtStatus ) && ( STATUS_CANCELLED != NtStatus ) )
        {
            AbortDialogIfNecessary(); // display error...
        }
    }
}


BOOL CNewLicenseDialog::RefreshCtrls()

/*++

Routine Description:

    Refreshs list of products available.

Arguments:

    None.

Return Values:

    Returns true if controls refreshed.

--*/

{
    int iProductInCB = CB_ERR;

    BeginWaitCursor(); // hourglass...

    if ( !m_strProduct.IsEmpty() )
    {
        iProductInCB = m_productList.AddString(m_strProduct);
    }
    else if ( ConnectServer() )
    {
        GetProductList();
    }

    m_productList.SetCurSel((iProductInCB == CB_ERR) ? 0 : iProductInCB);

    EndWaitCursor(); // hourglass...

    return TRUE;
}


void CNewLicenseDialog::OnDeltaPosSpin(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

    Notification handler for UDN_DELTAPOS.

Arguments:

    pNMHDR - notification header.
    pResult - return code.

Return Values:

    None.

--*/

{
    UpdateData(TRUE);   // get data

    m_nLicenses += ((NM_UPDOWN*)pNMHDR)->iDelta;
    
    if (m_nLicenses < 0)
    {
        m_nLicenses = 0;

        ::MessageBeep(MB_OK);      
    }
    else if (m_nLicenses > 999999)
    {
        m_nLicenses = 999999;

        ::MessageBeep(MB_OK);      
    }

    UpdateData(FALSE);  // set data

    GetDlgItem( IDOK )->EnableWindow( m_nLicenses == 0 ? FALSE : TRUE );

    *pResult = 1;   // handle ourselves...
}


void CNewLicenseDialog::OnUpdateQuantity()

/*++

Routine Description:

    Message handler for EN_UPDATE.

Arguments:

    None.

Return Values:

    None.

--*/

{
    long nLicensesOld = m_nLicenses;

    if (!IsQuantityValid())
    {
        m_nLicenses = nLicensesOld;

        UpdateData(FALSE);

        m_licEdit.SetFocus();
        m_licEdit.SetSel(0,-1);

        ::MessageBeep(MB_OK);      
    }

    GetDlgItem( IDOK )->EnableWindow( m_nLicenses == 0 ? FALSE : TRUE );
}


BOOL CNewLicenseDialog::IsQuantityValid()

/*++

Routine Description:

    Wrapper around UpdateData(TRUE).

Arguments:

    None.

Return Values:

    VT_BOOL.

--*/

{
    BOOL bIsValid;

    m_nLicensesMin = 1; // raise minimum...

    bIsValid = UpdateData(TRUE);

    m_nLicensesMin = 0; // reset minimum...

    return bIsValid;
}


BOOL CNewLicenseDialog::ConnectServer()

/*++

Routine Description:

   Establish a connection to the license service on the target server.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   if ( NULL == m_hLls )
   {
      LPTSTR   pszServerName;

      if ( m_strServerName.IsEmpty() )
      {
         pszServerName = NULL;
      }
      else
      {
         pszServerName = m_strServerName.GetBuffer( 0 );
      }

      NTSTATUS nt = ConnectTo( FALSE, pszServerName, &m_hLls );

      if ( NULL != pszServerName )
      {
         m_strServerName.ReleaseBuffer();
      }
   }

   if ( NULL == m_hLls )
   {
      theApp.DisplayLastError();
      EndDialog( IDABORT );
   }

   return ( NULL != m_hLls );
}


BOOL CNewLicenseDialog::ConnectEnterprise()

/*++

Routine Description:

   Establish a connection to the license service on the enterprise server
   of the target server.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   if ( NULL == m_hEnterpriseLls )
   {
      LPTSTR   pszServerName;

      if ( m_strServerName.IsEmpty() )
      {
         pszServerName = NULL;
      }
      else
      {
         pszServerName = m_strServerName.GetBuffer( 0 );
      }

      NTSTATUS nt = ConnectTo( !( m_dwEnterFlags & CCF_ENTER_FLAG_SERVER_IS_ES ), pszServerName, &m_hEnterpriseLls );
      
      if ( NULL != pszServerName )
      {
         m_strServerName.ReleaseBuffer();
      }
   }

   if ( NULL == m_hEnterpriseLls )
   {
      theApp.DisplayLastError();

      // not being able to connect to the enterprise
      // is not a fatal error
      // EndDialog( IDABORT );
   }

   return ( NULL != m_hEnterpriseLls );
}


NTSTATUS CNewLicenseDialog::ConnectTo( BOOL bUseEnterprise, LPTSTR pszServerName, PLLS_HANDLE phLls )

/*++

Routine Description:

   Establish a connection to the license service on the given server or that
   on the given server's enterprise server.

Arguments:

   bUseEnterprise (BOOL)
      If TRUE, connect to the enterprise server of the target server, not to
      the target server itself. 
   pszServerName (LPTSTR)
      The target server.  A NULL value indicates the local server.
   phLls (PLLS_HANDLE)
      On return, holds the handle to the standard LLS RPC.

Return Values:

   STATUS_SUCCESS or NT status code.

--*/

{
   NTSTATUS    nt;

   if ( !bUseEnterprise )
   {
      nt = ::LlsConnect( pszServerName, phLls );
   }
   else
   {
      PLLS_CONNECT_INFO_0  pConnect = NULL;

      nt = ::LlsConnectEnterprise( pszServerName, phLls, 0, (LPBYTE *) &pConnect );

      if ( STATUS_SUCCESS == nt )
      {
         ::LlsFreeMemory( pConnect );
      }
   }

   if ( STATUS_SUCCESS != nt )
   {
      *phLls = NULL;
   }

   theApp.SetLastLlsError( nt );

   return nt;
}


void CNewLicenseDialog::GetProductList()

/*++

Routine Description:

   Fill the product list box with the unsecure product names from the
   target server.

Arguments:

   None.

Return Values:

   None.

--*/

{
   if ( ConnectServer() )
   {
      // get list of products from license server, inserting into listbox
      m_productList.ResetContent();

      DWORD       dwResumeHandle = 0;
      DWORD       dwTotalEntries;
      DWORD       dwEntriesRead;
      NTSTATUS    nt;

      do
      {
         LPBYTE      pReturnBuffer = NULL;
         BOOL        bListProduct;

         nt = ::LlsProductEnum( m_hLls,
                                0,
                                &pReturnBuffer,
                                0x4000,
                                &dwEntriesRead,
                                &dwTotalEntries,
                                &dwResumeHandle );
         theApp.SetLastLlsError( nt );

         if ( ( STATUS_SUCCESS == nt ) || ( STATUS_MORE_ENTRIES == nt ) )
         {
            LLS_PRODUCT_INFO_0 *    pProductInfo = (LLS_PRODUCT_INFO_0 *) pReturnBuffer;

            for ( DWORD i=0; i < dwEntriesRead; i++ )
            {
               if ( !LlsCapabilityIsSupported( m_hLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
               {
                  // 3.51-level server; all products are unsecure, so add all
                  bListProduct = TRUE;
               }
               else
               {
                  // only list this product if it's unsecure
                  BOOL        bIsSecure;

                  bListProduct =    ( STATUS_SUCCESS != ::LlsProductSecurityGet( m_hLls, pProductInfo[i].Product, &bIsSecure ) )
                                 || ( !bIsSecure                                                                               );
               }

               if ( bListProduct )
               {
                  m_productList.AddString( pProductInfo[i].Product );
               }

               ::LlsFreeMemory( pProductInfo[i].Product );
            }

            ::LlsFreeMemory( pProductInfo );
         }

      } while ( STATUS_MORE_ENTRIES == nt );

      if ( STATUS_SUCCESS != nt )
      {
         // still connected?
         AbortDialogIfNecessary();
      }

      // restore previous edit selection
      UpdateData( FALSE );
   }
}


NTSTATUS CNewLicenseDialog::AddLicense()

/*++

Routine Description:

   Add the license described in the dialog.

Arguments:

   None.

Return Values:

   STATUS_SUCCESS
   ERROR_CANCELLED
   ERROR_NOT_ENOUGH_MEMORY
   NT status code
   Win error

--*/

{
   NTSTATUS    nt;

   if ( !ConnectServer() )
   {
      nt = ERROR_CANCELLED;
      // don't set last error
      // (preserve that set by the failed connect attempt)
   }
   else
   {
      LPTSTR   pszProductName = m_strProduct.GetBuffer(0);
      LPTSTR   pszServerName  = m_strServerName.GetBuffer(0);
      LPTSTR   pszComment     = m_strComment.GetBuffer(0);

      if ( ( NULL == pszProductName ) || ( NULL == pszServerName ) || ( NULL == pszComment ) )
      {
         nt = ERROR_NOT_ENOUGH_MEMORY;
         theApp.SetLastError( nt );
      }
      else
      {
         LLS_HANDLE  hLls              = m_hLls;

         if (    ( 0 != m_nLicenseMode )
              || ( m_dwEnterFlags & CCF_ENTER_FLAG_SERVER_IS_ES ) )
         {
            // per server mode, or per seat installed on ES; target server correct
            nt = STATUS_SUCCESS;
         }
         else
         {
            // per seat mode; make sure we're installing on the enterprise server
            PLLS_CONNECT_INFO_0  pConnectInfo = NULL;

            BeginWaitCursor();

            nt = ::LlsEnterpriseServerFind( pszServerName, 0, (LPBYTE *) &pConnectInfo );
            theApp.SetLastLlsError( nt );

            EndWaitCursor();

            if ( STATUS_SUCCESS == nt )
            {
               if ( lstrcmpi( pszServerName, pConnectInfo->EnterpriseServer ) )
               {
                  // not the enterprise server; make sure that per seat
                  // licenses are being sent to the right place (i.e., the
                  // enterprise server)
                  int         nResponse;
   
                  nResponse = AfxMessageBox( IDS_PER_SEAT_CHOSEN_SEND_TO_ENTERPRISE, MB_ICONINFORMATION | MB_OKCANCEL, 0 );
   
                  if ( IDOK == nResponse )
                  {
                     if ( !ConnectEnterprise() )
                     {
                        nt = ERROR_CANCELLED;
                        // don't set last error
                        // (preserve that set by the failed connect attempt)
                     }
                     else
                     {
                        hLls = m_hEnterpriseLls;
                     }
                  }
                  else
                  {
                     nt = ERROR_CANCELLED; 
                     theApp.SetLastError( nt );
                  }
               }
            }

            // free memory allocated for us by Lls
            LlsFreeMemory( pConnectInfo );
         }

         if ( STATUS_SUCCESS == nt )
         {
            // we've determined the real target server

            // get name of user entering the certificate
            TCHAR       szUserName[ 64 ];
            DWORD       cchUserName;
            BOOL        ok;
   
            cchUserName = sizeof( szUserName ) / sizeof( *szUserName );
            ok = GetUserName( szUserName, &cchUserName );
      
            if ( !ok )
            {
               nt = GetLastError();
               theApp.SetLastError( nt );
            }
            else
            {
               // enter certificate into system
               if ( 0 == m_nLicenseMode )
               {
                  // add 3.51 style per seat license
                  LLS_LICENSE_INFO_0   lic;
         
                  ZeroMemory( &lic, sizeof( lic ) );
      
                  lic.Product       = pszProductName;
                  lic.Comment       = pszComment;
                  lic.Admin         = szUserName;
                  lic.Quantity      = m_nLicenses;
                  lic.Date          = 0;

                  BeginWaitCursor();

                  nt = ::LlsLicenseAdd( hLls, 0, (LPBYTE) &lic );
                  theApp.SetLastLlsError( nt );

                  EndWaitCursor();
               }
               else
               {
                  // add 3.51 style per server license (blek)
                  HKEY  hKeyLocalMachine;

                  nt = RegConnectRegistry( pszServerName, HKEY_LOCAL_MACHINE, &hKeyLocalMachine );

                  if ( ERROR_SUCCESS != nt )
                  {
                     theApp.SetLastError( nt );
                  }
                  else
                  {
                     HKEY  hKeyLicenseInfo;

                     nt = RegOpenKeyEx( hKeyLocalMachine, TEXT( "SYSTEM\\CurrentControlSet\\Services\\LicenseInfo" ), 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_SET_VALUE, &hKeyLicenseInfo );

                     if ( ERROR_SUCCESS != nt )
                     {
                        theApp.SetLastError( nt );
                     }
                     else
                     {
                        BOOL     bFoundKey = FALSE;
                        DWORD    iSubKey = 0;

                        // okay, now we have to find the product corresponding to this display name (ickie)
                        do
                        {
                           TCHAR    szKeyName[ 128 ];
                           DWORD    cchKeyName = sizeof( szKeyName ) / sizeof( *szKeyName );
                                 
                           nt = RegEnumKeyEx( hKeyLicenseInfo, iSubKey++, szKeyName, &cchKeyName, NULL, NULL, NULL, NULL );

                           if ( ERROR_SUCCESS == nt )
                           {
                              HKEY  hKeyProduct;

                              nt = RegOpenKeyEx( hKeyLicenseInfo, szKeyName, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hKeyProduct );

                              if ( ERROR_SUCCESS == nt )
                              {
                                 DWORD    dwType;
                                 TCHAR    szDisplayName[ 128 ];
                                 DWORD    cbDisplayName = sizeof( szDisplayName );

                                 nt = RegQueryValueEx( hKeyProduct, TEXT( "DisplayName" ), NULL, &dwType, (LPBYTE) szDisplayName, &cbDisplayName );

                                 if (    ( ERROR_SUCCESS == nt )
                                      && ( REG_SZ == dwType )
                                      && !lstrcmpi( szDisplayName, pszProductName ) )
                                 {
                                    // YES!  we found the product key
                                    // now add the concurrent licenses
                                    bFoundKey = TRUE;

                                    DWORD    dwConcurrentLimit;
                                    DWORD    cbConcurrentLimit = sizeof( dwConcurrentLimit );

                                    nt = RegQueryValueEx( hKeyProduct, TEXT( "ConcurrentLimit" ), NULL, &dwType, (LPBYTE) &dwConcurrentLimit, &cbConcurrentLimit );

                                    if ( ( ERROR_FILE_NOT_FOUND == nt ) || ( ERROR_PATH_NOT_FOUND == nt ) )
                                    {
                                       // okay if the value doesn't exist
                                       dwConcurrentLimit = 0;
                                       nt = ERROR_SUCCESS;
                                    }

                                    if ( ERROR_SUCCESS == nt )
                                    {
                                       if ( (LONG)dwConcurrentLimit + (LONG)m_nLicenses > 0 )
                                       {
                                          dwConcurrentLimit += m_nLicenses;

                                          nt = RegSetValueEx( hKeyProduct, TEXT( "ConcurrentLimit" ), 0, REG_DWORD, (LPBYTE) &dwConcurrentLimit, sizeof( dwConcurrentLimit ) );
                                       }
                                    }
                                 }

                                 RegCloseKey( hKeyProduct );
                              }

                              // even if an error occurred while trying to find the right product key,
                              // we should continue to search the rest
                              if ( !bFoundKey )
                              {
                                 nt = ERROR_SUCCESS;
                              }
                           }
                        } while ( !bFoundKey && ( ERROR_SUCCESS == nt ) );

                        if ( ERROR_NO_MORE_ITEMS == nt )
                        {
                           // trying to install per server licenses for this box, but
                           // the application isn't installed locally
                           AfxMessageBox( IDS_PER_SERVER_APP_NOT_INSTALLED, MB_ICONSTOP | MB_OK, 0 );

                           nt = ERROR_CANCELLED;
                        }
                        else if ( ERROR_SUCCESS != nt )
                        {
                           theApp.SetLastError( nt );
                        }

                        RegCloseKey( hKeyLicenseInfo );
                     }

                     RegCloseKey( hKeyLocalMachine );
                  }
               }
            }
         }
      }

      if ( NULL != pszProductName )    m_strProduct.ReleaseBuffer();
      if ( NULL != pszServerName )     m_strServerName.ReleaseBuffer();
      if ( NULL != pszComment )        m_strComment.ReleaseBuffer();
   }

   return nt;
}


void CNewLicenseDialog::OnHelp() 

/*++

Routine Description:

   Handler for help button click.

Arguments:

   None.

Return Values:

   None.

--*/

{
   WinHelp( IDD, HELP_CONTEXT );   
}


void CNewLicenseDialog::WinHelp(DWORD dwData, UINT nCmd) 

/*++

Routine Description:

   Call WinHelp for this dialog.

Arguments:

   dwData (DWORD)
   nCmd (UINT)

Return Values:

   None.

--*/

{
   ::HtmlHelp(m_hWnd, L"liceconcepts.chm", HH_DISPLAY_TOPIC,0);
/*
   BOOL ok = ::WinHelp( m_hWnd, theApp.GetHelpFileName(), nCmd, dwData );
   ASSERT( ok );
*/
}


void CNewLicenseDialog::OnDestroy()

/*++

Routine Description:

   Handler for WM_DESTROY.

Arguments:

   None.

Return Values:

   None.

--*/

{
   ::WinHelp( m_hWnd, theApp.GetHelpFileName(), HELP_QUIT, 0 );
   
   CDialog::OnDestroy();
}


void CNewLicenseDialog::OnPerSeat() 

/*++

Routine Description:

   Handler for per seat radio button selection.

Arguments:

   None.

Return Values:

   None.

--*/

{
   GetDlgItem( IDC_NEW_LICENSE_COMMENT )->EnableWindow( TRUE );
}


void CNewLicenseDialog::OnPerServer() 

/*++

Routine Description:

   Handler for per server radio button selection.

Arguments:

   None.

Return Values:

   None.

--*/

{
   GetDlgItem( IDC_NEW_LICENSE_COMMENT )->EnableWindow( FALSE );
}


DWORD CNewLicenseDialog::CertificateEnter( LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags )

/*++

Routine Description:

   Display a dialog allowing the user to enter a license certificate
   into the system with no certificate (3.51-style).

Arguments:

   pszServerName (LPCSTR)
      Name of the server for which licenses are to be installed.  Note that
      this may not be the same as the server on which licenses are actually
      installed, as, for example, per seat licenses are always installed on
      the enterprise server.  A NULL value indicates the local server.
   pszProductName (LPCSTR)
      Product for which licenses are to be installed.  A NULL value indicates
      that the user should be allowed to choose.
   pszVendor (LPCSTR)
      Name of the vendor of the product.  This value should be NULL if
      pszProductName is NULL, and should be non-NULL if pszProductName is
      non-NULL.
   dwFlags (DWORD)
      A bitfield containing one or more of the following:
         CCF_ENTER_FLAG_PER_SEAT_ONLY
            Allow the user to enter only per seat licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SERVER_ONLY.
         CCF_ENTER_FLAG_PER_SERVER_ONLY
            Allow the user to enter only per server licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SEAT_ONLY.

Return Value:

   ERROR_SUCCESS     (A certificate was successfully entered into the system.)
   ERROR_CANCELLED   (The user cancelled without installing a certificate.)
   other Win error

--*/

{
   DWORD dwError;

   m_strServerName  = pszServerName  ? pszServerName  : "";
   m_strProduct     = pszProductName ? pszProductName : "";
   // pszVendor is not used
   m_dwEnterFlags   = dwFlags;

   if ( IDOK == DoModal() )
   {
      dwError = ERROR_SUCCESS;
   }
   else
   {
      dwError = ERROR_CANCELLED;
   }

   return dwError;
}


DWORD CNewLicenseDialog::CertificateRemove( LPCSTR pszServerName, DWORD dwFlags, PLLS_LICENSE_INFO_1 pLicenseInfo )

/*++

Routine Description:

   Remove licenses previously installed via 3.51 or CertificateEnter().

Arguments:

   pszServerName (LPCSTR)
      Name of the server on which licenses are to be removed.  A NULL value
      indicates the local server.
   dwFlags (DWORD)
      Certificate removal options.  As of this writing, no flags are
      supported.
   dwLicenseLevel (DWORD)
      Level of the LLS_LICENSE_INFO_X structure pointed to by pvLicenseInfo.
   pvLicenseInfo (LPVOID)
      Points to a LLS_LICENSE_INFO_X (where X is determined by dwLicenseLevel)
      describing the licenses to be removed.

Return Value:

   ERROR_SUCCESS
   Win error

--*/

{
   DWORD    dwError;

   m_strServerName  = pszServerName  ? pszServerName  : "";
   m_strProduct     = pLicenseInfo->Product;

   if ( !ConnectServer() )
   {
      dwError = theApp.GetLastError();
      // error message already displayed
   }
   else
   {
      if ( LLS_LICENSE_MODE_ALLOW_PER_SERVER & pLicenseInfo->AllowedModes )
      {
         // remove per server licenses
         HKEY  hKeyLocalMachine;

         LPTSTR pszUniServerName = m_strServerName.GetBuffer(0);

         if ( NULL == pszUniServerName )
         {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
         }
         else
         {
            dwError = RegConnectRegistry( pszUniServerName, HKEY_LOCAL_MACHINE, &hKeyLocalMachine );

            if ( ERROR_SUCCESS != dwError )
            {
               theApp.SetLastError( dwError );
            }
            else
            {
               HKEY  hKeyLicenseInfo;

               dwError = RegOpenKeyEx( hKeyLocalMachine, TEXT( "SYSTEM\\CurrentControlSet\\Services\\LicenseInfo" ), 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_SET_VALUE, &hKeyLicenseInfo );

               if ( ERROR_SUCCESS != dwError )
               {
                  theApp.SetLastError( dwError );
               }
               else
               {
                  BOOL     bFoundKey = FALSE;
                  DWORD    iSubKey = 0;

                  // okay, now we have to find the product corresponding to this display name (ickie)
                  do
                  {
                     TCHAR    szKeyName[ 128 ];
                     DWORD    cchKeyName = sizeof( szKeyName ) / sizeof( *szKeyName );
                        
                     dwError = RegEnumKeyEx( hKeyLicenseInfo, iSubKey++, szKeyName, &cchKeyName, NULL, NULL, NULL, NULL );

                     if ( ERROR_SUCCESS == dwError )
                     {
                        HKEY  hKeyProduct;

                        dwError = RegOpenKeyEx( hKeyLicenseInfo, szKeyName, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hKeyProduct );

                        if ( ERROR_SUCCESS == dwError )
                        {
                           DWORD    dwType;
                           TCHAR    szDisplayName[ 128 ];
                           DWORD    cbDisplayName = sizeof( szDisplayName );

                           dwError = RegQueryValueEx( hKeyProduct, TEXT( "DisplayName" ), NULL, &dwType, (LPBYTE) szDisplayName, &cbDisplayName );

                           if (    ( ERROR_SUCCESS == dwError )
                                && ( REG_SZ == dwType )
                                && !lstrcmpi( szDisplayName, m_strProduct ) )
                           {
                              // YES!  we found the product key
                              // now subtract the concurrent licenses
                              bFoundKey = TRUE;

                              DWORD    dwConcurrentLimit;
                              DWORD    cbConcurrentLimit = sizeof( dwConcurrentLimit );

                              dwError = RegQueryValueEx( hKeyProduct, TEXT( "ConcurrentLimit" ), NULL, &dwType, (LPBYTE) &dwConcurrentLimit, &cbConcurrentLimit );

                              if ( ( ERROR_SUCCESS == dwError ) && ( REG_DWORD == dwType ) )
                              {
                                 if ( (LONG)dwConcurrentLimit + (LONG)m_nLicenses > 0 )
                                 {
                                    if ( pLicenseInfo->Quantity > (LONG)dwConcurrentLimit )
                                    {
                                       dwConcurrentLimit = 0;
                                    }
                                    else
                                    {
                                       dwConcurrentLimit -= pLicenseInfo->Quantity;
                                    }

                                    dwError = RegSetValueEx( hKeyProduct, TEXT( "ConcurrentLimit" ), 0, REG_DWORD, (LPBYTE) &dwConcurrentLimit, sizeof( dwConcurrentLimit ) );
                                 }
                              }
                           }

                           RegCloseKey( hKeyProduct );
                        }

                        // even if an error occurred while trying to find the right product key,
                        // we should continue to search the rest
                        if ( !bFoundKey )
                        {
                           dwError = ERROR_SUCCESS;
                        }
                     }
                  } while ( !bFoundKey && ( ERROR_SUCCESS == dwError ) );

                  if ( ERROR_SUCCESS != dwError )
                  {
                     theApp.SetLastError( dwError );
                  }

                  RegCloseKey( hKeyLicenseInfo );
               }

               RegCloseKey( hKeyLocalMachine );
            }
         }
      }
      else
      {
         // remove per seat licenses
         CString  strComment;
         strComment.LoadString( IDS_NO_REMOVE_COMMENT );

         LPTSTR   pszUniProductName = m_strProduct.GetBuffer(0);
         LPTSTR   pszUniComment     = strComment.GetBuffer(0);

         if ( ( NULL == pszUniProductName ) || ( NULL == pszUniComment ) )
         {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
         }
         else
         {
            TCHAR szUserName[ 256 ];
            DWORD cchUserName = sizeof( szUserName ) / sizeof( *szUserName );

            BOOL  ok = GetUserName( szUserName, &cchUserName );

            if ( !ok )
            {
               dwError = GetLastError();
            }
            else
            {
               NTSTATUS             nt;
               LLS_LICENSE_INFO_0   lic;
      
               ZeroMemory( &lic, sizeof( lic ) );

               lic.Product       = pszUniProductName;
               lic.Comment       = pszUniComment;
               lic.Admin         = szUserName;
               lic.Quantity      = -pLicenseInfo->Quantity;
               lic.Date          = 0;

               BeginWaitCursor();

               nt = ::LlsLicenseAdd( m_hLls, 0, (LPBYTE) &lic );
               theApp.SetLastLlsError( nt );

               EndWaitCursor();

               dwError = (DWORD) nt;
            }
         }

         if ( NULL != pszUniProductName )    m_strProduct.ReleaseBuffer();
         if ( NULL != pszUniComment     )    strComment.ReleaseBuffer();
      }

      if ( ( ERROR_SUCCESS != dwError ) && ( ERROR_CANCELLED != dwError ) )
      {
         theApp.SetLastError( dwError );
         theApp.DisplayLastError();
      }
   }

   return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\psrvdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    psrvdlg.h

Abstract:

    Per server confirmation dialog.

Author:

    Don Ryan (donryan) 28-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 15-Dec-1995
        Robbed from LLSMGR.

--*/

#ifndef _PSRVDLG_H_
#define _PSRVDLG_H_

class CPerServerLicensingDialog : public CDialog
{
public:
    CString m_strProduct;
    CString m_strLicenses;

public:
    CPerServerLicensingDialog(CWnd* pParent = NULL);   

    //{{AFX_DATA(CPerServerLicensingDialog)
    enum { IDD = IDD_PER_SERVER_LICENSING };
    CButton m_agreeBtn;
    CButton m_okBtn;
    CString m_strStaticClients;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CPerServerLicensingDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);   
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CPerServerLicensingDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnAgree();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _PSRVDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\pseatdlg.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    pseatdlg.h

Abstract:

    Per seat confirmation dialog.

Author:

    Don Ryan (donryan) 28-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 15-Dec-1995
        Robbed from LLSMGR.

--*/

#ifndef _PSEATDLG_H_
#define _PSEATDLG_H_

class CPerSeatLicensingDialog : public CDialog
{
public:
    CString m_strProduct;

public:
    CPerSeatLicensingDialog(CWnd* pParent = NULL);   

    //{{AFX_DATA(CPerSeatLicensingDialog)
    enum { IDD = IDD_PER_SEAT_LICENSING };
    CButton m_agreeBtn;
    CButton m_okBtn;
    CString m_strStaticClients;
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CPerSeatLicensingDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX); 
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CPerSeatLicensingDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnAgree();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // _PSEATDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\psrvdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    psrvdlg.cpp

Abstract:

    Per server confirmation dialog.

Author:

    Don Ryan (donryan) 28-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 15-Dec-1995
        Robbed from LLSMGR.

--*/

#include "stdafx.h"
#include "ccfapi.h"
#include "psrvdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CPerServerLicensingDialog, CDialog)
    //{{AFX_MSG_MAP(CPerServerLicensingDialog)
    ON_BN_CLICKED(IDC_PER_SERVER_AGREE, OnAgree)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CPerServerLicensingDialog::CPerServerLicensingDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CPerServerLicensingDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CPerServerLicensingDialog)
    m_strStaticClients = _T("");
    //}}AFX_DATA_INIT
}


void CPerServerLicensingDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPerServerLicensingDialog)
    DDX_Control(pDX, IDC_PER_SERVER_AGREE, m_agreeBtn);
    DDX_Control(pDX, IDOK, m_okBtn);
    DDX_Text(pDX, IDC_PER_SERVER_STATIC_CLIENTS, m_strStaticClients);
    //}}AFX_DATA_MAP
}


BOOL CPerServerLicensingDialog::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    AfxFormatString2(
        m_strStaticClients, 
        IDS_PER_SERVER_LICENSING_1, 
        m_strLicenses, 
        m_strProduct
        );

    CDialog::OnInitDialog();
    
    m_agreeBtn.SetCheck(0);
    m_okBtn.EnableWindow(FALSE);

    return TRUE;  
}


void CPerServerLicensingDialog::OnAgree() 

/*++

Routine Description:

    Toggle okay button.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_okBtn.EnableWindow(!m_okBtn.IsWindowEnabled());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\pseatdlg.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    pseatdlg.cpp

Abstract:

    Per seat confirmation dialog.

Author:

    Don Ryan (donryan) 28-Feb-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 15-Dec-1995
        Robbed from LLSMGR.

--*/

#include "stdafx.h"
#include "ccfapi.h"
#include "pseatdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CPerSeatLicensingDialog, CDialog)
    //{{AFX_MSG_MAP(CPerSeatLicensingDialog)
    ON_BN_CLICKED(IDC_PER_SEAT_AGREE, OnAgree)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CPerSeatLicensingDialog::CPerSeatLicensingDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CPerSeatLicensingDialog::IDD, pParent)

/*++

Routine Description:

    Constructor for dialog.

Arguments:

    pParent - owner window.

Return Values:

    None.

--*/

{
    //{{AFX_DATA_INIT(CPerSeatLicensingDialog)
    m_strStaticClients = _T("");
    //}}AFX_DATA_INIT

    m_strProduct = _T("");
}


void CPerSeatLicensingDialog::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

    Called by framework to exchange dialog data.

Arguments:

    pDX - data exchange object.

Return Values:

    None.

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPerSeatLicensingDialog)
    DDX_Control(pDX, IDC_PER_SEAT_AGREE, m_agreeBtn);
    DDX_Control(pDX, IDOK, m_okBtn);
    DDX_Text(pDX, IDC_PER_SEAT_STATIC_CLIENTS, m_strStaticClients);
    //}}AFX_DATA_MAP
}


BOOL CPerSeatLicensingDialog::OnInitDialog() 

/*++

Routine Description:

    Message handler for WM_INITDIALOG.

Arguments:

    None.

Return Values:

    Returns false if focus set manually.

--*/

{
    AfxFormatString1(
        m_strStaticClients, 
        IDS_PER_SEAT_LICENSING_1, 
        m_strProduct
        );

    CDialog::OnInitDialog();
    
    m_agreeBtn.SetCheck(0);
    m_okBtn.EnableWindow(FALSE);

    return TRUE;  
}


void CPerSeatLicensingDialog::OnAgree() 

/*++

Routine Description:

    Toggle okay button.

Arguments:

    None.

Return Values:

    None.

--*/

{
    m_okBtn.EnableWindow(!m_okBtn.IsWindowEnabled());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\paper.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   paper.h

Abstract:

   Paper certificate dialog prototype.

Author:

   Jeff Parham (jeffparh) 13-Dec-1995

Revision History:

--*/


// constrained by number of bits allowed for it in KeyCode (see below)
#define  MAX_NUM_LICENSES  ( 4095 )

// XOR mask for key code value; this is so that the high bits that are
// usually set for the key code need not be entered -- they only need
// be entered if the high bits are _not_ set
#define  KEY_CODE_MASK     ( 0xF0000000 )


class CPaperSourceDlg : public CDialog
{
// Construction
public:
   CPaperSourceDlg(CWnd* pParent = NULL);   // standard constructor
   ~CPaperSourceDlg();

   DWORD CertificateEnter(  LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags );
   DWORD CertificateRemove( LPCSTR pszServerName, DWORD dwFlags, PLLS_LICENSE_INFO_1 pLicenseInfo );

   BOOL     ConnectServer();
   BOOL     ConnectEnterprise();
   NTSTATUS ConnectTo( BOOL bUseEnterprise, CString strServerName, PLLS_HANDLE phLls );
   void     AbortDialogIfNecessary();

   void     GetProductList();

   DWORD    ComputeActivationCode();
   NTSTATUS AddLicense();

   BOOL        m_bProductListRetrieved;
   DWORD       m_dwEnterFlags;
   
   CString     m_strServerName;

   LLS_HANDLE  m_hLls;
   LLS_HANDLE  m_hEnterpriseLls;

   // KeyCode format:
   //
   // 31....................................0
   // | 2 | 2 |       16       |     12     |
   //   A   B          C              D
   //
   // ModesAllowed   = A
   //    Bit field: bit 0 = allow per seat
   //               bit 1 = allow per server
   //
   // FlipsAllowed   = B
   //    Bit field: bit 0 = allow flip from per seat
   //               bit 1 = allow flip from per server
   //    (THIS IS CURRENTLY UNIMPLEMENTED.)
   //
   // ExpirationDate = C
   //    Bit field: bits 0-6   = years since 1980
   //               bits 7-10  = month (1-12)
   //               bits 11-15 = day (1-31)
   //
   // NumLicenses = D

   DWORD KeyCodeToNumLicenses(    DWORD dwKeyCode );
   DWORD KeyCodeToFlipsAllowed(   DWORD dwKeyCode );
   DWORD KeyCodeToModesAllowed(   DWORD dwKeyCode );
   DWORD KeyCodeToExpirationDate( DWORD dwKeyCode );

// Dialog Data
   //{{AFX_DATA(CPaperSourceDlg)
   enum { IDD = IDD_CERT_SOURCE_PAPER };
   CSpinButtonCtrl   m_spinLicenses;
   CComboBox         m_cboxProductName;
   CString           m_strActivationCode;
   CString           m_strKeyCode;
   CString           m_strSerialNumber;
   CString           m_strVendor;
   CString           m_strProductName;
   CString           m_strComment;
   int               m_nDontInstallAllLicenses;
   int               m_nLicenses;
   int               m_nLicenseMode;
   //}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CPaperSourceDlg)
   public:
   virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   void EnableOrDisableOK();

   // Generated message map functions
   //{{AFX_MSG(CPaperSourceDlg)
   afx_msg void OnUpdateActivationCode();
   afx_msg void OnUpdateKeyCode();
   afx_msg void OnUpdateVendor();
   virtual BOOL OnInitDialog();
   virtual void OnOK();
   afx_msg void OnUpdateSerialNumber();
   afx_msg void OnUpdateProductName();
   afx_msg void OnDropDownProductName();
   afx_msg void OnHelp();
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   afx_msg void OnDestroy();
   afx_msg void OnAllLicenses();
   afx_msg void OnSomeLicenses();
   afx_msg void OnDeltaPosSpinLicenses(NMHDR* pNMHDR, LRESULT* pResult);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};

///////////////////////////////////

inline DWORD CPaperSourceDlg::KeyCodeToNumLicenses( DWORD dwKeyCode )
   { return ( dwKeyCode & 0x00000FFF );   }

inline DWORD CPaperSourceDlg::KeyCodeToModesAllowed( DWORD dwKeyCode )
   { return ( dwKeyCode >> 30 ); }

inline DWORD CPaperSourceDlg::KeyCodeToFlipsAllowed( DWORD dwKeyCode )
   { return ( ( dwKeyCode >> 28 ) & 0x3 );   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\remdlg.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   paper.cpp

Abstract:

   Remove licenses dialog prototype.

Author:

   Jeff Parham (jeffparh) 13-Dec-1995

Revision History:

--*/


class CCertRemoveSelectDlg : public CDialog
{
public:
   CCertRemoveSelectDlg(CWnd* pParent = NULL);   // standard constructor
   ~CCertRemoveSelectDlg();

   void UpdateSpinControlRange();
   BOOL LoadImages();

// Dialog Data
   //{{AFX_DATA(CCertRemoveSelectDlg)
   enum { IDD = IDD_CERT_REMOVE_SELECT };
   CSpinButtonCtrl      m_spinLicenses;
   CListCtrl            m_listCertificates;
   int                  m_nLicenses;
   //}}AFX_DATA

   CObArray             m_licenseArray;
   LLS_HANDLE           m_hLls;
   BOOL                 m_bLicensesRefreshed;
   CString              m_strSourceToUse;
   CString              m_strProductName;
   CString              m_strServerName;
   CString              m_strVendor;
   CImageList           m_smallImages;
   DWORD                m_dwRemoveFlags;

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CCertRemoveSelectDlg)
   public:
   virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

public:
   DWORD    CertificateRemove( LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags, LPCSTR pszSourceToUse );

   void     ResetLicenses();
   BOOL     RefreshLicenses();
   BOOL     RefreshCertificateList();
   DWORD    RemoveSelectedCertificate();

   BOOL     ConnectServer();
   NTSTATUS ConnectTo( LPTSTR pszServerName, PLLS_HANDLE phLls );

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CCertRemoveSelectDlg)
   afx_msg void OnHelp();
   afx_msg void OnColumnClickCertificateList(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg void OnGetDispInfoCertificateList(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg void OnDeltaPosSpinLicenses(NMHDR* pNMHDR, LRESULT* pResult);
   virtual void OnOK();
   virtual BOOL OnInitDialog();
   afx_msg void OnDblClkCertificateList(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg void OnReturnCertificateList(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg void OnDestroy();
   afx_msg void OnClickCertificateList(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg void OnKeyDownCertificateList(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg void OnRefresh();
   afx_msg LRESULT OnHelpCmd( WPARAM , LPARAM );
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};

#define LVID_REMOVE_SERIAL_NUMBER   0
#define LVID_REMOVE_PRODUCT_NAME    1
#define LVID_REMOVE_LICENSE_MODE    2
#define LVID_REMOVE_NUM_LICENSES    3
#define LVID_REMOVE_SOURCE          4

#define LVID_REMOVE_TOTAL_COLUMNS   5

#define LVCX_REMOVE_SERIAL_NUMBER   20
#define LVCX_REMOVE_PRODUCT_NAME    35
#define LVCX_REMOVE_LICENSE_MODE    16
#define LVCX_REMOVE_NUM_LICENSES    10
#define LVCX_REMOVE_SOURCE          -1

int CALLBACK CompareLicenses(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\srclist.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   srclist.h

Abstract:

   Certificate source list object prototype.

Author:

   Jeff Parham (jeffparh) 15-Dec-1995

Revision History:

--*/


typedef struct _CERT_SOURCE_INFO
{
   TCHAR szName[ 64 ];
   TCHAR szDisplayName[ 64 ];
   TCHAR szImagePath[ _MAX_PATH ];
} CERT_SOURCE_INFO, *PCERT_SOURCE_INFO;

class CCertSourceList
{
public:
   CCertSourceList();
   ~CCertSourceList();

   BOOL                 RefreshSources();
   LPCTSTR              GetSourceName( int nIndex );
   LPCTSTR              GetSourceDisplayName( int nIndex );
   LPCTSTR              GetSourceImagePath( int nIndex );
   int                  GetNumSources();

private:
   BOOL                 RemoveSources();
   BOOL                 AddSource( PCERT_SOURCE_INFO pcsiNewSource );
   
   PCERT_SOURCE_INFO *  m_ppcsiSourceList;
   DWORD                m_dwNumSources;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\resource.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1999
//
// File:        resource.h
//
// Contents:    
//
// History:     
//              
//              
//---------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CCFApi.rc
//

// special case error messages
#define IDS_ERROR_DROPPED_LINK                           2000
#define IDS_ERROR_NO_RPC_SERVER                          2001
#define IDS_ERROR_UNSUCCESSFUL                           2002
#define IDS_ERROR_DOWNLEVEL_SERVER                       2003
#define IDS_ERROR_ACCESS_DENIED                          2004
#define IDS_ERROR_CERTIFICATE_EXPIRED                    2005

// dialog messages
#define IDS_BAD_ACTIVATION_CODE                          2100
#define IDS_NO_PRODUCT_SEND_TO_ENTERPRISE                2101
#define IDS_PER_SEAT_SEND_TO_ENTERPRISE                  2102
#define IDS_PER_SERVER_APP_NOT_INSTALLED                 2103
#define IDS_PER_SEAT_CHOSEN_SEND_TO_ENTERPRISE           2104
#define IDS_NOT_ENOUGH_LICENSES_ON_CERTIFICATE           2105
#define IDS_INVALID_NUM_LICENSES                         2106
#define IDS_REMOVE_CERTIFICATE_CONFIRM                   2107
#define IDS_CERT_SOURCE_NOT_AVAILABLE                    2108
#define IDS_ENTERPRISE_SERVER_BACKLEVEL_CANT_ADD_CERT    2109
#define IDS_LOCAL_LICENSES_ALREADY_INSTALLED             2110
#define IDS_NET_CERTIFICATE_TARGET_ENTRY                 2111
#define IDS_NET_LICENSES_ALREADY_INSTALLED_ON            2112
#define IDS_NET_LICENSES_ALREADY_INSTALLED               2113
#define IDS_PER_SEAT_LICENSING_1                         2114
#define IDS_PER_SERVER_LICENSING_1                       2115
#define IDS_REMOVE_INVALID_NUM_LICENSES                  2116
#define IDS_LICENSE_MODE_NOT_ALLOWED                     2117
#define IDS_NO_PRODUCT_CERTIFICATE_SOURCES               2118

// certificate removal comments
#define IDS_NO_REMOVE_COMMENT                            2200
#define IDS_PAPER_REMOVE_COMMENT                         2201

// dialog data values
#define IDS_NO_CERTIFICATE_SOURCE_NAME                   2300
#define IDS_SOURCE_NONE                                  2301
#define IDS_LICENSE_MODE_EITHER                          2302
#define IDS_LICENSE_MODE_PER_SEAT                        2303
#define IDS_LICENSE_MODE_PER_SERVER                      2304
#define IDS_LICENSE_MODE_UNKNOWN                         2305

// dialog data headers
#define IDS_SERIAL_NUMBER                                2400
#define IDS_PRODUCT_NAME                                 2401
#define IDS_QUANTITY                                     2402
#define IDS_SOURCE                                       2403
#define IDS_LICENSE_MODE                                 2404

// icons
#define IDI_LICENSE                                      2500
#define IDI_PHONE                                        2501
#define IDI_MY_WARNING                                   2502

// dialogs
#define IDD_CERT_SOURCE_SELECT                           2600
#define IDD_CERT_SOURCE_PAPER                            2601
#define IDD_CERT_REMOVE_SELECT                           2602
#define IDD_NEW_LICENSE                                  2603
#define IDD_PER_SERVER_LICENSING                         2604
#define IDD_PER_SEAT_LICENSING                           2605

// bitmaps
#define IDB_SMALL_ICONS                                  2700

// dialog controls
#define IDC_CERT_SOURCE                                  2800
#define IDC_PRODUCT_NAME                                 2801
#define IDC_PER_SEAT                                     2802
#define IDC_VENDOR                                       2803
#define IDC_PER_SERVER                                   2804
#define IDC_SERIAL_NUMBER                                2805
#define IDC_KEY_CODE                                     2806
#define IDC_ALL_LICENSES                                 2807
#define IDC_ACTIVATION_CODE                              2808
#define IDC_COMMENT                                      2809
#define IDC_MY_HELP                                      2810
#define IDC_SOME_LICENSES                                2811
#define IDC_SPIN_LICENSES                                2812
#define IDC_NUM_LICENSES                                 2813
#define IDC_CERTIFICATE_LIST                             2814
#define IDC_NEW_LICENSE_PRODUCT                          2815
#define IDC_NEW_LICENSE_COMMENT                          2816
#define IDC_NEW_LICENSE_QUANTITY                         2817
#define IDC_NEW_LICENSE_SPIN                             2818
#define IDC_PER_SERVER_STATIC_CLIENTS                    2819
#define IDC_PER_SERVER_AGREE                             2820
#define IDC_PER_SEAT_AGREE                               2821
#define IDC_PER_SEAT_STATIC_CLIENTS                      2822
#define IDC_REFRESH                                      2823

#define IDS_CLOSETEXT                                    2825
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\srclist.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   srclist.cpp

Abstract:

   Certificate source list object implementation.

Author:

   Jeff Parham (jeffparh) 15-Dec-1995

Revision History:

--*/


#include "stdafx.h"
#include "srclist.h"

// key name under which the individual source key names may be found
#define     KEY_CERT_SOURCE_LIST       "Software\\LSAPI\\Microsoft\\CertificateSources"

// value name for the path to the certificate source DLL (REG_EXPAND_SZ)
#define     VALUE_CERT_SOURCE_PATH     "ImagePath"

// value name for the display name of the certificate source
#define     VALUE_CERT_DISPLAY_NAME    "DisplayName"


CCertSourceList::CCertSourceList()

/*++

Routine Description:

   Constructor for object.

Arguments:

   None.

Return Values:

   None.

--*/

{
   m_dwNumSources    = 0;
   m_ppcsiSourceList    = NULL;

   RefreshSources();
}


CCertSourceList::~CCertSourceList()

/*++

Routine Description:

   Destructor for dialog.

Arguments:

   None.

Return Values:

   None.

--*/

{
   RemoveSources();
}


BOOL CCertSourceList::RefreshSources()

/*++

Routine Description:

   Refresh source list from configuration stored in the registry.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   LONG              lError;
   LONG              lEnumError;
   HKEY           hKeyCertSourceList;
   int               iSubKey;
   HKEY           hKeyCertSource;
   DWORD          cb;
   BOOL           ok;
   PCERT_SOURCE_INFO pcsiSourceInfo;
   DWORD          cch;
   TCHAR          szExpImagePath[ _MAX_PATH ];

   RemoveSources();
   
   lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT( KEY_CERT_SOURCE_LIST ), 0, KEY_READ, &hKeyCertSourceList );
   
   if ( ERROR_SUCCESS == lError )
   {
      iSubKey = 0;

      do
      {
         ok = FALSE;

         pcsiSourceInfo = (PCERT_SOURCE_INFO) LocalAlloc( LPTR, sizeof( *pcsiSourceInfo ) );

         if ( NULL != pcsiSourceInfo )
         {
            // determine next certificate source
            cch = sizeof( pcsiSourceInfo->szName ) / sizeof( pcsiSourceInfo->szName[0] );
            lEnumError = RegEnumKeyEx( hKeyCertSourceList, iSubKey, pcsiSourceInfo->szName, &cch, NULL, NULL, NULL, NULL );
            iSubKey++;

            if ( ERROR_SUCCESS == lError )
            {
               // open certificate source's key
               lError = RegOpenKeyEx( hKeyCertSourceList, pcsiSourceInfo->szName, 0, KEY_READ, &hKeyCertSource );

               if ( ERROR_SUCCESS == lError )
               {
                  // certificate source key opened; get its REG_EXPAND_SZ image path
                  cb = sizeof( szExpImagePath );
                  lError = RegQueryValueEx( hKeyCertSource, TEXT( VALUE_CERT_SOURCE_PATH ), NULL, NULL, (LPBYTE) szExpImagePath, &cb );

                  if ( ERROR_SUCCESS == lError )
                  {
                     // translate environment variables in path
                     cch = ExpandEnvironmentStrings( szExpImagePath, pcsiSourceInfo->szImagePath, sizeof( pcsiSourceInfo->szImagePath ) / sizeof( pcsiSourceInfo->szImagePath[0] ) );

                     if ( ( 0 != cch ) && ( cch < sizeof( pcsiSourceInfo->szImagePath ) / sizeof( pcsiSourceInfo->szImagePath[0] ) ) )
                     {
                        // get display name
                        cb = sizeof( pcsiSourceInfo->szDisplayName );
                        lError = RegQueryValueEx( hKeyCertSource, TEXT( VALUE_CERT_DISPLAY_NAME ), NULL, NULL, (LPBYTE) pcsiSourceInfo->szDisplayName, &cb );
   
                        if ( ERROR_SUCCESS != lError )
                        {
                           // default display name is the key name
                           lstrcpy( pcsiSourceInfo->szDisplayName, pcsiSourceInfo->szName );
                        }

                        // add the certificate source to our list
                        AddSource( pcsiSourceInfo );

                        ok = TRUE;
                     }
                  }

                  RegCloseKey( hKeyCertSource );
               }
            }

            if ( !ok )
            {
               // an error occurred before saving our pointer; don't leak!
               LocalFree( pcsiSourceInfo );
            }
         }

      } while ( ( NULL != pcsiSourceInfo ) && ( ERROR_SUCCESS == lEnumError ) );

      RegCloseKey( hKeyCertSourceList );
   }

   // 'salright
   return TRUE;
}


BOOL CCertSourceList::RemoveSources()

/*++

Routine Description:

   Free internal certificate source list.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   if ( NULL != m_ppcsiSourceList )
   {
      for ( DWORD i=0; i < m_dwNumSources; i++ )
      {
         LocalFree( m_ppcsiSourceList[i] );
      }

      LocalFree( m_ppcsiSourceList );
   }

   m_ppcsiSourceList = NULL;
   m_dwNumSources       = 0;

   return TRUE;
}


LPCTSTR CCertSourceList::GetSourceName( int nIndex )

/*++

Routine Description:

   Get the name (e.g., "Paper") of the source at the given index.

Arguments:

   nIndex (int)

Return Values:

   LPCTSTR.

--*/

{
   LPTSTR   pszName;

   if ( ( nIndex < 0 ) || ( nIndex >= (int) m_dwNumSources ) )
   {
      pszName = NULL;
   }
   else
   {
      pszName = m_ppcsiSourceList[ nIndex ]->szName;
   }

   return pszName;
}


LPCTSTR CCertSourceList::GetSourceDisplayName( int nIndex )

/*++

Routine Description:

   Get the display name (e.g., "Paper Certificate") of the source
   at the given index.

Arguments:

   nIndex (int)

Return Values:

   LPCTSTR.

--*/

{
   LPTSTR   pszDisplayName;

   if ( ( nIndex < 0 ) || ( nIndex >= (int) m_dwNumSources ) )
   {
      pszDisplayName = NULL;
   }
   else
   {
      pszDisplayName = m_ppcsiSourceList[ nIndex ]->szDisplayName;
   }

   return pszDisplayName;
}


LPCTSTR CCertSourceList::GetSourceImagePath( int nIndex )

/*++

Routine Description:

   Get the image path name (e.g., "C:\WINNT35\SYSTEM32\CCFAPI32.DLL") of
   the source at the given index.

Arguments:

   nIndex (int)

Return Values:

   LPCTSTR.

--*/

{
   LPTSTR   pszImagePath;

   if ( ( nIndex < 0 ) || ( nIndex >= (int) m_dwNumSources ) )
   {
      pszImagePath = NULL;
   }
   else
   {
      pszImagePath = m_ppcsiSourceList[ nIndex ]->szImagePath;
   }

   return pszImagePath;
}


int CCertSourceList::GetNumSources()

/*++

Routine Description:

   Get the number of certificate sources available.

Arguments:

   None.

Return Values:

   int.

--*/

{
   return m_dwNumSources;
}


BOOL CCertSourceList::AddSource( PCERT_SOURCE_INFO pcsiNewSource )

/*++

Routine Description:

   Add a source to the internal list.

Arguments:

   pcsiNewSource (PCERT_SOURCE_INFO)

Return Values:

   BOOL.

--*/

{
   if ( 0 == m_dwNumSources )
   {
      m_ppcsiSourceList = (PCERT_SOURCE_INFO *) LocalAlloc( LMEM_FIXED, sizeof( pcsiNewSource ) );
   }
   else
   {
      m_ppcsiSourceList = (PCERT_SOURCE_INFO *) LocalReAlloc( m_ppcsiSourceList, ( 1 + m_dwNumSources ) * sizeof( pcsiNewSource ), 0 );
   }

   if ( NULL != m_ppcsiSourceList )
   {
      m_ppcsiSourceList[ m_dwNumSources ] = pcsiNewSource;
      m_dwNumSources++;
   }
   else
   {
      m_dwNumSources = 0;
   }

   return ( NULL != m_ppcsiSourceList );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\remdlg.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   remdlg.cpp

Abstract:

   Remove licenses dialog implementation.

Author:

   Jeff Parham (jeffparh) 13-Dec-1995

Revision History:

--*/


#include "stdafx.h"
#include "ccfapi.h"
#include "remdlg.h"
#include "utils.h"
#include "licobj.h"
#include "imagelst.h"
#include "nlicdlg.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// describes the list view layout
static LV_COLUMN_INFO g_removeColumnInfo =
{
    0, 1, LVID_REMOVE_TOTAL_COLUMNS,

    {{LVID_REMOVE_SERIAL_NUMBER,    IDS_SERIAL_NUMBER,   LVCX_REMOVE_SERIAL_NUMBER  },
     {LVID_REMOVE_PRODUCT_NAME,     IDS_PRODUCT_NAME,    LVCX_REMOVE_PRODUCT_NAME   },
     {LVID_REMOVE_LICENSE_MODE,     IDS_LICENSE_MODE,    LVCX_REMOVE_LICENSE_MODE   },
     {LVID_REMOVE_NUM_LICENSES,     IDS_QUANTITY,        LVCX_REMOVE_NUM_LICENSES   },
     {LVID_REMOVE_SOURCE,           IDS_SOURCE,          LVCX_REMOVE_SOURCE         }},
};


CCertRemoveSelectDlg::CCertRemoveSelectDlg(CWnd* pParent /*=NULL*/)
   : CDialog(CCertRemoveSelectDlg::IDD, pParent)

/*++

Routine Description:

   Constructor for dialog.

Arguments:

   pParent - owner window.

Return Values:

   None.

--*/

{
   //{{AFX_DATA_INIT(CCertRemoveSelectDlg)
   m_nLicenses = 0;
   //}}AFX_DATA_INIT

   m_hLls                  = NULL;
   m_bLicensesRefreshed    = FALSE;
   m_dwRemoveFlags         = 0;
}


CCertRemoveSelectDlg::~CCertRemoveSelectDlg()

/*++

Routine Description:

   Destructor for dialog.

Arguments:

   None.

Return Values:

   None.

--*/

{
   if ( NULL != m_hLls )
   {
      LlsClose( m_hLls );
   }
}


void CCertRemoveSelectDlg::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

   Called by framework to exchange dialog data.

Arguments:

   pDX - data exchange object.

Return Values:

   None.

--*/

{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CCertRemoveSelectDlg)
   DDX_Control(pDX, IDC_SPIN_LICENSES, m_spinLicenses);
   DDX_Control(pDX, IDC_CERTIFICATE_LIST, m_listCertificates);
   DDX_Text(pDX, IDC_NUM_LICENSES, m_nLicenses);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCertRemoveSelectDlg, CDialog)
   //{{AFX_MSG_MAP(CCertRemoveSelectDlg)
   ON_BN_CLICKED(IDC_MY_HELP, OnHelp)
   ON_NOTIFY(LVN_COLUMNCLICK, IDC_CERTIFICATE_LIST, OnColumnClickCertificateList)
   ON_NOTIFY(LVN_GETDISPINFO, IDC_CERTIFICATE_LIST, OnGetDispInfoCertificateList)
   ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LICENSES, OnDeltaPosSpinLicenses)
   ON_NOTIFY(NM_DBLCLK, IDC_CERTIFICATE_LIST, OnDblClkCertificateList)
   ON_NOTIFY(NM_RETURN, IDC_CERTIFICATE_LIST, OnReturnCertificateList)
   ON_WM_DESTROY()
   ON_NOTIFY(NM_CLICK, IDC_CERTIFICATE_LIST, OnClickCertificateList)
   ON_NOTIFY(LVN_KEYDOWN, IDC_CERTIFICATE_LIST, OnKeyDownCertificateList)
   ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
   ON_MESSAGE( WM_HELP , OnHelpCmd )
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CCertRemoveSelectDlg::OnInitDialog()

/*++

Routine Description:

   Handler for WM_INITDIALOG.

Arguments:

   None.

Return Values:

   Returns false if focus set manually.

--*/

{
   CDialog::OnInitDialog();

   LoadImages();

   m_listCertificates.SetImageList( &m_smallImages, LVSIL_SMALL );

   ::LvInitColumns( &m_listCertificates, &g_removeColumnInfo );

   RefreshLicenses();
   RefreshCertificateList();
   UpdateSpinControlRange();

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}


void CCertRemoveSelectDlg::OnOK()

/*++

Routine Description:

   Handler for BN_CLICKED of OK.

Arguments:

   None.

Return Values:

   None.

--*/

{
   RemoveSelectedCertificate();
}

/*++

Routine Description:

   Handler for pressing F1.

Arguments:

   None.

Return Values:

   Nothing significant.

--*/
LRESULT CCertRemoveSelectDlg::OnHelpCmd( WPARAM , LPARAM )
{
    OnHelp();

    return 0;
}

void CCertRemoveSelectDlg::OnHelp()

/*++

Routine Description:

   Handler for help button click.

Arguments:

   None.

Return Values:

   None.

--*/

{
   WinHelp( IDD, HELP_CONTEXT );
}


void CCertRemoveSelectDlg::WinHelp(DWORD dwData, UINT nCmd)

/*++

Routine Description:

   Call WinHelp for this dialog.

Arguments:

   dwData (DWORD)
   nCmd (UINT)

Return Values:

   None.

--*/

{
   ::HtmlHelp(m_hWnd, L"liceconcepts.chm", HH_DISPLAY_TOPIC,0);
/*
   BOOL ok = ::WinHelp( m_hWnd, theApp.GetHelpFileName(), nCmd, dwData );
   ASSERT( ok );
*/
}


void CCertRemoveSelectDlg::OnDestroy()

/*++

Routine Description:

   Handler for WM_DESTROY.

Arguments:

   None.

Return Values:

   None.

--*/

{
   ResetLicenses();
/*
   ::WinHelp( m_hWnd, theApp.GetHelpFileName(), HELP_QUIT, 0 );
*/

   CDialog::OnDestroy();
}


void CCertRemoveSelectDlg::OnColumnClickCertificateList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

   Handler for LVN_COLUMNCLICK of certificate list view.

Arguments:

   pNMHDR (NMHDR*)
   pResult (LRESULT*)

Return Values:

   None.

--*/

{
   g_removeColumnInfo.bSortOrder  = GetKeyState(VK_CONTROL) < 0;
   g_removeColumnInfo.nSortedItem = ((NM_LISTVIEW*)pNMHDR)->iSubItem;

   m_listCertificates.SortItems( CompareLicenses, 0 );    // use column info

   *pResult = 0;
}


void CCertRemoveSelectDlg::OnGetDispInfoCertificateList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

   Handler for LVN_GETDISPINFO of certificate list view.

Arguments:

   pNMHDR (NMHDR*)
   pResult (LRESULT*)

Return Values:

   None.

--*/

{
   LV_ITEM* plvItem = &((LV_DISPINFO*)pNMHDR)->item;
   ASSERT(plvItem);

   CLicense* pLicense = (CLicense*)plvItem->lParam;
   VALIDATE_OBJECT(pLicense, CLicense);

   switch (plvItem->iSubItem)
   {
   case LVID_REMOVE_SERIAL_NUMBER:
      plvItem->iImage = BMPI_CERTIFICATE;
      {
         CString  strSerialNumber;

         strSerialNumber.Format( TEXT("%ld"), (LONG) ( pLicense->m_dwCertificateID ) );
         lstrcpyn( plvItem->pszText, strSerialNumber, plvItem->cchTextMax );
      }
      break;

   case LVID_REMOVE_PRODUCT_NAME:
      lstrcpyn( plvItem->pszText, pLicense->m_strProduct, plvItem->cchTextMax );
      break;

   case LVID_REMOVE_LICENSE_MODE:
      lstrcpyn( plvItem->pszText, pLicense->GetAllowedModesString(), plvItem->cchTextMax );
      break;

   case LVID_REMOVE_NUM_LICENSES:
      {
         CString  strLicenses;

         strLicenses.Format( TEXT("%ld"), (LONG) ( pLicense->m_lQuantity ) );
         lstrcpyn( plvItem->pszText, strLicenses, plvItem->cchTextMax );
      }
      break;

   case LVID_REMOVE_SOURCE:
      lstrcpyn( plvItem->pszText, pLicense->GetSourceDisplayName(), plvItem->cchTextMax );
      break;

   default:
      ASSERT( FALSE );
      break;
   }

   *pResult = 0;
}


void CCertRemoveSelectDlg::OnDeltaPosSpinLicenses(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

   Handler for UDN_DELTAPOS of number of licenses.

Arguments:

   pNMHDR (NMHDR*)
   pResult (LRESULT*)

Return Values:

   None.

--*/

{
   if ( UpdateData(TRUE) )   // get data
   {
      m_nLicenses += ((NM_UPDOWN*)pNMHDR)->iDelta;

      int   nLow;
      int   nHigh;

      m_spinLicenses.GetRange( nLow, nHigh );

      if (m_nLicenses < nLow)
      {
         m_nLicenses = nLow;

         ::MessageBeep(MB_OK);
      }
      else if (m_nLicenses > nHigh )
      {
         m_nLicenses = nHigh;

         ::MessageBeep(MB_OK);
      }

      UpdateData(FALSE);  // set data
   }

   *pResult = 1;   // handle ourselves...
}


void CCertRemoveSelectDlg::OnDblClkCertificateList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

   Handler for NM_DBLCLK of certificate list view.

Arguments:

   pNMHDR (NMHDR*)
   pResult (LRESULT*)

Return Values:

   None.

--*/

{
   RemoveSelectedCertificate();
   *pResult = 0;
}


void CCertRemoveSelectDlg::OnReturnCertificateList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

   Handler for NM_RETURN of certificate list view.

Arguments:

   None.

Return Values:

   None.

--*/

{
   RemoveSelectedCertificate();
   *pResult = 0;
}


void CCertRemoveSelectDlg::ResetLicenses()

/*++

Routine Description:

   Remove all licenses from internal list.

Arguments:

   None.

Return Values:

   None.

--*/

{
   CLicense* pLicense;
   int       iLicense = (int)m_licenseArray.GetSize();

   while (iLicense--)
   {
      if (pLicense = (CLicense*)m_licenseArray[iLicense])
      {
         ASSERT(pLicense->IsKindOf(RUNTIME_CLASS(CLicense)));
         delete pLicense;
      }
   }

   m_licenseArray.RemoveAll();
   m_listCertificates.DeleteAllItems();

   m_bLicensesRefreshed = FALSE;
}


BOOL CCertRemoveSelectDlg::RefreshLicenses()

/*++

Routine Description:

   Refresh internal license list with data from license server.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   ResetLicenses();

   if ( ConnectServer() )
   {
      NTSTATUS    NtStatus;
      DWORD       ResumeHandle = 0L;

      int iLicense = 0;

      do
      {
         DWORD  EntriesRead;
         DWORD  TotalEntries;
         LPBYTE ReturnBuffer = NULL;
         DWORD  Level = LlsCapabilityIsSupported( m_hLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) ? 1 : 0;

         BeginWaitCursor();
         NtStatus = ::LlsLicenseEnum( m_hLls,
                                      Level,
                                      &ReturnBuffer,
                                      LLS_PREFERRED_LENGTH,
                                      &EntriesRead,
                                      &TotalEntries,
                                      &ResumeHandle );
         EndWaitCursor();

         if (    ( STATUS_SUCCESS      == NtStatus )
              || ( STATUS_MORE_ENTRIES == NtStatus ) )
         {
            CLicense*            pLicense;
            PLLS_LICENSE_INFO_0  pLicenseInfo0;
            PLLS_LICENSE_INFO_1  pLicenseInfo1;

            pLicenseInfo0 = (PLLS_LICENSE_INFO_0)ReturnBuffer;
            pLicenseInfo1 = (PLLS_LICENSE_INFO_1)ReturnBuffer;

            while (EntriesRead--)
            {
               if (    ( m_strProductName.IsEmpty() || !m_strProductName.CompareNoCase( Level ? pLicenseInfo1->Product : pLicenseInfo0->Product ) )
                    && ( m_strSourceToUse.IsEmpty() || !m_strSourceToUse.CompareNoCase( Level ? pLicenseInfo1->Source  : TEXT("None")           ) ) )
               {
                  // we want to list this license

                  // have we seen this certificate yet?
                  for ( int i=0; i < m_licenseArray.GetSize(); i++ )
                  {
                     pLicense = (CLicense*) m_licenseArray[ i ];

                     VALIDATE_OBJECT( pLicense, CLicense );

                     if (    (    ( 1 == Level )
                               && ( pLicense->m_dwCertificateID == pLicenseInfo1->CertificateID     )
                               && ( pLicense->m_dwAllowedModes  == pLicenseInfo1->AllowedModes      )
                               && ( pLicense->m_dwMaxQuantity   == pLicenseInfo1->MaxQuantity       )
                               && ( !pLicense->m_strSource.CompareNoCase(  pLicenseInfo1->Source  ) )
                               && ( !pLicense->m_strProduct.CompareNoCase( pLicenseInfo1->Product ) )
                               && ( !memcmp( pLicense->m_adwSecrets,
                                             pLicenseInfo1->Secrets,
                                             sizeof( pLicense->m_adwSecrets ) )                     ) )
                          || (    ( 0 == Level )
                               && ( !pLicense->m_strProduct.CompareNoCase( pLicenseInfo0->Product ) ) ) )
                     {
                        // we've seen this certificate before; update the tally
                        pLicense->m_lQuantity += ( Level ? pLicenseInfo1->Quantity : pLicenseInfo0->Quantity );
                        break;
                     }
                  }

                  if ( i >= m_licenseArray.GetSize() )
                  {
                     // we haven't seen this certificate yet; create a new license for it
                     if ( 1 == Level )
                     {
                        pLicense = new CLicense( pLicenseInfo1->Product,
                                                 pLicenseInfo1->Vendor,
                                                 pLicenseInfo1->Admin,
                                                 pLicenseInfo1->Date,
                                                 pLicenseInfo1->Quantity,
                                                 pLicenseInfo1->Comment,
                                                 pLicenseInfo1->AllowedModes,
                                                 pLicenseInfo1->CertificateID,
                                                 pLicenseInfo1->Source,
                                                 pLicenseInfo1->ExpirationDate,
                                                 pLicenseInfo1->MaxQuantity,
                                                 pLicenseInfo1->Secrets );

                        ::LlsFreeMemory( pLicenseInfo1->Product );
                        ::LlsFreeMemory( pLicenseInfo1->Admin   );
                        ::LlsFreeMemory( pLicenseInfo1->Comment );
                        ::LlsFreeMemory( pLicenseInfo1->Source  );
                     }
                     else
                     {
                        ASSERT( 0 == Level );

                        pLicense = new CLicense( pLicenseInfo0->Product,
                                                 TEXT( "Microsoft" ),
                                                 pLicenseInfo0->Admin,
                                                 pLicenseInfo0->Date,
                                                 pLicenseInfo0->Quantity,
                                                 pLicenseInfo0->Comment );

                        ::LlsFreeMemory( pLicenseInfo0->Product );
                        ::LlsFreeMemory( pLicenseInfo0->Admin   );
                        ::LlsFreeMemory( pLicenseInfo0->Comment );
                     }

                     if ( NULL == pLicense )
                     {
                        NtStatus = ERROR_OUTOFMEMORY;
                        break;
                     }

                     m_licenseArray.Add( pLicense );
                  }
               }

               pLicenseInfo1++;
               pLicenseInfo0++;
            }

            ::LlsFreeMemory(ReturnBuffer);
         }

      } while ( STATUS_MORE_ENTRIES == NtStatus );

      theApp.SetLastLlsError( NtStatus );   // called api

      if ( STATUS_SUCCESS == NtStatus )
      {
         // add per server entries
         LPTSTR pszServerName = m_strServerName.GetBuffer(0);

         if ( NULL != pszServerName )
         {
            BeginWaitCursor();

            HKEY  hKeyLocalMachine;

            NtStatus = RegConnectRegistry( pszServerName, HKEY_LOCAL_MACHINE, &hKeyLocalMachine );

            if ( ERROR_SUCCESS != NtStatus )
            {
               theApp.SetLastError( NtStatus );
            }
            else
            {
               HKEY  hKeyLicenseInfo;

               NtStatus = RegOpenKeyEx( hKeyLocalMachine, TEXT( "SYSTEM\\CurrentControlSet\\Services\\LicenseInfo" ), 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_SET_VALUE, &hKeyLicenseInfo );

               if ( ERROR_SUCCESS != NtStatus )
               {
                  theApp.SetLastError( NtStatus );
               }
               else
               {
                  NTSTATUS ntEnum;
                  BOOL     bFoundKey = FALSE;
                  DWORD    iSubKey = 0;

                  // if the service is 3.51-style per server, add it to the list
                  do
                  {
                     TCHAR    szKeyName[ 128 ];
                     DWORD    cchKeyName = sizeof( szKeyName ) / sizeof( *szKeyName );

                     ntEnum = RegEnumKeyEx( hKeyLicenseInfo, iSubKey++, szKeyName, &cchKeyName, NULL, NULL, NULL, NULL );

                     if ( ERROR_SUCCESS == ntEnum )
                     {
                        HKEY  hKeyProduct;

                        NtStatus = RegOpenKeyEx( hKeyLicenseInfo, szKeyName, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hKeyProduct );

                        if ( ERROR_SUCCESS == NtStatus )
                        {
                           DWORD    dwType;
                           TCHAR    szDisplayName[ 128 ];
                           DWORD    cbDisplayName = sizeof( szDisplayName );

                           NtStatus = RegQueryValueEx( hKeyProduct, TEXT( "DisplayName" ), NULL, &dwType, (LPBYTE) szDisplayName, &cbDisplayName );

                           if ( ERROR_SUCCESS == NtStatus )
                           {
                              // is this product secure?
                              BOOL bIsSecure = FALSE;

                              if ( LlsCapabilityIsSupported( m_hLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
                              {
                                 NtStatus = ::LlsProductSecurityGet( m_hLls, szDisplayName, &bIsSecure );
                                 theApp.SetLastLlsError( NtStatus );

                                 if ( STATUS_SUCCESS != NtStatus )
                                 {
                                    bIsSecure = FALSE;
                                 }
                              }

                              if ( !bIsSecure )
                              {
#ifdef REMOVE_CONCURRENT_ONLY_IF_PER_SERVER_MODE
                              // not secure; is it in per server mode?
                              DWORD    dwMode;
                              DWORD    cbMode = sizeof( dwMode );

                              NtStatus = RegQueryValueEx( hKeyProduct, TEXT( "Mode" ), NULL, &dwType, (LPBYTE) &dwMode, &cbMode );

                              if ( ( ERROR_SUCCESS == NtStatus ) && dwMode )
                              {
                                 // per server mode; add to list
#endif
                                 DWORD    dwConcurrentLimit;
                                 DWORD    cbConcurrentLimit = sizeof( dwConcurrentLimit );

                                 NtStatus = RegQueryValueEx( hKeyProduct, TEXT( "ConcurrentLimit" ), NULL, &dwType, (LPBYTE) &dwConcurrentLimit, &cbConcurrentLimit );

                                 if (    ( ERROR_SUCCESS == NtStatus )
                                      && ( 0 < dwConcurrentLimit )
                                      && ( m_strProductName.IsEmpty() || !m_strProductName.CompareNoCase( szDisplayName ) )
                                      && ( m_strSourceToUse.IsEmpty() || !m_strSourceToUse.CompareNoCase( TEXT("None")  ) ) )
                                 {
                                    CLicense * pLicense = new CLicense( szDisplayName,
                                                                        TEXT(""),
                                                                        TEXT(""),
                                                                        0,
                                                                        dwConcurrentLimit,
                                                                        TEXT(""),
                                                                        LLS_LICENSE_MODE_ALLOW_PER_SERVER );

                                    if ( NULL != pLicense )
                                    {
                                       m_licenseArray.Add( pLicense );
                                    }
                                 }
                              }
#ifdef REMOVE_CONCURRENT_ONLY_IF_PER_SERVER_MODE
                              }
#endif
                           }

                           RegCloseKey( hKeyProduct );
                        }
                     }
                  } while ( ERROR_SUCCESS == ntEnum );

                  RegCloseKey( hKeyLicenseInfo );
               }

               RegCloseKey( hKeyLocalMachine );
            }

            m_strServerName.ReleaseBuffer();
         }

         EndWaitCursor();

         m_bLicensesRefreshed = TRUE;

         // remove any entries from the list that aren't removable
         for ( int i=0; i < m_licenseArray.GetSize(); )
         {
            CLicense* pLicense = (CLicense*) m_licenseArray[ i ];

            VALIDATE_OBJECT( pLicense, CLicense );

            if ( pLicense->m_lQuantity <= 0 )
            {
               delete pLicense;
               m_licenseArray.RemoveAt( i );
            }
            else
            {
               i++;
            }
         }
      }
      else
      {
         theApp.DisplayLastError();
         ResetLicenses();
      }
   }

   return m_bLicensesRefreshed;
}


BOOL CCertRemoveSelectDlg::RefreshCertificateList()

/*++

Routine Description:

   Refresh certificate list view from internal license list.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   BeginWaitCursor();

   BOOL ok = ::LvRefreshObArray( &m_listCertificates, &g_removeColumnInfo, &m_licenseArray );

   EndWaitCursor();

   return ok;
}


int CALLBACK CompareLicenses(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)

/*++

Routine Description:

   Notification handler for LVM_SORTITEMS.

Arguments:

   lParam1 - object to sort.
   lParam2 - object to sort.
   lParamSort - sort criteria.

Return Values:

   Same as lstrcmp.

--*/

{
   CLicense *    pLic1 = (CLicense *) lParam1;
   CLicense *    pLic2 = (CLicense *) lParam2;

   VALIDATE_OBJECT( pLic1, CLicense );
   VALIDATE_OBJECT( pLic2, CLicense );

   int iResult;

   switch (g_removeColumnInfo.nSortedItem)
   {
   case LVID_REMOVE_SERIAL_NUMBER:
      iResult = pLic1->m_dwCertificateID - pLic2->m_dwCertificateID;
      break;

   case LVID_REMOVE_PRODUCT_NAME:
      iResult = pLic1->m_strProduct.CompareNoCase( pLic2->m_strProduct );
      break;

   case LVID_REMOVE_NUM_LICENSES:
      iResult = pLic1->m_lQuantity - pLic2->m_lQuantity;
      break;

   case LVID_REMOVE_SOURCE:
      iResult = pLic1->GetSourceDisplayName().CompareNoCase( pLic2->GetSourceDisplayName() );
      break;

   default:
      iResult = 0;
      break;
   }

   return g_removeColumnInfo.bSortOrder ? -iResult : iResult;
}


void CCertRemoveSelectDlg::UpdateSpinControlRange()

/*++

Routine Description:

   Update range of spin control for number of licenses.

Arguments:

   None.

Return Values:

   None.

--*/

{
   CLicense *  pLicense;

   UpdateData( TRUE );

   if ( pLicense = (CLicense*)::LvGetSelObj( &m_listCertificates ) )
   {
      m_spinLicenses.SetRange( 1, pLicense->m_lQuantity );
      m_nLicenses = pLicense->m_lQuantity;
      GetDlgItem( IDOK )->EnableWindow( TRUE );
   }
   else
   {
      m_spinLicenses.SetRange( 0, 0 );
      m_nLicenses = 0;
      GetDlgItem( IDOK )->EnableWindow( FALSE );
   }

   UpdateData( FALSE );
}


DWORD CCertRemoveSelectDlg::RemoveSelectedCertificate()

/*++

Routine Description:

   Remove the given number of licenses from the selected certificate.

Arguments:

   None.

Return Values:

   ERROR_SUCCESS
   NT status code
   Win error

--*/

{
   NTSTATUS    nt = STATUS_SUCCESS;

   if ( UpdateData( TRUE ) )
   {
      BOOL        bDisplayError = TRUE;
      CLicense *  pLicense;

      if ( !( pLicense = (CLicense*)::LvGetSelObj( &m_listCertificates ) ) )
      {
         // no certificate selected
         bDisplayError = FALSE;
      }
      else if ( ( m_nLicenses < 1 ) || ( m_nLicenses > pLicense->m_lQuantity ) )
      {
         // invalid number of licenses to remove
         AfxMessageBox( IDS_REMOVE_INVALID_NUM_LICENSES, MB_ICONEXCLAMATION | MB_OK, 0 );
         nt = ERROR_CANCELLED;
         bDisplayError = FALSE;
      }
      else
      {
         CString  strLicenses;
         CString  strConfirm;

         strLicenses.Format( TEXT("%d"), m_nLicenses );
         AfxFormatString2( strConfirm, IDS_REMOVE_CERTIFICATE_CONFIRM, strLicenses, pLicense->m_strProduct );

         int nResponse = AfxMessageBox( strConfirm, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2 );

         if ( IDYES != nResponse )
         {
            nt = ERROR_CANCELLED;
            bDisplayError = FALSE;
         }
         else
         {
            // delete certificate
            LPSTR  pszAscServerName  = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + m_strServerName.GetLength()        );
            LPSTR  pszAscProductName = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + pLicense->m_strProduct.GetLength() );
            LPSTR  pszAscVendor      = (LPSTR) LocalAlloc( LMEM_FIXED, 1 + m_strVendor.GetLength()            );

            CString cstrClose;
            
            cstrClose.LoadString( IDS_CLOSETEXT );

            CWnd *pWnd = GetDlgItem( IDCANCEL );

            if( pWnd != NULL )
            {
                pWnd->SetWindowText( cstrClose );
            }

            if ( ( NULL == pszAscServerName ) || ( NULL == pszAscProductName ) || ( NULL == pszAscVendor ) )
            {
               nt = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
               wsprintfA( pszAscServerName,  "%ls", (LPCWSTR) m_strServerName        );
               wsprintfA( pszAscProductName, "%ls", (LPCWSTR) pLicense->m_strProduct );
               wsprintfA( pszAscVendor,      "%ls", (LPCWSTR) m_strVendor            );

               LLS_LICENSE_INFO_1   lic;

               nt = pLicense->CreateLicenseInfo( &lic );

               if ( STATUS_SUCCESS == nt )
               {
                  // only remove as many licenses as requested
                  lic.Quantity = m_nLicenses;

                  if ( !pLicense->m_strSource.CompareNoCase( TEXT( "None" ) ) )
                  {
                     nt = NoCertificateRemove( m_hWnd, pszAscServerName, m_dwRemoveFlags, 1, &lic );
                     bDisplayError = FALSE;
                  }
                  else
                  {
                     // get certificate source DLL path
                     CString  strKeyName =   TEXT( "Software\\LSAPI\\Microsoft\\CertificateSources\\" )
                                           + pLicense->m_strSource;
                     HKEY     hKeySource;

                     nt = RegOpenKeyEx( HKEY_LOCAL_MACHINE, strKeyName, 0, KEY_READ, &hKeySource );

                     if ( ( ERROR_PATH_NOT_FOUND == nt ) || ( ERROR_FILE_NOT_FOUND == nt ) )
                     {
                        AfxMessageBox( IDS_CERT_SOURCE_NOT_AVAILABLE, MB_ICONSTOP | MB_OK, 0 );
                        nt = ERROR_CANCELLED;
                        bDisplayError = FALSE;
                     }
                     else if ( ERROR_SUCCESS == nt )
                     {
                        TCHAR    szImagePath[ 1 + _MAX_PATH ];
                        DWORD    cbImagePath = sizeof( szImagePath );
                        DWORD    dwType;

                        nt = RegQueryValueEx( hKeySource, TEXT( "ImagePath" ), NULL, &dwType, (LPBYTE) szImagePath, &cbImagePath );

                        if ( ERROR_SUCCESS == nt )
                        {
                           TCHAR    szExpandedImagePath[ 1 + _MAX_PATH ];

                           BOOL ok = ExpandEnvironmentStrings( szImagePath, szExpandedImagePath, sizeof( szExpandedImagePath ) / sizeof( *szExpandedImagePath ) );

                           if ( !ok )
                           {
                              nt = GetLastError();
                           }
                           else
                           {
                              // load certificate source DLL
                              HINSTANCE hDll = ::LoadLibrary( szExpandedImagePath );

                              if ( NULL == hDll )
                              {
                                 nt = GetLastError();
                              }
                              else
                              {
                                 // get certificate remove function
                                 CHAR              szExportName[ 256 ];
                                 PCCF_REMOVE_API   pRemoveFn;

                                 wsprintfA( szExportName, "%lsCertificateRemove", (LPCWSTR) pLicense->m_strSource );
                                 pRemoveFn = (PCCF_REMOVE_API) GetProcAddress( hDll, szExportName );

                                 if ( NULL == pRemoveFn )
                                 {
                                    nt = GetLastError();
                                 }
                                 else
                                 {
                                    // remove certificate
                                    nt = (*pRemoveFn)( m_hWnd, pszAscServerName, m_dwRemoveFlags, 1, &lic );
                                    bDisplayError = FALSE;
                                 }

                                 ::FreeLibrary( hDll );
                              }
                           }
                        }

                        RegCloseKey( hKeySource );
                     }
                  }

                  pLicense->DestroyLicenseInfo( &lic );
               }
            }

            if ( NULL != pszAscServerName  )    LocalFree( pszAscServerName  );
            if ( NULL != pszAscProductName )    LocalFree( pszAscProductName );
            if ( NULL != pszAscVendor      )    LocalFree( pszAscVendor      );

            RefreshLicenses();
            RefreshCertificateList();
            UpdateSpinControlRange();
         }
      }

      if ( bDisplayError && ( ERROR_SUCCESS != nt ) )
      {
         theApp.SetLastError( nt );
         theApp.DisplayLastError();
      }
   }

   return nt;
}


BOOL CCertRemoveSelectDlg::ConnectServer()

/*++

Routine Description:

   Establish a connection to the license service on the target server.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   if ( NULL == m_hLls )
   {
      LPTSTR   pszServerName;

      if ( m_strServerName.IsEmpty() )
      {
         pszServerName = NULL;
      }
      else
      {
         pszServerName = m_strServerName.GetBuffer( 0 );
      }

      ConnectTo( pszServerName, &m_hLls );

      if ( NULL != pszServerName )
      {
         m_strServerName.ReleaseBuffer();
      }
   }

   if ( NULL == m_hLls )
   {
      theApp.DisplayLastError();

      if ( ( NULL != m_hWnd ) && IsWindow( m_hWnd ) )
      {
         EndDialog( IDABORT );
      }
   }

   return ( NULL != m_hLls );
}


NTSTATUS CCertRemoveSelectDlg::ConnectTo( LPTSTR pszServerName, PLLS_HANDLE phLls )

/*++

Routine Description:

   Establish a connection to the license service on the given server.

Arguments:

   pszServerName (CString)
      The target server.  An empty value indicates the local server.
   phLls (PLLS_HANDLE)
      On return, holds the handle to the standard LLS RPC.

Return Values:

   STATUS_SUCCESS or NT status code.

--*/

{
   NTSTATUS    nt;

   nt = ::LlsConnect( pszServerName, phLls );
   theApp.SetLastLlsError( nt );

   if ( STATUS_SUCCESS != nt )
   {
      *phLls = NULL;
   }

   return nt;
}


void CCertRemoveSelectDlg::OnClickCertificateList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

   Handler for NM_CLICK of certificate list view.

Arguments:

   pNMHDR (NMHDR*)
   pResult (LRESULT*)

Return Values:

   None.

--*/

{
   UpdateSpinControlRange();
   *pResult = 1; // not handled...
}

void CCertRemoveSelectDlg::OnKeyDownCertificateList(NMHDR* pNMHDR, LRESULT* pResult)

/*++

Routine Description:

   Handler for LVN_KEYDOWN of certificate list view.

Arguments:

   pNMHDR (NMHDR*)
   pResult (LRESULT*)

Return Values:

   None.

--*/

{
   UpdateSpinControlRange();
   *pResult = 1; // not handled...
}


BOOL CCertRemoveSelectDlg::LoadImages()

/*++

Routine Description:

   Load icons for the list view.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   BOOL bImagesLoaded = m_smallImages.Create( IDB_SMALL_ICONS, BMPI_SMALL_SIZE, 0, BMPI_RGB_BKGND );
   ASSERT( bImagesLoaded );

   return bImagesLoaded;
}


void CCertRemoveSelectDlg::OnRefresh()

/*++

Routine Description:

   Handler for BN_CLICK of refresh button.

Arguments:

   None.

Return Values:

   None.

--*/

{
   RefreshLicenses();
   RefreshCertificateList();
   UpdateSpinControlRange();
}


DWORD CCertRemoveSelectDlg::CertificateRemove( LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags, LPCSTR pszSourceToUse )

/*++

Routine Description:

   Display a dialog allowing the user to remove one or more license
   certificates from the system.

Arguments:

   pszServerName (LPCSTR)
      Name of the server on which licenses are to be removed.  A NULL value
      indicates the local server.
   pszProductName (LPCSTR)
      Product for which licenses are to be removed.  A NULL value indicates
      that the user should be allowed to remove licenses from any product.
   pszVendor (LPCSTR)
      Name of the vendor of the product.  This value should be NULL if
      pszProductName is NULL, and should be non-NULL if pszProductName is
      non-NULL.
   dwFlags (DWORD)
      Certificate removal options.  As of this writing, no flags are
      supported.
   pszSourceToUse (LPCSTR)
      Name of the secure certificate source by which licenses are to be
      removed, e.g., "Paper".  A NULL value indicates that the user should
      be allowed to remove licenses that were installed with any source.

Return Value:

   ERROR_SUCCESS
   Win error

--*/

{
   m_strServerName   = pszServerName  ? pszServerName  : "";
   m_strProductName  = pszProductName ? pszProductName : "";
   m_strVendor       = pszVendor      ? pszVendor      : "";
   m_dwRemoveFlags   = dwFlags;
   m_strSourceToUse  = pszSourceToUse ? pszSourceToUse : "";

   DoModal();

   return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\stdafx.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1999
//
// File:        stdafx.h
//
// Contents:    
//
// History:     
//              
//              
//---------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

// #define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

// #define _AFX_NO_OLE_SUPPORT
// #define _AFX_NO_DB_SUPPORT
#define _AFX_NO_DAO_SUPPORT
// #define _AFX_NO_AFXCMN_SUPPORT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef ASSERT
#  undef ASSERT
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <llsapi.h>

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\source.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   source.h

Abstract:

   Select certificate source dialog prototype.

Author:

   Jeff Parham (jeffparh) 13-Dec-1995

Revision History:

--*/


#include "afxwin.h"
#include "srclist.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CCertSourceSelect dialog

class CCertSourceSelectDlg : public CDialog
{
public:
   CCertSourceSelectDlg(CWnd* pParent = NULL);
   ~CCertSourceSelectDlg();

   DWORD    CertificateEnter( HWND hWndParent, LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags, LPCSTR pszSourceToUse );

   void     AbortDialogIfNecessary();

   DWORD    CallCertificateSource( int nIndex );

   BOOL     ConnectServer();
   NTSTATUS ConnectTo( LPTSTR pszServerName, PLLS_HANDLE phLls );

   void     GetSourceList();

   LLS_HANDLE        m_hLls;

   LPCSTR            m_pszServerName;
   LPCSTR            m_pszProductName;
   LPCSTR            m_pszVendor;
   DWORD             m_dwEnterFlags;

   CCertSourceList   m_cslSourceList;

// Dialog Data
   //{{AFX_DATA(CCertSourceSelectDlg)
   enum { IDD = IDD_CERT_SOURCE_SELECT };
   CComboBox   m_cboxSource;
   CString  m_strSource;
   //}}AFX_DATA

// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CCertSourceSelectDlg)
   public:
   virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CCertSourceSelectDlg)
   virtual BOOL OnInitDialog();
   virtual void OnOK();
   afx_msg void OnHelp();
   afx_msg void OnDestroy();
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\client\lsapi_c_stub.c ===
#include "lsapi_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\client\llsrpc_c_stub.c ===
#include "llsrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\source.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   source.cpp

Abstract:

   Select certificate source dialog implementation.

Author:

   Jeff Parham (jeffparh) 13-Dec-1995

Revision History:

--*/


#include "stdafx.h"
#include "ccfapi.h"
#include "source.h"
#include "paper.h"
#include "nlicdlg.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


// 3.51-style
static CString       l_strOldEntryName;
static const DWORD   l_dwOldEntryIndex  = (DWORD) (-1L);


CCertSourceSelectDlg::CCertSourceSelectDlg(CWnd* pParent /*=NULL*/)
   : CDialog(CCertSourceSelectDlg::IDD, pParent)

/*++

Routine Description:

   Constructor for dialog.

Arguments:

   pParent - owner window.

Return Values:

   None.

--*/

{
   //{{AFX_DATA_INIT(CCertSourceSelectDlg)
   m_strSource = _T("");
   //}}AFX_DATA_INIT

   m_dwEnterFlags    = 0;
   m_pszProductName  = NULL;
   m_pszServerName   = NULL;
   m_pszVendor       = NULL;

   l_strOldEntryName.LoadString( IDS_NO_CERTIFICATE_SOURCE_NAME );

   m_hLls   = NULL;
}


CCertSourceSelectDlg::~CCertSourceSelectDlg()

/*++

Routine Description:

   Destructor for dialog.

Arguments:

   None.

Return Values:

   None.

--*/

{
   if ( NULL != m_hLls )
   {
      LlsClose( m_hLls );
   }
}


void CCertSourceSelectDlg::DoDataExchange(CDataExchange* pDX)

/*++

Routine Description:

   Called by framework to exchange dialog data.

Arguments:

   pDX - data exchange object.

Return Values:

   None.

--*/

{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CCertSourceSelectDlg)
   DDX_Control(pDX, IDC_CERT_SOURCE, m_cboxSource);
   DDX_CBString(pDX, IDC_CERT_SOURCE, m_strSource);
   //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCertSourceSelectDlg, CDialog)
   //{{AFX_MSG_MAP(CCertSourceSelectDlg)
   ON_BN_CLICKED(IDC_MY_HELP, OnHelp)
   ON_WM_DESTROY()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CCertSourceSelectDlg::OnInitDialog()

/*++

Routine Description:

   Handler for WM_INITDIALOG.

Arguments:

   None.

Return Values:

   Returns false if focus set manually.

--*/

{
   CDialog::OnInitDialog();

   GetSourceList();

   m_cboxSource.SetCurSel( 0 );

   return TRUE;
}


void CCertSourceSelectDlg::OnOK()

/*++

Routine Description:

   Handler for BN_CLICKED of OK.

Arguments:

   None.

Return Values:

   None.

--*/

{
   if ( NULL != GetParent() )
      GetParent()->EnableWindow();

   ShowWindow( FALSE );

   if ( ERROR_SUCCESS == CallCertificateSource( (int)m_cboxSource.GetItemData( m_cboxSource.GetCurSel() ) ) )
      CDialog::OnOK();
   else
      ShowWindow( TRUE );
}


void CCertSourceSelectDlg::OnHelp()

/*++

Routine Description:

   Handler for help button click.

Arguments:

   None.

Return Values:

   None.

--*/

{
   WinHelp( IDD, HELP_CONTEXT );
}


void CCertSourceSelectDlg::WinHelp(DWORD dwData, UINT nCmd)

/*++

Routine Description:

   Call WinHelp for this dialog.

Arguments:

   dwData (DWORD)
   nCmd (UINT)

Return Values:

   None.

--*/

{
   ::HtmlHelp(m_hWnd, L"liceconcepts.chm", HH_DISPLAY_TOPIC,0);
/*
   BOOL ok = ::WinHelp( m_hWnd, theApp.GetHelpFileName(), nCmd, dwData );
 */  ASSERT( ok );
}

void CCertSourceSelectDlg::OnDestroy()

/*++

Routine Description:

   Handler for WM_DESTROY.

Arguments:

   None.

Return Values:

   None.

--*/

{
   WinHelp( 0, HELP_QUIT );

   CDialog::OnDestroy();
}


void CCertSourceSelectDlg::GetSourceList()

/*++

Routine Description:

   Insert list of valid certificate sources into list box.

Arguments:

   None.

Return Values:

   None.

--*/

{
   BOOL        ok = TRUE;
   int         nCboxIndex;

   if ( NULL == m_pszProductName )
   {
      // otherwise we know that the product is secure, otherwise it would have
      // been handed to the unsecure product entry dialog already, and we
      // wouldn't offer to let the user use the unsecure entry dialog

      // add standard non-secure certificate source to possible choices
      nCboxIndex = m_cboxSource.AddString( l_strOldEntryName );

      ok =    ( 0      <= nCboxIndex )
           && ( CB_ERR != m_cboxSource.SetItemData( nCboxIndex, l_dwOldEntryIndex ) );
   }

   if (    ok
        && ConnectServer()
        && LlsCapabilityIsSupported( m_hLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
   {
      // secure certificates supported on the target server (post-3.51 license server)

      // add secure certificate sources to source list
      for ( int nSourceIndex=0; ok && ( nSourceIndex < m_cslSourceList.GetNumSources() ); nSourceIndex++ )
      {
         nCboxIndex = m_cboxSource.AddString( m_cslSourceList.GetSourceDisplayName( nSourceIndex ) );

         if ( nCboxIndex < 0 )
         {
            // couldn't add string to combo box
            ok = FALSE;
         }
         else
         {
            // string added; associate index of source with it
            ok = ( CB_ERR != m_cboxSource.SetItemData( nCboxIndex, nSourceIndex ) );
         }
      }
   }

   if ( !ok )
   {
      theApp.SetLastError( ERROR_NOT_ENOUGH_MEMORY );
      theApp.DisplayLastError();
      EndDialog( IDABORT );
   }
   else if ( m_cboxSource.GetCount() == 0 )
   {
      AfxMessageBox( IDS_NO_PRODUCT_CERTIFICATE_SOURCES, MB_OK | MB_ICONSTOP, 0 );
      EndDialog( IDABORT );
   }
}


DWORD CCertSourceSelectDlg::CallCertificateSource( int nIndex )

/*++

Routine Description:

   Call the certificate source with the specified index into the source list.

Arguments:

   nIndex (int)

Return Values:

   ERROR_SUCCESS
   ERROR_SERVICE_NOT_FOUND
   Win error

--*/

{
   DWORD dwError = ERROR_SERVICE_NOT_FOUND;

   if ( l_dwOldEntryIndex == nIndex )
   {
      dwError = NoCertificateEnter( m_hWnd, m_pszServerName, m_pszProductName, m_pszVendor, m_dwEnterFlags );
   }
   else
   {
      HMODULE     hDll;

      hDll = ::LoadLibrary( m_cslSourceList.GetSourceImagePath( nIndex ) );

      if ( NULL == hDll )
      {
         dwError = GetLastError();
         theApp.SetLastError( dwError );
         theApp.DisplayLastError();
      }
      else
      {
         CHAR              szExportName[ 256 ];
         PCCF_ENTER_API    pfn;

         wsprintfA( szExportName, "%lsCertificateEnter", m_cslSourceList.GetSourceName( nIndex ) );

         pfn = (PCCF_ENTER_API) GetProcAddress( hDll, szExportName );

         if ( NULL == pfn )
         {
            dwError = GetLastError();
            theApp.SetLastError( dwError );
            theApp.DisplayLastError();
         }
         else
         {
            dwError = (*pfn)( m_hWnd, m_pszServerName, m_pszProductName, m_pszVendor, m_dwEnterFlags );
         }

         ::FreeLibrary( hDll );
      }
   }

   return dwError;
}


void CCertSourceSelectDlg::AbortDialogIfNecessary()

/*++

Routine Description:

   Display error message and abort dialog if connection lost.

Arguments:

   None.

Return Values:

   None.

--*/

{
   theApp.DisplayLastError();

   if ( theApp.IsConnectionDropped() )
   {
      EndDialog( IDABORT );
   }
}


BOOL CCertSourceSelectDlg::ConnectServer()

/*++

Routine Description:

   Establish a connection to the license service on the target server.

Arguments:

   None.

Return Values:

   BOOL.

--*/

{
   NTSTATUS    nt;

   if ( NULL == m_hLls )
   {
      LPTSTR   pszUniServerName = NULL;

      if ( NULL == m_pszServerName )
      {
         pszUniServerName = NULL;
         nt = STATUS_SUCCESS;
      }
      else
      {
         pszUniServerName = (LPTSTR) LocalAlloc( LMEM_FIXED, sizeof( TCHAR ) * ( 1 + strlen( m_pszServerName ) ) );

         if ( NULL == pszUniServerName )
         {
            nt = ERROR_NOT_ENOUGH_MEMORY;
            theApp.SetLastError( (DWORD) nt );
         }
         else
         {
            wsprintf( pszUniServerName, TEXT( "%hs" ), m_pszServerName );
            nt = STATUS_SUCCESS;
         }
      }

      if ( STATUS_SUCCESS == nt )
      {
         nt = ConnectTo( pszUniServerName, &m_hLls );
      }

      if ( NULL != pszUniServerName )
      {
         LocalFree( pszUniServerName );
      }
   }

   if ( NULL == m_hLls )
   {
      theApp.DisplayLastError();

      if ( ( NULL != m_hWnd ) && IsWindow( m_hWnd ) )
      {
         EndDialog( IDABORT );
      }
   }

   return ( NULL != m_hLls );
}


NTSTATUS CCertSourceSelectDlg::ConnectTo( LPTSTR pszServerName, PLLS_HANDLE phLls )

/*++

Routine Description:

   Establish a connection to the license service on the given server.

Arguments:

   pszServerName (CString)
      The target server.  An empty value indicates the local server.
   phLls (PLLS_HANDLE)
      On return, holds the handle to the standard LLS RPC.

Return Values:

   STATUS_SUCCESS or NT status code.

--*/

{
   NTSTATUS    nt;

   nt = ::LlsConnect( pszServerName, phLls );
   theApp.SetLastLlsError( nt );

   if ( STATUS_SUCCESS != nt )
   {
      *phLls = NULL;
   }

   return nt;
}


DWORD CCertSourceSelectDlg::CertificateEnter( HWND hWndParent, LPCSTR pszServerName, LPCSTR pszProductName, LPCSTR pszVendor, DWORD dwFlags, LPCSTR pszSourceToUse )

/*++

Routine Description:

   Display a dialog allowing the user to enter a license certificate
   into the system.

Arguments:

   pszServerName (LPCSTR)
      Name of the server for which licenses are to be installed.  Note that
      this may not be the same as the server on which licenses are actually
      installed, as, for example, per seat licenses are always installed on
      the enterprise server.  A NULL value indicates the local server.
   pszProductName (LPCSTR)
      Product for which licenses are to be installed.  A NULL value indicates
      that the user should be allowed to choose.
   pszVendor (LPCSTR)
      Name of the vendor of the product.  This value should be NULL if
      pszProductName is NULL, and should be non-NULL if pszProductName is
      non-NULL.
   dwFlags (DWORD)
      A bitfield containing one or more of the following:
         CCF_ENTER_FLAG_PER_SEAT_ONLY
            Allow the user to enter only per seat licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SERVER_ONLY.
         CCF_ENTER_FLAG_PER_SERVER_ONLY
            Allow the user to enter only per server licenses.  Not valid in
            combination with CCF_ENTER_FLAG_PER_SEAT_ONLY.
   pszSourceToUse (LPCSTR)
      Name of the secure certificate source to use to install the certificate,
      e.g., "Paper".  A NULL value indicates that the user should be allowed
      to choose.

Return Value:

   ERROR_SUCCESS     (A certificate was successfully entered into the system.)
   ERROR_CANCELLED   (The user cancelled without installing a certificate.)
   other Win error

--*/

{
   DWORD dwError;

   m_pszServerName  = pszServerName;
   m_pszProductName = pszProductName;
   m_pszVendor      = pszVendor;
   m_dwEnterFlags   = dwFlags;

   if ( pszSourceToUse != NULL )
   {
      CString  strSourceToUse = pszSourceToUse;
      int      nSrcIndex;

      for ( nSrcIndex = 0; nSrcIndex < m_cslSourceList.GetNumSources(); nSrcIndex++ )
      {
         if ( !strSourceToUse.CompareNoCase( m_cslSourceList.GetSourceDisplayName( nSrcIndex ) ) )
         {
            // use this certificate source
            break;
         }
      }

      if ( m_cslSourceList.GetNumSources() == nSrcIndex )
      {
         // requested certificate source is not available
         dwError = ERROR_SERVICE_NOT_FOUND;
      }
      else
      {
         // don't display dialog, just use the indicated source
         dwError = CallCertificateSource( nSrcIndex );
      }
   }
   else if ( pszProductName != NULL )
   {
      // find out if this is a secure product
      if ( !ConnectServer() )
      {
         dwError = theApp.GetLastError();
      }
      else
      {
         BOOL  bProductIsSecure;

         if ( !LlsCapabilityIsSupported( m_hLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
         {
            // no extended RPC, so all products on this server must be unsecure
            bProductIsSecure = FALSE;
            dwError = ERROR_SUCCESS;
         }
         else
         {
            LPTSTR   pszUniProductName;

            pszUniProductName = (LPTSTR) LocalAlloc( LMEM_FIXED, sizeof( TCHAR ) * ( 1 + strlen( pszProductName ) ) );

            if ( NULL == pszUniProductName )
            {
               dwError = ERROR_NOT_ENOUGH_MEMORY;
               theApp.SetLastError( dwError );
               theApp.DisplayLastError();
            }
            else
            {
               dwError = ERROR_SUCCESS;

               wsprintf( pszUniProductName, TEXT( "%hs" ), pszProductName );

               BOOL    bIsSecure;

               bProductIsSecure =    ( STATUS_SUCCESS == ::LlsProductSecurityGet( m_hLls, pszUniProductName, &bIsSecure ) )
                                  && bIsSecure;

               LocalFree( pszUniProductName );
            }
         }

         if ( ERROR_SUCCESS == dwError )
         {

            if ( !bProductIsSecure )
            {
               // unsecure product; no need to select source
               dwError = NoCertificateEnter( hWndParent, pszServerName, pszProductName, pszVendor, dwFlags );
            }
            else

            if ( 1 == m_cslSourceList.GetNumSources() )
            {
               // product is secure and there is only one source to choose from; use it!
               dwError = CallCertificateSource( 0 );
            }
            else if ( IDOK == DoModal() )
            {
               dwError = ERROR_SUCCESS;
            }
            else
            {
               dwError = ERROR_CANCELLED;
            }
         }
      }
   }
   else if ( !ConnectServer() )
   {
      dwError = theApp.GetLastError();
   }
   else if (    !LlsCapabilityIsSupported( m_hLls, LLS_CAPABILITY_SECURE_CERTIFICATES )
             || !m_cslSourceList.GetNumSources() )
   {
      // secure certificates not supported or no sources available; use unsecure source
      dwError = NoCertificateEnter( hWndParent, pszServerName, pszProductName, pszVendor, dwFlags );
   }
   else if ( IDOK == DoModal() )
   {
      dwError = ERROR_SUCCESS;
   }
   else
   {
      dwError = ERROR_CANCELLED;
   }

   return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\client\llsrpc.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   llsrpc.c

Abstract:

   Client side RPC wrappers for License Logging Service.

Author:

   Arthur Hanson (arth) 30-Jan-1995

Revision History:

   Jeff Parham (jeffparh) 04-Dec-1995
      o  Forced include of LLS API prototypes, exposing an incorrect prototype
         in LLSAPI.H.
      o  Fixed case where an LSA access denied was interpreted as implying the
         server had no DC, rather than properly bubbling the access denied back
         to the caller (of LlsConnectEnterprise()).  This plugs a security hole
         wherein a non-admin user with the ability to read the System registry
         key would be allowed to administer domain licenses through
         License Manager. (Bug #11441.)
      o  Added functions to support extended LLSRPC API.
      o  Removed replication dependency on no further LlsConnect()'s being made
         until replication was completed.
      o  Installed lock around llsrpc_handle global binding variable.  Required
         addition of DllMain() function.
      o  Added LLSRPC capabilities detection.  Upon connection, the client
         requests the server's capabilities (an RPC call which itself will fail
         when connected to a 3.51 server).  The capabilities set is an
         arbitrary bit field, but individual bits are normally defined to
         indicate that a specific feature has been implemented at the server.
      o  Added szServerName filed to LOCAL_HANDLE to remember the name of the
         machine to which we're connected.

--*/

#include <nt.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <dsgetdc.h>
#include <dsrole.h>
#include "debug.h"

#include "llsapi.h"
#include "llsrpc_c.h"
#include "lsapi_c.h"

// #define API_TRACE

typedef struct _GENERIC_INFO_CONTAINER {
    DWORD       EntriesRead;
    LPBYTE      Buffer;
} GENERIC_INFO_CONTAINER, *PGENERIC_INFO_CONTAINER, *LPGENERIC_INFO_CONTAINER ;

typedef struct _GENERIC_ENUM_STRUCT {
    DWORD                   Level;
    PGENERIC_INFO_CONTAINER Container;
} GENERIC_ENUM_STRUCT, *PGENERIC_ENUM_STRUCT, *LPGENERIC_ENUM_STRUCT ;


typedef struct _LOCAL_HANDLE {
   TCHAR       szServerName[ 3 + MAX_PATH ];
   LPTSTR      pszStringBinding;
   handle_t    llsrpc_handle;
   LLS_HANDLE  Handle;
   BYTE        Capabilities[ ( LLS_CAPABILITY_MAX + 7 ) / 8 ];
} LOCAL_HANDLE, *PLOCAL_HANDLE;


LPTSTR pszStringBinding = NULL;


RTL_CRITICAL_SECTION    g_RpcHandleLock;


/////////////////////////////////////////////////////////////////////////
BOOL APIENTRY DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )

/*++

Routine Description:

   Standard DLL entry point.

Arguments:

   hInstance (HINSTANCE)
   dwReason (DWORD)
   lpReserved (LPVOID)

Return Value:

   TRUE if successful.

--*/

{
   NTSTATUS nt = STATUS_SUCCESS;

   switch (dwReason)
   {
   case DLL_PROCESS_ATTACH:
      DisableThreadLibraryCalls(hInstance);
      nt = RtlInitializeCriticalSection( &g_RpcHandleLock );
      break;

   case DLL_PROCESS_DETACH:
      nt = RtlDeleteCriticalSection( &g_RpcHandleLock );
      break;
   }

   return NT_SUCCESS( nt );
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTDomainGet(
   LPTSTR ServerName,
   LPTSTR Domain
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   TCHAR Serv[MAX_PATH + 3];
   UNICODE_STRING us;
   NTSTATUS ret;
   OBJECT_ATTRIBUTES oa;
   ACCESS_MASK am;
   SECURITY_QUALITY_OF_SERVICE qos;
   LSA_HANDLE hLSA;
   PPOLICY_PRIMARY_DOMAIN_INFO pvBuffer;

   lstrcpy(Domain, TEXT(""));

   // only need read access
   //
   //am = POLICY_READ | POLICY_VIEW_LOCAL_INFORMATION;
   am = MAXIMUM_ALLOWED;


   // set up quality of service
   qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
   qos.ImpersonationLevel = SecurityImpersonation;
   qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
   qos.EffectiveOnly = FALSE;

   // Macro sets everything except security field
   InitializeObjectAttributes( &oa, NULL, 0L, NULL, NULL );
   oa.SecurityQualityOfService = &qos;

   if ( (ServerName == NULL) || (ServerName[0] == TEXT('\0')) )
      ret = LsaOpenPolicy(NULL, &oa, am, &hLSA);
   else {
      if (ServerName[0] == TEXT('\\'))
         lstrcpy(Serv, ServerName);
      else
         wsprintf(Serv, TEXT("\\\\%s"), ServerName);

      // Set up unicode string structure
      us.Length = (USHORT)(lstrlen(Serv) * sizeof(TCHAR));
      us.MaximumLength = us.Length + sizeof(TCHAR);
      us.Buffer = Serv;

      ret = LsaOpenPolicy(&us, &oa, am, &hLSA);
   }

   if (!ret) {
      ret = LsaQueryInformationPolicy(hLSA, PolicyPrimaryDomainInformation, (PVOID *) &pvBuffer);
      LsaClose(hLSA);
      if ((!ret) && (pvBuffer != NULL) && (pvBuffer->Sid != NULL)) {
         lstrcpy(Domain, pvBuffer->Name.Buffer);
         LsaFreeMemory((PVOID) pvBuffer);
      } else
         if (!ret)
            ret = STATUS_UNSUCCESSFUL;
   }

   return ret;

} // NTDomainGet


/////////////////////////////////////////////////////////////////////////
NTSTATUS
EnterpriseServerGet(
   LPTSTR ServerName,
   LPTSTR pEnterpriseServer
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   HKEY hKey = NULL;
   HKEY hKey2 = NULL;
   BOOL Enterprise = FALSE;
   BOOL bIsNetBIOSName = TRUE;
   DWORD dwType, dwSize;
   TCHAR RegKeyText[512];
   NTSTATUS Status;
   DWORD UseEnterprise;
   TCHAR EnterpriseServer[MAX_PATH + 3] = TEXT("");
   LPTSTR pName = ServerName;

   Status = RegConnectRegistry(ServerName, HKEY_LOCAL_MACHINE, &hKey);
   if (Status == ERROR_SUCCESS) {
      //
      // Create registry key-name we are looking for
      //
      lstrcpy(RegKeyText, TEXT("System\\CurrentControlSet\\Services\\LicenseService\\Parameters"));

      if ((Status = RegOpenKeyEx(hKey, RegKeyText, 0, KEY_READ, &hKey2)) == ERROR_SUCCESS) {
         dwSize = sizeof(UseEnterprise);
         Status = RegQueryValueEx(hKey2, TEXT("UseEnterprise"), NULL, &dwType, (LPBYTE) &UseEnterprise, &dwSize);

         if ((Status == ERROR_SUCCESS) && (UseEnterprise == 1)) {
            //
            //                  ** NEW - NT 5.0 **
            //
            // NB : This is temporary code! The proper way to do this is to
            //      consult the license settings object in the site in which
            //      the server resides.
            //
            // Read the SiteServer value first, if available, to get the site
            // server's DNS name. If this fails, default to EnterpriseServer.
            //
            dwSize = sizeof(EnterpriseServer);
            Status = RegQueryValueEx(hKey2,
                                     TEXT("SiteServer"),
                                     NULL,
                                     &dwType,
                                     (LPBYTE) &EnterpriseServer,
                                     &dwSize);

            if (Status == ERROR_SUCCESS && EnterpriseServer[0]) {
               bIsNetBIOSName = FALSE;
            }
            else {
               dwSize = sizeof(EnterpriseServer);
               Status = RegQueryValueEx(hKey2,
                                        TEXT("EnterpriseServer"),
                                        NULL,
                                        &dwType,
                                        (LPBYTE) &EnterpriseServer,
                                        &dwSize);
            }

            if (Status == ERROR_SUCCESS) {
               pName = EnterpriseServer;
            }
         }

         RegCloseKey(hKey2);
      }

      RegCloseKey(hKey);
   }

   if (bIsNetBIOSName && *pName != TEXT('\\')) {
      lstrcpy(pEnterpriseServer, TEXT("\\\\"));
      lstrcat(pEnterpriseServer, pName);
   } else
      lstrcpy(pEnterpriseServer, pName);

   return STATUS_SUCCESS;
} // EnterpriseServerGet


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsEnterpriseServerFindW(
   LPTSTR Focus,
   DWORD Level,
   LPBYTE *BufPtr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   LPTSTR pFocus;
   BOOL Domain = TRUE;
   LPTSTR pszUuid = NULL;
   LPTSTR pszProtocolSequence = NULL;
   LPTSTR pszNetworkAddress = NULL;
   LPTSTR pszEndpoint = NULL;
   LPTSTR pszOptions = NULL;
   TCHAR EnterpriseServer[MAX_PATH + 4];
   TCHAR pDomain[MAX_PATH + 4];
   DWORD uRet;
   PDOMAIN_CONTROLLER_INFO pbBuffer = NULL;
   PLLS_CONNECT_INFO_0 pConnectInfo;
   ULONG Size;
   DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;
   BOOL fInWorkgroup = TRUE;

   if (Level != 0)
      return STATUS_INVALID_LEVEL;

   pDomain[0] = 0;
   EnterpriseServer[0] = 0;

   //
   // Figure out if doing domain or server
   //
   pFocus = Focus;
   if (pFocus !=NULL)
      while ((*pFocus != TEXT('\0')) && (*pFocus == TEXT('\\'))) {
         Domain = FALSE;
         pFocus++;
      }

   uRet = DsRoleGetPrimaryDomainInformation((!Domain) ? Focus : NULL,
                                             DsRolePrimaryDomainInfoBasic,
                                             (PBYTE *) &pDomainInfo);

   if ((uRet == NO_ERROR) && (pDomainInfo != NULL) && (pDomainInfo->MachineRole != DsRole_RoleStandaloneWorkstation) && (pDomainInfo->MachineRole != DsRole_RoleStandaloneServer))
   {
       fInWorkgroup = FALSE;
   }

   if ((uRet == NO_ERROR) && (pDomainInfo != NULL))
   {
       DsRoleFreeMemory(pDomainInfo);
   }

   if (!fInWorkgroup)
   {
       //
       // If we got a domain find the DC of it, else find DC of server
       //
       if (!Domain) {
           uRet = DsGetDcName(Focus, NULL, NULL, NULL, DS_BACKGROUND_ONLY, &pbBuffer);
       } else {
           //
           // Get the DC name of wherever we are going
           //
           if ((pFocus == NULL) || (*pFocus == TEXT('\0')))
               uRet = DsGetDcName(NULL, NULL, NULL, NULL, DS_BACKGROUND_ONLY, &pbBuffer);
           else
               uRet = DsGetDcName(NULL, pFocus, NULL, NULL, DS_BACKGROUND_ONLY, &pbBuffer);
       }
   }
   else
   {
       //
       // Not in a domain, don't call DsGetDcName
       //

       uRet = ERROR_NO_SUCH_DOMAIN;
   }

   if (uRet || (pbBuffer == NULL)) {
      //
      // If we focus on a server and can't find a domain then look for an
      // enterprise server.  This is the case if the focus server is a
      // standalone system.
      //
      if (Domain == FALSE) {
         Status = EnterpriseServerGet((LPTSTR) Focus, EnterpriseServer);
         goto LlsEnterpriseServerFindWExit;
      }

      return STATUS_NO_SUCH_DOMAIN;
   } else {
       lstrcpy(pDomain,pbBuffer->DomainName);
   }

   //
   // Go to DC and figure out if they are replicating anywhere, if so go
   // to that system.
   //
   Status = EnterpriseServerGet((LPTSTR) (pbBuffer->DomainControllerName), EnterpriseServer);

   if (pbBuffer != NULL)
      NetApiBufferFree(pbBuffer);

LlsEnterpriseServerFindWExit:
   if (Status != STATUS_SUCCESS)
      return Status;

   Size = sizeof(LLS_CONNECT_INFO_0);
   Size += ((lstrlen(pDomain) + 1) * sizeof(TCHAR));
   Size += ((lstrlen(EnterpriseServer) + 1) * sizeof(TCHAR));

   pConnectInfo = (PLLS_CONNECT_INFO_0) MIDL_user_allocate(Size);
   if (pConnectInfo == NULL)
      return STATUS_NO_MEMORY;

   pConnectInfo->Domain = (LPTSTR) (((PBYTE) pConnectInfo) + sizeof(LLS_CONNECT_INFO_0));
   pConnectInfo->EnterpriseServer = (LPTSTR) &pConnectInfo->Domain[lstrlen(pDomain) + 1];

   lstrcpy(pConnectInfo->Domain, pDomain);
   lstrcpy(pConnectInfo->EnterpriseServer, EnterpriseServer);
   *BufPtr = (LPBYTE) pConnectInfo;
   return Status;

} // LlsEnterpriseServerFindW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsEnterpriseServerFindA(
   LPSTR Focus,
   DWORD Level,
   LPBYTE *BufPtr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsEnterpriseServerFindA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsEnterpriseServerFindA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsConnectW(
   LPTSTR Server,
   LLS_HANDLE* Handle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   RPC_STATUS Status;
   LPTSTR pszUuid = NULL;
   LPTSTR pszProtocolSequence = NULL;
   LPTSTR pszNetworkAddress = NULL;
   LPTSTR pszEndpoint = NULL;
   LPTSTR pszOptions = NULL;
   TCHAR pComputer[MAX_COMPUTERNAME_LENGTH + 1];
   ULONG Size;
   PLOCAL_HANDLE pLocalHandle = NULL;
   handle_t prev_llsrpc_handle;

#ifdef API_TRACE
   if (Server == NULL)
      dprintf(TEXT("LLSRPC.DLL: LlsConnectW: <NULL>\n"));
   else
      dprintf(TEXT("LLSRPC.DLL: LlsConnectW: %s\n"), Server);
#endif

   //
   //                   ** NEW - NT 5.0 **
   //
   // The server name may either be a DNS name or a NetBIOS name.
   //

   if (Handle == NULL)
      return STATUS_INVALID_PARAMETER;

   *Handle = NULL;
   Size = sizeof(pComputer) / sizeof(TCHAR);
   GetComputerName(pComputer, &Size);

   if ((Server == NULL) || (*Server == TEXT('\0'))) {
      pszProtocolSequence = TEXT("ncalrpc");
      pszEndpoint = TEXT(LLS_LPC_ENDPOINT);
      pszNetworkAddress = NULL;
   } else {
      pszProtocolSequence = TEXT("ncacn_np");
      pszEndpoint = TEXT(LLS_NP_ENDPOINT);
      pszNetworkAddress = Server;
   }

   pLocalHandle = MIDL_user_allocate(sizeof(LOCAL_HANDLE));
   if (pLocalHandle == NULL)
      return STATUS_NO_MEMORY;

   pLocalHandle->pszStringBinding = NULL;
   pLocalHandle->llsrpc_handle = NULL;
   pLocalHandle->Handle = NULL;

   ZeroMemory( pLocalHandle->szServerName, sizeof( pLocalHandle->szServerName ) );
   if ( NULL != Server )
   {
      lstrcpyn( pLocalHandle->szServerName, Server, sizeof( pLocalHandle->szServerName ) / sizeof( *pLocalHandle->szServerName ) - 1 );
   }
   else
   {
      lstrcpy( pLocalHandle->szServerName, pComputer );
   }

   // Compose a string binding
   Status = RpcStringBindingComposeW(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pLocalHandle->pszStringBinding);
   if(Status) {
#if DBG
      dprintf(TEXT("LLSRPC RpcStringBindingComposeW Failed: 0x%lX\n"), Status);
#endif

        if(pLocalHandle->pszStringBinding)	  
        {
            RpcStringFree(&pLocalHandle->pszStringBinding);
            pLocalHandle->pszStringBinding = NULL;
        }
	  
      MIDL_user_free( pLocalHandle );

      return I_RpcMapWin32Status(Status);
   }

   RtlEnterCriticalSection( &g_RpcHandleLock );
   prev_llsrpc_handle = llsrpc_handle;

   llsrpc_handle = NULL;
   // Bind using the created string binding...
   Status = RpcBindingFromStringBindingW(pLocalHandle->pszStringBinding, &llsrpc_handle);
   if(Status) {
#if DBG
      dprintf(TEXT("LLSRPC RpcBindingFromStringBindingW Failed: 0x%lX\n"), Status);
#endif
        if(llsrpc_handle)
        {
            RpcBindingFree(llsrpc_handle);
            llsrpc_handle = prev_llsrpc_handle;
        }

      Status = I_RpcMapWin32Status(Status);
   }

   if ( NT_SUCCESS( Status ) )
   {
      pLocalHandle->llsrpc_handle = llsrpc_handle;

      try {
         Status = LlsrConnect(&pLocalHandle->Handle, pComputer);         
      }
      except (TRUE) {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("LLSRPC ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }

      if ( NT_SUCCESS( Status ) )
      {
         // get server capabilities
         try {
            LlsrCapabilityGet( pLocalHandle->Handle, sizeof( pLocalHandle->Capabilities ), pLocalHandle->Capabilities );
         }
         except (TRUE) {
            Status = I_RpcMapWin32Status(RpcExceptionCode());

            if ( RPC_NT_PROCNUM_OUT_OF_RANGE == Status )
            {
               // 'salright; API doesn't exist at target server (it's running 3.51)
               ZeroMemory( pLocalHandle->Capabilities, sizeof( pLocalHandle->Capabilities ) );
               Status = STATUS_SUCCESS;
            }
            else
            {            
#if DBG
            dprintf(TEXT("LLSRPC ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
            }
         }

         if ( !NT_SUCCESS( Status ) )
         {
            LlsClose( pLocalHandle );
         }
         else
         {
            *Handle = (LLS_HANDLE) pLocalHandle;
         }
      }
      else
      {          
        if(pLocalHandle->pszStringBinding)	  
        {
            RpcStringFree(&pLocalHandle->pszStringBinding);
            pLocalHandle->pszStringBinding = NULL;
        }

        if(llsrpc_handle)
        {
            RpcBindingFree(llsrpc_handle);
            llsrpc_handle = prev_llsrpc_handle;
        }

        MIDL_user_free( pLocalHandle );
     }      
   }
   else
   {
        if(pLocalHandle->pszStringBinding)	  
            RpcStringFree(&pLocalHandle->pszStringBinding);

        MIDL_user_free( pLocalHandle );
   }

   llsrpc_handle = prev_llsrpc_handle;

   RtlLeaveCriticalSection( &g_RpcHandleLock );

   return Status;
} // LlsConnectW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsConnectA(
   LPSTR Server,
   LLS_HANDLE* Handle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsConnectA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsConnectA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsConnectEnterpriseW(
   LPTSTR Focus,
   LLS_HANDLE* Handle,
   DWORD Level,
   LPBYTE *BufPtr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLLS_CONNECT_INFO_0 pConnectInfo;

   Status = LlsEnterpriseServerFindW(Focus, Level, BufPtr);

   if (Status)
      return Status;

   pConnectInfo = (PLLS_CONNECT_INFO_0) *BufPtr;
   Status = LlsConnectW(pConnectInfo->EnterpriseServer, Handle);

   return Status;

} // LlsConnectEnterpriseW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsConnectEnterpriseA(
   LPSTR Focus,
   LLS_HANDLE* Handle,
   DWORD Level,
   LPBYTE *BufPtr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsConnectEnterpriseA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsConnectEnterpriseA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsClose(
   LLS_HANDLE Handle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   RPC_STATUS Status;
   NTSTATUS NtStatus = STATUS_SUCCESS;
   PLOCAL_HANDLE pLocalHandle;

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      NtStatus = LlsrCloseEx(&(pLocalHandle->Handle));
   }
   except (TRUE) {
      NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: LlsrCloseEx RPC Exception: 0x%lX\n"), NtStatus);
#endif
   }

   //
   // LlsrCloseEx was added for NT 5.0. Check for downlevel.
   //

   if (NtStatus == RPC_S_PROCNUM_OUT_OF_RANGE) {
      try {
         NtStatus = LlsrClose(pLocalHandle->Handle);
      }
      except (TRUE) {
         NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: LlsrClose RPC Exception: 0x%lX\n"), NtStatus);
#endif
      }
   }

   try {
      Status = RpcStringFree(&pLocalHandle->pszStringBinding);
      if (Status ) {
         NtStatus = I_RpcMapWin32Status(Status);
#if DBG
         dprintf(TEXT("LLSRPC.DLL: LlsClose - RpcStringFree returned: 0x%lX\n"), NtStatus);
#endif
      }

      Status = RpcBindingFree(&pLocalHandle->llsrpc_handle);
      if (Status ) {
         NtStatus = I_RpcMapWin32Status(Status);
#if DBG
         dprintf(TEXT("LLSRPC.DLL: LlsClose - RpcBindingFree returned: 0x%lX\n"), NtStatus);
#endif
      }
   }
   except (TRUE) {
      NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), NtStatus);
#endif
   }

   MIDL_user_free(pLocalHandle);
   return NtStatus;

} // LlsClose


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsFreeMemory(
    PVOID BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   MIDL_user_free( BufPtr );
   return STATUS_SUCCESS;
} // LlsFreeMemory


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsLicenseEnumW(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLicenseEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrLicenseEnumW(
                   pLocalHandle->Handle,
                   (PLLS_LICENSE_ENUM_STRUCTW) &InfoStruct,
                   PrefMaxLen,
                   TotalEntries,
                   ResumeHandle
                   );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsLicenseEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsLicenseEnumA(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLicenseEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrLicenseEnumA(
                pLocalHandle->Handle,
                (PLLS_LICENSE_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;

} // LlsLicenseEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsLicenseAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLicenseAddW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrLicenseAddW(pLocalHandle->Handle, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsLicenseAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsLicenseAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLicenseAddA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrLicenseAddA(pLocalHandle->Handle, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsLicenseAddA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductEnumW(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrProductEnumW(
                pLocalHandle->Handle,
                (PLLS_PRODUCT_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;

} // LlsProductEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductEnumA(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrProductEnumA(
                pLocalHandle->Handle,
                (PLLS_PRODUCT_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsProductEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsProductAddW(
   IN LLS_REPL_HANDLE Handle,
   IN LPWSTR ProductFamily,
   IN LPWSTR Product,
   IN LPWSTR Version
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductAddW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrProductAddW(pLocalHandle->Handle, ProductFamily, Product, Version);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsProductAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsProductAddA(
   IN LLS_REPL_HANDLE Handle,
   IN LPSTR ProductFamily,
   IN LPSTR Product,
   IN LPSTR Version
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductAddA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrProductAddA(pLocalHandle->Handle, ProductFamily, Product, Version);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsProductAddA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductUserEnumW(
   LLS_HANDLE Handle,
   LPTSTR     Product,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductUserEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrProductUserEnumW(
                pLocalHandle->Handle,
                Product,
                (PLLS_PRODUCT_USER_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsProductUserEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductUserEnumA(
   LLS_HANDLE Handle,
   LPSTR      Product,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductUserEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrProductUserEnumA(
                pLocalHandle->Handle,
                Product,
                (PLLS_PRODUCT_USER_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsProductUserEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductServerEnumW(
   LLS_HANDLE Handle,
   LPTSTR     Product,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductServerEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrProductServerEnumW(
                pLocalHandle->Handle,
                Product,
                (PLLS_SERVER_PRODUCT_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsProductServerEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductServerEnumA(
   LLS_HANDLE Handle,
   LPSTR      Product,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductServerEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrProductServerEnumA(
                pLocalHandle->Handle,
                Product,
                (PLLS_SERVER_PRODUCT_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsProductServerEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductLicenseEnumW(
   LLS_HANDLE Handle,
   LPTSTR     Product,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductLicenseEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrProductLicenseEnumW(
                pLocalHandle->Handle,
                Product,
                (PLLS_PRODUCT_LICENSE_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsProductLicenseEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductLicenseEnumA(
   LLS_HANDLE Handle,
   LPSTR      Product,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductLicenseEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrProductLicenseEnumA(
                pLocalHandle->Handle,
                Product,
                (PLLS_PRODUCT_LICENSE_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsProductLicenseEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserEnumW(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrUserEnumW(
                pLocalHandle->Handle,
                (PLLS_USER_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsUserEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserEnumA(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrUserEnumA(
                pLocalHandle->Handle,
                (PLLS_USER_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsUserEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     User,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserInfoGetW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if ((pLocalHandle == NULL) || (bufptr == NULL))
      return STATUS_INVALID_PARAMETER;

   *bufptr = NULL;

   try {
      Status = LlsrUserInfoGetW(pLocalHandle->Handle, User, Level, (PLLS_USER_INFOW *) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsUserInfoGetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      User,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserInfoGetA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if ((pLocalHandle == NULL) || (bufptr == NULL))
      return STATUS_INVALID_PARAMETER;

   *bufptr = NULL;

   try {
      Status = LlsrUserInfoGetA(pLocalHandle->Handle, User, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsUserInfoGetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserInfoSetW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrUserInfoSetW(pLocalHandle->Handle, User, Level, (PLLS_USER_INFOW) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsUserInfoSetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserInfoSetA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrUserInfoSetA(pLocalHandle->Handle, User, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsUserInfoSetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserDeleteW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrUserDeleteW(pLocalHandle->Handle, User);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsUserDeleteW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR     User
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserDeleteA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrUserDeleteA(pLocalHandle->Handle, User);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsUserDeleteA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserProductEnumW(
   LLS_HANDLE Handle,
   LPTSTR     User,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserProductEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrUserProductEnumW(
                pLocalHandle->Handle,
                User,
                (PLLS_USER_PRODUCT_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsUserProductEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserProductEnumA(
   LLS_HANDLE Handle,
   LPSTR      User,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserProductEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrUserProductEnumA(
                pLocalHandle->Handle,
                User,
                (PLLS_USER_PRODUCT_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsUserProductEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserProductDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN LPWSTR     Product
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserProductDeleteW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrUserProductDeleteW(pLocalHandle->Handle, User, Product);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsUserProductDeleteW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsUserProductDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN LPSTR      Product
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsUserProductDeleteA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrUserProductDeleteA(pLocalHandle->Handle, User, Product);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsUserProductDeleteA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupEnumW(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrMappingEnumW(
                pLocalHandle->Handle,
                (PLLS_MAPPING_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsGroupEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupEnumA(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrMappingEnumA(
                pLocalHandle->Handle,
                (PLLS_MAPPING_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsGroupEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     Group,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupInfoGetW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if ((pLocalHandle == NULL) || (bufptr == NULL))
      return STATUS_INVALID_PARAMETER;

   *bufptr = NULL;

   try {
      Status = LlsrMappingInfoGetW(pLocalHandle->Handle, Group, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupInfoGetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      Group,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupInfoGetA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if ((pLocalHandle == NULL) || (bufptr == NULL))
      return STATUS_INVALID_PARAMETER;

   *bufptr = NULL;

   try {
      Status = LlsrMappingInfoGetA(pLocalHandle->Handle, Group, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupInfoGetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupInfoSetW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrMappingInfoSetW(pLocalHandle->Handle, Group, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupInfoSetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupInfoSetA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrMappingInfoSetA(pLocalHandle->Handle, Group, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupInfoSetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupUserEnumW(
   LLS_HANDLE Handle,
   LPTSTR     Group,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupUserEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrMappingUserEnumW(
                pLocalHandle->Handle,
                Group,
                (PLLS_USER_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsGroupUserEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupUserEnumA(
   LLS_HANDLE Handle,
   LPSTR      Group,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupUserEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrMappingUserEnumA(
                pLocalHandle->Handle,
                Group,
                (PLLS_USER_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsGroupUserEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupUserAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupUserAddW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrMappingUserAddW(pLocalHandle->Handle, Group, User);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupUserAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupUserAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupUserAddA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrMappingUserAddA(pLocalHandle->Handle, Group, User);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupUserAddA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupUserDeleteW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrMappingUserDeleteW(pLocalHandle->Handle, Group, User);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupUserDeleteW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupUserDeleteA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrMappingUserDeleteA(pLocalHandle->Handle, Group, User);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupUserDeleteA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupAddW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrMappingAddW(pLocalHandle->Handle, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupAddA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrMappingAddA(pLocalHandle->Handle, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupAddA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsGroupDeleteW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrMappingDeleteW(pLocalHandle->Handle, Group);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupDeleteW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsGroupDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: GroupDeleteA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrMappingDeleteA(pLocalHandle->Handle, Group);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsGroupDeleteA


#ifdef OBSOLETE
/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsServerEnumW(
   LLS_HANDLE Handle,
   LPWSTR     Server,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsServerEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrServerEnumW(
                pLocalHandle->Handle,
                Server,
                (PLLS_SERVER_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsServerEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsServerEnumA(
   LLS_HANDLE Handle,
   LPSTR      Server,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsServerEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrServerEnumA(
                pLocalHandle->Handle,
                Server,
                (PLLS_SERVER_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsServerEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsServerProductEnumW(
   LLS_HANDLE Handle,
   LPWSTR     Server,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsServerProductEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrServerProductEnumW(
                pLocalHandle->Handle,
                Server,
                (PLLS_SERVER_PRODUCT_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsServerProductEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsServerProductEnumA(
   LLS_HANDLE Handle,
   LPSTR      Server,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsServerProductEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrServerProductEnumA(
                pLocalHandle->Handle,
                Server,
                (PLLS_SERVER_PRODUCT_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsServerProductEnumA

/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsLocalProductEnumW(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalProductEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrLocalProductEnumW(
                pLocalHandle->Handle,
                (PLLS_SERVER_PRODUCT_ENUM_STRUCTW) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsLocalProductEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsLocalProductEnumA(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalProductEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = Level;

   try {
      Status = LlsrLocalProductEnumA(
                pLocalHandle->Handle,
                (PLLS_SERVER_PRODUCT_ENUM_STRUCTA) &InfoStruct,
                PrefMaxLen,
                TotalEntries,
                ResumeHandle
                );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
      *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
      *EntriesRead = GenericInfoContainer.EntriesRead;
   }


   return Status;
} // LlsLocalProductEnumA

/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsLocalProductInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     Product,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalProductInfoGetW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if ((pLocalHandle == NULL) || (bufptr == NULL))
      return STATUS_INVALID_PARAMETER;

   *bufptr = NULL;

   try {
      Status = LlsrLocalProductInfoGetW(pLocalHandle->Handle, Product, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsLocalProductInfoGetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsLocalProductInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      Product,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalProductInfoGetA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if ((pLocalHandle == NULL) || (bufptr == NULL))
      return STATUS_INVALID_PARAMETER;

   *bufptr = NULL;

   try {
      Status = LlsrLocalProductInfoGetA(pLocalHandle->Handle, Product, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsLocalProductInfoGetA

/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsLocalProductInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalProductInfoSetW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrLocalProductInfoSetW(pLocalHandle->Handle, Product, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsLocalProductInfoSetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsLocalProductInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalProductInfoSetA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrLocalProductInfoSetA(pLocalHandle->Handle, Product, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsLocalProductInfoSetA

#endif // OBSOLETE

/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsServiceInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsServiceInfoGetW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if ((pLocalHandle == NULL) || (bufptr == NULL))
      return STATUS_INVALID_PARAMETER;

   if ( LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_SERVICE_INFO_GETW ) )
   {
      *bufptr = NULL;

      try {
         Status = LlsrServiceInfoGetW(pLocalHandle->Handle, Level, (PVOID) bufptr);
      }
      except (TRUE) {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }
   }
   else if ( 0 != Level )
   {
      Status = STATUS_INVALID_LEVEL;
   }
   else
   {
      // the target server will blow up if we make the RPC call
      // in 3.51, the IDL file for the returned structure was incorrect, causing
      // the ReplicateTo and EnterpriseServer buffers at the server to be freed

      // instead, get this info from the target machine's registry

      PLLS_SERVICE_INFO_0W    pServiceInfo;

      pServiceInfo = MIDL_user_allocate( sizeof( *pServiceInfo ) );

      if ( NULL == pServiceInfo )
      {
         Status = STATUS_NO_MEMORY;
      }
      else
      {
         DWORD cbServerName = sizeof( WCHAR ) * ( 3 + MAX_PATH );

         ZeroMemory( pServiceInfo, sizeof( *pServiceInfo ) );
         pServiceInfo->Version           = 5;                                   // we know it's a 3.51 box
         pServiceInfo->TimeStarted       = 0;                                   // don't know, but 3.51 fills in 0 anyway
         pServiceInfo->Mode              = LLS_MODE_ENTERPRISE_SERVER;          // we know it's a 3.51 box
         pServiceInfo->ReplicateTo       = MIDL_user_allocate( cbServerName );
         pServiceInfo->EnterpriseServer  = MIDL_user_allocate( cbServerName );

         if ( ( NULL == pServiceInfo->ReplicateTo ) || ( NULL == pServiceInfo->EnterpriseServer ) )
         {
            Status = STATUS_NO_MEMORY;
         }
         else
         {
            HKEY  hKeyLocalMachine;
            LONG  lError;

            // get parameters from registry
            lError = RegConnectRegistry( pLocalHandle->szServerName + 2, HKEY_LOCAL_MACHINE, &hKeyLocalMachine );

            if ( ERROR_SUCCESS == lError )
            {
               HKEY  hKeyParameters;

               lError = RegOpenKeyEx( hKeyLocalMachine, TEXT( "System\\CurrentControlSet\\Services\\LicenseService\\Parameters" ), 0, KEY_READ, &hKeyParameters );

               if ( ERROR_SUCCESS == lError )
               {
                  DWORD cbData;

                  // these parameters all default to 0
                  // (they were initialized to 0 via ZeroMemory(), above)

                  cbData = sizeof( pServiceInfo->ReplicationTime );
                  lError = RegQueryValueEx( hKeyParameters, TEXT( "ReplicationTime" ), NULL, NULL, (LPBYTE) &pServiceInfo->ReplicationTime, &cbData );

                  cbData = sizeof( pServiceInfo->ReplicationType );
                  lError = RegQueryValueEx( hKeyParameters, TEXT( "ReplicationType" ), NULL, NULL, (LPBYTE) &pServiceInfo->ReplicationType, &cbData );

                  cbData = sizeof( pServiceInfo->UseEnterprise   );
                  lError = RegQueryValueEx( hKeyParameters, TEXT( "UseEnterprise"   ), NULL, NULL, (LPBYTE) &pServiceInfo->UseEnterprise,   &cbData );

                  RegCloseKey( hKeyParameters );

                  lError = ERROR_SUCCESS;
               }

               RegCloseKey( hKeyLocalMachine );
            }

            switch ( lError )
            {
            case ERROR_SUCCESS:
               Status = STATUS_SUCCESS;
               break;
            case ERROR_ACCESS_DENIED:
               Status = STATUS_ACCESS_DENIED;
               break;
            default:
               Status = STATUS_UNSUCCESSFUL;
               break;
            }

            if ( STATUS_SUCCESS == Status )
            {
               // parameters retrieved from registry; only remaining parameters
               // to be filled in are EnterpriseServer and ReplicateTo
               TCHAR          szDomain[ 1 + MAX_PATH ];

               // retrieve the enterprise server
               EnterpriseServerGet( pLocalHandle->szServerName, pServiceInfo->EnterpriseServer );

               // derive ReplicateTo
               Status = NTDomainGet( pLocalHandle->szServerName, szDomain );

               if ( STATUS_ACCESS_DENIED != Status )
               {
                  if ( STATUS_SUCCESS == Status )
                  {
                     NET_API_STATUS netStatus;
                     LPWSTR         pszDCName;

                     netStatus = NetGetDCName( NULL, szDomain, (LPBYTE *) &pszDCName );

                     if ( NERR_Success == netStatus )
                     {
                        if ( !lstrcmpi( pszDCName, pLocalHandle->szServerName ) )
                        {
                           // server is primary domain controller;
                           // it replicates to its enterprise server (if any)
                           lstrcpy( pServiceInfo->ReplicateTo, pServiceInfo->EnterpriseServer );
                        }
                        else
                        {
                           // server is domain member; it replicates to the DC
                           lstrcpy( pServiceInfo->ReplicateTo, pszDCName );
                        }

                        NetApiBufferFree( pszDCName );
                     }
                     else
                     {
                        // server had domain but domain has no DC?
                        Status = STATUS_NO_SUCH_DOMAIN;
                     }
                  }
                  else
                  {
                     // server is not in a domain;
                     // it replicates to its enterprise server (if any)
                     lstrcpy( pServiceInfo->ReplicateTo, pServiceInfo->EnterpriseServer );
                     Status = STATUS_SUCCESS;
                  }
               }
            }
         }
      }

      if ( STATUS_SUCCESS != Status )
      {
         if ( NULL != pServiceInfo )
         {
            if ( NULL != pServiceInfo->ReplicateTo )
            {
               MIDL_user_free( pServiceInfo->ReplicateTo );
            }
            if ( NULL != pServiceInfo->EnterpriseServer )
            {
               MIDL_user_free( pServiceInfo->EnterpriseServer );
            }

            MIDL_user_free( pServiceInfo );
         }
      }
      else
      {
         if ( !lstrcmpi( pLocalHandle->szServerName, pServiceInfo->ReplicateTo ) )
         {
            *pServiceInfo->ReplicateTo = TEXT( '\0' );
         }
         if ( !lstrcmpi( pLocalHandle->szServerName, pServiceInfo->EnterpriseServer ) )
         {
            *pServiceInfo->EnterpriseServer = TEXT( '\0' );
         }

         *bufptr = (LPBYTE) pServiceInfo;
      }
   }

   return Status;
} // LlsServiceInfoGetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsServiceInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsServiceInfoGetA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if ((pLocalHandle == NULL) || (bufptr == NULL))
      return STATUS_INVALID_PARAMETER;

   *bufptr = NULL;

   try {
      Status = LlsrServiceInfoGetA(pLocalHandle->Handle, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsServiceInfoGetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsServiceInfoSetW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsServiceInfoSetW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrServiceInfoSetW(pLocalHandle->Handle, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if ( ( STATUS_NOT_SUPPORTED == Status ) && ( 0 == Level ) )
   {
      // RPC API is not supported; use the registry instead
      HKEY                    hKeyLocalMachine;
      HKEY                    hKeyParameters;
      LONG                    lError;
      PLLS_SERVICE_INFO_0W    pServiceInfo = (PLLS_SERVICE_INFO_0W) bufptr;
      LPWSTR                  pszEnterpriseServer;

      pszEnterpriseServer = pServiceInfo->EnterpriseServer;

      // strip leading backslashes from EnterpriseServer
      if ( !wcsncmp( pszEnterpriseServer, L"\\\\", 2 ) )
      {
         pszEnterpriseServer += 2;
      }

      lError = RegConnectRegistry( pLocalHandle->szServerName + 2, HKEY_LOCAL_MACHINE, &hKeyLocalMachine );

      if ( ERROR_SUCCESS == lError )
      {
         lError = RegOpenKeyEx( hKeyLocalMachine, TEXT( "System\\CurrentControlSet\\Services\\LicenseService\\Parameters" ), 0, KEY_WRITE, &hKeyParameters );

         if ( ERROR_SUCCESS == lError )
         {
            lError = RegSetValueExW( hKeyParameters, L"EnterpriseServer", 0, REG_SZ, (LPBYTE) pszEnterpriseServer, sizeof( *pszEnterpriseServer ) * ( 1 + lstrlenW( pszEnterpriseServer ) ) );

            if ( ERROR_SUCCESS == lError )
            {
               lError = RegSetValueEx( hKeyParameters, TEXT( "ReplicationTime" ), 0, REG_DWORD, (LPBYTE) &pServiceInfo->ReplicationTime, sizeof( pServiceInfo->ReplicationTime ) );

               if ( ERROR_SUCCESS == lError )
               {
                  lError = RegSetValueEx( hKeyParameters, TEXT( "ReplicationType" ), 0, REG_DWORD, (LPBYTE) &pServiceInfo->ReplicationType, sizeof( pServiceInfo->ReplicationType ) );

                  if ( ERROR_SUCCESS == lError )
                  {
                     lError = RegSetValueEx( hKeyParameters, TEXT( "UseEnterprise" ), 0, REG_DWORD, (LPBYTE) &pServiceInfo->UseEnterprise, sizeof( pServiceInfo->UseEnterprise ) );

                     if ( ERROR_SUCCESS == lError )
                     {
                        Status = STATUS_SUCCESS;
                     }
                  }
               }
            }

            RegCloseKey( hKeyParameters );
         }

         RegCloseKey( hKeyLocalMachine );
      }
   }

   return Status;
} // LlsServiceInfoSetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsServiceInfoSetA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsServiceInfoSetA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrServiceInfoSetA(pLocalHandle->Handle, Level, (PVOID) bufptr);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsServiceInfoSetA



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsReplConnectW(
   LPTSTR Server,
   LLS_REPL_HANDLE* Handle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   RPC_STATUS Status;
   LPTSTR pszUuid = NULL;
   LPTSTR pszProtocolSequence = NULL;
   LPTSTR pszNetworkAddress = NULL;
   LPTSTR pszEndpoint = NULL;
   LPTSTR pszOptions = NULL;
   TCHAR pComputer[MAX_COMPUTERNAME_LENGTH + 1];
   ULONG Size;

#ifdef API_TRACE
   if (Server == NULL)
      dprintf(TEXT("LLSRPC.DLL: LlsReplConnectW: <NULL>\n"));
   else
      dprintf(TEXT("LLSRPC.DLL: LlsReplConnectW: %s\n"), Server);
#endif

   //
   //                   ** NEW - NT 5.0 **
   //
   // The server name may either be a DNS name or a NetBIOS name.
   //

   if (Server == NULL || (Server != NULL && !*Server))
      return STATUS_INVALID_PARAMETER;

   Size = sizeof(pComputer) / sizeof(TCHAR);
   GetComputerName(pComputer, &Size);

   pszProtocolSequence = TEXT("ncacn_np");
   pszEndpoint = TEXT(LLS_NP_ENDPOINT);
   pszNetworkAddress = Server;

   // Compose a string binding
   Status = RpcStringBindingComposeW(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);
   if(Status) {
#if DBG
      dprintf(TEXT("LLSRPC RpcStringBindingComposeW Failed: 0x%lX\n"), Status);
#endif
      
      return I_RpcMapWin32Status(Status);
   }

   RtlEnterCriticalSection( &g_RpcHandleLock );

   // Bind using the created string binding...
   Status = RpcBindingFromStringBindingW(pszStringBinding, &llsrpc_handle);
   if(Status) {
#if DBG
      dprintf(TEXT("LLSRPC RpcBindingFromStringBindingW Failed: 0x%lX\n"), Status);
#endif
      if(pszStringBinding != NULL)
      {
          RpcStringFree(&pszStringBinding);
      }
      if(llsrpc_handle != NULL)
      {
          RpcBindingFree(llsrpc_handle);          
          llsrpc_handle = NULL;
      }
      RtlLeaveCriticalSection( &g_RpcHandleLock );
      return I_RpcMapWin32Status(Status);
   }

   try {
      LlsrReplConnect(Handle, pComputer);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }
    if(!NT_SUCCESS(Status))
    {
       if(pszStringBinding != NULL)
      {
          RpcStringFree(&pszStringBinding);
      }
      if(llsrpc_handle != NULL)
      {
          RpcBindingFree(llsrpc_handle);          
          llsrpc_handle = NULL;
      }
    }

   RtlLeaveCriticalSection( &g_RpcHandleLock );

   return I_RpcMapWin32Status(Status);

} // LlsReplConnectW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsReplClose(
   PLLS_REPL_HANDLE Handle
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   RPC_STATUS Status;
   NTSTATUS NtStatus = STATUS_SUCCESS;

   try {
      NtStatus = LlsrReplClose(Handle);
   }
   except (TRUE) {
      NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), NtStatus);
#endif
   }

   try {
      Status = RpcStringFree(&pszStringBinding);
      if (Status ) {
         NtStatus = I_RpcMapWin32Status(Status);
#if DBG
         dprintf(TEXT("LLSRPC.DLL: LlsClose - RpcStringFree returned: 0x%lX\n"), NtStatus);
#endif
      }

      Status = RpcBindingFree(&llsrpc_handle);
      if (Status ) {
         NtStatus = I_RpcMapWin32Status(Status);
#if DBG
         dprintf(TEXT("LLSRPC.DLL: LlsClose - RpcBindingFree returned: 0x%lX\n"), NtStatus);
#endif
      }
   }
   except (TRUE) {
      NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), NtStatus);
#endif
   }

   return NtStatus;

} // LlsClose


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsReplicationRequestW(
   IN LLS_REPL_HANDLE Handle,
   IN DWORD Version,
   IN OUT PREPL_REQUEST Request
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;

   try {
      Status = LlsrReplicationRequestW(Handle, Version, Request);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsReplicationRequestW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsReplicationServerAddW(
   IN LLS_REPL_HANDLE Handle,
   IN ULONG NumRecords,
   IN PREPL_SERVER_RECORD Servers
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;

   try {
      Status = LlsrReplicationServerAddW(Handle, NumRecords, Servers);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsReplicationServerAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsReplicationServerServiceAddW(
   IN LLS_REPL_HANDLE Handle,
   IN ULONG NumRecords,
   IN PREPL_SERVER_SERVICE_RECORD ServerServices
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;

   try {
      Status = LlsrReplicationServerServiceAddW(Handle, NumRecords, ServerServices);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsReplicationServerServiceAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsReplicationServiceAddW(
   IN LLS_REPL_HANDLE Handle,
   IN ULONG NumRecords,
   IN PREPL_SERVICE_RECORD Services
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;

   try {
      Status = LlsrReplicationServiceAddW(Handle, NumRecords, Services);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsReplicationServiceAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsReplicationUserAddW(
   IN LLS_REPL_HANDLE Handle,
   IN ULONG NumRecords,
   IN PREPL_USER_RECORD_0 Users
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
   NTSTATUS Status;

   try {
      Status = LlsrReplicationUserAddW(Handle, NumRecords, Users);
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsReplicationUserAddW

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LlsProductSecurityGetW(
   LLS_HANDLE  Handle,
   LPWSTR      Product,
   LPBOOL      pIsSecure
   )

/*++

Routine Description:

   Retrieve the "security" of a product.  A product is deemed secure iff
   it requires a secure certificate.  In such a case, licenses for the
   product may not be entered via the Honesty ("enter the number of
   licenses you purchased") method.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   Product (LPWSTR)
      The name of the product ("DisplayName") for which to receive the
      security.
   pIsSecure (LPBOOL)
      On return, and if successful, indicates whether the product is
      secure.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductSecurityGetW\n"));
#endif

   if ( !LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
   {
      return STATUS_NOT_SUPPORTED;
   }

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrProductSecurityGetW( pLocalHandle->Handle, Product, pIsSecure );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsProductSecurityGetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductSecurityGetA(
   LLS_HANDLE  Handle,
   LPSTR       Product,
   LPBOOL      pIsSecure
   )

/*++

Routine Description:

   Retrieve the "security" of a product.  A product is deemed secure iff
   it requires a secure certificate.  In such a case, licenses for the
   product may not be entered via the Honesty ("enter the number of
   licenses you purchased") method.

   NOTE: Not yet implemented.  Use LlsProductSecurityGetW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   Product (LPSTR)
      The name of the product ("DisplayName") for which to receive the
      security.
   pIsSecure (LPBOOL)
      On return, and if successful, indicates whether the product is
      secure.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductSecurityGetA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsProductSecurityGetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductSecuritySetW(
   LLS_HANDLE  Handle,
   LPWSTR      Product
   )

/*++

Routine Description:

   Flags the given product as secure.  A product is deemed secure iff
   it requires a secure certificate.  In such a case, licenses for the
   product may not be entered via the Honesty ("enter the number of
   licenses you purchased") method.

   This designation is not reversible and is propagated up the
   replication tree.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   Product (LPWSTR)
      The name of the product ("DisplayName") for which to activate
      security.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductSecuritySetW\n"));
#endif

   if ( !LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
   {
      return STATUS_NOT_SUPPORTED;
   }

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrProductSecuritySetW( pLocalHandle->Handle, Product );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsProductSecuritySetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductSecuritySetA(
   LLS_HANDLE  Handle,
   LPSTR       Product
   )

/*++

Routine Description:

   Flags the given product as secure.  A product is deemed secure iff
   it requires a secure certificate.  In such a case, licenses for the
   product may not be entered via the Honesty ("enter the number of
   licenses you purchased") method.

   This designation is not reversible and is propagated up the
   replication tree.

   NOTE: Not yet implemented.  Use LlsProductSecuritySetW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   Product (LPSTR)
      The name of the product ("DisplayName") for which to activate
      security.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductSecuritySetA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsProductSecuritySetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductLicensesGetW(
   LLS_HANDLE  Handle,
   LPWSTR      Product,
   DWORD       Mode,
   LPDWORD     pQuantity )

/*++

Routine Description:

   Returns the number of licenses installed on the target machine for
   use in the given mode.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   Product (LPWSTR)
      The name of the product for which to tally licenses.
   Mode (DWORD)
      Licensing mode for which to tally the licenses.
   pQuantity (LPDWORD)
      On return (and if successful), holds the total number of licenses
      for use by the given product in the given license mode.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductLicensesGetW\n"));
#endif

   if ( !LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
   {
      return STATUS_NOT_SUPPORTED;
   }

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrProductLicensesGetW( pLocalHandle->Handle, Product, Mode, pQuantity );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsProductLicensesGetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsProductLicensesGetA(
   LLS_HANDLE  Handle,
   LPSTR       Product,
   DWORD       Mode,
   LPDWORD     pQuantity )

/*++

Routine Description:

   Returns the number of licenses installed on the target machine for
   use in the given mode.

   NOTE: Not yet implemented.  Use LlsProductLicensesGetW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   Product (LPSTR)
      The name of the product for which to tally licenses.
   Mode (DWORD)
      Licensing mode for which to tally the licenses.
   pQuantity (LPDWORD)
      On return (and if successful), holds the total number of licenses
      for use by the given product in the given license mode.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsProductLicensesGetA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsProductLicensesGetA


#ifdef OBSOLETE

/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsCertificateClaimEnumW(
   LLS_HANDLE  Handle,
   DWORD       LicenseLevel,
   LPBYTE      pLicenseInfo,
   DWORD       TargetLevel,
   LPBYTE *    ppTargets,
   LPDWORD     pNumTargets )

/*++

Routine Description:

   Enumerates the servers on which a given secure certificate is installed.
   This function is normally invoked when an attempt to add licenses from
   a certificate is denied.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   pLicenseInfo (LPBYTE)
      Points to a LLS_LICENSE_INFO_X structure, where X is LicenseLevel.
      This license structure describes a license for which the certificate
      targets are requested.
   TargetLevel (DWORD)
      The level of the target structure desired.
   ppTargets (LPBYTE *)
      On return (and if successful), holds a PLLS_EX_CERTIFICATE_CLAIM_X,
      where X is TargetLevel.  This array of structures describes the
      location of all installations of licenses from the given certificate.
   pNumTargets (LPDWORD)
      On return (and if successful), holds the number of structures pointed
      to by ppTargets.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS Status;
   GENERIC_INFO_CONTAINER GenericInfoContainer;
   GENERIC_ENUM_STRUCT InfoStruct;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsCertificateClaimEnumW\n"));
#endif

   if ( !LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
   {
      return STATUS_NOT_SUPPORTED;
   }

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   GenericInfoContainer.Buffer = NULL;
   GenericInfoContainer.EntriesRead = 0;

   InfoStruct.Container = &GenericInfoContainer;
   InfoStruct.Level = TargetLevel;

   try
   {
      Status = LlsrCertificateClaimEnumW(
            pLocalHandle->Handle,
            LicenseLevel,
            (LPVOID) pLicenseInfo,
            (PLLS_CERTIFICATE_CLAIM_ENUM_STRUCTW) &InfoStruct );
   }
   except (TRUE)
   {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   if (Status == STATUS_SUCCESS)
   {
      *ppTargets = (LPBYTE) GenericInfoContainer.Buffer;
      *pNumTargets = GenericInfoContainer.EntriesRead;
   }

   return Status;
} // LlsCertificateClaimEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsCertificateClaimEnumA(
   LLS_HANDLE  Handle,
   DWORD       LicenseLevel,
   LPBYTE      pLicenseInfo,
   DWORD       TargetLevel,
   LPBYTE *    ppTargets,
   LPDWORD     pNumTargets )

/*++

Routine Description:

   Enumerates the servers on which a given secure certificate is installed.
   This function is normally invoked when an attempt to add licenses from
   a certificate is denied.

   NOTE: Not yet implemented.  Use LlsCertificateClaimEnumW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   pLicenseInfo (LPBYTE)
      Points to a LLS_LICENSE_INFO_X structure, where X is LicenseLevel.
      This license structure describes a license for which the certificate
      targets are requested.
   TargetLevel (DWORD)
      The level of the target structure desired.
   ppTargets (LPBYTE *)
      On return (and if successful), holds a PLLS_EX_CERTIFICATE_CLAIM_X,
      where X is TargetLevel.  This array of structures describes the
      location of all installations of licenses from the given certificate.
   pNumTargets (LPDWORD)
      On return (and if successful), holds the number of structures pointed
      to by ppTargets.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsCertificateClaimEnumA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsCertificateClaimEnumA

#endif // OBSOLETE

/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsCertificateClaimAddCheckW(
   LLS_HANDLE  Handle,
   DWORD       LicenseLevel,
   LPBYTE      pLicenseInfo,
   LPBOOL      pbMayInstall )

/*++

Routine Description:

   Verify that no more licenses from a given certificate are installed in
   a licensing enterprise than are allowed by the certificate.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   pLicenseInfo (LPBYTE)
      Points to a LLS_LICENSE_INFO_X structure, where X is LicenseLevel.
      This license structure describes the license wished to add.
   pbMayInstall (LPBOOL)
      On return (and if successful), indicates whether the certificate
      may be legally installed.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsCertificateClaimAddCheckW\n"));
#endif

   if ( !LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
   {
      return STATUS_NOT_SUPPORTED;
   }

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrCertificateClaimAddCheckW( pLocalHandle->Handle, LicenseLevel, (LPVOID) pLicenseInfo, pbMayInstall );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsCertificateClaimAddCheckW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsCertificateClaimAddCheckA(
   IN  LLS_HANDLE             Handle,
   IN  DWORD                  LicenseLevel,
   IN  LPBYTE                 pLicenseInfo,
   OUT LPBOOL                 pbMayInstall )

/*++

Routine Description:

   Verify that no more licenses from a given certificate are installed in
   a licensing enterprise than are allowed by the certificate.

   NOTE: Not yet implemented.  Use LlsCertificateClaimAddCheckW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   pLicenseInfo (LPBYTE)
      Points to a LLS_LICENSE_INFO_X structure, where X is LicenseLevel.
      This license structure describes the license wished to add.
   pbMayInstall (LPBOOL)
      On return (and if successful), indicates whether the certificate
      may be legally installed.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsCertificateClaimAddCheckA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsCertificateClaimAddCheckA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsCertificateClaimAddW(
   LLS_HANDLE  Handle,
   LPWSTR      ServerName,
   DWORD       LicenseLevel,
   LPBYTE      pLicenseInfo )

/*++

Routine Description:

   Declare a number of licenses from a given certificate as being installed
   on the target machine.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   ServerName (LPWSTR)
      Name of the server on which the licenses are installed.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   pLicenseInfo (LPBYTE)
      Points to a LLS_LICENSE_INFO_X structure, where X is LicenseLevel.
      This license structure describes the license added.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsCertificateClaimAddW\n"));
#endif

   if ( !LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
   {
      return STATUS_NOT_SUPPORTED;
   }

   pLocalHandle = (PLOCAL_HANDLE) Handle;
   if (pLocalHandle == NULL)
      return STATUS_INVALID_PARAMETER;

   try {
      Status = LlsrCertificateClaimAddW( pLocalHandle->Handle, ServerName, LicenseLevel, (LPVOID) pLicenseInfo );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsCertificateClaimAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsCertificateClaimAddA(
   LLS_HANDLE  Handle,
   LPSTR       ServerName,
   DWORD       LicenseLevel,
   LPBYTE      pLicenseInfo )

/*++

Routine Description:

   Declare a number of licenses from a given certificate as being installed
   on the target machine.

   NOTE: Not yet implemented.  Use LlsCertificateClaimAddW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   ServerName (LPWSTR)
      Name of the server on which the licenses are installed.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   pLicenseInfo (LPBYTE)
      Points to a LLS_LICENSE_INFO_X structure, where X is LicenseLevel.
      This license structure describes the license added.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsCertificateClaimAddA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsCertificateClaimAddA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsReplicationCertDbAddW(
   LLS_REPL_HANDLE            Handle,
   DWORD                      Level,
   LPVOID                     Certificates )

/*++

Routine Description:

   Called as an optional part of replication, this function replicates
   the contents of the remote certificate database.

Arguments:

   Handle (LLS_REPL_HANDLE)
      An open replication handle to the target server.
   Level (DWORD)
      Level of replication information sent.
   Certificates (LPVOID)
      Replicated certificate information.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS Status;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsReplicationCertDbAddW\n"));
#endif

   try {
      Status = LlsrReplicationCertDbAddW( Handle, Level, Certificates );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsReplicationCertDbAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsReplicationProductSecurityAddW(
   LLS_REPL_HANDLE            Handle,
   DWORD                      Level,
   LPVOID                     SecureProducts )

/*++

Routine Description:

   Called as an optional part of replication, this function replicates
   the list of products which require secure certificates.

Arguments:

   Handle (LLS_REPL_HANDLE)
      An open replication handle to the target server.
   Level (DWORD)
      Level of the product security information.
   SecureProducts (LPVOID)
      Replicated secure product information.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS Status;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsReplicationProductSecurityAddW\n"));
#endif

   try {
      Status = LlsrReplicationProductSecurityAddW( Handle, Level, SecureProducts );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsReplicationProductSecurityAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
NTAPI
LlsReplicationUserAddExW(
   LLS_REPL_HANDLE            Handle,
   DWORD                      Level,
   LPVOID                     Users )

/*++

Routine Description:

   Replacement for LlsReplicationUserAddW().  (This function, unlike its
   counterpart, supports structure levels.)  This function replicates
   the user list.

Arguments:

   Handle (LLS_REPL_HANDLE)
      An open replication handle to the target server.
   Level (DWORD)
      Level of the user information.
   Users (LPVOID)
      Replicated user information.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS Status;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsReplicationUserAddExW\n"));
#endif

   if ( (0 != Level) && (1 != Level) )
      return STATUS_INVALID_LEVEL;

   try {
      Status = LlsrReplicationUserAddExW( Handle, Level, Users );
   }
   except (TRUE) {
      Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
      dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
   }

   return Status;
} // LlsReplicationUserAddExW


/////////////////////////////////////////////////////////////////////////
BOOL
NTAPI
LlsCapabilityIsSupported(
   LLS_HANDLE  Handle,
   DWORD       Capability )

/*++

Routine Description:

   Determine whether the target license server supports an arbitrary
   function.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   Capability (DWORD)
      The capability number to check for, 0 <= Capability < LLS_CAPABILITY_MAX.

Return Value:

   TRUE (supports the capability) or FALSE (does not).

--*/

{
   BOOL           bIsSupported = FALSE;
   PLOCAL_HANDLE  pLocalHandle;
   DWORD          dwCapByte;
   DWORD          dwCapBit;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsCapabilityIsSupported\n"));
#endif

   if ( ( NULL != Handle ) && ( Capability < LLS_CAPABILITY_MAX ) )
   {
      pLocalHandle = (PLOCAL_HANDLE) Handle;

      dwCapByte = Capability / 8;
      dwCapBit  = Capability - 8 * dwCapByte;

      if ( 1 & ( pLocalHandle->Capabilities[ dwCapByte ] >> dwCapBit ) )
      {
         bIsSupported = TRUE;
      }
   }

   return bIsSupported;
} // LlsCapabilityIsSupported


NTSTATUS
NTAPI
LlsLocalServiceEnumW(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle )
{
   NTSTATUS       Status;
   PLOCAL_HANDLE  pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalServiceEnumW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;

   if (pLocalHandle == NULL)
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else if ( LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_LOCAL_SERVICE_API ) )
   {
      GENERIC_INFO_CONTAINER  GenericInfoContainer;
      GENERIC_ENUM_STRUCT     InfoStruct;

      GenericInfoContainer.Buffer = NULL;
      GenericInfoContainer.EntriesRead = 0;

      InfoStruct.Container = &GenericInfoContainer;
      InfoStruct.Level = Level;

      try
      {
         Status = LlsrLocalServiceEnumW(
                      pLocalHandle->Handle,
                      (PLLS_LOCAL_SERVICE_ENUM_STRUCTW) &InfoStruct,
                      PrefMaxLen,
                      TotalEntries,
                      ResumeHandle
                      );
      }
      except (TRUE)
      {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }

      if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES))
      {
         *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
         *EntriesRead = GenericInfoContainer.EntriesRead;
      }
   }
   else if ( 0 != Level )
   {
      Status = STATUS_INVALID_LEVEL;
   }
   else
   {
      PLLS_LOCAL_SERVICE_INFO_0  pLocalServices = NULL;
      DWORD                      cEntriesRead = 0;
      LONG                       lError;
      HKEY                       hKeyLocalMachine;

      lError = RegConnectRegistry( pLocalHandle->szServerName, HKEY_LOCAL_MACHINE, &hKeyLocalMachine );

      if ( ERROR_SUCCESS == lError )
      {
         HKEY     hKeyLicenseInfo;

         lError = RegOpenKeyEx( hKeyLocalMachine, REG_KEY_LICENSE, 0, KEY_READ, &hKeyLicenseInfo );

         if ( ERROR_SUCCESS == lError )
         {
            const DWORD cbBufferSize = 0x4000;

            // fudge; we ignore MaxPrefLen and allocate a 16k buffer
            // this is because when we restart an enumeration, we don't know how
            // many items we have left (we could do it, but it'd be slow)
            // this is only for 3.51 boxes, anyway, and this buffer will hold
            // about 500 local service entries (plenty!)
            // this also keeps us from having to keep the registry key open
            // across function calls

            pLocalServices = MIDL_user_allocate( cbBufferSize );

            if ( NULL == pLocalServices )
            {
               lError = ERROR_OUTOFMEMORY;
            }
            else
            {
               DWORD    iSubKey;
               TCHAR    szKeyName[ 128 ];

               // read all the services installed on this machine
               for ( iSubKey=0, cEntriesRead=0;
                     ( ERROR_SUCCESS == lError ) && ( ( cEntriesRead + 1 ) * sizeof( *pLocalServices ) < cbBufferSize );
                     iSubKey++ )
               {
                  lError = RegEnumKey( hKeyLicenseInfo, iSubKey, szKeyName, sizeof( szKeyName ) / sizeof( *szKeyName ) );

                  if ( ERROR_SUCCESS == lError )
                  {
                     HKEY  hKeyService;

                     lError = RegOpenKeyEx( hKeyLicenseInfo, szKeyName, 0, KEY_READ, &hKeyService );

                     if ( ERROR_SUCCESS == lError )
                     {
                        DWORD    cbData;

                        cbData = sizeof( pLocalServices[ cEntriesRead ].Mode );
                        lError = RegQueryValueEx( hKeyService, REG_VALUE_MODE, NULL, NULL, (LPBYTE) &pLocalServices[ cEntriesRead ].Mode, &cbData );

                        if ( ERROR_SUCCESS == lError )
                        {
                           cbData = sizeof( pLocalServices[ cEntriesRead ].FlipAllow );
                           lError = RegQueryValueEx( hKeyService, REG_VALUE_FLIP, NULL, NULL, (LPBYTE) &pLocalServices[ cEntriesRead ].FlipAllow, &cbData );

                           if ( ERROR_SUCCESS == lError )
                           {
                              cbData = sizeof( pLocalServices[ cEntriesRead ].ConcurrentLimit );
                              lError = RegQueryValueEx( hKeyService, REG_VALUE_LIMIT, NULL, NULL, (LPBYTE) &pLocalServices[ cEntriesRead ].ConcurrentLimit, &cbData );

                              if ( ERROR_SUCCESS == lError )
                              {
                                 DWORD    cbKeyName;
                                 DWORD    cbDisplayName;
                                 DWORD    cbFamilyDisplayName;

                                 cbData = sizeof( pLocalServices[ cEntriesRead ].HighMark );
                                 lError = RegQueryValueEx( hKeyService, REG_VALUE_HIGHMARK, NULL, NULL, (LPBYTE) &pLocalServices[ cEntriesRead ].HighMark, &cbData );

                                 if ( ERROR_SUCCESS != lError )
                                 {
                                    pLocalServices[ cEntriesRead ].HighMark = 0;
                                    lError = ERROR_SUCCESS;
                                 }

                                 if (    ( ERROR_SUCCESS == RegQueryValueEx( hKeyService, REG_VALUE_NAME,   NULL, NULL, NULL, &cbDisplayName       ) )
                                      && ( ERROR_SUCCESS == RegQueryValueEx( hKeyService, REG_VALUE_FAMILY, NULL, NULL, NULL, &cbFamilyDisplayName ) ) )
                                 {
                                    cbKeyName = sizeof( *szKeyName ) * ( 1 + lstrlen( szKeyName  ) );

                                    pLocalServices[ cEntriesRead ].KeyName = MIDL_user_allocate( cbKeyName );

                                    if ( NULL == pLocalServices[ cEntriesRead ].KeyName )
                                    {
                                       lError = ERROR_OUTOFMEMORY;
                                    }
                                    else
                                    {
                                       lstrcpy( pLocalServices[ cEntriesRead ].KeyName, szKeyName );

                                       pLocalServices[ cEntriesRead ].DisplayName = MIDL_user_allocate( cbDisplayName );

                                       if ( NULL == pLocalServices[ cEntriesRead ].DisplayName )
                                       {
                                          lError = ERROR_OUTOFMEMORY;
                                       }
                                       else
                                       {
                                          lError = RegQueryValueEx( hKeyService, REG_VALUE_NAME, NULL, NULL, (LPBYTE) pLocalServices[ cEntriesRead ].DisplayName, &cbDisplayName );

                                          if ( ERROR_SUCCESS == lError )
                                          {
                                             pLocalServices[ cEntriesRead ].FamilyDisplayName = MIDL_user_allocate( cbFamilyDisplayName );

                                             if ( NULL == pLocalServices[ cEntriesRead ].FamilyDisplayName )
                                             {
                                                lError = ERROR_OUTOFMEMORY;
                                             }
                                             else
                                             {
                                                lError = RegQueryValueEx( hKeyService, REG_VALUE_FAMILY, NULL, NULL, (LPBYTE) pLocalServices[ cEntriesRead ].FamilyDisplayName, &cbFamilyDisplayName );

                                                if ( ERROR_SUCCESS != lError )
                                                {
                                                   MIDL_user_free( pLocalServices[ cEntriesRead ].FamilyDisplayName );
                                                }
                                             }
                                          }

                                          if ( ERROR_SUCCESS != lError )
                                          {
                                             MIDL_user_free( pLocalServices[ cEntriesRead ].DisplayName );
                                          }
                                       }

                                       if ( ERROR_SUCCESS != lError )
                                       {
                                          MIDL_user_free( pLocalServices[ cEntriesRead ].KeyName );
                                       }
                                       else
                                       {
                                          // all data for this service was retrieved!
                                          cEntriesRead++;
                                       }
                                    }
                                 }
                              }
                           }
                        }

                        RegCloseKey( hKeyService );
                     }

                     if ( ERROR_OUTOFMEMORY != lError )
                     {
                        // continue enumeration...
                        lError = ERROR_SUCCESS;
                     }
                  }
               }
            }

            RegCloseKey( hKeyLicenseInfo );
         }

         RegCloseKey( hKeyLocalMachine );
      }

      switch ( lError )
      {
      case ERROR_SUCCESS:
      case ERROR_NO_MORE_ITEMS:
         Status = STATUS_SUCCESS;
         break;
      case ERROR_ACCESS_DENIED:
         Status = STATUS_ACCESS_DENIED;
         break;
      case ERROR_OUTOFMEMORY:
         Status = STATUS_NO_MEMORY;
         break;
      case ERROR_FILE_NOT_FOUND:
      case ERROR_PATH_NOT_FOUND:
         Status = STATUS_NOT_FOUND;
         break;
      default:
         Status = STATUS_UNSUCCESSFUL;
         break;
      }

      if ( STATUS_SUCCESS != Status )
      {
         // free all of our allocations
         DWORD i;

         for ( i=0; i < cEntriesRead; i++ )
         {
            MIDL_user_free( pLocalServices[ i ].KeyName );
            MIDL_user_free( pLocalServices[ i ].DisplayName );
            MIDL_user_free( pLocalServices[ i ].FamilyDisplayName );
         }

         MIDL_user_free( pLocalServices );
      }
      else
      {
         // success!  return the array of services.
         *bufptr       = (LPBYTE) pLocalServices;
         *EntriesRead  = cEntriesRead;
         *TotalEntries = cEntriesRead;
         *ResumeHandle = 0;
      }
   }

   return Status;
}


NTSTATUS
NTAPI
LlsLocalServiceEnumA(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle )
{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalServiceEnumA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;

   if (pLocalHandle == NULL)
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else if ( LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_LOCAL_SERVICE_API ) )
   {
      GENERIC_INFO_CONTAINER GenericInfoContainer;
      GENERIC_ENUM_STRUCT InfoStruct;

      GenericInfoContainer.Buffer = NULL;
      GenericInfoContainer.EntriesRead = 0;

      InfoStruct.Container = &GenericInfoContainer;
      InfoStruct.Level = Level;

      try {
         Status = LlsrLocalServiceEnumA(
                   pLocalHandle->Handle,
                   (PLLS_LOCAL_SERVICE_ENUM_STRUCTA) &InfoStruct,
                   PrefMaxLen,
                   TotalEntries,
                   ResumeHandle
                   );
      }
      except (TRUE) {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }

      if ((Status == STATUS_SUCCESS) || (Status == STATUS_MORE_ENTRIES)) {
         *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
         *EntriesRead = GenericInfoContainer.EntriesRead;
      }
   }
   else
   {
      Status = STATUS_NOT_SUPPORTED;
   }

   return Status;
}


#ifdef OBSOLETE

NTSTATUS
NTAPI
LlsLocalServiceAddW(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPBYTE      bufptr )
{
   NTSTATUS       Status;
   PLOCAL_HANDLE  pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalServiceAddW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;

   if (pLocalHandle == NULL)
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else if ( LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_LOCAL_SERVICE_API ) )
   {
      try
      {
         Status = LlsrLocalServiceAddW( pLocalHandle->Handle, Level, (PLLS_LOCAL_SERVICE_INFOW) bufptr );
      }
      except (TRUE)
      {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }
   }
   else if ( 0 != Level )
   {
      Status = STATUS_INVALID_LEVEL;
   }
   else if (    ( NULL == ((PLLS_LOCAL_SERVICE_INFO_0W) bufptr)->KeyName           )
             || ( NULL == ((PLLS_LOCAL_SERVICE_INFO_0W) bufptr)->DisplayName       )
             || ( NULL == ((PLLS_LOCAL_SERVICE_INFO_0W) bufptr)->FamilyDisplayName ) )
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else
   {
      PLLS_LOCAL_SERVICE_INFO_0W LocalServiceInfo;
      LONG                       lError;
      HKEY                       hKeyLocalMachine;

      LocalServiceInfo = (PLLS_LOCAL_SERVICE_INFO_0W) bufptr;

      lError = RegConnectRegistry( pLocalHandle->szServerName, HKEY_LOCAL_MACHINE, &hKeyLocalMachine );

      if ( ERROR_SUCCESS == lError )
      {
         HKEY  hKeyLicenseInfo;

         lError = RegOpenKeyEx( hKeyLocalMachine, TEXT( "System\\CurrentControlSet\\Services\\LicenseInfo" ), 0, KEY_WRITE, &hKeyLicenseInfo );

         if ( ERROR_SUCCESS == lError )
         {
            HKEY  hKeyService;
            DWORD dwDisposition;

            // create key
            lError = RegCreateKeyEx( hKeyLicenseInfo, LocalServiceInfo->KeyName, 0, NULL, 0, KEY_WRITE, NULL, &hKeyService, &dwDisposition );

            if ( ERROR_SUCCESS == lError )
            {
               // set DisplayName
               lError = RegSetValueEx( hKeyService, TEXT( "DisplayName" ), 0, REG_SZ, (LPBYTE) LocalServiceInfo->DisplayName, sizeof( *LocalServiceInfo->DisplayName ) * ( 1 + lstrlen( LocalServiceInfo->DisplayName ) ) );

               if ( ERROR_SUCCESS == lError )
               {
                  // set FamilyDisplayName
                  lError = RegSetValueEx( hKeyService, TEXT( "FamilyDisplayName" ), 0, REG_SZ, (LPBYTE) LocalServiceInfo->FamilyDisplayName, sizeof( *LocalServiceInfo->FamilyDisplayName ) * ( 1 + lstrlen( LocalServiceInfo->FamilyDisplayName ) ) );
               }

               RegCloseKey( hKeyService );
            }

            RegCloseKey( hKeyLicenseInfo );
         }

         RegCloseKey( hKeyLocalMachine );
      }

      switch ( lError )
      {
      case ERROR_SUCCESS:
         Status = STATUS_SUCCESS;
         break;
      case ERROR_FILE_NOT_FOUND:
      case ERROR_PATH_NOT_FOUND:
         Status = STATUS_OBJECT_NAME_NOT_FOUND;
         break;
      case ERROR_ACCESS_DENIED:
         Status = STATUS_ACCESS_DENIED;
         break;
      default:
         Status = STATUS_UNSUCCESSFUL;
         break;
      }

      if ( STATUS_SUCCESS == Status )
      {
         // set remaining items
         Status = LlsLocalServiceInfoSetW( Handle, LocalServiceInfo->KeyName, Level, bufptr );
      }
   }

   return Status;
}


NTSTATUS
NTAPI
LlsLocalServiceAddA(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPBYTE      bufptr )
{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalServiceAddA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;

   if (pLocalHandle == NULL)
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else if ( LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_LOCAL_SERVICE_API ) )
   {
      try {
         Status = LlsrLocalServiceAddA( pLocalHandle->Handle, Level, (PLLS_LOCAL_SERVICE_INFOA) bufptr );
      }
      except (TRUE) {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }
   }
   else
   {
      Status = STATUS_NOT_SUPPORTED;
   }

   return Status;
}

#endif // OBSOLETE

NTSTATUS
NTAPI
LlsLocalServiceInfoSetW(
   LLS_HANDLE Handle,
   LPWSTR     KeyName,
   DWORD      Level,
   LPBYTE     bufptr )
{
   NTSTATUS       Status;
   PLOCAL_HANDLE  pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalServiceInfoSetW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;

   if (pLocalHandle == NULL)
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else if ( LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_LOCAL_SERVICE_API ) )
   {
      try
      {
         Status = LlsrLocalServiceInfoSetW( pLocalHandle->Handle, KeyName, Level, (PLLS_LOCAL_SERVICE_INFOW) bufptr );
      }
      except (TRUE)
      {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }
   }
   else if ( 0 != Level )
   {
      Status = STATUS_INVALID_LEVEL;
   }
   else if ( NULL == KeyName )
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else
   {
      LONG  lError;
      HKEY  hKeyLocalMachine;

      lError = RegConnectRegistry( pLocalHandle->szServerName, HKEY_LOCAL_MACHINE, &hKeyLocalMachine );

      if ( ERROR_SUCCESS == lError )
      {
         HKEY  hKeyLicenseInfo;

         lError = RegOpenKeyEx( hKeyLocalMachine, REG_KEY_LICENSE, 0, KEY_WRITE, &hKeyLicenseInfo );

         if ( ERROR_SUCCESS == lError )
         {
            HKEY                       hKeyService;
            PLLS_LOCAL_SERVICE_INFO_0W LocalServiceInfo;

            LocalServiceInfo = (PLLS_LOCAL_SERVICE_INFO_0W) bufptr;

            lError = RegOpenKeyEx( hKeyLicenseInfo, KeyName, 0, KEY_WRITE, &hKeyService );

            if ( ERROR_SUCCESS == lError )
            {
               // set Mode
               lError = RegSetValueEx( hKeyService, REG_VALUE_MODE, 0, REG_DWORD, (LPBYTE) &LocalServiceInfo->Mode, sizeof( LocalServiceInfo->Mode ) );

               if ( ERROR_SUCCESS == lError )
               {
                  // set FlipAllow
                  lError = RegSetValueEx( hKeyService, REG_VALUE_FLIP, 0, REG_DWORD, (LPBYTE) &LocalServiceInfo->FlipAllow, sizeof( LocalServiceInfo->FlipAllow ) );

                  if ( ERROR_SUCCESS == lError )
                  {
                     // set ConcurrentLimit
                     lError = RegSetValueEx( hKeyService, REG_VALUE_LIMIT, 0, REG_DWORD, (LPBYTE) &LocalServiceInfo->ConcurrentLimit, sizeof( LocalServiceInfo->ConcurrentLimit ) );
                  }
               }

               RegCloseKey( hKeyService );
            }

            RegCloseKey( hKeyLicenseInfo );
         }

         RegCloseKey( hKeyLocalMachine );
      }

      switch ( lError )
      {
      case ERROR_SUCCESS:
         Status = STATUS_SUCCESS;
         break;
      case ERROR_FILE_NOT_FOUND:
      case ERROR_PATH_NOT_FOUND:
         Status = STATUS_OBJECT_NAME_NOT_FOUND;
         break;
      case ERROR_ACCESS_DENIED:
         Status = STATUS_ACCESS_DENIED;
         break;
      default:
         Status = STATUS_UNSUCCESSFUL;
         break;
      }
   }

   return Status;
}


NTSTATUS
NTAPI
LlsLocalServiceInfoSetA(
   LLS_HANDLE  Handle,
   LPSTR       KeyName,
   DWORD       Level,
   LPBYTE      bufptr )
{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalServiceInfoSetA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;

   if (pLocalHandle == NULL)
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else if ( LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_LOCAL_SERVICE_API ) )
   {
      try {
         Status = LlsrLocalServiceInfoSetA( pLocalHandle->Handle, KeyName, Level, (PLLS_LOCAL_SERVICE_INFOA) bufptr );
      }
      except (TRUE) {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }
   }
   else
   {
      Status = STATUS_NOT_SUPPORTED;
   }

   return Status;
}


NTSTATUS
NTAPI
LlsLocalServiceInfoGetW(
   LLS_HANDLE  Handle,
   LPWSTR      KeyName,
   DWORD       Level,
   LPBYTE *    pbufptr )
{
   NTSTATUS       Status;
   PLOCAL_HANDLE  pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalServiceInfoGetW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;

   if (pLocalHandle == NULL)
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else if ( LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_LOCAL_SERVICE_API ) )
   {
      try
      {
         Status = LlsrLocalServiceInfoGetW( pLocalHandle->Handle, KeyName, Level, (PLLS_LOCAL_SERVICE_INFOW *) pbufptr );
      }
      except (TRUE)
      {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }
   }
   else if ( 0 != Level )
   {
      Status = STATUS_INVALID_LEVEL;
   }
   else if ( NULL == KeyName )
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else
   {
      PLLS_LOCAL_SERVICE_INFO_0W pLocalService = NULL;
      LONG                       lError;
      HKEY                       hKeyLocalMachine;

      lError = RegConnectRegistry( pLocalHandle->szServerName, HKEY_LOCAL_MACHINE, &hKeyLocalMachine );

      if ( ERROR_SUCCESS == lError )
      {
         HKEY  hKeyLicenseInfo;

         lError = RegOpenKeyEx( hKeyLocalMachine, REG_KEY_LICENSE, 0, KEY_READ, &hKeyLicenseInfo );

         if ( ERROR_SUCCESS == lError )
         {
            HKEY  hKeyService;

            lError = RegOpenKeyEx( hKeyLicenseInfo, KeyName, 0, KEY_READ, &hKeyService );

            if ( ERROR_SUCCESS == lError )
            {
               pLocalService = MIDL_user_allocate( sizeof( *pLocalService ) );

               if ( NULL == pLocalService )
               {
                  lError = ERROR_OUTOFMEMORY;
               }
               else
               {
                  DWORD    cbData;

                  cbData = sizeof( pLocalService->Mode );
                  lError = RegQueryValueEx( hKeyService, REG_VALUE_MODE, NULL, NULL, (LPBYTE) &pLocalService->Mode, &cbData );

                  if ( ERROR_SUCCESS == lError )
                  {
                     cbData = sizeof( pLocalService->FlipAllow );
                     lError = RegQueryValueEx( hKeyService, REG_VALUE_FLIP, NULL, NULL, (LPBYTE) &pLocalService->FlipAllow, &cbData );

                     if ( ERROR_SUCCESS == lError )
                     {
                        cbData = sizeof( pLocalService->ConcurrentLimit );
                        lError = RegQueryValueEx( hKeyService, REG_VALUE_LIMIT, NULL, NULL, (LPBYTE) &pLocalService->ConcurrentLimit, &cbData );

                        if ( ERROR_SUCCESS == lError )
                        {
                           DWORD    cbKeyName;
                           DWORD    cbDisplayName;
                           DWORD    cbFamilyDisplayName;

                           cbData = sizeof( pLocalService->HighMark );
                           lError = RegQueryValueEx( hKeyService, REG_VALUE_HIGHMARK, NULL, NULL, (LPBYTE) &pLocalService->HighMark, &cbData );

                           if ( ERROR_SUCCESS != lError )
                           {
                              pLocalService->HighMark = 0;
                              lError = ERROR_SUCCESS;
                           }

                           if (    ( ERROR_SUCCESS == RegQueryValueEx( hKeyService, REG_VALUE_NAME,   NULL, NULL, NULL, &cbDisplayName       ) )
                                && ( ERROR_SUCCESS == RegQueryValueEx( hKeyService, REG_VALUE_FAMILY, NULL, NULL, NULL, &cbFamilyDisplayName ) ) )
                           {
                              cbKeyName = sizeof( *KeyName ) * ( 1 + lstrlen( KeyName ) );

                              pLocalService->KeyName = MIDL_user_allocate( cbKeyName );

                              if ( NULL == pLocalService->KeyName )
                              {
                                 lError = ERROR_OUTOFMEMORY;
                              }
                              else
                              {
                                 lstrcpy( pLocalService->KeyName, KeyName );

                                 pLocalService->DisplayName = MIDL_user_allocate( cbDisplayName );

                                 if ( NULL == pLocalService->DisplayName )
                                 {
                                    lError = ERROR_OUTOFMEMORY;
                                 }
                                 else
                                 {
                                    lError = RegQueryValueEx( hKeyService, REG_VALUE_NAME, NULL, NULL, (LPBYTE) pLocalService->DisplayName, &cbDisplayName );

                                    if ( ERROR_SUCCESS == lError )
                                    {
                                       pLocalService->FamilyDisplayName = MIDL_user_allocate( cbFamilyDisplayName );

                                       if ( NULL == pLocalService->FamilyDisplayName )
                                       {
                                          lError = ERROR_OUTOFMEMORY;
                                       }
                                       else
                                       {
                                          lError = RegQueryValueEx( hKeyService, REG_VALUE_FAMILY, NULL, NULL, (LPBYTE) pLocalService->FamilyDisplayName, &cbFamilyDisplayName );

                                          if ( ERROR_SUCCESS != lError )
                                          {
                                             MIDL_user_free( pLocalService->FamilyDisplayName );
                                          }
                                       }
                                    }

                                    if ( ERROR_SUCCESS != lError )
                                    {
                                       MIDL_user_free( pLocalService->DisplayName );
                                    }
                                 }

                                 if ( ERROR_SUCCESS != lError )
                                 {
                                    MIDL_user_free( pLocalService->KeyName );
                                 }
                              }
                           }
                        }
                     }
                  }

                  if ( ERROR_SUCCESS != lError )
                  {
                     MIDL_user_free( pLocalService );
                  }
               }

               RegCloseKey( hKeyService );
            }

            RegCloseKey( hKeyLicenseInfo );
         }

         RegCloseKey( hKeyLocalMachine );
      }

      switch ( lError )
      {
      case ERROR_SUCCESS:
         Status = STATUS_SUCCESS;
         break;
      case ERROR_FILE_NOT_FOUND:
      case ERROR_PATH_NOT_FOUND:
         Status = STATUS_OBJECT_NAME_NOT_FOUND;
         break;
      case ERROR_ACCESS_DENIED:
         Status = STATUS_ACCESS_DENIED;
         break;
      default:
         Status = STATUS_UNSUCCESSFUL;
         break;
      }

      if ( STATUS_SUCCESS == Status )
      {
         *pbufptr = (LPBYTE) pLocalService;
      }
   }

   return Status;
}


NTSTATUS
NTAPI
LlsLocalServiceInfoGetA(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPSTR       KeyName,
   LPBYTE *    pbufptr )
{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLocalServiceInfoGetA\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;

   if (pLocalHandle == NULL)
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else if ( LlsCapabilityIsSupported( Handle, LLS_CAPABILITY_LOCAL_SERVICE_API ) )
   {
      try {
         Status = LlsrLocalServiceInfoGetA( pLocalHandle->Handle, KeyName, Level, (PLLS_LOCAL_SERVICE_INFOA *) pbufptr );
      }
      except (TRUE) {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }
   }
   else
   {
      Status = STATUS_NOT_SUPPORTED;
   }

   return Status;
}


NTSTATUS
NTAPI
LlsLicenseRequest2W(
   LLS_HANDLE  Handle,
   LPWSTR      Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   PHANDLE     pLicenseHandle )
{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;
   LICENSE_HANDLE RpcLicenseHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLicenseRequestW\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;

   if ((pLocalHandle == NULL) || (pLicenseHandle == NULL))
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else
   {
      try {
         RtlEnterCriticalSection( &g_RpcHandleLock );

         lsapirpc_handle = pLocalHandle->llsrpc_handle;

         Status = LlsrLicenseRequestW( &RpcLicenseHandle,
                                       Product,
                                       VersionIndex,
                                       IsAdmin,
                                       DataType,
                                       DataSize,
                                       Data );

         RtlLeaveCriticalSection( &g_RpcHandleLock );
      }
      except (TRUE) {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }

      *pLicenseHandle = RpcLicenseHandle;
   }

   return Status;
}

NTSTATUS
NTAPI
LlsLicenseRequestW(
   LLS_HANDLE  Handle,
   LPWSTR      Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   LPDWORD     pLicenseHandle )
{
   HANDLE RealLicenseHandle = (HANDLE)(-1);
   NTSTATUS status;

    if (sizeof(ULONG) == sizeof(HANDLE))
    {
        // Should still work on Win32

        status = LlsLicenseRequest2W(Handle,Product,VersionIndex,IsAdmin,DataType,DataSize,Data,&RealLicenseHandle);

        if (NULL != pLicenseHandle)
            *pLicenseHandle = PtrToUlong(RealLicenseHandle);
    }
    else
    {
        status = STATUS_NOT_IMPLEMENTED;

        if (NULL != pLicenseHandle)
            *pLicenseHandle = (ULONG) 0xFFFFFFFF;
    }

    return status;
}

NTSTATUS
NTAPI
LlsLicenseRequest2A(
   LLS_HANDLE  Handle,
   LPSTR       Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   PHANDLE     pLicenseHandle )
{
   return STATUS_NOT_SUPPORTED;
}

NTSTATUS
NTAPI
LlsLicenseRequestA(
   LLS_HANDLE  Handle,
   LPSTR       Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   LPDWORD     pLicenseHandle )
{
   return STATUS_NOT_SUPPORTED;
}

NTSTATUS
NTAPI
LlsLicenseFree2(
   LLS_HANDLE  Handle,
   HANDLE      LicenseHandle )
{
   NTSTATUS Status;
   PLOCAL_HANDLE pLocalHandle;
   LICENSE_HANDLE RpcLicenseHandle = (LICENSE_HANDLE) LicenseHandle;

#ifdef API_TRACE
   dprintf(TEXT("LLSRPC.DLL: LlsLicenseFree\n"));
#endif

   pLocalHandle = (PLOCAL_HANDLE) Handle;

   if (pLocalHandle == NULL)
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else
   {
      try {
         RtlEnterCriticalSection( &g_RpcHandleLock );

         lsapirpc_handle = pLocalHandle->llsrpc_handle;

         Status = LlsrLicenseFree( &RpcLicenseHandle );

         RtlLeaveCriticalSection( &g_RpcHandleLock );
      }
      except (TRUE) {
         Status = I_RpcMapWin32Status(RpcExceptionCode());
#if DBG
         dprintf(TEXT("ERROR LLSRPC.DLL: RPC Exception: 0x%lX\n"), Status);
#endif
      }
   }

   return Status;
}

NTSTATUS
NTAPI
LlsLicenseFree(
   LLS_HANDLE  Handle,
   DWORD       LicenseHandle )
{
   if (sizeof(ULONG) == sizeof(HANDLE))
   {
       // Should still work on Win32
       return LlsLicenseFree2(Handle,ULongToPtr(LicenseHandle));
   }
   else
   {
       return STATUS_NOT_IMPLEMENTED;
   }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\utils.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    Utilities.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 12-Nov-1995
        Copied from LLSMGR, stripped Tv (Tree view) functions,
        removed OLE support

--*/

#ifndef _UTILS_H_
#define _UTILS_H_

#define LPSTR_TEXTCALLBACK_MAX  260 

//
// List view utilities
//

#define LVID_SEPARATOR          0   
#define LVID_UNSORTED_LIST     -1

typedef struct _LV_COLUMN_ENTRY {

    int iSubItem;                   // column index
    int nStringId;                  // header string id 
    int nRelativeWidth;             // header width 

} LV_COLUMN_ENTRY, *PLV_COLUMN_ENTRY;

#pragma warning(disable:4200)
typedef struct _LV_COLUMN_INFO {

    BOOL bSortOrder;                // sort order (ascending false)
    int  nSortedItem;               // column sorted (default none)

    int nColumns;
    LV_COLUMN_ENTRY lvColumnEntry[];

} LV_COLUMN_INFO, *PLV_COLUMN_INFO;
#pragma warning(default:4200)

void LvInitColumns(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo);
void LvResizeColumns(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo);
void LvChangeFormat(CListCtrl* pListCtrl, UINT nFormatId);

LPVOID LvGetSelObj(CListCtrl* pListCtrl);
LPVOID LvGetNextObj(CListCtrl* pListCtrl, LPINT piItem, int nType = LVNI_ALL|LVNI_SELECTED);
void LvSelObjIfNecessary(CListCtrl* pListCtrl, BOOL bSetFocus = FALSE);

BOOL LvInsertObArray(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo, CObArray* pObArray);
BOOL LvRefreshObArray(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo, CObArray* pObArray);
void LvReleaseObArray(CListCtrl* pListCtrl);
void LvReleaseSelObjs(CListCtrl* pListCtrl);

#ifdef _DEBUG
void LvDumpObArray(CListCtrl* pListCtrl);
#endif

#define IsItemSelectedInList(plv)   (::LvGetSelObj((CListCtrl*)(plv)) != NULL)

//
// Other stuff...
//

void SetDefaultFont(CWnd* pWnd);

#ifdef _DEBUG
#define VALIDATE_OBJECT(pOb, ObClass) \
    { ASSERT_VALID((pOb)); ASSERT((pOb)->IsKindOf(RUNTIME_CLASS(ObClass))); }
#else
#define VALIDATE_OBJECT(pOb, ObClass)
#endif

#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ccfapi32\utils.cpp ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    Utiltities.

Author:

    Don Ryan (donryan) 04-Jan-1995

Environment:

    User Mode - Win32

Revision History:

    Jeff Parham (jeffparh) 12-Nov-1995
        Copied from LLSMGR, stripped Tv (Tree view) functions,
        removed OLE support

--*/

#include "stdafx.h"
#include "ccfapi.h"
#include "utils.h"

#define _AFX_NO_OLE_SUPPORT

//
// List view utilities
//

void LvInitColumns(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo)

/*++

Routine Description:

    Initializes list view columns.

Arguments:

    pListCtrl - list control.
    plvColumnInfo - column information.

Return Values:

    None.

--*/

{
    ASSERT(plvColumnInfo);
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    int        nStringId;
    CString    strText;
    LV_COLUMN  lvColumn;

    int nColumns = plvColumnInfo->nColumns;
    PLV_COLUMN_ENTRY plvColumnEntry = plvColumnInfo->lvColumnEntry;

    lvColumn.mask = LVCF_FMT|
                    LVCF_TEXT|
                    LVCF_SUBITEM;

    lvColumn.fmt = LVCFMT_LEFT;

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    while (nColumns--)
    {
        lvColumn.iSubItem = plvColumnEntry->iSubItem;

        if (nStringId = plvColumnEntry->nStringId)
        {
            strText.LoadString(nStringId);
        }
        else
        {
            strText = _T("");
        }

        lvColumn.pszText = strText.GetBuffer(0);

        int nColumnInserted = pListCtrl->InsertColumn( lvColumn.iSubItem, &lvColumn );
        ASSERT( -1 != nColumnInserted );

        plvColumnEntry++;

        strText.ReleaseBuffer();
    }

    SetDefaultFont(pListCtrl);

    LvResizeColumns(pListCtrl, plvColumnInfo);

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
}


void LvResizeColumns(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo)

/*++

Routine Description:

    Resizes list view columns.

Arguments:

    pListCtrl - list control.
    plvColumnInfo - column information.

Return Values:

    None.

--*/

{
    ASSERT(plvColumnInfo);
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    int nColumnWidth;
    int nRelativeWidth;
    int nEntireWidthSoFar = 0;
    int nColumns = plvColumnInfo->nColumns;
    PLV_COLUMN_ENTRY plvColumnEntry = plvColumnInfo->lvColumnEntry;

    CRect clientRect;
    pListCtrl->GetClientRect(clientRect);

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    while ((nRelativeWidth = plvColumnEntry->nRelativeWidth) != -1)
    {
        nColumnWidth = (nRelativeWidth * clientRect.Width()) / 100;
        pListCtrl->SetColumnWidth(plvColumnEntry->iSubItem, nColumnWidth);
        nEntireWidthSoFar += nColumnWidth;
        plvColumnEntry++;
    }

    nColumnWidth = clientRect.Width() - nEntireWidthSoFar;
    pListCtrl->SetColumnWidth(plvColumnEntry->iSubItem, nColumnWidth);

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
}


void LvChangeFormat(CListCtrl* pListCtrl, UINT nFormatId)

/*++

Routine Description:

    Changes window style of list view.

Arguments:

    pListCtrl - list control.
    nFormatId - format specification.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    DWORD dwStyle = ::GetWindowLong(pListCtrl->GetSafeHwnd(), GWL_STYLE);

    pListCtrl->BeginWaitCursor();
    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    if ((dwStyle & LVS_TYPEMASK) != nFormatId)
    {
        ::SetWindowLong(
            pListCtrl->GetSafeHwnd(),
            GWL_STYLE,
            (dwStyle & ~LVS_TYPEMASK) | nFormatId
            );
    }

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
    pListCtrl->EndWaitCursor();
}


LPVOID LvGetSelObj(CListCtrl* pListCtrl)

/*++

Routine Description:

    Retrieves the object selected (assumes one) from list view.

Arguments:

    pListCtrl - list control.

Return Values:

    Same as LvGetNextObj.

--*/

{
    int iItem = -1;
    return LvGetNextObj(pListCtrl, &iItem);
}


LPVOID LvGetNextObj(CListCtrl* pListCtrl, LPINT piItem, int nType)

/*++

Routine Description:

    Retrieves the next object selected from list view.

Arguments:

    pListCtrl - list control.
    piItem - starting index (updated).
    nType - specifies search criteria.

Return Values:

    Returns object pointer or null.

--*/

{
    ASSERT(piItem);
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    LV_ITEM lvItem;

    if ((lvItem.iItem = pListCtrl->GetNextItem(*piItem, nType)) != -1)
    {
        lvItem.mask = LVIF_PARAM;
        lvItem.iSubItem = 0;

        if (pListCtrl->GetItem(&lvItem))
        {
            *piItem = lvItem.iItem;
            return (LPVOID)lvItem.lParam;
        }
    }

    return NULL;
}


BOOL LvInsertObArray(CListCtrl* pListCtrl, PLV_COLUMN_INFO plvColumnInfo, CObArray* pObArray)

/*++

Routine Description:

    Insert object array into list view.
    Note list view must be unsorted and support LVN_GETDISPINFO.

Arguments:

    pListCtrl - list control.
    plvColumnInfo - column info.
    pObArray - object array.

Return Values:

    VT_BOOL.

--*/

{
    VALIDATE_OBJECT(pObArray, CObArray);
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    ASSERT(plvColumnInfo);
    ASSERT(pListCtrl->GetItemCount() == 0);

    BOOL bItemsInserted = FALSE;

    LV_ITEM lvItem;

    lvItem.mask = LVIF_TEXT|
                  LVIF_PARAM|
                  LVIF_IMAGE;

    lvItem.pszText    = LPSTR_TEXTCALLBACK;
    lvItem.cchTextMax = LPSTR_TEXTCALLBACK_MAX;
    lvItem.iImage     = I_IMAGECALLBACK;
    lvItem.iSubItem   = 0;

    int iItem;
    int iSubItem;

    int nItems = (int)pObArray->GetSize();
    ASSERT(nItems != -1); // iItem is -1 if error...

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    pListCtrl->SetItemCount(nItems);

    CObject* pObject = NULL;

    for (iItem = 0; (-1 != iItem) && (iItem < nItems) && (pObject = pObArray->GetAt(iItem)); iItem++)
    {
        VALIDATE_OBJECT(pObject, CObject);

        lvItem.iItem  = iItem;
        lvItem.lParam = (LPARAM)(LPVOID)pObject;

        iItem = pListCtrl->InsertItem(&lvItem);
        ASSERT((iItem == lvItem.iItem) || (iItem == -1));

        if ( -1 != iItem )
        {
            for (iSubItem = 1; iSubItem < plvColumnInfo->nColumns; iSubItem++)
            {
                BOOL ok = pListCtrl->SetItemText(iItem, iSubItem, LPSTR_TEXTCALLBACK);
                ASSERT( ok );
            }
        }
    }

    if (iItem == nItems)
    {
        bItemsInserted = TRUE;
        VERIFY(pListCtrl->SetItemState(
                    0,
                    LVIS_FOCUSED|
                    LVIS_SELECTED,
                    LVIS_FOCUSED|
                    LVIS_SELECTED
                    ));
    }
    else
    {
        theApp.SetLastError(ERROR_OUTOFMEMORY);
        VERIFY(pListCtrl->DeleteAllItems());
    }

    LvResizeColumns(pListCtrl, plvColumnInfo);

    pListCtrl->SetRedraw(TRUE); // turn on drawing...

    return bItemsInserted;
}


BOOL
LvRefreshObArray(
    CListCtrl*      pListCtrl,
    PLV_COLUMN_INFO plvColumnInfo,
    CObArray*       pObArray
    )

/*++

Routine Description:

    Refresh object array in list view.

Arguments:

    pListCtrl - list control.
    plvColumnInfo - column info.
    pObArray - object array.

Return Values:

    VT_BOOL.

--*/

{
    ASSERT(plvColumnInfo);
    VALIDATE_OBJECT(pObArray, CObArray);
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    long nObjects = (long)pObArray->GetSize();
    long nObjectsInList = pListCtrl->GetItemCount();

    if (!nObjects)
    {
        LvReleaseObArray(pListCtrl);
        return TRUE;
    }
    else if (!nObjectsInList)
    {
        return LvInsertObArray(
                pListCtrl,
                plvColumnInfo,
                pObArray
                );
    }

    CObject* pObject;

    int iObject = 0;
    int iObjectInList = 0;

    LV_ITEM lvItem;

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    while (nObjectsInList--)
    {
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iObjectInList;
        lvItem.iSubItem = 0;

        VERIFY(pListCtrl->GetItem(&lvItem));

        pObject = (CObject*)lvItem.lParam;
        VALIDATE_OBJECT(pObject, CObject);

        if (iObject < nObjects)
        {
            pObject = pObArray->GetAt(iObject++);
            VALIDATE_OBJECT(pObject, CObject);

            lvItem.mask = LVIF_TEXT|LVIF_PARAM;
            lvItem.pszText = LPSTR_TEXTCALLBACK;
            lvItem.cchTextMax = LPSTR_TEXTCALLBACK_MAX;
            lvItem.lParam = (LPARAM)(LPVOID)pObject;

            VERIFY(pListCtrl->SetItem(&lvItem)); // overwrite...

            iObjectInList++; // increment count...
        }
        else
        {
            VERIFY(pListCtrl->DeleteItem(iObjectInList));
        }
    }

    lvItem.mask = LVIF_TEXT|
                  LVIF_PARAM|
                  LVIF_IMAGE;

    lvItem.pszText    = LPSTR_TEXTCALLBACK;
    lvItem.cchTextMax = LPSTR_TEXTCALLBACK_MAX;
    lvItem.iImage     = I_IMAGECALLBACK;
    lvItem.iSubItem   = 0;

    int iItem;
    int iSubItem;

    while (iObject < nObjects)
    {
        lvItem.iItem = iObject;

        pObject = pObArray->GetAt(iObject++);
        VALIDATE_OBJECT(pObject, CObject);

        lvItem.lParam = (LPARAM)(LPVOID)pObject;

        iItem = pListCtrl->InsertItem(&lvItem);
        ASSERT((iItem == lvItem.iItem) && (iItem != -1));

        for (iSubItem = 1; iSubItem < plvColumnInfo->nColumns; iSubItem++)
        {
            VERIFY(pListCtrl->SetItemText(iItem, iSubItem, LPSTR_TEXTCALLBACK));
        }
    }

    LvResizeColumns(pListCtrl, plvColumnInfo);

    pListCtrl->SetRedraw(TRUE); // turn on drawing...

    return TRUE;
}


void LvReleaseObArray(CListCtrl* pListCtrl)

/*++

Routine Description:

    Release objects inserted into list view.

Arguments:

    pListCtrl - list control.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    LV_ITEM lvItem;

    CObject* pObject;

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = 0;
    lvItem.iSubItem = 0;

    int nObjectsInList = pListCtrl->GetItemCount();

    pListCtrl->BeginWaitCursor();
    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    while (nObjectsInList--)
    {
        VERIFY(pListCtrl->GetItem(&lvItem));

        pObject = (CObject*)lvItem.lParam;
        VALIDATE_OBJECT(pObject, CObject);

        VERIFY(pListCtrl->DeleteItem(lvItem.iItem));
    }

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
    pListCtrl->EndWaitCursor();
}


void LvReleaseSelObjs(CListCtrl* pListCtrl)

/*++

Routine Description:

    Release selected objects in list view.

Arguments:

    pListCtrl - list control.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    LV_ITEM lvItem;

    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;

    CObject* pObject;

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    int iItem = pListCtrl->GetNextItem(-1, LVNI_ALL|LVNI_SELECTED);

    while (iItem != -1)
    {
        lvItem.iItem = iItem;

        VERIFY(pListCtrl->GetItem(&lvItem));

        pObject = (CObject*)lvItem.lParam;
        VALIDATE_OBJECT(pObject, CObject);

        iItem = pListCtrl->GetNextItem(lvItem.iItem, LVNI_ALL|LVNI_SELECTED);

        VERIFY(pListCtrl->DeleteItem(lvItem.iItem));
    }

    LvSelObjIfNecessary(pListCtrl);

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
}


void LvSelObjIfNecessary(CListCtrl* pListCtrl, BOOL bSetFocus)

/*++

Routine Description:

    Ensure that object selected.

Arguments:

    pListCtrl - list control.
    bSetFocus - true if focus to be set focus as well.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    if (!IsItemSelectedInList(pListCtrl) && pListCtrl->GetItemCount())
    {
        pListCtrl->SendMessage(WM_KEYDOWN, VK_RIGHT); // HACKHACK...

        int iItem = pListCtrl->GetNextItem(-1, LVNI_FOCUSED|LVNI_ALL);
        int nState = bSetFocus ? (LVIS_SELECTED|LVIS_FOCUSED) : LVIS_SELECTED;

        VERIFY(pListCtrl->SetItemState((iItem == -1) ? 0 : iItem, nState, nState));
    }
}


#ifdef _DEBUG

void LvDumpObArray(CListCtrl* pListCtrl)

/*++

Routine Description:

    Release objects inserted into list view.

Arguments:

    pListCtrl - list control.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pListCtrl, CListCtrl);

    LV_ITEM lvItem;

    CString strDump;
    CObject* pObject;

    lvItem.mask = LVIF_STATE|LVIF_PARAM;
    lvItem.stateMask = (DWORD)-1;
    lvItem.iSubItem = 0;

    int nObjectsInList = pListCtrl->GetItemCount();

    pListCtrl->SetRedraw(FALSE); // turn off drawing...

    while (nObjectsInList--)
    {
        lvItem.iItem = nObjectsInList;

        VERIFY(pListCtrl->GetItem(&lvItem));

        pObject = (CObject*)lvItem.lParam;
        VALIDATE_OBJECT(pObject, CObject);

        strDump.Format(_T("iItem %d"), lvItem.iItem);
        strDump += (lvItem.state & LVIS_CUT)      ? _T(" LVIS_CUT ")      : _T("");
        strDump += (lvItem.state & LVIS_FOCUSED)  ? _T(" LVIS_FOCUSED ")  : _T("");
        strDump += (lvItem.state & LVIS_SELECTED) ? _T(" LVIS_SELECTED ") : _T("");
        strDump += _T("\r\n");

        afxDump << strDump;
    }

    pListCtrl->SetRedraw(TRUE); // turn on drawing...
}

#endif


void SetDefaultFont(CWnd* pWnd)

/*++

Routine Description:

    Set default font.

Arguments:

    pWnd - window to change font.

Return Values:

    None.

--*/

{
    VALIDATE_OBJECT(pWnd, CWnd);

    HFONT hFont;
    LOGFONT lFont;
    CHARSETINFO csi;
    DWORD dw = ::GetACP();
    TCHAR szData[7] ;
    LANGID wLang = GetUserDefaultUILanguage();
    csi.ciCharset = DEFAULT_CHARSET;

    if( GetLocaleInfo(MAKELCID(wLang, SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szData, (sizeof( szData ) / sizeof( TCHAR ))) > 0)
    {
        UINT uiCp = _ttoi(szData);
        TranslateCharsetInfo((DWORD*) (DWORD_PTR)uiCp, &csi, TCI_SRCCODEPAGE);
    }
            

    memset(&lFont, 0, sizeof(LOGFONT));     // initialize

    //
    // Merged from FE NT 4.0.
    //

 //   if (!::TranslateCharsetInfo((DWORD*)dw, &csi, TCI_SRCCODEPAGE))
 //   csi.ciCharset = DEFAULT_CHARSET;
    lFont.lfCharSet = (BYTE)csi.ciCharset;

    lFont.lfHeight      = 13;
    lFont.lfWeight      = 200;              // non-bold

    hFont = ::CreateFontIndirect(&lFont);
    pWnd->SetFont(CFont::FromHandle(hFont));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ntlsapi\lsapi_c_stub.c ===
#include "lsapi_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\common\debug.c ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    debug.c

Abstract:

Notes:

--*/

#include <windows.h>
#include <windowsx.h>
#include <io.h>
#include <malloc.h>
#include <string.h>

#if DBG
void __cdecl dprintf(LPTSTR szFormat, ...) {
   static TCHAR tmpStr[1024];
   va_list marker;

   va_start(marker, szFormat);
   wvsprintf(tmpStr, szFormat, marker);
   OutputDebugString(tmpStr);
   va_end(marker);

} // dprintf
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\idl\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1995 - 1998

Module Name:

    makefile.inc

!ENDIF

#
# This is the MIDL compile phase of the build process.
#

MIDL_PROTOCOL=all
!INCLUDE $(NTMAKEENV)\makefile.plt

#####################################################################
#
# For the UI RPC functions
#
IDL_NAME = llsrpc
CLIENT_ACF = llscli.acf
SERVER_ACF = llssrv.acf

CLIENT_INC_FILE = $(IDL_NAME)_c.h
SERVER_INC_FILE = $(IDL_NAME)_s.h

#####################################################################
#
# For the NtLSApi functions
#
LSAPI_IDL_NAME = lsapi
LSAPI_CLIENT_ACF = lsapicli.acf
LSAPI_SERVER_ACF = lsapisrv.acf

LSAPI_CLIENT_INC_FILE = $(LSAPI_IDL_NAME)_c.h
LSAPI_SERVER_INC_FILE = $(LSAPI_IDL_NAME)_s.h

#####################################################################
#
# For the Debugging RPC functions
#
DEBUG_IDL_NAME = llsdbg
DEBUG_CLIENT_ACF = lsdbgcli.acf
DEBUG_SERVER_ACF = lsdbgsrv.acf

DEBUG_CLIENT_INC_FILE = $(DEBUG_IDL_NAME)_c.h
DEBUG_SERVER_INC_FILE = $(DEBUG_IDL_NAME)_s.h

#####################################################################
#
# Common INC files
#
SDKINC = $(SDK_INC_PATH)
SDKCRTINC = $(CRT_INC_PATH)
LLSINC = ..\inc

INCS  = -I$(SDKINC)  -I$(SDKCRTINC) -I$(LLSINC)

EXTRN_DEPENDS =

MIDL_FLAGS= $(MIDL_FLAGS) -out .\$(O)

CLIENT_FLAGS = $(MIDL_OPTIMIZATION) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(CLIENT_ACF) -header $(CLIENT_INC_FILE) -server none
SERVER_FLAGS = $(MIDL_OPTIMIZATION) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(SERVER_ACF) -header $(SERVER_INC_FILE) -client none

LSAPI_CLIENT_FLAGS = $(MIDL_OPTIMIZATION) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(LSAPI_CLIENT_ACF) -header $(LSAPI_CLIENT_INC_FILE) -server none
LSAPI_SERVER_FLAGS = $(MIDL_OPTIMIZATION) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(LSAPI_SERVER_ACF) -header $(LSAPI_SERVER_INC_FILE) -client none

DEBUG_CLIENT_FLAGS = $(MIDL_OPTIMIZATION) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(DEBUG_CLIENT_ACF) -header $(DEBUG_CLIENT_INC_FILE) -server none
DEBUG_SERVER_FLAGS = $(MIDL_OPTIMIZATION) -oldnames -c_ext -ms_ext $(MIDL_FLAGS) -acf $(DEBUG_SERVER_ACF) -header $(DEBUG_SERVER_INC_FILE) -client none

CPP = -cpp_cmd "$(MIDL_CPP)"

#
# Separate client and server targets.  Note that the .h file produced
# when MIDL is run with the client .acf file attached differs from the
# .h file produced when MIDL is run with the server .acf file attached.
#

CLIENT_TARGETS = $(O)\$(IDL_NAME)_c.c          \
                 $(O)\$(CLIENT_INC_FILE)

SERVER_TARGETS = $(O)\$(IDL_NAME)_s.c          \
                 $(O)\$(SERVER_INC_FILE)

LSAPI_CLIENT_TARGETS =                            \
                 $(O)\$(LSAPI_IDL_NAME)_c.c    \
                 $(O)\$(LSAPI_CLIENT_INC_FILE)

LSAPI_SERVER_TARGETS =                           \
                 $(O)\$(LSAPI_IDL_NAME)_s.c    \
                 $(O)\$(LSAPI_SERVER_INC_FILE)

DEBUG_SERVER_TARGETS =                           \
                 $(O)\$(DEBUG_IDL_NAME)_s.c    \
                 $(O)\$(DEBUG_SERVER_INC_FILE)

TARGETS =   $(CLIENT_TARGETS)       \
            $(SERVER_TARGETS)       \
            $(LSAPI_CLIENT_TARGETS) \
            $(LSAPI_SERVER_TARGETS) \
            $(DEBUG_SERVER_TARGETS)


CLIENT_EXTRN_DEPENDS = $(CLIENT_ACF) $(LSAPI_CLIENT_ACF) $(DEBUG_CLIENT_ACF)
SERVER_EXTRN_DEPENDS = $(SERVER_ACF) $(LSAPI_SERVER_ACF) $(DEBUG_SERVER_ACF)
EXTRN_DEPENDS = $(CLIENT_EXTRN_DEPENDS)

#
# MIDL COMPILE
#

$(CLIENT_TARGETS) : $(IDL_NAME).idl $(CLIENT_EXTRN_DEPENDS)
    midl -no_format_opt $(CPP) $(CLIENT_FLAGS) $(INCS) $(IDL_NAME).idl

$(SERVER_TARGETS) : $(IDL_NAME).idl $(SERVER_EXTRN_DEPENDS)
    midl -no_format_opt $(CPP) $(SERVER_FLAGS) $(INCS) $(IDL_NAME).idl

$(LSAPI_CLIENT_TARGETS) : $(LSAPI_IDL_NAME).idl $(CLIENT_EXTRN_DEPENDS)
    midl -no_format_opt $(CPP) $(LSAPI_CLIENT_FLAGS) $(INCS) $(LSAPI_IDL_NAME).idl

$(LSAPI_SERVER_TARGETS) : $(LSAPI_IDL_NAME).idl $(SERVER_EXTRN_DEPENDS)
    midl -no_format_opt $(CPP) $(LSAPI_SERVER_FLAGS) $(INCS) $(LSAPI_IDL_NAME).idl

$(DEBUG_SERVER_TARGETS) : $(DEBUG_IDL_NAME).idl $(SERVER_EXTRN_DEPENDS)
    midl -no_format_opt $(CPP) $(DEBUG_SERVER_FLAGS) $(INCS) $(DEBUG_IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\inc\llsimp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    llsimp.h

Abstract:

    Private Includes

Author:

    Arthur Hanson       (arth)      Jan 20-1994

Environment:

Revision History:

--*/

#include <nt.h>
#include <windef.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\inc\llsconst.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    llsconst.h

Abstract:

--*/

#ifndef NT_LS_USER_NAME
#define NT_LS_USER_NAME 0
#endif

#ifndef NT_LS_USER_SID
#define NT_LS_USER_SID  1
#endif

#define MAX_PRODUCT_NAME_LENGTH 35
#define MAX_VERSION_LENGTH 15
#define MAX_USER_NAME_LENGTH 37
#define MAX_DATA_LENGTH 80
#define MAX_DATA_LENGTHW 40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\inc\debug.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    debug.h

Abstract:

--*/

#ifdef __cplusplus
extern "C" {
#endif

#define TRACE_FUNCTION_TRACE  0x0001
#define TRACE_WARNINGS        0x0002
#define TRACE_PACK            0x0004
#define TRACE_LICENSE_REQUEST 0x0008
#define TRACE_LICENSE_FREE    0x0010
#define TRACE_REGISTRY        0x0020
#define TRACE_REPLICATION     0x0040
#define TRACE_LPC             0x0080
#define TRACE_RPC             0x0100
#define TRACE_INIT            0x0200
#define TRACE_DATABASE        0x0400

#define SERVICE_TABLE_NUM             1
#define USER_TABLE_NUM                2
#define SID_TABLE_NUM                 3
#define LICENSE_TABLE_NUM             4
#define ADD_CACHE_TABLE_NUM           5
#define MASTER_SERVICE_TABLE_NUM      6
#define SERVICE_FAMILY_TABLE_NUM      7
#define MAPPING_TABLE_NUM             8
#define SERVER_TABLE_NUM              9
#define SECURE_PRODUCT_TABLE_NUM     10
#define CERTIFICATE_TABLE_NUM        11

#if DBG
void __cdecl dprintf(LPTSTR szFormat, ...);

extern DWORD TraceFlags;

#define ERR(x) \
        dprintf(TEXT("LLS : <%s @line %d> -> 0x%x\n"), \
            __FILE__, \
            __LINE__, \
            x);

#else
#define dprintf
#define ERR(x)
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\inc\lpcstub.h ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name:

    lpcstub.h

Abstract:

--*/

//
//
//

#ifndef _LLSLPCSTUB_H
#define _LLSLPCSTUB_H


#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS LLSInitLPC();
NTSTATUS LLSCloseLPC();
NTSTATUS LLSLicenseRequest ( IN LPWSTR ProductName, IN LPWSTR Version, IN ULONG DataType,
    IN BOOLEAN IsAdmin, IN PVOID Data, OUT ULONG *LicenseHandle );
NTSTATUS LLSLicenseFree ( IN ULONG LicenseHandle );

NTSTATUS LLSLicenseRequest2 ( IN LPWSTR ProductName, IN LPWSTR Version, IN ULONG DataType,
    IN BOOLEAN IsAdmin, IN PVOID Data, OUT LS_HANDLE *LicenseHandle );
NTSTATUS LLSLicenseFree2 ( IN LS_HANDLE LicenseHandle );


#ifdef DEBUG

NTSTATUS LLSDbg_TableDump ( ULONG Table );
NTSTATUS LLSDbg_TableInfoDump ( IN ULONG Table, IN ULONG DataType, IN PVOID Data );
NTSTATUS LLSDbg_TableFlush ( ULONG Table );
NTSTATUS LLSDbg_TraceSet ( ULONG Level );
NTSTATUS LLSDbg_ConfigDump ( );
NTSTATUS LLSDbg_ReplicationForce ( );
NTSTATUS LLSDbg_ReplicationDeny ( );
NTSTATUS LLSDbg_RegistryUpdateForce ( );
NTSTATUS LLSDbg_LicenseCheckForce ( );

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ntlsapi\main.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    main.c

Created:

    20-Apr-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsapi.h>
#include <malloc.h>

#include <lpcstub.h>

extern RTL_CRITICAL_SECTION LPCInitLock;

//
// DLL Startup code
//
BOOL WINAPI DllMain(
    HANDLE hDll,
    DWORD  dwReason,
    LPVOID lpReserved)
{
    NTSTATUS status = STATUS_SUCCESS;

    switch(dwReason)
        {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hDll);
            status = LLSInitLPC();
            break;

        case DLL_PROCESS_DETACH:
            LLSCloseLPC();
            RtlDeleteCriticalSection(&LPCInitLock);
            break;

        } // end switch()

    return NT_SUCCESS(status);

} // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\inc\rpcutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rpcutil.h

Abstract:

    This file contains prototypes for the bind and unbind functions that
    all lls functions will call.  It also includes the allocate
    and free routines used by the MIDL generated RPC stubs.

Author:

    Arthur Hanson   (arth)            Jan 30, 1994

[Environment:]

    User Mode - Win32

Revision History:

--*/

#ifndef _RPCUTIL_
#define _RPCUTIL_

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>

//
// The following typedefs are created for use in the Enum entry point
// routines.  These structures are meant to mirror the level specific
// info containers that are specified in the .idl file for the Enum API
// function.  Using these structures to set up for the API call allows
// the entry point routine to avoid using any bulky level-specific logic
// to set-up or return from the RPC stub call.
//

typedef struct _GENERIC_INFO_CONTAINER {
    DWORD       EntriesRead;
    LPBYTE      Buffer;
} GENERIC_INFO_CONTAINER, *PGENERIC_INFO_CONTAINER, *LPGENERIC_INFO_CONTAINER ;

typedef struct _GENERIC_ENUM_STRUCT {
    DWORD                   Level;
    PGENERIC_INFO_CONTAINER Container;
} GENERIC_ENUM_STRUCT, *PGENERIC_ENUM_STRUCT, *LPGENERIC_ENUM_STRUCT ;



//
// DEFINES
//

//
// Function Prototypes
//

void *
MIDL_user_allocate(
    IN ULONG NumBytes
    );

void
MIDL_user_free(
    IN PVOID MemPointer
    );


#endif // _RPCUTIL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\certdb.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   certdb.h

Abstract:


Author:
   
   Jeff Parham (jeffparh) 16-Nov-1995

Revision History:

--*/

#ifndef _CERTDB_H_
#define _CERTDB_H_

// maximum time (in seconds) allowed to pass between certificate replications
// before we remove the apparently no longer used data.  this is so that, for
// example, if a machine goes down (taking its licenses with it), the licenses
// it had registered won't forever keep the user from reinstalling them.
#define LLS_CERT_DB_REPLICATION_DATE_DELTA_MAX     ( 60 * 60 * 72 )

#define LLS_CERT_DB_FILE_VERSION                   ( 0x0201 )

typedef struct _LLS_CERT_DB_FILE_HEADER
{
   ULONG ProductStringSize;
   ULONG NumCertificates;
   ULONG NumClaims;
} LLS_CERT_DB_FILE_HEADER, *PLLS_CERT_DB_FILE_HEADER;

typedef struct _LLS_CERT_DB_CERTIFICATE_CLAIM
{
   TCHAR  ServerName[ 1 + MAX_COMPUTERNAME_LENGTH ];
   DWORD  ReplicationDate;
   LONG   Quantity;
} LLS_CERT_DB_CERTIFICATE_CLAIM, *PLLS_CERT_DB_CERTIFICATE_CLAIM;

typedef struct _LLS_CERT_DB_CERTIFICATE_HEADER
{
   LPTSTR                           Product;
   DWORD                            CertificateID;
   DWORD                            MaxQuantity;
   DWORD                            ExpirationDate;

   DWORD                            NumClaims;
   PLLS_CERT_DB_CERTIFICATE_CLAIM   Claims;
} LLS_CERT_DB_CERTIFICATE_HEADER, *PLLS_CERT_DB_CERTIFICATE_HEADER;


NTSTATUS
CertDbInit();

NTSTATUS
CertDbLoad();

NTSTATUS
CertDbSave();

void
CertDbLogViolations();

void
CertDbPrune();

void
CertDbRemoveLocalClaims();

void
CertDbUpdateLocalClaims();

NTSTATUS
CertDbClaimEnter(    LPTSTR                           pszServerName,
                     PLLS_LICENSE_INFO_1              pLicense,
                     BOOL                             bIsTotal,
                     DWORD                            ReplicationDate );

BOOL
CertDbClaimApprove(  PLLS_LICENSE_INFO_1              pLicense );

PLLS_CERT_DB_CERTIFICATE_HEADER
CertDbHeaderFind(    PLLS_LICENSE_INFO_1              pLicense );

PLLS_CERT_DB_CERTIFICATE_HEADER
CertDbHeaderAdd(     PLLS_LICENSE_INFO_1              pLicense );

int
CertDbClaimFind(     PLLS_CERT_DB_CERTIFICATE_HEADER  pHeader,
                     LPTSTR                           pszServerName );

NTSTATUS
CertDbPack(          LPDWORD                               pcchProductStrings,
                     LPTSTR *                              ppchProductStrings,
                     LPDWORD                               pdwNumHeaders,
                     PREPL_CERT_DB_CERTIFICATE_HEADER_0 *  ppHeaders,
                     LPDWORD                               pdwNumClaims,
                     PREPL_CERT_DB_CERTIFICATE_CLAIM_0 *   ppClaims );

NTSTATUS
CertDbUnpack(        DWORD                               cchProductStrings,
                     LPTSTR                              pchProductStrings,
                     DWORD                               dwNumHeaders,
                     PREPL_CERT_DB_CERTIFICATE_HEADER_0  pHeaders,
                     DWORD                               dwNumClaims,
                     PREPL_CERT_DB_CERTIFICATE_CLAIM_0   pClaims,
                     BOOL                                bReplicated );

NTSTATUS
CertDbClaimsGet(     PLLS_LICENSE_INFO_1                 pLicense,
                     LPDWORD                             pdwNumClaims,
                     PLLS_CERTIFICATE_CLAIM_INFO_0 *     ppTargets );

#if DBG
void CertDbDebugDump();
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\certdb.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   certdb.c

Abstract:

   License Logging Service certificate database implementation.  This database
   tracks license certificates to help ensure that no more licenses from a
   single certificate are installe don the license enterprise than are allowed
   by the certificate's license agreement.

   The certificate database at the top level is an unsorted array of
   certificate headers.  There is exactly one header per unique certificate.
   A unique certificate is identified by a combination of product name,
   certificate ID, certificate capacity (max. licenses legally installable),
   and expiration date.

   Each header has an attached array of certificate claims.  There is exactly
   one claim per machine that (a) replicates to this machine, directly or
   indirectly, and (b) has licenses from this certificate installed.  Each
   claim contains the server name to which it corresponds, the number of
   licenses installed on it, and the date this information was replicated.
   If a claim is not updated after LLS_CERT_DB_REPLICATION_DATE_DELTA_MAX
   seconds (3 days as of this writing), the claim is considered forfeit and
   is erased.

Author:

   Jeff Parham (jeffparh) 08-Dec-1995

Revision History:

--*/


#include <stdlib.h>
#include <limits.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <rpcndr.h>
#include <dsgetdc.h>

#include "debug.h"
#include "llsutil.h"
#include "llssrv.h"
#include "llsapi.h"
#include "llsevent.h"
#include "llsrpc_s.h"
#include "certdb.h"
#include "purchase.h"
#include "registry.h"


RTL_RESOURCE                     CertDbHeaderListLock;
static PLLS_CERT_DB_CERTIFICATE_HEADER  CertDbHeaderList        = NULL;
static DWORD                            CertDbHeaderListSize    = 0;
static HANDLE                           CertDbFile              = NULL;


///////////////////////////////////////////////////////////////////////////////
NTSTATUS CertDbClaimEnter( LPTSTR               pszServerName,
                           PLLS_LICENSE_INFO_1  pLicense,
                           BOOL                 bIsTotal,
                           DWORD                ReplicationDate )

/*++

Routine Description:

   Enter a claim into the database.

Arguments:

   pszServerName (LPTSTR)
      The server for which to enter this claim.  A value of NULL indicates the
      local server.
   pLicense (PLLS_LICENSE_INFO_1)
      License information to enter into the database.
   bIsTotal (BOOL)
      If TRUE, indicates that this license information represents the total
      licenses installed on the machine and should therefore replace the
      current claim (if any).  Otherwise, indicates this license information
      should be added to the current claim (if any).
   ReplicationDate (DWORD)
      Indicates the date which this information was last replicated.  A value
      of 0 will be replaced with the current system time.

Return Value:

   STATUS_SUCCESS
   STATUS_INVALID_PARAMETER
   STATUS_INVALID_COMPUTER_NAME
   STATUS_NO_MEMORY

--*/

{
   NTSTATUS    nt;

   if ( ( NULL == pLicense ) || ( 0 == pLicense->CertificateID ) )
   {
      ASSERT( FALSE );
      nt = STATUS_INVALID_PARAMETER;
   }
   else
   {
      TCHAR    szComputerName[ 1 + MAX_COMPUTERNAME_LENGTH ];

      if ( NULL == pszServerName )
      {
         // use local server name
         DWORD    cchComputerName = sizeof( szComputerName ) / sizeof( *szComputerName );
         BOOL     ok;

         ok = GetComputerName( szComputerName, &cchComputerName );
         ASSERT( ok );

         if ( ok )
         {
            pszServerName = szComputerName;
         }
      }
      else
      {
         // remove leading backslashes (if any) from server name
         while ( TEXT('\\') == *pszServerName )
         {
            pszServerName++;
         }
      }

      if ( ( NULL == pszServerName ) || !*pszServerName || ( lstrlen( pszServerName ) > MAX_COMPUTERNAME_LENGTH ) )
      {
         ASSERT( FALSE );
         nt = STATUS_INVALID_COMPUTER_NAME;
      }
      else
      {
         PLLS_CERT_DB_CERTIFICATE_HEADER  pHeader;

         RtlAcquireResourceExclusive( &CertDbHeaderListLock, TRUE );

         // is the certificate in the db?
         pHeader = CertDbHeaderFind( pLicense );

         if ( NULL == pHeader )
         {
            // certificate not yet in db; add it
            pHeader = CertDbHeaderAdd( pLicense );
         }

         if ( NULL == pHeader )
         {
            // could not find or add header
            ASSERT( FALSE );
            nt = STATUS_NO_MEMORY;
         }
         else
         {
            // now have header; is this claim already filed?
            int iClaim;

            iClaim = CertDbClaimFind( pHeader, pszServerName );

            if ( iClaim < 0 )
            {
               PLLS_CERT_DB_CERTIFICATE_CLAIM pClaimsTmp;

               // claim does not yet exist; add it
               if ( NULL == pHeader->Claims )
               {
                  pClaimsTmp = LocalAlloc( LPTR, ( 1 + pHeader->NumClaims ) * sizeof( LLS_CERT_DB_CERTIFICATE_CLAIM ) );
               }
               else
               {
                   pClaimsTmp = LocalReAlloc( pHeader->Claims, ( 1 + pHeader->NumClaims ) * sizeof( LLS_CERT_DB_CERTIFICATE_CLAIM ), LHND );

               }

               if ( NULL != pClaimsTmp )
               {
                  // memory allocation succeeded

                  // claim list expanded; save server name
                  pHeader->Claims = pClaimsTmp;

                  iClaim = pHeader->NumClaims;
                  lstrcpy( pHeader->Claims[ iClaim ].ServerName, pszServerName );
                  pHeader->Claims[ iClaim ].Quantity = 0;

                  pHeader->NumClaims++;
               }
            }

            if ( iClaim < 0 )
            {
               // could not find or add claim to header
               ASSERT( FALSE );
               nt = STATUS_NO_MEMORY;
            }
            else
            {
               // claim found or added; update info
               ASSERT( !lstrcmpi( pszServerName, pHeader->Claims[ iClaim ].ServerName ) );
               pHeader->Claims[ iClaim ].ReplicationDate = ReplicationDate ? ReplicationDate : DateSystemGet();

               if ( bIsTotal )
               {
                  // the given value is the new total
                  pHeader->Claims[ iClaim ].Quantity        = pLicense->Quantity;
                  nt = STATUS_SUCCESS;
               }
               else if ( pHeader->Claims[ iClaim ].Quantity + pLicense->Quantity >= 0 )
               {
                  // the given value is added to the current sum to make the total
                  pHeader->Claims[ iClaim ].Quantity       += pLicense->Quantity;
                  nt = STATUS_SUCCESS;
               }
               else
               {
                  // overflow
                  nt = STATUS_INVALID_PARAMETER;
               }
            }
         }

         RtlReleaseResource( &CertDbHeaderListLock );

         if ( STATUS_SUCCESS == nt )
         {
            // any product that has licenses with non-0 certificate IDs
            // must be secure; this code is here such that when certificates
            // are replicated, the "product is secure" info is replicated, too
            // this will also help recover from the case where someone deletes
            // the registry key that lists all secure products
            ServiceSecuritySet( pLicense->Product );
         }
      }
   }

   return nt;
}


///////////////////////////////////////////////////////////////////////////////
BOOL CertDbClaimApprove( PLLS_LICENSE_INFO_1 pLicense )

/*++

Routine Description:

   Check to see if adding the given licenses is legal.  This call is typically
   made before adding a license into the system to verify that doing so does
   not violate the certificate's license agreement.

Arguments:

   pLicense (PLLS_LICENSE_INFO_1)
      License information for which approval is sought.

Return Value:

   TRUE (approved) or FALSE (rejected).

--*/

{
   BOOL                             bOkToAdd = TRUE;
   PLLS_CERT_DB_CERTIFICATE_HEADER  pHeader;
   TCHAR                            szComputerName[ 1 + MAX_COMPUTERNAME_LENGTH ];
   DWORD                            cchComputerName = sizeof( szComputerName ) / sizeof( *szComputerName );
   BOOL                             ok;

   if ( ( pLicense->Quantity > 0 ) && ( (DWORD)pLicense->Quantity > pLicense->MaxQuantity ) )
   {
      // certificate add request exceeds its capacity all by itself!
      bOkToAdd = FALSE;
   }
   else
   {
      ok = GetComputerName( szComputerName, &cchComputerName );
      ASSERT( ok );

      if ( !ok )
      {
         // deletions will fail...
         *szComputerName = TEXT( '\0' );
      }

      // do we have a record of this certificate?
      RtlAcquireResourceShared( &CertDbHeaderListLock, TRUE );

      pHeader = CertDbHeaderFind( pLicense );

      if ( NULL == pHeader )
      {
         // don't have any record of this certificate; ok to add if Quantity > 0
         bOkToAdd = ( pLicense->Quantity > 0 );
      }
      else
      {
         LONG     lTotalQuantity = 0;
         int      iClaim;

         // we have seen this certificate; are there enough licenses available?
         for ( iClaim=0; (DWORD)iClaim < pHeader->NumClaims; iClaim++ )
         {
            // for license remove requests, tally only local licenses
            // for license add requests, tally all licenses
            if (    (    ( pLicense->Quantity > 0 )
                      || ( !lstrcmpi( pHeader->Claims[ iClaim ].ServerName, szComputerName ) ) )
                 && ( lTotalQuantity + pHeader->Claims[ iClaim ].Quantity >= 0 ) )
            {
               // add to tally
               lTotalQuantity += pHeader->Claims[ iClaim ].Quantity;
            }
         }

         if ( lTotalQuantity + pLicense->Quantity < 0 )
         {
            // overflow or underflow
            bOkToAdd = FALSE;
         }
         else if ( (DWORD)(lTotalQuantity + pLicense->Quantity) > pHeader->MaxQuantity )
         {
            // exceeds certificate capacity
            bOkToAdd = FALSE;
         }
         else
         {
            // okay by me
            bOkToAdd = TRUE;
         }
      }

      RtlReleaseResource( &CertDbHeaderListLock );
   }

   return bOkToAdd;
}


///////////////////////////////////////////////////////////////////////////////
PLLS_CERT_DB_CERTIFICATE_HEADER CertDbHeaderFind( PLLS_LICENSE_INFO_1 pLicense )

/*++

Routine Description:

   Find a certificate header in the database.

Arguments:

   pLicense (PLLS_LICENSE_INFO_1)
      License information for which to find the appropriate header.

Return Value:

   A pointer to the found header, or NULL if not found.

--*/

{
   // assumes db is already locked for shared or exclusive access

   PLLS_CERT_DB_CERTIFICATE_HEADER  pHeader = NULL;
   int                              iHeader;

   for ( iHeader=0; ( NULL == pHeader ) && ( (DWORD)iHeader < CertDbHeaderListSize ); iHeader++ )
   {
      if (    ( CertDbHeaderList[ iHeader ].CertificateID  ==   pLicense->CertificateID  )
           && ( CertDbHeaderList[ iHeader ].MaxQuantity    ==   pLicense->MaxQuantity    )
           && ( CertDbHeaderList[ iHeader ].ExpirationDate ==   pLicense->ExpirationDate )
           && ( !lstrcmpi( CertDbHeaderList[ iHeader ].Product, pLicense->Product      ) ) )
      {
         // header found!
         pHeader = &CertDbHeaderList[ iHeader ];
      }
   }

   return pHeader;
}


///////////////////////////////////////////////////////////////////////////////
PLLS_CERT_DB_CERTIFICATE_HEADER CertDbHeaderAdd( PLLS_LICENSE_INFO_1 pLicense )

/*++

Routine Description:

   Add a certificate header to the database.

Arguments:

   pLicense (PLLS_LICENSE_INFO_1)
      License information for which to add the header.

Return Value:

   A pointer to the added header, or NULL if memory could not be allocated.

--*/

{
   // assumes caller has made sure the header does not already exist
   // assumes db is locked for exclusive access

   PLLS_CERT_DB_CERTIFICATE_HEADER  pHeader;

   if ( CertDbHeaderListSize )
   {
      pHeader = LocalReAlloc( CertDbHeaderList, ( 1 + CertDbHeaderListSize ) * sizeof( LLS_CERT_DB_CERTIFICATE_HEADER ), LHND );
   }
   else
   {
      pHeader = LocalAlloc( LPTR, ( 1 + CertDbHeaderListSize ) * sizeof( LLS_CERT_DB_CERTIFICATE_HEADER ) );
   }

   if ( NULL != pHeader )
   {
       CertDbHeaderList = pHeader;

      // allocate space for product name
      CertDbHeaderList[ CertDbHeaderListSize ].Product = LocalAlloc( LPTR, sizeof( TCHAR ) * ( 1 + lstrlen( pLicense->Product ) ) );

      if ( NULL == CertDbHeaderList[ CertDbHeaderListSize ].Product )
      {
         // memory allocation failed
         ASSERT( FALSE );
         pHeader = NULL;
      }
      else
      {
         // success!
         pHeader = &CertDbHeaderList[ CertDbHeaderListSize ];
         CertDbHeaderListSize++;

         lstrcpy( pHeader->Product, pLicense->Product );
         pHeader->CertificateID   = pLicense->CertificateID;
         pHeader->MaxQuantity     = pLicense->MaxQuantity;
         pHeader->ExpirationDate  = pLicense->ExpirationDate;
      }
   }

   return pHeader;
}


///////////////////////////////////////////////////////////////////////////////
int CertDbClaimFind( PLLS_CERT_DB_CERTIFICATE_HEADER pHeader, LPTSTR pszServerName )

/*++

Routine Description:

   Find a certificate claim for a specific server in the claim list.

Arguments:

   pHeader (PLLS_CERT_DB_CERTIFICATE_HEADER)
      Header containing the claim list to search.
   pszServerName (LPTSTR)
      Name of the server for which the claim is sought.

Return Value:

   The index of the found claim, or -1 if not found.

--*/

{
   // assumes db is already locked for shared or exclusive access

   int iClaim;

   for ( iClaim=0; (DWORD)iClaim < pHeader->NumClaims; iClaim++ )
   {
      if ( !lstrcmpi( pHeader->Claims[ iClaim ].ServerName, pszServerName ) )
      {
         break;
      }
   }

   if ( (DWORD)iClaim >= pHeader->NumClaims )
   {
      iClaim = -1;
   }

   return iClaim;
}


///////////////////////////////////////////////////////////////////////////////
void CertDbPrune()

/*++

Routine Description:

   Remove entries in the database which have expired.  Entries expire if they
   have not been re-replicated in LLS_CERT_DB_REPLICATION_DATE_DELTA_MAX
   seconds (3 days as of this writing).

Arguments:

   None.

Return Value:

   None.

--*/

{
   int      iHeader;
   int      iClaim;
   DWORD    CurrentDate;
   DWORD    MinimumDate;
   TCHAR    szComputerName[ 1 + MAX_COMPUTERNAME_LENGTH ] = TEXT("");
   DWORD    cchComputerName = sizeof( szComputerName ) / sizeof( *szComputerName );
   BOOL     ok;

   ok = GetComputerName( szComputerName, &cchComputerName );
   ASSERT( ok );

   if ( ok )
   {
      RtlAcquireResourceExclusive( &CertDbHeaderListLock, TRUE );

      CurrentDate = DateSystemGet();
      MinimumDate = CurrentDate - LLS_CERT_DB_REPLICATION_DATE_DELTA_MAX;

      for ( iHeader=0; (DWORD)iHeader < CertDbHeaderListSize; iHeader++ )
      {
         for ( iClaim=0; (DWORD)iClaim < CertDbHeaderList[ iHeader ].NumClaims; )
         {
            // Note that we prune entries made in the future, too, to avoid having an incorrect date
            // forcing us to keep an entry forever.
            //
            // For this application, it's better to keep fewer entries rather than more, as the
            // fewer entries we have, the less restrictive the system is.
            //
            // Don't prune local entries.

            if (    (    ( CertDbHeaderList[ iHeader ].Claims[ iClaim ].ReplicationDate < MinimumDate )
                      || ( CertDbHeaderList[ iHeader ].Claims[ iClaim ].ReplicationDate > CurrentDate ) )
                 && lstrcmpi( szComputerName, CertDbHeaderList[ iHeader ].Claims[ iClaim ].ServerName   ) )
            {
               // remove claim
               MoveMemory( &CertDbHeaderList[ iHeader ].Claims[ iClaim ],
                           &CertDbHeaderList[ iHeader ].Claims[ iClaim+1 ],
                           CertDbHeaderList[ iHeader ].NumClaims - ( iClaim + 1 ) );

               CertDbHeaderList[ iHeader ].NumClaims--;
            }
            else
            {
               // keep this claim
               iClaim++;
            }
         }
      }

      RtlReleaseResource( &CertDbHeaderListLock );
   }
}


///////////////////////////////////////////////////////////////////////////////
void CertDbRemoveLocalClaims()

/*++

Routine Description:

   Remove entries in the database corresponding to the local server.

Arguments:

   None.

Return Value:

   None.

--*/

{
   int      iHeader;
   int      iClaim;
   TCHAR    szComputerName[ 1 + MAX_COMPUTERNAME_LENGTH ] = TEXT("");
   DWORD    cchComputerName = sizeof( szComputerName ) / sizeof( *szComputerName );
   BOOL     ok;

   ok = GetComputerName( szComputerName, &cchComputerName );
   ASSERT( ok );

   if ( ok )
   {
      RtlAcquireResourceExclusive( &CertDbHeaderListLock, TRUE );

      for ( iHeader=0; (DWORD)iHeader < CertDbHeaderListSize; iHeader++ )
      {
         for ( iClaim=0; (DWORD)iClaim < CertDbHeaderList[ iHeader ].NumClaims; )
         {
            if ( !lstrcmpi( szComputerName, CertDbHeaderList[ iHeader ].Claims[ iClaim ].ServerName ) )
            {
               // remove claim
               MoveMemory( &CertDbHeaderList[ iHeader ].Claims[ iClaim ],
                           &CertDbHeaderList[ iHeader ].Claims[ iClaim+1 ],
                           CertDbHeaderList[ iHeader ].NumClaims - ( iClaim + 1 ) );

               CertDbHeaderList[ iHeader ].NumClaims--;
            }
            else
            {
               // keep this claim
               iClaim++;
            }
         }
      }

      RtlReleaseResource( &CertDbHeaderListLock );
   }
}


///////////////////////////////////////////////////////////////////////////////
void CertDbLogViolations()

/*++

Routine Description:

   Log violations of certificate license agreements to the event log of the
   local server.

Arguments:

   None.

Return Value:

   None.

--*/

{
   int         iHeader;
   int         iClaim;
   HANDLE      hEventLog;
   DWORD       dwTotalQuantity;
   HINSTANCE   hDll;
   DWORD       cch;
   LPTSTR      pszViolationServerEntryFormat;
   LPTSTR      pszViolationFormat;
   LPTSTR      pszViolationServerEntryList;
   LPTSTR      pszNextViolationServerEntry;
   TCHAR       szNumLicenses[ 20 ];
   TCHAR       szMaxLicenses[ 20 ];
   TCHAR       szCertificateID[ 20 ];
   LPTSTR      apszSubstStrings[ 5 ];
   DWORD       cbViolationServerList;
   LPTSTR      pszViolationServerList;

   // get rid of out-dated entries
   CertDbPrune();

   hDll = LoadLibrary( TEXT( "LLSRPC.DLL" ) );
   ASSERT( NULL != hDll );

   if ( NULL != hDll )
   {
      // format for part of logged message that lists server and #licenses
      cch = FormatMessage(   FORMAT_MESSAGE_ALLOCATE_BUFFER
                           | FORMAT_MESSAGE_IGNORE_INSERTS
                           | FORMAT_MESSAGE_FROM_HMODULE,
                           hDll,
                           LLS_EVENT_CERT_VIOLATION_SERVER_ENTRY,
                           GetSystemDefaultLangID(),
                           (LPVOID) &pszViolationServerEntryFormat,
                           0,
                           NULL );

      if ( 0 != cch )
      {
         hEventLog = RegisterEventSource( NULL, TEXT("LicenseService") );

         if ( NULL != hEventLog )
         {
            RtlAcquireResourceShared( &CertDbHeaderListLock, TRUE );

            for ( iHeader=0; (DWORD)iHeader < CertDbHeaderListSize; iHeader++ )
            {
               dwTotalQuantity = 0;

               // tally the number of licenses claimed against this certificate
               for ( iClaim=0; (DWORD)iClaim < CertDbHeaderList[ iHeader ].NumClaims; iClaim++ )
               {
                  if ( dwTotalQuantity + (DWORD)CertDbHeaderList[ iHeader ].Claims[ iClaim ].Quantity < dwTotalQuantity )
                  {
                     // overflow!
                     dwTotalQuantity = ULONG_MAX;
                     break;
                  }
                  else
                  {
                     // add to tally
                     dwTotalQuantity += CertDbHeaderList[ iHeader ].Claims[ iClaim ].Quantity;
                  }
               }

               if ( dwTotalQuantity > CertDbHeaderList[ iHeader ].MaxQuantity )
               {
                  // this certificate is in violation

                  // create message we're going to log
                  cbViolationServerList =   CertDbHeaderList[ iHeader ].NumClaims
                                          * sizeof( TCHAR )
                                          * (   lstrlen( pszViolationServerEntryFormat )
                                              + 20
                                              + MAX_COMPUTERNAME_LENGTH );
                  pszViolationServerList = LocalAlloc( LPTR, cbViolationServerList );
                  ASSERT( NULL != pszViolationServerList );

                  if ( NULL != pszViolationServerList )
                  {
                     // create an entry for each server in violation, stringing them
                     // together in pszViolationServerList
                     pszNextViolationServerEntry  = pszViolationServerList;

                     for ( iClaim=0; (DWORD)iClaim < CertDbHeaderList[ iHeader ].NumClaims; iClaim++ )
                     {
                        _ltow( CertDbHeaderList[ iHeader ].Claims[ iClaim ].Quantity, szNumLicenses, 10 );

                        apszSubstStrings[ 0 ] = CertDbHeaderList[ iHeader ].Claims[ iClaim ].ServerName;
                        apszSubstStrings[ 1 ] = szNumLicenses;

                        cch = FormatMessage(   FORMAT_MESSAGE_FROM_STRING
                                             | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                             pszViolationServerEntryFormat,
                                             (DWORD)0,
                                             (DWORD)0,
                                             pszNextViolationServerEntry,
                                             cbViolationServerList - (DWORD)( pszNextViolationServerEntry - pszViolationServerList ),
                                             (va_list *) apszSubstStrings );
                        ASSERT( 0 != cch );

                        pszNextViolationServerEntry += lstrlen( pszNextViolationServerEntry );
                     }

                     _ultow( CertDbHeaderList[ iHeader ].CertificateID, szCertificateID, 10 );
                     _ultow( dwTotalQuantity,                           szNumLicenses,   10 );
                     _ultow( CertDbHeaderList[ iHeader ].MaxQuantity,   szMaxLicenses,   10 );

                     apszSubstStrings[ 0 ] = CertDbHeaderList[ iHeader ].Product;
                     apszSubstStrings[ 1 ] = szCertificateID;
                     apszSubstStrings[ 2 ] = szNumLicenses;
                     apszSubstStrings[ 3 ] = szMaxLicenses;
                     apszSubstStrings[ 4 ] = pszViolationServerList;

                     // log the violation
                     if ( NULL != hEventLog )
                     {
                        ReportEvent( hEventLog,
                                     EVENTLOG_ERROR_TYPE,
                                     0,
                                     LLS_EVENT_CERT_VIOLATION,
                                     NULL,
                                     5,
                                     0,
                                     apszSubstStrings,
                                     NULL );
                     }

                     LocalFree( pszViolationServerList );
                  }
               }
            }

            RtlReleaseResource( &CertDbHeaderListLock );
            LocalFree( pszViolationServerEntryFormat );

            DeregisterEventSource( hEventLog );
         }
      }

      FreeLibrary( hDll );
   }
}


///////////////////////////////////////////////////////////////////////////////
NTSTATUS CertDbPack( LPDWORD                               pcchProductStrings,
                     LPTSTR *                              ppchProductStrings,
                     LPDWORD                               pdwNumHeaders,
                     PREPL_CERT_DB_CERTIFICATE_HEADER_0 *  ppHeaders,
                     LPDWORD                               pdwNumClaims,
                     PREPL_CERT_DB_CERTIFICATE_CLAIM_0 *   ppClaims )

/*++

Routine Description:

   Pack the certificate database into manageable chunks that can be saved or
   replicated.

Arguments:

   pcchProductStrings (LPDWORD)
      On return, holds the size (in characters) of the buffer pointed to by
      *ppchProductStrings.
   ppchProductStrings (LPTSTR *)
      On return, points to the buffer containing the product strings component
      of the database.
   pdwNumHeaders (LPDWORD)
      On return, holds the number of certificate headers in the array pointed
      to by *ppHeaders.
   ppHeaders (PREPL_CERT_DB_CERTIFICATE_HEADER_0 *)
      On return, holds a pointer to the certificate header array component of
      the database.
   pdwNumClaims (LPDWORD)
      On return, holds the number of certificate claims in the array pointed
      to by *ppHeaders.
   ppClaims (PREPL_CERT_DB_CERTIFICATE_CLAIM_0 *)
      On return, holds a pointer to the certificate claim array component of
      the database.

Return Value:

   STATUS_SUCCESS or STATUS_NO_MEMORY.

--*/

{
   NTSTATUS                            nt                   = STATUS_SUCCESS;

   DWORD                               cchProductStrings    = 0;
   LPTSTR                              pchProductStrings    = NULL;
   DWORD                               dwNumHeaders         = 0;
   PREPL_CERT_DB_CERTIFICATE_HEADER_0  pHeaders             = NULL;
   DWORD                               dwNumClaims          = 0;
   PREPL_CERT_DB_CERTIFICATE_CLAIM_0   pClaims              = NULL;

   LPTSTR                              pchNextProductString;
   int                                 iHeader;
   int                                 iClaim;

   CertDbPrune();
   CertDbUpdateLocalClaims();

   RtlAcquireResourceExclusive( &CertDbHeaderListLock, TRUE );

   if ( 0 != CertDbHeaderListSize )
   {
      // how big are all of our strings put together?
      // hom many certificate claims are there?
      for ( iHeader=0; (DWORD)iHeader < CertDbHeaderListSize; iHeader++ )
      {
         cchProductStrings += 1 + lstrlen( CertDbHeaderList[ iHeader ].Product );
         dwNumClaims += CertDbHeaderList[ iHeader ].NumClaims;
      }
      dwNumHeaders = CertDbHeaderListSize;

      pchProductStrings = LocalAlloc( LMEM_FIXED, cchProductStrings * sizeof( TCHAR ) );
      pHeaders          = LocalAlloc( LMEM_FIXED, dwNumHeaders * sizeof( REPL_CERT_DB_CERTIFICATE_HEADER_0 ) );
      pClaims           = LocalAlloc( LMEM_FIXED, dwNumClaims * sizeof( REPL_CERT_DB_CERTIFICATE_CLAIM_0 ) );

      if ( ( NULL == pchProductStrings ) || ( NULL == pHeaders ) || ( NULL == pClaims ) )
      {
         ASSERT( FALSE );
         nt = STATUS_NO_MEMORY;
      }
      else
      {
         // pack the product strings
         pchNextProductString = pchProductStrings;

         for ( iHeader=0; (DWORD)iHeader < CertDbHeaderListSize; iHeader++ )
         {
            lstrcpy( pchNextProductString, CertDbHeaderList[ iHeader ].Product );
            pchNextProductString += 1 + lstrlen( pchNextProductString );
         }

         // now pack away the rest of our structures
         iClaim = 0;
         for ( iHeader=0; (DWORD)iHeader < CertDbHeaderListSize; iHeader++ )
         {
            pHeaders[ iHeader ].CertificateID   = CertDbHeaderList[ iHeader ].CertificateID;
            pHeaders[ iHeader ].MaxQuantity     = CertDbHeaderList[ iHeader ].MaxQuantity;
            pHeaders[ iHeader ].ExpirationDate  = CertDbHeaderList[ iHeader ].ExpirationDate;
            pHeaders[ iHeader ].NumClaims       = CertDbHeaderList[ iHeader ].NumClaims;

            if ( CertDbHeaderList[ iHeader ].NumClaims )
            {
               memcpy( &pClaims[ iClaim ],
                       CertDbHeaderList[ iHeader ].Claims,
                       CertDbHeaderList[ iHeader ].NumClaims * sizeof( LLS_CERT_DB_CERTIFICATE_CLAIM ) );

               iClaim += CertDbHeaderList[ iHeader ].NumClaims;
            }
         }

         // all done!
         nt = STATUS_SUCCESS;
      }
   }

   if ( STATUS_SUCCESS == nt )
   {
      *pcchProductStrings  = cchProductStrings;
      *ppchProductStrings  = pchProductStrings;

      *pdwNumHeaders       = dwNumHeaders;
      *ppHeaders           = pHeaders;

      *pdwNumClaims        = dwNumClaims;
      *ppClaims            = pClaims;
   }
   else
   {
      if ( NULL != pchProductStrings   )  LocalFree( pchProductStrings  );
      if ( NULL != pHeaders            )  LocalFree( pHeaders           );
      if ( NULL != pClaims             )  LocalFree( pClaims            );
   }

   RtlReleaseResource( &CertDbHeaderListLock );

   return nt;
}


///////////////////////////////////////////////////////////////////////////////
NTSTATUS CertDbUnpack( DWORD                               cchProductStrings,
                       LPTSTR                              pchProductStrings,
                       DWORD                               dwNumHeaders,
                       PREPL_CERT_DB_CERTIFICATE_HEADER_0  pHeaders,
                       DWORD                               dwNumClaims,
                       PREPL_CERT_DB_CERTIFICATE_CLAIM_0   pClaims,
                       BOOL                                bReplicated )

/*++

Routine Description:

   Pack the certificate database into manageable chunks that can be saved or
   replicated.

Arguments:

   cchProductStrings (DWORD)
      The size (in characters) of the buffer pointed to by pchProductStrings.
   pchProductStrings (LPTSTR)
      The buffer containing the product strings component of the database.
   dwNumHeaders (DWORD)
      The number of certificate headers in the array pointed to by pHeaders.
   pHeaders (PREPL_CERT_DB_CERTIFICATE_HEADER_0)
      The certificate header array component of the database.
   dwNumClaims (DWORD)
      The number of certificate claims in the array pointed to by pHeaders.
   pClaims (PREPL_CERT_DB_CERTIFICATE_CLAIM_0)
      The certificate claim array component of the database.
   bReplicated (BOOL)
      Indicates whether this information was replicated.  This is used to
      determine the time at which this information will expire.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS                            nt                      = STATUS_SUCCESS;
   LPTSTR                              pchNextProductString;
   LPBYTE                              pb;
   int                                 iHeader;
   int                                 iClaim;
   int                                 iClaimBase;
   LLS_LICENSE_INFO_1                  lic;
   TCHAR                               szComputerName[ 1 + MAX_COMPUTERNAME_LENGTH ];
   DWORD                               cchComputerName = sizeof( szComputerName ) / sizeof( *szComputerName );
   BOOL                                ok;

   ok = GetComputerName( szComputerName, &cchComputerName );
   ASSERT( ok );

   if ( !ok )
   {
      // in this case, we'll just add in the local entries, too
      // under normal circumstances (i.e., as long as the cert db isn't corrupt),
      // this is harmless and is preferrable to failing to unpack
      *szComputerName = TEXT( '\0' );
   }

   RtlAcquireResourceExclusive( &CertDbHeaderListLock, TRUE );

   pchNextProductString = pchProductStrings;

   // these fields are irrelevant!
   lic.Date         = 0;
   lic.Admin        = NULL;
   lic.Comment      = NULL;
   lic.Vendor       = NULL;
   lic.Source       = NULL;
   lic.AllowedModes = 0;

   iClaimBase = 0;
   for ( iHeader=0; (DWORD)iHeader < dwNumHeaders; iHeader++ )
   {
      if ( 0 != pHeaders[ iHeader ].NumClaims )
      {
         // certificate-specific fields
         lic.Product          = pchNextProductString;
         lic.CertificateID    = pHeaders[ iHeader ].CertificateID;
         lic.MaxQuantity      = pHeaders[ iHeader ].MaxQuantity;
         lic.ExpirationDate   = pHeaders[ iHeader ].ExpirationDate;

         for ( iClaim=0; (DWORD)iClaim < pHeaders[ iHeader ].NumClaims; iClaim++ )
         {
            if ( lstrcmpi( szComputerName, pClaims[ iClaimBase + iClaim ].ServerName ) )
            {
               // not the local server

               // claim-specific field
               lic.Quantity = pClaims[ iClaimBase + iClaim ].Quantity;

               nt = CertDbClaimEnter( pClaims[ iClaimBase + iClaim ].ServerName, &lic, TRUE, bReplicated ? 0 : pClaims[ iClaimBase + iClaim ].ReplicationDate );
               ASSERT( STATUS_SUCCESS == nt );

               // even if we encounter an error, go ahead and unpack the rest of the records
            }
         }

         iClaimBase += pHeaders[ iHeader ].NumClaims;
      }

      pchNextProductString += 1 + lstrlen( pchNextProductString );
   }

   RtlReleaseResource( &CertDbHeaderListLock );

   return nt;
}


///////////////////////////////////////////////////////////////////////////////
NTSTATUS CertDbSave()

/*++

Routine Description:

   Save the certificate database.

Arguments:

   None.

Return Value:

   STATUS_SUCCESS, Windows error, or NTSTATUS error code.

--*/

{
   NTSTATUS                            nt;
   LLS_CERT_DB_FILE_HEADER             FileHeader;
   DWORD                               cchProductStrings    = 0;
   LPTSTR                              pchProductStrings    = NULL;
   DWORD                               dwNumHeaders         = 0;
   PREPL_CERT_DB_CERTIFICATE_HEADER_0  pHeaders             = NULL;
   DWORD                               dwNumClaims          = 0;
   PREPL_CERT_DB_CERTIFICATE_CLAIM_0   pClaims              = NULL;
   DWORD                               dwBytesWritten;
   BOOL                                ok;

   nt = CertDbPack( &cchProductStrings, &pchProductStrings, &dwNumHeaders, &pHeaders, &dwNumClaims, &pClaims );

   if ( STATUS_SUCCESS == nt )
   {
      if ( dwNumHeaders )
      {
         nt = EBlock( pchProductStrings, cchProductStrings * sizeof( TCHAR ) );

         if ( STATUS_SUCCESS == nt )
         {
            nt = EBlock( pHeaders, sizeof( REPL_CERT_DB_CERTIFICATE_HEADER_0 ) * dwNumHeaders );

            if ( STATUS_SUCCESS == nt )
            {
               nt = EBlock( pClaims, sizeof( REPL_CERT_DB_CERTIFICATE_CLAIM_0 ) * dwNumClaims );

               if ( STATUS_SUCCESS == nt )
               {
                  if ( NULL != CertDbFile )
                  {
                     CloseHandle( CertDbFile );
                  }

                  CertDbFile = LlsFileInit( CertDbFileName, LLS_CERT_DB_FILE_VERSION, sizeof( LLS_CERT_DB_FILE_HEADER ) );

                  if ( NULL == CertDbFile )
                  {
                     nt = GetLastError();
                  }
                  else
                  {
                     FileHeader.NumCertificates    = dwNumHeaders;
                     FileHeader.ProductStringSize  = cchProductStrings;
                     FileHeader.NumClaims          = dwNumClaims;

                     ok = WriteFile( CertDbFile, &FileHeader, sizeof( FileHeader ), &dwBytesWritten, NULL );

                     if ( ok )
                     {
                        ok = WriteFile( CertDbFile, pchProductStrings, FileHeader.ProductStringSize * sizeof( TCHAR ), &dwBytesWritten, NULL );

                        if ( ok )
                        {
                           ok = WriteFile( CertDbFile, pHeaders, sizeof( REPL_CERT_DB_CERTIFICATE_HEADER_0 ) * FileHeader.NumCertificates, &dwBytesWritten, NULL );

                           if ( ok )
                           {
                              ok = WriteFile( CertDbFile, pClaims, sizeof( REPL_CERT_DB_CERTIFICATE_CLAIM_0 ) * FileHeader.NumClaims, &dwBytesWritten, NULL );
                           }
                        }
                     }

                     if ( !ok )
                     {
                        nt = GetLastError();
                     }
                  }
               }
            }
         }

         LocalFree( pchProductStrings  );
         LocalFree( pHeaders           );
         LocalFree( pClaims            );
      }
   }

   if ( STATUS_SUCCESS != nt )
   {
      LogEvent( LLS_EVENT_SAVE_CERT_DB, 0, NULL, nt );
   }

   return nt;
}


///////////////////////////////////////////////////////////////////////////////
NTSTATUS CertDbLoad()

/*++

Routine Description:

   Load the certificate database.

Arguments:

   None.

Return Value:

   STATUS_SUCCESS, Windows error, or NTSTATUS error code.

--*/

{
   NTSTATUS                            nt                   = STATUS_SUCCESS;
   DWORD                               dwVersion;
   DWORD                               dwDataSize;
   LLS_CERT_DB_FILE_HEADER             FileHeader;
   LPTSTR                              pchProductStrings    = NULL;
   PREPL_CERT_DB_CERTIFICATE_HEADER_0  pHeaders             = NULL;
   PREPL_CERT_DB_CERTIFICATE_CLAIM_0   pClaims              = NULL;
   DWORD                               dwBytesRead;
   BOOL                                ok;

   if ( NULL != CertDbFile )
   {
      CloseHandle( CertDbFile );
      CertDbFile = NULL;
   }

   if ( FileExists( CertDbFileName ) )
   {
      CertDbFile = LlsFileCheck( CertDbFileName, &dwVersion, &dwDataSize );

      if ( NULL == CertDbFile )
      {
         nt = GetLastError();
      }
      else if (    ( LLS_CERT_DB_FILE_VERSION != dwVersion )
                || ( sizeof( FileHeader ) != dwDataSize ) )
      {
         nt = STATUS_FILE_INVALID;
      }
      else
      {
         ok = ReadFile( CertDbFile, &FileHeader, sizeof( FileHeader ), &dwBytesRead, NULL );

         if ( !ok )
         {
            nt = GetLastError();
         }
         else if ( FileHeader.NumCertificates )
         {
            pchProductStrings = LocalAlloc( LMEM_FIXED, sizeof( TCHAR ) * FileHeader.ProductStringSize );
            pHeaders          = LocalAlloc( LMEM_FIXED, sizeof( REPL_CERT_DB_CERTIFICATE_HEADER_0 ) * FileHeader.NumCertificates );
            pClaims           = LocalAlloc( LMEM_FIXED, sizeof( REPL_CERT_DB_CERTIFICATE_CLAIM_0  ) * FileHeader.NumClaims );

            if ( ( NULL == pchProductStrings ) || ( NULL == pHeaders ) || ( NULL == pClaims ) )
            {
               ASSERT( FALSE );
               nt = STATUS_NO_MEMORY;
            }
            else
            {
               ok = ReadFile( CertDbFile, pchProductStrings, FileHeader.ProductStringSize * sizeof( TCHAR ), &dwBytesRead, NULL );

               if ( ok )
               {
                  ok = ReadFile( CertDbFile, pHeaders, sizeof( REPL_CERT_DB_CERTIFICATE_HEADER_0 ) * FileHeader.NumCertificates, &dwBytesRead, NULL );

                  if ( ok )
                  {
                     ok = ReadFile( CertDbFile, pClaims, sizeof( REPL_CERT_DB_CERTIFICATE_CLAIM_0 ) * FileHeader.NumClaims, &dwBytesRead, NULL );
                  }
               }

               if ( !ok )
               {
                  nt = GetLastError();
               }
               else
               {
                  nt = DeBlock( pchProductStrings, sizeof( TCHAR ) * FileHeader.ProductStringSize );

                  if ( STATUS_SUCCESS == nt )
                  {
                     nt = DeBlock( pHeaders, sizeof( REPL_CERT_DB_CERTIFICATE_HEADER_0 ) * FileHeader.NumCertificates );

                     if ( STATUS_SUCCESS == nt )
                     {
                        nt = DeBlock( pClaims, sizeof( REPL_CERT_DB_CERTIFICATE_CLAIM_0 ) * FileHeader.NumClaims );

                        if ( STATUS_SUCCESS == nt )
                        {
                           nt = CertDbUnpack( FileHeader.ProductStringSize,
                                              pchProductStrings,
                                              FileHeader.NumCertificates,
                                              pHeaders,
                                              FileHeader.NumClaims,
                                              pClaims,
                                              FALSE );
                        }
                     }
                  }
               }
            }
         }
      }
   }

   if ( NULL != pchProductStrings   )  LocalFree( pchProductStrings  );
   if ( NULL != pHeaders            )  LocalFree( pHeaders           );
   if ( NULL != pClaims             )  LocalFree( pClaims            );

   if ( STATUS_SUCCESS != nt )
   {
      LogEvent( LLS_EVENT_LOAD_CERT_DB, 0, NULL, nt );
   }
   else
   {
      CertDbPrune();
   }

   return nt;
}


///////////////////////////////////////////////////////////////////////////////
NTSTATUS CertDbInit()

/*++

Routine Description:

   Initialize the certificate database.

Arguments:

   None.

Return Value:

   STATUS_SUCCESS.

--*/

{
   CertDbFile           = NULL;

   try
   {
       RtlInitializeResource( &CertDbHeaderListLock );
   } except(EXCEPTION_EXECUTE_HANDLER ) {
        return GetExceptionCode();
   }

   return STATUS_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
void CertDbUpdateLocalClaims()

/*++

Routine Description:

   Synchronize the certificate database with the purchase history.

Arguments:

   None.

Return Value:

   None.

--*/

{
   DWORD                      dwPurchaseNdx;
   LLS_LICENSE_INFO_1         lic;
   PLICENSE_PURCHASE_RECORD   pPurchase;

   RtlAcquireResourceExclusive( &LicenseListLock,      TRUE );
   RtlAcquireResourceExclusive( &CertDbHeaderListLock, TRUE );

   // first dump all current entries for the local server
   CertDbRemoveLocalClaims();

   // these fields are irrelevant!
   lic.Date         = 0;
   lic.Admin        = NULL;
   lic.Comment      = NULL;
   lic.Source       = NULL;
   lic.Vendor       = NULL;
   lic.AllowedModes = 0;

   // add in all secure purchases
   for ( dwPurchaseNdx = 0; dwPurchaseNdx < PurchaseListSize; dwPurchaseNdx++ )
   {
      pPurchase = &PurchaseList[ dwPurchaseNdx ];

      if ( 0 != pPurchase->CertificateID )
      {
         lic.Product          =   ( pPurchase->AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT )
                                ? pPurchase->Service->ServiceName
                                : pPurchase->PerServerService->ServiceName;

         lic.CertificateID    = pPurchase->CertificateID;
         lic.MaxQuantity      = pPurchase->MaxQuantity;
         lic.ExpirationDate   = pPurchase->ExpirationDate;
         lic.Quantity         = pPurchase->NumberLicenses;

         CertDbClaimEnter( NULL, &lic, FALSE, 0 );
      }
   }

   RtlReleaseResource( &CertDbHeaderListLock );
   RtlReleaseResource( &LicenseListLock      );
}


///////////////////////////////////////////////////////////////////////////////
NTSTATUS CertDbClaimsGet( PLLS_LICENSE_INFO_1               pLicense,
                          LPDWORD                           pdwNumClaims,
                          PLLS_CERTIFICATE_CLAIM_INFO_0 *   ppTargets )

/*++

Routine Description:

   Retrieve a list of all servers with licenses installed from a given
   certificate and the number of licenses installed on each.

Arguments:

   pLicense (PLLS_LICENSE_INFO_1)
      License describing the certificate for which the claims are sought.
   pdwNumClaims (LPDWORD)
      On return, holds the number of claims in the array pointed to by
      *ppTargets.
   ppTargets (PLLS_CERTIFICATE_CLAIM_INFO_0 *)
      On return, holds an array describing all claims made on this
      certificate.

Return Value:

   STATUS_SUCCESS
   STATUS_NOT_FOUND
   STATUS_NO_MEMORY

--*/

{
   NTSTATUS                         nt;
   PLLS_CERT_DB_CERTIFICATE_HEADER  pHeader;
   int                              iClaim;

   // is the certificate in the db?
   pHeader = CertDbHeaderFind( pLicense );

   if ( NULL == pHeader )
   {
      // not here!
      nt = STATUS_NOT_FOUND;
   }
   else
   {
      *ppTargets = MIDL_user_allocate( pHeader->NumClaims * sizeof( LLS_CERTIFICATE_CLAIM_INFO_0 ) );

      if ( NULL == *ppTargets )
      {
         nt = STATUS_NO_MEMORY;
      }
      else
      {
         *pdwNumClaims = pHeader->NumClaims;

         for ( iClaim=0; (DWORD)iClaim < pHeader->NumClaims; iClaim++ )
         {
            lstrcpy( (*ppTargets)[ iClaim ].ServerName, pHeader->Claims[ iClaim ].ServerName );
            (*ppTargets)[ iClaim ].Quantity = pHeader->Claims[ iClaim ].Quantity;
         }

         nt = STATUS_SUCCESS;
      }
   }

   return nt;
}


#if DBG
/////////////////////////////////////////////////////////////////////////
void CertDbDebugDump()

/*++

Routine Description:

   Dump contents of certificate database to debug console.

Arguments:

   None.

Return Value:

   None.

--*/

{
   int            iHeader;
   int            iClaim;

   RtlAcquireResourceShared( &CertDbHeaderListLock, TRUE );

   for ( iHeader=0; (DWORD)iHeader < CertDbHeaderListSize; iHeader++ )
   {
      dprintf( TEXT("\n(%3d)  Product        : %s\n"), iHeader, CertDbHeaderList[ iHeader ].Product );
      dprintf( TEXT("       CertificateID  : %d\n"), CertDbHeaderList[ iHeader ].CertificateID );
      dprintf( TEXT("       MaxQuantity    : %d\n"), CertDbHeaderList[ iHeader ].MaxQuantity );
      dprintf( TEXT("       ExpirationDate : %s\n"), TimeToString( CertDbHeaderList[ iHeader ].ExpirationDate ) );

      for ( iClaim=0; (DWORD)iClaim < CertDbHeaderList[ iHeader ].NumClaims; iClaim++ )
      {
         dprintf( TEXT("\n       (%3d)  ServerName      : %s\n"), iClaim, CertDbHeaderList[ iHeader ].Claims[ iClaim ].ServerName );
         dprintf( TEXT("              ReplicationDate : %s\n"), TimeToString( CertDbHeaderList[ iHeader ].Claims[ iClaim ].ReplicationDate ) );
         dprintf( TEXT("              Quantity        : %d\n"), CertDbHeaderList[ iHeader ].Claims[ iClaim ].Quantity );
      }
   }

   RtlReleaseResource( &CertDbHeaderListLock );

} // CertDbDebugDump

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\llsdbg_s_stub.c ===
#include "llsdbg_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ntlsapi\rpcstub.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rpcstub.c

Abstract:

    License Logging Service client stubs.

Author:

    Arthur Hanson   (arth) 06-Dec-1994

Environment:   User mode only.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <string.h>
#include <zwapi.h>
#include <llsconst.h>

#include <debug.h>
#include "lsapi_c.h"


// #define API_TRACE 1

BOOLEAN LLSUp = FALSE;

#define MAX_EXPECTED_SID_LENGTH 72

LPTSTR pszStringBinding = NULL;
RTL_CRITICAL_SECTION LPCInitLock;

static HANDLE LpcPortHandle = NULL;


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LLSReInitLPC( )

/*++

Routine Description:

    This service connects to the LLS server and initializes the LPC port.

Arguments:

Return Value:

    STATUS_SUCCESS - The call completed successfully.

--*/

{
   RPC_STATUS Status = STATUS_SUCCESS;
   LPTSTR pszUuid = NULL;
   LPTSTR pszProtocolSequence = NULL;
   LPTSTR pszNetworkAddress = NULL;
   LPTSTR pszEndpoint = NULL;
   LPTSTR pszOptions = NULL;

   pszProtocolSequence = TEXT("ncalrpc");
   pszEndpoint = TEXT(LLS_LPC_ENDPOINT);
   pszNetworkAddress = NULL;

   if (LLSUp) {
      LLSUp = FALSE;

      if (pszStringBinding != NULL) {
         Status = RpcStringFree(&pszStringBinding);
         pszStringBinding = NULL;
      }

      if (Status == STATUS_SUCCESS) {

         if (lsapirpc_handle != NULL) {
            Status = RpcBindingFree(&lsapirpc_handle);
         }

         lsapirpc_handle = NULL;
      }

   }

   try {
      // Compose a string binding
      Status = RpcStringBindingComposeW(pszUuid,
                                        pszProtocolSequence,
                                        pszNetworkAddress,
                                        pszEndpoint,
                                        pszOptions,
                                        &pszStringBinding);
   }
   except (TRUE) {
      Status = RpcExceptionCode();
   }

   if(Status) {
#if DBG
      dprintf(TEXT("NTLSAPI RpcStringBindingComposeW Failed: 0x%lX\n"), Status);
#endif
      if (pszStringBinding != NULL) {
         RpcStringFree(&pszStringBinding);
         pszStringBinding = NULL;
      }
      return I_RpcMapWin32Status(Status);
   }

   // Bind using the created string binding...
   try {
      Status = RpcBindingFromStringBindingW(pszStringBinding, &lsapirpc_handle);
   }
   except (TRUE) {
      Status = RpcExceptionCode();
   }

   if(Status) {
#if DBG
      dprintf(TEXT("NTLSAPI RpcBindingFromStringBindingW Failed: 0x%lX\n"), Status);
#endif
  //    lsapirpc_handle = NULL;

      if (pszStringBinding != NULL) {
         RpcStringFree(&pszStringBinding);
         pszStringBinding = NULL;
      }      

      return I_RpcMapWin32Status(Status);
   }

   LLSUp = TRUE;

   return I_RpcMapWin32Status(Status);

} // LLSReInitLPC


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LLSInitLPC( )

/*++

Routine Description:

    This service connects to the LLS server and initializes the LPC port.

Arguments:

Return Value:

    STATUS_SUCCESS - The call completed successfully.

--*/

{
   NTSTATUS status;

   status = RtlInitializeCriticalSection(&LPCInitLock);

   lsapirpc_handle = NULL;

   return status;

} // LLSInitLPC


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LLSCloseLPC( )

/*++

Routine Description:

    This closes the LPC port connection to the service.

Arguments:

Return Value:

    STATUS_SUCCESS - The call completed successfully.

--*/

{
   RPC_STATUS Status = STATUS_SUCCESS, Status2 = STATUS_SUCCESS;

   RtlEnterCriticalSection(&LPCInitLock);
   LLSUp = FALSE;

   if (pszStringBinding != NULL) {
      Status = RpcStringFree(&pszStringBinding);
      pszStringBinding = NULL;
   }

   if (lsapirpc_handle != NULL) {
      Status2 = RpcBindingFree(&lsapirpc_handle);
   }

   if (Status == STATUS_SUCCESS)
      Status = Status2;

   lsapirpc_handle = NULL;

   RtlLeaveCriticalSection(&LPCInitLock);
   return Status;

} // LLSCloseLPC


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LLSLicenseRequest2 (
    IN LPWSTR ProductName,
    IN LPWSTR Version,
    IN ULONG DataType,
    IN BOOLEAN IsAdmin,
    IN PVOID Data,
    OUT PHANDLE LicenseHandle
    )

/*++

Arguments:

    ProductName -

    Version -

    DataType -

    IsAdmin -

    Data -

    LicenseHandle -

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.


Routine Description:


--*/

{
    WCHAR ProductID[MAX_PRODUCT_NAME_LENGTH + MAX_VERSION_LENGTH + 2];
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL Close = FALSE;
    ULONG VersionIndex;
    ULONG Size = 0;
    ULONG i;
    LICENSE_HANDLE RpcLicenseHandle;

    BOOL bActuallyConnect = TRUE;

    //
    // Get this out of the way in-case anything goes wrong
    //
    *LicenseHandle = NULL;

    // 
    // If LicenseService isn't running (no LPC port) then just return
    // dummy info - and let the user on.
    //
    RtlEnterCriticalSection(&LPCInitLock);
    if (!LLSUp)
       Status = LLSReInitLPC();
    RtlLeaveCriticalSection(&LPCInitLock);

    if (!NT_SUCCESS(Status))
       return STATUS_SUCCESS;

    if (((i = lstrlen(ProductName)) > MAX_PRODUCT_NAME_LENGTH) || (lstrlen(Version) > MAX_VERSION_LENGTH))
       return STATUS_SUCCESS;

    //
    // Create productID - product name + version string.
    //
    lstrcpy(ProductID, ProductName);
    lstrcat(ProductID, TEXT(" "));
    lstrcat(ProductID, Version);

    VersionIndex = i;

    //
    // Based on DataType figure out if we are doing a name or a SID
    // and copy the data appropriatly
    //
    if (DataType == NT_LS_USER_NAME) {
       Size = lstrlen((LPWSTR) Data);
       if (Size > MAX_USER_NAME_LENGTH)
          return STATUS_SUCCESS;

       Size = (Size + 1) * sizeof(TCHAR);
    }

    if (DataType == NT_LS_USER_SID) {
       //
       // Friggin SID, so need to copy it manually.
       // WARNING:  This makes it dependent on the structure of the 
       // SID!!!
       //
       Size = RtlLengthSid( (PSID) Data);

       if (Size > MAX_EXPECTED_SID_LENGTH)
          return STATUS_SUCCESS;
    }

    //
    // Call the Server.
    //
    try {
       Status = LlsrLicenseRequestW(
                   &RpcLicenseHandle,
                   ProductID,
                   VersionIndex,
                   IsAdmin,
                   DataType,
                   Size,
                   (PBYTE) Data );
    }
    except (TRUE) {
#if DBG
       Status = I_RpcMapWin32Status(RpcExceptionCode());
       if (Status != RPC_NT_SERVER_UNAVAILABLE) {
          dprintf(TEXT("ERROR NTLSAPI.DLL: RPC Exception: 0x%lX\n"), Status);
//          ASSERT(FALSE);
       }
#endif
       *LicenseHandle = NULL;         

       Status = STATUS_SUCCESS;

       bActuallyConnect = FALSE;
    }

    if (Close)
       LLSCloseLPC();

    // This is really a ULONG, we just treated it as a PVOID so
    // RPC would treat is as a context handle

    if(bActuallyConnect == TRUE)
        *LicenseHandle = RpcLicenseHandle;

    return Status;

} // LLSLicenseRequest


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LLSLicenseRequest (
    IN LPWSTR ProductName,
    IN LPWSTR Version,
    IN ULONG DataType,
    IN BOOLEAN IsAdmin,
    IN PVOID Data,
    OUT PULONG LicenseHandle
    )

/*++

Arguments:

    ProductName -

    Version -

    DataType -

    IsAdmin -

    Data -

    LicenseHandle -

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.


Routine Description:


--*/
{
    HANDLE RealLicenseHandle;
    NTSTATUS status;

    if (sizeof(ULONG) == sizeof(HANDLE))
    {
        // Should still work on Win32

        status = LLSLicenseRequest2(ProductName,Version,DataType,IsAdmin,Data,&RealLicenseHandle);

        if (NULL != LicenseHandle)
            *LicenseHandle = PtrToUlong(RealLicenseHandle);
    }
    else
    {
        status = STATUS_NOT_IMPLEMENTED;

        if (NULL != LicenseHandle)
            *LicenseHandle = (ULONG) 0xFFFFFFFF;
    }

    return status;
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS
LLSLicenseFree2 (
    IN HANDLE LicenseHandle
    )

/*++

Arguments:

    LicenseHandle - 

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/

{
    BOOL Close = FALSE;
    NTSTATUS Status;
    LICENSE_HANDLE RpcLicenseHandle = (LICENSE_HANDLE) LicenseHandle;

    // 
    // If LicenseService isn't running (no LPC port) then just return
    // dummy info - and let the user on.
    //
    if (!LLSUp)
    {
           return STATUS_SUCCESS;
    }

    //
    // Call the Server.
    //
    try {
       Status = LlsrLicenseFree( &RpcLicenseHandle );
    }
    except (TRUE) {
#if DBG
       Status = I_RpcMapWin32Status(RpcExceptionCode());
       if (Status != RPC_NT_SERVER_UNAVAILABLE) {
          dprintf(TEXT("ERROR NTLSAPI.DLL: RPC Exception: 0x%lX\n"), Status);
//          ASSERT(FALSE);
       }
#endif
       Status = STATUS_SUCCESS;
    }

    if (Close)
       LLSCloseLPC();

    return Status;
} // LLSLicenseFree

/////////////////////////////////////////////////////////////////////////
NTSTATUS
LLSLicenseFree (
    IN ULONG LicenseHandle
    )

/*++

Arguments:

    LicenseHandle - 

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/
{
    if (sizeof(ULONG) == sizeof(HANDLE))
    {
        // Should still work on Win32
        return LLSLicenseFree2(ULongToPtr(LicenseHandle));
    }
    else
    {
        return STATUS_NOT_IMPLEMENTED;
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\llsrpc_s_stub.c ===
#include "llsrpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\ntlsapi\ntlsapi.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    lsapi.c

Created:

    20-Apr-1994

Revision History:

    01-Nov-1994   arth     Changed from LS API set to simpler request only
                           API.
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntlsapi.h>
#include <llsconst.h>
#include <debug.h>
#include <stdlib.h>

#include <lpcstub.h>

// #define API_TRACE 1
// #define TIME_TRACE 1
// #define LOG_LICENSE_TRAFFIC

#ifdef TIME_TRACE
   DWORD TimeDelta;
#endif


//
// SID is linear in memory (check if this is safe assumption).  Can use
// RtlCopySID then pass linear buffer - use RtlLengthSid for size.
//

/*++
     NtLicenseRequest()
       Request licensing resources needed to allow software to be
       used.

      Format

       Status = NtLicenseRequest(
                    [in] LS_STR *ProductName,
                    [in] LS_STR *Version,
                    [in] NT_LS_DATA *NtData)
                    );

      Arguments

       ProductName The name of the product requesting licensing
                    resources.  This string may not be null and must
                    be unique (in the first 32 characters) within the
                    PublisherName domain.

       Version     The version number of this product. This string
                    must be unique (in the first 12 characters) within
                    the ProductName domain, and cannot be NULL

       NtData      The username and/or SID identifying the person using the
                   license.

                    NOTE: The arguments ProductName, and Version may not be
                          NULL.


      Description

       This function is used by the application to request licensing
       resources to allow the identified product to execute. If a
       valid license is found, the challenge response is computed and
       LS_SUCCESS is returned.

--*/

LS_STATUS_CODE LS_API_ENTRY NtLicenseRequestA(
                  LPSTR       ProductName,
                  LPSTR       Version,
                  LS_HANDLE   FAR *LicenseHandle,
                  NT_LS_DATA  *NtData)
{
   WCHAR uProductName[MAX_PRODUCT_NAME_LENGTH + 1];
   WCHAR uVersion[MAX_VERSION_LENGTH + 1];
   WCHAR uUserName[MAX_USER_NAME_LENGTH + 1];
   void *tmpData = NULL;
   LS_STATUS_CODE ret = LS_SUCCESS;

#ifdef API_TRACE
   dprintf(TEXT("NtLicenseRequestA!!!\r\n"));

#endif

   // Convert parms to Unicode and call Unicode function

   // First make sure we have correct data
   if ( (ProductName != NULL) && (Version != NULL) && (NtData != NULL) && (NtData->Data != NULL)) {
      if (lstrlenA(ProductName) > MAX_PRODUCT_NAME_LENGTH) {
#ifdef API_TRACE
         dprintf(TEXT("   Error: ProductName too long\r\n"));
#endif
         lstrcpy(uProductName, TEXT(""));
      } else
         MultiByteToWideChar(CP_ACP, 0, ProductName, -1, uProductName, MAX_PRODUCT_NAME_LENGTH + 1);

      if (lstrlenA(Version) > MAX_VERSION_LENGTH) {
#ifdef API_TRACE
         dprintf(TEXT("   Error: Version too long\r\n"));
#endif
         lstrcpy(uVersion, TEXT(""));
      } else
         MultiByteToWideChar(CP_ACP, 0, Version, -1, uVersion, MAX_VERSION_LENGTH + 1);

      if (NtData->DataType == NT_LS_USER_NAME) {
         if (lstrlenA((LPSTR) NtData->Data) > MAX_USER_NAME_LENGTH) {
#ifdef API_TRACE
         dprintf(TEXT("   Error: UserName too long\r\n"));
#endif
            lstrcpy(uUserName, TEXT(""));
         } else
            MultiByteToWideChar(CP_ACP, 0, NtData->Data, -1, uUserName, MAX_USER_NAME_LENGTH + 1);

         // Have UserName convert to wide char format, but need to point
         // Data structure to it...
         tmpData = (void *) NtData->Data;
         NtData->Data = (void *) uUserName;
         ret = NtLicenseRequestW(uProductName, uVersion, LicenseHandle, NtData);

         // Nothing needs to be converted back to ANSI on return, just return
         // data structure to the way it was
         NtData->Data = tmpData;
         return ret;
      } else {
         // Gave SID so no Unicode conversion needed on name
         ret = NtLicenseRequestW(uProductName, uVersion, LicenseHandle, NtData);
         return ret;
      }

   }
#ifdef API_TRACE
   else
      dprintf(TEXT("   LLS Error: <NULL> Parms passed in!\r\n"));
#endif

   // If NULL parms or such then just return a dummy handle for right now
   if ( LicenseHandle != NULL )
      *LicenseHandle = -1;

   return(LS_SUCCESS);
} // NtLicenseRequestA


LS_STATUS_CODE LS_API_ENTRY NtLicenseRequestW(
                  LPWSTR      ProductName,
                  LPWSTR      Version,
                  LS_HANDLE   FAR *LicenseHandle,
                  NT_LS_DATA  *NtData)
{
   LPWSTR dVersion = Version;
   LS_STATUS_CODE Status;
#ifdef API_TRACE
   UNICODE_STRING UString;
   NTSTATUS NtStatus;
#endif

   //
   // Check parms before calling down
   //
   if ((ProductName == NULL) || (NtData == NULL) || (NtData->DataType > NT_LS_USER_SID)) {

#ifdef API_TRACE
      dprintf(TEXT("NtLicenseRequestW: <Bad Parms>\r\n"));
#endif

      if (LicenseHandle != NULL)
         *LicenseHandle = 0xFFFFFFFFL;

      return(LS_SUCCESS);
   }

   //
   // LsaLogonUser passes in NULL version because it doesn't know what version
   // the calling app is.  So just use a blank field for this.  There must
   // be something in the version field or it messes up the lower level
   // algorithms, so just enter a blank.
   //
   if ((Version == NULL) || (*Version == TEXT('\0')))
      dVersion = TEXT("");

#ifdef API_TRACE
   if (NtData->DataType == NT_LS_USER_SID) {
      NtStatus = RtlConvertSidToUnicodeString(&UString, (PSID) NtData->Data, TRUE);

      if (NtStatus != STATUS_SUCCESS)
         dprintf(TEXT("NtLicenseRequestW RtlConvertSidToUnicodeString: 0x%lx\n"), NtStatus);
      else {
         if (NtData->IsAdmin)
            dprintf(TEXT("NtLicenseRequestW: %s, %s, <ADMIN>, SID: %s\n"), ProductName, dVersion, UString.Buffer);
         else
            dprintf(TEXT("NtLicenseRequestW: %s, %s, SID: %s\n"), ProductName, dVersion, UString.Buffer);

         RtlFreeUnicodeString(&UString);
      }
   } else {

      if (NtData->IsAdmin)
         dprintf(TEXT("NtLicenseRequestW: %s, %s, <ADMIN>, %s\n"), ProductName, dVersion, NtData->Data);
      else
         dprintf(TEXT("NtLicenseRequestW: %s, %s, %s\n"), ProductName, dVersion, NtData->Data);

   }

#endif

#ifdef TIME_TRACE
   TimeDelta = GetTickCount();
#endif

   // make the LPC call and marshal the parms.
   Status = (LS_STATUS_CODE) LLSLicenseRequest2( ProductName,
                                                dVersion,
                                                NtData->DataType,
                                                (BOOLEAN) NtData->IsAdmin,
                                                NtData->Data,
                                                LicenseHandle
                                               );

#ifdef TIME_TRACE
   TimeDelta = GetTickCount() - TimeDelta;
   dprintf(TEXT("NtLicenseRequest LPC Call Time: %ldms\n"), TimeDelta);
#endif

#ifdef LOG_LICENSE_TRAFFIC
{
   HANDLE   LogHandle;
   LPTSTR   Strings[ 5 ];
   TCHAR    szLicenseHandle[ 20 ];
   TCHAR    szModuleName[ 1 + MAX_PATH ] = TEXT("<Unknown>");

   LogHandle = RegisterEventSourceW( NULL, TEXT("LicenseService") );

   if ( NULL != LogHandle )
   {
      wsprintf( szLicenseHandle, TEXT( "0x%08X" ), LicenseHandle );
      GetModuleFileName( NULL, szModuleName, sizeof( szModuleName ) / sizeof( *szModuleName ) );

      if ( NT_SUCCESS( Status ) )
      {
         Strings[ 0 ] = TEXT( "<License Request -- Accepted>" );
      }
      else
      {
         Strings[ 0 ] = TEXT( "<License Request -- * DENIED *>" );
      }
      Strings[ 1 ] = szModuleName;
      Strings[ 2 ] = ProductName;
      Strings[ 3 ] = dVersion;
      Strings[ 4 ] = ( NtData->DataType == NT_LS_USER_SID ) ? TEXT( "(SID)" ) : (LPTSTR) NtData->Data;
      Strings[ 5 ] = szLicenseHandle;

      ReportEvent( LogHandle,
                   NT_SUCCESS( Status ) ? EVENTLOG_INFORMATION_TYPE : EVENTLOG_WARNING_TYPE,
                   0,
                   NT_SUCCESS( Status ) ? 9999 : 9000,
                   ( NtData->DataType == NT_LS_USER_SID ) ? (PSID) NtData->Data : NULL,
                   6,
                   sizeof(DWORD),
                   Strings,
                   (PVOID) &Status );

      DeregisterEventSource(LogHandle);
   }
}
#endif // LOG_LICENSE_TRAFFIC

   return(Status);
} // NtLicenseRequestW


/*
     NtLSFreeHandle ( )

      Frees all licensing handle context.

      Format

       void  NtLSFreeHandle ( [in] LS_HANDLE LicenseHandle);

      Arguments

       LicenseHandle  Handle identifying the license context. This
                    argument must be a handle that was created with
                    NtLSRequest() or NtLicenseRequest().

      Description

       (NOTE:  The handle is no longer valid.)

*/

LS_STATUS_CODE LS_API_ENTRY NtLSFreeHandle(
                  LS_HANDLE LicenseHandle )
{

#ifdef API_TRACE
   dprintf(TEXT("NtLSFreeHandle: %ld\r\n"), LicenseHandle);
#endif

#ifdef LOG_LICENSE_TRAFFIC
{
   HANDLE   LogHandle;
   LPTSTR   Strings[ 5 ];
   TCHAR    szLicenseHandle[ 20 ];
   TCHAR    szModuleName[ 1 + MAX_PATH ] = TEXT("<Unknown>");

   LogHandle = RegisterEventSourceW( NULL, TEXT("LicenseService") );

   if ( NULL != LogHandle )
   {
      wsprintf( szLicenseHandle, TEXT( "0x%08X" ), LicenseHandle );
      GetModuleFileName( NULL, szModuleName, sizeof( szModuleName ) / sizeof( *szModuleName ) );

      Strings[ 0 ] = TEXT( "<License Free>" );
      Strings[ 1 ] = szModuleName;
      Strings[ 2 ] = szLicenseHandle;

      ReportEvent( LogHandle,
                   EVENTLOG_INFORMATION_TYPE,
                   0,
                   10000,
                   NULL,
                   3,
                   0,
                   Strings,
                   NULL );

      DeregisterEventSource(LogHandle);
   }
}
#endif // LOG_LICENSE_TRAFFIC

   //
   // If we get an invalid License Handle (or a dummy 0xFFFFFFFF one)
   // then don't even bother calling through LPC as it is a waste
   // of time.
   //
   if (LicenseHandle == 0xFFFFFFFFL)
      return( LS_SUCCESS );

   //
   // Make the LPC call
   //
   LLSLicenseFree2( LicenseHandle );

   return( LS_SUCCESS );
} // NtLSFreeHandle


#ifdef OBSOLETE

// **************************************************************************
//     OLD API's Don't Use
// **************************************************************************

/*
     LSRequest()
       Request licensing resources needed to allow software to be
       used.

      Format

       Status = LSRequest( [in] LicenseSystem, [in] PublisherName,
                    [in] ProductName,
                    [in] Version, [in] TotUnitsReserved, [in]
                    LogComment,
                    [in/out] Challenge,  [out] TotUnitsGranted, [out]
                    hLicenseHandle );

       LS_STR *      LicenseSystem;

       LS_STR *      PublisherName;

       LS_STR *      ProductName;

       LS_STR *      Version;

       LS_ULONG      TotUnitsReserved;

       LS_STR *      LogComment;

       LS_CHALLENGE *Challenge;

       LS_ULONG *    TotUnitsGranted;

       LS_HANDLE *   hLicenseHandle;

       LS_STATUS_CODEStatus;

      Arguments

       LicenseSystem  Pointer to a string which uniquely identifies
                    the particular license system. This may be
                    obtained through the LSEnumProviders() API.
                    Normally, the constant LS_ANY is specified to
                    indicate a match against all installed license
                    systems (indicates that all license providers
                    should be searched for a license match).

       PublisherName  The name of the publisher (manufacturer) of
                    this product.  This string may not be null and
                    must be unique in the first 32 characters. It is
                    recommended that a company name and trademark be
                    used.

       ProductName The name of the product requesting licensing
                    resources.  This string may not be null and must
                    be unique (in the first 32 characters) within the
                    PublisherName domain.

       Version     The version number of this product. This string
                    must be unique (in the first 12 characters) within
                    the ProductName domain, and cannot be NULL

                    NOTE: The arguments PublisherName, ProductName,
                          and Version may not be NULL, or may not be
                          LS_ANY.

       TotUnitsReserved Specifies the number of units required to run
                    the application.  The software publisher may
                    choose to specify this policy attribute within the
                    application. The recommended value of
                    LS_DEFAULT_UNITS allows the licensing system to
                    determine the proper value using information
                    provided by the license system or license itself.
                    The license system verifies that the requested
                    number of units exist and may reserve those units,
                    but no units are actually consumed at this time.
                    The number of units available is returned in
                    TotUnitsGranted.

       LogComment  An optional string indicating a comment to be
                    associated with the request and logged (if logging
                    is enabled and supported) by the underlying
                    licensing system. The underlying license system
                    may choose to log the comment even if an error is
                    returned (i.e., logged with the error), but this
                    is not guaranteed.  If a string is not specified,
                    the value must be LS_NULL.

       Challenge   Pointer to a challenge structure. The challenge
                    response will also be returned in this structure.
                    Refer to Challenge Mechanism on page 25 for more
                    information.

       TotUnitsGrantedA pointer to an LS_ULONG in which the total
                    number of units granted is returned. The following
                    table describes the TotUnitsGranted return value,
                    given the TotUnitsReserved input value, and the
                    Status returned:

                                           LS_INSUFFICIENT_U
                TotUnitsReserv  LS_SUCCES  NITS               Other
                ed              S                             errors
                LS_DEFAULT_UNI  (A)        (B)                (E)
                TS
                Other           (C)        (D)                (E)
                (specific
                count)
                    (A)    The default umber of units commensurate
                      with the license granted.(B)  The maximum
                      number of units available to the requesting
                      software. This may be less than the normal
                      default.
                    (C)    The number of units used to grant the
                      request. Note that this value may be greater
                      than or equal to  the actual units requested
                      (i.e., the policy may allow only in increments
                      of 5 units, thus a request of 7 units would
                      result in 10 units being granted).
                    (D)    The maximum number of units available to
                      the requesting software. This may be more or
                      less than the units requested.
                    (E)    Zero is returned.

       LicenseHandle  Pointer to a LS_HANDLE in which a handle to the
                    license context is to be returned.

       Status      Detailed error code that can be directly processed
                    by the caller, or that can be converted into a
                    localized message string by the LSGetMessage()
                    function.

      Description

       This function is used by the application to request licensing
       resources to allow the identified product to execute. If a
       valid license is found, the challenge response is computed and
       LS_SUCCESS is returned. At minimum, the PublisherName,
       ProductName, and Version strings are used to identify matching
       license(s). Note that an underlying license system service
       provider may ascertain additional information for the license
       request (e.g., the current username, machine name, etc.).

       A valid license handle is always returned by this function
       whether valid license resources are granted or not.  This
       handle must always be released with LSFreeHandle() when the
       application has completed execution.

       If license resources were granted, it must call LSRelease() to
       free the license resource, prior to calling LSFreeHandle().

       A challenge response is NOT returned unless the license
       request completed successfully (i.e., a status code of
       LS_SUCCESS is returned).

       If the number of units requested is greater than the number of
       units available, then the license request is not granted. Upon
       successful completion, the value returned in TotUnitsReserved
       indicates the number of units granted. This is greater than or
       equal to the number of units requested unless LS_DEFAULT_UNITS
       was specified. In the case of failure, the value returned in
       TotUnitsGranted is zero.

*/

LS_STATUS_CODE LS_API_ENTRY NtLSRequest(
                  LS_STR             FAR *LicenseSystem,
                  LS_STR             FAR *PublisherName,
                  LS_STR             FAR *ProductName,
                  LS_STR             FAR *Version,
                  LS_ULONG           TotUnitsReserved,
                  LS_STR             FAR *LogComment,
                  LS_CHALLENGE       FAR *Challenge,
                  LS_ULONG           FAR *TotUnitsGranted,
                  LS_HANDLE          FAR *LicenseHandle,
                  NT_LS_DATA         FAR *NtData)
{
   NT_LS_DATA tmpNtData;
   WCHAR uProductName[MAX_PRODUCT_NAME_LENGTH + 1];
   WCHAR uVersion[MAX_VERSION_LENGTH + 1];
   WCHAR uUserName[MAX_USER_NAME_LENGTH + 1];
   LS_STATUS_CODE ret = LS_SUCCESS;

#ifdef API_TRACE
   dprintf(TEXT("NtLSRequest:\r\n"));

   if (ProductName == NULL)
      dprintf(TEXT("   Product Name: <NULL>\r\n"));

   if (Version == NULL)
      dprintf(TEXT("   Version: <NULL>\r\n"));

   if (LicenseHandle == NULL)
      dprintf(TEXT("   LicenseHandle: <NULL>\r\n"));

   if (NtData != NULL) {
      if (NtData->Data == NULL)
         dprintf(TEXT("   NtData->Data: <NULL>\r\n"));
   } else
      dprintf(TEXT("NtData: <NULL>\r\n"));

   dprintf(TEXT("\r\n"));

#endif

   // Do some fudging to follow old API spec...
   if ( TotUnitsGranted != NULL )
      *TotUnitsGranted = TotUnitsReserved;

   // Need to do a couple things:
   //   1. Convert used parms to Unicode
   //   2. Set up new NtData structure (extra IsAdmin field)
   //   3. Make call to new NtLicenseRequest API and use it's return code.
   //
   // Note:  No conversion back to ANSI needed upon return from API
   //

   // First make sure we have correct data
   if ( (ProductName != NULL) && (Version != NULL) && (NtData != NULL) && (NtData->Data != NULL)) {

      // 1. Convert parms to Unicode
      if (lstrlenA(ProductName) > MAX_PRODUCT_NAME_LENGTH) {
#ifdef API_TRACE
         dprintf(TEXT("   Error: ProductName too long\r\n"));
#endif
         MultiByteToWideChar(CP_ACP, 0, ProductName, MAX_PRODUCT_NAME_LENGTH, uProductName, MAX_PRODUCT_NAME_LENGTH + 1);
         uProductName[MAX_PRODUCT_NAME_LENGTH] = TEXT('\0');
      } else
         MultiByteToWideChar(CP_ACP, 0, ProductName, -1, uProductName, MAX_PRODUCT_NAME_LENGTH + 1);

      if (lstrlenA(Version) > MAX_VERSION_LENGTH) {
#ifdef API_TRACE
         dprintf(TEXT("   Error: Version too long\r\n"));
#endif
         MultiByteToWideChar(CP_ACP, 0, Version, MAX_VERSION_LENGTH, uVersion, MAX_VERSION_LENGTH + 1);
         uVersion[MAX_VERSION_LENGTH] = TEXT('\0');
      } else
         MultiByteToWideChar(CP_ACP, 0, Version, -1, uVersion, MAX_VERSION_LENGTH + 1);

      // 2. Set up new NtData structure
      tmpNtData.DataType = NtData->DataType;

      // just use FALSE for IsAdmin as none of the old Apps need it.
      tmpNtData.IsAdmin = FALSE;

      if (NtData->DataType == NT_LS_USER_NAME) {
         if (lstrlenA((LPSTR) NtData->Data) > MAX_USER_NAME_LENGTH) {
#ifdef API_TRACE
         dprintf(TEXT("   Error: UserName too long\r\n"));
#endif
            MultiByteToWideChar(CP_ACP, 0, NtData->Data, MAX_USER_NAME_LENGTH, uUserName, MAX_USER_NAME_LENGTH + 1);
            uUserName[MAX_USER_NAME_LENGTH] = TEXT('\0');
         } else {
            MultiByteToWideChar(CP_ACP, 0, NtData->Data, -1, uUserName, MAX_USER_NAME_LENGTH + 1);
         }

         tmpNtData.Data = (void *) uUserName;

         // Have UserName convert to wide char format, but need to point
         // Data structure to it...
         ret = NtLicenseRequestW(uProductName, uVersion, LicenseHandle, &tmpNtData);

         // Nothing needs to be converted back to ANSI on return, just return
         return ret;
      } else {
         // Gave SID so no Unicode convesion needed on name
         tmpNtData.Data = NtData->Data;
         ret = NtLicenseRequestW(uProductName, uVersion, LicenseHandle, &tmpNtData);
         return ret;
      }

   }

   // If NULL parms or such then just return a dummy handle for right now
   if ( LicenseHandle != NULL )
      *LicenseHandle = 0xffffffffL;

   return(LS_SUCCESS);
} // NtLSRequest

/*
     LSRelease()
       Release licensing resources associated with the specified
       context.

      Format

       Status = LSRelease( [in] LicenseHandle, [in] TotUnitsConsumed,
                    [in] LogComment );

       LS_HANDLE     LicenseHandle;

       LS_ULONG      TotUnitsConsumed;

       LS_STR *      LogComment;

       LS_STATUS_CODEStatus;

      Arguments

       LicenseHandle  Handle identifying the license context. This
                    argument must be a handle that was created with
                    LSRequest().

       TotUnitsConsumedThe TOTAL number of units consumed in this
                    handle context since the initial LSRequest() call.
                    The software publisher may choose to specify this
                    policy attribute within the application.  A value
                    of LS_DEFAULT_UNITS indicates that the licensing
                    system should determine the appropriate value
                    using its own licensing policy mechanisms.

       LogComment  An optional string indicating a comment to be
                    associated with the request and logged (if logging
                    is enabled and supported) by the underlying
                    licensing system. The underlying license system
                    may choose to log the comment even if an error is
                    returned (i.e., logged with the error), but this
                    is not guaranteed.  If a string is not specified,
                    the value must be LS_NULL.

       Status      Detailed error code that can be directly processed
                    by the caller, or that can be converted into a
                    localized message string by the LSGetMessage()
                    function.

      Description

       This function is used to release licensing resources
       associated with the license context identified by
       LicenseHandle.  If a consumptive style licensing policy is in
       effect, and if the software publisher chooses to implement
       such license policy in the application, then the license units
       to be consumed may be passed as part of this call.

       NOTE:  The license handle context is NOT freed. See
       LSFreeHandle().

*/

LS_STATUS_CODE LS_API_ENTRY NtLSRelease(
                  LS_HANDLE          LicenseHandle,
                  LS_ULONG           TotUnitsConsumed,
                  LS_STR             FAR *LogComment)
{
   return(LS_SUCCESS);
}

/*
     LSUpdate()
       Update the synchronization between licensed software and the
       licensing system.

      Format

       Status = LSUpdate( [in] LicenseHandle, [in] TotUnitsConsumed,
                    [in] TotUnitsReserved,
                    [in] LogComment, [in/out] Challenge, [out]
                    TotUnitsGranted );

       LS_HANDLE     LicenseHandle;

       LS_ULONG      TotUnitsConsumed;

       LS_ULONG      TotUnitsReserved;

       LS_STR *      LogComment;

       LS_CHALLENGE *Challenge;

       LS_ULONG *    TotUnitsGranted;

       LS_STATUS_CODEStatus;

      Arguments

       LicenseHandle  Handle identifying the license context. This
                    argument must be a handle that was created with
                    LSRequest().

       TotUnitsConsumedThe TOTAL number of units consumed so far in
                    this handle context.  The software publisher may
                    choose to specify this policy attribute within the
                    application.  A value of LS_DEFAULT_UNITS
                    indicates that the licensing system should
                    determine the appropriate value using its own
                    licensing policy mechanisms. If an error is
                    returned, then no units are consumed.

       TotUnitsReserved Specifies the total number of units to be
                    reserved. If no additional units are required
                    since the initial LSRequest() or last LSUpdate(),
                    then this parameter should be the current total
                    (as returned in TotUnitsGranted). The total
                    reserved is inclusive of units consumed. That is,
                    if an application requests 100 units be reserved,
                    then consumes 20 units, there are still 100 units
                    reserved (but only 80 available for consumption).

                    If additional units are required, the application
                    must calculate a new total for TotUnitsReserved.
                    LS_DEFAULT_UNITS may be specified, but this will
                    not allocate any additional units.

                    The license system verifies that the requested
                    number of units exist and may reserve those units,
                    but these units are not consumed at this time.
                    This value may be smaller than the original
                    request to indicate that fewer units are needed
                    than originally anticipated.

       LogComment  An optional string indicating a comment to be
                    associated with the request and logged (if logging
                    is enabled and supported) by the underlying
                    licensing system. The underlying license system
                    may choose to log the comment even if an error is
                    returned (i.e., logged with the error), but this
                    is not guaranteed.  If a string is not specified,
                    the value must be LS_NULL.

       Challenge   Pointer to a challenge structure. The challenge
                    response will also be returned in this structure.
                    Refer to Challenge Mechanism on page 25 for more
                    information.

       TotUnitsGrantedA pointer to an LS_ULONG in which the total
                    number of units granted since the initial license
                    request is returned. The following table describes
                    the TotUnitsGranted return value, given the
                    TotUnitsReserved input value, and the Status
                    returned:

                                           LS_INSUFFICIENT_U
                TotUnitsReserv  LS_SUCCES  NITS               Other
                ed              S                             errors
                LS_DEFAULT_UNI  (A)        (B)                (E)
                TS
                Other           (C)        (D)                (E)
                (specific
                count)
                    (A)    The default umber of units commensurate
                      with the license granted. (B) The maximum
                      number of units available to the requesting
                      software. This may be less than the normal
                      default.
                    (C)    The number of units used to grant the
                      request. Note that this value may differ from
                      the actual units requested (i.e., the policy
                      may allow only in increments of 5 units, thus a
                      request of 7 units would result in 10 units
                      being granted).
                    (D)    The maximum number of units available to
                      the requesting software. This may be more or
                      less than the units requested.
                    (E)    Zero is returned.

       Status      Detailed error code that can be directly processed
                    by the caller, or that can be converted into a
                    localized message string by the LSGetMessage()
                    function.

      Description

       The client application periodically issues this call to re-
       verify that the current license is still valid. The LSQuery()
       API may be used to determine the proper interval for the
       current licensing context. A guideline  of once an hour may be
       appropriate, with a minimum interval of 15 minutes. Consult
       your licensing system vendor for more information.

       If the number of new units requested (in TotUnitsReserved) is
       greater than the number available, then the update request
       fails with an LS_INSUFFICIENT_UNITS error. Upon successful
       completion, the value returned in TotUnitsGranted indicates
       the current total of units granted.

       If the TotUnitsConsumed exceeds the number of units reserved,
       then the error LS_INSUFFICIENT_UNITS is returned. The
       remaining units are consumed.

       A challenge response is NOT returned if an error is returned.

       The LSUpdate() call verifies that the licensing system context
       has not changed from that expected by the licensed software.
       In this way the LSUpdate() call can:

       1.Determine if the licensing system can verify that the
          licensing resources granted to the specified handle are
          still reserved for this application by the licensing system.
          Note that in distributed license system, an error here might
          indicate a temporary network interruption, among other
          things.

       2.Determine when the licensing system has released the
          licensing resources that had been granted to the specified
          handle, indicating the software requiring that grant no
          longer has authorization to execute normally.

       Application Software should be prepared to handle vendor
       specific error conditions, should they arise. However, a best
       effort will be used by license systems to map error conditions
       to the common error set.

       The LSUpdate() call may indicate if that the current licensing
       context has expired (for example, in the case of a time-
       restricted license policy). In such a case, the warning status
       LS_LICENSE_EXPIRED is returned.  If any error is returned, a
       call to LSRelease() is still required.
*/

LS_STATUS_CODE LS_API_ENTRY NtLSUpdate(
                  LS_HANDLE          LicenseHandle,
                  LS_ULONG           TotUnitsConsumed,
                  LS_ULONG           TotUnitsReserved,
                  LS_STR             FAR *LogComment,
                  LS_CHALLENGE       FAR *Challenge,
                  LS_ULONG           FAR *TotUnitsGranted)
{
   // set the return buffer to NULL
   if ( TotUnitsGranted != NULL )
      *TotUnitsGranted = TotUnitsReserved;

   return(LS_SUCCESS);
}

/*
     LSGetMessage()
       Return the message associated with a License Service API
       status code.

      Format

       Status = LSGetMessage( [in] LicenseHandle, [in] Value, [out]
                    Buffer, [in] BufferSize );

       LS_HANDLE     LicenseHandle;

       LS_STATUS_CODEValue;

       LS_STR *      Buffer;

       LS_ULONG      BufferSize;

       LS_STATUS_CODEStatus;

      Arguments

       LicenseHandle  Handle identifying the license context. This
                    argument must be a handle that was created with
                    LSRequest().

       Value       Any status code returned by a License Service API
                    function.

       Buffer      Pointer to a buffer in which a localized error
                    message string is to be placed.

       BufferSize  Maximum size of the string that may be returned in
                    Buffer.

       Status      Resulting status of LSGetMessage() call.

      Description

       For a given error, this function returns an error code and a string
       describing the error, and a suggested action to be taken in
       response to the specific error.  If the value of Value is
       LS_USE_LAST, then the last error associated with the supplied
       licensing handle, and its associated data, is returned.  Otherwise,
       the supplied error code is used.

       Possible status codes returned by LSGetMessage() include:
       LS_SUCCESS, LS_NO_MSG_TEXT, LS_UNKNOWN_STATUS, and
       LS_BUFFER_TOO_SMALL.

*/

LS_STATUS_CODE LS_API_ENTRY NtLSGetMessage(
                  LS_HANDLE          LicenseHandle,
                  LS_STATUS_CODE     Value,
                  LS_STR             FAR *Buffer,
                  LS_ULONG           BufferSize)
{
   return(LS_TEXT_UNAVAILABLE);
}

/*
     LSQuery()
       Return information about the license system context associated
       with the specified handle.

      Format

       Status = LSQuery( [in] LicenseHandle, [in] Information, [out]
                    InfoBuffer, [in] BufferSize,
                    [out] ActualBufferSize);

       LS_HANDLE     LicenseHandle;

       LS_ULONG      Information;

       LS_VOID *     InfoBuffer;

       LS_ULONG      BufferSize;

       LS_ULONG *    ActualBufferSize;

       LS_STATUS_CODEStatus;

      Arguments

       LicenseHandle  Handle identifying the license context. This
                    argument must be a handle that was created with
                    LSRequest().

       Information Index which identifies the information to be
                    returned.

       InfoBuffer  Points to a buffer in which the resulting
                    information is to be placed.

       BufferSize  Maximum size of the buffer pointed to by
                    InfoBuffer.

       ActualBufferSize On entry, points to a LS_ULONG whose value on
                    exit indicates the actual count of characters
                    returned in the buffer (not including the trailing
                    NULL byte).

       Status      Detailed error code that can be directly processed
                    by the caller, or which can be converted into a
                    localized message string by the LSGetMessage
                    function.

      Description

       This function is used to obtain information about the license
       obtained from the LSRequest() call. For example, an application may
       determine the license type (demo, concurrent, personal, etc.); time
       restrictions; etc.

       The buffer should be large enough to accommodate the expected data.
       If the buffer is too small, then the status code
       LS_BUFFER_TOO_SMALL is returned and only BufferSize bytes of data
       are returned.

       The following Information constants are defined:

     Information      Valu  Meaning
     Constant         e
     LS_INFO_NONE     0     Reserved.
     LS_INFO_SYSTEM   1     Return the unique identification
                            of the license system supplying
                            the current license context.
                            This is returned as a null-
                            terminated string.

                            This value is the same as an
                            appropriate call to
                            LSEnumProviders() provides.

     LS_INFO_DATA     2     Return the block of
                            miscellaneous application data
                            contained on the license. This
                            data is completely vendor-
                            defined. The amount of space
                            allocated for such data will
                            vary from license system to
                            license system, or may not be
                            available at all.

                            The first ULONG in the data
                            buffer indicates the size (in
                            bytes) of the actual data which
                            follows:

                             +------------------------------
                             --+
                             |             ULONG
                             |
                             |  (count of bytes that follow)
                             |
                             +------------------------------
                             --+
                             | Vendor data bytes from license
                             |
                             |
                             |
                             +------------------------------
                             --+

     LS_UPDATE_PERIO  3     Return the recommended interval
     D                      (in minutes) at which LSUpdate()
                            should be called.

                             +------------------------------
                             --+
                             |             ULONG
                             |
                             |       Recommended Interval
                             |
                             |          (in minutes)
                             |
                             +------------------------------
                             --+
                             |             ULONG
                             |
                             |    Recommended Minutes until
                             |
                             |       next LSUpdate()call
                             |
                             +------------------------------
                             --+

                            If a value of 0xFFFFFFFF is
                            returned for the recommended
                            interval, then no recommendation
                            is being made.

     LS_LICENSE_CONT  4     Return a value which uniquely
     EXT                    identifies the licensing context
                            within the specific license
                            service provider identified by
                            the LicenseHandle.

                             +------------------------------
                             --+
                             |             ULONG
                             |
                             |   Count of Bytes that follow
                             |
                             +------------------------------
                             --+
                             |             BYTES
                             |
                                            ...
                             |
                             |
                             +------------------------------
                             --+

                            The contents of the bytes
                            returned is license system
                            specific. In circumstances where
                            license system specific
                            functionality is being used,
                            this sequence of bytes may be
                            used to identify the current
                            license context.
*/

LS_STATUS_CODE LS_API_ENTRY NtLSQuery(
                  LS_HANDLE          LicenseHandle,
                  LS_ULONG           Information,
                  LS_VOID            FAR *InfoBuffer,
                  LS_ULONG           BufferSize,
                  LS_ULONG           FAR *ActualBufferSize)
{
   switch ( Information )
   {
   case   LS_INFO_DATA:
   case   LS_LICENSE_CONTEXT:
     // set the return buffer to NULL
     if ( InfoBuffer != NULL )
       *((LS_ULONG *)InfoBuffer) = 0;

     if ( ActualBufferSize != NULL )
       *ActualBufferSize = sizeof( LS_ULONG );

     break;
   case   LS_UPDATE_PERIOD:
     if (( InfoBuffer != NULL ) && ( BufferSize >= sizeof(LS_ULONG)*2 ))
     {
          // set the return balue to no recommendation
        LS_ULONG * uLong = (LS_ULONG*)InfoBuffer;
        *uLong = 0xffffffff;
        uLong++;
        *uLong = 0xffffffff;
        *ActualBufferSize = sizeof(LS_ULONG) * 2;
     }
     break;
   case   LS_INFO_NONE:
   case   LS_INFO_SYSTEM:
   default:
     // set return buffer to NULL
     if ( InfoBuffer != NULL )
       strcpy( InfoBuffer, (LS_STR*)"");

     if ( ActualBufferSize != NULL )
       *ActualBufferSize = 0;

     break;
   }
   return(LS_SUCCESS);
}

/*
     LSEnumProviders()
       This call is used to enumerate the installed license system
       service providers.

      Format

       Status = LSEnumProviders( [in] Index, [out] Buffer);

       LS_ULONG      Index

       LS_STR *      Buffer

       LS_STATUS_CODEStatus;

      Arguments

       Index       Index of the service provider. The first provider
                    has an index of zero, the second has an index of
                    one, etc. This index should be incremented by the
                    caller for each successive call to
                    LSEnumProviders() until the status LS_BAD_INDEX is
                    returned.

       Buffer      Points to a buffer in which the unique null-
                    terminated string identifying the license system
                    service provider is to be placed. The buffer
                    pointed to by Buffer must be at least 255 bytes
                    long.  The value of LS_ANY indicates that the
                    current index is not in use, but is not the last
                    index to obtain.

       Status      Detailed error code that can be directly processed
                    by the caller, or which can be converted into a
                    localized message string by the LSGetMessage()
                    function.

      Description

       For each installed provider, a unique string is returned. The
       unique null-terminated string typically identifies the vendor,
       product, and version of the license system. This value is the same
       as an appropriate call to LSQuery().  An Error of LS_BAD_INDEX is
       returned when the value of Index is higher than the number of
       providers currently installed.  In a networked environment, the
       version returned is that of the client, not the server.

       An application may enumerate the installed license system service
       providers by calling LSEnumProviders() successively. The Index is
       passed in and should be incremented by the caller for each call
       until the status LS_BAD_INDEX is returned.

*/

LS_STATUS_CODE LS_API_ENTRY NtLSEnumProviders(
                  LS_ULONG           Index,
                  LS_STR             FAR *Buffer)
{
   // set return buffer to NULL
   if ( Buffer != NULL )
     strcpy( Buffer, (LS_STR*)"" );

   return(LS_SUCCESS);
}
#endif // OBSOLETE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\gentable.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Gentable.c

Abstract:

    This module implements the generic table package.

Author:

    Gary Kimura     [GaryKi]    23-May-1989

Environment:

    Pure Utility Routines

Revision History:

    Anthony V. Ercolano [tonye] 23-May-1990

    Implement package.

    Anthony V. Ercolano [tonye] 1-Jun-1990

    Added ability to get elements out in the order
    inserted.  *NOTE* *NOTE* This depends on the implicit
    ordering of record fields:

        SPLAY_LINKS,
        LIST_ENTRY,
        USER_DATA

    RobLeit 28-Jan-2000

    Copied code to preserve in-order traversal propery.

--*/

#include <nt.h>

#include <ntrtl.h>

#include "llsrtl.h"

#pragma pack(8)

//
// This structure is the header for a generic table entry.
// Align this structure on a 8 byte boundary so the user
// data is correctly aligned.
//

typedef struct _TABLE_ENTRY_HEADER {

    RTL_SPLAY_LINKS SplayLinks;
    LIST_ENTRY ListEntry;
    LONGLONG UserData;

} TABLE_ENTRY_HEADER, *PTABLE_ENTRY_HEADER;

#pragma pack()


static
LLS_TABLE_SEARCH_RESULT
FindNodeOrParent(
    IN PLLS_GENERIC_TABLE Table,
    IN PVOID Buffer,
    OUT PRTL_SPLAY_LINKS *NodeOrParent
    )

/*++

Routine Description:

    This routine is used by all of the routines of the generic
    table package to locate the a node in the tree.  It will
    find and return (via the NodeOrParent parameter) the node
    with the given key, or if that node is not in the tree it
    will return (via the NodeOrParent parameter) a pointer to
    the parent.

Arguments:

    Table - The generic table to search for the key.

    Buffer - Pointer to a buffer holding the key.  The table
             package doesn't examine the key itself.  It leaves
             this up to the user supplied compare routine.

    NodeOrParent - Will be set to point to the node containing the
                   the key or what should be the parent of the node
                   if it were in the tree.  Note that this will *NOT*
                   be set if the search result is TableEmptyTree.

Return Value:

    TABLE_SEARCH_RESULT - TableEmptyTree: The tree was empty.  NodeOrParent
                                          is *not* altered.

                          TableFoundNode: A node with the key is in the tree.
                                          NodeOrParent points to that node.

                          TableInsertAsLeft: Node with key was not found.
                                             NodeOrParent points to what would be
                                             parent.  The node would be the left
                                             child.

                          TableInsertAsRight: Node with key was not found.
                                              NodeOrParent points to what would be
                                              parent.  The node would be the right
                                              child.

--*/



{

    if (LLSIsGenericTableEmpty(Table)) {

        return LLSTableEmptyTree;

    } else {

        //
        // Used as the iteration variable while stepping through
        // the generic table.
        //
        PRTL_SPLAY_LINKS NodeToExamine = Table->TableRoot;

        //
        // Just a temporary.  Hopefully a good compiler will get
        // rid of it.
        //
        PRTL_SPLAY_LINKS Child;

        //
        // Holds the value of the comparasion.
        //
        LLS_GENERIC_COMPARE_RESULTS Result;

        while (TRUE) {

            //
            // Compare the buffer with the key in the tree element.
            //

            Result = Table->CompareRoutine(
                         Table,
                         Buffer,
                         &((PTABLE_ENTRY_HEADER) NodeToExamine)->UserData
                         );

            if (Result == LLSGenericLessThan) {

                if (Child = RtlLeftChild(NodeToExamine)) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return LLSTableInsertAsLeft;

                }

            } else if (Result == LLSGenericGreaterThan) {

                if (Child = RtlRightChild(NodeToExamine)) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return LLSTableInsertAsRight;

                }


            } else {

                //
                // Node is in the tree (or it better be because of the
                // assert).  Set the output parameter to point to
                // the node and tell the caller that we found the node.
                //

                ASSERT(Result == LLSGenericEqual);
                *NodeOrParent = NodeToExamine;
                return LLSTableFoundNode;

            }

        }

    }

}

VOID
LLSInitializeGenericTable (
    IN PLLS_GENERIC_TABLE Table,
    IN PLLS_GENERIC_COMPARE_ROUTINE CompareRoutine,
    IN PLLS_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    IN PLLS_GENERIC_FREE_ROUTINE FreeRoutine,
    IN PVOID TableContext
    )

/*++

Routine Description:

    The procedure InitializeGenericTable takes as input an uninitialized
    generic table variable and pointers to the three user supplied routines.
    This must be called for every individual generic table variable before
    it can be used.

Arguments:

    Table - Pointer to the generic table to be initialized.

    CompareRoutine - User routine to be used to compare to keys in the
                     table.

    AllocateRoutine - User routine to call to allocate memory for a new
                      node in the generic table.

    FreeRoutine - User routine to call to deallocate memory for
                        a node in the generic table.

    TableContext - Supplies user supplied context for the table.

Return Value:

    None.

--*/

{

    //
    // Initialize each field of the Table parameter.
    //

    Table->TableRoot = NULL;
    InitializeListHead(&Table->InsertOrderList);
    Table->NumberGenericTableElements = 0;
    Table->OrderedPointer = &Table->InsertOrderList;
    Table->WhichOrderedElement = 0;
    Table->CompareRoutine = CompareRoutine;
    Table->AllocateRoutine = AllocateRoutine;
    Table->FreeRoutine = FreeRoutine;
    Table->TableContext = TableContext;

}


PVOID
LLSInsertElementGenericTable (
    IN PLLS_GENERIC_TABLE Table,
    IN PVOID Buffer,
    IN CLONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL
    )

/*++

Routine Description:

    The function InsertElementGenericTable will insert a new element
    in a table.  It does this by allocating space for the new element
    (this includes splay links), inserting the element in the table, and
    then returning to the user a pointer to the new element (which is
    the first available space after the splay links).  If an element
    with the same key already exists in the table the return value is a pointer
    to the old element.  The optional output parameter NewElement is used
    to indicate if the element previously existed in the table.  Note: the user
    supplied Buffer is only used for searching the table, upon insertion its
    contents are copied to the newly created element.  This means that
    pointer to the input buffer will not point to the new element.

Arguments:

    Table - Pointer to the table in which to (possibly) insert the
            key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

    BufferSize - The amount of space to allocate when the (possible)
                 insertion is made.  Note that if we actually do
                 not find the node and we do allocate space then we
                 will add the size of the SPLAY_LINKS to this buffer
                 size.  The user should really take care not to depend
                 on anything in the first sizeof(SPLAY_LINKS) bytes
                 of the memory allocated via the memory allocation
                 routine.

    NewElement - Optional Flag.  If present then it will be set to
                 TRUE if the buffer was not "found" in the generic
                 table.

Return Value:

    PVOID - Pointer to the user defined data.

--*/

{

    //
    // Holds a pointer to the node in the table or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the table lookup.
    //
    LLS_TABLE_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Table,
                 Buffer,
                 &NodeOrParent
                 );

    //
    //  Call the full routine to do the real work.
    //

    return LLSInsertElementGenericTableFull(
                Table,
                Buffer,
                BufferSize,
                NewElement,
                NodeOrParent,
                Lookup
                );
}


PVOID
LLSInsertElementGenericTableFull (
    IN PLLS_GENERIC_TABLE Table,
    IN PVOID Buffer,
    IN CLONG BufferSize,
    OUT PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    LLS_TABLE_SEARCH_RESULT SearchResult
    )

/*++

Routine Description:

    The function InsertElementGenericTableFull will insert a new element
    in a table.  It does this by allocating space for the new element
    (this includes splay links), inserting the element in the table, and
    then returning to the user a pointer to the new element.  If an element
    with the same key already exists in the table the return value is a pointer
    to the old element.  The optional output parameter NewElement is used
    to indicate if the element previously existed in the table.  Note: the user
    supplied Buffer is only used for searching the table, upon insertion its
    contents are copied to the newly created element.  This means that
    pointer to the input buffer will not point to the new element.
    This routine is passed the NodeOrParent and SearchResult from a
    previous RtlLookupElementGenericTableFull.

Arguments:

    Table - Pointer to the table in which to (possibly) insert the
            key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

    BufferSize - The amount of space to allocate when the (possible)
                 insertion is made.  Note that if we actually do
                 not find the node and we do allocate space then we
                 will add the size of the SPLAY_LINKS to this buffer
                 size.  The user should really take care not to depend
                 on anything in the first sizeof(SPLAY_LINKS) bytes
                 of the memory allocated via the memory allocation
                 routine.

    NewElement - Optional Flag.  If present then it will be set to
                 TRUE if the buffer was not "found" in the generic
                 table.

   NodeOrParent - Result of prior RtlLookupElementGenericTableFull.

   SearchResult - Result of prior RtlLookupElementGenericTableFull.

Return Value:

    PVOID - Pointer to the user defined data.

--*/

{
    //
    // Node will point to the splay links of what
    // will be returned to the user.
    //

    PRTL_SPLAY_LINKS NodeToReturn;

    if (SearchResult != LLSTableFoundNode) {

        //
        // We just check that the table isn't getting
        // too big.
        //

        ASSERT(Table->NumberGenericTableElements != (MAXULONG-1));

        //
        // The node wasn't in the (possibly empty) tree.
        // Call the user allocation routine to get space
        // for the new node.
        //

        NodeToReturn = Table->AllocateRoutine(
                           Table,
                           BufferSize+FIELD_OFFSET( TABLE_ENTRY_HEADER, UserData )
                           );

        //
        // If the return is NULL, return NULL from here to indicate that
        // the entry could not be added.
        //

        if (NodeToReturn == NULL) {

            if (ARGUMENT_PRESENT(NewElement)) {

                *NewElement = FALSE;
            }

            return(NULL);
        }

        RtlInitializeSplayLinks(NodeToReturn);

        //
        // Insert the new node at the end of the ordered linked list.
        //

        InsertTailList(
            &Table->InsertOrderList,
            &((PTABLE_ENTRY_HEADER) NodeToReturn)->ListEntry
            );

        Table->NumberGenericTableElements++;

        //
        // Insert the new node in the tree.
        //

        if (SearchResult == LLSTableEmptyTree) {

            Table->TableRoot = NodeToReturn;

        } else {

            if (SearchResult == LLSTableInsertAsLeft) {

                RtlInsertAsLeftChild(
                    NodeOrParent,
                    NodeToReturn
                    );

            } else {

                RtlInsertAsRightChild(
                    NodeOrParent,
                    NodeToReturn
                    );
            }
        }

        //
        // Copy the users buffer into the user data area of the table.
        //

        RtlCopyMemory(
            &((PTABLE_ENTRY_HEADER) NodeToReturn)->UserData,
            Buffer,
            BufferSize
            );

    } else {

        NodeToReturn = NodeOrParent;
    }

    //
    // Always splay the (possibly) new node.
    //

    Table->TableRoot = RtlSplay(NodeToReturn);

    if (ARGUMENT_PRESENT(NewElement)) {

        *NewElement = ((SearchResult == LLSTableFoundNode)?(FALSE):(TRUE));
    }

    //
    // Insert the element on the ordered list;
    //

    return &((PTABLE_ENTRY_HEADER) NodeToReturn)->UserData;
}


BOOLEAN
LLSDeleteElementGenericTable (
    IN PLLS_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function DeleteElementGenericTable will find and delete an element
    from a generic table.  If the element is located and deleted the return
    value is TRUE, otherwise if the element is not located the return value
    is FALSE.  The user supplied input buffer is only used as a key in
    locating the element in the table.

Arguments:

    Table - Pointer to the table in which to (possibly) delete the
            memory accessed by the key buffer.

    Buffer - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

Return Value:

    BOOLEAN - If the table contained the key then true, otherwise false.

--*/

{

    //
    // Holds a pointer to the node in the table or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the table lookup.
    //
    LLS_TABLE_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Table,
                 Buffer,
                 &NodeOrParent
                 );

    if ((Lookup == LLSTableEmptyTree) || (Lookup != LLSTableFoundNode)) {

        return FALSE;

    } else {

        //
        // Delete the node from the splay tree.
        //

        Table->TableRoot = RtlDelete(NodeOrParent);

        //
        // Delete the element from the linked list.
        //

        RemoveEntryList(&((PTABLE_ENTRY_HEADER) NodeOrParent)->ListEntry);
        Table->NumberGenericTableElements--;
        Table->WhichOrderedElement = 0;
        Table->OrderedPointer = &Table->InsertOrderList;

        //
        // The node has been deleted from the splay table.
        // Now give the node to the user deletion routine.
        // NOTE: We are giving the deletion routine a pointer
        // to the splay links rather then the user data.  It
        // is assumed that the deallocation is rather bad.
        //

        Table->FreeRoutine(Table,NodeOrParent);
        return TRUE;

    }

}


PVOID
LLSLookupElementGenericTable (
    IN PLLS_GENERIC_TABLE Table,
    IN PVOID Buffer
    )

/*++

Routine Description:

    The function LookupElementGenericTable will find an element in a generic
    table.  If the element is located the return value is a pointer to
    the user defined structure associated with the element, otherwise if
    the element is not located the return value is NULL.  The user supplied
    input buffer is only used as a key in locating the element in the table.

Arguments:

    Table - Pointer to the users Generic table to search for the key.

    Buffer - Used for the comparasion.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{
    //
    // Holds a pointer to the node in the table or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the table lookup.
    //
    LLS_TABLE_SEARCH_RESULT Lookup;

    return LLSLookupElementGenericTableFull(
                Table,
                Buffer,
                &NodeOrParent,
                &Lookup
                );
}


PVOID
NTAPI
LLSLookupElementGenericTableFull (
    PLLS_GENERIC_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT LLS_TABLE_SEARCH_RESULT *SearchResult
    )

/*++

Routine Description:

    The function LookupElementGenericTableFull will find an element in a generic
    table.  If the element is located the return value is a pointer to
    the user defined structure associated with the element.  If the element is not
    located then a pointer to the parent for the insert location is returned.  The
    user must look at the SearchResult value to determine which is being returned.
    The user can use the SearchResult and parent for a subsequent FullInsertElement
    call to optimize the insert.

Arguments:

    Table - Pointer to the users Generic table to search for the key.

    Buffer - Used for the comparasion.

    NodeOrParent - Address to store the desired Node or parent of the desired node.

    SearchResult - Describes the relationship of the NodeOrParent with the desired Node.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{

    //
    //  Lookup the element and save the result.
    //

    *SearchResult = FindNodeOrParent(
                        Table,
                        Buffer,
                        (PRTL_SPLAY_LINKS *)NodeOrParent
                        );

    if ((*SearchResult == LLSTableEmptyTree) || (*SearchResult != LLSTableFoundNode)) {

        return NULL;

    } else {

        //
        // Splay the tree with this node.
        //

        Table->TableRoot = RtlSplay(*NodeOrParent);

        //
        // Return a pointer to the user data.
        //

        return &((PTABLE_ENTRY_HEADER)*NodeOrParent)->UserData;
    }
}


PVOID
LLSEnumerateGenericTable (
    IN PLLS_GENERIC_TABLE Table,
    IN BOOLEAN Restart
    )

/*++

Routine Description:

    The function EnumerateGenericTable will return to the caller one-by-one
    the elements of of a table.  The return value is a pointer to the user
    defined structure associated with the element.  The input parameter
    Restart indicates if the enumeration should start from the beginning
    or should return the next element.  If the are no more new elements to
    return the return value is NULL.  As an example of its use, to enumerate
    all of the elements in a table the user would write:

        for (ptr = EnumerateGenericTable(Table,TRUE);
             ptr != NULL;
             ptr = EnumerateGenericTable(Table, FALSE)) {
                :
        }

Arguments:

    Table - Pointer to the generic table to enumerate.

    Restart - Flag that if true we should start with the least
              element in the tree otherwise, return we return
              a pointer to the user data for the root and make
              the real successor to the root the new root.

Return Value:

    PVOID - Pointer to the user data.

--*/

{

    if (LLSIsGenericTableEmpty(Table)) {

        //
        // Nothing to do if the table is empty.
        //

        return NULL;

    } else {

        //
        // Will be used as the "iteration" through the tree.
        //
        PRTL_SPLAY_LINKS NodeToReturn;

        //
        // If the restart flag is true then go to the least element
        // in the tree.
        //

        if (Restart) {

            //
            // We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = Table->TableRoot;
                RtlLeftChild(NodeToReturn);
                NodeToReturn = RtlLeftChild(NodeToReturn)
                ) {
                ;
            }

            Table->TableRoot = RtlSplay(NodeToReturn);

        } else {

            //
            // The assumption here is that the root of the
            // tree is the last node that we returned.  We
            // find the real successor to the root and return
            // it as next element of the enumeration.  The
            // node that is to be returned is splayed (thereby
            // making it the root of the tree).  Note that we
            // need to take care when there are no more elements.
            //

            NodeToReturn = RtlRealSuccessor(Table->TableRoot);

            if (NodeToReturn) {

                Table->TableRoot = RtlSplay(NodeToReturn);

            }

        }

        //
        // If there actually is a next element in the enumeration
        // then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   ((PVOID)&((PTABLE_ENTRY_HEADER)NodeToReturn)->UserData)
                  :((PVOID)(NULL)));

    }

}


BOOLEAN
LLSIsGenericTableEmpty (
    IN PLLS_GENERIC_TABLE Table
    )

/*++

Routine Description:

    The function IsGenericTableEmpty will return to the caller TRUE if
    the input table is empty (i.e., does not contain any elements) and
    FALSE otherwise.

Arguments:

    Table - Supplies a pointer to the Generic Table.

Return Value:

    BOOLEAN - if enabled the tree is empty.

--*/

{

    //
    // Table is empty if the root pointer is null.
    //

    return ((Table->TableRoot)?(FALSE):(TRUE));

}

PVOID
LLSGetElementGenericTable (
    IN PLLS_GENERIC_TABLE Table,
    IN ULONG I
    )

/*++

Routine Description:


    The function GetElementGenericTable will return the i'th element
    inserted in the generic table.  I = 0 implies the first element,
    I = (RtlNumberGenericTableElements(Table)-1) will return the last element
    inserted into the generic table.  The type of I is ULONG.  Values
    of I > than (NumberGenericTableElements(Table)-1) will return NULL.  If
    an arbitrary element is deleted from the generic table it will cause
    all elements inserted after the deleted element to "move up".

Arguments:

    Table - Pointer to the generic table from which to get the ith element.

    I - Which element to get.


Return Value:

    PVOID - Pointer to the user data.

--*/

{

    //
    // Current location in the table.
    //
    ULONG CurrentLocation = Table->WhichOrderedElement;

    //
    // Hold the number of elements in the table.
    //
    ULONG NumberInTable = Table->NumberGenericTableElements;

    //
    // Holds the value of I+1.
    //
    // Note that we don't care if this value overflows.
    // If we end up accessing it we know that it didn't.
    //
    ULONG NormalizedI = I + 1;

    //
    // Will hold distances to travel to the desired node;
    //
    ULONG ForwardDistance,BackwardDistance;

    //
    // Will point to the current element in the linked list.
    //
    PLIST_ENTRY CurrentNode = Table->OrderedPointer;


    //
    // If it's out of bounds get out quick.
    //

    if ((I == MAXULONG) || (NormalizedI > NumberInTable)) return NULL;

    //
    // If we're already at the node then return it.
    //

    if (NormalizedI == CurrentLocation) {

        return &((PTABLE_ENTRY_HEADER) CONTAINING_RECORD(CurrentNode, TABLE_ENTRY_HEADER, ListEntry))->UserData;
    }

    //
    // Calculate the forward and backward distance to the node.
    //

    if (CurrentLocation > NormalizedI) {

        //
        // When CurrentLocation is greater than where we want to go,
        // if moving forward gets us there quicker than moving backward
        // then it follows that moving forward from the listhead is
        // going to take fewer steps. (This is because, moving forward
        // in this case must move *through* the listhead.)
        //
        // The work here is to figure out if moving backward would be quicker.
        //
        // Moving backward would be quicker only if the location we wish  to
        // go to is more than half way between the listhead and where we
        // currently are.
        //

        if (NormalizedI > (CurrentLocation/2)) {

            //
            // Where we want to go is more than half way from the listhead
            // We can traval backwards from our current location.
            //

            for (
                BackwardDistance = CurrentLocation - NormalizedI;
                BackwardDistance;
                BackwardDistance--
                ) {

                CurrentNode = CurrentNode->Blink;

            }
        } else {

            //
            // Where we want to go is less than halfway between the start
            // and where we currently are.  Start from the listhead.
            //

            for (
                CurrentNode = &Table->InsertOrderList;
                NormalizedI;
                NormalizedI--
                ) {

                CurrentNode = CurrentNode->Flink;

            }

        }

    } else {


        //
        // When CurrentLocation is less than where we want to go,
        // if moving backwards gets us there quicker than moving forwards
        // then it follows that moving backwards from the listhead is
        // going to take fewer steps. (This is because, moving backwards
        // in this case must move *through* the listhead.)
        //

        ForwardDistance = NormalizedI - CurrentLocation;

        //
        // Do the backwards calculation as if we are starting from the
        // listhead.
        //

        BackwardDistance = (NumberInTable - NormalizedI) + 1;

        if (ForwardDistance <= BackwardDistance) {

            for (
                ;
                ForwardDistance;
                ForwardDistance--
                ) {

                CurrentNode = CurrentNode->Flink;

            }


        } else {

            for (
                CurrentNode = &Table->InsertOrderList;
                BackwardDistance;
                BackwardDistance--
                ) {

                CurrentNode = CurrentNode->Blink;

            }

        }

    }

    //
    // We're where we want to be.  Save our current location and return
    // a pointer to the data to the user.
    //

    Table->OrderedPointer = CurrentNode;
    Table->WhichOrderedElement = I+1;

    return &((PTABLE_ENTRY_HEADER) CONTAINING_RECORD(CurrentNode, TABLE_ENTRY_HEADER, ListEntry))->UserData;

}


ULONG
LLSNumberGenericTableElements(
    IN PLLS_GENERIC_TABLE Table
    )

/*++

Routine Description:

    The function NumberGenericTableElements returns a ULONG value
    which is the number of generic table elements currently inserted
    in the generic table.

Arguments:

    Table - Pointer to the generic table from which to find out the number
    of elements.


Return Value:

    ULONG - The number of elements in the generic table.

--*/
{

    return Table->NumberGenericTableElements;

}


PVOID
LLSEnumerateGenericTableWithoutSplaying (
    IN PLLS_GENERIC_TABLE Table,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    The function EnumerateGenericTableWithoutSplaying will return to the
    caller one-by-one the elements of of a table.  The return value is a
    pointer to the user defined structure associated with the element.
    The input parameter RestartKey indicates if the enumeration should
    start from the beginning or should return the next element.  If the
    are no more new elements to return the return value is NULL.  As an
    example of its use, to enumerate all of the elements in a table the
    user would write:

        *RestartKey = NULL;

        for (ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey);
             ptr != NULL;
             ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
                :
        }

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Pointer that indicates if we should restart or return the next
                element.  If the contents of RestartKey is NULL, the search
                will be started from the beginning.

Return Value:

    PVOID - Pointer to the user data.

--*/

{

    if (LLSIsGenericTableEmpty(Table)) {

        //
        // Nothing to do if the table is empty.
        //

        return NULL;

    } else {

        //
        // Will be used as the "iteration" through the tree.
        //
        PRTL_SPLAY_LINKS NodeToReturn;

        //
        // If the restart flag is true then go to the least element
        // in the tree.
        //

        if (*RestartKey == NULL) {

            //
            // We just loop until we find the leftmost child of the root.
            //

            for (
                NodeToReturn = Table->TableRoot;
                RtlLeftChild(NodeToReturn);
                NodeToReturn = RtlLeftChild(NodeToReturn)
                ) {
                ;
            }

            *RestartKey = NodeToReturn;

        } else {

            //
            // The caller has passed in the previous entry found
            // in the table to enable us to continue the search.  We call
            // RtlRealSuccessor to step to the next element in the tree.
            //

            NodeToReturn = RtlRealSuccessor(*RestartKey);

            if (NodeToReturn) {

                *RestartKey = NodeToReturn;

            }

        }

        //
        // If there actually is a next element in the enumeration
        // then the pointer to return is right after the list links.
        //

        return ((NodeToReturn)?
                   ((PVOID)&((PTABLE_ENTRY_HEADER)NodeToReturn)->UserData)
                  :((PVOID)(NULL)));

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\llssrv.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

   LlsSrv.h

Abstract:


Author:

   Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added certificate database support.

--*/

#ifndef _LLS_LLSSRV_H
#define _LLS_LLSSRV_H


#ifdef __cplusplus
extern "C" {
#endif

#define MAP_FILE_NAME         "LlsMap.LLS"
#define USER_FILE_NAME        "LlsUser.LLS"
#define LICENSE_FILE_NAME     "CPL.CFG"
#define CERT_DB_FILE_NAME     "LlsCert.LLS"

#define LLS_FILE_SUBDIR "LLS"


#define REPLICATE_DELTA 0
#define REPLICATE_AT    1

#define MAX_USERNAME_LENGTH 256
#define MAX_DOMAINNAME_LENGTH MAX_COMPUTERNAME_LENGTH


/////////////////////////////////////////////////////////////////////////
typedef struct _CONFIG_RECORD {
   SYSTEMTIME Started;
   DWORD Version;
   LPTSTR SystemDir;

   //
   // Replication Info
   //
   LPTSTR ComputerName;
   LPTSTR ReplicateTo;
   LPTSTR EnterpriseServer;
   DWORD EnterpriseServerDate;
   DWORD LogLevel;

   // When to replicate
   ULONG ReplicationType;
   ULONG ReplicationTime;
   DWORD UseEnterprise;

   DWORD LastReplicatedSeconds;
   DWORD NextReplication;
   SYSTEMTIME LastReplicated;

   ULONG NumReplicating;   // Number of machines currently replicating here
   ULONG BackoffTime;
   ULONG ReplicationSpeed;

   BOOL IsMaster;          // TRUE if is a Master Server (top of repl tree).
   BOOL Replicate;         // Whether this server replicates
   BOOL IsReplicating;     // TRUE if currently replicating
   BOOL PerServerCapacityWarning;   // TRUE -- warn when per server usage
                                    //         nears capacity
   LPTSTR SiteServer;      // Site license master server DNS name
} CONFIG_RECORD, *PCONFIG_RECORD;

typedef enum LICENSE_CAPACITY_STATE {
    LICENSE_CAPACITY_NORMAL,
    LICENSE_CAPACITY_NEAR_MAXIMUM,
    LICENSE_CAPACITY_AT_MAXIMUM,
    LICENSE_CAPACITY_EXCEEDED
};

extern CONFIG_RECORD ConfigInfo;
extern RTL_CRITICAL_SECTION ConfigInfoLock;

extern TCHAR MyDomain[];
extern ULONG MyDomainSize;

extern BOOL IsMaster;

extern TCHAR MappingFileName[];
extern TCHAR UserFileName[];
extern TCHAR LicenseFileName[];
extern TCHAR CertDbFileName[];

extern RTL_CRITICAL_SECTION g_csLock;

DWORD LlsTimeGet();
VOID ConfigInfoUpdate(DOMAIN_CONTROLLER_INFO * pDCInfo);
VOID ConfigInfoRegistryUpdate( );
DWORD EnsureInitialized ( VOID );

/////////////////////////////////////////////////////////////////////////
#if DBG

VOID ConfigInfoDebugDump();
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\llsutil.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    LlsUtil.c

Abstract:


Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

   Jeff Parham (jeffparh) 12-Jan-1996
      o  Added WinNtBuildNumberGet() to ascertain the Windows NT build number
         running on a given machine.
      o  Enhanced output of TimeToString().

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>
#include <stdlib.h>
#include <crypt.h>
#include <wchar.h>
#include <dsgetdc.h>

#include "debug.h"
#include "llssrv.h"
#include "llsevent.h"


//
// NB : Keep this define in sync with client\llsrpc.rc.
//
#define IDS_LICENSEWARNING  1501

const char HeaderString[] = "License Logging System Data File\x01A";
#define HEADER_SIZE 34

typedef struct _LLS_FILE_HEADER {
   char Header[HEADER_SIZE];
   DWORD Version;
   DWORD DataSize;
} LLS_FILE_HEADER, *PLLS_FILE_HEADER;


extern HANDLE gLlsDllHandle;

static HANDLE ghWarningDlgThreadHandle = NULL;

VOID WarningDlgThread( PVOID ThreadParameter );


/////////////////////////////////////////////////////////////////////////
NTSTATUS
EBlock(
   PVOID Data,
   ULONG DataSize
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   DATA_KEY PublicKey;
   CRYPT_BUFFER CryptBuffer;

   //
   // Init our public key
   //
   PublicKey.Length = 4;
   PublicKey.MaximumLength = 4;
   PublicKey.Buffer = LocalAlloc(LPTR, 4);

   if (PublicKey.Buffer != NULL) {
      ((char *) (PublicKey.Buffer))[0] = '7';
      ((char *) (PublicKey.Buffer))[1] = '7';
      ((char *) (PublicKey.Buffer))[2] = '7';
      ((char *) (PublicKey.Buffer))[3] = '7';

      CryptBuffer.Length = DataSize;
      CryptBuffer.MaximumLength = DataSize;
      CryptBuffer.Buffer = (PVOID) Data;
      Status = RtlEncryptData2(&CryptBuffer, &PublicKey);

      LocalFree(PublicKey.Buffer);
   } else
      Status = STATUS_NO_MEMORY;

   return Status;
} // EBlock


/////////////////////////////////////////////////////////////////////////
NTSTATUS
DeBlock(
   PVOID Data,
   ULONG DataSize
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   DATA_KEY PublicKey;
   CRYPT_BUFFER CryptBuffer;

   //
   // Init our public key
   //
   PublicKey.Length = 4;
   PublicKey.MaximumLength = 4;
   PublicKey.Buffer = LocalAlloc(LPTR, 4);
   if (PublicKey.Buffer != NULL) {
      ((char *) (PublicKey.Buffer))[0] = '7';
      ((char *) (PublicKey.Buffer))[1] = '7';
      ((char *) (PublicKey.Buffer))[2] = '7';
      ((char *) (PublicKey.Buffer))[3] = '7';

      CryptBuffer.Length = DataSize;
      CryptBuffer.MaximumLength = DataSize;
      CryptBuffer.Buffer = (PVOID) Data;
      Status = RtlDecryptData2(&CryptBuffer, &PublicKey);

      LocalFree(PublicKey.Buffer);
   } else
      Status = STATUS_NO_MEMORY;

   return Status;
} // DeBlock


/////////////////////////////////////////////////////////////////////////
BOOL
FileExists(
   LPTSTR FileName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   return (BOOL) RtlDoesFileExists_U(FileName);

} // FileExists


/////////////////////////////////////////////////////////////////////////
VOID
lsplitpath(
   const TCHAR *path,
   TCHAR *drive,
   TCHAR *dir,
   TCHAR *fname,
   TCHAR *ext
   )

/*++

Routine Description:
   Splits a path name into its individual components

   Took the _splitpath and _makepath routines and converted them to
   be NT (long file name) and Unicode friendly.

Arguments:
   Entry:
     path  - pointer to path name to be parsed
     drive - pointer to buffer for drive component, if any
     dir   - pointer to buffer for subdirectory component, if any
     fname - pointer to buffer for file base name component, if any
     ext   - pointer to buffer for file name extension component, if any

   Exit:
     drive - pointer to drive string.  Includes ':' if a drive was given.
     dir   - pointer to subdirectory string.  Includes leading and
             trailing '/' or '\', if any.
     fname - pointer to file base name
     ext   - pointer to file extension, if any.  Includes leading '.'.

Return Value:


--*/

{
    TCHAR *p;
    TCHAR *last_slash = NULL, *dot = NULL;
    SIZE_T len;

    // init these so we don't exit with bogus values
    drive[0] = TEXT('\0');
    dir[0] = TEXT('\0');
    fname[0] = TEXT('\0');
    ext[0] = TEXT('\0');

    if (path[0] == TEXT('\0'))
      return;

    /*+---------------------------------------------------------------------+
      | Assume that the path argument has the following form, where any or  |
      | all of the components may be missing.                               |
      |                                                                     |
      |  <drive><dir><fname><ext>                                           |
      |                                                                     |
      |  drive:                                                             |
      |     0 to MAX_DRIVE-1 characters, the last of which, if any, is a    |
      |     ':' or a '\' in the case of a UNC path.                         |
      |  dir:                                                               |
      |     0 to _MAX_DIR-1 characters in the form of an absolute path      |
      |     (leading '/' or '\') or relative path, the last of which, if    |
      |     any, must be a '/' or '\'.  E.g -                               |
      |                                                                     |
      |     absolute path:                                                  |
      |        \top\next\last\     ; or                                     |
      |        /top/next/last/                                              |
      |     relative path:                                                  |
      |        top\next\last\  ; or                                         |
      |        top/next/last/                                               |
      |     Mixed use of '/' and '\' within a path is also tolerated        |
      |  fname:                                                             |
      |     0 to _MAX_FNAME-1 characters not including the '.' character    |
      |  ext:                                                               |
      |     0 to _MAX_EXT-1 characters where, if any, the first must be a   |
      |     '.'                                                             |
      +---------------------------------------------------------------------+*/

    // extract drive letter and :, if any
    if ( path[0] && (path[1] == TEXT(':')) ) {
        if (drive) {
            drive[0] = path[0];
            drive[1] = path[1];
            drive[2] = TEXT('\0');
        }
        path += 2;
    }

    // if no drive then check for UNC pathname
    if (drive[0] == TEXT('\0'))
      if ((path[0] == TEXT('\\')) && (path[1] == TEXT('\\'))) {
         // got a UNC path so put server-sharename into drive
         drive[0] = path[0];
         drive[1] = path[1];
         path += 2;

         p = &drive[2];
         while ((*path != TEXT('\0')) && (*path != TEXT('\\')))
            *p++ = *path++;

         if (*path == TEXT('\0'))
            return;

         // now sitting at the share - copy this as well (copy slash first)
         *p++ = *path++;
         while ((*path != TEXT('\0')) && (*path != TEXT('\\')))
            *p++ = *path++;

         // tack on terminating NULL
         *p = TEXT('\0');
      }

    /*+---------------------------------------------------------------------+
      | extract path string, if any.  Path now points to the first character|
      | of the path, if any, or the filename or extension, if no path was   |
      | specified.  Scan ahead for the last occurence, if any, of a '/' or  |
      | '\' path separator character.  If none is found, there is no path.  |
      | We will also note the last '.' character found, if any, to aid in   |
      | handling the extension.                                             |
      +---------------------------------------------------------------------+*/

    for (last_slash = NULL, p = (TCHAR *)path; *p; p++) {
        if (*p == TEXT('/') || *p == TEXT('\\'))
            // point to one beyond for later copy
            last_slash = p + 1;
        else if (*p == TEXT('.'))
            dot = p;
    }

    if (last_slash) {

        // found a path - copy up through last_slash or max. characters allowed,
        //  whichever is smaller
        if (dir) {
            len = __min((last_slash - path), (_MAX_DIR - 1));
            lstrcpyn(dir, path, (int)len + 1);
            dir[len] = TEXT('\0');
        }
        path = last_slash;
    }

    /*+---------------------------------------------------------------------+
      | extract file name and extension, if any.  Path now points to the    |
      | first character of the file name, if any, or the extension if no    |
      | file name was given.  Dot points to the '.' beginning the extension,|
      | if any.                                                             |
      +---------------------------------------------------------------------+*/

    if (dot && (dot >= path)) {
        // found the marker for an extension - copy the file name up to the
        //  '.'.
        if (fname) {
            len = __min((dot - path), (_MAX_FNAME - 1));
            lstrcpyn(fname, path, (int)len + 1);
            *(fname + len) = TEXT('\0');
        }

        // now we can get the extension - remember that p still points to the
        // terminating nul character of path.
        if (ext) {
            len = __min((p - dot), (_MAX_EXT - 1));
            lstrcpyn(ext, dot, (int)len + 1);
            ext[len] = TEXT('\0');
        }
    }
    else {
        // found no extension, give empty extension and copy rest of string
        // into fname.
        if (fname) {
            len = __min((p - path), (_MAX_FNAME - 1));
            lstrcpyn(fname, path, (int)len + 1);
            fname[len] = TEXT('\0');
        }
        if (ext) {
            *ext = TEXT('\0');
        }
    }

} // lsplitpath


/////////////////////////////////////////////////////////////////////////
VOID
lmakepath(
   TCHAR *path,
   const TCHAR *drive,
   const TCHAR *dir,
   const TCHAR *fname,
   const TCHAR *ext
   )

/*++

Routine Description:
   Create a path name from its individual components.

Arguments:
   Entry:
     char *path - pointer to buffer for constructed path
     char *drive - pointer to drive component, may or may not contain
         trailing ':'
     char *dir - pointer to subdirectory component, may or may not include
         leading and/or trailing '/' or '\' characters
     char *fname - pointer to file base name component
     char *ext - pointer to extension component, may or may not contain
         a leading '.'.

   Exit:
     path - pointer to constructed path name

Return Value:


--*/

{
    const TCHAR *p;

    /*+---------------------------------------------------------------------+
      | we assume that the arguments are in the following form (although we |
      | do not diagnose invalid arguments or illegal filenames (such as     |
      | names longer than 8.3 or with illegal characters in them)           |
      |                                                                     |
      |  drive:                                                             |
      |     A  or  A:                                                       |
      |  dir:                                                               |
      |     \top\next\last\     ; or                                        |
      |     /top/next/last/     ; or                                        |
      |                                                                     |
      |     either of the above forms with either/both the leading and      |
      |     trailing / or \ removed.  Mixed use of '/' and '\' is also      |
      |      tolerated                                                      |
      |  fname:                                                             |
      |     any valid file name                                             |
      |  ext:                                                               |
      |     any valid extension (none if empty or null )                    |
      +---------------------------------------------------------------------+*/

    // copy drive
    if (drive && *drive)
        while (*drive)
           *path++ = *drive++;

    // copy dir
    if ((p = dir) && *p) {
        do {
            *path++ = *p++;
        }
        while (*p);
        if ((*(p-1) != TEXT('/')) && (*(p-1) != TEXT('\\'))) {
            *path++ = TEXT('\\');
        }
    }

    // copy fname
    if (p = fname) {
        while (*p) {
            *path++ = *p++;
        }
    }

    // copy ext, including 0-terminator - check to see if a '.' needs to be
    // inserted.
    if (p = ext) {
        if (*p && *p != TEXT('.')) {
            *path++ = TEXT('.');
        }
        while (*path++ = *p++)
            ;
    }
    else {
        // better add the 0-terminator
        *path = TEXT('\0');
    }

} // lmakepath


/////////////////////////////////////////////////////////////////////////
VOID
FileBackupCreate(
   LPTSTR Path
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   HANDLE hFile = NULL;
   DWORD dwFileNumber = 0;
   TCHAR Drive[_MAX_DRIVE + 1];
   TCHAR Dir[_MAX_DIR + 1];
   TCHAR FileName[_MAX_FNAME + 1];
   TCHAR Ext[_MAX_EXT + 1];
   TCHAR NewExt[_MAX_EXT + 1];
   TCHAR NewPath[MAX_PATH + 1];

   //
   // Make sure file exists
   //
   if (!FileExists(FileName))
      return;

   //
   // Split name into constituent parts...
   //
   lsplitpath(Path, Drive, Dir, FileName, Ext);

   // Find next backup number...
   // Files are backed up as .xxx where xxx is a number in the form .001,
   // the first backup is stored as .001, second as .002, etc...
   do {
      //
      // Create new file name with backup extension
      //
      dwFileNumber++;
      wsprintf(NewExt, TEXT("%03u"), dwFileNumber);
      lmakepath(NewPath, Drive, Dir, FileName, NewExt);

   } while ( FileExists(NewPath) );

   MoveFile( Path, NewPath );

} // FileBackupCreate


/////////////////////////////////////////////////////////////////////////
HANDLE
LlsFileInit(
   LPTSTR FileName,
   DWORD Version,
   DWORD DataSize
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   HANDLE hFile = NULL;
   LLS_FILE_HEADER Header;
   DWORD BytesWritten;

#ifdef DEBUG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: LlsFileInit\n"));
#endif

   if (FileName == NULL)
      return NULL;

   strcpy(Header.Header, HeaderString);
   Header.Version = Version;
   Header.DataSize = DataSize;

   SetFileAttributes(FileName, FILE_ATTRIBUTE_NORMAL);
   hFile = CreateFile(FileName, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
   if (hFile != INVALID_HANDLE_VALUE) {
      if (!WriteFile(hFile, &Header, sizeof(LLS_FILE_HEADER), &BytesWritten, NULL)) {
         CloseHandle(hFile);
         hFile = NULL;
      }
   } else {
       return NULL;
   }

   return hFile;
} // LlsFileInit


/////////////////////////////////////////////////////////////////////////
HANDLE
LlsFileCheck(
   LPTSTR FileName,
   LPDWORD Version,
   LPDWORD DataSize
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   BOOL FileOK = FALSE;
   HANDLE hFile = NULL;
   LLS_FILE_HEADER Header;
   DWORD FileSize;
   DWORD BytesRead;

#ifdef DEBUG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: LlsFileCheck\n"));
#endif

   if (FileName == NULL)
      return NULL;

   //
   // We are assuming the file exists
   //
   SetFileAttributes(FileName, FILE_ATTRIBUTE_NORMAL);
   hFile = CreateFile(FileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
   if (hFile != INVALID_HANDLE_VALUE) {
      FileSize = GetFileSize(hFile, NULL);

      //
      // Make sure there is enough data there to read
      //
      if (FileSize > (sizeof(LLS_FILE_HEADER) + 1)) {
         if (ReadFile(hFile, &Header, sizeof(LLS_FILE_HEADER), &BytesRead, NULL)) {
            if ( !_strcmpi(Header.Header, HeaderString) ) {
               //
               // Data checks out - so return datalength
               //
               *Version = Header.Version;
               *DataSize = Header.DataSize;
               FileOK = TRUE;
            }
         }
      }

      //
      // If we opened the file and something was wrong - close it.
      //
      if (!FileOK) {
         CloseHandle(hFile);
         hFile = NULL;
      }
   } else {
       return NULL;
   }

   return hFile;

} // LlsFileCheck


/////////////////////////////////////////////////////////////////////////
DWORD
DateSystemGet(
   )

/*++

Routine Description:


Arguments:


Return Value:

   Seconds since midnight.

--*/

{
   DWORD Seconds = 0;
   LARGE_INTEGER SysTime;

   NtQuerySystemTime(&SysTime);
   RtlTimeToSecondsSince1980(&SysTime, &Seconds);
   return Seconds;

} // DateSystemGet


/////////////////////////////////////////////////////////////////////////
DWORD
DateLocalGet(
   )

/*++

Routine Description:


Arguments:


Return Value:

   Seconds since midnight.

--*/

{
   DWORD Seconds = 0;
   LARGE_INTEGER SysTime, LocalTime;

   NtQuerySystemTime(&SysTime);
   RtlSystemTimeToLocalTime(&SysTime, &LocalTime);
   RtlTimeToSecondsSince1980(&LocalTime, &Seconds);
   return Seconds;

} // DateLocalGet


/////////////////////////////////////////////////////////////////////////
DWORD
InAWorkgroup(
    VOID
    )
/*++

Routine Description:

    This function determines whether we are a member of a domain, or of
    a workgroup.  First it checks to make sure we're running on a Windows NT
    system (otherwise we're obviously in a domain) and if so, queries LSA
    to get the Primary domain SID, if this is NULL, we're in a workgroup.

    If we fail for some random unexpected reason, we'll pretend we're in a
    workgroup (it's more restrictive).

Arguments:
    None

Return Value:

    TRUE   - We're in a workgroup
    FALSE  - We're in a domain

--*/
{
   NT_PRODUCT_TYPE ProductType;
   OBJECT_ATTRIBUTES ObjectAttributes;
   LSA_HANDLE Handle;
   NTSTATUS Status;
   PPOLICY_PRIMARY_DOMAIN_INFO PolicyPrimaryDomainInfo = NULL;
   DWORD Result = FALSE;


   Status = RtlGetNtProductType(&ProductType);

   if (!NT_SUCCESS(Status)) {
#if DBG
       dprintf(TEXT("ERROR LLS Could not get Product type\n"));
#endif
       return TRUE;
   }

   if (ProductType == NtProductLanManNt) {
       return(FALSE);
   }

   InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);

   Status = LsaOpenPolicy(NULL,
                       &ObjectAttributes,
                       POLICY_VIEW_LOCAL_INFORMATION,
                       &Handle);

   if (!NT_SUCCESS(Status)) {
#if DBG
       dprintf(TEXT("ERROR LLS: Could not open LSA Policy Database\n"));
#endif
      return TRUE;
   }

   Status = LsaQueryInformationPolicy(Handle, PolicyPrimaryDomainInformation,
      (PVOID *) &PolicyPrimaryDomainInfo);

   if (NT_SUCCESS(Status)) {

       if (PolicyPrimaryDomainInfo->Sid == NULL) {
          Result = TRUE;
       }
       else {
          Result = FALSE;
       }
   }

   if (PolicyPrimaryDomainInfo) {
       LsaFreeMemory((PVOID)PolicyPrimaryDomainInfo);
   }

   LsaClose(Handle);

   return(Result);
} // InAWorkgroup

/////////////////////////////////////////////////////////////////////////
VOID
LogEvent(
    DWORD MessageId,
    DWORD NumberOfSubStrings,
    LPWSTR *SubStrings,
    DWORD ErrorCode
    )
{

    HANDLE LogHandle;
    WORD wEventType;

    LogHandle = RegisterEventSourceW (
                    NULL,
                    TEXT("LicenseService")
                    );

    if (LogHandle == NULL) {
#if DBG
        dprintf(TEXT("LLS RegisterEventSourceW failed %lu\n"), GetLastError());
#endif
        return;
    }

    switch ( MessageId >> 30 )
    {
    case STATUS_SEVERITY_INFORMATIONAL:
    case STATUS_SEVERITY_SUCCESS:
        wEventType = EVENTLOG_INFORMATION_TYPE;
        break;
    case STATUS_SEVERITY_WARNING:
        wEventType = EVENTLOG_WARNING_TYPE;
        break;
    case STATUS_SEVERITY_ERROR:
    default:
        wEventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    if (ErrorCode == ERROR_SUCCESS) {

        //
        // No error codes were specified
        //
        (void) ReportEventW(
                   LogHandle,
                   wEventType,
                   0,            // event category
                   MessageId,
                   NULL,
                   (WORD)NumberOfSubStrings,
                   0,
                   SubStrings,
                   (PVOID) NULL
                   );

    }
    else {

        //
        // Log the error code specified
        //
        (void) ReportEventW(
                   LogHandle,
                   wEventType,
                   0,            // event category
                   MessageId,
                   NULL,
                   (WORD)NumberOfSubStrings,
                   sizeof(DWORD),
                   SubStrings,
                   (PVOID) &ErrorCode
                   );
    }

    DeregisterEventSource(LogHandle);
} // LogEvent

#define THROTTLE_WRAPAROUND 24

//
// Reduce the frequency of logging
// No need for the limit to be exact
//

/////////////////////////////////////////////////////////////////////////
VOID
ThrottleLogEvent(
    DWORD MessageId,
    DWORD NumberOfSubStrings,
    LPWSTR *SubStrings,
    DWORD ErrorCode
    )
{
    static LONG lLogged = THROTTLE_WRAPAROUND;
    LONG lResult;

    lResult = InterlockedIncrement(&lLogged);

    if (THROTTLE_WRAPAROUND <= lResult)
    {
        LogEvent(
                 MessageId,
                 NumberOfSubStrings,
                 SubStrings,
                 ErrorCode );

        lLogged = 0;
    }
}

/////////////////////////////////////////////////////////////////////////
VOID
LicenseCapacityWarningDlg(DWORD dwCapacityState)
{
    //
    // NB : The ServiceLock critical section is entered for the duration
    //      of this routine. No serialization issues.
    //

    if (ghWarningDlgThreadHandle == NULL) {
        //
        // No action necessary if this fails.
        //
        DWORD   Ignore;
        DWORD * pWarningMessageID;

        pWarningMessageID = LocalAlloc(LPTR, sizeof(DWORD));

        if ( pWarningMessageID != NULL ) {
            switch( dwCapacityState ) {
            case LICENSE_CAPACITY_NEAR_MAXIMUM:
                *pWarningMessageID = LLS_EVENT_NOTIFY_LICENSES_NEAR_MAX;
                break;

            case LICENSE_CAPACITY_AT_MAXIMUM:
                *pWarningMessageID = LLS_EVENT_NOTIFY_LICENSES_AT_MAX;
                break;

            case LICENSE_CAPACITY_EXCEEDED:
                *pWarningMessageID = LLS_EVENT_NOTIFY_LICENSES_EXCEEDED;
                break;

            default:
                *pWarningMessageID = LLS_EVENT_NOTIFY_LICENSES_EXCEEDED;
            };

            ghWarningDlgThreadHandle = CreateThread(NULL,
                                                    0L,
                                                    (LPTHREAD_START_ROUTINE)
                                                        WarningDlgThread,
                                                    pWarningMessageID,
                                                    0L,
                                                    &Ignore);

            if (ghWarningDlgThreadHandle == NULL)
            {
                //
                // CreateThread failed
                //
                LocalFree(pWarningMessageID);
            }
        }
    }
}


/////////////////////////////////////////////////////////////////////////
VOID
WarningDlgThread(
    PVOID ThreadParameter)
{
    LPTSTR  pszWarningMessage = NULL;
    DWORD * pWarningMessageID;
    HANDLE  hThread;
    TCHAR   szWarningTitle[256] = TEXT("");

    ASSERT(ThreadParameter != NULL);

    pWarningMessageID = (DWORD *)ThreadParameter;

    //
    // NB : The .dll should already have been loaded in MasterServiceListInit
    //      on service startup. This logic exists here for the case where
    //      the code invoked on initialization should fail.
    //
    //      It is OK if another thread should simulataneously initialize
    //      gLlsDllHandle. Worst case, there will be an orphaned handle
    //      to the .dll. But the .dll is loaded for the lifetime of this
    //      .exe, so no big deal.
    //

    if ( gLlsDllHandle == NULL ) {
        gLlsDllHandle = LoadLibrary(TEXT("LLSRPC.DLL"));
    }

    if ( gLlsDllHandle != NULL) {
        DWORD ccWarningMessage;

        //
        // Fetch the dialog title.
        //

        LoadString(gLlsDllHandle,
                   IDS_LICENSEWARNING,
                   szWarningTitle,
                   sizeof(szWarningTitle)/sizeof(TCHAR));

        //
        // Fetch the dialog message.
        //

        ccWarningMessage = FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |
                                            FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         gLlsDllHandle,
                                         *pWarningMessageID,
                                         0,
                                         (LPTSTR)&pszWarningMessage,
                                         0,
                                         NULL);

        if ( ccWarningMessage > 2 ) {
            //
            // Strip the trailing <CR><LF> format message always adds.
            //

            pszWarningMessage[ccWarningMessage - 2] = TEXT('\0');

            MessageBox(NULL,
                       pszWarningMessage,
                       szWarningTitle,
                       MB_ICONWARNING | MB_OK | MB_SYSTEMMODAL |
                            MB_SERVICE_NOTIFICATION);
        }

        if ( pszWarningMessage != NULL) {
            LocalFree(pszWarningMessage);
        }
    }

    LocalFree(pWarningMessageID);

    //
    // By closing the handle, we allow the system to remove all remaining
    // traces of this thread.
    //

    hThread = ghWarningDlgThreadHandle;
    ghWarningDlgThreadHandle = NULL;
    CloseHandle(hThread);
}

/////////////////////////////////////////////////////////////////////////
DWORD WinNtBuildNumberGet( LPTSTR pszServerName, LPDWORD pdwBuildNumber )

/*++

Routine Description:

   Retrieve the build number of Windows NT running on a given machine.

Arguments:

   pszServerName (LPTSTR)
      Name of the server to check.
   pdwBuildNumber (LPDWORD)
      On return, holds the build number of the server (e.g., 1057 for the
      release version of Windows NT 3.51).

Return Value:

   ERROR_SUCCESS or Win error code.

--*/

{
   LONG     lError;
   HKEY     hKeyLocalMachine;

   lError = RegConnectRegistry( pszServerName, HKEY_LOCAL_MACHINE, &hKeyLocalMachine );

   if ( ERROR_SUCCESS != lError )
   {
#if DBG
      dprintf( TEXT("WinNtBuildNumberGet(): Could not connect to remote registry, error %ld.\n"), lError );
#endif
   }
   else
   {
      HKEY     hKeyCurrentVersion;

      lError = RegOpenKeyEx( hKeyLocalMachine,
                             TEXT( "Software\\Microsoft\\Windows NT\\CurrentVersion" ),
                             0,
                             KEY_READ,
                             &hKeyCurrentVersion );

      if ( ERROR_SUCCESS != lError )
      {
#if DBG
         dprintf( TEXT("WinNtBuildNumberGet(): Could not open key, error %ld.\n"), lError );
#endif
      }
      else
      {
         DWORD    dwType;
         TCHAR    szWinNtBuildNumber[ 16 ];
         DWORD    cbWinNtBuildNumber = sizeof( szWinNtBuildNumber );

         lError = RegQueryValueEx( hKeyCurrentVersion,
                                   TEXT( "CurrentBuildNumber" ),
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &szWinNtBuildNumber,
                                   &cbWinNtBuildNumber );

         if ( ERROR_SUCCESS != lError )
         {
#if DBG
            dprintf( TEXT("WinNtBuildNumberGet(): Could not query value, error %ld.\n"), lError );
#endif
         }
         else
         {
            *pdwBuildNumber = (DWORD) _wtol( szWinNtBuildNumber );
         }

         RegCloseKey( hKeyCurrentVersion );
      }

      RegCloseKey( hKeyLocalMachine );
   }

   return (DWORD) lError;
}


#if DBG

/////////////////////////////////////////////////////////////////////////
LPTSTR
TimeToString(
    ULONG Seconds
    )
{
   TIME_FIELDS tf;
   LARGE_INTEGER Time, LTime;
   static TCHAR TimeString[100];

   if ( 0 == Seconds )
   {
      lstrcpy(TimeString, TEXT("None"));
   }
   else
   {
      RtlSecondsSince1980ToTime(Seconds, &Time);
      RtlSystemTimeToLocalTime(&Time, &LTime);
      RtlTimeToTimeFields(&LTime, &tf);

      wsprintf(TimeString, TEXT("%02hd/%02hd/%04hd @ %02hd:%02hd:%02hd"), tf.Month, tf.Day, tf.Year, tf.Hour, tf.Minute, tf.Second);
   }

   return TimeString;

} // TimeToString

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\llssrv.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

   llssrv.c

Abstract:

   Main routine to setup the exception handlers and initialize everything
   to listen to LPC and RPC port requests.

Author:

   Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added certificate database support.
      o  Expanded file load time (the update limit sent to the service
         controller) to account for certificate database loading.
      o  Reordered initialization such that the license purchase subsystem
         is initialized before the service subsystem.  (The service
         subsystem now uses the license subsystem.)
      o  Increased internal version number.

--*/

#include <nt.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>

#define COBJMACROS
#include <objbase.h>
#include <iads.h>
#include <adshlp.h>
#include <adserr.h>

#include <lm.h>
#include <alertmsg.h>
#include <winsock2.h>

#include <dsgetdc.h>
#include <ntdsapi.h>

#include "llsapi.h"
#include "debug.h"
#include "llsutil.h"
#include "llssrv.h"
#include "service.h"
#include "registry.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "perseat.h"
#include "purchase.h"
#include "server.h"
#include "repl.h"
#include "scaven.h"
#include "llsrpc_s.h"
#include "certdb.h"


BOOL    CompareMachineName(
                LPCWSTR pwszName1,
                LPCWSTR pwszName2);
VOID    DNSToFlatName(
                LPCWSTR pwszDNSName,
                DWORD   ccBufferLen,
                LPWSTR  pwszBuffer);
NTSTATUS GetDCInfo(
                DWORD                     ccDomain,
                WCHAR                     wszDomain[],
                DOMAIN_CONTROLLER_INFO ** ppDCInfo);
HRESULT GetSiteServer(
                LPCWSTR  pwszDomain,
                LPCWSTR  pwszSiteName,
                BOOL     fIsDC,
                LPWSTR * ppwszSiteServer);
HRESULT
BecomeSiteServer(
                DS_NAME_RESULT **ppDsResult,
                IADs           *pADs2,
                LPWSTR         *ppwszDN,
                LPCWSTR        pwszDomain);

LPWSTR  GetSiteServerFromRegistry(
                VOID);
LPWSTR  GetEnterpriseServerFromRegistry(
                VOID);
HRESULT GetLicenseSettingsObject(
                LPCWSTR pwszSiteName,
                LPCWSTR pwszConfigContainer,
                IADs ** ppADs);
HRESULT GetSiteObject(
                LPCWSTR pwszSiteName,
                LPCWSTR pwszConfigContainer,
                IADsContainer ** ppADsContainer);
HRESULT CreateLicenseSettingsObject(
                LPCWSTR pwszSiteName,
                LPCWSTR pwszConfigContainer,
                IADs ** ppADs);
BOOL    IsDC(
                VOID);
VOID    LLSRpcInit();
BOOLEAN LLSpLPCInitialize(
                VOID);
VOID    LoadAll();
VOID    SetSiteRegistrySettings(
                LPCWSTR pwszSiteServer);

NTSTATUS FilePrintTableInit();

#define INTERNAL_VERSION 0x0006

#define DEFAULT_LICENSE_CHECK_TIME 24
#define DEFAULT_REPLICATION_TIME   12 * 60 * 60

CONFIG_RECORD ConfigInfo;
RTL_CRITICAL_SECTION ConfigInfoLock;


#if DBG
DWORD TraceFlags = 0;
#endif

//
// this event is signalled when the service should end
//
HANDLE  hServerStopEvent = NULL;
TCHAR MyDomain[MAX_COMPUTERNAME_LENGTH + 2];
ULONG MyDomainSize;

BOOL IsMaster = FALSE;

//
// Files
//
TCHAR MappingFileName[MAX_PATH + 1];
TCHAR UserFileName[MAX_PATH + 1];
TCHAR LicenseFileName[MAX_PATH + 1];
TCHAR CertDbFileName[MAX_PATH + 1];

extern SERVICE_STATUS_HANDLE sshStatusHandle;

RTL_CRITICAL_SECTION g_csLock;
volatile BOOL g_fInitializationComplete = FALSE;
volatile BOOL g_fDoingInitialization = FALSE;

HANDLE g_hThrottleConfig = NULL;

/////////////////////////////////////////////////////////////////////////
NTSTATUS
GetDCInfo(
   DWORD                     ccDomain,
   WCHAR                     wszDomain[],
   DOMAIN_CONTROLLER_INFO ** ppDCInfo
   )

/*++

Routine Description:


Arguments:


Return Value:

   None.

--*/

{
    DWORD Status;

    Status = DsGetDcNameW(NULL,
                          NULL,
                          NULL,
                          NULL,
                          DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_FLAT_NAME | DS_BACKGROUND_ONLY,
                          ppDCInfo);

    if (Status == STATUS_SUCCESS) {
        wcsncpy(wszDomain, (*ppDCInfo)->DomainName, ccDomain);
    }
    else {
        *wszDomain = L'\0';
        *ppDCInfo  = NULL;
    }

    return(Status);
} // GetDCInfo


/////////////////////////////////////////////////////////////////////////
DWORD
LlsTimeGet(
   )

/*++

Routine Description:


Arguments:


Return Value:

   Seconds since midnight.

--*/

{
   DWORD Seconds;
   SYSTEMTIME SysTime;

   GetLocalTime(&SysTime);

   Seconds = (SysTime.wHour * 24 * 60) + (SysTime.wMinute * 60) + (SysTime.wSecond);
   return Seconds;

} // LlsTimeGet


/////////////////////////////////////////////////////////////////////////
VOID
ConfigInfoRegistryUpdate( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DWORD ReplicationType, ReplicationTime;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ConfigInfoRegistryUpdate\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   ConfigInfoUpdate(NULL);

   RtlEnterCriticalSection(&ConfigInfoLock);

   //
   // Update values from Registry
   //
   ReplicationTime = ConfigInfo.ReplicationTime;
   ReplicationType = ConfigInfo.ReplicationType;
   ConfigInfoRegistryInit( &ConfigInfo.ReplicationType,
                           &ConfigInfo.ReplicationTime,
                           &ConfigInfo.LogLevel,
                           &ConfigInfo.PerServerCapacityWarning );

   if ( (ConfigInfo.ReplicationTime == 0) && (LLS_REPLICATION_TYPE_TIME != ConfigInfo.ReplicationType) )
      ConfigInfo.ReplicationTime = DEFAULT_REPLICATION_TIME;

   //
   // Adjust replication time if it has changed
   //
   if ((ReplicationTime != ConfigInfo.ReplicationTime) || (ReplicationType != ConfigInfo.ReplicationType))
      ReplicationTimeSet();

   RtlLeaveCriticalSection(&ConfigInfoLock);

} // ConfigInfoRegistryUpdate


/////////////////////////////////////////////////////////////////////////
VOID
ConfigInfoUpdate(
    DOMAIN_CONTROLLER_INFO * pDCInfo
    )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
    BOOL   fIsDC                          = FALSE;
    BOOL   fSiteServerFromRegistry        = FALSE;
    BOOL   fInDomain                      = FALSE;
    LPWSTR pwszSiteName                   = NULL;
    LPWSTR pwszSiteServer                 = NULL;
    LPWSTR pwszPropagationTarget          = NULL;
    DOMAIN_CONTROLLER_INFO * pDCInfoLocal = NULL;
    DWORD  ReplicationType, ReplicationTime;
    TCHAR  pDomain[MAX_COMPUTERNAME_LENGTH + 1] = { TEXT('\0') };
    DWORD  dwWait;

#if DBG
    if (TraceFlags & TRACE_FUNCTION_TRACE)
        dprintf(TEXT("LLS TRACE: ConfigInfoUpdate2\n"));
#endif

    dwWait = WaitForSingleObject(g_hThrottleConfig, 0);

    if (dwWait == WAIT_TIMEOUT)
    {
        // We've already updated in the past 15 minutes; return immediately
        return;
    }

    //
    // Get domain/DC information.
    //
    if (pDCInfo == NULL) {
        GetDCInfo(MAX_COMPUTERNAME_LENGTH + 1,
                  pDomain,
                  &pDCInfoLocal);
        pDCInfo = pDCInfoLocal;
    }
    else {
        //
        // Copy the domain name.
        //
        if (pDCInfo->DomainName != NULL) {
            wcsncpy(pDomain, pDCInfo->DomainName, MAX_COMPUTERNAME_LENGTH);
        }
    }

    if (*pDomain) {
        fInDomain = TRUE;

        if (NO_ERROR != DsGetSiteName(NULL, &pwszSiteName))
        {
            pwszSiteName = NULL;
        }

        fIsDC     = IsDC();

        if (fIsDC && (NULL != pwszSiteName)) {
            GetSiteServer(pDomain, pwszSiteName, fIsDC, &pwszSiteServer);
        }

    }

    if (!fIsDC) {

        //
        // Domain or Workgroup member
        //

        pwszSiteServer = GetSiteServerFromRegistry();

        fSiteServerFromRegistry = TRUE;
    }

    if ( fIsDC ) {
        //
        // This server is a DC. Propagate to the site server.
        //

        if (pwszSiteServer == NULL) {
            //
            // The attempt to obtain it from the DS failed, default to
            // the local registry.
            //
            pwszSiteServer          = GetSiteServerFromRegistry();
            fSiteServerFromRegistry = TRUE;
        }

        pwszPropagationTarget = pwszSiteServer;
    }
    else if ( fInDomain ) {
        //
        // This server is a member server. Propagate to a DC, providing
        // it is in the same site as this server; else, propagate
        // directly to the site server.
        //

        if (pDCInfo != NULL && pwszSiteName != NULL &&
            pDCInfo->DcSiteName != NULL &&
            lstrcmpi(pwszSiteName, pDCInfo->DcSiteName) == 0) {

            //
            // DC and server are in same site. Propagate to DC.
            //
            // Create DC name copy so the info struct can be freed.
            //
            if (pDCInfo->DomainControllerName != NULL) {
                pwszPropagationTarget = LocalAlloc(
                        LPTR,
                        (lstrlen(pDCInfo->DomainControllerName) + 1)
                                    * sizeof(TCHAR));

                if (pwszPropagationTarget != NULL) {
                    lstrcpy(pwszPropagationTarget,
                            pDCInfo->DomainControllerName);
                }
                else {
#if DBG
                    dprintf(TEXT("LLS: DC name allocation failure\n"));
#endif
                    goto CleanExit;
                }
            }
        }
        else {
            //
            // DC is in another site. Propagate to the site server.
            //

            if ((NULL == pwszSiteServer)
                && (NULL != pwszSiteName)) {

                //
                // No value found in registry, try Active Directory
                //

                fSiteServerFromRegistry = FALSE;

                GetSiteServer(pDomain, pwszSiteName, fIsDC, &pwszSiteServer);
            }

            pwszPropagationTarget = pwszSiteServer;
        }
    }
    else {
        //
        // Standalone server. Propagate directly to the enterprise
        // server
        //
        pwszPropagationTarget = GetEnterpriseServerFromRegistry();

        if (pwszPropagationTarget == NULL)
        {
            //
            // Don't have an enterprise server, try site server
            //
            pwszPropagationTarget = pwszSiteServer;
        }
    }

    //
    // Update ConfigInfo fields from information obtained above.
    //
    RtlEnterCriticalSection(&ConfigInfoLock);

    //
    // Check if the propagation target is actually this
    // machine. i.e., this is the site server.
    //
    if ((pwszPropagationTarget != NULL) && (*pwszPropagationTarget != 0)) {
        if (CompareMachineName(pwszPropagationTarget,
                               ConfigInfo.ComputerName)) {
            //
            // This is the site server - don't propagate.
            //
            if (pwszPropagationTarget != pwszSiteServer) {
                LocalFree(pwszPropagationTarget);
            }
            pwszPropagationTarget = NULL;    // For free below.
            ConfigInfo.IsMaster  = TRUE;
            ConfigInfo.Replicate = FALSE;
        }
    }

    //
    // Update the SiteServer ConfigInfo field.
    //
    if (pwszSiteServer != NULL) {
        if (ConfigInfo.SiteServer != ConfigInfo.ReplicateTo) {
            LocalFree(ConfigInfo.SiteServer);
        }
        ConfigInfo.SiteServer = pwszSiteServer;
        pwszSiteServer        = NULL;       // For free below.

        //
        // Update the site related registry values.
        //
        if (!fSiteServerFromRegistry) {
            SetSiteRegistrySettings(ConfigInfo.SiteServer);
        }
    }

    //
    // Update the ReplicateTo ConfigInfo field.
    //
    if ((pwszPropagationTarget != NULL) && (*pwszPropagationTarget != 0)) {
        //
        // This server is propgagating to the site server or the DC.
        //
        ConfigInfo.IsMaster  = FALSE;
        ConfigInfo.Replicate = TRUE;

        if ((ConfigInfo.ReplicateTo != NULL) && (ConfigInfo.ReplicateTo != ConfigInfo.SiteServer)) {
            LocalFree(ConfigInfo.ReplicateTo);
        }
        ConfigInfo.ReplicateTo = pwszPropagationTarget;
        pwszPropagationTarget   = NULL;      // For free below.
    }
    else if (!ConfigInfo.IsMaster) {
        //
        // Standalone server, and Site Server not specified in registry.
        // Do not replicate.
        //
        ConfigInfo.IsMaster  = FALSE;
        ConfigInfo.Replicate = FALSE;
    }

    //
    // Update remaining ConfigInfo fields from registry.
    //
    // NB : Hardcode to *always* use the enterprise - new with NT 5.0.
    //
    ConfigInfo.UseEnterprise = 1;

    ReplicationTime = ConfigInfo.ReplicationTime;
    ReplicationType = ConfigInfo.ReplicationType;

    ConfigInfoRegistryInit( &ConfigInfo.ReplicationType,
                            &ConfigInfo.ReplicationTime,
                            &ConfigInfo.LogLevel,
                            &ConfigInfo.PerServerCapacityWarning );

    //
    // Finally, adjust replication time if it has changed
    //
    if ((ReplicationTime != ConfigInfo.ReplicationTime)
        || (ReplicationType != ConfigInfo.ReplicationType)) {
        ReplicationTimeSet();
    }

    IsMaster = ConfigInfo.IsMaster;

    RtlLeaveCriticalSection(&ConfigInfoLock);

CleanExit:
    if (pDCInfoLocal != NULL) {
        NetApiBufferFree(pDCInfoLocal); // Allocated from DsGetDcName
    }

    if (pwszSiteName != NULL) {         // Allocated from DsGetSiteName
        NetApiBufferFree(pwszSiteName);
    }

    if (pwszSiteServer != NULL && pwszSiteServer == pwszPropagationTarget) {
        LocalFree(pwszSiteServer);
        pwszPropagationTarget = NULL;
    }
    if (pwszPropagationTarget != NULL) {
        LocalFree(pwszPropagationTarget);
    }
}

/////////////////////////////////////////////////////////////////////////
BOOL
IsDC(
    VOID
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NT_PRODUCT_TYPE NtType;

   //
   // If we aren't a DC, then count us as a member
   //
   NtType = NtProductLanManNt;
   RtlGetNtProductType(&NtType);
   if (NtType != NtProductLanManNt)
      return(FALSE);
   else {
      return(TRUE);
   }
}


/////////////////////////////////////////////////////////////////////////
NTSTATUS
ConfigInfoInit( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DWORD                    Size;
   TCHAR                    DataPath[MAX_PATH + 1];
   NTSTATUS                 status;

   //
   // First zero init the memory
   //
   memset(&ConfigInfo, 0, sizeof(CONFIG_RECORD));

   ConfigInfo.ComputerName = LocalAlloc(LPTR, (MAX_COMPUTERNAME_LENGTH + 1) * sizeof(TCHAR));
   ConfigInfo.ReplicateTo = LocalAlloc(LPTR, (MAX_COMPUTERNAME_LENGTH + 3) * sizeof(TCHAR));
   ConfigInfo.EnterpriseServer = LocalAlloc(LPTR, (MAX_COMPUTERNAME_LENGTH + 3) * sizeof(TCHAR));
   ConfigInfo.SystemDir = LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(TCHAR));

   if ((ConfigInfo.ComputerName == NULL) || (ConfigInfo.ReplicateTo == NULL) || (ConfigInfo.EnterpriseServer == NULL) || (ConfigInfo.SystemDir == NULL) ) {
      ASSERT(FALSE);
   }

   ConfigInfo.Version = INTERNAL_VERSION;
   GetLocalTime(&ConfigInfo.Started);

   //
   // LastReplicated is just for display, LlsReplTime is what is used to
   // Calculate it.
   GetLocalTime(&ConfigInfo.LastReplicated);
   ConfigInfo.LastReplicatedSeconds = DateSystemGet();

   if (ConfigInfo.SystemDir != NULL)
   {
       GetSystemDirectory(ConfigInfo.SystemDir, MAX_PATH);
       lstrcat(ConfigInfo.SystemDir, TEXT("\\"));
   }

   ConfigInfo.IsMaster = FALSE;

   ConfigInfo.Replicate = FALSE;
   ConfigInfo.IsReplicating = FALSE;
   ConfigInfo.PerServerCapacityWarning = TRUE;

   ConfigInfo.ReplicationType = REPLICATE_DELTA;
   ConfigInfo.ReplicationTime = DEFAULT_REPLICATION_TIME;

   if (ConfigInfo.ComputerName != NULL)
   {
       Size = MAX_COMPUTERNAME_LENGTH + 1;
       GetComputerName(ConfigInfo.ComputerName, &Size);
   }

   status = RtlInitializeCriticalSection(&ConfigInfoLock);

   if (!NT_SUCCESS(status))
       return status;

   ConfigInfo.LogLevel = 0;

   if (ConfigInfo.SystemDir != NULL)
   {
       //
       // Create File paths
       //
       lstrcpy(MappingFileName, ConfigInfo.SystemDir);
       lstrcat(MappingFileName, TEXT(LLS_FILE_SUBDIR));
       lstrcat(MappingFileName, TEXT("\\"));
       lstrcat(MappingFileName, TEXT(MAP_FILE_NAME));
       
       lstrcpy(UserFileName, ConfigInfo.SystemDir);
       lstrcat(UserFileName, TEXT(LLS_FILE_SUBDIR));
       lstrcat(UserFileName, TEXT("\\"));
       lstrcat(UserFileName, TEXT(USER_FILE_NAME));

       lstrcpy(CertDbFileName, ConfigInfo.SystemDir);
       lstrcat(CertDbFileName, TEXT(LLS_FILE_SUBDIR));
       lstrcat(CertDbFileName, TEXT("\\"));
       lstrcat(CertDbFileName, TEXT(CERT_DB_FILE_NAME));

       lstrcpy(LicenseFileName, ConfigInfo.SystemDir);
       lstrcat(LicenseFileName, TEXT(LICENSE_FILE_NAME));

       //
       // Make sure our directory is there.
       //
       lstrcpy(DataPath, ConfigInfo.SystemDir);
       lstrcat(DataPath, TEXT(LLS_FILE_SUBDIR));
       CreateDirectory(DataPath, NULL);
   } else
   {
       MappingFileName[0] = 0;
       UserFileName[0] = 0;
       CertDbFileName[0] = 0;
       LicenseFileName[0] = 0;
   }

   return STATUS_SUCCESS;

} // ConfigInfoInit


/////////////////////////////////////////////////////////////////////////
DWORD WINAPI
LLSTopLevelExceptionHandler(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )

/*++

Routine Description:

    The Top Level exception filter for LLSMain.exe.

    This ensures the entire process will be cleaned up if any of
    the threads fail.  Since LLSMain.exe is a distributed application,
    it is better to fail the entire process than allow random threads
    to continue executing.

Arguments:

    ExceptionInfo - Identifies the exception that occurred.


Return Values:

    EXCEPTION_EXECUTE_HANDLER - Terminate the process.

    EXCEPTION_CONTINUE_SEARCH - Continue processing as though this filter
        was never called.


--*/
{
    HANDLE hModule;


    //
    // Raise an alert
    //

    hModule = LoadLibraryA("netapi32");

    if ( hModule != NULL ) {
        NET_API_STATUS  (NET_API_FUNCTION *NetAlertRaiseExFunction)
            (LPTSTR, LPVOID, DWORD, LPTSTR);


        NetAlertRaiseExFunction =
            (NET_API_STATUS  (NET_API_FUNCTION *) (LPTSTR, LPVOID, DWORD, LPTSTR))
            GetProcAddress(hModule, "NetAlertRaiseEx");

        if ( NetAlertRaiseExFunction != NULL ) {
            NTSTATUS Status;
            UNICODE_STRING Strings;

            char message[ALERTSZ + sizeof(ADMIN_OTHER_INFO)];
            PADMIN_OTHER_INFO admin = (PADMIN_OTHER_INFO) message;

            //
            // Build the variable data
            //

            admin->alrtad_errcode = ALERT_UnhandledException;
            admin->alrtad_numstrings = 0;

            Strings.Buffer = (LPWSTR) ALERT_VAR_DATA(admin);
            Strings.Length = 0;
            Strings.MaximumLength = ALERTSZ;

            Status = RtlIntegerToUnicodeString(
                        (ULONG)ExceptionInfo->ExceptionRecord->ExceptionCode,
                        16,
                        &Strings );

            if ( NT_SUCCESS(Status) ) {
                if ( Strings.Length + sizeof(WCHAR) >= Strings.MaximumLength) {
                    Status = STATUS_BUFFER_TOO_SMALL;
                } else {
                    admin->alrtad_numstrings++;
                    *(Strings.Buffer+(Strings.Length/sizeof(WCHAR))) = L'\0';
                    Strings.Length += sizeof(WCHAR);

                    Status = RtlAppendUnicodeToString( &Strings, L"LLS" );
                }

            }

            if ( NT_SUCCESS(Status) ) {
                if ( Strings.Length + sizeof(WCHAR) >= Strings.MaximumLength) {
                    Status = STATUS_BUFFER_TOO_SMALL;
                } else {
                    admin->alrtad_numstrings++;
                    *(Strings.Buffer+(Strings.Length/sizeof(WCHAR))) = L'\0';
                    Strings.Buffer += (Strings.Length/sizeof(WCHAR)) + 1;
                    Strings.MaximumLength -= Strings.Length + sizeof(WCHAR);
                    Strings.Length = 0;

                    Status = RtlIntPtrToUnicodeString(
                                (ULONG_PTR)(ExceptionInfo->ExceptionRecord->ExceptionAddress),
                                16,
                                &Strings );
                }

            }

            if ( NT_SUCCESS(Status) ) {
                if ( Strings.Length + sizeof(WCHAR) >= Strings.MaximumLength) {
                    Status = STATUS_BUFFER_TOO_SMALL;
                } else {
                    admin->alrtad_numstrings++;
                    *(Strings.Buffer+(Strings.Length/sizeof(WCHAR))) = L'\0';
                    Strings.Buffer += (Strings.Length/sizeof(WCHAR)) + 1;

                    (VOID) (*NetAlertRaiseExFunction)(
                                        ALERT_ADMIN_EVENT,
                                        message,
                                        (DWORD)((PCHAR)Strings.Buffer -
                                            (PCHAR)message),
                                        L"LLS" );
                }

            }


        }

        (VOID) FreeLibrary( hModule );
    }


    //
    // Just continue processing the exception.
    //

    return EXCEPTION_CONTINUE_SEARCH;

} // LLSTopLevelExceptionHandler

DWORD
ServiceStartDelayed(
                    )
/*++

Routine Description:

  Do the stuff that used to be done at service startup time,
  but can wait until the first RPC. 

Arguments:

   None.

Return Values:

   None.

--*/
{
    NTSTATUS dwErr = STATUS_SUCCESS;

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

    //
    // Create the FilePrint table
    //
    dwErr = FilePrintTableInit();

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

    if (!NT_SUCCESS(dwErr))
        goto Cleanup;

    // Initialize the Service Table
    dwErr = LicenseListInit();

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

    if (!NT_SUCCESS(dwErr))
        goto Cleanup;

    dwErr = MasterServiceListInit();

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

    if (!NT_SUCCESS(dwErr))
        goto Cleanup;

    dwErr = LocalServiceListInit();

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

    if (!NT_SUCCESS(dwErr))
        goto Cleanup;

    dwErr = ServiceListInit();

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

    if (!NT_SUCCESS(dwErr))
        goto Cleanup;

    dwErr = MappingListInit();

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

    if (!NT_SUCCESS(dwErr))
        goto Cleanup;

    // Initialize the Per-Seat Table
    dwErr = UserListInit();

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

    if (!NT_SUCCESS(dwErr))
        goto Cleanup;

    // Initialize the Service Table
    dwErr = ServerListInit();

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

    if (!NT_SUCCESS(dwErr))
        goto Cleanup;

    // Initialize the Certificate Database
    dwErr = CertDbInit();

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

    if (!NT_SUCCESS(dwErr))
        goto Cleanup;

    // Load data files
    LoadAll();

    ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);

Cleanup:

    return dwErr;
}

DWORD
EnsureInitialized (
    VOID
    )
{
    DWORD dwErr;

    // Most common case is we're already initialized.  Perform a quick
    // check for this.
    //
    if (g_fInitializationComplete)
    {
        return NOERROR;
    }

    dwErr = NOERROR;

    // Make no assumptions about how many threads may be trying to
    // initialize us at the same time.
    //
    RtlEnterCriticalSection (&g_csLock);

    // Need to re-check after acquiring the lock because another thread
    // may have just finished initializing and released the lock allowing
    // us to get it.
    //
    if ((!g_fInitializationComplete) && (!g_fDoingInitialization))
    {
        // set this now so this thread can't call ServiceStartDelayed twice
        g_fDoingInitialization = TRUE;
        
        dwErr = ServiceStartDelayed();

        g_fInitializationComplete = TRUE;
    }

    RtlLeaveCriticalSection (&g_csLock);

    return dwErr;
}

/////////////////////////////////////////////////////////////////////////
VOID
ServiceStart (
   DWORD dwArgc,
   LPTSTR *lpszArgv
   )
/*++

Routine Description:

   The code that starts everything, is really the main().

Arguments:

   None.  *** argc and argv unused ***

Return Values:

    None.

--*/
{
    DWORD     dwWait;
    NTSTATUS  Status = STATUS_SUCCESS;
    BOOLEAN   EnableAlignmentFaults = TRUE;
    KPRIORITY BasePriority;
    HANDLE    hThread = NULL;
    BOOL      fCoInitialized = FALSE;
    LARGE_INTEGER liWait;
    BOOL      fRet;


    ///////////////////////////////////////////////////
    //
    // Service initialization
    //

    //
    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
        goto Cleanup;

    //
    // Define a top-level exception handler for the entire process.
    //

    (VOID) SetErrorMode( SEM_FAILCRITICALERRORS );

    //
    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
        goto Cleanup;


    (VOID) SetUnhandledExceptionFilter( &LLSTopLevelExceptionHandler );

    //
    // Run the LLS in the foreground.
    //
    // Several processes which depend on the LLS (like the lanman server)
    // run in the foreground.  If we don't run in the foreground, they'll
    // starve waiting for us.
    //

    BasePriority = FOREGROUND_BASE_PRIORITY;

    Status = NtSetInformationProcess(
                NtCurrentProcess(),
                ProcessBasePriority,
                &BasePriority,
                sizeof(BasePriority)
                );

    // BUGBUG: ignore error for now; may be caused by running as NetworkService

#if 0
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
#endif

    //
    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
        goto Cleanup;

    //
    // Create an event to throttle ConfigInfoUpdate
    //

    g_hThrottleConfig
        = CreateWaitableTimer(NULL,         // SecurityAttributes,
                              FALSE,        // bManualReset
                              NULL          // lpName
                              );

    if (NULL == g_hThrottleConfig)
    {
        Status = GetLastError();
        goto Cleanup;
    }

    liWait.QuadPart = (LONGLONG) (-1);  // Start immediately

    fRet = SetWaitableTimer(g_hThrottleConfig,
                     &liWait,
                     1000*60*15,    // lPeriod, 15 minutes
                     NULL,          // pfnCompletionRoutine
                     NULL,          // lpArgToCompletionRoutine
                     FALSE          // fResume (from suspended)
                     );

    if (!fRet)
    {
        Status = GetLastError();
        goto Cleanup;
    }

    //
    // Start separate thread to contact the DS
    //

    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE) ConfigInfoInit,
                           NULL,
                           0,
                           NULL);

    Status = RtlInitializeCriticalSection(&g_csLock);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
        goto Cleanup;

    //
    // Create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    hServerStopEvent = CreateEvent(
        NULL,    // no security attributes
        TRUE,    // manual reset event
        FALSE,   // not-signalled
        NULL);   // no name

    if ( hServerStopEvent == NULL)
        goto Cleanup;

    //
    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
        goto Cleanup;

    //
    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
        goto Cleanup;

    // Initialize Replication...
    ReplicationInit();

    //
    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
        goto Cleanup;

    // Initialize the Registry values...
    RegistryInit();

    //
    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
        goto Cleanup;

    // Initialize scavenger thread...
    ScavengerInit();

    //
    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
        goto Cleanup;

    //
    // wait for ConfigInfoInit to complete before accepting clients
    //
    while (hThread != NULL)
    {
        dwWait = WaitForSingleObject(hThread,NSERVICEWAITHINT/2);

        //
        // Report the status to the service control manager.
        //
        if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
            goto Cleanup;

        if (dwWait == WAIT_OBJECT_0)
        {
            GetExitCodeThread(hThread,&Status);

            // Check if critsec creation failed
            if (!NT_SUCCESS(Status))
                goto Cleanup;

            CloseHandle(hThread);
            hThread = NULL;
            break;
        }
    }

    // Initialize RegistryMonitor thread...
    RegistryStartMonitor();

    //
    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT))                 // wait hint
        goto Cleanup;

    // Initialize COM

    if (!FAILED(CoInitialize(NULL)))
    {
        fCoInitialized = TRUE;
    }

    // Do all the stuff that used to be delayed
    EnsureInitialized();

    // Initialize RPC Stuff... (start accepting clients)
    LLSRpcInit();

    //
    // End of initialization
    //
    ////////////////////////////////////////////////////////

    //
    // Tell SCM we are up and running!
    //
    if (!ReportStatusToSCMgr( SERVICE_RUNNING, NO_ERROR, 0))
        goto Cleanup;

    ////////////////////////////////////////////////////////
    //
    // Service is now running, perform work until shutdown
    //
    dwWait = WaitForSingleObject(hServerStopEvent, INFINITE);

Cleanup:
    
    if (fCoInitialized)
        CoUninitialize();

    if (hThread != NULL)
        CloseHandle(hThread);

    if (hServerStopEvent)
        CloseHandle(hServerStopEvent);

    if (sshStatusHandle)
       ReportStatusToSCMgr( SERVICE_STOPPED, NO_ERROR, 0);

} // ServiceStart


/////////////////////////////////////////////////////////////////////////
VOID ServiceStop()
/*++

Routine Description:

   Stops the service.

   If a ServiceStop procedure is going to take longer than 3 seconds to
   execute, it should spawn a thread to execute the stop code, and return.
   Otherwise, the ServiceControlManager will believe that the service has
   stopped responding.

Arguments:

   None.

Return Values:

    None.

--*/
{
    if ( hServerStopEvent )
        SetEvent(hServerStopEvent);
} // ServiceStop


#define FIND_DNSNAME_SEPARATOR(pwsz) {   \
    while (*pwsz && *pwsz != TEXT('.')) { \
        pwsz++;                          \
    }                                   \
}

/////////////////////////////////////////////////////////////////////////
VOID
DNSToFlatName(
    LPCWSTR pwszDNSName,
    DWORD   ccBufferLen,
    LPWSTR  pwszBuffer
    )

/*++

Routine Description:


Arguments:
    pwszDNSName
    ccBufferLen
    pwszBuffer

Return Value:

--*/

{
    LPWSTR pwszFlatName = (LPWSTR)pwszDNSName;
    SIZE_T  ccFlatNameLen;

    ASSERT(pwszDNSName != NULL);

    FIND_DNSNAME_SEPARATOR(pwszFlatName);

    ccFlatNameLen = (DWORD)(pwszFlatName - pwszDNSName);

    if (ccFlatNameLen && ccFlatNameLen < ccBufferLen) {
        lstrcpyn(pwszBuffer, pwszDNSName, (int)ccFlatNameLen + 1);
        pwszBuffer[ccFlatNameLen] = TEXT('\0');
    }
    else {
        *pwszBuffer = TEXT('\0');
    }
}



/////////////////////////////////////////////////////////////////////////
BOOL
CompareMachineName(
    LPCWSTR pwszName1,
    LPCWSTR pwszName2
    )

/*++

Routine Description:


Arguments:
    pwszName1
    pwszName2

Return Value:
    TRUE  -- The names match.
    FALSE -- Otherwise.

--*/

{
    TCHAR  szFlatName[MAX_COMPUTERNAME_LENGTH + 3];
    LPWSTR pwszTmp1 = (LPWSTR)pwszName1;
    LPWSTR pwszTmp2 = (LPWSTR)pwszName2;

    if (pwszName1 == NULL || pwszName2 == NULL) {
        return FALSE;
    }

    //
    // Identify if both/either name are DNS names by checking for the
    // existence of a '.' separator.
    //
    FIND_DNSNAME_SEPARATOR(pwszTmp1);
    FIND_DNSNAME_SEPARATOR(pwszTmp2);

    if ((*pwszTmp1 && *pwszTmp2) || (!*pwszTmp1 && !*pwszTmp2)) {
        //
        // Non-differing name types. Both are either DNS or flat.
        //
        return (lstrcmpi(pwszName1, pwszName2) == 0);
    }
    else if (*pwszTmp1) {
        //
        // Name 1 is DNS, name 2 is flat.
        // Convert DNS to flat, then compare.
        //
        DNSToFlatName(pwszName1,
                      MAX_COMPUTERNAME_LENGTH + 3,
                      szFlatName);

        return (lstrcmpi(szFlatName, pwszName2) == 0);
    }
    else {
        //
        // Name 2 is DNS, name 1 is flat.
        // Convert DNS to flat, then compare.
        //
        DNSToFlatName(pwszName2,
                      MAX_COMPUTERNAME_LENGTH + 3,
                      szFlatName);

        return (lstrcmpi(szFlatName, pwszName1) == 0);
    }
}


#define REG_LS_PARAMETERS \
    TEXT("System\\CurrentControlSet\\Services\\LicenseService\\Parameters")
#define REG_LS_SITESERVER \
    TEXT("SiteServer")
#define REG_LS_ENTERPRISESERVER \
    TEXT("EnterpriseServer")
#define REG_LS_USEENTERPRISE \
    TEXT("UseEnterprise")

/////////////////////////////////////////////////////////////////////////
LPWSTR
GetSiteServerFromRegistry(
    VOID
    )

/*++

Routine Description:


Arguments:
    None.

Return Value:

--*/

{
    HKEY   hKey = NULL;
    DWORD  dwType, dwSize;
    LPWSTR pwszSiteServer = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REG_LS_PARAMETERS,
                     0,
                     KEY_READ,
                     &hKey) == ERROR_SUCCESS) {

        //
        // Allocate SiteServer on the heap since it could be quite large.
        //

        dwSize = 0;

        if (RegQueryValueEx(hKey,
                            REG_LS_SITESERVER,
                            NULL,
                            &dwType,
                            (LPBYTE)NULL,
                            &dwSize) == ERROR_SUCCESS)
        {
            pwszSiteServer = LocalAlloc(LPTR, dwSize);

            if (pwszSiteServer != NULL) {
                if (RegQueryValueEx(hKey,
                                    REG_LS_SITESERVER,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)pwszSiteServer,
                                    &dwSize) != ERROR_SUCCESS) {
                    LocalFree(pwszSiteServer);
                    pwszSiteServer = NULL;
                }
            }
        }

        RegCloseKey(hKey);
    }

    return pwszSiteServer;
}


/////////////////////////////////////////////////////////////////////////
LPWSTR
GetEnterpriseServerFromRegistry(
    VOID
    )

/*++

Routine Description:


Arguments:
    None.

Return Value:

--*/

{
    HKEY   hKey = NULL;
    DWORD  dwType, dwSize;
    LPWSTR pwszEnterpriseServer = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REG_LS_PARAMETERS,
                     0,
                     KEY_READ,
                     &hKey) == ERROR_SUCCESS) {

        //
        // Allocate EnterpriseServer on the heap since it could be quite large.
        //

        dwSize = 0;

        if (RegQueryValueEx(hKey,
                            REG_LS_ENTERPRISESERVER,
                            NULL,
                            &dwType,
                            (LPBYTE)NULL,
                            &dwSize) == ERROR_SUCCESS)
        {
            pwszEnterpriseServer = LocalAlloc(LPTR, dwSize);

            if (pwszEnterpriseServer != NULL) {
                if (RegQueryValueEx(hKey,
                                    REG_LS_ENTERPRISESERVER,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)pwszEnterpriseServer,
                                    &dwSize) != ERROR_SUCCESS) {
                    LocalFree(pwszEnterpriseServer);
                    pwszEnterpriseServer = NULL;
                }
            }
        }

        RegCloseKey(hKey);
    }

    return pwszEnterpriseServer;
}


/////////////////////////////////////////////////////////////////////////
VOID
SetSiteRegistrySettings(
    LPCWSTR pwszSiteServer
    )

/*++

Routine Description:

Arguments:
    pwszSiteServer

Return Value:

--*/

{
    HKEY  hKey;
    DWORD dwSize;
    DWORD dwType = REG_SZ;
    DWORD dwUseEnterprise = 1;
    TCHAR szSiteServerFlatName[MAX_COMPUTERNAME_LENGTH + 1];

    ASSERT(pwszSiteServer != NULL);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REG_LS_PARAMETERS,
                     0,
                     KEY_WRITE,
                     &hKey) == ERROR_SUCCESS) {

        //
        // Write the SiteServer value.
        //

        dwSize = (lstrlen(pwszSiteServer) + 1) * sizeof(TCHAR);

        RegSetValueEx(hKey,
                      REG_LS_SITESERVER,
                      0,
                      dwType,
                      (LPBYTE)pwszSiteServer,
                      dwSize);

        RegCloseKey(hKey);
    }
}

//
// Pre-fill the ADSI cache with only the attribute we want, then get it
// Only use if exactly one attribute is needed
//

HRESULT
GetWithGetInfoEx(
                 IADs *pADs,
                 LPWSTR wszAttribute,
                 VARIANT *pvar
                 )
{
    HRESULT hr;

    hr = ADsBuildVarArrayStr( &wszAttribute, 1, pvar );
    if( SUCCEEDED( hr ) )
    {
        hr = IADs_GetInfoEx( pADs, *pvar, 0L );
        VariantClear( pvar );

        if (SUCCEEDED(hr))
        {
            hr = IADs_Get( pADs, wszAttribute, pvar );
        }
    }

    return hr;
}

//
// Pre-fill the ADSI cache with only the attributes we want, then get them
// Only use if exactly two attributes are needed
//

HRESULT
GetWithGetInfoEx2(
                 IADs *pADs,
                 LPWSTR wszAttribute1,
                 LPWSTR wszAttribute2,
                 VARIANT *pvar1,
                 VARIANT *pvar2,
                 HRESULT * phr2
                 )
{
    HRESULT hr;
    LPWSTR rgwszAttributes[] = {wszAttribute1,wszAttribute2};

    hr = ADsBuildVarArrayStr( rgwszAttributes, 2, pvar1 );
    if( SUCCEEDED( hr ) )
    {
        hr = IADs_GetInfoEx( pADs, *pvar1, 0L );
        VariantClear( pvar1 );

        if (SUCCEEDED(hr))
        {
            hr = IADs_Get( pADs, wszAttribute1, pvar1 );

            if (SUCCEEDED(hr))
            {
                *phr2 = IADs_Get( pADs, wszAttribute2, pvar2 );
            }
        }
    }

    return hr;
}


#define CWSTR_SIZE(x)       (sizeof(x) - (sizeof(WCHAR) * 2))
#define DWSTR_SIZE(x)       ((wcslen(x) + 1) * sizeof(WCHAR))

#define ROOT_DSE_PATH       L"LDAP://RootDSE"
#define CONFIG_CNTNR        L"ConfigurationNamingContext"
#define SITE_SERVER         L"siteServer"
#define DNS_MACHINE_NAME    L"dNSHostName"
#define IS_DELETED          L"isDeleted"

/////////////////////////////////////////////////////////////////////////
HRESULT
GetSiteServer(
    LPCWSTR  pwszDomain,
    LPCWSTR  pwszSiteName,
    BOOL     fIsDC,
    LPWSTR * ppwszSiteServer
    )

/*++

Routine Description:


Arguments:
    pwszSiteName
    fIsDC
    ppwszSiteServer

Return Value:

--*/

{
    LPWSTR           pwszDN         = NULL;
    LPWSTR           pwszConfigContainer;
    LPWSTR           pwszBindPath;
    IADs *           pADs           = NULL;
    IADs *           pADs2          = NULL;
    IADs *           pADs3          = NULL;
    DS_NAME_RESULT * pDsResult      = NULL;
    VARIANT          var;
    VARIANT          var2;
    HRESULT          hr, hr2;
    DWORD            cbSize;
    DWORD            dwRet          = 0;
    BOOL             fAlreadyTookSiteServer = FALSE;
    BOOL             fCoInitialized = FALSE;

    ASSERT(pwszSiteName != NULL);
    ASSERT(ppwszSiteServer != NULL);

    *ppwszSiteServer = NULL;

    VariantInit(&var);
    VariantInit(&var2);

    hr = CoInitialize(NULL);

    if (FAILED(hr)) {
        ERR(hr);
        goto CleanExit;
    }

    fCoInitialized = TRUE;

    //
    // Obtain the path to the configuration container.
    //

    hr = ADsGetObject(ROOT_DSE_PATH, &IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
        ERR(hr);
        goto CleanExit;
    }

    hr = IADs_Get(pADs, CONFIG_CNTNR, &var);

    if (FAILED(hr)) {
        ERR(hr);
        goto CleanExit;
    }

    if (V_VT(&var) != VT_BSTR) {
        ASSERT(V_VT(&var) == VT_BSTR);
        dwRet = ERROR_INVALID_DATA;
        ERR(dwRet);
        goto CleanExit;
    }

    pwszConfigContainer = var.bstrVal;  // For sake of readability.

    //
    // Bind to the license settings object.
    //

    hr = GetLicenseSettingsObject(pwszSiteName,
                                  pwszConfigContainer,
                                  &pADs2);

    if (hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT)) {
        //
        // The license settings object doesn't exist. Create it.
        //

        hr = CreateLicenseSettingsObject(pwszSiteName,
                                         pwszConfigContainer,
                                         &pADs2);
    }

    if (FAILED(hr)) {
        //
        // Failed to bind or create the license settings object.
        //

        goto CleanExit;
    }

    ASSERT(pADs2 != NULL);

    //
    // Consult the site server property on the license settings object.
    // It's a DN to the machine object of the site server.
    //

    VariantClear(&var);

    hr = GetWithGetInfoEx(pADs2, SITE_SERVER, &var);

    //
    // If the site server property has not been set and this server
    // is a DC, designate this server as the site server.
    //

    if (hr == E_ADS_PROPERTY_NOT_FOUND && fIsDC) {
        dwRet = BecomeSiteServer(&pDsResult,pADs2,&pwszDN,pwszDomain);

        if (dwRet)
            goto CleanExit;
    }
    else if (SUCCEEDED(hr)) {
        if (V_VT(&var) != VT_BSTR) {
            ASSERT(V_VT(&var) == VT_BSTR);
            dwRet = ERROR_INVALID_DATA;
            ERR(dwRet);
            goto CleanExit;
        }

        pwszDN = V_BSTR(&var);
    }
    else {
        goto CleanExit;
    }

TryNewSiteServer:
    //
    // Bind to the computer object referenced by the Site-Server property.
    //

    if (pwszDN == NULL)
    {
        hr = E_FAIL;
        ERR(hr);
        goto CleanExit;
    }

    // LDAP:// + pwszDN + 1
    pwszBindPath = LocalAlloc(LPTR,
                              (wcslen(pwszDN) + 8) * sizeof(WCHAR));

    if (pwszBindPath == NULL) {
        hr = E_OUTOFMEMORY;
        ERR(hr);
        goto CleanExit;
    }

    wsprintf(pwszBindPath, L"LDAP://%ws", pwszDN);

    hr = ADsOpenObject(pwszBindPath,
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND | ADS_SERVER_BIND,
                       &IID_IADs,
                       (void **)&pADs3);

    LocalFree(pwszBindPath);

    if (FAILED(hr)) {
        if (fIsDC && !fAlreadyTookSiteServer)
        {
            // 
            // Existing SiteServer is gone, claim it
            //
            if (pDsResult != NULL) {
                DsFreeNameResult(pDsResult);
            }

            dwRet = BecomeSiteServer(&pDsResult,pADs2,&pwszDN,pwszDomain);
            if (dwRet)
            {
                goto CleanExit;
            }
            else
            {
                fAlreadyTookSiteServer = TRUE;

                if (pADs3 != NULL) {
                    IADs_Release(pADs3);
                }
                
                goto TryNewSiteServer;
            }
        } else
        {
            ERR(hr);
            goto CleanExit;
        }
    }

    //
    // Fetch the Machine-DNS-Name property.
    //

    VariantClear(&var);

    hr = GetWithGetInfoEx2(pADs3, DNS_MACHINE_NAME, IS_DELETED, &var, &var2, &hr2);

    if (FAILED(hr)) {
        ERR(hr);
        goto CleanExit;
    }

    if (SUCCEEDED(hr2))
    {

        hr = VariantChangeType(&var2,&var2,0,VT_BOOL);

        if (FAILED(hr)) {
            ERR(hr);
            goto CleanExit;
        }

        if (V_BOOL(&var2))
        {
            // object has been deleted - pretend it isn't set
            hr = E_ADS_PROPERTY_NOT_SET;

            if (fIsDC && !fAlreadyTookSiteServer)
            {
                // 
                // Existing SiteServer is gone, claim it
                //
                if (pDsResult != NULL) {
                    DsFreeNameResult(pDsResult);
                }

                dwRet = BecomeSiteServer(&pDsResult,pADs2,&pwszDN,pwszDomain);
                if (dwRet)
                {
                    goto CleanExit;
                }
                else
                {
                    fAlreadyTookSiteServer = TRUE;

                    if (pADs3 != NULL) {
                        IADs_Release(pADs3);
                    }
                    
                    goto TryNewSiteServer;
                }
            } else
            {
                ERR(hr);
                goto CleanExit;
            }
        }
    }

    //
    // Allocate a return copy of the DNS-Machine-Name.
    //

    *ppwszSiteServer = (LPWSTR)LocalAlloc(LPTR,
                                         SysStringByteLen(V_BSTR(&var))
                                            + sizeof(WCHAR));

    if (*ppwszSiteServer != NULL) {
        lstrcpy(*ppwszSiteServer, V_BSTR(&var));
    }
    else {
        hr = E_OUTOFMEMORY;
        ERR(hr);
    }

CleanExit:
    // Do not free pwszDN, pwszConfigContainer or pwszBindPath.

    if (pADs != NULL) {
        IADs_Release(pADs);
    }
    if (pADs2 != NULL) {
        IADs_Release(pADs2);
    }
    if (pADs3 != NULL) {
        IADs_Release(pADs3);
    }
    if (pDsResult != NULL) {
        DsFreeNameResult(pDsResult);
    }

    if (dwRet) {
        // If dwRet has no facility, then make into HRESULT
        if (dwRet != ERROR_SUCCESS && HRESULT_CODE(dwRet) == dwRet)
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, dwRet);
    }

    VariantClear(&var);
    VariantClear(&var2);

    if (fCoInitialized) {
        CoUninitialize();
    }

    return hr;
}

HRESULT
BecomeSiteServer(
                 DS_NAME_RESULT **ppDsResult,
                 IADs           *pADs2,
                 LPWSTR         *ppwszDN,
                 LPCWSTR        pwszDomain
                 )
{
    HANDLE           hDS;
    WCHAR            wszName[MAX_PATH + 1];
    LPWSTR           rgpwszNames[2];
    DWORD            dwRet          = 0;
    VARIANT          var;
    DS_NAME_RESULT * pDsResult      = NULL;
    LPWSTR           pwszDN         = NULL;
    HRESULT          hr = S_OK;

    ASSERT(ppDsResult != NULL);
    ASSERT(ppwszDN != NULL);

    VariantInit(&var);

    //
    // Bind to the DS (get a handle for use with DsCrackNames).
    //

    if (ConfigInfo.ComputerName == NULL) {
        hr = E_UNEXPECTED;
        goto CleanExit;
    }

    if (DsBind(NULL, (WCHAR *)pwszDomain, &hDS) == ERROR_SUCCESS) {
        //
        // Request the DS-DN of this server's computer object.
        // Offer the domain\server$ name of this server.
        //

        wsprintf(wszName,
                 L"%ws\\%ws$",
                 pwszDomain,
                 ConfigInfo.ComputerName);

        rgpwszNames[0] = wszName;
        rgpwszNames[1] = NULL;

        if (DsCrackNames(hDS,
                         DS_NAME_NO_FLAGS,
                         DS_UNKNOWN_NAME,
                         DS_FQDN_1779_NAME,
                         1,
                         &rgpwszNames[0],
                         &pDsResult) == ERROR_SUCCESS) {

            if (pDsResult->rItems[0].status != DS_NAME_NO_ERROR) {
                if (pDsResult->rItems[0].status == DS_NAME_ERROR_RESOLVING) {
                    dwRet = ERROR_PATH_NOT_FOUND;
                    ERR(dwRet);
                }
                else {
                    ERR(pDsResult->rItems[0].status);
                    hr = E_FAIL;
                }

                goto CleanExit;
            }

            if (pDsResult->rItems[0].pName == NULL)
            {
                hr = E_FAIL;
                goto CleanExit;
            }

            //
            // Update the site server property on the license
            // settings object.
            //

            VariantInit(&var);
            V_VT(&var)   = VT_BSTR;
            V_BSTR(&var) = pwszDN = pDsResult->rItems[0].pName;
            
            hr = IADs_Put(pADs2, SITE_SERVER, var);

            V_VT(&var) = VT_EMPTY;  // For VariantClear below

            if (SUCCEEDED(hr)) {
                hr = IADs_SetInfo(pADs2);

                if (FAILED(hr)) {
                    ERR(hr);
                }
            }
            else {
                ERR(hr);
            }
        }
        else {
            dwRet = GetLastError();
            ERR(dwRet);
        }
        
        DsUnBind(&hDS);
    }
    else {
        dwRet = GetLastError();
        ERR(dwRet);
    }

CleanExit:
    *ppDsResult = pDsResult;
    *ppwszDN = pwszDN;

    if (!SUCCEEDED(hr) && SUCCEEDED(dwRet))
        dwRet = hr;

    return dwRet;
}

#define SITE_FORMAT         L"LDAP://CN=%ws,CN=%ws,%ws"
#define SITES               L"sites"
#define SITE_FORMAT_SIZE    CWSTR_SIZE(SITE_FORMAT)
#define SITES_SIZE          CWSTR_SIZE(SITES)

HRESULT
GetSiteObject(LPCWSTR          pwszSiteName,
              LPCWSTR          pwszConfigContainer,
              IADsContainer ** ppADsContainer)
{
    LPWSTR  pwszSite;
    HRESULT hr;

    *ppADsContainer = NULL;

    //
    // Build the X.500 path to the Site object.
    //

    pwszSite = (LPWSTR)LocalAlloc(LPTR,
                                  SITE_FORMAT_SIZE
                                    + DWSTR_SIZE(pwszSiteName)
                                    + SITES_SIZE
                                    + DWSTR_SIZE(pwszConfigContainer)
                                    + sizeof(WCHAR));

    if (pwszSite == NULL) {
        hr = E_OUTOFMEMORY;
        ERR(hr);
        goto Exit;
    }

    wsprintf(pwszSite,
             SITE_FORMAT,
             pwszSiteName,
             SITES,
             pwszConfigContainer);

    hr = ADsGetObject(pwszSite,
                      &IID_IADsContainer,
                      (void **)ppADsContainer);

    LocalFree(pwszSite);

    if (FAILED(hr)) {
        ERR(hr);
    }

Exit:
    return hr;
}

#define LICENSE_SETTINGS                L"Licensing Site Settings"
#define LICENSE_SETTINGS_FORMAT         L"LDAP://CN=%ws,CN=%ws,CN=%ws,%ws"
#define LICENSE_SETTINGS_SIZE           CWSTR_SIZE(LICENSE_SETTINGS)
#define LICENSE_SETTINGS_FORMAT_SIZE    CWSTR_SIZE(LICENSE_SETTINGS_FORMAT)

HRESULT
GetLicenseSettingsObject(LPCWSTR pwszSiteName,
                         LPCWSTR pwszConfigContainer,
                         IADs ** ppADs)
{
    LPWSTR  pwszLicenseSettings;
    HRESULT hr;

    *ppADs = NULL;

    //
    // Build the X.500 path to the LicenseSettings object.
    //

    pwszLicenseSettings = (LPWSTR)LocalAlloc(
                                    LPTR,
                                    LICENSE_SETTINGS_FORMAT_SIZE
                                        + LICENSE_SETTINGS_SIZE
                                        + DWSTR_SIZE(pwszSiteName)
                                        + SITES_SIZE
                                        + DWSTR_SIZE(pwszConfigContainer)
                                        + sizeof(WCHAR));

    if (pwszLicenseSettings == NULL) {
        hr = E_OUTOFMEMORY;
        ERR(hr);
        goto Exit;
    }

    wsprintf(pwszLicenseSettings,
             LICENSE_SETTINGS_FORMAT,
             LICENSE_SETTINGS,
             pwszSiteName,
             SITES,
             pwszConfigContainer);

    hr = ADsOpenObject(pwszLicenseSettings, 
                       NULL,
                       NULL,
                       ADS_SECURE_AUTHENTICATION | ADS_FAST_BIND,
                       &IID_IADs,
                       (void **)ppADs);

    LocalFree(pwszLicenseSettings);

    if (FAILED(hr)) {
        ERR(hr);
    }

Exit:
    return hr;
}

HRESULT
CreateLicenseSettingsObject(LPCWSTR pwszSiteName,
                            LPCWSTR pwszConfigContainer,
                            IADs ** ppADs)
{
    IADsContainer * pADsContainer;
    IADs *          pADs;
    IDispatch *     pDisp;
    HRESULT         hr;

    *ppADs = NULL;

    //
    // Obtain the site container object.
    //

    hr = GetSiteObject(pwszSiteName,
                       pwszConfigContainer,
                       &pADsContainer);

    if (SUCCEEDED(hr)) {
        //
        // Create the license settings leaf object.
        //

        hr = IADsContainer_Create(pADsContainer,
                                  LICENSE_SETTINGS,
                                  LICENSE_SETTINGS,
                                  &pDisp);

        if (SUCCEEDED(hr)) {

            //
            // Return an IADs to the new license settings object.
            //

            hr = IDispatch_QueryInterface(pDisp,
                                          &IID_IADs,
                                          (void **)ppADs);

            if (SUCCEEDED(hr)) {
                //
                // Persist the change via SetInfo.
                //

                hr = IADs_SetInfo(*ppADs);

                if (FAILED(hr)) {
                    ERR(hr);
                    IADs_Release(*ppADs);
                    *ppADs = NULL;
                }
            }
            else {
                ERR(hr);
            }

            IDispatch_Release(pDisp);
        }
        else {
            ERR(hr);
        }

        IADsContainer_Release(pADsContainer);
    }
    else {
        ERR(hr);
    }

    return hr;
}


#if DBG
/////////////////////////////////////////////////////////////////////////
VOID
ConfigInfoDebugDump( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ConfigInfoUpdate(NULL);

   RtlEnterCriticalSection(&ConfigInfoLock);

   dprintf(TEXT("License Logging Service - Version: 0x%lX\n"), ConfigInfo.Version);
   dprintf(TEXT("   Started: %u-%u-%u @ %u:%u:%u\n"),
               (UINT) ConfigInfo.Started.wDay,
               (UINT) ConfigInfo.Started.wMonth,
               (UINT) ConfigInfo.Started.wYear,
               (UINT) ConfigInfo.Started.wHour,
               (UINT) ConfigInfo.Started.wMinute,
               (UINT) ConfigInfo.Started.wSecond );

   dprintf(TEXT("   Replication\n"));
   dprintf(TEXT("   +--------------+\n"));
   if (ConfigInfo.IsMaster)
      dprintf(TEXT("      Master Server\n"));
   else
      dprintf(TEXT("      NOT Master Server\n"));

   if (ConfigInfo.Replicate)
      dprintf(TEXT("      Replicates\n"));
   else
      dprintf(TEXT("      Does not Replicate\n"));

   if (ConfigInfo.IsReplicating)
      dprintf(TEXT("      Currently Replicating\n"));
   else
      dprintf(TEXT("      NOT Currently Replicating\n"));

   dprintf(TEXT("      Replicates To: %s\n"), ConfigInfo.ReplicateTo);
   dprintf(TEXT("      Enterprise Server: %s\n"), ConfigInfo.EnterpriseServer);

   if (ConfigInfo.ReplicationType == REPLICATE_DELTA)
      dprintf(TEXT("      Replicate Every: %lu Seconds\n"), ConfigInfo.ReplicationTime );
   else
      dprintf(TEXT("      Replicate @: %lu\n"), ConfigInfo.ReplicationTime );

   dprintf(TEXT("\n      Last Replicated: %u-%u-%u @ %u:%u:%u\n\n"),
               (UINT) ConfigInfo.LastReplicated.wDay,
               (UINT) ConfigInfo.LastReplicated.wMonth,
               (UINT) ConfigInfo.LastReplicated.wYear,
               (UINT) ConfigInfo.LastReplicated.wHour,
               (UINT) ConfigInfo.LastReplicated.wMinute,
               (UINT) ConfigInfo.LastReplicated.wSecond );

   dprintf(TEXT("      Number Servers Currently Replicating: %lu\n"), ConfigInfo.NumReplicating);

   dprintf(TEXT("      Current Backoff Time Delta: %lu\n"), ConfigInfo.BackoffTime);

   dprintf(TEXT("      Current Replication Speed: %lu\n"), ConfigInfo.ReplicationSpeed);

   RtlLeaveCriticalSection(&ConfigInfoLock);

} // ConfigInfoDebugDump
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\llsutil.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    LlsUtil.h

Abstract:


Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

   Jeff Parham (jeffparh) 12-Jan-1996
      o  Added WinNtBuildNumberGet() to ascertain the Windows NT build number
         running on a given machine.

--*/


#ifndef _LLS_LLSUTIL_H
#define _LLS_LLSUTIL_H


#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS EBlock( PVOID Data, ULONG DataSize );
NTSTATUS DeBlock( PVOID Data, ULONG DataSize );

BOOL FileExists( LPTSTR FileName );
VOID lsplitpath( const TCHAR *path, TCHAR *drive, TCHAR *dir, TCHAR *fname, TCHAR *ext );
VOID lmakepath( TCHAR *path, const TCHAR *drive, const TCHAR *dir, const TCHAR *fname, const TCHAR *ext );
VOID FileBackupCreate( LPTSTR Path );
HANDLE LlsFileInit( LPTSTR FileName, DWORD Version, DWORD DataSize );
HANDLE LlsFileCheck( LPTSTR FileName, LPDWORD Version, LPDWORD DataSize );

DWORD DateSystemGet( );
DWORD DateLocalGet( );
DWORD InAWorkgroup( VOID );
VOID ThrottleLogEvent( DWORD MessageId, DWORD NumberOfSubStrings, LPWSTR *SubStrings, DWORD ErrorCode );
VOID LogEvent( DWORD MessageId, DWORD NumberOfSubStrings, LPWSTR *SubStrings, DWORD ErrorCode );
VOID  LicenseCapacityWarningDlg(DWORD dwCapacityState);

DWORD WinNtBuildNumberGet( LPTSTR pszServerName, LPDWORD pdwBuildNumber );

#if DBG

LPTSTR TimeToString( ULONG Seconds );

#endif


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\lsapi_s_stub.c ===
#include "lsapi_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\llsrtl.h ===
/*++ BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    llsrtl.h

Abstract:

    Include file for NT runtime routines that are callable by both
    kernel mode code in the executive and user mode code in various
    NT subsystems.

Author:

    Steve Wood (stevewo) 31-Mar-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

#ifndef _LLSRTL_
#define _LLSRTL_

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4514)
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#endif
#if (_MSC_VER > 1020)
#pragma once
#endif
#endif

// begin_ntddk begin_wdm begin_winnt begin_ntifs begin_nthal
//
// for move macros
//
#ifdef _MAC
#ifndef _INC_STRING
#include <string.h>
#endif /* _INC_STRING */
#else
#include <string.h>
#endif // _MAC

// end_ntddk end_wdm end_winnt end_ntifs end_nthal

#ifdef __cplusplus
extern "C" {
#endif

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis
//
// If debugging support enabled, define an ASSERT macro that works.  Otherwise
// define the ASSERT macro to expand to an empty expression.
//

#if DBG

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#ifndef ASSERT
#define ASSERT( exp ) \
    ((!(exp)) ? \
        RtlAssert( #exp, __FILE__, __LINE__, NULL ) : \
        ((void)0))
#endif

#ifndef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    ((!(exp)) ? \
        RtlAssert( #exp, __FILE__, __LINE__, msg ) : \
        ((void)0))
#endif

#else
#ifndef ASSERT
#define ASSERT( exp ) ((void)0)
#endif

#ifndef ASSERTMSG
#define ASSERTMSG( msg, exp ) ((void)0)
#endif
#endif // DBG

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

// end_wdm end_nthal end_ntifs end_ntndis


// end_ntddk


//
//  Define the generic table package.  Note a generic table should really
//  be an opaque type.  We provide routines to manipulate the structure.
//
//  A generic table is package for inserting, deleting, and looking up elements
//  in a table (e.g., in a symbol table).  To use this package the user
//  defines the structure of the elements stored in the table, provides a
//  comparison function, a memory allocation function, and a memory
//  deallocation function.
//
//  Note: the user compare function must impose a complete ordering among
//  all of the elements, and the table does not allow for duplicate entries.
//

//
// Add an empty typedef so that functions can reference the
// a pointer to the generic table struct before it is declared.
//

struct _LLS_GENERIC_TABLE;

//
//  The results of a compare can be less than, equal, or greater than.
//

typedef enum _LLS_GENERIC_COMPARE_RESULTS {
    LLSGenericLessThan,
    LLSGenericGreaterThan,
    LLSGenericEqual
} LLS_GENERIC_COMPARE_RESULTS;

//
//  The comparison function takes as input pointers to elements containing
//  user defined structures and returns the results of comparing the two
//  elements.
//

typedef
LLS_GENERIC_COMPARE_RESULTS
(NTAPI *PLLS_GENERIC_COMPARE_ROUTINE) (
    struct _LLS_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

//
//  The allocation function is called by the generic table package whenever
//  it needs to allocate memory for the table.
//

typedef
PVOID
(NTAPI *PLLS_GENERIC_ALLOCATE_ROUTINE) (
    struct _LLS_GENERIC_TABLE *Table,
    CLONG ByteSize
    );

//
//  The deallocation function is called by the generic table package whenever
//  it needs to deallocate memory from the table that was allocated by calling
//  the user supplied allocation function.
//

typedef
VOID
(NTAPI *PLLS_GENERIC_FREE_ROUTINE) (
    struct _LLS_GENERIC_TABLE *Table,
    PVOID Buffer
    );

//
//  To use the generic table package the user declares a variable of type
//  GENERIC_TABLE and then uses the routines described below to initialize
//  the table and to manipulate the table.  Note that the generic table
//  should really be an opaque type.
//

typedef struct _LLS_GENERIC_TABLE {
    PRTL_SPLAY_LINKS TableRoot;
    LIST_ENTRY InsertOrderList;
    PLIST_ENTRY OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    PLLS_GENERIC_COMPARE_ROUTINE CompareRoutine;
    PLLS_GENERIC_ALLOCATE_ROUTINE AllocateRoutine;
    PLLS_GENERIC_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} LLS_GENERIC_TABLE;
typedef LLS_GENERIC_TABLE *PLLS_GENERIC_TABLE;

//
// This enumerated type is used as the function return value of the function
// that is used to search the tree for a key. FoundNode indicates that the
// function found the key. Insert as left indicates that the key was not found
// and the node should be inserted as the left child of the parent. Insert as
// right indicates that the key was not found and the node should be inserted
//  as the right child of the parent.
//
typedef enum _LLS_TABLE_SEARCH_RESULT{
    LLSTableEmptyTree,
    LLSTableFoundNode,
    LLSTableInsertAsLeft,
    LLSTableInsertAsRight
} LLS_TABLE_SEARCH_RESULT;

//
//  The procedure InitializeGenericTable takes as input an uninitialized
//  generic table variable and pointers to the three user supplied routines.
//  This must be called for every individual generic table variable before
//  it can be used.
//


VOID
NTAPI
LLSInitializeGenericTable (
    PLLS_GENERIC_TABLE Table,
    PLLS_GENERIC_COMPARE_ROUTINE CompareRoutine,
    PLLS_GENERIC_ALLOCATE_ROUTINE AllocateRoutine,
    PLLS_GENERIC_FREE_ROUTINE FreeRoutine,
    PVOID TableContext
    );

//
//  The function InsertElementGenericTable will insert a new element
//  in a table.  It does this by allocating space for the new element
//  (this includes splay links), inserting the element in the table, and
//  then returning to the user a pointer to the new element.  If an element
//  with the same key already exists in the table the return value is a pointer
//  to the old element.  The optional output parameter NewElement is used
//  to indicate if the element previously existed in the table.  Note: the user
//  supplied Buffer is only used for searching the table, upon insertion its
//  contents are copied to the newly created element.  This means that
//  pointer to the input buffer will not point to the new element.
//


PVOID
NTAPI
LLSInsertElementGenericTable (
    PLLS_GENERIC_TABLE Table,
    PVOID Buffer,
    CLONG BufferSize,
    PBOOLEAN NewElement OPTIONAL
    );

//
//  The function InsertElementGenericTableFull will insert a new element
//  in a table.  It does this by allocating space for the new element
//  (this includes splay links), inserting the element in the table, and
//  then returning to the user a pointer to the new element.  If an element
//  with the same key already exists in the table the return value is a pointer
//  to the old element.  The optional output parameter NewElement is used
//  to indicate if the element previously existed in the table.  Note: the user
//  supplied Buffer is only used for searching the table, upon insertion its
//  contents are copied to the newly created element.  This means that
//  pointer to the input buffer will not point to the new element.
//  This routine is passed the NodeOrParent and SearchResult from a
//  previous RtlLookupElementGenericTableFull.
//


PVOID
NTAPI
LLSInsertElementGenericTableFull (
    PLLS_GENERIC_TABLE Table,
    PVOID Buffer,
    CLONG BufferSize,
    PBOOLEAN NewElement OPTIONAL,
    PVOID NodeOrParent,
    LLS_TABLE_SEARCH_RESULT SearchResult
    );

//
//  The function DeleteElementGenericTable will find and delete an element
//  from a generic table.  If the element is located and deleted the return
//  value is TRUE, otherwise if the element is not located the return value
//  is FALSE.  The user supplied input buffer is only used as a key in
//  locating the element in the table.
//


BOOLEAN
NTAPI
LLSDeleteElementGenericTable (
    PLLS_GENERIC_TABLE Table,
    PVOID Buffer
    );

//
//  The function LookupElementGenericTable will find an element in a generic
//  table.  If the element is located the return value is a pointer to
//  the user defined structure associated with the element, otherwise if
//  the element is not located the return value is NULL.  The user supplied
//  input buffer is only used as a key in locating the element in the table.
//


PVOID
NTAPI
LLSLookupElementGenericTable (
    PLLS_GENERIC_TABLE Table,
    PVOID Buffer
    );

//
//  The function LookupElementGenericTableFull will find an element in a generic
//  table.  If the element is located the return value is a pointer to
//  the user defined structure associated with the element.  If the element is not
//  located then a pointer to the parent for the insert location is returned.  The
//  user must look at the SearchResult value to determine which is being returned.
//  The user can use the SearchResult and parent for a subsequent FullInsertElement
//  call to optimize the insert.
//


PVOID
NTAPI
LLSLookupElementGenericTableFull (
    PLLS_GENERIC_TABLE Table,
    PVOID Buffer,
    OUT PVOID *NodeOrParent,
    OUT LLS_TABLE_SEARCH_RESULT *SearchResult
    );

//
//  The function EnumerateGenericTable will return to the caller one-by-one
//  the elements of of a table.  The return value is a pointer to the user
//  defined structure associated with the element.  The input parameter
//  Restart indicates if the enumeration should start from the beginning
//  or should return the next element.  If the are no more new elements to
//  return the return value is NULL.  As an example of its use, to enumerate
//  all of the elements in a table the user would write:
//
//      for (ptr = EnumerateGenericTable(Table, TRUE);
//           ptr != NULL;
//           ptr = EnumerateGenericTable(Table, FALSE)) {
//              :
//      }
//
//
//  PLEASE NOTE:
//
//      If you enumerate a GenericTable using RtlEnumerateGenericTable, you
//      will flatten the table, turning it into a sorted linked list.
//      To enumerate the table without perturbing the splay links, use
//      RtlEnumerateGenericTableWithoutSplaying


PVOID
NTAPI
LLSEnumerateGenericTable (
    PLLS_GENERIC_TABLE Table,
    BOOLEAN Restart
    );

//
//  The function EnumerateGenericTableWithoutSplaying will return to the
//  caller one-by-one the elements of of a table.  The return value is a
//  pointer to the user defined structure associated with the element.
//  The input parameter RestartKey indicates if the enumeration should
//  start from the beginning or should return the next element.  If the
//  are no more new elements to return the return value is NULL.  As an
//  example of its use, to enumerate all of the elements in a table the
//  user would write:
//
//      RestartKey = NULL;
//      for (ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey);
//           ptr != NULL;
//           ptr = EnumerateGenericTableWithoutSplaying(Table, &RestartKey)) {
//              :
//      }
//
//  If RestartKey is NULL, the package will start from the least entry in the
//  table, otherwise it will start from the last entry returned.
//
//
//  Note that unlike RtlEnumerateGenericTable, this routine will NOT perturb
//  the splay order of the tree.
//


PVOID
NTAPI
LLSEnumerateGenericTableWithoutSplaying (
    PLLS_GENERIC_TABLE Table,
    PVOID *RestartKey
    );

//
// The function GetElementGenericTable will return the i'th element
// inserted in the generic table.  I = 0 implies the first element,
// I = (RtlNumberGenericTableElements(Table)-1) will return the last element
// inserted into the generic table.  The type of I is ULONG.  Values
// of I > than (NumberGenericTableElements(Table)-1) will return NULL.  If
// an arbitrary element is deleted from the generic table it will cause
// all elements inserted after the deleted element to "move up".


PVOID
NTAPI
LLSGetElementGenericTable(
    PLLS_GENERIC_TABLE Table,
    ULONG I
    );

//
// The function NumberGenericTableElements returns a ULONG value
// which is the number of generic table elements currently inserted
// in the generic table.


ULONG
NTAPI
LLSNumberGenericTableElements(
    PLLS_GENERIC_TABLE Table
    );

//
//  The function IsGenericTableEmpty will return to the caller TRUE if
//  the input table is empty (i.e., does not contain any elements) and
//  FALSE otherwise.
//


BOOLEAN
NTAPI
LLSIsGenericTableEmpty (
    PLLS_GENERIC_TABLE Table
    );

// end_ntifs

#endif // _LLSRTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1995 - 1996

Module Name:

    makefile.inc.

!ENDIF

$(O)\llssrv.res: $(SOURCES_PATH)llssrv.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\mapping.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Mapping.c

Abstract:


Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

--*/

#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <dsgetdc.h>

#include "debug.h"
#include "llsutil.h"
#include "llssrv.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "perseat.h"

#define NO_LLS_APIS
#include "llsapi.h"


ULONG MappingListSize = 0;
PMAPPING_RECORD *MappingList = NULL;
RTL_RESOURCE MappingListLock;


/////////////////////////////////////////////////////////////////////////
NTSTATUS
MappingListInit()

/*++

Routine Description:


   The table is linear so a binary search can be used on the table.  We
   assume that adding new Mappings is a relatively rare occurance, since
   we need to sort it each time.

   The Mapping table is guarded by a read and write semaphore.  Multiple
   reads can occur, but a write blocks everything.

Arguments:

   None.

Return Value:

   None.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;

   try
   {
       RtlInitializeResource(&MappingListLock);
   } except(EXCEPTION_EXECUTE_HANDLER ) {
       status = GetExceptionCode();
   }

   return status;

} // MappingListInit


/////////////////////////////////////////////////////////////////////////
int __cdecl MappingListCompare(const void *arg1, const void *arg2) {
   PMAPPING_RECORD Svc1, Svc2;

   Svc1 = (PMAPPING_RECORD) *((PMAPPING_RECORD *) arg1);
   Svc2 = (PMAPPING_RECORD) *((PMAPPING_RECORD *) arg2);

   return lstrcmpi( Svc1->Name, Svc2->Name);

} // MappingListCompare


/////////////////////////////////////////////////////////////////////////
int __cdecl MappingUserListCompare(const void *arg1, const void *arg2) {
   LPTSTR User1, User2;

   User1 = (LPTSTR) *((LPTSTR *) arg1);
   User2 = (LPTSTR) *((LPTSTR *) arg2);

   return lstrcmpi( User1, User2);

} // MappingUserListCompare


/////////////////////////////////////////////////////////////////////////
PMAPPING_RECORD
MappingListFind(
   LPTSTR MappingName
   )

/*++

Routine Description:

   Internal routine to actually do binary search on MappingList, this
   does not do any locking as we expect the wrapper routine to do this.
   The search is a simple binary search.

Arguments:

   MappingName -

Return Value:

   Pointer to found Mapping table entry or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end = (LONG) MappingListSize - 1;
   LONG cur;
   int match;
   PMAPPING_RECORD Mapping;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MappingListFind\n"));
#endif

   if ((MappingName == NULL) || (MappingListSize == 0))
      return NULL;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;
      Mapping = MappingList[cur];

      // compare the two result into match
      match = lstrcmpi(MappingName, Mapping->Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return Mapping;
   }

   return NULL;

} // MappingListFind


/////////////////////////////////////////////////////////////////////////
LPTSTR
MappingUserListFind(
   LPTSTR User,
   ULONG NumEntries,
   LPTSTR *Users
   )

/*++

Routine Description:

   Internal routine to actually do binary search on MasterServiceList, this
   does not do any locking as we expect the wrapper routine to do this.
   The search is a simple binary search.

Arguments:

   ServiceName -

Return Value:

   Pointer to found service table entry or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end;
   LONG cur;
   int match;
   LPTSTR pUser;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MappingUserListFind\n"));
#endif

   if (NumEntries == 0)
      return NULL;

   end = (LONG) NumEntries - 1;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;
      pUser = Users[cur];

      // compare the two result into match
      match = lstrcmpi(User, pUser);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return pUser;
   }

   return NULL;

} // MappingUserListFind


/////////////////////////////////////////////////////////////////////////
PMAPPING_RECORD
MappingListUserFind( LPTSTR User )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;
   PMAPPING_RECORD pMap = NULL;

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&MappingListLock, TRUE);

   if (MappingList == NULL)
      goto MappingListUserFindExit;

   while ((i < MappingListSize) && (pMap == NULL)) {
      if (MappingUserListFind(User,  MappingList[i]->NumMembers, MappingList[i]->Members ) != NULL)
         pMap = MappingList[i];
      i++;
   }

MappingListUserFindExit:
   RtlReleaseResource(&MappingListLock);

   return pMap;
} // MappingListUserFind


/////////////////////////////////////////////////////////////////////////
PMAPPING_RECORD
MappingListAdd(
   LPTSTR MappingName,
   LPTSTR Comment,
   ULONG Licenses,
   NTSTATUS *pStatus
   )

/*++

Routine Description:

   Adds a Mapping to the Mapping table.

Arguments:

   MappingName -

Return Value:

   Pointer to added Mapping table entry, or NULL if failed.

--*/

{
   PMAPPING_RECORD NewMapping;
   LPTSTR NewMappingName;
   LPTSTR NewComment;
   PMAPPING_RECORD CurrentRecord = NULL;
   PMAPPING_RECORD *pMappingListTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MappingListAdd\n"));
#endif

   //
   // We do a double check here to see if the mapping already exists
   //
   CurrentRecord = MappingListFind(MappingName);
   if (CurrentRecord != NULL) {

      if (NULL != pStatus)
          *pStatus = STATUS_GROUP_EXISTS;

      return NULL;
   }

   //
   // Allocate space for table (zero init it).
   //
   if (MappingList == NULL)
      pMappingListTmp = (PMAPPING_RECORD *) LocalAlloc(LPTR, sizeof(PMAPPING_RECORD));
   else
      pMappingListTmp = (PMAPPING_RECORD *) LocalReAlloc(MappingList, sizeof(PMAPPING_RECORD) * (MappingListSize + 1), LHND);

   //
   // Make sure we could allocate Mapping table
   //
   if (pMappingListTmp == NULL) {
      return NULL;
   } else {
       MappingList = pMappingListTmp;
   }

   NewMapping = LocalAlloc(LPTR, sizeof(MAPPING_RECORD));
   if (NewMapping == NULL)
      return NULL;

   MappingList[MappingListSize] = NewMapping;

   NewMappingName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(MappingName) + 1) * sizeof(TCHAR));
   if (NewMappingName == NULL) {
      LocalFree(NewMapping);
      return NULL;
   }

   // now copy it over...
   NewMapping->Name = NewMappingName;
   lstrcpy(NewMappingName, MappingName);

   //
   // Allocate space for Comment
   //
   NewComment = (LPTSTR) LocalAlloc(LPTR, (lstrlen(Comment) + 1) * sizeof(TCHAR));
   if (NewComment == NULL) {
      LocalFree(NewMapping);
      LocalFree(NewMappingName);
      return NULL;
   }

   // now copy it over...
   NewMapping->Comment = NewComment;
   lstrcpy(NewComment, Comment);

   NewMapping->NumMembers = 0;
   NewMapping->Members = NULL;
   NewMapping->Licenses = Licenses;
   NewMapping->LicenseListSize = 0;
   NewMapping->LicenseList = NULL;
   NewMapping->Flags = (LLS_FLAG_LICENSED | LLS_FLAG_SUITE_AUTO);

   MappingListSize++;

   // Have added the entry - now need to sort it in order of the Mapping names
   qsort((void *) MappingList, (size_t) MappingListSize, sizeof(PMAPPING_RECORD), MappingListCompare);

   return NewMapping;

} // MappingListAdd


/////////////////////////////////////////////////////////////////////////
NTSTATUS
MappingListDelete(
   LPTSTR MappingName
   )

/*++

Routine Description:

Arguments:

   MappingName -

Return Value:


--*/

{
   PMAPPING_RECORD Mapping;
   ULONG i;
   PMAPPING_RECORD *pMappingListTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MappingListDelete\n"));
#endif

   //
   // Get mapping record based on name given
   //
   Mapping = MappingListFind(MappingName);
   if (Mapping == NULL)
      return STATUS_OBJECT_NAME_NOT_FOUND;

   //
   // Make sure there are no members to the mapping
   //
   if (Mapping->NumMembers != 0)
      return STATUS_MEMBER_IN_GROUP;

   //
   // Check if this is the last Mapping
   //
   if (MappingListSize == 1) {
      LocalFree(Mapping->Name);
      LocalFree(Mapping->Comment);
      LocalFree(Mapping);
      LocalFree(MappingList);
      MappingListSize = 0;
      MappingList = NULL;
      return STATUS_SUCCESS;
   }

   //
   // Not the last mapping so find it in the list
   //
   i = 0;
   while ((i < MappingListSize) && (lstrcmpi(MappingList[i]->Name, MappingName)))
      i++;

   //
   // Now move everything below it up.
   //
   i++;
   while (i < MappingListSize) {
      memcpy(&MappingList[i-1], &MappingList[i], sizeof(PMAPPING_RECORD));
      i++;
   }

   pMappingListTmp = (PMAPPING_RECORD *) LocalReAlloc(MappingList, sizeof(PMAPPING_RECORD) * (MappingListSize - 1), LHND);

   //
   // Make sure we could allocate Mapping table
   //
   if (pMappingListTmp != NULL)
       MappingList = pMappingListTmp;

   // 
   // if realloc failed, use old table; still decrement size, though
   //
   MappingListSize--;

   //
   // Now free up the record
   //
   LocalFree(Mapping->Name);
   LocalFree(Mapping->Comment);
   LocalFree(Mapping);

   return STATUS_SUCCESS;

} // MappingListDelete


/////////////////////////////////////////////////////////////////////////
PMAPPING_RECORD
MappingUserListAdd(
   LPTSTR MappingName,
   LPTSTR User
   )

/*++

Routine Description:


Arguments:

   MappingName -

Return Value:

   Pointer to added Mapping table entry, or NULL if failed.

--*/

{
   PMAPPING_RECORD Mapping;
   LPTSTR NewName;
   LPTSTR pUser;
   LPTSTR *pMembersTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MappingUserListAdd\n"));
#endif

   //
   // Get mapping record based on name given
   //
   Mapping = MappingListFind(MappingName);
   if (Mapping == NULL)
      return NULL;

   //
   // We do a double check here to see if another thread just got done
   // adding the Mapping, between when we checked last and actually got
   // the write lock.
   //
   pUser = MappingUserListFind(User, Mapping->NumMembers, Mapping->Members);

   if (pUser != NULL) {
      return Mapping;
   }

   //
   // Allocate space for table (zero init it).
   //
   if (Mapping->Members == NULL)
      pMembersTmp = (LPTSTR *) LocalAlloc(LPTR, sizeof(LPTSTR));
   else
      pMembersTmp = (LPTSTR *) LocalReAlloc(Mapping->Members, sizeof(LPTSTR) * (Mapping->NumMembers + 1), LHND);

   //
   // Make sure we could allocate Mapping table
   //
   if (pMembersTmp == NULL) {
      return NULL;
   } else {
       Mapping->Members = pMembersTmp;
   }

   NewName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(User) + 1) * sizeof(TCHAR));
   if (NewName == NULL)
      return NULL;

   // now copy it over...
   Mapping->Members[Mapping->NumMembers] = NewName;
   lstrcpy(NewName, User);

   Mapping->NumMembers++;

   // Have added the entry - now need to sort it in order of the Mapping names
   qsort((void *) Mapping->Members, (size_t) Mapping->NumMembers, sizeof(LPTSTR), MappingUserListCompare);

   return Mapping;

} // MappingUserListAdd


/////////////////////////////////////////////////////////////////////////
NTSTATUS
MappingUserListDelete(
   LPTSTR MappingName,
   LPTSTR User
   )

/*++

Routine Description:


Arguments:

   MappingName -

Return Value:

   Pointer to added Mapping table entry, or NULL if failed.

--*/

{
   PMAPPING_RECORD Mapping;
   LPTSTR pUser;
   ULONG i;
   LPTSTR *pMembersTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MappingUserListDelete\n"));
#endif

   //
   // Get mapping record based on name given
   //
   Mapping = MappingListFind(MappingName);
   if (Mapping == NULL)
      return STATUS_OBJECT_NAME_NOT_FOUND;

   //
   // Find the given user
   //
   pUser = MappingUserListFind(User, Mapping->NumMembers, Mapping->Members);
   if (pUser == NULL)
      return STATUS_OBJECT_NAME_NOT_FOUND;

   //
   // Check if this is the last user
   //
   if (Mapping->NumMembers == 1) {
      LocalFree(pUser);
      LocalFree(Mapping->Members);
      Mapping->Members = NULL;
      Mapping->NumMembers = 0;
      return STATUS_SUCCESS;
   }

   //
   // Not the last member so find it in the list
   //
   i = 0;
   while ((i < Mapping->NumMembers) && (lstrcmpi(Mapping->Members[i], User)))
      i++;

   //
   // Now move everything below it up.
   //
   i++;
   while (i < Mapping->NumMembers) {
      memcpy(&Mapping->Members[i-1], &Mapping->Members[i], sizeof(LPTSTR));
      i++;
   }

   pMembersTmp = (LPTSTR *) LocalReAlloc(Mapping->Members, sizeof(LPTSTR) * (Mapping->NumMembers - 1), LHND);

   //
   // Make sure we could allocate Mapping table
   //
   if (pMembersTmp != NULL) {
      Mapping->Members = pMembersTmp;
   }

   Mapping->NumMembers--;

   LocalFree(pUser);
   return STATUS_SUCCESS;

} // MappingUserListDelete


#if DBG
/////////////////////////////////////////////////////////////////////////
VOID
MappingListDebugDump( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&MappingListLock, TRUE);

   dprintf(TEXT("Mapping Table, # Entries: %lu\n"), MappingListSize);
   if (MappingList == NULL)
      goto MappingListDebugDumpExit;

   for (i = 0; i < MappingListSize; i++) {
      dprintf(TEXT("   Name: %s Flags: 0x%4lX LT: %2lu Lic: %4lu # Mem: %4lu Comment: %s\n"),
          MappingList[i]->Name, MappingList[i]->Flags, MappingList[i]->LicenseListSize, MappingList[i]->Licenses, MappingList[i]->NumMembers, MappingList[i]->Comment);
   }

MappingListDebugDumpExit:
   RtlReleaseResource(&MappingListLock);

   return;
} // MappingListDebugDump


/////////////////////////////////////////////////////////////////////////
VOID
MappingListDebugInfoDump( PVOID Data )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i;
   PMAPPING_RECORD Mapping = NULL;

   RtlAcquireResourceShared(&MappingListLock, TRUE);
   dprintf(TEXT("Mapping Table, # Entries: %lu\n"), MappingListSize);

   if (Data == NULL)
      goto MappingListDebugInfoDumpExit;

   if (MappingList == NULL)
      goto MappingListDebugInfoDumpExit;

   if (lstrlen((LPWSTR) Data) > 0) {
      Mapping = MappingListFind((LPTSTR) Data);

      if (Mapping != NULL) {
         dprintf(TEXT("   Name: %s Flags: 0x%4lX LT: %2lu Lic: %4lu # Mem: %4lu Comment: %s\n"),
             Mapping->Name, Mapping->Flags, Mapping->LicenseListSize, Mapping->Licenses, Mapping->NumMembers, Mapping->Comment);

         if (Mapping->NumMembers != 0)
            dprintf(TEXT("\nMembers\n"));

         for (i = 0; i < Mapping->NumMembers; i++)
            dprintf(TEXT("      %s\n"), Mapping->Members[i]);

         if (Mapping->LicenseListSize != 0)
            dprintf(TEXT("\nLicenseTable\n"));

         for (i = 0; i < Mapping->LicenseListSize; i++)
            dprintf( TEXT("      Flags: 0x%4lX Ref: %2lu LN: %2lu Svc: %s\n"),
                     Mapping->LicenseList[i]->Flags,
                     Mapping->LicenseList[i]->RefCount,
                     Mapping->LicenseList[i]->LicensesNeeded,
                     Mapping->LicenseList[i]->Service->Name );

      } else
         dprintf(TEXT("Mapping not found: %s\n"), (LPTSTR) Data);
   }

MappingListDebugInfoDumpExit:
   RtlReleaseResource(&MappingListLock);

} // MappingListDebugInfoDump

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\mapping.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Mapping.h

Abstract:


Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

--*/


#ifndef _LLS_MAPPING_H
#define _LLS_MAPPING_H


#ifdef __cplusplus
extern "C" {
#endif

struct _USER_LICENSE_RECORD;

typedef struct _MAPPING_RECORD {
   LPTSTR Name;
   DWORD Flags;
   LPTSTR Comment;
   ULONG Licenses;
   ULONG NumMembers;
   LPTSTR *Members;

   ULONG LicenseListSize;
   struct _USER_LICENSE_RECORD **LicenseList;
} MAPPING_RECORD, *PMAPPING_RECORD;


NTSTATUS MappingListInit();
PMAPPING_RECORD MappingListFind( LPTSTR MappingName );
LPTSTR MappingUserListFind( LPTSTR User, ULONG NumEntries, LPTSTR *Users );
PMAPPING_RECORD MappingListAdd( LPTSTR MappingName, LPTSTR Comment, ULONG Licenses, NTSTATUS *pStatus );
NTSTATUS MappingListDelete( LPTSTR MappingName );
PMAPPING_RECORD MappingUserListAdd( LPTSTR MappingName, LPTSTR User );
PMAPPING_RECORD MappingListUserFind( LPTSTR User );
NTSTATUS MappingUserListDelete( LPTSTR MappingName, LPTSTR User );

extern ULONG MappingListSize;
extern PMAPPING_RECORD *MappingList;
extern RTL_RESOURCE MappingListLock;

#if DBG

VOID MappingListDebugDump();
VOID MappingListDebugInfoDump( PVOID Data );

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\pack.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   Pack.h

Abstract:


Author:

   Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added new fields to purchase record to support secure certificates.
      o  Unified per server purchase model with per seat purchase model for
         secure certificates; per server model still done in the traditional
         manner for non-secure certificates (for backwards compatibility).
      o  Added SaveAll() function analogous to LoadAll().
      o  Added support for extended user data packing/unpacking.  This was
         done to save the SUITE_USE flag across restarts of the service.
      o  Removed user table parameters from unpack routines that didn't use
         them.

--*/

#ifndef _LLS_PACK_H
#define _LLS_PACK_H


#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////
//
// Save / Load Mapping
//
#define MAPPING_FILE_VERSION 0x0100

typedef struct _PACK_MAPPING_RECORD {
   LPTSTR Name;
   LPTSTR Comment;
   ULONG Licenses;
} PACK_MAPPING_RECORD, *PPACK_MAPPING_RECORD;

typedef struct _PACK_MAPPING_USER_RECORD {
   ULONG Mapping;
   LPTSTR Name;
} PACK_MAPPING_USER_RECORD, *PPACK_MAPPING_USER_RECORD;

typedef struct _MAPPING_FILE_HEADER {
   ULONG MappingUserTableSize;
   ULONG MappingUserStringSize;
   ULONG MappingTableSize;
   ULONG MappingStringSize;
} MAPPING_FILE_HEADER, *PMAPPING_FILE_HEADER;


/////////////////////////////////////////////////////////////////////
//
// Save / Load License
//

/////////////////  OLD (3.51) FORMAT ////////////////////
#define LICENSE_FILE_VERSION_0 0x0100

typedef struct _PACK_LICENSE_PURCHASE_RECORD_0 {
   ULONG Service;
   LONG NumberLicenses;
   DWORD Date;
   LPTSTR Admin;
   LPTSTR Comment;
} PACK_LICENSE_PURCHASE_RECORD_0, *PPACK_LICENSE_PURCHASE_RECORD_0;

typedef struct _LICENSE_FILE_HEADER_0 {
   ULONG LicenseServiceTableSize;
   ULONG LicenseServiceStringSize;
   ULONG LicenseTableSize;
   ULONG LicenseStringSize;
} LICENSE_FILE_HEADER_0, *PLICENSE_FILE_HEADER_0;

/////////////////  NEW FORMAT ////////////////////
#define LICENSE_FILE_VERSION 0x0201

typedef struct _PACK_LICENSE_SERVICE_RECORD {
   LPTSTR ServiceName;
   LONG NumberLicenses;
} PACK_LICENSE_SERVICE_RECORD, *PPACK_LICENSE_SERVICE_RECORD;

typedef struct _PACK_LICENSE_PURCHASE_RECORD {
   ULONG Service;
   LONG NumberLicenses;
   DWORD Date;
   LPTSTR Admin;
   LPTSTR Comment;

   // new for SUR: (see description in purchase.h)
   ULONG    PerServerService;
   DWORD    AllowedModes;
   DWORD    CertificateID;
   LPTSTR   Source;
   DWORD    ExpirationDate;
   DWORD    MaxQuantity;
   LPTSTR   Vendor;
   DWORD    Secrets[ LLS_NUM_SECRETS ];
} PACK_LICENSE_PURCHASE_RECORD, *PPACK_LICENSE_PURCHASE_RECORD;

typedef struct _LICENSE_FILE_HEADER {
   ULONG LicenseServiceTableSize;
   ULONG LicenseServiceStringSize;

   ULONG LicenseTableSize;
   ULONG LicenseStringSize;

   // new for SUR:
   ULONG PerServerLicenseServiceTableSize;
   ULONG PerServerLicenseServiceStringSize;

} LICENSE_FILE_HEADER, *PLICENSE_FILE_HEADER;


/////////////////////////////////////////////////////////////////////
//
// Save / Load LLS Data
//

/////////////////  OLD (3.51) FORMAT ////////////////////
#define USER_FILE_VERSION_0 0x0100

typedef struct _LLS_DATA_FILE_HEADER_0 {
   ULONG ServiceTableSize;
   ULONG ServiceStringSize;
   ULONG ServerTableSize;
   ULONG ServerStringSize;
   ULONG ServerServiceTableSize;
   ULONG UserTableSize;
   ULONG UserStringSize;
} LLS_DATA_FILE_HEADER_0, *PLLS_DATA_FILE_HEADER_0;

/////////////////  NEW FORMAT ////////////////////
#define USER_FILE_VERSION 0x0200

typedef struct _LLS_DATA_FILE_HEADER {
   ULONG ServiceLevel;
   ULONG ServiceTableSize;
   ULONG ServiceStringSize;

   ULONG ServerLevel;
   ULONG ServerTableSize;
   ULONG ServerStringSize;

   ULONG ServerServiceLevel;
   ULONG ServerServiceTableSize;

   ULONG UserLevel;
   ULONG UserTableSize;
   ULONG UserStringSize;
} LLS_DATA_FILE_HEADER, *PLLS_DATA_FILE_HEADER;



VOID LicenseListLoad();
NTSTATUS LicenseListSave();
VOID MappingListLoad();
NTSTATUS MappingListSave();
VOID LLSDataLoad();
NTSTATUS LLSDataSave();

VOID LoadAll ( );
VOID SaveAll ( );

NTSTATUS ServiceListPack ( ULONG *pServiceTableSize, PREPL_SERVICE_RECORD *pServices );
VOID     ServiceListUnpack ( ULONG   ServiceTableSize, PREPL_SERVICE_RECORD Services, ULONG ServerTableSize, PREPL_SERVER_RECORD Servers, ULONG ServerServiceTableSize, PREPL_SERVER_SERVICE_RECORD ServerServices );
NTSTATUS ServerListPack ( ULONG *pServerTableSize, PREPL_SERVER_RECORD *pServers );
VOID     ServerListUnpack ( ULONG   ServiceTableSize, PREPL_SERVICE_RECORD Services, ULONG ServerTableSize, PREPL_SERVER_RECORD Servers, ULONG ServerServiceTableSize, PREPL_SERVER_SERVICE_RECORD ServerServices );
NTSTATUS ServerServiceListPack ( ULONG *pServerServiceTableSize, PREPL_SERVER_SERVICE_RECORD *pServerServices );
VOID     ServerServiceListUnpack ( ULONG ServiceTableSize, PREPL_SERVICE_RECORD Services, ULONG ServerTableSize, PREPL_SERVER_RECORD Servers, ULONG ServerServiceTableSize, PREPL_SERVER_SERVICE_RECORD ServerServices );
NTSTATUS UserListPack ( DWORD LastReplicated, ULONG UserLevel, ULONG *pUserTableSize, LPVOID *pUsers );
VOID     UserListUnpack ( ULONG ServiceTableSize, PREPL_SERVICE_RECORD Services, ULONG ServerTableSize, PREPL_SERVER_RECORD Servers, ULONG ServerServiceTableSize, PREPL_SERVER_SERVICE_RECORD ServerServices, ULONG UserLevel, ULONG UserTableSize, LPVOID Users );
NTSTATUS PackAll ( DWORD LastReplicated, ULONG *pServiceTableSize, PREPL_SERVICE_RECORD *pServices, ULONG *pServerTableSize, PREPL_SERVER_RECORD *pServers, ULONG *pServerServiceTableSize, PREPL_SERVER_SERVICE_RECORD *pServerServices, ULONG UserLevel, ULONG *pUserTableSize, LPVOID *pUsers );
VOID     UnpackAll ( ULONG ServiceTableSize, PREPL_SERVICE_RECORD Services, ULONG ServerTableSize, PREPL_SERVER_RECORD Servers, ULONG ServerServiceTableSize, PREPL_SERVER_SERVICE_RECORD ServerServices, ULONG UserLevel, ULONG UserTableSize, LPVOID Users );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\perseat.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    perseat.c

Abstract:

   Routines to handle per-seat licensing.  Handles the in-memory cache
   of useage via the Rtl Generic table functions (these are a generic
   splay tree package).

   There can be up to three tables kept.  The first table is a username
   table and is the main table.  The second table is for SID's, which will
   be converted into usernames when replicated.

   The SID and username trees are handled in this module as they are used
   by all modes of the server.

Author:

   Arthur Hanson (arth) 03-Jan-1995

Revision History:

   Jeff Parham (jeffparh) 12-Jan-1996
      o  Fixed possible infinite loop in UserListLicenseDelete().
      o  In FamilyLicenseUpdate(), now rescans for BackOffice upgrades
         regardless of whether the family being updated was BackOffice.
         This fixes a problem wherein a freed BackOffice license was
         not being assigned to a user that needed it.  (Bug #3299.)
      o  Added support for maintaining the SUITE_USE flag when adding
         users to the AddCache.

--*/

#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <dsgetdc.h>

#include "debug.h"
#include "llsutil.h"
#include "llssrv.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "perseat.h"
#include "llsevent.h"
#include "llsrtl.h"

#define NO_LLS_APIS
#include "llsapi.h"

//
// At what # of product do we switch to BackOffice
//
#define BACKOFFICE_SWITCH 3

NTSTATUS GetDCInfo(
                DWORD                     ccDomain,
                WCHAR                     wszDomain[],
                DOMAIN_CONTROLLER_INFO ** ppDCInfo);

/////////////////////////////////////////////////////////////////////////
//
// Actual User and SID Lists, and their access locks
//
ULONG UserListNumEntries = 0;
static ULONG SidListNumEntries = 0;
LLS_GENERIC_TABLE UserList;
static LLS_GENERIC_TABLE SidList;

RTL_RESOURCE UserListLock;
static RTL_RESOURCE SidListLock;

/////////////////////////////////////////////////////////////////////////
//
// The AddCache itself, a critical section to protect access to it and an
// event to signal the server when there are items on it that need to be
// processed.
//
PADD_CACHE AddCache = NULL;
ULONG AddCacheSize = 0;
RTL_CRITICAL_SECTION AddCacheLock;
HANDLE LLSAddCacheEvent;

DWORD LastUsedTime = 0;
BOOL UsersDeleted = FALSE;


static RTL_CRITICAL_SECTION GenTableLock;

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// The License List is a linear list of all the licenses the object is
// using.
//
// The license list is kept as part of each user and mapping record, if
// the user is mapped then the mapping should contain the license list.
// The structure is a sorted array of pointers to License Records, and
// access is controled by the ServiceTableLock.
//
// The license is identified by the Service Family Name (the license list
// is sorted on this).
//

/////////////////////////////////////////////////////////////////////////
int __cdecl
LicenseListCompare(const void *arg1, const void *arg2) {
   PUSER_LICENSE_RECORD pLic1, pLic2;

   pLic1 = (PUSER_LICENSE_RECORD) *((PUSER_LICENSE_RECORD *) arg1);
   pLic2 = (PUSER_LICENSE_RECORD) *((PUSER_LICENSE_RECORD *) arg2);

   return lstrcmpi( pLic1->Family->Name, pLic2->Family->Name );

} // LicenseListCompare


/////////////////////////////////////////////////////////////////////////
PUSER_LICENSE_RECORD
LicenseListFind(
   LPTSTR Name,
   PUSER_LICENSE_RECORD *pLicenseList,
   ULONG NumTableEntries
   )

/*++

Routine Description:

   Find the license in a license list for the given Family of products.

Arguments:

   Name - Name of product family to find license for.

   pLicenseList - Size of the license list to search.

   NumTableEntries - Pointer to the license List to search.

Return Value:

   Pointer to the found License Record, or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end = (LONG) NumTableEntries - 1;
   LONG cur;
   int match;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LicenseListFind\n"));
#endif

   if ((Name == NULL) || (pLicenseList == NULL) || (NumTableEntries == 0))
      return NULL;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;

      // compare the two result into match
      match = lstrcmpi(Name, pLicenseList[cur]->Family->Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return pLicenseList[cur];
   }

   return NULL;

} // LicenseListFind


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LicenseListDelete(
   PMASTER_SERVICE_ROOT Family,
   PUSER_LICENSE_RECORD **pLicenses,
   PULONG pLicenseListSize
   )

/*++

Routine Description:

  Delete the given license from the license list.

Arguments:

   Family -

   pLicenses -

   pLicenseListSize -

Return Value:

   STATUS_SUCCESS if successful, else error code.

--*/

{
   PUSER_LICENSE_RECORD *LicenseList;
   ULONG LicenseListSize;
   PUSER_LICENSE_RECORD LicenseRec;
   ULONG i;
   PUSER_LICENSE_RECORD *pLicenseListTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LicenseListDelete\n"));
#endif

   if ( (pLicenses == NULL) || (pLicenseListSize == NULL) )
      return STATUS_OBJECT_NAME_NOT_FOUND;

   LicenseListSize = *pLicenseListSize;
   LicenseList = *pLicenses;

   //
   // Get record based on name given
   //
   LicenseRec = LicenseListFind(Family->Name, LicenseList, LicenseListSize);
   if (LicenseRec == NULL)
      return STATUS_OBJECT_NAME_NOT_FOUND;

   //
   // Check if this is the last user
   //
   if (LicenseListSize == 1) {
      LocalFree(LicenseList);
      *pLicenseListSize = 0;
      *pLicenses = NULL;
      return STATUS_SUCCESS;
   }

   //
   // Not the last so find it in the list
   //
   i = 0;
   while ( (i < LicenseListSize) && (LicenseList[i]->Family != Family) )
      i++;

   //
   // Now move everything below it up.
   //
   i++;
   while (i < LicenseListSize) {
      LicenseList[i-1] = LicenseList[i];
      i++;
   }

   pLicenseListTmp = (PUSER_LICENSE_RECORD *) LocalReAlloc(LicenseList, sizeof(PUSER_LICENSE_RECORD) * (LicenseListSize - 1), LHND);

   //
   // Make sure we could allocate table
   //
   if (pLicenseListTmp != NULL) {
      LicenseList = pLicenseListTmp;
   }

   LicenseListSize--;

   LocalFree(LicenseRec);
   *pLicenses = LicenseList;
   *pLicenseListSize = LicenseListSize;

   return STATUS_SUCCESS;

} // LicenseListDelete


/////////////////////////////////////////////////////////////////////////
PUSER_LICENSE_RECORD
LicenseListAdd(
   PMASTER_SERVICE_ROOT Family,
   PUSER_LICENSE_RECORD **pLicenses,
   PULONG pLicenseListSize
   )

/*++

Routine Description:

   Adds an empty license record to the license list.  Sets the license
   family, but not any of the other info.

Arguments:


Return Value:


--*/

{
   PUSER_LICENSE_RECORD *LicenseList;
   ULONG LicenseListSize;
   PUSER_LICENSE_RECORD LicenseRec;
   PUSER_LICENSE_RECORD *pLicenseListTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LicenseListAdd\n"));
#endif

   if ((Family == NULL) || (pLicenses == NULL) || (pLicenseListSize == NULL) )
      return NULL;

   LicenseList = *pLicenses;
   LicenseListSize = *pLicenseListSize;

   //
   // We do a double check here to see if another thread just got done
   // adding the Mapping, between when we checked last and actually got
   // the write lock.
   //
   LicenseRec = LicenseListFind(Family->Name, LicenseList, LicenseListSize );

   if (LicenseRec != NULL) {
      return LicenseRec;
   }

   LicenseRec = (PUSER_LICENSE_RECORD) LocalAlloc(LPTR, sizeof(USER_LICENSE_RECORD));
   if (LicenseRec == NULL) {
      ASSERT(FALSE);
      return NULL;
   }

   //
   // Allocate space for table (zero init it).
   //
   if (LicenseList == NULL)
      pLicenseListTmp = (PUSER_LICENSE_RECORD *) LocalAlloc(LPTR, sizeof(PUSER_LICENSE_RECORD));
   else
      pLicenseListTmp = (PUSER_LICENSE_RECORD *) LocalReAlloc(LicenseList, sizeof(PUSER_LICENSE_RECORD) * (LicenseListSize + 1), LHND);

   //
   // Make sure we could allocate Mapping table
   //
   if (pLicenseListTmp == NULL) {
       LocalFree(LicenseRec);
      return NULL;
   } else {
       LicenseList = pLicenseListTmp;
   }

   // now copy it over...
   LicenseList[LicenseListSize] = LicenseRec;
   LicenseRec->Family = Family;
   LicenseRec->Flags = LLS_FLAG_LICENSED;
   LicenseRec->RefCount = 0;
   LicenseRec->Service = NULL;
   LicenseRec->LicensesNeeded = 0;

   LicenseListSize++;

   // Have added the entry - now need to sort it in order of the names
   qsort((void *) LicenseList, (size_t) LicenseListSize, sizeof(PUSER_LICENSE_RECORD), LicenseListCompare);

   *pLicenses = LicenseList;
   *pLicenseListSize = LicenseListSize;
   return LicenseRec;

} // LicenseListAdd


/////////////////////////////////////////////////////////////////////////
// These routines are specific to the license list in the user and
// mapping records.
/////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
VOID
UserLicenseListFree (
   PUSER_RECORD pUser
   )

/*++

Routine Description:

   Walks the license list deleting all entries and freeing up any claimed
   licenses from the service table.  This only cleans up the licenses
   in a user record (not a mapping) so the # licenses is always 1.

Arguments:


Return Value:


--*/

{
   ULONG i;
   BOOL ReScan = FALSE;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: UserLicenseListFree\n"));
#endif

   //
   // Walk license table and free all licenses
   //
   for (i = 0; i < pUser->LicenseListSize; i++) {
      pUser->LicenseList[i]->Service->LicensesUsed -= 1;
      pUser->LicenseList[i]->Service->LicensesClaimed -= (1 - pUser->LicenseList[i]->LicensesNeeded);
      pUser->LicenseList[i]->Service->Family->Flags |= LLS_FLAG_UPDATE;
      ReScan = TRUE;
      LocalFree(pUser->LicenseList[i]);
   }

   //
   // Free related entries in user list
   //
   if (pUser->LicenseList != NULL)
      LocalFree(pUser->LicenseList);

   pUser->LicenseList = NULL;
   pUser->LicenseListSize = 0;
   pUser->LicensedProducts = 0;

   //
   // Get rid of pointers in services table
   //
   for (i = 0; i < pUser->ServiceTableSize; i++)
      pUser->Services[i].License = NULL;

   //
   // Check if we freed up licenses and need to re-scan the user-table
   //
   if (ReScan) {
      //
      // Set to licensed so scan doesn't assign to ourself
      //
      pUser->Flags |= LLS_FLAG_LICENSED;

      for (i = 0; i < RootServiceListSize; i++) {
         if (RootServiceList[i]->Flags & LLS_FLAG_UPDATE) {
            RootServiceList[i]->Flags &= ~LLS_FLAG_UPDATE;
            FamilyLicenseUpdate( RootServiceList[i] );
         }
      }

      if (pUser->ServiceTableSize > 0)
         pUser->Flags &= ~LLS_FLAG_LICENSED;
   }
} // UserLicenseListFree


/////////////////////////////////////////////////////////////////////////
VOID
MappingLicenseListFree (
   PMAPPING_RECORD pMap
   )

/*++

Routine Description:

   Walks the license list in a mapping freeing up any claimed licenses.
   Like UserLicenseListFree, but for a mapping.

Arguments:


Return Value:


--*/

{
   ULONG i;
   BOOL ReScan = FALSE;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MappingLicenseListFree\n"));
#endif

   //
   // Walk license table and free all licenses
   //
   for (i = 0; i < pMap->LicenseListSize; i++) {
      pMap->LicenseList[i]->Service->LicensesUsed -= pMap->Licenses;
      pMap->LicenseList[i]->Service->LicensesClaimed -= (pMap->Licenses - pMap->LicenseList[i]->LicensesNeeded);
      pMap->LicenseList[i]->Service->Family->Flags |= LLS_FLAG_UPDATE;
      ReScan = TRUE;
      LocalFree(pMap->LicenseList[i]);
   }

   //
   // Free related entries in mapping list
   //
   if (pMap->LicenseList != NULL)
      LocalFree(pMap->LicenseList);

   pMap->LicenseList = NULL;
   pMap->LicenseListSize = 0;

   //
   // Check if we freed up licenses and need to re-scan the user-table
   //
   if (ReScan)
      for (i = 0; i < RootServiceListSize; i++) {
         if (RootServiceList[i]->Flags & LLS_FLAG_UPDATE) {
            RootServiceList[i]->Flags &= ~LLS_FLAG_UPDATE;
            FamilyLicenseUpdate( RootServiceList[i] );
         }
      }

} // MappingLicenseListFree



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// The service table is a linear array of records pointed to by the
// user record.  Each entry contains a pointer into the service table
// identifying the service, some statistical useage information and a
// pointer into the license table identifying the license used by the
// service.
//

/////////////////////////////////////////////////////////////////////////
int __cdecl
SvcListCompare(
   const void *arg1,
   const void *arg2
   )
{
   PSVC_RECORD pSvc1, pSvc2;

   pSvc1 = (PSVC_RECORD) arg1;
   pSvc2 = (PSVC_RECORD) arg2;

   return lstrcmpi( pSvc1->Service->Name, pSvc2->Service->Name );

} // SvcListCompare


/////////////////////////////////////////////////////////////////////////
PSVC_RECORD
SvcListFind(
   LPTSTR DisplayName,
   PSVC_RECORD ServiceList,
   ULONG NumTableEntries
   )

/*++

Routine Description:

   Internal routine to actually do binary search on Service List in user
   record.  This is a binary search, however since the string pointers are
   from the service table and therefore the pointers are fixed, we only
   need to compare the pointers, not the strings themselves to find a
   match.

Arguments:

   ServiceName -

Return Value:

   Pointer to found service table entry or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end = (LONG) NumTableEntries - 1;
   LONG cur;
   int match;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: SvcListFind\n"));
#endif
   if ((DisplayName == NULL) || (ServiceList == NULL) || (NumTableEntries == 0))
      return NULL;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;

      // compare the two result into match
      match = lstrcmpi(DisplayName, ServiceList[cur].Service->Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return &ServiceList[cur];
   }

   return NULL;

} // SvcListFind


/////////////////////////////////////////////////////////////////////////
NTSTATUS
SvcListDelete(
   LPTSTR UserName,
   LPTSTR ServiceName
)

/*++

Routine Description:

   Deletes a service record from the service table.

Arguments:


Return Value:


--*/

{
   PUSER_RECORD pUserRec;
   PSVC_RECORD pService;
   PSVC_RECORD SvcTable = NULL;
   PUSER_LICENSE_RECORD License = NULL;
   ULONG NumLicenses = 1;
   ULONG i;
   BOOL ReScan = FALSE;
   PMASTER_SERVICE_ROOT Family = NULL;
   PSVC_RECORD pSvcTableTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: SvcListDelete\n"));
#endif

   pUserRec = UserListFind(UserName);
   if (pUserRec == NULL)
      return STATUS_OBJECT_NAME_NOT_FOUND;

   RtlEnterCriticalSection(&pUserRec->ServiceTableLock);
   pService = SvcListFind( ServiceName, pUserRec->Services, pUserRec->ServiceTableSize );

   //
   // If we couldn't find it then get out.
   //
   if (pService == NULL) {
      RtlLeaveCriticalSection(&pUserRec->ServiceTableLock);
      return STATUS_OBJECT_NAME_NOT_FOUND;
   }

   Family = pService->Service->Family;

   //
   // If we are a mapping then we may use more then one license
   //
   if (pUserRec->Mapping != NULL)
      NumLicenses = pUserRec->Mapping->Licenses;

   License = pService->License;

   if (License != NULL) {
      License->RefCount--;

      //
      // If this is the last service that uses this license then we need
      // to get rid of it.
      //
      if (License->RefCount == 0) {
         License->Service->LicensesUsed -= NumLicenses;
         NumLicenses -= License->LicensesNeeded;
         License->Service->LicensesClaimed -= NumLicenses;

         //
         // Do we need to delete it from the mapping or user license table?
         //
         if (pUserRec->Mapping != NULL) {
            if ((License->Service == BackOfficeRec) && (pUserRec->Mapping->Flags & LLS_FLAG_SUITE_AUTO))
               pUserRec->Mapping->Flags &= ~LLS_FLAG_SUITE_USE;

            LicenseListDelete(License->Service->Family, &pUserRec->Mapping->LicenseList, &pUserRec->Mapping->LicenseListSize );

         } else {
            if ((License->Service == BackOfficeRec) && (pUserRec->Flags & LLS_FLAG_SUITE_AUTO))
               pUserRec->Flags &= ~LLS_FLAG_SUITE_USE;

            LicenseListDelete(License->Service->Family, &pUserRec->LicenseList, &pUserRec->LicenseListSize );
         }

         //
         // Freed a license so need to scan and adjust counts
         //
         ReScan = TRUE;
      }
   }

   if (pService->Flags & LLS_FLAG_LICENSED)
      pUserRec->LicensedProducts--;
   else {
      //
      // This was an unlicensed product - see if this makes the user
      // licensed
      //
      if (pUserRec->LicensedProducts == (pUserRec->ServiceTableSize - 1))
         pUserRec->Flags |= LLS_FLAG_LICENSED;
   }

   //
   // First check if this is the only entry in the table
   //
   if (pUserRec->ServiceTableSize == 1) {
      LocalFree(pUserRec->Services);
      pUserRec->Services = NULL;
      goto SvcListDeleteExit;
   }

   //
   // Find this record linearly in the table.
   //
   i = 0;
   while ((i < pUserRec->ServiceTableSize) && (lstrcmpi(pUserRec->Services[i].Service->Name, ServiceName)))
      i++;

   //
   // Now move everything below it up.
   //
   i++;
   while (i < pUserRec->ServiceTableSize) {
      memcpy(&pUserRec->Services[i-1], &pUserRec->Services[i], sizeof(SVC_RECORD));
      i++;
   }

   pSvcTableTmp = (PSVC_RECORD) LocalReAlloc( pUserRec->Services, sizeof(SVC_RECORD) * (pUserRec->ServiceTableSize - 1), LHND);

   if (pSvcTableTmp == NULL) {
      pUserRec->ServiceTableSize--;
      RtlLeaveCriticalSection(&pUserRec->ServiceTableLock);
      return STATUS_SUCCESS;
   } else {
       SvcTable = pSvcTableTmp;
   }

   pUserRec->Services = SvcTable;

SvcListDeleteExit:
   pUserRec->ServiceTableSize--;

   if (pUserRec->ServiceTableSize == 0)
      pUserRec->Services = NULL;

   RtlLeaveCriticalSection(&pUserRec->ServiceTableLock);

   if (ReScan)
      FamilyLicenseUpdate ( Family );

   return STATUS_SUCCESS;

} // SvcListDelete


/////////////////////////////////////////////////////////////////////////
VOID
SvcListLicenseFree(
   PUSER_RECORD pUser
)

/*++

Routine Description:


   Walk the services table and free up any licenses they are using.  If the
   licenses are then no longer needed (refCount == 0) then the license is
   deleted.

Arguments:


Return Value:


--*/

{
   ULONG i;
   ULONG NumLicenses = 1;
   PUSER_LICENSE_RECORD License = NULL;
   BOOL ReScan = FALSE;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: SvcListLicenseFree\n"));
#endif

   //
   // If we are a mapping then we may use more then one license
   //
   for (i = 0; i < pUser->ServiceTableSize; i++) {

      if (pUser->Mapping != NULL)
         NumLicenses = pUser->Mapping->Licenses;
      else
         NumLicenses = 1;

      License = pUser->Services[i].License;

      if (License != NULL) {
         License->RefCount--;

         //
         // If this is the last service that uses this license then we need
         // to get rid of it.
         //
         if (License->RefCount == 0) {
            if ( (pUser->Mapping != NULL) && (License->Service == BackOfficeRec) && (pUser->Mapping->Flags & LLS_FLAG_SUITE_AUTO) )
               pUser->Mapping->Flags &= ~LLS_FLAG_SUITE_USE;

            License->Service->LicensesUsed -= NumLicenses;
            NumLicenses -= License->LicensesNeeded;

            if (License->Service->LicensesClaimed > 0) {
               //
               // Freed a license so need to scan and adjust counts
               //
               License->Service->Family->Flags |= LLS_FLAG_UPDATE;
               ReScan = TRUE;
            }

            License->Service->LicensesClaimed -= NumLicenses;

            if (pUser->Mapping != NULL)
               LicenseListDelete(License->Service->Family, &pUser->Mapping->LicenseList, &pUser->Mapping->LicenseListSize );
            else
               LicenseListDelete(License->Service->Family, &pUser->LicenseList, &pUser->LicenseListSize );

         }
      }

      pUser->Services[i].License = NULL;
   }

   pUser->LicensedProducts = 0;

   //
   // Check if we freed up licenses and need to re-scan the user-table
   //
   if (ReScan) {
      //
      // Flag license so rescan won't worry about this user
      //
      pUser->Flags |= LLS_FLAG_LICENSED;

      for (i = 0; i < RootServiceListSize; i++) {
         if (RootServiceList[i]->Flags & LLS_FLAG_UPDATE) {
            RootServiceList[i]->Flags &= ~LLS_FLAG_UPDATE;
            FamilyLicenseUpdate( RootServiceList[i] );
         }
      }
   }

} // SvcListLicenseFree


/////////////////////////////////////////////////////////////////////////
VOID
SvcListLicenseUpdate(
   PUSER_RECORD pUser
)

/*++

Routine Description:

   Walk the services table and assign the appropriate license to each
   service.  This is the opposite of the SvcListLicenseFree Routine.

Arguments:


Return Value:


--*/

{
   ULONG i;
   ULONG Claimed = 0;
   PUSER_LICENSE_RECORD License = NULL;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: SvcListLicenseUpdate\n"));
#endif

   //
   // Check if user is set to use BackOffice
   if ( pUser->Flags & LLS_FLAG_SUITE_USE ) {
      //
      // Go grab a backoffice license to fulfill the suite useage
      //
      License = LicenseListAdd(BackOfficeRec->Family, &pUser->LicenseList, &pUser->LicenseListSize);

      ASSERT(License != NULL);
      if (License != NULL) {
         License->Service = BackOfficeRec;
         RtlAcquireResourceExclusive(&MasterServiceListLock, TRUE);

         // Can only claim a # of licenses that we have
         if ( BackOfficeRec->LicensesClaimed < BackOfficeRec->Licenses) {
            Claimed = BackOfficeRec->Licenses - BackOfficeRec->LicensesClaimed;

            if (Claimed > 1)
               Claimed = 1;

         }

         //
         // Adjust license counts
         //
         BackOfficeRec->LicensesUsed += 1;
         BackOfficeRec->LicensesClaimed += Claimed;
         License->LicensesNeeded = 1 - Claimed;

         //
         // Figure out if we are licensed or not.
         //
         if (License->LicensesNeeded > 0) {
            //
            // Not licensed
            //
            License->Flags &= ~LLS_FLAG_LICENSED;
            pUser->Flags &= ~LLS_FLAG_LICENSED;

            for (i = 0; i < pUser->ServiceTableSize; i++) {
               pUser->Services[i].Flags &= ~LLS_FLAG_LICENSED;
               pUser->Services[i].License = License;
               License->RefCount++;
            }
         } else {
            //
            // Licensed
            //
            License->Flags |= LLS_FLAG_LICENSED;
            pUser->Flags |= LLS_FLAG_LICENSED;

            for (i = 0; i < pUser->ServiceTableSize; i++) {
               pUser->LicensedProducts++;
               pUser->Services[i].Flags |= LLS_FLAG_LICENSED;
               pUser->Services[i].License = License;
               License->RefCount++;
            }
         }

         RtlReleaseResource(&MasterServiceListLock);
      }

   } else {
      BOOL Licensed = TRUE;

      //
      // Loop through all the services and make sure they are all
      // licensed.
      //
      for (i = 0; i < pUser->ServiceTableSize; i++) {
         SvcLicenseUpdate(pUser, &pUser->Services[i]);

         if ( pUser->Services[i].Flags & LLS_FLAG_LICENSED )
            pUser->LicensedProducts++;
         else
            Licensed = FALSE;
      }

      if (Licensed)
         pUser->Flags |= LLS_FLAG_LICENSED;
      else
         pUser->Flags &= ~LLS_FLAG_LICENSED;
   }

} // SvcListLicenseUpdate


/////////////////////////////////////////////////////////////////////////
VOID
SvcLicenseUpdate(
   PUSER_RECORD pUser,
   PSVC_RECORD Svc
)

/*++

Routine Description:

   For a given service record for a user check and update license compliance.
   Is a single service record version of SvcListLicenseUpdate.

Arguments:


Return Value:


--*/

{
   ULONG NumLicenses = 1;
   PUSER_LICENSE_RECORD License = NULL;
   BOOL UseMapping = FALSE;
   PMASTER_SERVICE_RECORD LicenseService = NULL;
   PMASTER_SERVICE_RECORD Service;
   BOOL ReScan = FALSE;
   DWORD Flags = 0;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: SvcLicenseUpdate\n"));
#endif

   if ((pUser == NULL) || (Svc == NULL))
      return;

   Flags = pUser->Flags;

   //
   // If we are a mapping then we may use more then one license
   //
   if (pUser->Mapping != NULL) {
      NumLicenses = pUser->Mapping->Licenses;
      UseMapping = TRUE;
      Flags = pUser->Mapping->Flags;
   }

   //
   // Try to find a license record in the license list of the user or mapping
   // to use.  If we are using BackOffice then look for BackOffice license
   // instead of the service license.
   if (Flags & LLS_FLAG_SUITE_USE) {
      Service = BackOfficeRec;

      if (UseMapping)
         License = LicenseListFind(BackOfficeStr, pUser->Mapping->LicenseList, pUser->Mapping->LicenseListSize);
      else
         License = LicenseListFind(BackOfficeStr, pUser->LicenseList, pUser->LicenseListSize);

   } else {
      //
      // Not BackOffice - so look for normal service license
      //
      Service = Svc->Service;
      ASSERT(Service != NULL);

      //
      // Try to find a license for this family of products
      //
      if (UseMapping)
         License = LicenseListFind(Service->Family->Name, pUser->Mapping->LicenseList, pUser->Mapping->LicenseListSize);
      else
         License = LicenseListFind(Service->Family->Name, pUser->LicenseList, pUser->LicenseListSize);
   }

   //
   // Check if we couldn't find a license.  If we didn't find it then we need
   // to create a new license for this.
   //
   if (License == NULL) {
      ULONG LicenseListSize;
      PUSER_LICENSE_RECORD *LicenseList;

      //
      // The license list to use depends if we are part of a mapping or not.
      //
      if (UseMapping) {
         LicenseListSize = pUser->Mapping->LicenseListSize;
         LicenseList = pUser->Mapping->LicenseList;
      } else {
         LicenseListSize = pUser->LicenseListSize;
         LicenseList = pUser->LicenseList;
      }

      //
      // Check if we need to add a license for BackOffice or just the service
      // itself.
      //
      if (Flags & LLS_FLAG_SUITE_USE)
         License = LicenseListAdd(BackOfficeRec->Family, &LicenseList, &LicenseListSize);
      else
         License = LicenseListAdd(Service->Family, &LicenseList, &LicenseListSize);

      //
      // Now update the couters in the parent record
      //
      if (UseMapping) {
         pUser->Mapping->LicenseListSize = LicenseListSize;
         pUser->Mapping->LicenseList = LicenseList;
      } else {
         pUser->LicenseListSize = LicenseListSize;
         pUser->LicenseList = LicenseList;
      }

      if (License != NULL)
         License->LicensesNeeded = NumLicenses;
   }

   //
   // We have either found an old license or added a new one, either way
   // License points to it.
   //
   if (License != NULL) {
      RtlAcquireResourceExclusive(&MasterServiceListLock, TRUE);

      //
      // if we have a license for this family already and the product
      // version >= current then we are okay, else need to get new license
      //
      if ( (License->Service != NULL) && (License->Service->Version >= Service->Version) ) {
         LicenseService = License->Service;
      } else {
         //
         // we have an old license for this family, but the version
         // isn't adequate, so we need to try and get a new license.
         // Walk the family tree looking for the licenses we
         // need.
         //
         LicenseService = Service;
         while ((LicenseService != NULL) && ( (LicenseService->LicensesUsed + NumLicenses) > LicenseService->Licenses) )
            if (LicenseService->next > 0)
               LicenseService = MasterServiceTable[LicenseService->next - 1];
            else
               LicenseService = NULL;

         //
         // if we couldn't find a license just use the old
         // service.
         if (LicenseService == NULL)
            LicenseService = Service;
         else {
            //
            // Need to clean up old stuff
            //
            if (License->Service != NULL) {
               //
               // If we actually free up any licenses then mark that we need
               // to rescan to allocate these freed licenses.
               //
               if ((NumLicenses - License->LicensesNeeded) > 0)
                  ReScan = TRUE;

               License->Service->LicensesUsed -= NumLicenses;
               License->Service->LicensesClaimed -= (NumLicenses - License->LicensesNeeded);
               License->LicensesNeeded = NumLicenses;
               License->Service = NULL;
            }
         }
      }

      if (LicenseService != NULL) {
         ULONG Claimed = 0;

         //
         // If we switched services then adjust LicensesUsed
         //
         if (License->Service != LicenseService) {
            LicenseService->LicensesUsed += NumLicenses;

            if (License->Service != NULL) {
               License->Service->LicensesUsed -= NumLicenses;
            }
         }

         // Can only claim a # of licenses that we have
         if ( LicenseService->LicensesClaimed < LicenseService->Licenses) {
            Claimed = LicenseService->Licenses - LicenseService->LicensesClaimed;

            if (Claimed > License->LicensesNeeded)
               Claimed = License->LicensesNeeded;

         }

         LicenseService->LicensesClaimed += Claimed;
         License->Service = LicenseService;
         License->LicensesNeeded -= Claimed;

         if (License->LicensesNeeded != 0)
            License->Flags &= ~LLS_FLAG_LICENSED;
         else
            License->Flags |= LLS_FLAG_LICENSED;
      }

      RtlReleaseResource(&MasterServiceListLock);

      if (License->Flags & LLS_FLAG_LICENSED)
         Svc->Flags |= LLS_FLAG_LICENSED;
      else
         Svc->Flags &= ~LLS_FLAG_LICENSED;

   } else
      Svc->Flags &= ~LLS_FLAG_LICENSED;

   if ((Svc->License != License) && (License != NULL))
      License->RefCount++;

   Svc->License = License;
   if (ReScan)
      FamilyLicenseUpdate ( Service->Family );

} // SvcLicenseUpdate



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// Misc licensing Routines.
//
// BackOffice and Mappings have a special affect on LicenseUseage and so
// there are a couple miscelanous routines to handle them.
//
// There are also two special cases that cause us to re-walk our lists to
// fixup the licenses:
//
// 1.  Sometimes when we add licenses we free up some we already had claimed.
//     Ex:  Users of a LicenseGroup used 5 SQL 4.0 licenses but could only
//     claim 2 (there weren't enough).  Later we add 5 SQL 5.0 licenses,
//     since we can use these to get into license compliance we free the
//     2 previously claimed licenses and take the 5 SQL 5.0 licenses.  Now
//     we need to re-walk the user table to try and apply the 2 freed
//     licenses.
//
//     If we switch a user to BackOffice then it will also free up licenses
//     causing us to re-walk the table.
//
// 2.  If we ever apply new licenses to a user in a mapping then we need
//     to re-walk all the other users in the mapping and update their
//     license compliance.
//

/////////////////////////////////////////////////////////////////////////
VOID
MappingLicenseUpdate (
    PMAPPING_RECORD Mapping,
    BOOL ReSynch
    )

/*++

Routine Description:

   Go through all user records for a given mapping and recalc license
   compliance.

Arguments:

   Mapping - the Mapping to recalc licenses for.

   ReSync - If true all previous licenses are destroyed before the licenses
            are checked, else only services that currently don't have a
            license assignment are touched.

Return Value:


--*/

{
   ULONG i, j;
   PUSER_LICENSE_RECORD License = NULL;
   PUSER_RECORD pUser;
   PSVC_RECORD SvcTable = NULL;
   BOOL BackOfficeCheck = FALSE;
   ULONG Claimed;
   BOOL Licensed = TRUE;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MappingLicenseUpdate\n"));
#endif

   //
   // Run through all the users in the mapping - adjust their licenses
   // based on the licenses the mapping has...
   //
   RtlAcquireResourceExclusive(&MappingListLock, TRUE);
   for (i = 0; i < Mapping->LicenseListSize; i++)
      if (!(Mapping->LicenseList[i]->Flags & LLS_FLAG_LICENSED))
         Licensed = FALSE;

   if (Licensed)
      Mapping->Flags |= LLS_FLAG_LICENSED;
   else
      Mapping->Flags &= ~LLS_FLAG_LICENSED;

   //
   // If we want to resynch then blow away all old references
   //
   if (ReSynch)
      for (i = 0; i < Mapping->LicenseListSize; i++)
         Mapping->LicenseList[i]->RefCount = 0;

   //
   // Special handling if the Mapping uses BackOffice
   //
   if (Mapping->Flags & LLS_FLAG_SUITE_USE) {
      License = LicenseListFind(BackOfficeStr, Mapping->LicenseList, Mapping->LicenseListSize);

      //
      // If there isn't one (can happen if all users were deleted from
      // the mapping with BackOffice flag set).  Then update everything.
      //
      if (License == NULL) {
         License = LicenseListAdd(BackOfficeRec->Family, &Mapping->LicenseList, &Mapping->LicenseListSize);

         ASSERT(License != NULL);
         if (License != NULL) {
            License->Service = BackOfficeRec;

            // Can only claim a # of licenses that we have
            if ( BackOfficeRec->LicensesClaimed < BackOfficeRec->Licenses) {
               Claimed = BackOfficeRec->Licenses - BackOfficeRec->LicensesClaimed;

               if (Claimed > Mapping->Licenses)
                  Claimed = Mapping->Licenses;

            }

            BackOfficeRec->LicensesUsed += Mapping->Licenses;
            BackOfficeRec->LicensesClaimed += Claimed;
            License->LicensesNeeded = Mapping->Licenses - Claimed;

            Mapping->Flags |= LLS_FLAG_LICENSED;
            if (License->LicensesNeeded > 0) {
               License->Flags &= ~LLS_FLAG_LICENSED;
               Mapping->Flags &= ~LLS_FLAG_LICENSED;
            }
         }
      }
   }

   //
   // Run through all the members in the Mapping and update their license
   // Compliance.
   //
   for (i = 0; i < Mapping->NumMembers; i++) {
      pUser = UserListFind(Mapping->Members[i]);

      if ( (pUser != NULL) && (pUser->Mapping == Mapping) ) {
         RtlEnterCriticalSection(&pUser->ServiceTableLock);
         SvcTable = pUser->Services;
         pUser->LicensedProducts = 0;

         if (Mapping->Flags & LLS_FLAG_SUITE_USE) {
            if (Mapping->Flags & LLS_FLAG_LICENSED) {
               pUser->Flags |= LLS_FLAG_LICENSED;
               pUser->LicensedProducts = pUser->ServiceTableSize;
            } else
               pUser->Flags &= ~LLS_FLAG_LICENSED;

            //
            // All Services and users are flagged as per BackOffice
            //
            for (j = 0; j < pUser->ServiceTableSize; j++) {
               if (ReSynch)
                  SvcTable[j].License = NULL;

               if (SvcTable[j].License == NULL) {
                  SvcTable[j].License = License;
                  License->RefCount++;
               }

               if (Mapping->Flags & LLS_FLAG_LICENSED) {
                  SvcTable[j].Flags |= LLS_FLAG_LICENSED;
               } else
                  SvcTable[j].Flags &= ~LLS_FLAG_LICENSED;
            }
         } else {
            BOOL Licensed = TRUE;

            //
            // Fixup all the service records
            //
            for (j = 0; j < pUser->ServiceTableSize; j++) {
               if (ReSynch)
                  SvcTable[j].License = NULL;

               if (SvcTable[j].License == NULL) {
                  SvcLicenseUpdate(pUser, &SvcTable[j]);
                  BackOfficeCheck = TRUE;
               }
            }

            //
            // Now run through the services again and see if this user is
            // actually licenses for all the products.
            //
            pUser->LicensedProducts = 0;
            for (j = 0; j < pUser->ServiceTableSize; j++)
               if ( (SvcTable[j].License != NULL) && (SvcTable[j].License->Flags & LLS_FLAG_LICENSED) ) {
                  SvcTable[j].Flags |= LLS_FLAG_LICENSED;
                  pUser->LicensedProducts++;
               } else {
                  SvcTable[j].Flags &= ~LLS_FLAG_LICENSED;
                  Licensed = FALSE;
               }

            if (Licensed)
               pUser->Flags |= LLS_FLAG_LICENSED;
            else
               pUser->Flags &= ~LLS_FLAG_LICENSED;
         }

         RtlLeaveCriticalSection(&pUser->ServiceTableLock);
      }

   }
   RtlReleaseResource(&MappingListLock);

   //
   // Check if we need to re-check for BackOffice
   //
   if (BackOfficeCheck && (pUser != NULL))
      UserBackOfficeCheck( pUser );

} // MappingLicenseUpdate



/////////////////////////////////////////////////////////////////////////
VOID
UserMappingAdd (
   PMAPPING_RECORD Mapping,
   PUSER_RECORD pUser
   )

/*++

Routine Description:

   Takes care of re-adjusting the licenses when we add a user to a mapping.
   We need to free up any old licenses they have and point them to use
   the licenses the mapping has.

Arguments:


Return Value:


--*/

{
   ULONG i, j;
   PUSER_LICENSE_RECORD License = NULL;
   PSVC_RECORD SvcTable = NULL;
   BOOL ReScan = FALSE;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: UserMappingAdd\n"));
#endif

   if ( (pUser == NULL) || (Mapping == NULL) )
      return;

   //
   // Run though and clean up all old licenses
   //
   RtlEnterCriticalSection(&pUser->ServiceTableLock);
   SvcListLicenseFree(pUser);
   UserLicenseListFree(pUser);
   RtlLeaveCriticalSection(&pUser->ServiceTableLock);

   pUser->Mapping = Mapping;
   MappingLicenseUpdate(Mapping, FALSE);

} // UserMappingAdd


/////////////////////////////////////////////////////////////////////////
VOID
FamilyLicenseUpdate (
    PMASTER_SERVICE_ROOT Family
    )

/*++

Routine Description:

   Used when licenses are freed-up or added to a given family of products.
   Goes through the user list looking for out-of-license conditions for the
   given family of products and distributes the new licenses.

Arguments:


Return Value:


--*/

{
   ULONG NumLicenses = 1;
   PUSER_LICENSE_RECORD License = NULL;
   PMASTER_SERVICE_RECORD LicenseService = NULL;
   ULONG i, j;
   PUSER_RECORD pUser;
   BOOL UseMapping = FALSE;
   BOOL ReScan = TRUE;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: FamilyLicenseUpdate\n"));
#endif

   RtlAcquireResourceExclusive(&UserListLock, TRUE);

   while (ReScan) {
      //
      // Walk user list in order of entry - adding any licenses
      //
      ReScan = FALSE;
      i = 0;
      while (i < UserListNumEntries) {
         pUser = LLSGetElementGenericTable(&UserList, i);

         if (pUser != NULL) {
            //
            // only worry about un-licensed users
            //
            if ( !(pUser->Flags & LLS_FLAG_LICENSED ) ) {
               //
               // Find the License?
               //
               RtlEnterCriticalSection(&pUser->ServiceTableLock);
               if (pUser->Mapping != NULL) {
                  License = LicenseListFind(Family->Name, pUser->Mapping->LicenseList, pUser->Mapping->LicenseListSize);
                  NumLicenses = pUser->Mapping->Licenses;
               } else {
                  License = LicenseListFind(Family->Name, pUser->LicenseList, pUser->LicenseListSize);
                  NumLicenses = 1;
               }

               //
               // Make sure we need any extra licenses for this product
               //
               if ( (License != NULL) && (License->LicensesNeeded > 0) ) {
                  //
                  // We have found a user using this family of products in need
                  // of more licenses...
                  //
                  LicenseService = License->Service;

                  if (pUser->Mapping != NULL)
                     pUser->Mapping->Flags |= LLS_FLAG_UPDATE;

                  //
                  // Check if we can satisfy licenses using currently
                  // assigned service
                  //
                  if ((LicenseService->Licenses - LicenseService->LicensesClaimed) >= License->LicensesNeeded) {
                     LicenseService->LicensesClaimed += License->LicensesNeeded;
                     License->LicensesNeeded = 0;
                  } else {
                     //
                     // See if any other service will satisfy it...
                     //
                     while ((LicenseService != NULL) && ((LicenseService->Licenses - LicenseService->LicensesClaimed) < NumLicenses ) )
                        if (LicenseService->next > 0)
                           LicenseService = MasterServiceTable[LicenseService->next - 1];
                        else
                           LicenseService = NULL;

                     //
                     // check if we found a service to satisfy licensing needs
                     //
                     if (LicenseService != NULL) {
                        //
                        // Free up any stuff - since we are freeing licenses
                        // we need to re-scan.
                        //
                        ReScan = TRUE;

                        License->Service->LicensesUsed -= NumLicenses;
                        License->Service->LicensesClaimed -= (NumLicenses - License->LicensesNeeded);

                        //
                        // Now do new stuff
                        //
                        License->Service = LicenseService;
                        License->Service->LicensesUsed += NumLicenses;
                        License->Service->LicensesClaimed += NumLicenses;
                        License->LicensesNeeded = 0;
                     } else {
                        //
                        // Eat any unclaimed licenses
                        //
                        LicenseService = License->Service;
                        if (LicenseService->Licenses > LicenseService->LicensesClaimed) {
                           License->LicensesNeeded -= (LicenseService->Licenses - LicenseService->LicensesClaimed);
                           LicenseService->LicensesClaimed = LicenseService->Licenses;
                        }
                     }
                  }

                  //
                  // Check if we got into license
                  //
                  if (License->LicensesNeeded == 0) {
                     BOOL Licensed = TRUE;

                     License->Flags |= LLS_FLAG_LICENSED;

                     //
                     // this license is fulfilled so scan product list and
                     // adjust flags on any product using this license.
                     //
                     for (j = 0; j < pUser->ServiceTableSize; j++) {
                        if (pUser->Services[j].License == License) {
                           pUser->Services[j].Flags |= LLS_FLAG_LICENSED;
                        } else
                           if (!(pUser->Services[j].Flags & LLS_FLAG_LICENSED))
                              Licensed = FALSE;
                     }

                     //
                     // Recalc how many products are licensed
                     //
                     pUser->LicensedProducts = 0;
                     for (j = 0; j < pUser->ServiceTableSize; j++) {
                        if (pUser->Services[j].Flags & LLS_FLAG_LICENSED)
                           pUser->LicensedProducts++;
                     }

                     if (Licensed)
                        pUser->Flags |= LLS_FLAG_LICENSED;
                  }
               }

               RtlLeaveCriticalSection(&pUser->ServiceTableLock);
            }
         }

         i++;
      }
   }

   //
   // If this license is for BackOffice, we have applied any licenses to
   // anything set to use BackOffice.  If there are still licenses left
   // then see if any users should be auto-switched to BackOffice.
   //
   // if (Family == BackOfficeRec->Family) {
   i = 0;
   while ( (BackOfficeRec->LicensesClaimed < BackOfficeRec->Licenses) && (i < UserListNumEntries) ) {
      pUser = LLSGetElementGenericTable(&UserList, i);

      if (pUser != NULL)
         UserBackOfficeCheck(pUser);

      i++;
   }
   // }

   //
   // Run through mapping and re-adjust any that need it.
   //
   RtlAcquireResourceExclusive(&MappingListLock, TRUE);
   for (i = 0; i < MappingListSize; i++) {
      if (MappingList[i]->Flags & LLS_FLAG_UPDATE) {
         MappingList[i]->Flags &= ~LLS_FLAG_UPDATE;
         MappingLicenseUpdate( MappingList[i], FALSE );
      }
   }
   RtlReleaseResource(&MappingListLock);

   RtlReleaseResource(&UserListLock);

} // FamilyLicenseUpdate


/////////////////////////////////////////////////////////////////////////
VOID
UserListLicenseDelete(
   PMASTER_SERVICE_RECORD Service,
   LONG Quantity
)

/*++

Routine Description:

   This is used when licenses are deleted.  It must walk the user-list in
   the reverse order they were entered (since licenses are applied in a
   FIFO manner they are removed in a LIFO manner) and delete the required
   number of licenses from those consumed.

Arguments:


Return Value:


--*/

{
   LONG Licenses;
   ULONG i, j;
   PUSER_RECORD pUser;
   PSVC_RECORD pService;
   ULONG NumLicenses = 1;
   PUSER_LICENSE_RECORD License = NULL;
   BOOL UseMapping = FALSE;
   LONG Claimed;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: UserListLicenseDelete\n"));
#endif

   RtlAcquireResourceExclusive(&UserListLock, TRUE);

   Licenses = 0 - Quantity;

   //
   // Walk user list in opposite order of entry - removing licenses
   //
   i = UserListNumEntries - 1;
   while (((LONG)i >= 0) && (Licenses > 0)) {
      pUser = LLSGetElementGenericTable(&UserList, i);

      if (pUser != NULL) {
         NumLicenses = 1;
         UseMapping = FALSE;

         //
         // If we are a mapping then we may use more then one license
         //
         if (pUser->Mapping != NULL) {
            NumLicenses = pUser->Mapping->Licenses;
            UseMapping = TRUE;
         }

         //
         // Try to find a license for this family of products
         //
         if (UseMapping)
            License = LicenseListFind(Service->Family->Name, pUser->Mapping->LicenseList, pUser->Mapping->LicenseListSize);
         else
            License = LicenseListFind(Service->Family->Name, pUser->LicenseList, pUser->LicenseListSize);

         if (License != NULL) {
            //
            // Check if same as product we adjusted
            //
            if (License->Service == Service) {
               //
               // Can only release how many we took
               //
               Claimed = NumLicenses - License->LicensesNeeded;
               if (Claimed > 0) {
                  if (Claimed > Licenses) {
                     License->LicensesNeeded += Licenses;
                     License->Service->LicensesClaimed -= Licenses;
                     Licenses = 0;
                  } else {
                     License->LicensesNeeded = NumLicenses;
                     License->Service->LicensesClaimed -= Claimed;
                     Licenses -= Claimed;
                  }

                  License->Flags &= ~LLS_FLAG_LICENSED;

                  //
                  // Flag any mapping that we need to recalc uses in the
                  // mapping
                  //
                  if (UseMapping)
                     pUser->Mapping->Flags |= LLS_FLAG_UPDATE;

                  //
                  // Scan product list and adjust flags on any
                  // product using this license.
                  //
                  RtlEnterCriticalSection(&pUser->ServiceTableLock);
                  for (j = 0; j < pUser->ServiceTableSize; j++)
                     if (pUser->Services[j].License == License)
                        pUser->Services[j].Flags &= ~LLS_FLAG_LICENSED;

                  //
                  // Recalc how many products are licensed
                  //
                  pUser->LicensedProducts = 0;
                  for (j = 0; j < pUser->ServiceTableSize; j++) {
                     if (pUser->Services[j].Flags & LLS_FLAG_LICENSED)
                        pUser->LicensedProducts++;
                  }

                  RtlLeaveCriticalSection(&pUser->ServiceTableLock);
                  pUser->Flags &= ~LLS_FLAG_LICENSED;
               }
            }
         }
      }

      i--;
   }

   //
   // Run through mapping and re-adjust any that need it.
   //
   RtlAcquireResourceExclusive(&MappingListLock, TRUE);
   for (i = 0; i < MappingListSize; i++) {
      if (MappingList[i]->Flags & LLS_FLAG_UPDATE) {
         MappingList[i]->Flags &= ~LLS_FLAG_UPDATE;
         MappingLicenseUpdate( MappingList[i], FALSE );
      }
   }
   RtlReleaseResource(&MappingListLock);

   RtlReleaseResource(&UserListLock);

} // UserListLicenseDelete


/////////////////////////////////////////////////////////////////////////
VOID
UserBackOfficeCheck (
   PUSER_RECORD pUser
   )

/*++

Routine Description:

   Checks if the user should switch to BackOffice, and if so - does so.  If
   we switch to BackOffice then we need to free up any old licenes the
   user may be using and claim a BackOffice License.

   Note:  We will only switch to BackOffice if there are enough BackOffice
   licenses available to satisfy our needs.

Arguments:

Return Value:


--*/

{
   DWORD Flags;
   ULONG i;
   ULONG LicenseListSize;
   ULONG NumLicenses = 1;
   PSVC_RECORD SvcTable = NULL;
   PUSER_LICENSE_RECORD *LicenseList = NULL;
   PUSER_LICENSE_RECORD License = NULL;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: UserBackOfficeCheck\n"));
#endif

   RtlEnterCriticalSection(&pUser->ServiceTableLock);
   if (pUser->Mapping != NULL) {
      Flags = pUser->Mapping->Flags;
      LicenseListSize = pUser->Mapping->LicenseListSize;
      LicenseList = pUser->Mapping->LicenseList;
      NumLicenses = pUser->Mapping->Licenses;
   } else {
      Flags = pUser->Flags;
      LicenseListSize = pUser->LicenseListSize;
      LicenseList = pUser->LicenseList;
   }

   //
   // If we are already using BackOffice - get out
   //
   if (Flags & LLS_FLAG_SUITE_USE) {
      RtlLeaveCriticalSection(&pUser->ServiceTableLock);
      return;
   }

   if ( Flags & LLS_FLAG_SUITE_AUTO )
      //
      // if we aren't licensed, or the # services == auto switch threshold
      // then switch to using BackOffice
      //
      if ((!(Flags & LLS_FLAG_LICENSED)) || ((LicenseListSize + 1) >= BACKOFFICE_SWITCH) ) {
         //
         // Make sure we have licenses for this
         //
         RtlAcquireResourceExclusive(&MasterServiceListLock, TRUE);
         if ( BackOfficeRec->Licenses >= (NumLicenses + BackOfficeRec->LicensesClaimed) ) {
            //
            // Free up the old licenses - temporarily claim the BackOffice
            // licenses so somebody else won't.
            //
            BackOfficeRec->LicensesClaimed += NumLicenses;
            UserLicenseListFree(pUser);
            BackOfficeRec->LicensesClaimed -= NumLicenses;

            //
            // UserLicenseListFree might have assigned us a license in
            // the rescan if we are part of a mapping so check this.
            //
            if (pUser->Mapping != NULL)
               Flags = pUser->Mapping->Flags;
            else
               Flags = pUser->Flags;

            //
            // If we are already using BackOffice - get out
            //
            if (Flags & LLS_FLAG_SUITE_USE) {
                RtlLeaveCriticalSection(&pUser->ServiceTableLock);
                RtlReleaseResource(&MasterServiceListLock);
                return;
            }

            //
            // And if part of a mapping free those up
            //
            if (pUser->Mapping != NULL)
               MappingLicenseListFree(pUser->Mapping);

            //
            // Now add the BackOffice License
            //
            if (pUser->Mapping != NULL) {
               pUser->Mapping->LicenseList = NULL;
               pUser->Mapping->LicenseListSize = 0;

               License = LicenseListAdd(BackOfficeRec->Family, &pUser->Mapping->LicenseList, &pUser->Mapping->LicenseListSize);

               LicenseList = pUser->Mapping->LicenseList;
               LicenseListSize = pUser->Mapping->LicenseListSize;
            } else {
               pUser->LicenseList = NULL;
               pUser->LicenseListSize = 0;

               License = LicenseListAdd(BackOfficeRec->Family, &pUser->LicenseList, &pUser->LicenseListSize);

               LicenseList = pUser->LicenseList;
               LicenseListSize = pUser->LicenseListSize;
            }

            ASSERT(License != NULL);
            if (License != NULL)
               License->Service = BackOfficeRec;

            //
            // if mapping adjust mapping records then go through all users and
            // adjust them
            //
            if (pUser->Mapping != NULL) {
               pUser->Mapping->Flags |= LLS_FLAG_SUITE_USE;
               pUser->Mapping->Flags |= LLS_FLAG_LICENSED;

               BackOfficeRec->LicensesUsed += NumLicenses;
               BackOfficeRec->LicensesClaimed += NumLicenses;

               RtlLeaveCriticalSection(&pUser->ServiceTableLock);
               RtlReleaseResource(&MasterServiceListLock);

               MappingLicenseUpdate(pUser->Mapping, TRUE);
               return;
            } else {
               pUser->Flags |= LLS_FLAG_SUITE_USE;
               pUser->Flags |= LLS_FLAG_LICENSED;

               pUser->LicensedProducts = pUser->ServiceTableSize;
               BackOfficeRec->LicensesUsed += NumLicenses;
               BackOfficeRec->LicensesClaimed += NumLicenses;

               //
               // Run through products & licenses adjusting licenses
               //
               SvcTable = pUser->Services;
               for (i = 0; i < pUser->ServiceTableSize; i++) {
                  SvcTable[i].Flags |= LLS_FLAG_LICENSED;
                  SvcTable[i].License = License;
                  SvcTable[i].License->RefCount++;
               }

            }

         }

         RtlReleaseResource(&MasterServiceListLock);

      }

   RtlLeaveCriticalSection(&pUser->ServiceTableLock);

} // UserBackOfficeCheck


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// Utility routines for managing the user and SID lists - used mostly
// by the splay table routines.

/////////////////////////////////////////////////////////////////////////
LLS_GENERIC_COMPARE_RESULTS
SidListCompare (
    struct _LLS_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:


Arguments:

   Table -

   FirstStruct -

   SecondStruct -

Return Value:


--*/

{
   PUSER_RECORD UseRec1, UseRec2;
   int ret;

   if ((FirstStruct == NULL) || (SecondStruct == NULL))
      return LLSGenericEqual;

   UseRec1 = (PUSER_RECORD) FirstStruct;
   UseRec2 = (PUSER_RECORD) SecondStruct;

   if (UseRec1->IDSize == UseRec2->IDSize) {
      ret = memcmp((PVOID) UseRec1->UserID, (PVOID) UseRec2->UserID, UseRec1->IDSize);
      if (ret < 0)
         return LLSGenericLessThan;
      else if (ret > 0)
         return LLSGenericGreaterThan;
      else
         return LLSGenericEqual;
   } else
      //
      // Not same size, so just compare length
      //
      if (UseRec1->IDSize > UseRec2->IDSize)
         return LLSGenericGreaterThan;
      else
         return LLSGenericLessThan;

} // SidListCompare


/////////////////////////////////////////////////////////////////////////
LLS_GENERIC_COMPARE_RESULTS
UserListCompare (
    struct _LLS_GENERIC_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )

/*++

Routine Description:


Arguments:

   Table -

   FirstStruct -

   SecondStruct -

Return Value:


--*/

{
   PUSER_RECORD UseRec1, UseRec2;
   int ret;

   if ((FirstStruct == NULL) || (SecondStruct == NULL))
      return LLSGenericEqual;

   UseRec1 = (PUSER_RECORD) FirstStruct;
   UseRec2 = (PUSER_RECORD) SecondStruct;

   ret = lstrcmpi((LPTSTR) UseRec1->UserID, (LPTSTR) UseRec2->UserID);

   if (ret < 0)
      return LLSGenericLessThan;
   else if (ret > 0)
      return LLSGenericGreaterThan;
   else
      return LLSGenericEqual;

} // UserListCompare


/////////////////////////////////////////////////////////////////////////
PVOID
UserListAlloc (
    struct _LLS_GENERIC_TABLE *Table,
    CLONG ByteSize
    )

/*++

Routine Description:


Arguments:

   Table -

   ByteSize -

Return Value:


--*/

{
   return (PVOID) LocalAlloc(LPTR, ByteSize);

} // UserListAlloc


/////////////////////////////////////////////////////////////////////////
VOID
UserListFree (
    struct _LLS_GENERIC_TABLE *Table,
    PVOID Buffer
    )

/*++

Routine Description:


Arguments:

   Table -

   Buffer -

Return Value:


--*/

{
   PUSER_RECORD UserRec;

   if (Buffer == NULL)
      return;

   UserRec = (PUSER_RECORD) Buffer;
   LocalFree(UserRec->UserID);
   LocalFree(UserRec);

} // UserListFree


/////////////////////////////////////////////////////////////////////////
PUSER_RECORD
UserListFind(
   LPTSTR UserName
)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   USER_RECORD UserRec;
   PUSER_RECORD pUserRec;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: UserListFind\n"));
#endif

   UserRec.UserID = (PVOID) UserName;

   RtlEnterCriticalSection(&GenTableLock);
   pUserRec = (PUSER_RECORD) LLSLookupElementGenericTable(&UserList, &UserRec);
   RtlLeaveCriticalSection(&GenTableLock);

   return pUserRec;

} // UserListFind



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
VOID
UserListAdd(
   PMASTER_SERVICE_RECORD Service,
   ULONG DataType,
   ULONG DataLength,
   PVOID Data,
   ULONG AccessCount,
   DWORD LastAccess,
   DWORD FlagsParam
)

/*++

Routine Description:

   Routine called by the Add cache routine to update the user and/or SID
   lists with the new service information.

Arguments:


Return Value:


--*/

{
   USER_RECORD UserRec;
   PUSER_RECORD pUserRec;
   BOOLEAN Added;
   PSVC_RECORD pService;
   PSVC_RECORD SvcTable = NULL;
   PLLS_GENERIC_TABLE pTable = NULL;
   PRTL_RESOURCE pLock = NULL;
   BOOL SIDSwitch = FALSE;
   BOOL UserLock = FALSE;
   PMAPPING_RECORD pMap = NULL;
   ULONG ProductLicenses, ProductLicensesUsed, i;
   BOOL SwitchToBackOffice = FALSE;
   NTSTATUS status;
   PSVC_RECORD pSvcTableTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: UserListAdd\n"));
#endif

   // only 2 bits are used
   ASSERT( FlagsParam == ( FlagsParam & ( LLS_FLAG_SUITE_USE | LLS_FLAG_SUITE_AUTO ) ) );

   //
   // Set up lock and table pointers based on if data is SID or username...
   //
   UserRec.UserID = Data;
   if (DataType == DATA_TYPE_USERNAME) {
      pTable = &UserList;
      pLock = &UserListLock;
   } else if (DataType == DATA_TYPE_SID) {
      pTable = &SidList;
      pLock = &SidListLock;
   }

   if (pTable == NULL)
      return;

   //
   // The generic table package copies the record so the record is
   // temporary, but since we store the string as a pointer the pointer is
   // copied but the actual memory that is pointed to is kept around
   // permenantly.
   //
   // We have already allocated memory for the Data
   //
   UserRec.UserID = Data;
   UserRec.IDSize = DataLength;

   UserRec.Flags = FlagsParam;
   UserRec.LicensedProducts = 0;
   UserRec.LastReplicated = 0;
   UserRec.ServiceTableSize = 0;
   UserRec.Services = NULL;
   UserRec.Mapping = NULL;
   UserRec.LicenseListSize = 0;
   UserRec.LicenseList = NULL;

   //
   // Assume that the user is licensed - we will blast it if they aren't
   // down below.
   //
   UserRec.Flags |= LLS_FLAG_LICENSED;

   //
   // Need to update list so get exclusive access. First get Add/Enum lock
   // so we don't block reads if doing an enum.
   //
   RtlAcquireResourceExclusive(pLock, TRUE);

   pUserRec = (PUSER_RECORD) LLSInsertElementGenericTable(pTable, (PVOID) &UserRec, sizeof(USER_RECORD), &Added);

   if (pUserRec == NULL) {
      ASSERT(FALSE);
      LocalFree(UserRec.UserID);
      RtlReleaseResource(pLock);
      return;
   }

   pUserRec->Flags &= ~LLS_FLAG_DELETED;

   // if auto suite is ever turned off, it's gone for good
   if ( ! ( FlagsParam & LLS_FLAG_SUITE_AUTO ) )
   {
      // set suite use to be that specified in the function parameters
      pUserRec->Flags &= ~LLS_FLAG_SUITE_AUTO;
      pUserRec->Flags |= ( FlagsParam & LLS_FLAG_SUITE_USE );
   }

   //
   // If for some reason the record is already there then we need to
   // clean-up the name we allocated.
   //
   if (Added == FALSE) {
      LocalFree(UserRec.UserID);

      //
      // If this is a SID then check the SID record to find the corresponding
      // USER_RECORD (it better be there) and update that instead.. Note:  We
      // kludge this by storing the pointer to the user table in the
      // LastReplicated field.
      //
      if ((DataType == DATA_TYPE_SID) && (pUserRec->LastReplicated != 0)) {
         //
         // Switch data as approp.
         //
         SIDSwitch = TRUE;
      }
   } else {
      //
      // Do this here so when we release to READ access another thread
      // won't AV when trying to get access to it.
      //
      status = RtlInitializeCriticalSection(&pUserRec->ServiceTableLock);
      if (!NT_SUCCESS(status))
      {
          // We're out of memory.  Fail to add the user
          return;
      }

      if (DataType == DATA_TYPE_USERNAME) {
         pMap = MappingListUserFind(UserRec.UserID);
         pUserRec->Mapping = pMap;
         UserListNumEntries++;
      } else
         SidListNumEntries++;

   }

   //
   // If this is a SID, and we haven't gotten an appropriate user-rec
   // then try to de-reference this and get the appropriate user-rec.
   //
   if ((DataType == DATA_TYPE_SID) && (pUserRec->LastReplicated == 0)) {
      TCHAR UserName[MAX_USERNAME_LENGTH + 1];
      TCHAR DomainName[MAX_DOMAINNAME_LENGTH + 1];
      TCHAR FullName[MAX_USERNAME_LENGTH + MAX_DOMAINNAME_LENGTH + 2];
      SID_NAME_USE snu;
      PUSER_RECORD pUserRec2;
      DWORD unSize, dnSize;

      unSize = sizeof(UserName);
      dnSize = sizeof(DomainName);
      if (LookupAccountSid(NULL, (PSID) Data, UserName, &unSize, DomainName, &dnSize, &snu)) {
         //
         // Okay, de-referenced the SID, so go get the user-rec, but pre-pend
         // domain first...
         //
         lstrcpy(FullName, DomainName);
         lstrcat(FullName, TEXT("\\"));
         lstrcat(FullName, UserName);
         UserRec.UserID = FullName;
         UserRec.IDSize = (lstrlen(FullName) + 1) * sizeof(TCHAR);

         //
         // Get locks, we will try shared first.
         //
         RtlAcquireResourceExclusive(&UserListLock, TRUE);
         UserLock = TRUE;
         SIDSwitch = TRUE;

         RtlEnterCriticalSection(&GenTableLock);
         pUserRec2 = (PUSER_RECORD) LLSLookupElementGenericTable(&UserList, &UserRec);
         RtlLeaveCriticalSection(&GenTableLock);
         if (pUserRec2 != NULL) {
            //
            // Tarnation!  we found it - so use it.
            //
            pUserRec->LastReplicated = (ULONG_PTR) pUserRec2;
         } else {
            //
            // Dang it all...  It ain't in the dern table, so we're gonna
            // put it there.  First need to alloc perm storage for UserID
            //
            UserRec.UserID = LocalAlloc(LPTR, UserRec.IDSize);
            if (UserRec.UserID != NULL) {
               lstrcpy((LPTSTR) UserRec.UserID, FullName);

               //
               // Need to update list so get exclusive access. First get
               // Add/Enum lock so we don't block reads if doing an enum.
               //
               pUserRec2 = (PUSER_RECORD) LLSInsertElementGenericTable(&UserList, (PVOID) &UserRec, sizeof(USER_RECORD), &Added);
            }

            //
            // If we couldn't insert it then seomthing is wrong, clean up
            // and exit.
            //
            if (pUserRec2 == NULL) {
               ASSERT(FALSE);

               if (UserRec.UserID != NULL)
                  LocalFree(UserRec.UserID);

               RtlReleaseResource(pLock);

               RtlReleaseResource(&UserListLock);
               return;
            }

            //
            // Update SID USER_REC pointer (LastReplicated) and then finally
            // free up the SID lock
            //
            pUserRec->LastReplicated = (ULONG_PTR) pUserRec2;

            if (Added == TRUE) {
               //
               // Do this here so when we release to READ access another
               // thread won't AV when trying to get access to it.
               //
               status = RtlInitializeCriticalSection(&pUserRec2->ServiceTableLock);
               if (!NT_SUCCESS(status))
               {
                   // We're out of memory.  Fail to add the user
                   return;
               }

               pMap = MappingListUserFind(UserRec.UserID);
               pUserRec2->Mapping = pMap;
               UserListNumEntries++;
            }

         }

         //
         // We have found or added a USER_REC for the SID which pUserRec2
         // points to.  Now we need to switch locks and tables.
         //
      }
   }

   //
   // If we need to munge from SID to User tables, then do so...
   //
   if (SIDSwitch) {
      //
      // Switch data as approp.
      //
      pUserRec = (PUSER_RECORD) pUserRec->LastReplicated;
      DataType = DATA_TYPE_USERNAME;

      //
      // Release locks on SID Table
      //
      RtlReleaseResource(pLock);

      //
      // Now switch locks to User Table
      //
      pTable = &UserList;
      pLock = &UserListLock;

      if (!UserLock)
         RtlAcquireResourceExclusive(pLock, TRUE);
   }

   //
   // At this point we have either found the old record, or added a new
   // one.  In either case pUserRec points to the correct record.
   //
   if (pUserRec != NULL) {
      //
      // Check Service table to make sure our service is already there
      //
      RtlEnterCriticalSection(&pUserRec->ServiceTableLock);
      pService = SvcListFind( Service->Name, pUserRec->Services, pUserRec->ServiceTableSize );

      if (pService != NULL) {
         //
         // Found entry in service table so just increment count
         //
         if (pService->AccessCount + AccessCount < MAX_ACCESS_COUNT)
            pService->AccessCount += AccessCount;
         else
            pService->AccessCount = MAX_ACCESS_COUNT;

         pService->LastAccess = LastAccess;
      } else {
         //
         // Need to add more entries to service table (or create it...)
         //
         if (pUserRec->Services == NULL)
            pSvcTableTmp = (PSVC_RECORD) LocalAlloc( LPTR, sizeof(SVC_RECORD));
         else
            pSvcTableTmp = (PSVC_RECORD) LocalReAlloc( pUserRec->Services, sizeof(SVC_RECORD) * (pUserRec->ServiceTableSize + 1), LHND);

         if (pSvcTableTmp != NULL) {
             SvcTable = pSvcTableTmp;
         } else {
             // why is this a void function?
             ASSERT(FALSE);
             return;
         }

         pUserRec->Services = SvcTable;

         if (SvcTable != NULL) {
            DWORD Flags;

            if (pUserRec->Mapping != NULL)
               Flags = pUserRec->Mapping->Flags;
            else
               Flags = pUserRec->Flags;

            SvcTable[pUserRec->ServiceTableSize].Service = Service;
            SvcTable[pUserRec->ServiceTableSize].LastAccess = LastAccess;

            //
            // Update AccessCount field, but make sure we don't roll over
            //
            if (AccessCount < MAX_ACCESS_COUNT)
               SvcTable[pUserRec->ServiceTableSize].AccessCount = AccessCount;
            else
               SvcTable[pUserRec->ServiceTableSize].AccessCount = MAX_ACCESS_COUNT;

            SvcTable[pUserRec->ServiceTableSize].Flags = LLS_FLAG_LICENSED;

            //
            // Now update the actual license info
            //
            SvcLicenseUpdate(pUserRec, &SvcTable[pUserRec->ServiceTableSize]);
            pUserRec->ServiceTableSize += 1;

            if (SvcTable[pUserRec->ServiceTableSize - 1].Flags & LLS_FLAG_LICENSED)
               pUserRec->LicensedProducts++;

            //
            // If the added product isn't licensed then update user flag
            //
            if (IsMaster && !(SvcTable[pUserRec->ServiceTableSize - 1].Flags & LLS_FLAG_LICENSED) )
               pUserRec->Flags &= ~LLS_FLAG_LICENSED;

            // Now that it is all setup - sort the table (so search will work)
            qsort((void *) pUserRec->Services, (size_t) pUserRec->ServiceTableSize, sizeof(SVC_RECORD), SvcListCompare);

            UserBackOfficeCheck ( pUserRec );
         }

      }
      RtlLeaveCriticalSection(&pUserRec->ServiceTableLock);

   }

   RtlReleaseResource(pLock);
} // UserListAdd


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//
// The AddCache routines are a queue of User Identifiers (Username or
// SID's) and the service being accessed.  Records are dequeued by a
// background thread and handed off to the UserListAdd function.

/////////////////////////////////////////////////////////////////////////
VOID
AddCacheManager (
    IN PVOID ThreadParameter
    )

/*++

Routine Description:


Arguments:

    ThreadParameter - Not used.


Return Value:

    This thread never exits.

--*/

{
   NTSTATUS Status;
   PADD_CACHE pAdd;

   //
   // Loop forever waiting to be given the opportunity to serve the
   // greater good.
   //
   for ( ; ; ) {
      //
      // Wait to be notified that there is work to be done
      //
      Status = NtWaitForSingleObject( LLSAddCacheEvent, TRUE, NULL );

      //
      // Take an item from the add cache.
      //
      RtlEnterCriticalSection(&AddCacheLock);
      while (AddCache != NULL) {
         pAdd = AddCache;
         AddCache = AddCache->prev;
         AddCacheSize--;

         RtlLeaveCriticalSection(&AddCacheLock);

         if (pAdd != NULL) {
            UserListAdd(pAdd->Service, pAdd->DataType, pAdd->DataLength, pAdd->Data, pAdd->AccessCount, pAdd->LastAccess, pAdd->Flags);
            LocalFree(pAdd);
         }

         Sleep(0);
         //
         // Need to re-enter critical section to check in the while loop
         RtlEnterCriticalSection(&AddCacheLock);
      }

      RtlLeaveCriticalSection(&AddCacheLock);
   }

} // AddCacheManager


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
NTSTATUS
UserListInit()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;
   HANDLE Thread;
   DOMAIN_CONTROLLER_INFO * pDCInfo = NULL;

   //
   // Initialize the generic table.
   //
   LLSInitializeGenericTable ( &UserList,
        UserListCompare,
        UserListAlloc,
        UserListFree,
        (PVOID) TEXT("LLS Table") );

   Status = RtlInitializeCriticalSection(&GenTableLock);

   if (!NT_SUCCESS(Status))
       return Status;

   try
   {
       RtlInitializeResource(&UserListLock);
   } except(EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
   }

   if (!NT_SUCCESS(Status))
       return Status;

   //
   // Initialize the SID table.
   //
   LLSInitializeGenericTable ( &SidList,
                               SidListCompare,
                               UserListAlloc,
                               UserListFree,
                               (PVOID) TEXT("LLS SID Table") );

   try
   {
       RtlInitializeResource(&SidListLock);
   } except(EXCEPTION_EXECUTE_HANDLER ) {
       Status = GetExceptionCode();
   }

   if (!NT_SUCCESS(Status))
       return Status;

   //
   // Now our add cache
   //
   Status = RtlInitializeCriticalSection(&AddCacheLock);

   if (!NT_SUCCESS(Status))
       return Status;

   //
   // Get MyDomain
   //
   GetDCInfo(MAX_COMPUTERNAME_LENGTH + 2,
             MyDomain,
             &pDCInfo);
   lstrcat(MyDomain, TEXT("\\"));
   MyDomainSize = (lstrlen(MyDomain) + 1) * sizeof(TCHAR);

   if (pDCInfo != NULL) {
       NetApiBufferFree(pDCInfo);
   }

   //
   // Create the Add Cache Management event
   //
   Status = NtCreateEvent(
                &LLSAddCacheEvent,
                EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE,
                NULL,
                SynchronizationEvent,
                FALSE
                );

   if (!NT_SUCCESS(Status))
       return Status;

   //
   // Create the Add Cache management thread
   //
   Thread = CreateThread(
                NULL,
                0L,
                (LPTHREAD_START_ROUTINE) AddCacheManager,
                0L,
                0L,
                NULL
                );

   if (NULL != Thread)
       CloseHandle(Thread);

   LastUsedTime = DateSystemGet();

   return STATUS_SUCCESS;

} // UserListInit


/////////////////////////////////////////////////////////////////////////
VOID
UserListUpdate(
   ULONG DataType,
   PVOID Data,
   PSERVICE_RECORD Service
)

/*++

Routine Description:

   Actual start of the perseat license code.  Given a SID or UserName find
   the record in the appropriate table and check the given service.  If the
   service is already there then the info is updated, if it isn't there then
   the record is put onto the add cache queue for background processing.

Arguments:


Return Value:


--*/

{
   USER_RECORD UserRec;
   PUSER_RECORD pUserRec;
   BOOLEAN Added;
   ULONG DataLength;
   PSVC_RECORD pService;
   PSVC_RECORD SvcTable = NULL;
   PLLS_GENERIC_TABLE pTable = NULL;
   PRTL_RESOURCE pLock = NULL;
   PADD_CACHE pAdd = NULL;
   NTSTATUS NtStatus;
   BOOL ToAddCache = FALSE;
   BOOL FullName = TRUE;
   LPTSTR pName;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: UserListUpdate\n"));
#endif

   //
   // Setup table and lock pointers based if Data is UserName or SID
   //
   UserRec.UserID = Data;
   if (DataType == DATA_TYPE_USERNAME) {
      pTable = &UserList;
      pLock = &UserListLock;
      DataLength = (lstrlen((LPWSTR) Data) + 1) * sizeof(TCHAR);
   } else if (DataType == DATA_TYPE_SID) {
      pTable = &SidList;
      pLock = &SidListLock;
      DataLength = RtlLengthSid((PSID) Data);
   }

   if (pTable == NULL)
      return;

   //
   // Searching so don't need exclusive access
   //
   RtlAcquireResourceExclusive(pLock, TRUE);

   RtlEnterCriticalSection(&GenTableLock);
   pUserRec = (PUSER_RECORD) LLSLookupElementGenericTable(pTable, &UserRec);
   RtlLeaveCriticalSection(&GenTableLock);
   if (pUserRec == NULL)
      ToAddCache = TRUE;
   else {
      //
      // pUserRec now points to the record we must update.
      //
      // Check Service table to make sure our service is already there
      //
      pUserRec->Flags &= ~LLS_FLAG_DELETED;
      RtlEnterCriticalSection(&pUserRec->ServiceTableLock);
      pService = SvcListFind( Service->DisplayName, pUserRec->Services, pUserRec->ServiceTableSize );

      if (pService == NULL)
         ToAddCache = TRUE;
      else {
         //
         // Found entry in service table so just increment count
         //
         pService->AccessCount += 1;
         pService->LastAccess = LastUsedTime;
      }
      RtlLeaveCriticalSection(&pUserRec->ServiceTableLock);

   }

   RtlReleaseResource(pLock);

   if (ToAddCache) {
      //
      // Couldn't find the specific user/service, so put it on the Add Cache.
      //  First alloc memory for the name and Add Cache record.
      //
      pAdd = LocalAlloc(LPTR, sizeof(ADD_CACHE));
      if (pAdd == NULL) {
         ASSERT(FALSE);
         return;
      }

      if (DataType == DATA_TYPE_USERNAME) {
         FullName = FALSE;
         pName = (LPTSTR) Data;

         //
         // Make sure first char isn't backslash, if not then look for
         // backslash as domain-name.  If first char is backslash then get
         // rid of it.
         //
         if (*pName != TEXT('\\'))
           while ((*pName != TEXT('\0')) && !FullName) {
              if (*pName == TEXT('\\'))
                 FullName = TRUE;

              pName++;
           }
         else
            ((LPTSTR) Data)++;

      }

      //
      // If we don't have a fully qualified Domain\Username, then tack the
      // Domain name onto the name.
      //
      if (!FullName) {
         UserRec.UserID = LocalAlloc( LPTR, DataLength + MyDomainSize);

         if (UserRec.UserID == NULL) {
            ASSERT(FALSE);
            LocalFree(pAdd);
            return;
         }

         pAdd->Data = UserRec.UserID;

         lstrcpy((LPTSTR) pAdd->Data, MyDomain);
         lstrcat((LPTSTR) pAdd->Data, (LPTSTR) Data);
         pAdd->DataLength = DataLength + MyDomainSize;

      } else {
         UserRec.UserID = LocalAlloc( LPTR, DataLength);

         if (UserRec.UserID == NULL) {
            ASSERT(FALSE);
            LocalFree(pAdd);
            return;
         }

         pAdd->Data = UserRec.UserID;
         memcpy(pAdd->Data, Data, DataLength);
         pAdd->DataLength = DataLength;
      }

      //
      // copy over all the data fields into the newly created Add Cache
      // record.
      //
      pAdd->DataType = DataType;
      pAdd->Service = Service->MasterService;
      pAdd->AccessCount = 1;
      pAdd->LastAccess = LastUsedTime;
      pAdd->Flags = LLS_FLAG_SUITE_AUTO;

      //
      // Now update the actual Add Cache
      //
      RtlEnterCriticalSection(&AddCacheLock);
      pAdd->prev = AddCache;
      AddCache = pAdd;
      AddCacheSize++;
      RtlLeaveCriticalSection(&AddCacheLock);

      //
      // Now must signal the event so we can pull off the new record.
      //
      NtStatus = NtSetEvent( LLSAddCacheEvent, NULL );
      ASSERT(NT_SUCCESS(NtStatus));
   }

} // UserListUpdate


#if DBG
/////////////////////////////////////////////////////////////////////////
VOID
AddCacheDebugDump ( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;
   PADD_CACHE pAdd;
   UNICODE_STRING UString;
   ULONG i = 0;

   RtlEnterCriticalSection(&AddCacheLock);

   dprintf(TEXT("Add Cache Dump.  Record Size: %4lu # Entries: %lu\n"), sizeof(ADD_CACHE), AddCacheSize);
   pAdd = AddCache;

   while (pAdd != NULL) {
      if (pAdd->DataType == DATA_TYPE_USERNAME)
         dprintf(TEXT("%4lu) Svc: %s User: [%2lu] %s\n"),
            ++i,
            pAdd->Service,
            pAdd->DataLength,
            pAdd->Data);
      else if (pAdd->DataType == DATA_TYPE_SID) {
         Status = RtlConvertSidToUnicodeString(&UString, (PSID) pAdd->Data, TRUE);

         dprintf(TEXT("%4lu) Svc: %s User: [%2lu] %s\n"),
            ++i,
            pAdd->Service,
            pAdd->DataLength,
            UString.Buffer);

         RtlFreeUnicodeString(&UString);
      }

      pAdd = pAdd->prev;
   }

   RtlLeaveCriticalSection(&AddCacheLock);

} // AddCacheDebugDump


/////////////////////////////////////////////////////////////////////////
VOID
UserListDebugDump( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;
   PUSER_RECORD UserRec = NULL;
   PVOID RestartKey = NULL;

   RtlAcquireResourceShared(&UserListLock, TRUE);

   dprintf(TEXT("User List Dump.  Record Size: %4lu # Entries: %lu\n"), sizeof(USER_RECORD), UserListNumEntries);
   UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);

   while (UserRec != NULL) {
      //
      // Dump info for found user-rec
      //
      if (UserRec->Mapping != NULL)
         dprintf(TEXT("%4lu) Repl: %s LT: %2lu Svc: %2lu Flags: 0x%4lX Map: %s User: [%2lu] %s\n"),
            ++i,
            TimeToString((ULONG)(UserRec->LastReplicated)),
            UserRec->LicenseListSize,
            UserRec->ServiceTableSize,
            UserRec->Flags,
            UserRec->Mapping->Name,
            UserRec->IDSize,
            (LPTSTR) UserRec->UserID );
      else
         dprintf(TEXT("%4lu) Repl: %s LT: %2lu Svc: %2lu Flags: 0x%4lX User: [%2lu] %s\n"),
            ++i,
            TimeToString((ULONG)(UserRec->LastReplicated)),
            UserRec->LicenseListSize,
            UserRec->ServiceTableSize,
            UserRec->Flags,
            UserRec->IDSize,
            (LPTSTR) UserRec->UserID );

      // Get next record
      UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);
   }

   RtlReleaseResource(&UserListLock);
} // UserListDebugDump


/////////////////////////////////////////////////////////////////////////
VOID
UserListDebugInfoDump(
   PVOID Data
 )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   USER_RECORD UserRec;
   PUSER_RECORD pUserRec;
   PSVC_RECORD SvcTable = NULL;
   ULONG i;

   RtlAcquireResourceExclusive(&UserListLock, TRUE);
   dprintf(TEXT("User List Info.  Record Size: %4lu # Entries: %lu\n"), sizeof(USER_RECORD), UserListNumEntries);

   //
   // Only dump user if one was specified.
   //
   if (lstrlen((LPWSTR) Data) > 0) {
      UserRec.UserID = Data;

      RtlEnterCriticalSection(&GenTableLock);
      pUserRec = (PUSER_RECORD) LLSLookupElementGenericTable(&UserList, &UserRec);
      RtlLeaveCriticalSection(&GenTableLock);

      if (pUserRec != NULL) {
         //
         // Dump info for found user-rec
         //
         if (pUserRec->Mapping != NULL)
            dprintf(TEXT("   Repl: %s LT: %2lu Svc: %2lu Flags: 0x%4lX Map: %s User: [%2lu] %s\n"),
               TimeToString((ULONG)(pUserRec->LastReplicated)),
               pUserRec->LicenseListSize,
               pUserRec->ServiceTableSize,
               pUserRec->Flags,
               pUserRec->Mapping->Name,
               pUserRec->IDSize,
               (LPTSTR) pUserRec->UserID );
         else
            dprintf(TEXT("   Repl: %s LT: %2lu Svc: %2lu Flags: 0x%4lX User: [%2lu] %s\n"),
               TimeToString((ULONG)(pUserRec->LastReplicated)),
               pUserRec->LicenseListSize,
               pUserRec->ServiceTableSize,
               pUserRec->Flags,
               pUserRec->IDSize,
               (LPTSTR) pUserRec->UserID );

         //
         // Now do the service table - but get critical section first.
         //
         RtlEnterCriticalSection(&pUserRec->ServiceTableLock);
         SvcTable = pUserRec->Services;

         if (pUserRec->ServiceTableSize != 0)
            dprintf(TEXT("\nServiceTable\n"));

         for (i = 0; i < pUserRec->ServiceTableSize; i++)
            dprintf( TEXT("      AC: %4lu LA: %s Flags: 0x%4lX Svc: %s\n"),
                     SvcTable[i].AccessCount,
                     TimeToString(SvcTable[i].LastAccess),
                     SvcTable[i].Flags,
                     SvcTable[i].Service->Name );

         if (pUserRec->LicenseListSize != 0)
            dprintf(TEXT("\nLicenseTable\n"));

         for (i = 0; i < pUserRec->LicenseListSize; i++)
            dprintf( TEXT("      Flags: 0x%4lX Ref: %2lu LN: %2lu Svc: %s\n"),
                     pUserRec->LicenseList[i]->Flags,
                     pUserRec->LicenseList[i]->RefCount,
                     pUserRec->LicenseList[i]->LicensesNeeded,
                     pUserRec->LicenseList[i]->Service->Name );

         RtlLeaveCriticalSection(&pUserRec->ServiceTableLock);

      } else
         dprintf(TEXT("User Not Found: %s\n"), (LPWSTR) Data);
   }

   RtlReleaseResource(&UserListLock);

} // UserListDebugInfoDump


/////////////////////////////////////////////////////////////////////////
VOID
UserListDebugFlush( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   USER_RECORD UserRec;

   //
   // Searching so don't need exclusive access
   //
   RtlAcquireResourceExclusive(&UserListLock, TRUE);

   RtlEnterCriticalSection(&GenTableLock);
   LLSLookupElementGenericTable(&UserList, &UserRec);
   RtlLeaveCriticalSection(&GenTableLock);

   RtlReleaseResource(&UserListLock);
} // UserListDebugFlush


/////////////////////////////////////////////////////////////////////////
VOID
SidListDebugDump( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;
   PUSER_RECORD UserRec = NULL;
   UNICODE_STRING UString;
   NTSTATUS NtStatus;
   PVOID RestartKey = NULL;

   RtlAcquireResourceShared(&SidListLock, TRUE);

   dprintf(TEXT("SID List Dump.  Record Size: %4lu # Entries: %lu\n"), sizeof(USER_RECORD), SidListNumEntries);
   UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&SidList, (VOID **) &RestartKey);

   while (UserRec != NULL) {
      //
      // Dump info for found user-rec
      //
      NtStatus = RtlConvertSidToUnicodeString(&UString, (PSID) UserRec->UserID, TRUE);
      dprintf(TEXT("%4lu) User-Rec: 0x%lX Svc: %2lu User: [%2lu] %s\n"),
         ++i,
         UserRec->LastReplicated,
         UserRec->ServiceTableSize,
         UserRec->IDSize,
         UString.Buffer );

      RtlFreeUnicodeString(&UString);

      // Get next record
      UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&SidList, (VOID **) &RestartKey);
   }

   RtlReleaseResource(&SidListLock);
} // SidListDebugDump


/////////////////////////////////////////////////////////////////////////
VOID
SidListDebugInfoDump(
   PVOID Data
 )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   USER_RECORD UserRec;
   PUSER_RECORD pUserRec;
   PSVC_RECORD SvcTable = NULL;
   ULONG i;

   RtlAcquireResourceExclusive(&SidListLock, TRUE);
   dprintf(TEXT("SID List Info.  Record Size: %4lu # Entries: %lu\n"), sizeof(USER_RECORD), SidListNumEntries);

   //
   // Only dump user if one was specified.
   //
   if (lstrlen((LPWSTR) Data) > 0) {
      UserRec.UserID = Data;

      RtlEnterCriticalSection(&GenTableLock);
      pUserRec = (PUSER_RECORD) LLSLookupElementGenericTable(&SidList, &UserRec);
      RtlLeaveCriticalSection(&GenTableLock);

      if (pUserRec != NULL) {
         //
         // Dump info for found user-rec
         //
         dprintf(TEXT("   User-Rec: 0x%lX Svc: %2lu User: [%2lu] %s\n"),
            pUserRec->LastReplicated,
            pUserRec->ServiceTableSize,
            pUserRec->IDSize,
            (LPTSTR) pUserRec->UserID );

         // No Service Table for SID's
      } else
         dprintf(TEXT("SID Not Found: %s\n"), (LPWSTR) Data);
   }

   RtlReleaseResource(&SidListLock);

} // SidListDebugInfoDump


/////////////////////////////////////////////////////////////////////////
VOID
SidListDebugFlush( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   USER_RECORD UserRec;

   //
   // Searching so don't need exclusive access
   //
   RtlAcquireResourceExclusive(&SidListLock, TRUE);

   RtlReleaseResource(&SidListLock);
} // SidListDebugFlush


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\msvctbl.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

   msvctbl.h

Abstract:

   See msvctbl.c
        
Author:

   Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added comments.

--*/


#ifndef _LLS_MSVCTBL_H
#define _LLS_MSVCTBL_H


#ifdef __cplusplus
extern "C" {
#endif


#define IDS_BACKOFFICE 1500

/////////////////////////////////////////////////////////////////////////
//
// The master service record is for license usage tracking.  We have
// A master ROOT record for a family of products (say SQL Server) and
// a sub linked-list of each of the specific versions in order of the
// version number.  When we do license checking we can move on up the tree 
// to higher level of licenses.
//
// There is also a mapping table kept for each of the ROOT records.  This
// tracks if the mapping license count has already been used.
//
struct _MASTER_SERVICE_ROOT;

typedef struct _MASTER_SERVICE_RECORD
{
   ULONG                            Index;               // index at which
                                                         // a pointer to this
                                                         // structure may be
                                                         // found in the
                                                         // MasterServiceTable

   LPTSTR                           Name;                // product name

   DWORD                            Version;             // version of the
                                                         // product;
                                                         // major.minor ->
                                                         // (major << 16)
                                                         //  | minor, e.g.,
                                                         // 5.2 -> 0x50002

   struct _MASTER_SERVICE_ROOT *    Family;              // pointer to the
                                                         // product family,
                                                         // e.g., "SNA 2.1"
                                                         // -> "SNA"

   ULONG                            Licenses;
   ULONG                            LicensesUsed;
   ULONG                            LicensesClaimed;

   ULONG                            MaxSessionCount;
   ULONG                            HighMark;

   ULONG                            next;                // index at which
                                                         // a pointer to the
                                                         // next ascending
                                                         // version of this
                                                         // product may be
                                                         // found in the
                                                         // MasterServiceTable
                                                         // NOTE: index is
                                                         // 1-based, so if
                                                         // next == 0 there
                                                         // are no more, and
                                                         // if non-zero then
                                                         // the next version
                                                         // is at index next-1

} MASTER_SERVICE_RECORD, *PMASTER_SERVICE_RECORD;

typedef struct _MASTER_SERVICE_ROOT
{
   LPTSTR            Name;                // name of this product family

   DWORD             Flags;

   RTL_RESOURCE      ServiceLock;         // lock for changes to the
                                          // Services array (below)

   ULONG             ServiceTableSize;    // number of entries in Services
                                          // array (below)

   ULONG *           Services;            // array of indices into the
                                          // MasterServiceTable of the various
                                          // (product,version) pairs
                                          // belonging to this family;
                                          // sorted in order of ascending
                                          // version
} MASTER_SERVICE_ROOT, *PMASTER_SERVICE_ROOT;

extern ULONG RootServiceListSize;
extern PMASTER_SERVICE_ROOT *RootServiceList;

extern ULONG MasterServiceListSize;
extern PMASTER_SERVICE_RECORD *MasterServiceList;
extern PMASTER_SERVICE_RECORD *MasterServiceTable;

extern RTL_RESOURCE MasterServiceListLock;

extern TCHAR BackOfficeStr[];
extern PMASTER_SERVICE_RECORD BackOfficeRec;


NTSTATUS MasterServiceListInit();
PMASTER_SERVICE_RECORD MServiceRecordFind( DWORD Version, ULONG NumServiceEntries, PULONG ServiceList );
PMASTER_SERVICE_ROOT MServiceRootFind( LPTSTR ServiceName );
PMASTER_SERVICE_RECORD MasterServiceListFind( LPTSTR DisplayName );
PMASTER_SERVICE_RECORD MasterServiceListAdd( LPTSTR FamilyName, LPTSTR Name, DWORD Version );

#if DBG

VOID MasterServiceRootDebugDump();
VOID MasterServiceRootDebugInfoDump( PVOID Data );
VOID MasterServiceListDebugDump();
VOID MasterServiceListDebugInfoDump( PVOID Data );

#endif



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\msvctbl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

   msvctbl.c

Abstract:

   Master Service Table routines.  Handles all access to the master service
   table kept for per-seat information.

   =========================== DATA STRUCTURES =============================

   MasterServiceTable (PMASTER_SERVICE_RECORD *)
   MasterServiceList (PMASTER_SERVICE_RECORD *)
      Each of these points to an array of pointers to dynamically allocated
      MASTER_SERVICE_RECORDs.  There is exactly one MASTER_SERVICE_RECORD
      for each (product, version) pairing; e.g., (SQL 4.0, SNA 2.0,
      SNA 2.1).  The MasterServiceTable is never re-ordered, so a valid
      index into this table is guaranteed to always dereference to the same
      (product, version).  The MasterServiceList contains the same data
      sorted lexicographically by product name (and therefore the data
      pointed to by a specific index may change over time as new
      (product, version) pairs are added to the table).  Each table
      contains MasterServiceListSize entries.

   RootServiceList (PMASTER_SERVICE_ROOT *)
      This points to an array of pointers to dynamically allocated
      MASTER_SERVICE_ROOTs.  There is exactly one MASTER_SERVICE_ROOT
      for each product family.  Each MASTER_SERVICE_ROOT contains a
      pointer to an array of indices into the MasterServiceTable
      corresponding to all the products in the family, sorted by
      ascending version number.  The RootServiceList itself is
      sorted lexicographically by ascending family name.  It contains
      RootServiceListSize entries.

Author:

   Arthur Hanson (arth) 07-Dec-1994

Revision History:

   Jeff Parham (jeffparh)  05-Dec-1995
      o  Added a few comments.
      o  Added parameter to LicenseServiceListFind().
      o  Fixed benign bug in memory allocation:
         sizeof(PULONG) -> sizeof(ULONG).

--*/

#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dsgetdc.h>

#include "llsapi.h"
#include "debug.h"
#include "llssrv.h"
#include "registry.h"
#include "ntlsapi.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "purchase.h"
#include "perseat.h"


/////////////////////////////////////////////////////////////////////////
//
// Master Service Table - Keeps list of products (SQL, SNA, etc.) with a
// sub-list for each version of the product.
//

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#define DEFAULT_SERVICE_TABLE_ENTRIES 10

ULONG RootServiceListSize = 0;
PMASTER_SERVICE_ROOT *RootServiceList = NULL;

ULONG MasterServiceListSize = 0;
PMASTER_SERVICE_RECORD *MasterServiceList = NULL;
PMASTER_SERVICE_RECORD *MasterServiceTable = NULL;

TCHAR BackOfficeStr[100];
PMASTER_SERVICE_RECORD BackOfficeRec;

RTL_RESOURCE MasterServiceListLock;

HANDLE gLlsDllHandle = NULL;


/////////////////////////////////////////////////////////////////////////
NTSTATUS
MasterServiceListInit()

/*++

Routine Description:

   Creates the Master Service table, used for tracking the services and
   session count.  This will pull the initial services from the registry.

   The table is linear so a binary search can be used on the table, so
   some extra records are initialized so that each time we add a new
   service we don't have to do a realloc.  We also assume that adding
   new services is a relatively rare occurance, since we need to sort
   it each time.

   The service table is guarded by a read and write semaphore.  Multiple
   reads can occur, but a write blocks everything.

   The service table has two default entries for FilePrint and REMOTE_ACCESS.

Arguments:

   None.

Return Value:

   None.

--*/

{
   int nLen;
   NTSTATUS status = STATUS_SUCCESS;

   try
   {
       RtlInitializeResource(&MasterServiceListLock);
   } except(EXCEPTION_EXECUTE_HANDLER ) {
       status = GetExceptionCode();
   }

   if (!NT_SUCCESS(status))
       return status;

   memset(BackOfficeStr, 0, sizeof(BackOfficeStr));
   BackOfficeRec = NULL;
   gLlsDllHandle = LoadLibrary(TEXT("LLSRPC.DLL"));


   if (gLlsDllHandle != NULL) {
      nLen = LoadString(gLlsDllHandle, IDS_BACKOFFICE, BackOfficeStr, sizeof(BackOfficeStr)/sizeof(TCHAR));

      if (nLen != 0) {
         BackOfficeRec = MasterServiceListAdd( BackOfficeStr, BackOfficeStr, 0 );
         if (NULL == BackOfficeRec)
             status = STATUS_NO_MEMORY;

      } else {
#if DBG
         dprintf(TEXT("LLS ERROR: Could not load BackOffice string\n"));
#endif

         status = GetLastError();
      }

      status = GetLastError();
   }

   return status;

} // MasterServiceListInit


/////////////////////////////////////////////////////////////////////////
// used by qsort to sort MasterServiceList by product name
int __cdecl MasterServiceListCompare(const void *arg1, const void *arg2) {
   PMASTER_SERVICE_RECORD Svc1, Svc2;

   Svc1 = (PMASTER_SERVICE_RECORD) *((PMASTER_SERVICE_RECORD *) arg1);
   Svc2 = (PMASTER_SERVICE_RECORD) *((PMASTER_SERVICE_RECORD *) arg2);

   return lstrcmpi( Svc1->Name, Svc2->Name );

} // MasterServiceListCompare


/////////////////////////////////////////////////////////////////////////
// used by qsort to sort the Services array of indices pointed to by the
// MASTER_SERVICE_ROOT structure by product version number
int __cdecl MServiceRecordCompare(const void *arg1, const void *arg2) {
   PMASTER_SERVICE_RECORD Svc1, Svc2;

   Svc1 = (PMASTER_SERVICE_RECORD) MasterServiceTable[*((PULONG) arg1)];
   Svc2 = (PMASTER_SERVICE_RECORD) MasterServiceTable[*((PULONG) arg2)];

   return (int) Svc1->Version - Svc2->Version;

} // MServiceRecordCompare


/////////////////////////////////////////////////////////////////////////
// used by qsort to sort the RootServiceList array of product families
// by family name
int __cdecl MServiceRootCompare(const void *arg1, const void *arg2) {
   PMASTER_SERVICE_ROOT Svc1, Svc2;

   Svc1 = (PMASTER_SERVICE_ROOT) *((PMASTER_SERVICE_ROOT *) arg1);
   Svc2 = (PMASTER_SERVICE_ROOT) *((PMASTER_SERVICE_ROOT *) arg2);

   return lstrcmpi( Svc1->Name, Svc2->Name );

} // MServiceRootCompare


/////////////////////////////////////////////////////////////////////////
PMASTER_SERVICE_ROOT
MServiceRootFind(
   LPTSTR ServiceName
   )

/*++

Routine Description:

   Internal routine to actually do binary search on MasterServiceList, this
   does not do any locking as we expect the wrapper routine to do this.
   The search is a simple binary search.

Arguments:

   ServiceName -

Return Value:

   Pointer to found service table entry or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end = (LONG) RootServiceListSize - 1;
   LONG cur;
   int match;
   PMASTER_SERVICE_ROOT ServiceRoot;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MServiceRootFind\n"));
#endif

   if ((RootServiceListSize == 0) || (ServiceName == NULL))
      return NULL;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;
      ServiceRoot = RootServiceList[cur];

      // compare the two result into match
      match = lstrcmpi(ServiceName, ServiceRoot->Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return ServiceRoot;
   }

   return NULL;

} // MServiceRootFind


/////////////////////////////////////////////////////////////////////////
PMASTER_SERVICE_RECORD
MasterServiceListFind(
   LPTSTR Name
   )

/*++

Routine Description:

   Internal routine to actually do binary search on MasterServiceList, this
   does not do any locking as we expect the wrapper routine to do this.
   The search is a simple binary search.

Arguments:

   ServiceName -

Return Value:

   Pointer to found service table entry or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end;
   LONG cur;
   int match;
   PMASTER_SERVICE_RECORD Service;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MasterServiceListFind\n"));
#endif

   if ((Name == NULL) || (MasterServiceListSize == 0))
      return NULL;

   end = (LONG) MasterServiceListSize - 1;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;
      Service = MasterServiceList[cur];

      // compare the two result into match
      match = lstrcmpi(Name, Service->Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return Service;
   }

   return NULL;

} // MasterServiceListFind


/////////////////////////////////////////////////////////////////////////
PMASTER_SERVICE_RECORD
MasterServiceListAdd(
   LPTSTR FamilyName,
   LPTSTR Name,
   DWORD Version
   )

/*++

Routine Description:


Arguments:

   ServiceName -

Return Value:

   Pointer to added service table entry, or NULL if failed.

--*/

{
   ULONG i;
   ULONG SessionLimit = 0;
   BOOL PerSeatLicensing = FALSE;
   LPTSTR NewServiceName, pDisplayName;
   PMASTER_SERVICE_RECORD Service = NULL;
   PMASTER_SERVICE_ROOT ServiceRoot = NULL;
   PULONG ServiceList;
   PLICENSE_SERVICE_RECORD pLicense;
   PMASTER_SERVICE_ROOT *pRootServiceListTmp;
   PULONG pServiceListTmp;
   PMASTER_SERVICE_RECORD *pMasterServiceListTmp, *pMasterServiceTableTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MasterServiceListAdd\n"));
#endif

   if ((FamilyName == NULL) || (Name == NULL))
   {
       return NULL;
   }

   //
   // Mask off low word of version - as it doesn't matter to licensing
   //
   Version &= 0xFFFF0000;

   //
   // Try to find a root node for that family of products
   //
   ServiceRoot = MServiceRootFind(FamilyName);

   if (ServiceRoot == NULL) {
      //
      // No root record - so create a new one
      //
      if (RootServiceList == NULL)
         pRootServiceListTmp = (PMASTER_SERVICE_ROOT *) LocalAlloc(LPTR, sizeof(PMASTER_SERVICE_ROOT));
      else
         pRootServiceListTmp = (PMASTER_SERVICE_ROOT *) LocalReAlloc(RootServiceList, sizeof(PMASTER_SERVICE_ROOT) * (RootServiceListSize + 1), LHND);

      //
      // Make sure we could allocate service table
      //
      if (pRootServiceListTmp == NULL) {
         return NULL;
      } else {
          RootServiceList = pRootServiceListTmp;
      }

      //
      // Allocate space for Root.
      //
      ServiceRoot = (PMASTER_SERVICE_ROOT) LocalAlloc(LPTR, sizeof(MASTER_SERVICE_ROOT));
      if (ServiceRoot == NULL) {
         return NULL;
      }

      NewServiceName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(FamilyName) + 1) * sizeof(TCHAR));
      if (NewServiceName == NULL) {
         LocalFree(ServiceRoot);
         return NULL;
      }

      try
      {
          RtlInitializeResource(&ServiceRoot->ServiceLock);
      } except(EXCEPTION_EXECUTE_HANDLER ) {
          LocalFree(ServiceRoot);
          LocalFree(NewServiceName);
          return NULL;
      }

      RootServiceList[RootServiceListSize] = ServiceRoot;

      // now copy it over...
      ServiceRoot->Name = NewServiceName;
      lstrcpy(NewServiceName, FamilyName);

      //
      // Initialize stuff for list of various versions of this product
      //
      ServiceRoot->ServiceTableSize = 0;
      ServiceRoot->Services = NULL;
      ServiceRoot->Flags = 0;

      RootServiceListSize++;

      // Have added the entry - now need to sort it in order of the service names
      qsort((void *) RootServiceList, (size_t) RootServiceListSize, sizeof(PMASTER_SERVICE_ROOT), MServiceRootCompare);

   }

   RtlAcquireResourceShared(&ServiceRoot->ServiceLock, TRUE);
   Service = MasterServiceListFind(Name);
   RtlReleaseResource(&ServiceRoot->ServiceLock);
   if (Service != NULL)
      return Service;

   ////////////////////////////////////////////////////////////////////////
   //
   // Whether added or found, ServiceRoot points to the Root Node entry.
   // Now double check to see if another thread just got done adding the
   // actual service before we got the write lock.
   //
   RtlAcquireResourceShared(&ServiceRoot->ServiceLock, TRUE);
   Service = MasterServiceListFind(Name);

   if (Service == NULL) {
      //
      // No Service Record - so create a new one
      //
      RtlConvertSharedToExclusive(&ServiceRoot->ServiceLock);

      //
      // Double-check that no one snuck in and created it
      //
      Service = MasterServiceListFind(Name);

      if (Service == NULL) {

          ServiceList = ServiceRoot->Services;
          if (ServiceList == NULL)
              pServiceListTmp = (PULONG) LocalAlloc(LPTR, sizeof(ULONG));
          else
              pServiceListTmp = (PULONG) LocalReAlloc(ServiceList, sizeof(ULONG) * (ServiceRoot->ServiceTableSize + 1), LHND);
          
          if (MasterServiceList == NULL) {
              pMasterServiceListTmp = (PMASTER_SERVICE_RECORD *) LocalAlloc(LPTR, sizeof(PMASTER_SERVICE_RECORD));
              pMasterServiceTableTmp = (PMASTER_SERVICE_RECORD *) LocalAlloc(LPTR, sizeof(PMASTER_SERVICE_RECORD));
          } else {
              pMasterServiceListTmp = (PMASTER_SERVICE_RECORD *) LocalReAlloc(MasterServiceList, sizeof(PMASTER_SERVICE_RECORD) * (MasterServiceListSize + 1), LHND);
              pMasterServiceTableTmp = (PMASTER_SERVICE_RECORD *) LocalReAlloc(MasterServiceTable, sizeof(PMASTER_SERVICE_RECORD) * (MasterServiceListSize + 1), LHND);
          }

          //
          // Make sure we could allocate service table
          //
          if ((pServiceListTmp == NULL) || (pMasterServiceListTmp == NULL) || (pMasterServiceTableTmp == NULL)) {
              if (pServiceListTmp != NULL)
                  LocalFree(pServiceListTmp);

              if (pMasterServiceListTmp != NULL)
                  LocalFree(pMasterServiceListTmp);

              if (pMasterServiceTableTmp != NULL)
                  LocalFree(pMasterServiceTableTmp);

              RtlReleaseResource(&ServiceRoot->ServiceLock);
              return NULL;
          } else {
              ServiceList = pServiceListTmp;
              MasterServiceList = pMasterServiceListTmp;
              MasterServiceTable = pMasterServiceTableTmp;
          }

          ServiceRoot->Services = ServiceList;

          //
          // Allocate space for saving off Service Record.
          //
          Service = (PMASTER_SERVICE_RECORD) LocalAlloc(LPTR, sizeof(MASTER_SERVICE_RECORD));
          if (Service == NULL) {
              ASSERT(FALSE);
              RtlReleaseResource(&ServiceRoot->ServiceLock);
              return NULL;
          }

          //
          // ...DisplayName
          //
          NewServiceName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(Name) + 1) * sizeof(TCHAR));
          if (NewServiceName == NULL) {
              ASSERT(FALSE);
              LocalFree(Service);
              RtlReleaseResource(&ServiceRoot->ServiceLock);
              return NULL;
          }

          ServiceList[ServiceRoot->ServiceTableSize] = MasterServiceListSize;
          MasterServiceList[MasterServiceListSize] = Service;
          MasterServiceTable[MasterServiceListSize] = Service;

          // now copy it over...
          Service->Name = NewServiceName;
          lstrcpy(NewServiceName, Name);

          //
          // Init rest of values.
          //
          Service->Version= Version;
          Service->LicensesUsed = 0;
          Service->LicensesClaimed = 0;
          Service->next = 0;
          Service->Index = MasterServiceListSize;
          Service->Family = ServiceRoot;

          pLicense = LicenseServiceListFind(Service->Name, FALSE);
          if (pLicense == NULL)
              Service->Licenses = 0;
          else
              Service->Licenses = pLicense->NumberLicenses;

          //
          // Init next pointer
          //
          i = 0;
          while ((i < ServiceRoot->ServiceTableSize) && (MasterServiceTable[ServiceRoot->Services[i]]->Version < Version))
              i++;
          
          if (i > 0) {
              Service->next = MasterServiceTable[ServiceRoot->Services[i - 1]]->next;
              MasterServiceTable[ServiceRoot->Services[i - 1]]->next = Service->Index + 1;
          }

          ServiceRoot->ServiceTableSize++;
          MasterServiceListSize++;
          
          // Have added the entry - now need to sort it in order of the versions
          qsort((void *) ServiceList, (size_t) ServiceRoot->ServiceTableSize, sizeof(ULONG), MServiceRecordCompare);
          
          // And sort the list the UI uses (sorted by service name)
          qsort((void *) MasterServiceList, (size_t) MasterServiceListSize, sizeof(PMASTER_SERVICE_RECORD), MasterServiceListCompare);
      }
   }

   RtlReleaseResource(&ServiceRoot->ServiceLock);
   return Service;

} // MasterServiceListAdd


#if DBG

/////////////////////////////////////////////////////////////////////////
//
//                   DEBUG INFORMATION DUMP ROUTINES
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
VOID
MasterServiceRootDebugDump( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&MasterServiceListLock, TRUE);

   dprintf(TEXT("Service Family Table, # Entries: %lu\n"), RootServiceListSize);
   if (RootServiceList == NULL)
      goto MasterServiceRootDebugDumpExit;

   for (i = 0; i < RootServiceListSize; i++) {
      dprintf(TEXT("%3lu) Services: %3lu Svc: %s [%s]\n"),
         i + 1, RootServiceList[i]->ServiceTableSize, RootServiceList[i]->Name, RootServiceList[i]->Name);
   }

MasterServiceRootDebugDumpExit:
   RtlReleaseResource(&MasterServiceListLock);

   return;
} // MasterServiceRootDebugDump


/////////////////////////////////////////////////////////////////////////
VOID
MasterServiceRootDebugInfoDump( PVOID Data )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&MasterServiceListLock, TRUE);

   dprintf(TEXT("Service Family Table, # Entries: %lu\n"), RootServiceListSize);
   if (RootServiceList == NULL)
      goto MasterServiceRootDebugDumpExit;

   for (i = 0; i < RootServiceListSize; i++) {
      dprintf(TEXT("%3lu) Services: %3lu Svc: %s [%s]\n"),
         i + 1, RootServiceList[i]->ServiceTableSize, RootServiceList[i]->Name, RootServiceList[i]->Name);
   }

MasterServiceRootDebugDumpExit:
   RtlReleaseResource(&MasterServiceListLock);

   return;
} // MasterServiceRootDebugInfoDump


/////////////////////////////////////////////////////////////////////////
VOID
MasterServiceListDebugDump( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&MasterServiceListLock, TRUE);

   dprintf(TEXT("Master Service Table, # Entries: %lu\n"), MasterServiceListSize);
   if (MasterServiceList == NULL)
      goto MasterServiceListDebugDumpExit;

   for (i = 0; i < MasterServiceListSize; i++) {
      dprintf(TEXT("%3lu) [%3lu] LU: %4lu LP: %4lu LC: %4lu MS: %4lu HM: %4lu Next: %3lu Svc: %s %lX\n"),
         i + 1, MasterServiceList[i]->Index,
         MasterServiceList[i]->LicensesUsed, MasterServiceList[i]->Licenses, MasterServiceList[i]->LicensesClaimed,
         MasterServiceList[i]->MaxSessionCount, MasterServiceList[i]->HighMark,
         MasterServiceList[i]->next, MasterServiceList[i]->Name, MasterServiceList[i]->Version);
   }

MasterServiceListDebugDumpExit:
   RtlReleaseResource(&MasterServiceListLock);

   return;
} // MasterServiceListDebugDump


/////////////////////////////////////////////////////////////////////////
VOID
MasterServiceListDebugInfoDump( PVOID Data )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PMASTER_SERVICE_RECORD CurrentRecord = NULL;

   dprintf(TEXT("Master Service Table, # Entries: %lu\n"), RootServiceListSize);

   if (lstrlen((LPWSTR) Data) > 0) {
//      CurrentRecord = MasterServiceListFind((LPWSTR) Data);
      if (CurrentRecord != NULL) {
      }
   }

} // MasterServiceListDebugInfoDump

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\perseat.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    PerSeat.h

Abstract:


Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

   Jeff Parham (jeffparh) 12-Jan-1996
      o  Added support for maintaining the SUITE_USE flag when adding
         users to the AddCache.
      o  Exported function prototype for MappingLicenseListFree().

--*/

#ifndef _LLS_PERSEAT_H
#define _LLS_PERSEAT_H

#include "llsrtl.h"

#ifdef __cplusplus
extern "C" {
#endif

#define DATA_TYPE_USERNAME 0
#define DATA_TYPE_SID      1

#define MAX_ACCESS_COUNT   0xFFFFFFF


/////////////////////////////////////////////////////////////////////////
//
// Add cache is here as add records need exclusive access to the user table.
// Since we may have alot of read requests comming in at once, we don't want
// to hold up our reply waiting for the exclusive access to be granted, so
// we just dump it onto the add cache (queue) and continue on.
//
// This is even more important with outgoing replication going on as we can 
// have shared access lock on the table for awhile.
//
// Incomming replication just bundles up the data and sticks it on the Add
// Cache to be processed like normal requests.
//
struct _ADD_CACHE;

typedef struct _ADD_CACHE {
   struct _ADD_CACHE *prev;
   ULONG DataType;
   ULONG DataLength;
   PVOID Data;
   PMASTER_SERVICE_RECORD Service;
   ULONG AccessCount;
   DWORD LastAccess;
   DWORD Flags;
} ADD_CACHE, *PADD_CACHE;


/////////////////////////////////////////////////////////////////////////
//
// These records are for storing the actual user-useage information.
//
typedef struct _USER_LICENSE_RECORD {
   DWORD Flags;
   PMASTER_SERVICE_ROOT Family;
   ULONG RefCount;

   //
   // Version of product License applies to
   PMASTER_SERVICE_RECORD Service;
   ULONG LicensesNeeded;
} USER_LICENSE_RECORD, *PUSER_LICENSE_RECORD;

typedef struct _SVC_RECORD {
   //
   // Actual service this is for
   //
   PMASTER_SERVICE_RECORD Service;

   //
   // What license we took - The product may be SQL 3.0, but in determining
   // the license we might have grabbed a SQL 4.0 license...
   //
   PUSER_LICENSE_RECORD License;

   ULONG AccessCount;
   DWORD LastAccess;
   ULONG Suite;
   DWORD Flags;
} SVC_RECORD, *PSVC_RECORD;

typedef struct _USER_RECORD {
   ULONG IDSize;
   PVOID UserID;

   //
   // Pointer to mapping to use.
   //
   PMAPPING_RECORD Mapping;

   //
   // Flags is mostly used right now for marking records to be deleted and
   // if backoffice has been set.
   //
   DWORD Flags;

   //
   // How many products are licensed vs unlicensed
   //
   ULONG LicensedProducts;

   //
   // Date when last replicated.  Note:  For SID records this is a pointer
   // into the USER_RECORD for the appropriate user.
   //
   ULONG_PTR LastReplicated;

   //
   // Keep only a critical section lock, and not RTL_RESOURCE (for read/write
   // locks).  All updates of existing services (most common case by far) will
   // be very quick, so exclusive access isn't that bad.  RTL_RESOURCE also
   // would make our table size increase dramatically and add too much extra
   // processing.
   //
   RTL_CRITICAL_SECTION ServiceTableLock;

   //
   // Service table is a linear buffer, we use the service number to access
   // into this buffer.
   //
   ULONG ServiceTableSize;

   // Stuff per service - linear buffer...
   PSVC_RECORD Services;

   //
   // Licenses the user is using
   //
   ULONG LicenseListSize;
   PUSER_LICENSE_RECORD *LicenseList;
} USER_RECORD, *PUSER_RECORD;


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

extern ULONG UserListNumEntries;
extern LLS_GENERIC_TABLE UserList;
extern RTL_RESOURCE UserListLock;

//
// The AddCache itself, a critical section to protect access to it and an
// event to signal the server when there are items on it that need to be
// processed.
//
extern PADD_CACHE AddCache;
extern ULONG AddCacheSize;
extern RTL_CRITICAL_SECTION AddCacheLock;
extern HANDLE LLSAddCacheEvent;

extern DWORD LastUsedTime;
extern BOOL UsersDeleted;


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

PSVC_RECORD SvcListFind( LPTSTR DisplayName, PSVC_RECORD ServiceList, ULONG NumTableEntries );
NTSTATUS SvcListDelete( LPTSTR UserName, LPTSTR ServiceName );
VOID SvcListLicenseFree( PUSER_RECORD pUser );
VOID SvcListLicenseUpdate( PUSER_RECORD pUser );

NTSTATUS UserListInit();
VOID UserListUpdate( ULONG DataType, PVOID Data, PSERVICE_RECORD Service );
PUSER_RECORD UserListFind( LPTSTR UserName );

VOID UserBackOfficeCheck( PUSER_RECORD pUser );

VOID UserListLicenseDelete( PMASTER_SERVICE_RECORD Service, LONG Quantity );
VOID UserLicenseListFree ( PUSER_RECORD pUser );

VOID UserMappingAdd ( PMAPPING_RECORD Mapping, PUSER_RECORD pUser );
VOID FamilyLicenseUpdate ( PMASTER_SERVICE_ROOT Family );
VOID SvcLicenseUpdate( PUSER_RECORD pUser, PSVC_RECORD Svc );

VOID MappingLicenseListFree ( PMAPPING_RECORD Mapping );
VOID MappingLicenseUpdate ( PMAPPING_RECORD Mapping, BOOL ReSynch );


/////////////////////////////////////////////////////////////////////////
#if DBG

VOID AddCacheDebugDump( );
VOID UserListDebugDump( );
VOID UserListDebugInfoDump( PVOID Data );
VOID UserListDebugFlush( );
VOID SidListDebugDump( );
VOID SidListDebugInfoDump( PVOID Data );
VOID SidListDebugFlush( );

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\purchase.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   Purchase.h

Abstract:


Author:

   Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added support for uniting per seat and per server purchase models.
      o  Added extra parameters and code to support secure certificates and
         certificate database.

--*/

#ifndef _LLS_PURCHASE_H
#define _LLS_PURCHASE_H


#ifdef __cplusplus
extern "C" {
#endif


typedef struct _LICENSE_SERVICE_RECORD {
   LPTSTR ServiceName;
   ULONG Index;
   LONG NumberLicenses;
} LICENSE_SERVICE_RECORD, *PLICENSE_SERVICE_RECORD;


typedef struct _LICENSE_PURCHASE_RECORD {
   PLICENSE_SERVICE_RECORD    Service;
   LONG                       NumberLicenses;
   DWORD                      Date;
   LPTSTR                     Admin;
   LPTSTR                     Comment;

   // added for SUR:
   PLICENSE_SERVICE_RECORD    PerServerService;    // points to per server
                                                   // license tally for this
                                                   // service

   DWORD                      AllowedModes;        // bit field: 1, allowed
                                                   // to be used in per seat
                                                   // mode; 2, per server

   DWORD                      CertificateID;       // identifies the secure
                                                   // certificate from which
                                                   // these licenses came, or
                                                   // 0 if unsecure

   LPTSTR                     Source;              // source of the certificate
                                                   // currently supported
                                                   // values are "None" and
                                                   // "Paper"

   DWORD                      ExpirationDate;      // time at which this
                                                   // certificate expires

   DWORD                      MaxQuantity;         // the largest number of licenses
                                                   // that can be installed from this
                                                   // certificate

   LPTSTR                     Vendor;              // vendor of the product, e.g.,
                                                   // "Microsoft"

   DWORD                      Secrets[ LLS_NUM_SECRETS ];   // secrets for LSAPI
                                                            // challenge mechanism

} LICENSE_PURCHASE_RECORD, *PLICENSE_PURCHASE_RECORD;



extern ULONG LicenseServiceListSize;
extern PLICENSE_SERVICE_RECORD *LicenseServiceList;

extern ULONG PerServerLicenseServiceListSize;
extern PLICENSE_SERVICE_RECORD *PerServerLicenseServiceList;

extern PLICENSE_PURCHASE_RECORD PurchaseList;
extern ULONG PurchaseListSize;

extern RTL_RESOURCE LicenseListLock;


NTSTATUS LicenseListInit();
PLICENSE_SERVICE_RECORD LicenseServiceListFind( LPTSTR ServiceName, BOOL UsePerServerList );
PLICENSE_SERVICE_RECORD LicenseServiceListAdd( LPTSTR ServiceName, BOOL UsePerServerList );
ULONG ProductLicensesGet( LPTSTR ServiceName, BOOL UsePerServerList );
NTSTATUS LicenseAdd( LPTSTR ServiceName, LPTSTR Vendor, LONG Quantity, DWORD MaxQuantity, LPTSTR Admin, LPTSTR Comment, DWORD Date, DWORD AllowedModes, DWORD CertificateID, LPTSTR Source, DWORD ExpirationDate, LPDWORD Secrets );


#if DBG
VOID LicenseListDebugDump( );
#endif


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\pack.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   pack.c

Abstract:


Author:

   Arthur Hanson (arth) 06-Jan-1995

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added new fields to purchase record to support secure certificates.
      o  Unified per server purchase model with per seat purchase model for
         secure certificates; per server model still done in the traditional
         manner for non-secure certificates (for backwards compatibility).
      o  Removed assertion on LicenseAdd() failure.  LicenseAdd() may
         legitimately fail under certain circumstances.
      o  Fixed bug wherein a memory allocation failure in the LLS routines
         would result in a corrupt data file (which would AV the server when
         it was thereafter read).  (Bug #14072.)
      o  Added SaveAll() function analogous to LoadAll().
      o  Added support for extended user data packing/unpacking.  This was
         done to save the SUITE_USE flag across restarts of the service.
      o  Removed user table parameters from unpack routines that didn't use
         them.
      o  Fixed ServerServiceListUnpack() to subtract out old values only when
         they were previously added to the MasterServiceTable.  This fixes
         problems with the MaxSessionCount and HighMark tallies getting skewed.

--*/

#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tstr.h>
#include <dsgetdc.h>

#include "llsapi.h"
#include "debug.h"
#include "llsutil.h"
#include "llssrv.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "perseat.h"
#include "purchase.h"
#include "server.h"
#include "service.h"

#include "llsrpc_s.h"
#include "lsapi_s.h"
#include "llsdbg_s.h"
#include "repl.h"
#include "pack.h"
#include "llsevent.h"
#include "certdb.h"
#include "llsrtl.h"


int __cdecl MServiceRecordCompare(const void *arg1, const void *arg2);
BOOL        ValidateDN(LPTSTR pszDN);

static HANDLE PurchaseFile = NULL;

/////////////////////////////////////////////////////////////////////////
// License List
//

/////////////////////////////////////////////////////////////////////////
VOID
LicenseListUnpackOld (
   ULONG LicenseServiceTableSize,
   PPACK_LICENSE_SERVICE_RECORD LicenseServices,

   ULONG LicenseTableSize,
   PPACK_LICENSE_PURCHASE_RECORD_0 Licenses
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG i;
   PPACK_LICENSE_PURCHASE_RECORD_0 pLicense;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LicenseListUnpackOld: Service[%lu] License[%lu]\n"), LicenseServiceTableSize, LicenseTableSize);
#endif

   //
   // Walk services table, adding any new services to our local table.
   // Fix up the index pointers to match our local services.
   //
   RtlAcquireResourceExclusive(&LicenseListLock, TRUE);

   for (i = 0; i < LicenseTableSize; i++) {
      pLicense = &Licenses[i];

      if (pLicense->Service < LicenseServiceTableSize)
         Status = LicenseAdd(LicenseServices[pLicense->Service].ServiceName, TEXT("Microsoft"), pLicense->NumberLicenses, 0, pLicense->Admin, pLicense->Comment, pLicense->Date, LLS_LICENSE_MODE_ALLOW_PER_SEAT, 0, TEXT("None"), 0, NULL );
      else {
         ASSERT(FALSE);
      }

      if (Status != STATUS_SUCCESS) {
#ifdef DBG
         dprintf(TEXT("LicenseAdd failed: 0x%lX\n"), Status);
#endif
         // ASSERT(FALSE);
      }

   }

   RtlReleaseResource(&LicenseListLock);

} // LicenseListUnpackOld


/////////////////////////////////////////////////////////////////////////
VOID
LicenseListStringsUnpackOld (
   ULONG LicenseServiceTableSize,
   PPACK_LICENSE_SERVICE_RECORD LicenseServices,

   ULONG LicenseServiceStringSize,
   LPTSTR LicenseServiceStrings,

   ULONG LicenseTableSize,
   PPACK_LICENSE_PURCHASE_RECORD_0 Licenses,

   ULONG LicenseStringSize,
   LPTSTR LicenseStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   ULONG i;
   PPACK_LICENSE_SERVICE_RECORD pSvc;
   PPACK_LICENSE_PURCHASE_RECORD_0 pLicense;
   TCHAR *pStr;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LicenseListStringsUnpack\n"));
#endif

   //
   // First do license service strings
   //
   pStr = LicenseServiceStrings;
   for (i = 0; i < LicenseServiceTableSize; i++) {
      pSvc = &LicenseServices[i];

      pSvc->ServiceName = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;
   }

   //
   // Now do license purchase strings
   //
   pStr = LicenseStrings;
   for (i = 0; i < LicenseTableSize; i++) {
      pLicense = &Licenses[i];

      pLicense->Admin = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;

      pLicense->Comment = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;
   }

} // LicenseListStringsUnpackOld


/////////////////////////////////////////////////////////////////////////
VOID
LicenseListLoadOld()

/*++

Routine Description:

Arguments:

   None.

Return Value:

   None.

--*/

{
   BOOL ret;
   DWORD Version, DataSize;
   NTSTATUS Status = STATUS_SUCCESS;
   HANDLE hFile = NULL;

   ULONG LicenseServiceTableSize;
   PPACK_LICENSE_SERVICE_RECORD LicenseServices = NULL;

   ULONG LicenseServiceStringSize;
   LPTSTR LicenseServiceStrings = NULL;

   ULONG LicenseTableSize;
   PPACK_LICENSE_PURCHASE_RECORD_0 Licenses = NULL;

   ULONG LicenseStringSize;
   LPTSTR LicenseStrings = NULL;

   LICENSE_FILE_HEADER_0 FileHeader;
   DWORD BytesRead;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: LicenseListLoad\n"));
#endif

   //
   // Check if we already have file open
   //
   if (PurchaseFile != NULL) {
      CloseHandle(PurchaseFile);
      PurchaseFile = NULL;
   }

   //
   // If nothing to load then get-out
   //
   if (!FileExists(LicenseFileName))
      goto LicenseListLoadExit;

   //
   // Check the init header
   //
   Version = DataSize = 0;
   PurchaseFile = LlsFileCheck(LicenseFileName, &Version, &DataSize );
   if (PurchaseFile == NULL) {
      Status = GetLastError();
      goto LicenseListLoadExit;
   }

   if ((Version != LICENSE_FILE_VERSION_0) || (DataSize != sizeof(LICENSE_FILE_HEADER_0))) {
      Status = STATUS_FILE_INVALID;
      goto LicenseListLoadExit;
   }

   //
   // The init header checks out, so load the license header and data blocks
   //
   hFile = PurchaseFile;
   ret = ReadFile(hFile, &FileHeader, sizeof(LICENSE_FILE_HEADER_0), &BytesRead, NULL);

   LicenseServiceTableSize = 0;
   LicenseServiceStringSize = 0;
   LicenseTableSize = 0;
   LicenseStringSize = 0;

   if (ret) {
      //
      // Run through and allocate space to read data blocks into
      //
      if (FileHeader.LicenseServiceTableSize != 0) {
         LicenseServiceTableSize = FileHeader.LicenseServiceTableSize / sizeof(PACK_LICENSE_SERVICE_RECORD);
         LicenseServices = MIDL_user_allocate(FileHeader.LicenseServiceTableSize);

         if ( LicenseServices == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LicenseListLoadExit;
         }
      }

      if (FileHeader.LicenseServiceStringSize != 0) {
         LicenseServiceStringSize = FileHeader.LicenseServiceStringSize / sizeof(TCHAR);
         LicenseServiceStrings = MIDL_user_allocate(FileHeader.LicenseServiceStringSize);

         if ( LicenseServiceStrings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LicenseListLoadExit;
         }
      }

      if (FileHeader.LicenseTableSize != 0) {
         LicenseTableSize = FileHeader.LicenseTableSize / sizeof(PACK_LICENSE_PURCHASE_RECORD);
         Licenses = MIDL_user_allocate(FileHeader.LicenseTableSize);

         if ( Licenses == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LicenseListLoadExit;
         }
      }

      if (FileHeader.LicenseStringSize != 0) {
         LicenseStringSize = FileHeader.LicenseStringSize / sizeof(TCHAR);
         LicenseStrings = MIDL_user_allocate(FileHeader.LicenseStringSize);

         if ( LicenseStrings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LicenseListLoadExit;
         }
      }

   }

   if (ret && (FileHeader.LicenseServiceTableSize != 0) )
      ret = ReadFile(hFile, LicenseServices, FileHeader.LicenseServiceTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.LicenseServiceStringSize != 0) )
      ret = ReadFile(hFile, LicenseServiceStrings, FileHeader.LicenseServiceStringSize, &BytesRead, NULL);

   if (ret && (FileHeader.LicenseTableSize != 0) )
      ret = ReadFile(hFile, Licenses, FileHeader.LicenseTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.LicenseStringSize != 0) )
      ret = ReadFile(hFile, LicenseStrings, FileHeader.LicenseStringSize, &BytesRead, NULL);

   if (!ret) {
      Status = GetLastError();
      goto LicenseListLoadExit;
   }

   //
   // Decrypt the data
   //
   Status = DeBlock(LicenseServices, FileHeader.LicenseServiceTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(LicenseServiceStrings, FileHeader.LicenseServiceStringSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(Licenses, FileHeader.LicenseTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(LicenseStrings, FileHeader.LicenseStringSize);

   if (Status != STATUS_SUCCESS)
      goto LicenseListLoadExit;


   //
   // Unpack the string data
   //
   LicenseListStringsUnpackOld( LicenseServiceTableSize, LicenseServices,
                                LicenseServiceStringSize, LicenseServiceStrings,
                                LicenseTableSize, Licenses,
                                LicenseStringSize, LicenseStrings );

   //
   // Unpack the license data
   //
   LicenseListUnpackOld( LicenseServiceTableSize, LicenseServices, LicenseTableSize, Licenses );

LicenseListLoadExit:

   // Note: Don't close the License Purchase File (keep it locked).

   //
   // Run through our tables and clean them up
   //
   if (LicenseServices != NULL)
      MIDL_user_free(LicenseServices);

   if (LicenseServiceStrings != NULL)
      MIDL_user_free(LicenseServiceStrings);

   if (Licenses != NULL)
      MIDL_user_free(Licenses);

   if (LicenseStrings != NULL)
      MIDL_user_free(LicenseStrings);

   //
   // If there was an error log it.
   //
   if (Status != STATUS_SUCCESS)
      LogEvent(LLS_EVENT_LOAD_LICENSE, 0, NULL, Status);

} // LicenseListLoadOld

/////////////////////////////////////////////////////////////////////////
NTSTATUS
LicenseListPack (
   ULONG *pLicenseServiceTableSize,
   PPACK_LICENSE_SERVICE_RECORD *pLicenseServices,

   ULONG *pLicenseTableSize,
   PPACK_LICENSE_PURCHASE_RECORD *pLicenses,

   ULONG *pPerServerLicenseServiceTableSize,
   PPACK_LICENSE_SERVICE_RECORD *pPerServerLicenseServices
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   PPACK_LICENSE_SERVICE_RECORD LicenseServices = NULL;
   PPACK_LICENSE_PURCHASE_RECORD Licenses = NULL;
   ULONG i;
   ULONG TotalRecords = 0;
   PLICENSE_SERVICE_RECORD pLicenseService;
   PLICENSE_PURCHASE_RECORD pLicense;
   PPACK_LICENSE_SERVICE_RECORD PerServerLicenseServices = NULL;
   PLICENSE_SERVICE_RECORD pPerServerLicenseService;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LicenseListPack\n"));
#endif

   ASSERT(pLicenseServices != NULL);
   ASSERT(pLicenseServiceTableSize != NULL);

   *pLicenseServices = NULL;
   *pLicenseServiceTableSize = 0;

   ASSERT(pLicenses != NULL);
   ASSERT(pLicenseTableSize != NULL);

   *pLicenses = NULL;
   *pLicenseTableSize = 0;

   ASSERT(pPerServerLicenseServices != NULL);
   ASSERT(pPerServerLicenseServiceTableSize != NULL);

   *pPerServerLicenseServices = NULL;
   *pPerServerLicenseServiceTableSize = 0;

   //////////////////////////////////////////////////////////////////
   //
   // Do License Service Table First
   //
   TotalRecords = LicenseServiceListSize;

   //
   // Make sure there is anything to replicate
   //
   if (TotalRecords > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      LicenseServices = MIDL_user_allocate(TotalRecords * sizeof(PACK_LICENSE_SERVICE_RECORD));
      if (LicenseServices == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer - walk the License Services tree
      //
      for (i = 0; i < LicenseServiceListSize; i++) {
         pLicenseService = LicenseServiceList[i];

         //
         // Make index match table in it's current state
         //
         pLicenseService->Index = i;

         LicenseServices[i].ServiceName = pLicenseService->ServiceName;
         LicenseServices[i].NumberLicenses = pLicenseService->NumberLicenses;
      }
   }

   *pLicenseServices = LicenseServices;
   *pLicenseServiceTableSize = TotalRecords;

   //////////////////////////////////////////////////////////////////
   //
   // Now Do Per Server License Service Table
   //
   TotalRecords = PerServerLicenseServiceListSize;

   //
   // Make sure there is anything to replicate
   //
   if (TotalRecords > 0)
   {
      //
      // Create our buffer to hold all of the garbage
      //
      PerServerLicenseServices = MIDL_user_allocate(TotalRecords * sizeof(PACK_LICENSE_SERVICE_RECORD));
      if (PerServerLicenseServices == NULL)
      {
         ASSERT(FALSE);

         //
         // Clean up already alloc'd information
         //
         if (LicenseServices != NULL)
            MIDL_user_free(LicenseServices);

         *pLicenseServices                   = NULL;
         *pLicenseServiceTableSize           = 0;

         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer - walk the Per Server License Services tree
      //
      for (i = 0; i < PerServerLicenseServiceListSize; i++)
      {
         pPerServerLicenseService = PerServerLicenseServiceList[i];

         //
         // Make index match table in it's current state
         //
         pPerServerLicenseService->Index = i;

         PerServerLicenseServices[i].ServiceName    = pPerServerLicenseService->ServiceName;
         PerServerLicenseServices[i].NumberLicenses = pPerServerLicenseService->NumberLicenses;
      }
   }

   *pPerServerLicenseServices = PerServerLicenseServices;
   *pPerServerLicenseServiceTableSize = TotalRecords;

   //////////////////////////////////////////////////////////////////
   //
   // Now Do License Purchase Records
   //
   TotalRecords = PurchaseListSize;

   //
   // Make sure there is anything to replicate
   //
   if (TotalRecords > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      Licenses = MIDL_user_allocate(TotalRecords * sizeof(PACK_LICENSE_PURCHASE_RECORD));
      if (Licenses == NULL) {
         ASSERT(FALSE);

         //
         // Clean up already alloc'd information
         //
         if (LicenseServices != NULL)
            MIDL_user_free(LicenseServices);
         if (PerServerLicenseServices != NULL)
            MIDL_user_free(PerServerLicenseServices);

         *pLicenseServices                   = NULL;
         *pLicenseServiceTableSize           = 0;
         *pPerServerLicenseServices          = NULL;
         *pPerServerLicenseServiceTableSize  = 0;

         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer - walk the License Purchase tree
      //
      for (i = 0; i < PurchaseListSize; i++) {
         pLicense = &PurchaseList[i];

         //
         // License Service table index is fixed-up to what we need
         //
         Licenses[i].Service = ( pLicense->AllowedModes & 1 ) ? pLicense->Service->Index
                                                              : 0xFFFFFFFF;
         Licenses[i].NumberLicenses = pLicense->NumberLicenses;
         Licenses[i].Date = pLicense->Date;
         Licenses[i].Admin = pLicense->Admin;
         Licenses[i].Comment = pLicense->Comment;

         Licenses[i].PerServerService = ( pLicense->AllowedModes & 2 ) ? pLicense->PerServerService->Index
                                                                       : 0xFFFFFFFF;
         Licenses[i].AllowedModes     = pLicense->AllowedModes;
         Licenses[i].CertificateID    = pLicense->CertificateID;
         Licenses[i].Source           = pLicense->Source;
         Licenses[i].ExpirationDate   = pLicense->ExpirationDate;
         Licenses[i].MaxQuantity      = pLicense->MaxQuantity;
         Licenses[i].Vendor           = pLicense->Vendor;
         memcpy( Licenses[i].Secrets, pLicense->Secrets, LLS_NUM_SECRETS * sizeof( *pLicense->Secrets ) );
      }
   }

   *pLicenses = Licenses;
   *pLicenseTableSize = TotalRecords;
   return Status;
} // LicenseListPack


/////////////////////////////////////////////////////////////////////////
VOID
LicenseListUnpack (
   ULONG LicenseServiceTableSize,
   PPACK_LICENSE_SERVICE_RECORD LicenseServices,

   ULONG LicenseTableSize,
   PPACK_LICENSE_PURCHASE_RECORD Licenses,

   ULONG PerServerLicenseServiceTableSize,
   PPACK_LICENSE_SERVICE_RECORD PerServerLicenseServices
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG i;
   PPACK_LICENSE_PURCHASE_RECORD pLicense;
   LPTSTR   ServiceName;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LicenseListUnpack: Service[%lu] PerServerService[%lu] License[%lu]\n"), LicenseServiceTableSize, PerServerLicenseServiceTableSize, LicenseTableSize);
#endif

   //
   // Walk services table, adding any new services to our local table.
   // Fix up the index pointers to match our local services.
   //
   RtlAcquireResourceExclusive(&LicenseListLock, TRUE);

   for (i = 0; i < LicenseTableSize; i++)
   {
      pLicense = &Licenses[i];

      ServiceName = NULL;

      if ( pLicense->AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SERVER )
      {
         if ( pLicense->PerServerService < PerServerLicenseServiceTableSize )
         {
            ServiceName = PerServerLicenseServices[ pLicense->PerServerService ].ServiceName;
         }
         else
         {
            ASSERT( FALSE );
         }
      }

      if ( ( NULL == ServiceName ) && ( pLicense->AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT ) )
      {
         if ( pLicense->Service < LicenseServiceTableSize )
         {
            ServiceName = LicenseServices[ pLicense->Service ].ServiceName;
         }
         else
         {
            ASSERT( FALSE );
         }
      }

      if ( NULL == ServiceName )
      {
         ASSERT( FALSE );
      }
      else
      {
         Status = LicenseAdd( ServiceName, pLicense->Vendor, pLicense->NumberLicenses, pLicense->MaxQuantity, pLicense->Admin, pLicense->Comment, pLicense->Date, pLicense->AllowedModes, pLicense->CertificateID, pLicense->Source, pLicense->ExpirationDate, pLicense->Secrets );

         if (Status != STATUS_SUCCESS)
         {
#ifdef DBG
            dprintf(TEXT("LicenseAdd failed: 0x%lX\n"), Status);
#endif
            // ASSERT(FALSE);
         }
      }
      if (i % 100 == 0) ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);
   }

   RtlReleaseResource(&LicenseListLock);

} // LicenseListUnpack


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LicenseListStringsPack (
   ULONG LicenseServiceTableSize,
   PPACK_LICENSE_SERVICE_RECORD LicenseServices,

   ULONG *pLicenseServiceStringSize,
   LPTSTR *pLicenseServiceStrings,

   ULONG LicenseTableSize,
   PPACK_LICENSE_PURCHASE_RECORD Licenses,

   ULONG *pLicenseStringSize,
   LPTSTR *pLicenseStrings,

   ULONG PerServerLicenseServiceTableSize,
   PPACK_LICENSE_SERVICE_RECORD PerServerLicenseServices,

   ULONG *pPerServerLicenseServiceStringSize,
   LPTSTR *pPerServerLicenseServiceStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG i;
   ULONG StringSize;
   PPACK_LICENSE_SERVICE_RECORD pSvc;
   PPACK_LICENSE_PURCHASE_RECORD pLicense;
   LPTSTR LicenseServiceStrings = NULL;
   LPTSTR LicenseStrings = NULL;
   TCHAR *pStr;
   LPTSTR PerServerLicenseServiceStrings = NULL;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LicenseListStringsPack\n"));
#endif

   ASSERT(pLicenseServiceStrings != NULL);
   ASSERT(pLicenseServiceStringSize != NULL);

   *pLicenseServiceStrings = NULL;
   *pLicenseServiceStringSize = 0;

   ASSERT(pLicenseStrings != NULL);
   ASSERT(pLicenseStringSize != NULL);

   *pLicenseStrings = NULL;
   *pLicenseStringSize = 0;

   ASSERT(pPerServerLicenseServiceStrings != NULL);
   ASSERT(pPerServerLicenseServiceStringSize != NULL);

   *pPerServerLicenseServiceStrings = NULL;
   *pPerServerLicenseServiceStringSize = 0;

   //////////////////////////////////////////////////////////////////
   //
   // Do License Service Strings
   //

   //
   // First walk the list adding up string sizes - to calculate our buff size
   //
   StringSize = 0;
   for (i = 0; i < LicenseServiceTableSize; i++) {
      pSvc = &LicenseServices[i];

      StringSize = StringSize + lstrlen(pSvc->ServiceName) + 1;
   }

   //
   // Make sure there is anything to replicate
   //
   if (StringSize > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      LicenseServiceStrings = MIDL_user_allocate(StringSize * sizeof(TCHAR));
      if (LicenseServiceStrings == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer
      //
      pStr = LicenseServiceStrings;
      for (i = 0; i < LicenseServiceTableSize; i++) {
         pSvc = &LicenseServices[i];

         lstrcpy(pStr, pSvc->ServiceName);
         pStr = &pStr[lstrlen(pSvc->ServiceName) + 1];
      }
   }

   *pLicenseServiceStrings = LicenseServiceStrings;
   *pLicenseServiceStringSize = StringSize;

   //////////////////////////////////////////////////////////////////
   //
   // Do Per Server License Service Strings
   //

   //
   // First walk the list adding up string sizes - to calculate our buff size
   //
   StringSize = 0;
   for (i = 0; i < PerServerLicenseServiceTableSize; i++) {
      pSvc = &PerServerLicenseServices[i];

      StringSize = StringSize + lstrlen(pSvc->ServiceName) + 1;
   }

   //
   // Make sure there is anything to replicate
   //
   if (StringSize > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      PerServerLicenseServiceStrings = MIDL_user_allocate(StringSize * sizeof(TCHAR));
      if (PerServerLicenseServiceStrings == NULL)
      {
         ASSERT(FALSE);

         //
         // Clean up already alloc'd information
         //
         if (LicenseServiceStrings != NULL)
            MIDL_user_free(LicenseServiceStrings);

         *pLicenseServiceStrings    = NULL;
         *pLicenseServiceStringSize = 0;

         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer
      //
      pStr = PerServerLicenseServiceStrings;
      for (i = 0; i < PerServerLicenseServiceTableSize; i++)
      {
         pSvc = &PerServerLicenseServices[i];

         lstrcpy(pStr, pSvc->ServiceName);
         pStr = &pStr[lstrlen(pSvc->ServiceName) + 1];
      }
   }

   *pPerServerLicenseServiceStrings    = PerServerLicenseServiceStrings;
   *pPerServerLicenseServiceStringSize = StringSize;

   //////////////////////////////////////////////////////////////////
   //
   // Now Do License Purchase Strings
   //

   //
   // First walk the list adding up string sizes - to calculate our buff size
   //
   StringSize = 0;
   for (i = 0; i < LicenseTableSize; i++) {
      pLicense = &Licenses[i];

      StringSize = StringSize + lstrlen(pLicense->Vendor) + 1;
      StringSize = StringSize + lstrlen(pLicense->Admin) + 1;
      StringSize = StringSize + lstrlen(pLicense->Comment) + 1;
      StringSize = StringSize + lstrlen(pLicense->Source) + 1;
   }

   //
   // Make sure there is anything to replicate
   //
   if (StringSize > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      LicenseStrings = MIDL_user_allocate(StringSize * sizeof(TCHAR));
      if (LicenseStrings == NULL) {
         ASSERT(FALSE);

         //
         // Clean up already alloc'd information
         //
         if (LicenseServiceStrings != NULL)
            MIDL_user_free(LicenseServiceStrings);
         if (PerServerLicenseServiceStrings != NULL)
            MIDL_user_free(PerServerLicenseServiceStrings);

         *pLicenseServiceStrings             = NULL;
         *pLicenseServiceStringSize          = 0;
         *pPerServerLicenseServiceStrings    = NULL;
         *pPerServerLicenseServiceStringSize = 0;

         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer
      //
      pStr = LicenseStrings;
      for (i = 0; i < LicenseTableSize; i++) {
         pLicense = &Licenses[i];

         lstrcpy(pStr, pLicense->Vendor);
         pStr = &pStr[lstrlen(pLicense->Vendor) + 1];

         lstrcpy(pStr, pLicense->Admin);
         pStr = &pStr[lstrlen(pLicense->Admin) + 1];

         lstrcpy(pStr, pLicense->Comment);
         pStr = &pStr[lstrlen(pLicense->Comment) + 1];

         lstrcpy(pStr, pLicense->Source);
         pStr = &pStr[lstrlen(pLicense->Source) + 1];
      }
   }

   *pLicenseStrings = LicenseStrings;
   *pLicenseStringSize = StringSize;

   return Status;
} // LicenseListStringsPack


/////////////////////////////////////////////////////////////////////////
VOID
LicenseListStringsUnpack (
   ULONG LicenseServiceTableSize,
   PPACK_LICENSE_SERVICE_RECORD LicenseServices,

   ULONG LicenseServiceStringSize,
   LPTSTR LicenseServiceStrings,

   ULONG LicenseTableSize,
   PPACK_LICENSE_PURCHASE_RECORD Licenses,

   ULONG LicenseStringSize,
   LPTSTR LicenseStrings,

   ULONG PerServerLicenseServiceTableSize,
   PPACK_LICENSE_SERVICE_RECORD PerServerLicenseServices,

   ULONG PerServerLicenseServiceStringSize,
   LPTSTR PerServerLicenseServiceStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   ULONG i;
   PPACK_LICENSE_SERVICE_RECORD pSvc;
   PPACK_LICENSE_PURCHASE_RECORD pLicense;
   TCHAR *pStr;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LicenseListStringsUnpack\n"));
#endif

   //
   // First do per seat license service strings
   //
   pStr = LicenseServiceStrings;
   for (i = 0; i < LicenseServiceTableSize; i++) {
      pSvc = &LicenseServices[i];

      pSvc->ServiceName = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;
   }

   //
   // Then do per server license service strings
   //
   pStr = PerServerLicenseServiceStrings;
   for (i = 0; i < PerServerLicenseServiceTableSize; i++) {
      pSvc = &PerServerLicenseServices[i];

      pSvc->ServiceName = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;
   }

   //
   // Now do license purchase strings
   //
   pStr = LicenseStrings;
   for (i = 0; i < LicenseTableSize; i++) {
      pLicense = &Licenses[i];

      pLicense->Vendor = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;

      pLicense->Admin = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;

      pLicense->Comment = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;

      pLicense->Source = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;
   }

} // LicenseListStringsUnpack


/////////////////////////////////////////////////////////////////////////
VOID
LicenseListLoad()

/*++

Routine Description:

Arguments:

   None.

Return Value:

   None.

--*/

{
   BOOL ret;
   DWORD Version, DataSize;
   NTSTATUS Status = STATUS_SUCCESS;
   HANDLE hFile = NULL;

   ULONG LicenseServiceTableSize;
   PPACK_LICENSE_SERVICE_RECORD LicenseServices = NULL;

   ULONG LicenseServiceStringSize;
   LPTSTR LicenseServiceStrings = NULL;

   ULONG PerServerLicenseServiceTableSize;
   PPACK_LICENSE_SERVICE_RECORD PerServerLicenseServices = NULL;

   ULONG PerServerLicenseServiceStringSize;
   LPTSTR PerServerLicenseServiceStrings = NULL;

   ULONG LicenseTableSize;
   PPACK_LICENSE_PURCHASE_RECORD Licenses = NULL;

   ULONG LicenseStringSize;
   LPTSTR LicenseStrings = NULL;

   LICENSE_FILE_HEADER FileHeader;
   DWORD BytesRead;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: LicenseListLoad\n"));
#endif

   //
   // Check if we already have file open
   //
   if (PurchaseFile != NULL) {
      CloseHandle(PurchaseFile);
      PurchaseFile = NULL;
   }

   //
   // If nothing to load then get-out
   //
   if (!FileExists(LicenseFileName))
      goto LicenseListLoadExit;

   //
   // Check the init header
   //
   Version = DataSize = 0;
   PurchaseFile = LlsFileCheck(LicenseFileName, &Version, &DataSize );
   if (PurchaseFile == NULL) {
      Status = GetLastError();
      goto LicenseListLoadExit;
   }

   if ( ( Version == LICENSE_FILE_VERSION_0 ) && ( DataSize == sizeof(LICENSE_FILE_HEADER_0) ) ) {
      CloseHandle(PurchaseFile);
      PurchaseFile = NULL;

      LicenseListLoadOld();
      return;
   }

   if ( ( Version != LICENSE_FILE_VERSION ) || ( DataSize != sizeof(LICENSE_FILE_HEADER) ) ) {
      Status = STATUS_FILE_INVALID;
      goto LicenseListLoadExit;
   }

   //
   // The init header checks out, so load the license header and data blocks
   //
   hFile = PurchaseFile;
   ret = ReadFile(hFile, &FileHeader, sizeof(LICENSE_FILE_HEADER), &BytesRead, NULL);

   LicenseServiceTableSize = 0;
   LicenseServiceStringSize = 0;
   LicenseTableSize = 0;
   LicenseStringSize = 0;

   if (ret) {
      //
      // Run through and allocate space to read data blocks into
      //
      if (FileHeader.LicenseServiceTableSize != 0) {
         LicenseServiceTableSize = FileHeader.LicenseServiceTableSize / sizeof(PACK_LICENSE_SERVICE_RECORD);
         LicenseServices = MIDL_user_allocate(FileHeader.LicenseServiceTableSize);

         if ( LicenseServices == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LicenseListLoadExit;
         }
      }

      if (FileHeader.LicenseServiceStringSize != 0) {
         LicenseServiceStringSize = FileHeader.LicenseServiceStringSize / sizeof(TCHAR);
         LicenseServiceStrings = MIDL_user_allocate(FileHeader.LicenseServiceStringSize);

         if ( LicenseServiceStrings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LicenseListLoadExit;
         }
      }

      if (FileHeader.LicenseServiceTableSize != 0) {
         PerServerLicenseServiceTableSize = FileHeader.PerServerLicenseServiceTableSize / sizeof(PACK_LICENSE_SERVICE_RECORD);
         PerServerLicenseServices = MIDL_user_allocate(FileHeader.PerServerLicenseServiceTableSize);

         if ( PerServerLicenseServices == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LicenseListLoadExit;
         }
      }

      if (FileHeader.PerServerLicenseServiceStringSize != 0) {
         PerServerLicenseServiceStringSize = FileHeader.PerServerLicenseServiceStringSize / sizeof(TCHAR);
         PerServerLicenseServiceStrings = MIDL_user_allocate(FileHeader.PerServerLicenseServiceStringSize);

         if ( PerServerLicenseServiceStrings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LicenseListLoadExit;
         }
      }

      if (FileHeader.LicenseTableSize != 0) {
         LicenseTableSize = FileHeader.LicenseTableSize / sizeof(PACK_LICENSE_PURCHASE_RECORD);
         Licenses = MIDL_user_allocate(FileHeader.LicenseTableSize);

         if ( Licenses == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LicenseListLoadExit;
         }
      }

      if (FileHeader.LicenseStringSize != 0) {
         LicenseStringSize = FileHeader.LicenseStringSize / sizeof(TCHAR);
         LicenseStrings = MIDL_user_allocate(FileHeader.LicenseStringSize);

         if ( LicenseStrings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LicenseListLoadExit;
         }
      }

   }

   if (ret && (FileHeader.LicenseServiceTableSize != 0) )
      ret = ReadFile(hFile, LicenseServices, FileHeader.LicenseServiceTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.LicenseServiceStringSize != 0) )
      ret = ReadFile(hFile, LicenseServiceStrings, FileHeader.LicenseServiceStringSize, &BytesRead, NULL);

   if (ret && (FileHeader.PerServerLicenseServiceTableSize != 0) )
      ret = ReadFile(hFile, PerServerLicenseServices, FileHeader.PerServerLicenseServiceTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.PerServerLicenseServiceStringSize != 0) )
      ret = ReadFile(hFile, PerServerLicenseServiceStrings, FileHeader.PerServerLicenseServiceStringSize, &BytesRead, NULL);

   if (ret && (FileHeader.LicenseTableSize != 0) )
      ret = ReadFile(hFile, Licenses, FileHeader.LicenseTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.LicenseStringSize != 0) )
      ret = ReadFile(hFile, LicenseStrings, FileHeader.LicenseStringSize, &BytesRead, NULL);

   if (!ret) {
      Status = GetLastError();
      goto LicenseListLoadExit;
   }

   //
   // Decrypt the data
   //
   Status = DeBlock(LicenseServices, FileHeader.LicenseServiceTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(LicenseServiceStrings, FileHeader.LicenseServiceStringSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(PerServerLicenseServices, FileHeader.PerServerLicenseServiceTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(PerServerLicenseServiceStrings, FileHeader.PerServerLicenseServiceStringSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(Licenses, FileHeader.LicenseTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(LicenseStrings, FileHeader.LicenseStringSize);

   if (Status != STATUS_SUCCESS)
      goto LicenseListLoadExit;


   //
   // Unpack the string data
   //
   LicenseListStringsUnpack( LicenseServiceTableSize, LicenseServices,
                             LicenseServiceStringSize, LicenseServiceStrings,
                             LicenseTableSize, Licenses,
                             LicenseStringSize, LicenseStrings,
                             PerServerLicenseServiceTableSize, PerServerLicenseServices,
                             PerServerLicenseServiceStringSize, PerServerLicenseServiceStrings
                             );

   //
   // Unpack the license data
   //
   LicenseListUnpack( LicenseServiceTableSize, LicenseServices, LicenseTableSize, Licenses, PerServerLicenseServiceTableSize, PerServerLicenseServices );

LicenseListLoadExit:

   // Note: Don't close the License Purchase File (keep it locked).

   //
   // Run through our tables and clean them up
   //
   if (LicenseServices != NULL)
      MIDL_user_free(LicenseServices);

   if (LicenseServiceStrings != NULL)
      MIDL_user_free(LicenseServiceStrings);

   if (PerServerLicenseServices != NULL)
      MIDL_user_free(PerServerLicenseServices);

   if (PerServerLicenseServiceStrings != NULL)
      MIDL_user_free(PerServerLicenseServiceStrings);

   if (Licenses != NULL)
      MIDL_user_free(Licenses);

   if (LicenseStrings != NULL)
      MIDL_user_free(LicenseStrings);

   //
   // If there was an error log it.
   //
   if (Status != STATUS_SUCCESS)
      LogEvent(LLS_EVENT_LOAD_LICENSE, 0, NULL, Status);

} // LicenseListLoad


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LicenseListSave()

/*++

Routine Description:

Arguments:

   None.

Return Value:

   None.

--*/

{
   BOOL ret = TRUE;
   NTSTATUS Status = STATUS_SUCCESS;
   HANDLE hFile = NULL;

   ULONG LicenseServiceTableSize;
   PPACK_LICENSE_SERVICE_RECORD LicenseServices = NULL;

   ULONG LicenseServiceStringSize;
   LPTSTR LicenseServiceStrings = NULL;

   ULONG PerServerLicenseServiceTableSize;
   PPACK_LICENSE_SERVICE_RECORD PerServerLicenseServices = NULL;

   ULONG PerServerLicenseServiceStringSize;
   LPTSTR PerServerLicenseServiceStrings = NULL;

   ULONG LicenseTableSize;
   PPACK_LICENSE_PURCHASE_RECORD Licenses = NULL;

   ULONG LicenseStringSize;
   LPTSTR LicenseStrings = NULL;

   LICENSE_FILE_HEADER FileHeader;
   DWORD BytesWritten;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: LicenseListSave\n"));
#endif

   RtlAcquireResourceExclusive(&LicenseListLock, TRUE);

   //
   // Check if we already have file open
   //
   if (PurchaseFile != NULL) {
      CloseHandle(PurchaseFile);
      PurchaseFile = NULL;
   }

   //
   // If nothing to save then get-out
   //
   if ( (LicenseServiceListSize == 0) && (PerServerLicenseServiceListSize == 0) )
      goto LicenseListSaveExit;

   //
   // Pack the license data
   //
   Status = LicenseListPack( &LicenseServiceTableSize, &LicenseServices, &LicenseTableSize, &Licenses, &PerServerLicenseServiceTableSize, &PerServerLicenseServices );
   if (Status != STATUS_SUCCESS)
      goto LicenseListSaveExit;

   //
   // Now pack the String data
   //
   Status = LicenseListStringsPack( LicenseServiceTableSize, LicenseServices,
                                    &LicenseServiceStringSize, &LicenseServiceStrings,
                                    LicenseTableSize, Licenses,
                                    &LicenseStringSize, &LicenseStrings,
                                    PerServerLicenseServiceTableSize, PerServerLicenseServices,
                                    &PerServerLicenseServiceStringSize, &PerServerLicenseServiceStrings );

   if (Status != STATUS_SUCCESS)
      goto LicenseListSaveExit;

   //
   // Fill out the file header - sizes are byte sizes
   //
   FileHeader.LicenseServiceTableSize = LicenseServiceTableSize * sizeof(PACK_LICENSE_SERVICE_RECORD);
   FileHeader.LicenseServiceStringSize = LicenseServiceStringSize * sizeof(TCHAR);
   FileHeader.PerServerLicenseServiceTableSize = PerServerLicenseServiceTableSize * sizeof(PACK_LICENSE_SERVICE_RECORD);
   FileHeader.PerServerLicenseServiceStringSize = PerServerLicenseServiceStringSize * sizeof(TCHAR);
   FileHeader.LicenseTableSize = LicenseTableSize * sizeof(PACK_LICENSE_PURCHASE_RECORD);
   FileHeader.LicenseStringSize = LicenseStringSize * sizeof(TCHAR);

   //
   // Encrypt the data before saving it out.
   //
   Status = EBlock(LicenseServices, FileHeader.LicenseServiceTableSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(LicenseServiceStrings, FileHeader.LicenseServiceStringSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(PerServerLicenseServices, FileHeader.PerServerLicenseServiceTableSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(PerServerLicenseServiceStrings, FileHeader.PerServerLicenseServiceStringSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(Licenses, FileHeader.LicenseTableSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(LicenseStrings, FileHeader.LicenseStringSize);

   if (Status != STATUS_SUCCESS)
      goto LicenseListSaveExit;

   //
   // Save out the header record
   //
   PurchaseFile = LlsFileInit(LicenseFileName, LICENSE_FILE_VERSION, sizeof(LICENSE_FILE_HEADER) );
   if (PurchaseFile == NULL) {
      Status = GetLastError();
      goto LicenseListSaveExit;
   }

   //
   // Now write out all the data blocks
   //
   hFile = PurchaseFile;

   ret = WriteFile(hFile, &FileHeader, sizeof(LICENSE_FILE_HEADER), &BytesWritten, NULL);

   if (ret && (LicenseServices != NULL) && (FileHeader.LicenseServiceTableSize != 0))
      ret = WriteFile(hFile, LicenseServices, FileHeader.LicenseServiceTableSize, &BytesWritten, NULL);

   if (ret && (LicenseServiceStrings != NULL) && (FileHeader.LicenseServiceStringSize != 0))
      ret = WriteFile(hFile, LicenseServiceStrings, FileHeader.LicenseServiceStringSize, &BytesWritten, NULL);

   if (ret && (PerServerLicenseServices != NULL) && (FileHeader.PerServerLicenseServiceTableSize != 0))
      ret = WriteFile(hFile, PerServerLicenseServices, FileHeader.PerServerLicenseServiceTableSize, &BytesWritten, NULL);

   if (ret && (PerServerLicenseServiceStrings != NULL) && (FileHeader.PerServerLicenseServiceStringSize != 0))
      ret = WriteFile(hFile, PerServerLicenseServiceStrings, FileHeader.PerServerLicenseServiceStringSize, &BytesWritten, NULL);

   if (ret && (Licenses != NULL) && (FileHeader.LicenseTableSize != 0))
      ret = WriteFile(hFile, Licenses, FileHeader.LicenseTableSize, &BytesWritten, NULL);

   if (ret && (LicenseStrings != NULL) && (FileHeader.LicenseStringSize != 0))
      ret = WriteFile(hFile, LicenseStrings, FileHeader.LicenseStringSize, &BytesWritten, NULL);

   if (!ret)
      Status = GetLastError();

LicenseListSaveExit:
   RtlReleaseResource(&LicenseListLock);

   // Note: Don't close the License Purchase File (keep it locked).
   if (hFile != NULL)
      FlushFileBuffers(hFile);

   //
   // Run through our tables and clean them up
   //
   if (LicenseServices != NULL)
      MIDL_user_free(LicenseServices);

   if (LicenseServiceStrings != NULL)
      MIDL_user_free(LicenseServiceStrings);

   if (PerServerLicenseServices != NULL)
      MIDL_user_free(PerServerLicenseServices);

   if (PerServerLicenseServiceStrings != NULL)
      MIDL_user_free(PerServerLicenseServiceStrings);

   if (Licenses != NULL)
      MIDL_user_free(Licenses);

   if (LicenseStrings != NULL)
      MIDL_user_free(LicenseStrings);

   //
   // If there was an error log it.
   //
   if (Status != STATUS_SUCCESS)
      LogEvent(LLS_EVENT_SAVE_LICENSE, 0, NULL, Status);

   return Status;
} // LicenseListSave



/////////////////////////////////////////////////////////////////////////
// Mapping List
//

/////////////////////////////////////////////////////////////////////////
NTSTATUS
MappingListPack (
   ULONG *pMappingUserTableSize,
   PPACK_MAPPING_USER_RECORD *pMappingUsers,

   ULONG *pMappingTableSize,
   PPACK_MAPPING_RECORD *pMappings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   PPACK_MAPPING_USER_RECORD MappingUsers = NULL;
   PPACK_MAPPING_RECORD Mappings = NULL;
   ULONG i, j, k;
   ULONG TotalRecords = 0;
   PMAPPING_RECORD pMapping;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: MappingListPack\n"));
#endif

   ASSERT(pMappingUsers != NULL);
   ASSERT(pMappingUserTableSize != NULL);

   *pMappingUsers = NULL;
   *pMappingUserTableSize = 0;

   ASSERT(pMappings != NULL);
   ASSERT(pMappingTableSize != NULL);

   *pMappings = NULL;
   *pMappingTableSize = 0;

   //////////////////////////////////////////////////////////////////
   //
   // Do Mapping User Table First
   //
   TotalRecords = 0;

   //
   // Make sure there is anything to replicate
   //
   for (i = 0; i < MappingListSize; i++)
      TotalRecords += MappingList[i]->NumMembers;

   if (TotalRecords > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      MappingUsers = MIDL_user_allocate(TotalRecords * sizeof(PACK_MAPPING_USER_RECORD));
      if (MappingUsers == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer - walk the Mapping tree
      //
      k = 0;
      for (i = 0; i < MappingListSize; i++) {
         pMapping = MappingList[i];

         for (j = 0; j < pMapping->NumMembers; j++) {
            MappingUsers[k].Mapping = i;
            MappingUsers[k].Name = pMapping->Members[j];
            k++;
         }
      }
   }

   *pMappingUsers = MappingUsers;
   *pMappingUserTableSize = TotalRecords;

   //////////////////////////////////////////////////////////////////
   //
   // Now Do Mapping Records
   //
   TotalRecords = MappingListSize;

   //
   // Make sure there is anything to replicate
   //
   if (TotalRecords > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      Mappings = MIDL_user_allocate(TotalRecords * sizeof(PACK_MAPPING_RECORD));
      if (Mappings == NULL) {
         ASSERT(FALSE);

         //
         // Clean up already alloc'd information
         //
         if (MappingUsers != NULL)
            MIDL_user_free(MappingUsers);

         *pMappingUsers = NULL;
         *pMappingUserTableSize = 0;

         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer - walk the License Purchase tree
      //
      for (i = 0; i < MappingListSize; i++) {
         pMapping = MappingList[i];

         Mappings[i].Name = pMapping->Name;
         Mappings[i].Comment = pMapping->Comment;
         Mappings[i].Licenses = pMapping->Licenses;
      }
   }

   *pMappings = Mappings;
   *pMappingTableSize = TotalRecords;
   return Status;
} // MappingListPack


/////////////////////////////////////////////////////////////////////////
VOID
MappingListUnpack (
   ULONG MappingUserTableSize,
   PPACK_MAPPING_USER_RECORD MappingUsers,

   ULONG MappingTableSize,
   PPACK_MAPPING_RECORD Mappings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status;
   ULONG i;
   PPACK_MAPPING_USER_RECORD pUsr;
   PPACK_MAPPING_RECORD pMapping;
   PMAPPING_RECORD pMap;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("MappingListUnpack: Mappings[%lu] TotalUsers[%lu]\n"), MappingTableSize, MappingUserTableSize);
#endif

   RtlAcquireResourceExclusive(&MappingListLock, TRUE);

   //
   // Add the Mappings first
   //
   for (i = 0; i < MappingTableSize; i++) {
      pMapping = &Mappings[i];

      pMap = MappingListAdd(pMapping->Name, pMapping->Comment, pMapping->Licenses,NULL);

      if (i % 100 == 0) ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);
   }

   //
   // Now add the users to the mappings...
   //
   for (i = 0; i < MappingUserTableSize; i++) {
      pUsr = &MappingUsers[i];

      pMap = NULL;
      if (pUsr->Mapping < MappingTableSize)
         pMap = MappingUserListAdd(Mappings[pUsr->Mapping].Name, pUsr->Name);

#if DBG
      if (pMap == NULL) {
         dprintf(TEXT("pMap: 0x%lX pUsr->Mapping: %lu MappingTableSize: %lu\n"), pMap, pUsr->Mapping, MappingTableSize);
         ASSERT(FALSE);
      }
#endif

      if (i % 100 == 0) ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);
   }

   RtlReleaseResource(&MappingListLock);

} // MappingListUnpack


/////////////////////////////////////////////////////////////////////////
NTSTATUS
MappingListStringsPack (
   ULONG MappingUserTableSize,
   PPACK_MAPPING_USER_RECORD MappingUsers,

   ULONG *pMappingUserStringSize,
   LPTSTR *pMappingUserStrings,

   ULONG MappingTableSize,
   PPACK_MAPPING_RECORD Mappings,

   ULONG *pMappingStringSize,
   LPTSTR *pMappingStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG i;
   ULONG StringSize;
   PPACK_MAPPING_USER_RECORD pUsr;
   PPACK_MAPPING_RECORD pMapping;
   LPTSTR MappingUserStrings = NULL;
   LPTSTR MappingStrings = NULL;
   TCHAR *pStr;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("MappingListStringsPack\n"));
#endif

   ASSERT(pMappingUserStrings != NULL);
   ASSERT(pMappingUserStringSize != NULL);

   *pMappingUserStrings = NULL;
   *pMappingUserStringSize = 0;

   ASSERT(pMappingStrings != NULL);
   ASSERT(pMappingStringSize != NULL);

   *pMappingStrings = NULL;
   *pMappingStringSize = 0;

   //////////////////////////////////////////////////////////////////
   //
   // Do Mapping User Strings
   //

   //
   // First walk the list adding up string sizes - to calculate our buff size
   //
   StringSize = 0;
   for (i = 0; i < MappingUserTableSize; i++) {
      pUsr = &MappingUsers[i];

      StringSize = StringSize + lstrlen(pUsr->Name) + 1;
   }

   //
   // Make sure there is anything to replicate
   //
   if (StringSize > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      MappingUserStrings = MIDL_user_allocate(StringSize * sizeof(TCHAR));
      if (MappingUserStrings == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer
      //
      pStr = MappingUserStrings;
      for (i = 0; i < MappingUserTableSize; i++) {
         pUsr = &MappingUsers[i];

         lstrcpy(pStr, pUsr->Name);
         pStr = &pStr[lstrlen(pUsr->Name) + 1];
      }
   }

   *pMappingUserStrings = MappingUserStrings;
   *pMappingUserStringSize = StringSize;

   //////////////////////////////////////////////////////////////////
   //
   // Now Do Mapping Strings
   //

   //
   // First walk the list adding up string sizes - to calculate our buff size
   //
   StringSize = 0;
   for (i = 0; i < MappingTableSize; i++) {
      pMapping = &Mappings[i];

      StringSize = StringSize + lstrlen(pMapping->Name) + 1;
      StringSize = StringSize + lstrlen(pMapping->Comment) + 1;
   }

   //
   // Make sure there is anything to replicate
   //
   if (StringSize > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      MappingStrings = MIDL_user_allocate(StringSize * sizeof(TCHAR));
      if (MappingStrings == NULL) {
         ASSERT(FALSE);

         //
         // Clean up already alloc'd information
         //
         if (MappingUserStrings != NULL)
            MIDL_user_free(MappingUserStrings);

         *pMappingUserStrings = NULL;
         *pMappingUserStringSize = 0;

         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer
      //
      pStr = MappingStrings;
      for (i = 0; i < MappingTableSize; i++) {
         pMapping = &Mappings[i];

         lstrcpy(pStr, pMapping->Name);
         pStr = &pStr[lstrlen(pMapping->Name) + 1];

         lstrcpy(pStr, pMapping->Comment);
         pStr = &pStr[lstrlen(pMapping->Comment) + 1];
      }
   }

   *pMappingStrings = MappingStrings;
   *pMappingStringSize = StringSize;

   return Status;
} // MappingListStringsPack


/////////////////////////////////////////////////////////////////////////
VOID
MappingListStringsUnpack (
   ULONG MappingUserTableSize,
   PPACK_MAPPING_USER_RECORD MappingUsers,

   ULONG MappingUserStringSize,
   LPTSTR MappingUserStrings,

   ULONG MappingTableSize,
   PPACK_MAPPING_RECORD Mappings,

   ULONG MappingStringSize,
   LPTSTR MappingStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   ULONG i;
   PPACK_MAPPING_USER_RECORD pUsr;
   PPACK_MAPPING_RECORD pMapping;
   TCHAR *pStr;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("MappingListStringsUnpack\n"));
#endif

   //
   // First do license service strings
   //
   pStr = MappingUserStrings;
   for (i = 0; i < MappingUserTableSize; i++) {
      pUsr = &MappingUsers[i];

      pUsr->Name = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;
   }

   //
   // Now do license purchase strings
   //
   pStr = MappingStrings;
   for (i = 0; i < MappingTableSize; i++) {
      pMapping = &Mappings[i];

      pMapping->Name = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;

      pMapping->Comment = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;
   }

} // MappingListStringsUnpack


/////////////////////////////////////////////////////////////////////////
VOID
MappingListLoad()

/*++

Routine Description:

Arguments:

   None.

Return Value:

   None.

--*/

{
   BOOL ret;
   DWORD Version, DataSize;
   NTSTATUS Status = STATUS_SUCCESS;
   HANDLE hFile = NULL;

   ULONG MappingUserTableSize;
   PPACK_MAPPING_USER_RECORD MappingUsers = NULL;

   ULONG MappingUserStringSize;
   LPTSTR MappingUserStrings = NULL;

   ULONG MappingTableSize;
   PPACK_MAPPING_RECORD Mappings = NULL;

   ULONG MappingStringSize;
   LPTSTR MappingStrings = NULL;

   MAPPING_FILE_HEADER FileHeader;
   DWORD BytesRead;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: MappingListLoad\n"));
#endif

   //
   // If nothing to load then get-out
   //
   if (!FileExists(MappingFileName))
      goto MappingListLoadExit;

   //
   // Check the init header
   //
   Version = DataSize = 0;
   hFile = LlsFileCheck(MappingFileName, &Version, &DataSize );
   if (hFile == NULL) {
      Status = GetLastError();
      goto MappingListLoadExit;
   }

   if ((Version != MAPPING_FILE_VERSION) || (DataSize != sizeof(MAPPING_FILE_HEADER))) {
      Status = STATUS_FILE_INVALID;
      goto MappingListLoadExit;
   }

   //
   // The init header checks out, so load the license header and data blocks
   //
   ret = ReadFile(hFile, &FileHeader, sizeof(MAPPING_FILE_HEADER), &BytesRead, NULL);

   MappingUserTableSize = 0;
   MappingUserStringSize = 0;
   MappingTableSize = 0;
   MappingStringSize = 0;

   if (ret) {
      //
      // Run through and allocate space to read data blocks into
      //
      if (FileHeader.MappingUserTableSize != 0) {
         MappingUserTableSize = FileHeader.MappingUserTableSize / sizeof(PACK_MAPPING_USER_RECORD);
         MappingUsers = MIDL_user_allocate(FileHeader.MappingUserTableSize);

         if ( MappingUsers == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto MappingListLoadExit;
         }
      }

      if (FileHeader.MappingUserStringSize != 0) {
         MappingUserStringSize = FileHeader.MappingUserStringSize / sizeof(TCHAR);
         MappingUserStrings = MIDL_user_allocate(FileHeader.MappingUserStringSize);

         if ( MappingUserStrings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto MappingListLoadExit;
         }
      }

      if (FileHeader.MappingTableSize != 0) {
         MappingTableSize = FileHeader.MappingTableSize / sizeof(PACK_MAPPING_RECORD);
         Mappings = MIDL_user_allocate(FileHeader.MappingTableSize);

         if ( Mappings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto MappingListLoadExit;
         }
      }

      if (FileHeader.MappingStringSize != 0) {
         MappingStringSize = FileHeader.MappingStringSize / sizeof(TCHAR);
         MappingStrings = MIDL_user_allocate(FileHeader.MappingStringSize);

         if ( MappingStrings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto MappingListLoadExit;
         }
      }

   }

   if (ret && (FileHeader.MappingUserTableSize != 0) )
      ret = ReadFile(hFile, MappingUsers, FileHeader.MappingUserTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.MappingUserStringSize != 0) )
      ret = ReadFile(hFile, MappingUserStrings, FileHeader.MappingUserStringSize, &BytesRead, NULL);

   if (ret && (FileHeader.MappingTableSize != 0) )
      ret = ReadFile(hFile, Mappings, FileHeader.MappingTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.MappingStringSize != 0) )
      ret = ReadFile(hFile, MappingStrings, FileHeader.MappingStringSize, &BytesRead, NULL);

   if (!ret) {
      Status = GetLastError();
      goto MappingListLoadExit;
   }

   //
   // Decrypt the data
   //
   Status = DeBlock(MappingUsers, FileHeader.MappingUserTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(MappingUserStrings, FileHeader.MappingUserStringSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(Mappings, FileHeader.MappingTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(MappingStrings, FileHeader.MappingStringSize);

   if (Status != STATUS_SUCCESS)
      goto MappingListLoadExit;


   //
   // Unpack the string data
   //
   MappingListStringsUnpack( MappingUserTableSize, MappingUsers,
                             MappingUserStringSize, MappingUserStrings,
                             MappingTableSize, Mappings,
                             MappingStringSize, MappingStrings );

   //
   // Unpack the data
   //
   MappingListUnpack( MappingUserTableSize, MappingUsers, MappingTableSize, Mappings );

MappingListLoadExit:

   if (hFile != NULL)
      CloseHandle(hFile);

   //
   // Run through our tables and clean them up
   //
   if (MappingUsers != NULL)
      MIDL_user_free(MappingUsers);

   if (MappingUserStrings != NULL)
      MIDL_user_free(MappingUserStrings);

   if (Mappings != NULL)
      MIDL_user_free(Mappings);

   if (MappingStrings != NULL)
      MIDL_user_free(MappingStrings);

   //
   // If there was an error log it.
   //
   if (Status != STATUS_SUCCESS)
      LogEvent(LLS_EVENT_LOAD_MAPPING, 0, NULL, Status);

} // MappingListLoad


/////////////////////////////////////////////////////////////////////////
NTSTATUS
MappingListSave()

/*++

Routine Description:

Arguments:

   None.

Return Value:

   None.

--*/

{
   BOOL ret = TRUE;
   NTSTATUS Status = STATUS_SUCCESS;
   HANDLE hFile = NULL;

   ULONG MappingUserTableSize;
   PPACK_MAPPING_USER_RECORD MappingUsers = NULL;

   ULONG MappingUserStringSize;
   LPTSTR MappingUserStrings = NULL;

   ULONG MappingTableSize;
   PPACK_MAPPING_RECORD Mappings = NULL;

   ULONG MappingStringSize;
   LPTSTR MappingStrings = NULL;

   MAPPING_FILE_HEADER FileHeader;
   DWORD BytesWritten;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: MappingListSave\n"));
#endif

   RtlAcquireResourceExclusive(&MappingListLock, TRUE);

   //
   // If nothing to save then get-out
   //
   if (MappingListSize == 0)
      goto MappingListSaveExit;

   //
   // Pack the data
   //
   Status = MappingListPack( &MappingUserTableSize, &MappingUsers, &MappingTableSize, &Mappings );
   if (Status != STATUS_SUCCESS)
      goto MappingListSaveExit;

   //
   // Now pack the String data
   //
   Status = MappingListStringsPack( MappingUserTableSize, MappingUsers,
                                    &MappingUserStringSize, &MappingUserStrings,
                                    MappingTableSize, Mappings,
                                    &MappingStringSize, &MappingStrings );

   if (Status != STATUS_SUCCESS)
      goto MappingListSaveExit;

   //
   // Fill out the file header - sizes are byte sizes
   //
   FileHeader.MappingUserTableSize = MappingUserTableSize * sizeof(PACK_MAPPING_USER_RECORD);
   FileHeader.MappingUserStringSize = MappingUserStringSize * sizeof(TCHAR);
   FileHeader.MappingTableSize = MappingTableSize * sizeof(PACK_MAPPING_RECORD);
   FileHeader.MappingStringSize = MappingStringSize * sizeof(TCHAR);

   //
   // Encrypt the data before saving it out.
   //
   Status = EBlock(MappingUsers, FileHeader.MappingUserTableSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(MappingUserStrings, FileHeader.MappingUserStringSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(Mappings, FileHeader.MappingTableSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(MappingStrings, FileHeader.MappingStringSize);

   if (Status != STATUS_SUCCESS)
      goto MappingListSaveExit;

   //
   // Save out the header record
   //
   hFile = LlsFileInit(MappingFileName, MAPPING_FILE_VERSION, sizeof(MAPPING_FILE_HEADER) );
   if (hFile == NULL) {
      Status = GetLastError();
      goto MappingListSaveExit;
   }

   //
   // Now write out all the data blocks
   //
   ret = WriteFile(hFile, &FileHeader, sizeof(MAPPING_FILE_HEADER), &BytesWritten, NULL);

   if (ret && (MappingUsers != NULL) && (FileHeader.MappingUserTableSize != 0))
      ret = WriteFile(hFile, MappingUsers, FileHeader.MappingUserTableSize, &BytesWritten, NULL);

   if (ret && (MappingUserStrings != NULL) && (FileHeader.MappingUserStringSize != 0))
      ret = WriteFile(hFile, MappingUserStrings, FileHeader.MappingUserStringSize, &BytesWritten, NULL);

   if (ret && (Mappings != NULL) && (FileHeader.MappingTableSize != 0))
      ret = WriteFile(hFile, Mappings, FileHeader.MappingTableSize, &BytesWritten, NULL);

   if (ret && (MappingStrings != NULL) && (FileHeader.MappingStringSize != 0))
      ret = WriteFile(hFile, MappingStrings, FileHeader.MappingStringSize, &BytesWritten, NULL);

   if (!ret)
      Status = GetLastError();

MappingListSaveExit:
   RtlReleaseResource(&MappingListLock);

   if (hFile != NULL)
      CloseHandle(hFile);

   //
   // Run through our tables and clean them up
   //
   if (MappingUsers != NULL)
      MIDL_user_free(MappingUsers);

   if (MappingUserStrings != NULL)
      MIDL_user_free(MappingUserStrings);

   if (Mappings != NULL)
      MIDL_user_free(Mappings);

   if (MappingStrings != NULL)
      MIDL_user_free(MappingStrings);

   //
   // If there was an error log it.
   //
   if (Status != STATUS_SUCCESS)
      LogEvent(LLS_EVENT_SAVE_MAPPING, 0, NULL, Status);

   return Status;
} // MappingListSave



/////////////////////////////////////////////////////////////////////////
// User List
//

/////////////////////////////////////////////////////////////////////////
NTSTATUS
UserListPack (
   DWORD LastReplicated,
   ULONG UserLevel,
   ULONG *pUserTableSize,
   LPVOID *pUsers
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   LPVOID Users = NULL;
   ULONG i, j, k;
   ULONG TotalRecords = 0;
   PUSER_RECORD pUser;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: UserListPack\n"));
#endif

   ASSERT(pUsers != NULL);
   ASSERT(pUserTableSize != NULL);

   *pUsers = NULL;
   *pUserTableSize = 0;

   //
   // Now walk our tree and figure out how many records we must send.
   //
   i = 0;
   TotalRecords = 0;
   while (i < UserListNumEntries) {
      pUser = LLSGetElementGenericTable(&UserList, i);

      if (pUser != NULL) {
         //
         // Walk each service under each user
         //
         RtlEnterCriticalSection(&pUser->ServiceTableLock);

         for (j = 0; j < pUser->ServiceTableSize; j++)
            if ( (pUser->Services[j].AccessCount > 0) || (pUser->Services[j].LastAccess > LastReplicated) )
               TotalRecords++;

         RtlLeaveCriticalSection(&pUser->ServiceTableLock);
      }

      i++;
   }

#if DBG
   if (TraceFlags & TRACE_REPLICATION)
      dprintf(TEXT("   LLS Packing %lu User Records\n"), TotalRecords);
#endif

   //
   // Make sure there is anything to replicate
   //
   if (TotalRecords > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      Users = MIDL_user_allocate(TotalRecords * ( UserLevel ? sizeof(REPL_USER_RECORD_1)
                                                            : sizeof(REPL_USER_RECORD_0) ) );
      if (Users == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer - walk the user tree
      //
      i = 0;
      j = 0;
      while ((i < UserListNumEntries) && (j < TotalRecords)) {
         pUser = LLSGetElementGenericTable(&UserList, i);

         if (pUser != NULL) {
            //
            // Walk each service under each user
            //
            k = 0;
            RtlEnterCriticalSection(&pUser->ServiceTableLock);
            while (k < pUser->ServiceTableSize) {
               if ( (pUser->Services[k].AccessCount > 0) || (pUser->Services[k].LastAccess > LastReplicated) ) {
                  if ( 0 == UserLevel )
                  {
                     ((PREPL_USER_RECORD_0)Users)[j].Name        = pUser->UserID;
                     ((PREPL_USER_RECORD_0)Users)[j].Service     = pUser->Services[k].Service->Index;
                     ((PREPL_USER_RECORD_0)Users)[j].AccessCount = pUser->Services[k].AccessCount;
                     ((PREPL_USER_RECORD_0)Users)[j].LastAccess  = pUser->Services[k].LastAccess;
                  }
                  else
                  {
                     ((PREPL_USER_RECORD_1)Users)[j].Name        = pUser->UserID;
                     ((PREPL_USER_RECORD_1)Users)[j].Service     = pUser->Services[k].Service->Index;
                     ((PREPL_USER_RECORD_1)Users)[j].AccessCount = pUser->Services[k].AccessCount;
                     ((PREPL_USER_RECORD_1)Users)[j].LastAccess  = pUser->Services[k].LastAccess;
                     ((PREPL_USER_RECORD_1)Users)[j].Flags       = pUser->Flags;
                  }

                  //
                  // Reset access count so we don't increment forever
                  //
                  if (LastReplicated != 0)
                     pUser->Services[k].AccessCount = 0;

                  j++;
               }

               k++;
            }
            RtlLeaveCriticalSection(&pUser->ServiceTableLock);
         }

         i++;
      }
   } // User Records

#if DBG
   if (TraceFlags & TRACE_REPLICATION)
      dprintf(TEXT("UserListPack: [%lu]\n"), TotalRecords);
#endif
   *pUsers = Users;
   *pUserTableSize = TotalRecords;
   return Status;
} // UserListPack


/////////////////////////////////////////////////////////////////////////
VOID
UserListUnpack (
   ULONG ServiceTableSize,
   PREPL_SERVICE_RECORD Services,

   ULONG ServerTableSize,
   PREPL_SERVER_RECORD Servers,

   ULONG ServerServiceTableSize,
   PREPL_SERVER_SERVICE_RECORD ServerServices,

   ULONG UserLevel,
   ULONG UserTableSize,
   LPVOID Users
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG i;
   PUSER_RECORD pUser;
   PREPL_USER_RECORD_0 pReplUser0 = NULL;
   PREPL_USER_RECORD_1 pReplUser1 = NULL;
   PADD_CACHE pAdd = NULL;
   PADD_CACHE tAdd = NULL;
   PADD_CACHE lAdd = NULL;
   ULONG CacheSize = 0;
   ULONG DataLength;
   LPTSTR NewName;

#if DBG
   if (TraceFlags & (TRACE_REPLICATION | TRACE_FUNCTION_TRACE))
      dprintf(TEXT("UserListUnpack: [%lu]\n"), UserTableSize);
#endif
   //
   // Walk User table.  First fixup service pointers to our local service
   // table.  Next create a big add cache list to dump onto our add-cache
   // queue.
   //
   for (i = 0; i < UserTableSize; i++) {
      //
      // Update Index
      //
      if ( 0 == UserLevel )
      {
         pReplUser0 = &( (PREPL_USER_RECORD_0) Users)[i];
         pReplUser0->Service = Services[pReplUser0->Service].Index;

         //
         // Validate the user name.
         //
         // NB : Strange this code is necessary, but occasionally the names
         //      received via replication are invalid. Maintain this code
         //      for safety until the original problem is completely fixed.
         //

         if (!ValidateDN(pReplUser0->Name))
         {
            //
            // TBD : Log event noting rejected name.
            //
#if DBG
            dprintf(TEXT("LS: Rejecting invalid user name = \"%s\"\n"),
                    pReplUser0->Name);
#endif
            continue;
         }
      }
      else
      {
         pReplUser1 = &( (PREPL_USER_RECORD_1) Users)[i];
         pReplUser1->Service = Services[pReplUser1->Service].Index;

         //
         // Validate the user name.
         //
         // NB : Strange this code is necessary, but occasionally the names
         //      received via replication are invalid. Maintain this code
         //      for safety until the original problem is completely fixed.
         //

         if (!ValidateDN(pReplUser1->Name))
         {
            //
            // TBD : Log event noting rejected name.
            //
#if DBG
            dprintf(TEXT("LS: Rejecting invalid user name = \"%s\"\n"),
                    pReplUser1->Name);
#endif
            continue;
         }
      }

      //
      // Now create Add Cache object
      //
      tAdd = LocalAlloc(LPTR, sizeof(ADD_CACHE));
      if (tAdd != NULL) {
         if ( 0 == UserLevel )
         {
            DataLength = (lstrlen(pReplUser0->Name) + 1) * sizeof(TCHAR);
         }
         else
         {
            DataLength = (lstrlen(pReplUser1->Name) + 1) * sizeof(TCHAR);
         }

         NewName = LocalAlloc( LPTR, DataLength);

         if (NewName == NULL) {
            LocalFree(tAdd);
            ASSERT(FALSE);
         } else {
            tAdd->Data       = NewName;
            tAdd->DataType   = DATA_TYPE_USERNAME;
            tAdd->DataLength = DataLength;

            if ( 0 == UserLevel )
            {
               lstrcpy( NewName,   pReplUser0->Name );
               tAdd->AccessCount = pReplUser0->AccessCount;
               tAdd->LastAccess  = pReplUser0->LastAccess;
               tAdd->Flags       = LLS_FLAG_SUITE_AUTO;

               RtlAcquireResourceShared(&MasterServiceListLock, TRUE);
               tAdd->Service = MasterServiceTable[pReplUser0->Service];
               RtlReleaseResource(&MasterServiceListLock);
            }
            else
            {
               lstrcpy( NewName,   pReplUser1->Name );
               tAdd->AccessCount = pReplUser1->AccessCount;
               tAdd->LastAccess  = pReplUser1->LastAccess;
               tAdd->Flags       = pReplUser1->Flags & ( LLS_FLAG_SUITE_USE | LLS_FLAG_SUITE_AUTO );

               RtlAcquireResourceShared(&MasterServiceListLock, TRUE);
               tAdd->Service = MasterServiceTable[pReplUser1->Service];
               RtlReleaseResource(&MasterServiceListLock);
            }

            //
            // Now add it to our cache
            //
            tAdd->prev = pAdd;
            pAdd = tAdd;

            //
            // Keep track of first on (bottom on stack) so we can append
            // it onto the real add cache.
            //
            if (lAdd == NULL)
               lAdd = pAdd;

            CacheSize++;
         }
      } else {
         ASSERT(FALSE);
      }

      if (i % 100 == 0) ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);
   }

   //
   // Now that we've walked through all the users - update the actual
   // Add Cache.
   //
   if (pAdd != NULL) {
      RtlEnterCriticalSection(&AddCacheLock);
      lAdd->prev = AddCache;
      AddCache = pAdd;
      AddCacheSize += CacheSize;
      RtlLeaveCriticalSection(&AddCacheLock);

      //
      // Now must signal the event so we can pull off the new record.
      //
      Status = NtSetEvent( LLSAddCacheEvent, NULL );
      ASSERT(NT_SUCCESS(Status));

   }

} // UserListUnpack


//
// Illegal user/domain characters.
//

#define CTRL_CHARS_0   TEXT(    "\001\002\003\004\005\006\007")
#define CTRL_CHARS_1   TEXT("\010\011\012\013\014\015\016\017")
#define CTRL_CHARS_2   TEXT("\020\021\022\023\024\025\026\027")
#define CTRL_CHARS_3   TEXT("\030\031\032\033\034\035\036\037")

#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

#define ILLEGAL_NAME_CHARS_STR  TEXT("\"/\\[]:|<>+=;,?") CTRL_CHARS_STR

static const TCHAR szUserIllegalChars[]   = ILLEGAL_NAME_CHARS_STR TEXT("*");
static const TCHAR szDomainIllegalChars[] = ILLEGAL_NAME_CHARS_STR TEXT("*") TEXT(" ");

/////////////////////////////////////////////////////////////////////////
BOOL
ValidateDN (
    LPTSTR pszDN
    )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   //
   // NB : This code understands only NT4 usernames at present.
   //

   TCHAR  szDN[MAX_USERNAME_LENGTH + MAX_DOMAINNAME_LENGTH + 2];
   LPTSTR pszUserName;
   LPTSTR pszDomainName;
   LPTSTR pszBSlash;
   SIZE_T  ccUserNameLength;
   SIZE_T  ccDomainNameLength;

   if (pszDN == NULL || !*pszDN) {
      return FALSE;
   }

   //
   // Use a local buffer for character replacement during check.
   //

   if (lstrlen(pszDN) < (MAX_USERNAME_LENGTH + MAX_DOMAINNAME_LENGTH + 2)) {
      lstrcpyn(szDN, pszDN, MAX_USERNAME_LENGTH + MAX_DOMAINNAME_LENGTH + 2);
   }
   else {
      return FALSE;
   }

   pszBSlash = STRRCHR(szDN, TEXT('\\'));

   if (pszBSlash == NULL) {
      return FALSE;
   }

   //
   // Isolate user/domain names.
   //

   *pszBSlash    = TEXT('\0');

   pszUserName   = pszBSlash + 1;
   pszDomainName = szDN;

   ccUserNameLength   = lstrlen(pszUserName);
   ccDomainNameLength = pszBSlash - pszDomainName;

   //
   // Check user/domain name length and the existence of invalid chars.
   //

   if (ccUserNameLength && ccUserNameLength <= MAX_USERNAME_LENGTH) {
      if (STRCSPN(pszUserName, szUserIllegalChars) == ccUserNameLength) {
         if (ccDomainNameLength <= MAX_DOMAINNAME_LENGTH) {
            if (STRCSPN(pszDomainName,
                        szDomainIllegalChars) == ccDomainNameLength) {
                return TRUE;
            }
         }
      }
   }

   return FALSE;
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS
UserListStringsPack (
   ULONG UserLevel,

   ULONG UserTableSize,
   LPVOID Users,

   ULONG *pUserStringSize,
   LPTSTR *pUserStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG i;
   ULONG StringSize;
   LPTSTR UserStrings = NULL;
   TCHAR *pStr;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("UserListStringsPack\n"));
#endif

   ASSERT(pUserStrings != NULL);
   ASSERT(pUserStringSize != NULL);

   *pUserStrings = NULL;
   *pUserStringSize = 0;

   //
   // First walk the list adding up string sizes - to calculate our buff size
   //
   StringSize = 0;
   for (i = 0; i < UserTableSize; i++) {
      if ( 0 == UserLevel )
      {
         StringSize += 1 + lstrlen( ((PREPL_USER_RECORD_0) Users)[i].Name );
      }
      else
      {
         StringSize += 1 + lstrlen( ((PREPL_USER_RECORD_1) Users)[i].Name );
      }
   }

   //
   // Make sure there is anything to replicate
   //
   if (StringSize > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      UserStrings = MIDL_user_allocate(StringSize * sizeof(TCHAR));
      if (UserStrings == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer
      //
      pStr = UserStrings;
      for (i = 0; i < UserTableSize; i++) {
         if ( 0 == UserLevel )
         {
            lstrcpy( pStr, ((PREPL_USER_RECORD_0) Users)[i].Name );
         }
         else
         {
            lstrcpy( pStr, ((PREPL_USER_RECORD_1) Users)[i].Name );
         }

         pStr += 1 + lstrlen( pStr );
      }
   }

   *pUserStrings = UserStrings;
   *pUserStringSize = StringSize;

   return Status;
} // UserListStringsPack


/////////////////////////////////////////////////////////////////////////
VOID
UserListStringsUnpack (
   ULONG UserLevel,

   ULONG UserTableSize,
   LPVOID Users,

   ULONG UserStringSize,
   LPTSTR UserStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   ULONG i;
   TCHAR *pStr;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("UserListStringsUnpack\n"));
#endif

   pStr = UserStrings;
   for (i = 0; i < UserTableSize; i++) {
      if ( 0 == UserLevel )
      {
         ((PREPL_USER_RECORD_0) Users)[i].Name = pStr;
      }
      else
      {
         ((PREPL_USER_RECORD_1) Users)[i].Name = pStr;
      }

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;
   }

} // UserListStringsUnpack



/////////////////////////////////////////////////////////////////////////
// Service List
//

/////////////////////////////////////////////////////////////////////////
NTSTATUS
ServiceListPack (
   ULONG *pServiceTableSize,
   PREPL_SERVICE_RECORD *pServices
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   PREPL_SERVICE_RECORD Services = NULL;
   ULONG i;
   ULONG TotalRecords = 0;
   PMASTER_SERVICE_RECORD pService;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServiceListPack\n"));
#endif

   ASSERT(pServices != NULL);
   ASSERT(pServiceTableSize != NULL);
   *pServices = NULL;
   *pServiceTableSize = 0;

   TotalRecords = MasterServiceListSize;

   //
   // Make sure there is anything to replicate
   //
   if (TotalRecords > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      Services = MIDL_user_allocate(TotalRecords * sizeof(REPL_SERVICE_RECORD));
      if (Services == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer - walk the user tree
      //
      for (i = 0; i < MasterServiceListSize; i++) {
         pService = MasterServiceTable[i];

         Services[i].Name = pService->Name;
         Services[i].FamilyName = pService->Family->Name;
         Services[i].Version = pService->Version;
         Services[i].Index = pService->Index;
      }
   }

#if DBG
   if (TraceFlags & TRACE_REPLICATION)
      dprintf(TEXT("ServiceListPack: [%lu]\n"), TotalRecords);
#endif
   *pServices = Services;
   *pServiceTableSize = TotalRecords;
   return Status;
} // ServiceListPack


/////////////////////////////////////////////////////////////////////////
VOID
ServiceListUnpack (
   ULONG ServiceTableSize,
   PREPL_SERVICE_RECORD Services,

   ULONG ServerTableSize,
   PREPL_SERVER_RECORD Servers,

   ULONG ServerServiceTableSize,
   PREPL_SERVER_SERVICE_RECORD ServerServices
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   ULONG i, j;
   PMASTER_SERVICE_RECORD pService;
   PREPL_SERVICE_RECORD pSvc;

#if DBG
   if (TraceFlags & (TRACE_REPLICATION | TRACE_FUNCTION_TRACE))
      dprintf(TEXT("ServiceListUnpack: [%lu]\n"), ServiceTableSize);
#endif
   //
   // Walk services table, adding any new services to our local table.
   // Fix up the index pointers to match our local services.
   //
   RtlAcquireResourceExclusive(&MasterServiceListLock, TRUE);

   for (i = 0; i < ServiceTableSize; i++) {
      pSvc = &Services[i];
      pService = MasterServiceListAdd(pSvc->FamilyName, pSvc->Name, pSvc->Version );

      if (pService != NULL) {
         pSvc->Index = pService->Index;

         //
         // In case this got added from the local service list table and we
         // didn't have a version # yet.
         //
         if ( (pService->Version == 0) && (pSvc->Version != 0) ) {
            PMASTER_SERVICE_ROOT ServiceRoot = NULL;

            //
            // Fixup next pointer chain
            //
            ServiceRoot = pService->Family;
            j = 0;
            while ((j < ServiceRoot->ServiceTableSize) && (MasterServiceTable[ServiceRoot->Services[j]]->Version < pSvc->Version))
               j++;

            pService->next = 0;
            pService->Version = pSvc->Version;
            if (j > 0) {
               if (MasterServiceTable[ServiceRoot->Services[j - 1]]->next == pService->Index + 1)
                  pService->next = 0;
               else
                  pService->next = MasterServiceTable[ServiceRoot->Services[j - 1]]->next;

               if (MasterServiceTable[ServiceRoot->Services[j - 1]] != pService)
                  MasterServiceTable[ServiceRoot->Services[j - 1]]->next = pService->Index + 1;

            }

            // Resort it in order of the versions
            qsort((void *) ServiceRoot->Services, (size_t) ServiceRoot->ServiceTableSize, sizeof(ULONG), MServiceRecordCompare);
         }

      } else {
         ASSERT(FALSE);
         pSvc->Index = 0;
      }

      if (i % 100 == 0) ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);
   }

   RtlReleaseResource(&MasterServiceListLock);

} // ServiceListUnpack


/////////////////////////////////////////////////////////////////////////
NTSTATUS
ServiceListStringsPack (
   ULONG ServiceTableSize,
   PREPL_SERVICE_RECORD Services,

   ULONG *pServiceStringSize,
   LPTSTR *pServiceStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG i;
   ULONG StringSize;
   PREPL_SERVICE_RECORD pService;
   LPTSTR ServiceStrings = NULL;
   TCHAR *pStr;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("ServiceListStringsPack\n"));
#endif

   ASSERT(pServiceStrings != NULL);
   ASSERT(pServiceStringSize != NULL);

   *pServiceStrings = NULL;
   *pServiceStringSize = 0;

   //
   // First walk the list adding up string sizes - to calculate our buff size
   //
   StringSize = 0;
   for (i = 0; i < ServiceTableSize; i++) {
      pService = &Services[i];

      StringSize = StringSize + lstrlen(pService->Name) + 1;
      StringSize = StringSize + lstrlen(pService->FamilyName) + 1;
   }

   //
   // Make sure there is anything to replicate
   //
   if (StringSize > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      ServiceStrings = MIDL_user_allocate(StringSize * sizeof(TCHAR));
      if (ServiceStrings == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer
      //
      pStr = ServiceStrings;
      for (i = 0; i < ServiceTableSize; i++) {
         pService = &Services[i];

         lstrcpy(pStr, pService->Name);
         pStr = &pStr[lstrlen(pService->Name) + 1];

         lstrcpy(pStr, pService->FamilyName);
         pStr = &pStr[lstrlen(pService->FamilyName) + 1];
      }
   }

   *pServiceStrings = ServiceStrings;
   *pServiceStringSize = StringSize;

   return Status;
} // ServiceListStringsPack


/////////////////////////////////////////////////////////////////////////
VOID
ServiceListStringsUnpack (
   ULONG ServiceTableSize,
   PREPL_SERVICE_RECORD Services,

   ULONG ServiceStringSize,
   LPTSTR ServiceStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   ULONG i;
   PREPL_SERVICE_RECORD pService;
   TCHAR *pStr;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("ServiceListStringsUnpack\n"));
#endif

   pStr = ServiceStrings;
   for (i = 0; i < ServiceTableSize; i++) {
      pService = &Services[i];

      pService->Name = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;

      pService->FamilyName = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;
   }

} // ServiceListStringsUnpack



/////////////////////////////////////////////////////////////////////////
// Server List
//

/////////////////////////////////////////////////////////////////////////
NTSTATUS
ServerListPack (
   ULONG *pServerTableSize,
   PREPL_SERVER_RECORD *pServers
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   PREPL_SERVER_RECORD Servers = NULL;
   ULONG i;
   ULONG TotalRecords = 0;
   PSERVER_RECORD pServer;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServerListPack\n"));
#endif

   ASSERT(pServers != NULL);
   ASSERT(pServerTableSize != NULL);

   *pServers = NULL;
   *pServerTableSize = 0;

   TotalRecords = ServerListSize;

   //
   // Make sure there is anything to replicate
   //
   if (TotalRecords > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      Servers = MIDL_user_allocate(TotalRecords * sizeof(REPL_SERVER_RECORD));
      if (Servers == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer - walk the user tree
      //
      for (i = 0; i < ServerListSize; i++) {
         pServer = ServerTable[i];

         Servers[i].Name = pServer->Name;
         Servers[i].MasterServer = pServer->MasterServer;
         Servers[i].Index = pServer->Index;
      }
   }

#if DBG
   if (TraceFlags & TRACE_REPLICATION)
      dprintf(TEXT("ServerListPack: [%lu]\n"), TotalRecords);
#endif
   *pServers = Servers;;
   *pServerTableSize = TotalRecords;
   return Status;
} // ServerListPack


/////////////////////////////////////////////////////////////////////////
VOID
ServerListUnpack (
   ULONG ServiceTableSize,
   PREPL_SERVICE_RECORD Services,

   ULONG ServerTableSize,
   PREPL_SERVER_RECORD Servers,

   ULONG ServerServiceTableSize,
   PREPL_SERVER_SERVICE_RECORD ServerServices
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   ULONG i;
   PSERVER_RECORD pServer;
   PREPL_SERVER_RECORD pSrv;
   TCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];

#if DBG
   if (TraceFlags & (TRACE_REPLICATION | TRACE_FUNCTION_TRACE))
      dprintf(TEXT("ServerListUnpack: [%lu]\n"), ServerTableSize);
#endif

   ComputerName[0] = 0;

   //
   // Walk server table, adding any new servers to our local table.
   // Fix up the index pointers to match our local table and re-fix
   // Service table pointers.
   //
   RtlEnterCriticalSection(&ConfigInfoLock);

   if (ConfigInfo.ComputerName != NULL)
       lstrcpy(ComputerName, ConfigInfo.ComputerName);

   RtlLeaveCriticalSection(&ConfigInfoLock);

   RtlAcquireResourceExclusive(&ServerListLock, TRUE);

   for (i = 0; i < ServerTableSize; i++) {
      pSrv = &Servers[i];

      if (pSrv->MasterServer != 0)
         pServer = ServerListAdd(pSrv->Name, Servers[pSrv->MasterServer - 1].Name);
      else
         pServer = ServerListAdd(pSrv->Name, ComputerName);

      if (pServer != NULL)
         pSrv->Index = pServer->Index;
      else {
         ASSERT(FALSE);
         pSrv->Index = 0;
      }

      if (i % 100 == 0) ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);
   }

   RtlReleaseResource(&ServerListLock);

} // ServerListUnpack


/////////////////////////////////////////////////////////////////////////
NTSTATUS
ServerServiceListPack (
   ULONG *pServerServiceTableSize,
   PREPL_SERVER_SERVICE_RECORD *pServerServices
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   PREPL_SERVER_SERVICE_RECORD ServerServices = NULL;
   ULONG i, j, k;
   ULONG TotalRecords = 0;
   PSERVER_RECORD pServer;
   PSERVER_SERVICE_RECORD pServerService;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServerServiceListPack\n"));
#endif

   ASSERT(pServerServices != NULL);
   ASSERT(pServerServiceTableSize != NULL);

   *pServerServices = NULL;
   *pServerServiceTableSize = 0;

   //
   // Walk the ServerList and find all ServiceRecords
   for (i = 0; i < ServerListSize; i++)
      TotalRecords += ServerTable[i]->ServiceTableSize;

   //
   // Make sure there is anything to replicate
   //
   if (TotalRecords > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      ServerServices = MIDL_user_allocate(TotalRecords * sizeof(REPL_SERVER_SERVICE_RECORD));
      if (ServerServices == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer - walk the user tree
      //
      k = 0;
      for (i = 0; i < ServerListSize; i++) {
         pServer = ServerTable[i];

         for (j = 0; j < pServer->ServiceTableSize; j++) {
            ServerServices[k].Server = pServer->Index;
            ServerServices[k].Service = pServer->Services[j]->Service;
            ServerServices[k].MaxSessionCount = pServer->Services[j]->MaxSessionCount;
            ServerServices[k].MaxSetSessionCount = pServer->Services[j]->MaxSetSessionCount;
            ServerServices[k].HighMark = pServer->Services[j]->HighMark;
            k++;
         }
      }
   }

#if DBG
   if (TraceFlags & TRACE_REPLICATION)
      dprintf(TEXT("ServerServiceListPack: [%lu]\n"), TotalRecords);
#endif
   *pServerServices = ServerServices;
   *pServerServiceTableSize = TotalRecords;
   return Status;
} // ServerServiceListPack


/////////////////////////////////////////////////////////////////////////
VOID
ServerServiceListUnpack (
   ULONG ServiceTableSize,
   PREPL_SERVICE_RECORD Services,

   ULONG ServerTableSize,
   PREPL_SERVER_RECORD Servers,

   ULONG ServerServiceTableSize,
   PREPL_SERVER_SERVICE_RECORD ServerServices
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   ULONG i;
   PSERVER_RECORD pServer;
   PREPL_SERVER_SERVICE_RECORD pSrv;
   PSERVER_SERVICE_RECORD pService;
   PMASTER_SERVICE_RECORD pMasterService;

#if DBG
   if (TraceFlags & (TRACE_REPLICATION | TRACE_FUNCTION_TRACE))
      dprintf(TEXT("ServerServiceListUnpack: [%lu]\n"), ServerServiceTableSize);
#endif
   //
   // Walk server table, adding any new servers to our local table.
   // Fix up the index pointers to match our local table and re-fix
   // Service table pointers.
   //

   RtlAcquireResourceExclusive(&ServerListLock, TRUE);
   RtlAcquireResourceShared(&MasterServiceListLock, TRUE);

   for (i = 0; i < ServerServiceTableSize; i++) {
      pSrv = &ServerServices[i];
      pServer = ServerListFind(Servers[pSrv->Server - 1].Name);
      ASSERT(pServer != NULL);

      if (pServer != NULL) {
         BOOL bReplaceValues;

         pService = ServerServiceListFind(Services[pSrv->Service].Name, pServer->ServiceTableSize, pServer->Services);
         bReplaceValues = ( NULL != pService );

         pService = ServerServiceListAdd(Services[pSrv->Service].Name,
                       Services[pSrv->Service].Index,
                       &pServer->ServiceTableSize,
                       &pServer->Services);

         ASSERT(pService != NULL);

         if (pService != NULL)
         {
             //
             // Remove any old info
             //
             pMasterService = MasterServiceTable[Services[pSrv->Service].Index];
             if ( bReplaceValues )
             {
                 pMasterService->MaxSessionCount -= pService->MaxSessionCount;
                 pMasterService->HighMark -= pService->HighMark;
             }

             //
             // Now update new info
             //
             pService->MaxSessionCount = pSrv->MaxSessionCount;
             pService->HighMark = pSrv->HighMark;
             pMasterService->MaxSessionCount += pService->MaxSessionCount;
             pMasterService->HighMark += pService->HighMark;
         }
      }

      if (i % 100 == 0) ReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, NSERVICEWAITHINT);
   }

   RtlReleaseResource(&MasterServiceListLock);
   RtlReleaseResource(&ServerListLock);

} // ServerServiceListUnpack


/////////////////////////////////////////////////////////////////////////
NTSTATUS
ServerListStringsPack (
   ULONG ServerTableSize,
   PREPL_SERVER_RECORD Servers,

   ULONG *pServerStringSize,
   LPTSTR *pServerStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG i;
   ULONG StringSize;
   PREPL_SERVER_RECORD pServer;
   LPTSTR ServerStrings = NULL;
   TCHAR *pStr;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("ServerListStringsPack\n"));
#endif

   ASSERT(pServerStrings != NULL);
   ASSERT(pServerStringSize != NULL);

   *pServerStrings = NULL;
   *pServerStringSize = 0;

   //
   // First walk the list adding up string sizes - to calculate our buff size
   //
   StringSize = 0;
   for (i = 0; i < ServerTableSize; i++) {
      pServer = &Servers[i];

      StringSize = StringSize + lstrlen(pServer->Name) + 1;
   }

   //
   // Make sure there is anything to replicate
   //
   if (StringSize > 0) {
      //
      // Create our buffer to hold all of the garbage
      //
      ServerStrings = MIDL_user_allocate(StringSize * sizeof(TCHAR));
      if (ServerStrings == NULL) {
         ASSERT(FALSE);
         return STATUS_NO_MEMORY;
      }

      //
      // Fill in the buffer
      //
      pStr = ServerStrings;
      for (i = 0; i < ServerTableSize; i++) {
         pServer = &Servers[i];

         lstrcpy(pStr, pServer->Name);
         pStr = &pStr[lstrlen(pServer->Name) + 1];
      }
   }

   *pServerStrings = ServerStrings;
   *pServerStringSize = StringSize;

   return Status;
} // ServerListStringsPack


/////////////////////////////////////////////////////////////////////////
VOID
ServerListStringsUnpack (
   ULONG ServerTableSize,
   PREPL_SERVER_RECORD Servers,

   ULONG ServerStringSize,
   LPTSTR ServerStrings
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   ULONG i;
   PREPL_SERVER_RECORD pServer;
   TCHAR *pStr;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("ServerListStringsUnpack\n"));
#endif

   //
   // First do license service strings
   //
   pStr = ServerStrings;
   for (i = 0; i < ServerTableSize; i++) {
      pServer = &Servers[i];

      pServer->Name = pStr;

      //
      // Move to end of current string
      //
      while (*pStr != TEXT('\0'))
         pStr++;

      // now go past ending NULL
      pStr++;
   }

} // ServerListStringsUnpack



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
NTSTATUS
PackAll (
   DWORD LastReplicated,

   ULONG *pServiceTableSize,
   PREPL_SERVICE_RECORD *pServices,

   ULONG *pServerTableSize,
   PREPL_SERVER_RECORD *pServers,

   ULONG *pServerServiceTableSize,
   PREPL_SERVER_SERVICE_RECORD *pServerServices,

   ULONG UserLevel,
   ULONG *pUserTableSize,
   LPVOID *pUsers
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: PackAll\n"));
#endif

   //
   // We need to grab all the locks here so that a service isn't snuck in
   // behind our backs - since these tables interact with each other.
   //
   RtlAcquireResourceExclusive(&UserListLock, TRUE);
   RtlAcquireResourceShared(&MasterServiceListLock, TRUE);
   RtlAcquireResourceShared(&ServerListLock, TRUE);

   Status = ServiceListPack(pServiceTableSize, pServices);
   if (Status != STATUS_SUCCESS)
      goto PackAllExit;

   Status = ServerListPack(pServerTableSize, pServers);
   if (Status != STATUS_SUCCESS)
      goto PackAllExit;

   Status = ServerServiceListPack(pServerServiceTableSize, pServerServices);
   if (Status != STATUS_SUCCESS)
      goto PackAllExit;

   Status = UserListPack(LastReplicated, UserLevel, pUserTableSize, pUsers);
   if (Status != STATUS_SUCCESS)
      goto PackAllExit;

   //
   // Now update our last used time
   //
   LastUsedTime = DateSystemGet() + 1;

PackAllExit:
   RtlReleaseResource(&ServerListLock);
   RtlReleaseResource(&MasterServiceListLock);
   RtlReleaseResource(&UserListLock);

   return Status;
} // PackAll


/////////////////////////////////////////////////////////////////////////
VOID
UnpackAll (
   ULONG ServiceTableSize,
   PREPL_SERVICE_RECORD Services,

   ULONG ServerTableSize,
   PREPL_SERVER_RECORD Servers,

   ULONG ServerServiceTableSize,
   PREPL_SERVER_SERVICE_RECORD ServerServices,

   ULONG UserLevel,
   ULONG UserTableSize,
   LPVOID Users
   )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: UnpackAll\n"));
#endif

   ServiceListUnpack(ServiceTableSize, Services, ServerTableSize, Servers, ServerServiceTableSize, ServerServices);
   ServerListUnpack(ServiceTableSize, Services, ServerTableSize, Servers, ServerServiceTableSize, ServerServices);
   ServerServiceListUnpack(ServiceTableSize, Services, ServerTableSize, Servers, ServerServiceTableSize, ServerServices);
   UserListUnpack(ServiceTableSize, Services, ServerTableSize, Servers, ServerServiceTableSize, ServerServices, UserLevel, UserTableSize, Users);
} // UnpackAll


/////////////////////////////////////////////////////////////////////////
VOID
LLSDataLoad()

/*++

Routine Description:

Arguments:

   None.

Return Value:

   None.

--*/

{
   BOOL ret;
   DWORD Version, DataSize;
   NTSTATUS Status = STATUS_SUCCESS;
   HANDLE hFile = NULL;

   ULONG ServiceTableSize = 0;
   PREPL_SERVICE_RECORD Services = NULL;

   ULONG ServiceStringSize;
   LPTSTR ServiceStrings = NULL;

   ULONG ServerServiceTableSize = 0;
   PREPL_SERVER_SERVICE_RECORD ServerServices = NULL;

   ULONG ServerTableSize = 0;
   PREPL_SERVER_RECORD Servers = NULL;

   ULONG ServerStringSize;
   LPTSTR ServerStrings = NULL;

   ULONG UserTableSize = 0;
   LPVOID Users = NULL;

   ULONG UserStringSize;
   LPTSTR UserStrings = NULL;

   LLS_DATA_FILE_HEADER FileHeader;
   DWORD BytesRead;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: LLSDataLoad\n"));
#endif

   //
   // If nothing to load then get-out
   //
   if (!FileExists(UserFileName))
      goto LLSDataLoadExit;

   //
   // Check the init header
   //
   Version = DataSize = 0;
   hFile = LlsFileCheck(UserFileName, &Version, &DataSize );
   if (hFile == NULL) {
      Status = GetLastError();
      goto LLSDataLoadExit;
   }

   if (    (    ( Version  != USER_FILE_VERSION_0            )
             || ( DataSize != sizeof(LLS_DATA_FILE_HEADER_0) ) )
        && (    ( Version  != USER_FILE_VERSION              )
             || ( DataSize != sizeof(LLS_DATA_FILE_HEADER)   ) ) )
   {
      Status = STATUS_FILE_INVALID;
      goto LLSDataLoadExit;
   }

   //
   // The init header checks out, so load the license header and data blocks
   //
   if ( USER_FILE_VERSION_0 == Version )
   {
      // 3.51 data file
      LLS_DATA_FILE_HEADER_0  FileHeader0;

      ret = ReadFile(hFile, &FileHeader0, sizeof(LLS_DATA_FILE_HEADER_0), &BytesRead, NULL);

      if ( ret )
      {
         FileHeader.ServiceLevel           = 0;
         FileHeader.ServiceTableSize       = FileHeader0.ServiceTableSize;
         FileHeader.ServiceStringSize      = FileHeader0.ServiceStringSize;
         FileHeader.ServerLevel            = 0;
         FileHeader.ServerTableSize        = FileHeader0.ServerTableSize;
         FileHeader.ServerStringSize       = FileHeader0.ServerStringSize;
         FileHeader.ServerServiceLevel     = 0;
         FileHeader.ServerServiceTableSize = FileHeader0.ServerServiceTableSize;
         FileHeader.UserLevel              = 0;
         FileHeader.UserTableSize          = FileHeader0.UserTableSize;
         FileHeader.UserStringSize         = FileHeader0.UserStringSize;
      }
   }
   else
   {
      ret = ReadFile(hFile, &FileHeader, sizeof(LLS_DATA_FILE_HEADER), &BytesRead, NULL);
   }

   if ( ret )
   {
      // header read okay; ensure data type levels are okay
      if (    ( 0 != FileHeader.ServiceLevel         )
           || ( 0 != FileHeader.ServerLevel          )
           || ( 0 != FileHeader.ServerServiceLevel   )
           || (    ( 0 != FileHeader.UserLevel     )
                && ( 1 != FileHeader.UserLevel     ) ) )
      {
         Status = STATUS_FILE_INVALID;
         goto LLSDataLoadExit;
      }
   }

   ServiceTableSize = 0;
   ServiceStringSize = 0;
   ServerServiceTableSize = 0;
   ServerTableSize = 0;
   ServerStringSize = 0;
   UserTableSize = 0;
   UserStringSize = 0;

   if (ret) {
      //
      // Run through and allocate space to read data blocks into
      //
      if (FileHeader.ServiceTableSize != 0) {
         ServiceTableSize = FileHeader.ServiceTableSize / sizeof(REPL_SERVICE_RECORD);
         Services = MIDL_user_allocate(FileHeader.ServiceTableSize);

         if ( Services == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LLSDataLoadExit;
         }
      }

      if (FileHeader.ServiceStringSize != 0) {
         ServiceStringSize = FileHeader.ServiceStringSize / sizeof(TCHAR);
         ServiceStrings = MIDL_user_allocate(FileHeader.ServiceStringSize);

         if ( ServiceStrings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LLSDataLoadExit;
         }
      }

      if (FileHeader.ServerTableSize != 0) {
         ServerTableSize = FileHeader.ServerTableSize / sizeof(REPL_SERVER_RECORD);
         Servers = MIDL_user_allocate(FileHeader.ServerTableSize);

         if ( Servers == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LLSDataLoadExit;
         }
      }

      if (FileHeader.ServerStringSize != 0) {
         ServerStringSize = FileHeader.ServerStringSize / sizeof(TCHAR);
         ServerStrings = MIDL_user_allocate(FileHeader.ServerStringSize);

         if ( ServerStrings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LLSDataLoadExit;
         }
      }

      if (FileHeader.ServerServiceTableSize != 0) {
         ServerServiceTableSize = FileHeader.ServerServiceTableSize / sizeof(REPL_SERVER_SERVICE_RECORD);
         ServerServices = MIDL_user_allocate(FileHeader.ServerServiceTableSize);

         if ( ServerServices == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LLSDataLoadExit;
         }
      }

      if (FileHeader.UserTableSize != 0) {
         UserTableSize = FileHeader.UserTableSize / ( FileHeader.UserLevel ? sizeof(REPL_USER_RECORD_1)
                                                                           : sizeof(REPL_USER_RECORD_0) );
         Users = MIDL_user_allocate(FileHeader.UserTableSize);

         if ( Users == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LLSDataLoadExit;
         }
      }

      if (FileHeader.UserStringSize != 0) {
         UserStringSize = FileHeader.UserStringSize / sizeof(TCHAR);
         UserStrings = MIDL_user_allocate(FileHeader.UserStringSize);

         if ( UserStrings == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto LLSDataLoadExit;
         }
      }

   }

   if (ret && (FileHeader.ServiceTableSize != 0) )
      ret = ReadFile(hFile, Services, FileHeader.ServiceTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.ServiceStringSize != 0) )
      ret = ReadFile(hFile, ServiceStrings, FileHeader.ServiceStringSize, &BytesRead, NULL);

   if (ret && (FileHeader.ServerTableSize != 0) )
      ret = ReadFile(hFile, Servers, FileHeader.ServerTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.ServerStringSize != 0) )
      ret = ReadFile(hFile, ServerStrings, FileHeader.ServerStringSize, &BytesRead, NULL);

   if (ret && (FileHeader.ServerServiceTableSize != 0) )
      ret = ReadFile(hFile, ServerServices, FileHeader.ServerServiceTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.UserTableSize != 0) )
      ret = ReadFile(hFile, Users, FileHeader.UserTableSize, &BytesRead, NULL);

   if (ret && (FileHeader.UserStringSize != 0) )
      ret = ReadFile(hFile, UserStrings, FileHeader.UserStringSize, &BytesRead, NULL);

   if (!ret) {
      Status = GetLastError();
      goto LLSDataLoadExit;
   }

   //
   // Decrypt the data
   //
   Status = DeBlock(Services, FileHeader.ServiceTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(ServiceStrings, FileHeader.ServiceStringSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(Servers, FileHeader.ServerTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(ServerStrings, FileHeader.ServerStringSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(ServerServices, FileHeader.ServerServiceTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(Users, FileHeader.UserTableSize);

   if (Status == STATUS_SUCCESS)
      Status = DeBlock(UserStrings, FileHeader.UserStringSize);

   if (Status != STATUS_SUCCESS)
      goto LLSDataLoadExit;


   //
   // Unpack the string data
   //
   ServiceListStringsUnpack( ServiceTableSize, Services, ServiceStringSize, ServiceStrings );
   ServerListStringsUnpack( ServerTableSize, Servers, ServerStringSize, ServerStrings );
   UserListStringsUnpack( FileHeader.UserLevel, UserTableSize, Users, UserStringSize, UserStrings );

   //
   // Unpack the data
   //
   UnpackAll ( ServiceTableSize, Services, ServerTableSize, Servers,
               ServerServiceTableSize, ServerServices,
               FileHeader.UserLevel, UserTableSize, Users );

LLSDataLoadExit:

   if (hFile != NULL)
      CloseHandle(hFile);

   //
   // Run through our tables and clean them up
   //
   if (Services != NULL)
      MIDL_user_free(Services);

   if (ServiceStrings != NULL)
      MIDL_user_free(ServiceStrings);

   if (Servers != NULL)
      MIDL_user_free(Servers);

   if (ServerStrings != NULL)
      MIDL_user_free(ServerStrings);

   if (ServerServices != NULL)
      MIDL_user_free(ServerServices);

   if (Users != NULL)
      MIDL_user_free(Users);

   if (UserStrings != NULL)
      MIDL_user_free(UserStrings);

   //
   // If there was an error log it.
   //
   if (Status != STATUS_SUCCESS)
      LogEvent(LLS_EVENT_LOAD_USER, 0, NULL, Status);

} // LLSDataLoad


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LLSDataSave()

/*++

Routine Description:

Arguments:

   None.

Return Value:

   None.

--*/

{
   BOOL ret = TRUE;
   NTSTATUS Status = STATUS_SUCCESS;
   HANDLE hFile = NULL;

   ULONG ServiceTableSize = 0;
   PREPL_SERVICE_RECORD Services = NULL;

   ULONG ServiceStringSize;
   LPTSTR ServiceStrings = NULL;

   ULONG ServerServiceTableSize = 0;
   PREPL_SERVER_SERVICE_RECORD ServerServices = NULL;

   ULONG ServerTableSize = 0;
   PREPL_SERVER_RECORD Servers = NULL;

   ULONG ServerStringSize;
   LPTSTR ServerStrings = NULL;

   ULONG UserTableSize = 0;
   PREPL_USER_RECORD_1 Users = NULL;

   ULONG UserStringSize;
   LPTSTR UserStrings = NULL;

   LLS_DATA_FILE_HEADER FileHeader;
   DWORD BytesWritten;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: LLSDataSave\n"));
#endif

   //
   // Pack the data
   //
   Status = PackAll ( 0,
                      &ServiceTableSize, &Services,
                      &ServerTableSize, &Servers,
                      &ServerServiceTableSize, &ServerServices,
                      1, &UserTableSize, &Users );
   if (Status != STATUS_SUCCESS)
      goto LLSDataSaveExit;

   //
   // Now pack the String data
   //
   Status = ServiceListStringsPack( ServiceTableSize, Services, &ServiceStringSize, &ServiceStrings );
   if (Status != STATUS_SUCCESS)
      goto LLSDataSaveExit;

   Status = ServerListStringsPack( ServerTableSize, Servers, &ServerStringSize, &ServerStrings );
   if (Status != STATUS_SUCCESS)
      goto LLSDataSaveExit;

   Status = UserListStringsPack( 1, UserTableSize, Users, &UserStringSize, &UserStrings );
   if (Status != STATUS_SUCCESS)
      goto LLSDataSaveExit;

   //
   // Fill out the file header - sizes are byte sizes
   //
   FileHeader.ServiceTableSize = ServiceTableSize * sizeof(REPL_SERVICE_RECORD);
   FileHeader.ServiceStringSize = ServiceStringSize * sizeof(TCHAR);
   FileHeader.ServerTableSize = ServerTableSize * sizeof(REPL_SERVER_RECORD);
   FileHeader.ServerStringSize = ServerStringSize * sizeof(TCHAR);
   FileHeader.ServerServiceTableSize = ServerServiceTableSize * sizeof(REPL_SERVER_SERVICE_RECORD);
   FileHeader.UserTableSize = UserTableSize * sizeof(REPL_USER_RECORD_1);
   FileHeader.UserStringSize = UserStringSize * sizeof(TCHAR);

   FileHeader.ServiceLevel       = 0;
   FileHeader.ServerLevel        = 0;
   FileHeader.ServerServiceLevel = 0;
   FileHeader.UserLevel          = 1;

   //
   // Encrypt the data before saving it out.
   //
   Status = EBlock(Services, FileHeader.ServiceTableSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(ServiceStrings, FileHeader.ServiceStringSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(Servers, FileHeader.ServerTableSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(ServerStrings, FileHeader.ServerStringSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(ServerServices, FileHeader.ServerServiceTableSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(Users, FileHeader.UserTableSize);

   if (Status == STATUS_SUCCESS)
      Status = EBlock(UserStrings, FileHeader.UserStringSize);

   if (Status != STATUS_SUCCESS)
      goto LLSDataSaveExit;

   //
   // Save out the header record
   //
   hFile = LlsFileInit(UserFileName, USER_FILE_VERSION, sizeof(LLS_DATA_FILE_HEADER) );
   if (hFile == NULL) {
      Status = GetLastError();
      goto LLSDataSaveExit;
   }

   //
   // Now write out all the data blocks
   //
   ret = WriteFile(hFile, &FileHeader, sizeof(LLS_DATA_FILE_HEADER), &BytesWritten, NULL);

   if (ret && (Services != NULL) && (FileHeader.ServiceTableSize != 0) )
      ret = WriteFile(hFile, Services, FileHeader.ServiceTableSize, &BytesWritten, NULL);

   if (ret && (ServiceStrings != NULL) && (FileHeader.ServiceStringSize != 0) )
      ret = WriteFile(hFile, ServiceStrings, FileHeader.ServiceStringSize, &BytesWritten, NULL);

   if (ret && (Servers != NULL) && (FileHeader.ServerTableSize != 0) )
      ret = WriteFile(hFile, Servers, FileHeader.ServerTableSize, &BytesWritten, NULL);

   if (ret && (ServerStrings != NULL) && (FileHeader.ServerStringSize != 0) )
      ret = WriteFile(hFile, ServerStrings, FileHeader.ServerStringSize, &BytesWritten, NULL);

   if (ret && (ServerServices != NULL) && (FileHeader.ServerServiceTableSize != 0) )
      ret = WriteFile(hFile, ServerServices, FileHeader.ServerServiceTableSize, &BytesWritten, NULL);

   if (ret && (Users != NULL) && (FileHeader.UserTableSize != 0) )
      ret = WriteFile(hFile, Users, FileHeader.UserTableSize, &BytesWritten, NULL);

   if (ret && (UserStrings != NULL) && (FileHeader.UserStringSize != 0) )
      ret = WriteFile(hFile, UserStrings, FileHeader.UserStringSize, &BytesWritten, NULL);

   if (!ret)
      Status = GetLastError();

LLSDataSaveExit:

   if (hFile != NULL)
      CloseHandle(hFile);

   //
   // Run through our tables and clean them up
   //
   if (Services != NULL)
      MIDL_user_free(Services);

   if (ServiceStrings != NULL)
      MIDL_user_free(ServiceStrings);

   if (Servers != NULL)
      MIDL_user_free(Servers);

   if (ServerStrings != NULL)
      MIDL_user_free(ServerStrings);

   if (ServerServices != NULL)
      MIDL_user_free(ServerServices);

   if (Users != NULL)
      MIDL_user_free(Users);

   if (UserStrings != NULL)
      MIDL_user_free(UserStrings);

   //
   // If there was an error log it.
   //
   if (Status != STATUS_SUCCESS)
      LogEvent(LLS_EVENT_SAVE_USER, 0, NULL, Status);

   return Status;
} // LLSDataSave


/////////////////////////////////////////////////////////////////////////
VOID
LoadAll ( )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: LoadAll\n"));
#endif

   PurchaseFile = NULL;

   try { 
       LicenseListLoad();
   } except (TRUE) {
      LogEvent(LLS_EVENT_LOAD_LICENSE, 0, NULL, GetExceptionCode());
   }

   try {
       MappingListLoad();
   } except (TRUE) {
      LogEvent(LLS_EVENT_LOAD_MAPPING, 0, NULL, GetExceptionCode());
   }

   try {
       LLSDataLoad();
   } except (TRUE) {
      LogEvent(LLS_EVENT_LOAD_USER, 0, NULL, GetExceptionCode());
   }

   try {
       CertDbLoad();
   } except (TRUE) {
      LogEvent(LLS_EVENT_LOAD_CERT_DB, 0, NULL, GetExceptionCode());
   }

} // LoadAll


/////////////////////////////////////////////////////////////////////////
VOID
SaveAll ( )

/*++

Routine Description:


Arguments:

Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_DATABASE))
      dprintf(TEXT("LLS TRACE: SaveAll\n"));
#endif

   LicenseListSave();
   MappingListSave();
   LLSDataSave();
   CertDbSave();

} // SaveAll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\purchase.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   purchase.c

Abstract:


Author:

   Arthur Hanson (arth) 03-Jan-1995

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added support for uniting per seat and per server purchase models.
      o  Added extra parameters and code to support secure certificates and
         certificate database.

--*/

#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dsgetdc.h>


#include <debug.h>
#include "llsevent.h"
#include "llsapi.h"
#include "llsutil.h"
#include "llssrv.h"
#include "mapping.h"
#include "msvctbl.h"
#include "purchase.h"
#include "svctbl.h"
#include "perseat.h"
#include "registry.h"
#include "llsrpc_s.h"
#include "certdb.h"
#include "server.h"


//
// Initialized in ReplicationInit in repl.c.
//
extern PLLS_CONNECT_W     pLlsConnectW;
extern PLLS_CLOSE         pLlsClose;
extern PLLS_LICENSE_ADD_W pLlsLicenseAddW;

ULONG LicenseServiceListSize = 0;
PLICENSE_SERVICE_RECORD *LicenseServiceList = NULL;

ULONG PerServerLicenseServiceListSize = 0;
PLICENSE_SERVICE_RECORD *PerServerLicenseServiceList = NULL;

PLICENSE_PURCHASE_RECORD PurchaseList = NULL;
ULONG PurchaseListSize = 0;

RTL_RESOURCE LicenseListLock;


static
NTSTATUS
LicenseAdd_UpdateQuantity(
   LPTSTR                     ServiceName,
   LONG                       Quantity,
   BOOL                       UsePerServerList,
   PLICENSE_SERVICE_RECORD *  ppService,
   BOOL *                     pChangeLicense,
   LONG *                     pNewLicenses,
   PMASTER_SERVICE_RECORD *   pmService
   );

NTSTATUS
ReplicationInitDelayed();

/////////////////////////////////////////////////////////////////////////
NTSTATUS
LicenseListInit()

/*++

Routine Description:

Arguments:

   None.

Return Value:

   None.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;

   try
   {
       RtlInitializeResource(&LicenseListLock);
   } except(EXCEPTION_EXECUTE_HANDLER ) {
       status = GetExceptionCode();
   }

   return status;

} // LicenseListInit


/////////////////////////////////////////////////////////////////////////
int __cdecl LicenseServiceListCompare(const void *arg1, const void *arg2) {
   PLICENSE_SERVICE_RECORD Svc1, Svc2;

   Svc1 = (PLICENSE_SERVICE_RECORD) *((PLICENSE_SERVICE_RECORD *) arg1);
   Svc2 = (PLICENSE_SERVICE_RECORD) *((PLICENSE_SERVICE_RECORD *) arg2);

   return lstrcmpi( Svc1->ServiceName, Svc2->ServiceName);

} // LicenseServiceListCompare


/////////////////////////////////////////////////////////////////////////
PLICENSE_SERVICE_RECORD
LicenseServiceListFind(
   LPTSTR ServiceName,
   BOOL   UsePerServerList
   )

/*++

Routine Description:

Arguments:

   ServiceName -

   (JeffParh 95-10-31)
   UsePerServerList - Determines whether the license record is searched for
      in the per seat list (as in 3.51) or in the per server list (new for
      SUR).  The license purchase models are now unified, so there is now
      a purchase history for both per seat and per server licenses.

Return Value:

   Pointer to found service table entry or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end = (LONG) LicenseServiceListSize - 1;
   LONG cur;
   int match;
   PLICENSE_SERVICE_RECORD Service;
   PLICENSE_SERVICE_RECORD *  ServiceList;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LicenseServiceListFind\n"));
#endif
   if (ServiceName == NULL)
      return NULL;

   if ( UsePerServerList )
   {
      end         = PerServerLicenseServiceListSize - 1;
      ServiceList = PerServerLicenseServiceList;
   }
   else
   {
      end         = LicenseServiceListSize - 1;
      ServiceList = LicenseServiceList;
   }

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;
      Service = ServiceList[cur];

      // compare the two result into match
      match = lstrcmpi(ServiceName, Service->ServiceName);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return Service;
   }

   return NULL;

} // LicenseServiceListFind


/////////////////////////////////////////////////////////////////////////
PLICENSE_SERVICE_RECORD
LicenseServiceListAdd(
   LPTSTR ServiceName,
   BOOL   UsePerServerList
   )

/*++

Routine Description:


Arguments:

   ServiceName -

   (JeffParh 95-10-31)
   UsePerServerList - Determines whether the license record is added to
      the per seat list (as in 3.51) or the per server list (new for
      SUR).  The license purchase models are now unified, so there is now
      a purchase history for both per seat and per server licenses.

Return Value:

   Pointer to added service table entry, or NULL if failed.

--*/

{
   PLICENSE_SERVICE_RECORD Service;
   LPTSTR NewServiceName;
   PLICENSE_SERVICE_RECORD **  pServiceList;
   LPDWORD                     pServiceListSize;
   PLICENSE_SERVICE_RECORD *  pServiceListTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LicenseServiceListAdd\n"));
#endif
   //
   // We do a double check here to see if another thread just got done
   // adding the service, between when we checked last and actually got
   // the write lock.
   //
   Service = LicenseServiceListFind(ServiceName, UsePerServerList);
   if (Service != NULL) {
      return Service;
   }

   if ( UsePerServerList )
   {
      pServiceList      = &PerServerLicenseServiceList;
      pServiceListSize  = &PerServerLicenseServiceListSize;
   }
   else
   {
      pServiceList      = &LicenseServiceList;
      pServiceListSize  = &LicenseServiceListSize;
   }

   //
   // Allocate space for table (zero init it).
   //
   if (*pServiceList == NULL)
      pServiceListTmp = (PLICENSE_SERVICE_RECORD *) LocalAlloc(LPTR, sizeof(PLICENSE_SERVICE_RECORD) * (*pServiceListSize + 1));
   else
      pServiceListTmp = (PLICENSE_SERVICE_RECORD *) LocalReAlloc(*pServiceList, sizeof(PLICENSE_SERVICE_RECORD) * (*pServiceListSize + 1), LHND);

   //
   // Make sure we could allocate service table
   //
   if (pServiceListTmp == NULL) {
      return NULL;
   } else {
      *pServiceList = pServiceListTmp;
   }

   Service = (PLICENSE_SERVICE_RECORD) LocalAlloc(LPTR, sizeof(LICENSE_SERVICE_RECORD));
   if (Service == NULL) {
      ASSERT(FALSE);
      return NULL;
   }

   //
   // Create space for saving off the name.
   //
   NewServiceName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(ServiceName) + 1) * sizeof(TCHAR));
   if (NewServiceName == NULL) {
      ASSERT(FALSE);

      LocalFree(Service);

      return NULL;
   }

   // now copy it over...
   Service->ServiceName = NewServiceName;
   lstrcpy(NewServiceName, ServiceName);

   (*pServiceList)[*pServiceListSize] = Service;
   Service->NumberLicenses = 0;
   Service->Index = *pServiceListSize;
   (*pServiceListSize)++;

   // Have added the entry - now need to sort it in order of the service names
   qsort((void *) *pServiceList, (size_t) *pServiceListSize, sizeof(PLICENSE_SERVICE_RECORD), LicenseServiceListCompare);

   return Service;

} // LicenseServiceListAdd


/////////////////////////////////////////////////////////////////////////
ULONG
ProductLicensesGet(
   LPTSTR ServiceName,
   BOOL   UsePerServerList
   )

/*++

Routine Description:


Arguments:

   ServiceName -

   (JeffParh 95-10-31)
   UsePerServerList - Determines whether the number of licenses is retirved
      from the per seat list (as in 3.51) or the per server list (new for
      SUR).  The license purchase models are now unified, so there is now
      a purchase history for both per seat and per server licenses.

Return Value:


--*/

{
   PLICENSE_SERVICE_RECORD Service;
   ULONG NumLicenses = 0;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ProductLicenseGet\n"));
#endif

   //
   // Try to find the service.
   //
   RtlAcquireResourceShared(&LicenseListLock, TRUE);
   Service = LicenseServiceListFind(ServiceName, UsePerServerList);
   if (Service != NULL)
      NumLicenses = Service->NumberLicenses;
   RtlReleaseResource(&LicenseListLock);

   return NumLicenses;
} // ProductLicensesGet


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LicenseAdd(
   LPTSTR   ServiceName,
   LPTSTR   Vendor,
   LONG     Quantity,
   DWORD    MaxQuantity,
   LPTSTR   Admin,
   LPTSTR   Comment,
   DWORD    Date,
   DWORD    AllowedModes,
   DWORD    CertificateID,
   LPTSTR   Source,
   DWORD    ExpirationDate,
   LPDWORD  Secrets
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static DWORD NullSecrets[ LLS_NUM_SECRETS ] = { 0, 0, 0, 0 };

   BOOL                       ChangeLicense = FALSE;
   PLICENSE_SERVICE_RECORD    Service = NULL;
   PLICENSE_PURCHASE_RECORD   PurchaseRecord;
   LONG                       NewLicenses = 0;
   NTSTATUS                   Status;
   BOOL                       PerServerChangeLicense = FALSE;
   PLICENSE_SERVICE_RECORD    PerServerService = NULL;
   LONG                       PerServerNewLicenses = 0;
   LPTSTR                     NewName,NewAdmin,NewComment,NewSource,NewVendor;
   PMASTER_SERVICE_RECORD     mService;
   LLS_LICENSE_INFO_1         lic;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LicenseAdd\n"));
#endif

   if ( ( 0 == CertificateID ) && ( ServiceIsSecure( ServiceName ) ) )
   {
      return STATUS_ACCESS_DENIED;
   }

   if ( ( 0 != ExpirationDate ) && ( ExpirationDate < DateSystemGet() ) )
   {
      // certificate has expired
      return STATUS_ACCOUNT_EXPIRED;
   }

   if (    ( NULL == ServiceName  )
        || ( NULL == Vendor       )
        || ( 0 == Quantity        )
        || ( ( 0 != CertificateID ) && ( 0 == MaxQuantity ) )
        || ( NULL == Admin        )
        || ( NULL == Comment      )
        || ( 0 == ( AllowedModes & ( LLS_LICENSE_MODE_ALLOW_PER_SEAT | LLS_LICENSE_MODE_ALLOW_PER_SERVER ) ) )
        || ( NULL == Source       ) )
   {
      // invalid parameter
      return STATUS_INVALID_PARAMETER;
   }

   if ( NULL == Secrets )
   {
      Secrets = NullSecrets;
   }

   //
   //                       ** NEW - NT 5.0 **
   //
   // All per seat purchase requests are deferred to the site license master
   // server. Per server is still handled individually at each server.
   //

   if ( AllowedModes & 1 ) {
       //
       // Update enterprise information, in case the site license master
       // has changed.
       //

#if DELAY_INITIALIZATION
       EnsureInitialized();
#endif

       ConfigInfoUpdate(NULL);

       //
       // Connect to the site license master server, if this server is
       // not the master.
       //

       RtlEnterCriticalSection(&ConfigInfoLock);
       if ( !ConfigInfo.IsMaster && (ConfigInfo.SiteServer != NULL)) {

         // Make sure function pointers are initialized
         ReplicationInitDelayed();

         if ( pLlsConnectW != NULL ) {
              LLS_HANDLE LlsHandle;
              Status = (*pLlsConnectW)(ConfigInfo.SiteServer,
                                       &LlsHandle);

             if ( Status == STATUS_SUCCESS ) {
                 LLS_LICENSE_INFO_0 LicenseInfo0;

                 LicenseInfo0.Product  = ServiceName;
                 LicenseInfo0.Quantity = Quantity;
                 LicenseInfo0.Date     = Date;
                 LicenseInfo0.Admin    = Admin;
                 LicenseInfo0.Comment  = Comment;

                 Status = (*pLlsLicenseAddW)(LlsHandle,
                                             0,
                                             (LPBYTE)&LicenseInfo0);
                 (*pLlsClose)(LlsHandle);
             }
         }
         else {
            //
            // Not the best error, but we must return something should
            // this obscure error condition become true.
            //
            Status = STATUS_INVALID_PARAMETER;
         }

         RtlLeaveCriticalSection(&ConfigInfoLock);
         return Status;

      }

      RtlLeaveCriticalSection(&ConfigInfoLock);
   }

   RtlAcquireResourceExclusive(&LicenseListLock, TRUE);

   if ( 0 != CertificateID )
   {
      lic.Product          = ServiceName;
      lic.Vendor           = Vendor;
      lic.Quantity         = Quantity;
      lic.MaxQuantity      = MaxQuantity;
      lic.Admin            = Admin;
      lic.Comment          = Comment;
      lic.Date             = Date;
      lic.AllowedModes     = AllowedModes;
      lic.CertificateID    = CertificateID;
      lic.Source           = Source;
      lic.ExpirationDate   = ExpirationDate;
      memcpy( lic.Secrets, Secrets, LLS_NUM_SECRETS * sizeof( *Secrets ) );

      if ( !CertDbClaimApprove( &lic ) )
      {
         // no way, hoser!
         RtlReleaseResource( &LicenseListLock );
         return STATUS_OBJECT_NAME_EXISTS;
      }
   }

   // update totals for per seat / per server mode licenses

   Status = STATUS_SUCCESS;

   if ( AllowedModes & 1 )
   {
      // per seat allowed; add to per seat license tally
      Status = LicenseAdd_UpdateQuantity( ServiceName,
                                          Quantity,
                                          FALSE,
                                          &Service,
                                          &ChangeLicense,
                                          &NewLicenses,
                                          &mService );
   }

   if ( ( STATUS_SUCCESS == Status ) && ( AllowedModes & 2 ) )
   {
      // per server allowed; add to per server license tally
      Status = LicenseAdd_UpdateQuantity( ServiceName,
                                          Quantity,
                                          TRUE,
                                          &PerServerService,
                                          &PerServerChangeLicense,
                                          &PerServerNewLicenses,
                                          &mService );
   }

   if ( STATUS_SUCCESS != Status )
   {
      RtlReleaseResource( &LicenseListLock );
      return Status;
   }

   //
   // Service now points to the service table entry - now update purchase
   // History.
   //

   //
   // First allocate members, then new struct
   //

   //
   // Create space for saving off the Admin Name
   //
   NewName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(Admin) + 1) * sizeof(TCHAR));
   if (NewName == NULL)
   {
      ASSERT(FALSE);
      RtlReleaseResource(&LicenseListLock);
      return STATUS_NO_MEMORY;
   }

   // now copy it over...
   lstrcpy(NewName, Admin);

   //
   // Create space for saving off the Comment
   //
   NewComment = (LPTSTR) LocalAlloc(LPTR, (lstrlen(Comment) + 1) * sizeof(TCHAR));
   if (NewComment == NULL)
   {
      ASSERT(FALSE);
      LocalFree(NewName);
      RtlReleaseResource(&LicenseListLock);
      return STATUS_NO_MEMORY;
   }

   // now copy it over...
   lstrcpy(NewComment, Comment);

   //
   // Create space for saving off the Source
   //
   NewSource = (LPTSTR) LocalAlloc(LPTR, (lstrlen(Source) + 1) * sizeof(TCHAR));
   if (NewSource == NULL)
   {
      ASSERT(FALSE);
      LocalFree(NewName);
      LocalFree(NewComment);
      RtlReleaseResource(&LicenseListLock);
      return STATUS_NO_MEMORY;
   }

   // now copy it over...
   lstrcpy(NewSource, Source);

   //
   // Create space for saving off the Vendor
   //
   NewVendor = (LPTSTR) LocalAlloc(LPTR, (lstrlen(Vendor) + 1) * sizeof(TCHAR));
   if (NewVendor == NULL)
   {
      ASSERT(FALSE);
      LocalFree(NewName);
      LocalFree(NewComment);
      LocalFree(NewSource);
      RtlReleaseResource(&LicenseListLock);
      return STATUS_NO_MEMORY;
   }

   // now copy it over...
   lstrcpy(NewVendor, Vendor);

   if (PurchaseList == NULL)
      PurchaseList = (PLICENSE_PURCHASE_RECORD) LocalAlloc(LPTR, sizeof(LICENSE_PURCHASE_RECORD) * (PurchaseListSize + 1));
   else
   {
      PLICENSE_PURCHASE_RECORD   PurchaseListTemp = NULL;

      PurchaseListTemp = (PLICENSE_PURCHASE_RECORD) LocalReAlloc(PurchaseList, sizeof(LICENSE_PURCHASE_RECORD) * (PurchaseListSize + 1), LHND);

      if (PurchaseListTemp != NULL)
      {
          PurchaseList = PurchaseListTemp;
      } else
      {
          ASSERT(FALSE);
          LocalFree(NewName);
          LocalFree(NewComment);
          LocalFree(NewSource);
          LocalFree(NewVendor);
          RtlReleaseResource(&LicenseListLock);
          return STATUS_NO_MEMORY;
      }
   }

   //
   // Make sure we could allocate service table
   //
   if (PurchaseList == NULL)
   {
      ASSERT(FALSE);
      PurchaseListSize = 0;
      LocalFree(NewName);
      LocalFree(NewComment);
      LocalFree(NewSource);
      LocalFree(NewVendor);
      RtlReleaseResource(&LicenseListLock);
      return STATUS_NO_MEMORY;
   }

   PurchaseRecord = &PurchaseList[PurchaseListSize];

   PurchaseRecord->Admin = NewName;
   PurchaseRecord->Comment = NewComment;
   PurchaseRecord->Source = NewSource;
   PurchaseRecord->Vendor = NewVendor;

   //
   // Update the rest of the stuff.
   //
   PurchaseRecord->NumberLicenses   = Quantity;
   PurchaseRecord->MaxQuantity      = MaxQuantity;
   PurchaseRecord->Service          = Service;
   PurchaseRecord->PerServerService = PerServerService;
   PurchaseRecord->AllowedModes     = AllowedModes;
   PurchaseRecord->CertificateID    = CertificateID;
   PurchaseRecord->ExpirationDate   = ExpirationDate;
   memcpy( PurchaseRecord->Secrets, Secrets, LLS_NUM_SECRETS * sizeof( *Secrets ) );

   if (Date == 0)
      PurchaseRecord->Date = DateSystemGet();
   else
      PurchaseRecord->Date = Date;

   PurchaseListSize++;

   RtlReleaseResource(&LicenseListLock);

   if ( 0 != CertificateID )
   {
      // these should still be set from above
      ASSERT( lic.Product         == ServiceName    );
      ASSERT( lic.Vendor          == Vendor         );
      ASSERT( lic.Quantity        == Quantity       );
      ASSERT( lic.MaxQuantity     == MaxQuantity    );
      ASSERT( lic.Admin           == Admin          );
      ASSERT( lic.Comment         == Comment        );
      ASSERT( lic.Date            == Date           );
      ASSERT( lic.AllowedModes    == AllowedModes   );
      ASSERT( lic.CertificateID   == CertificateID  );
      ASSERT( lic.Source          == Source         );
      ASSERT( lic.ExpirationDate  == ExpirationDate );
      ASSERT( 0 == memcmp( PurchaseRecord->Secrets, Secrets, LLS_NUM_SECRETS * sizeof( *Secrets ) ) );

      CertDbClaimEnter( NULL, &lic, FALSE, 0 );
   }

   //
   // Now check if we need to re-scan the user list and update licenses
   //
   if (ChangeLicense)
   {
      if ( NewLicenses < 0 )
         UserListLicenseDelete( mService, NewLicenses );

      if ( NewLicenses > 0 )
         FamilyLicenseUpdate ( mService->Family );
   }

   if ( AllowedModes & 2 )
   {
      // per server licenses modified
      LocalServiceListConcurrentLimitSet();
      LocalServerServiceListUpdate();
      ServiceListResynch();
   }

   return STATUS_SUCCESS;

} // LicenseAdd


/////////////////////////////////////////////////////////////////////////
static
NTSTATUS
LicenseAdd_UpdateQuantity(
   LPTSTR                     ServiceName,
   LONG                       Quantity,
   BOOL                       UsePerServerList,
   PLICENSE_SERVICE_RECORD *  ppService,
   BOOL *                     pChangeLicense,
   LONG *                     pNewLicenses,
   PMASTER_SERVICE_RECORD *   pmService
   )
{
   BOOL                          ChangeLicense = FALSE;
   PLICENSE_SERVICE_RECORD       Service;
   PLICENSE_PURCHASE_RECORD      PurchaseRecord;
   PMASTER_SERVICE_RECORD        mService;
   LONG                          NewLicenses = 0;

   Service = LicenseServiceListFind( ServiceName, UsePerServerList );

   //
   // If we didn't find it we will need to add it.
   //
   if (Service == NULL)
   {
      if (Quantity < 0)
      {
#if DBG
         dprintf(TEXT("Releasing Licenses from Non-existant product!\n"));
#endif
         // ASSERT(FALSE);
         return STATUS_UNSUCCESSFUL;
      }
      else
      {
         Service = LicenseServiceListAdd(ServiceName, UsePerServerList);
      }
   }

   //
   // Check to make sure we found or added it.  The only way we can fail is
   // if we couldn't alloc memory for it.
   //
   if (Service == NULL)
   {
      ASSERT(FALSE);
      return STATUS_NO_MEMORY;
   }

   if (((LONG) Service->NumberLicenses + Quantity) < 0)
   {
      return STATUS_UNSUCCESSFUL;
   }

   //
   // Update license count in service record
   //
   Service->NumberLicenses += Quantity;

   //
   // Now in master Service Record
   //
   RtlAcquireResourceShared(&MasterServiceListLock, TRUE);
   mService = MasterServiceListFind(ServiceName);

   if (mService != NULL)
   {
      //
      // if we were out of license and added more, then we need to update
      // the user list.
      //
      if (    ( Quantity > 0 )
           && ( (mService->LicensesUsed > mService->Licenses) || (mService == BackOfficeRec) ) )
      {
         ChangeLicense = TRUE;
      }

      //
      // Can only add a number of licenses up to licensed amount
      //
      if ( ChangeLicense )
      {
         // Get current unlicensed delta
         NewLicenses = mService->LicensesUsed - mService->Licenses;

         if ((NewLicenses <= 0) || (NewLicenses > Quantity))
         {
            NewLicenses = Quantity;
         }
      }

      if ( UsePerServerList )
      {
         // this will be done by LicenseAdd() in LocalServerServiceListUpdate()
         // mService->MaxSessionCount += Quantity;
      }
      else
      {
         mService->Licenses += Quantity;
      }

      //
      // if we we subtracted licenses and are out of licenses, then we
      // need to scan the user list.
      //
      if (Quantity < 0)
      {
         if (mService->LicensesUsed > mService->Licenses)
         {
            ChangeLicense = TRUE;

            //
            // Only remove # of licenses past limit
            //
            NewLicenses = mService->Licenses - mService->LicensesUsed;
            if (NewLicenses < Quantity)
            {
               NewLicenses = Quantity;
            }
         }
      }
   }

   RtlReleaseResource(&MasterServiceListLock);

   *ppService      = Service;
   *pChangeLicense = ChangeLicense;
   *pNewLicenses   = NewLicenses;
   *pmService      = mService;

   return STATUS_SUCCESS;
}

#if DBG
/////////////////////////////////////////////////////////////////////////
VOID
LicenseListDebugDump( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;
   ULONG j = 0;

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&LicenseListLock, TRUE);

   //
   // Dump License Service List first
   //
   dprintf(TEXT("Per Seat License Service Table, # Entries: %lu\n"), LicenseServiceListSize);
   if (LicenseServiceList != NULL)
   {
      for (i = 0; i < LicenseServiceListSize; i++)
         dprintf(TEXT("   %2lu) Tot Licenses: %lu Product: %s\n"), i, LicenseServiceList[i]->NumberLicenses, LicenseServiceList[i]->ServiceName);
   }

   dprintf(TEXT("\nPer Server License Service Table, # Entries: %lu\n"), PerServerLicenseServiceListSize);
   if (PerServerLicenseServiceList != NULL)
   {
      for (i = 0; i < PerServerLicenseServiceListSize; i++)
         dprintf(TEXT("   %2lu) Tot Licenses: %lu Product: %s\n"), i, PerServerLicenseServiceList[i]->NumberLicenses, PerServerLicenseServiceList[i]->ServiceName);
   }

   //
   // Now do purchase history
   //
   dprintf(TEXT("\nPurchase History, # Entries: %lu\n"), PurchaseListSize);
   if (PurchaseList != NULL)
   {
      for (i = 0; i < PurchaseListSize; i++)
      {
         TCHAR    szExpirationDate[ 40 ];

         lstrcpy( szExpirationDate, TimeToString( PurchaseList[i].ExpirationDate ) );

         dprintf( TEXT("  %3lu) Product        : %s\n"    )
                  TEXT( "       Vendor         : %s\n"    )
                  TEXT( "       Allowed Modes  :%s%s\n"   )
                  TEXT( "       Licenses       : %d\n"    )
                  TEXT( "       Max Licenses   : %lu\n"   )
                  TEXT( "       Date Entered   : %s\n"    )
                  TEXT( "       Date Expires   : %s\n"    )
                  TEXT( "       Certificate ID : %lu\n"   )
                  TEXT( "       Secrets        :" ),
                  i,
                    ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT )
                  ? PurchaseList[i].Service->ServiceName
                  : PurchaseList[i].PerServerService->ServiceName,
                  PurchaseList[i].Vendor,
                    ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT )
                  ? TEXT(" PERSEAT")
                  : TEXT(""),
                    ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SERVER )
                  ? TEXT(" PERSERVER")
                  : TEXT(""),
                  PurchaseList[i].NumberLicenses,
                  PurchaseList[i].MaxQuantity,
                  TimeToString( PurchaseList[i].Date ),
                  szExpirationDate,
                  PurchaseList[i].CertificateID
                  );

         for ( j=0; j < LLS_NUM_SECRETS; j++ )
         {
            dprintf( TEXT( " %08X" ), PurchaseList[i].Secrets[j] );
         }

         dprintf( TEXT( "\n"                              )
                  TEXT( "       Source         : %s\n"    )
                  TEXT( "       Admin          : %s\n"    )
                  TEXT( "       Comment        : %s\n\n"  ),
                  PurchaseList[i].Source,
                  PurchaseList[i].Admin,
                  PurchaseList[i].Comment
                  );
      }
   }

   RtlReleaseResource(&LicenseListLock);

   return;
} // LicenseListDebugDump

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\registry.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

   Registry.h

Abstract:


Author:

   Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added secure service list.  This list tracks the products that
         require "secure" license certificates for all licenses; i.e., the
         products that do not accept the 3.51 Honesty method of "enter the
         number of licenses you purchased."
      o  Added routine to update the concurrent limit value in the registry
         to accurately reflect the connection limit of secure products.

--*/

#ifndef _LLS_REGISTRY_H
#define _LLS_REGISTRY_H


#ifdef __cplusplus
extern "C" {
#endif


typedef struct _LOCAL_SERVICE_RECORD {
   LPTSTR Name;
   LPTSTR DisplayName;
   LPTSTR FamilyDisplayName;
   DWORD ConcurrentLimit;
   DWORD FlipAllow;
   DWORD Mode;
   ULONG HighMark;
} LOCAL_SERVICE_RECORD, *PLOCAL_SERVICE_RECORD;

extern ULONG LocalServiceListSize;
extern PLOCAL_SERVICE_RECORD *LocalServiceList;
extern RTL_RESOURCE LocalServiceListLock;


VOID RegistryInit( );
VOID RegistryStartMonitor( );
VOID ConfigInfoRegistryInit( DWORD *pReplicationType, DWORD *pReplicationTime, DWORD *pLogLevel, BOOL * pPerServerCapacityWarning );
VOID RegistryInitValues( LPTSTR ServiceName, BOOL *PerSeatLicensing, ULONG *SessionLimit );
VOID RegistryDisplayNameGet( LPTSTR ServiceName, LPTSTR DefaultName, LPTSTR *pDisplayName );
VOID RegistryFamilyDisplayNameGet( LPTSTR ServiceName, LPTSTR DefaultName, LPTSTR *pDisplayName );
VOID RegistryInitService( LPTSTR ServiceName, BOOL *PerSeatLicensing, ULONG *SessionLimit );
LPTSTR ServiceFindInTable( LPTSTR ServiceName, const LPTSTR Table[], ULONG TableSize, ULONG *TableIndex );

NTSTATUS LocalServiceListInit();
PLOCAL_SERVICE_RECORD LocalServiceListFind( LPTSTR Name );
PLOCAL_SERVICE_RECORD LocalServiceListAdd( LPTSTR Name, LPTSTR DisplayName, LPTSTR FamilyDisplayName, DWORD ConcurrentLimit, DWORD FlipAllow, DWORD Mode, DWORD SessLimit );
VOID LocalServiceListUpdate( );
VOID LocalServiceListHighMarkSet( );
VOID LocalServiceListConcurrentLimitSet( );

BOOL     ServiceIsSecure(        LPTSTR ServiceName );
NTSTATUS ServiceSecuritySet(     LPTSTR ServiceName );
NTSTATUS ProductSecurityUnpack(  DWORD   cchProductSecurityStrings,  WCHAR *  pchProductSecurityStrings  );
NTSTATUS ProductSecurityPack(    LPDWORD pcchProductSecurityStrings, WCHAR ** ppchProductSecurityStrings );

#if DBG
void ProductSecurityListDebugDump();
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\repl.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Repl.h

Abstract:


Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

--*/

#ifndef _LLS_REPL_H
#define _LLS_REPL_H


#ifdef __cplusplus
extern "C" {
#endif

//
// Maximum number of records we will send over to the server at once.
//
#define MAX_REPL_SIZE 25
#define REPL_VERSION 0x0102

extern HANDLE ReplicationEvent;


NTSTATUS ReplicationInit();
VOID ReplicationManager ( IN PVOID ThreadParameter );
VOID ReplicationTimeSet ( );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\scaven.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Scaven.h

Abstract:


Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

--*/

#ifndef _LLS_SCAVEN_H
#define _LLS_SCAVEN_H


#ifdef __cplusplus
extern "C" {
#endif


VOID ScavengerInit( );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\rpc.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   rpc.c

Abstract:


Author:

   Arthur Hanson (arth) 06-Jan-1995

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added replication of certificate database and secure service list.
      o  Added Llsr API to support secure certificates.
      o  Added LLS_LICENSE_INFO_1 support to LlsrLicenseEnumW() and
         LlsrLicenseAddW().
      o  Added LLS_PRODUCT_LICENSE_INFO_1 support to LlsrProductLicenseEnumW().
      o  Added save of all data files after receiving replicated data.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dsgetdc.h>

#include "llsapi.h"
#include "debug.h"
#include "llssrv.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "perseat.h"
#include "purchase.h"
#include "server.h"

#include "llsrpc_s.h"
#include "lsapi_s.h"
#include "llsdbg_s.h"
#include "repl.h"
#include "pack.h"
#include "registry.h"
#include "certdb.h"
#include "llsrtl.h"

#define LLS_SIG "LLSS"
#define LLS_SIG_SIZE 4

#define LLS_REPL_SIG "REPL"
#define LLS_REPL_SIG_SIZE 4

extern RTL_RESOURCE                     CertDbHeaderListLock;

typedef struct {
   char Signature[LLS_SIG_SIZE];
   PVOID *ProductUserEnumWRestartTable;
   DWORD ProductUserEnumWRestartTableSize;
   PVOID *UserEnumWRestartTable;
   DWORD UserEnumWRestartTableSize;
   TCHAR Name[MAX_COMPUTERNAME_LENGTH + 1];
} CLIENT_CONTEXT_TYPE, *PCLIENT_CONTEXT_TYPE;

typedef struct {
   char Signature[LLS_REPL_SIG_SIZE];
   TCHAR Name[MAX_COMPUTERNAME_LENGTH + 1];
   DWORD ReplicationStart;

   BOOL Active;
   BOOL Replicated;

   BOOL ServicesSent;
   ULONG ServiceTableSize;
   PREPL_SERVICE_RECORD Services;

   BOOL ServersSent;
   ULONG ServerTableSize;
   PREPL_SERVER_RECORD Servers;

   BOOL ServerServicesSent;
   ULONG ServerServiceTableSize;
   PREPL_SERVER_SERVICE_RECORD ServerServices;

   BOOL UsersSent;
   ULONG UserLevel;
   ULONG UserTableSize;
   LPVOID Users;

   BOOL                                CertDbSent;
   ULONG                               CertDbProductStringSize;
   WCHAR *                             CertDbProductStrings;
   ULONG                               CertDbNumHeaders;
   PREPL_CERT_DB_CERTIFICATE_HEADER_0  CertDbHeaders;
   ULONG                               CertDbNumClaims;
   PREPL_CERT_DB_CERTIFICATE_CLAIM_0   CertDbClaims;

   BOOL     ProductSecuritySent;
   ULONG    ProductSecurityStringSize;
   WCHAR *  ProductSecurityStrings;

} REPL_CONTEXT_TYPE, *PREPL_CONTEXT_TYPE;

//
// This function is obtained from the April 1998 Knowledge Base
// Its purpose is to determine if the current user is an
// Administrator and therefore priveledged to change license
// settings.
//
// BOOL IsAdmin(void)
//
//      returns TRUE if user is an admin
//              FALSE if user is not an admin
//

#if 0
BOOL IsAdmin(void)
{
	HANDLE hAccessToken;
	UCHAR InfoBuffer[1024];
	PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)InfoBuffer;
	DWORD dwInfoBufferSize;
	PSID psidAdministrators;
	SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
	UINT x;
	BOOL bSuccess;

	if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE,
                         &hAccessToken )) {
		if (GetLastError() != ERROR_NO_TOKEN)
			return FALSE;
		//
		// retry against process token if no thread token exists
		//
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY,
                              &hAccessToken))
			return FALSE;
	}

	bSuccess = GetTokenInformation(hAccessToken,TokenGroups,InfoBuffer,
                                   1024, &dwInfoBufferSize);

	CloseHandle(hAccessToken);

	if (!bSuccess )
		return FALSE;

	if (!AllocateAndInitializeSid(&siaNtAuthority, 2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &psidAdministrators))
		return FALSE;

	// assume that we don't find the admin SID.
	bSuccess = FALSE;

	for (x=0;x<ptgGroups->GroupCount;x++) {
		if ( EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) ) {
			bSuccess = TRUE;
			break;
		}

	}
	FreeSid(psidAdministrators);
	return bSuccess;
}
#endif

/////////////////////////////////////////////////////////////////////////
NTSTATUS
LLSRpcListen (
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

Arguments:

    ThreadParameter - Indicates how many active threads there currently
        are.

Return Value:

   None.

--*/

{
   RPC_STATUS Status;

   Status = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, 0);
   if (Status) {
#if DBG
      dprintf(TEXT("RpcServerListen Failed (0x%lx)\n"), Status);
#endif
   }

   return Status;

} // LLSRpcListen


/////////////////////////////////////////////////////////////////////////
VOID
LLSRpcInit()

/*++

Routine Description:


Arguments:

Return Value:

   None.

--*/

{
   RPC_STATUS Status;
   DWORD Ignore;
   HANDLE Thread;

   //
   // Setup for LPC calls..
   //
   Status = RpcServerUseProtseqEp(TEXT("ncalrpc"), RPC_C_PROTSEQ_MAX_REQS_DEFAULT, TEXT(LLS_LPC_ENDPOINT), NULL);
   if (Status) {
#if DBG
      dprintf(TEXT("RpcServerUseProtseq ncalrpc Failed (0x%lx)\n"), Status);
#endif

      return;
   }

   // Named pipes as well
   Status =  RpcServerUseProtseqEp(TEXT("ncacn_np"), RPC_C_PROTSEQ_MAX_REQS_DEFAULT, TEXT(LLS_NP_ENDPOINT), NULL);
   if (Status) {
#if DBG
      dprintf(TEXT("RpcServerUseProtseq ncacn_np Failed (0x%lx)\n"), Status);
#endif

      return;
   }

   // register the interface for the UI RPC's
   Status = RpcServerRegisterIf(llsrpc_ServerIfHandle, NULL, NULL);
   if (Status) {
#if DBG
      dprintf(TEXT("RpcServerRegisterIf Failed (0x%lx)\n"), Status);
#endif
      return;
   }

   // Now the interface for the Licensing RPC's
   Status = RpcServerRegisterIf(lsapirpc_ServerIfHandle, NULL, NULL);
   if (Status) {
#if DBG
      dprintf(TEXT("RpcServerRegisterIf2 Failed (0x%lx)\n"), Status);
#endif
      return;
   }

#if DBG
   //
   // ... and if DEBUG then the debugging interface
   //
   Status = RpcServerRegisterIf(llsdbgrpc_ServerIfHandle, NULL, NULL);
   if (Status) {
#if DBG
      dprintf(TEXT("RpcServerRegisterIf (debug) Failed (0x%lx)\n"), Status);
#endif
      return;
   }
#endif

   //
   // Create thread to listen for requests.
   //
   Thread = CreateThread(
                         NULL,
                         0L,
                         (LPTHREAD_START_ROUTINE) LLSRpcListen,
                         0L,
                         0L,
                         &Ignore
                         );

#if DBG
   if (NULL == Thread) {
      dprintf(TEXT("CreateThread Failed\n"));
   }
#endif

   if (NULL != Thread)
       CloseHandle(Thread);

} // LLSRpcInit



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
VOID __RPC_USER LLS_HANDLE_rundown(
   LLS_HANDLE Handle
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    PCLIENT_CONTEXT_TYPE pClient;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LLS_HANDLE_rundown\n"));
#endif

   pClient = (PCLIENT_CONTEXT_TYPE) Handle;

   if (0 != memcmp(pClient->Signature,LLS_SIG,LLS_SIG_SIZE))
   {
       return;
   }

   if (NULL != pClient->ProductUserEnumWRestartTable)
       LocalFree(pClient->ProductUserEnumWRestartTable);
   if (NULL != pClient->UserEnumWRestartTable)
       LocalFree(pClient->UserEnumWRestartTable);

   //
   // Deallocate context.
   //

   midl_user_free(Handle);

} // LLS_HANDLE_rundown


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrConnect(
    PLLS_HANDLE Handle,
    LPTSTR Name
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   CLIENT_CONTEXT_TYPE *pClient;
   RPC_STATUS Status = STATUS_SUCCESS;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsConnect: %s\n"), Name);
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (NULL == Handle)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *Handle = NULL;

   pClient = (CLIENT_CONTEXT_TYPE *) midl_user_allocate(sizeof(CLIENT_CONTEXT_TYPE));

   if (NULL == pClient)
   {
#if DBG
      dprintf(TEXT("midl_user_allocate Failed\n"));
#endif
      Status = STATUS_NO_MEMORY;
      goto LlsrConnectExit;
   }

   if (Name != NULL)
   {
      if (lstrlen(Name) > MAX_COMPUTERNAME_LENGTH)
      {
         Status = STATUS_INVALID_PARAMETER;
         midl_user_free(pClient);
         goto LlsrConnectExit;
      }

      lstrcpy(pClient->Name, Name);
   }
   else
      lstrcpy(pClient->Name, TEXT(""));

   memcpy(pClient->Signature,LLS_SIG,LLS_SIG_SIZE);

   pClient->ProductUserEnumWRestartTable = NULL;
   pClient->ProductUserEnumWRestartTableSize = 0;
   pClient->UserEnumWRestartTable = NULL;
   pClient->UserEnumWRestartTableSize = 0;

   *Handle = pClient;

LlsrConnectExit:

   return Status;
} // LlsrConnect


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrClose(
    LLS_HANDLE Handle
    )

/*++

Routine Description:
        Obsolete - use LlsrCloseEx

Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsClose\n"));
#endif

   //
   // Don't do anything; let rundown do cleanup
   // We have no way of telling RPC system the handle can't be used
   //
   return STATUS_SUCCESS;
} // LlsrClose


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrCloseEx(
    LLS_HANDLE * pHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsCloseEx\n"));
#endif

   if ((pHandle != NULL) && (*pHandle != NULL))
   {
       LLS_HANDLE_rundown(*pHandle);

       *pHandle = NULL;
   }

   return STATUS_SUCCESS;
} // LlsrCloseEx


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrLicenseEnumW(
    LLS_HANDLE Handle,
    PLLS_LICENSE_ENUM_STRUCTW pLicenseInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS    Status = STATUS_SUCCESS;
   DWORD       Level;
   PVOID       BufPtr = NULL;
   ULONG       BufSize = 0;
   ULONG       EntriesRead = 0;
   ULONG       TotalEntries = 0;
   ULONG       i = 0;
   ULONG       j = 0;
   DWORD       RecordSize;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLicenseEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&LicenseListLock, TRUE);

   if ((NULL == pLicenseInfo) || (NULL == pTotalEntries))
   {
       return STATUS_INVALID_PARAMETER;
   }

   Level = pLicenseInfo->Level;

   *pTotalEntries = 0;

   if ( 0 == Level )
   {
       if (NULL == pLicenseInfo->LlsLicenseInfo.Level0)
       {
           return STATUS_INVALID_PARAMETER;
       }

      RecordSize = sizeof( LLS_LICENSE_INFO_0W );
   }
   else if ( 1 == Level )
   {
       if (NULL == pLicenseInfo->LlsLicenseInfo.Level1)
       {
           return STATUS_INVALID_PARAMETER;
       }

      RecordSize = sizeof( LLS_LICENSE_INFO_1W );
   }
   else
   {
      return STATUS_INVALID_LEVEL;
   }

   //
   // Calculate how many records will fit into PrefMaxLen buffer.
   //
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;
   while ( ( i < PurchaseListSize ) && ( BufSize < pPrefMaxLen ) )
   {
      if (    ( Level > 0 )
           || ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT ) )
      {
         BufSize += RecordSize;
         EntriesRead++;
      }

      i++;
   }

   TotalEntries = EntriesRead;

   //
   // If we overflowed the buffer then back up one record.
   //
   if (BufSize > pPrefMaxLen)
   {
      BufSize -= RecordSize;
      EntriesRead--;
   }

   //
   // Now walk to the end of the list to see how many more records are still
   // available.
   //
   while ( i < PurchaseListSize )
   {
      if (    ( Level > 0 )
           || ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT ) )
      {
         TotalEntries++;
      }

      i++;
   }

   if (TotalEntries > EntriesRead)
      Status = STATUS_MORE_ENTRIES;

   //
   // Reset Enum to correct place.
   //
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;

   //
   // We now know how many records will fit into the buffer, so allocate space
   // and fix up pointers so we can copy the information.
   //
   BufPtr = MIDL_user_allocate(BufSize);
   if (BufPtr == NULL) {
      Status = STATUS_NO_MEMORY;
      goto LlsrLicenseEnumWExit;
   }

   RtlZeroMemory((PVOID) BufPtr, BufSize);

   //
   // Buffers are all setup, so loop through records and copy the data.
   //
   while ((j < EntriesRead) && (i < PurchaseListSize))
   {
      if (    ( Level > 0 )
           || ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT ) )
      {
         if ( 0 == Level )
         {
            ((PLLS_LICENSE_INFO_0W) BufPtr)[j].Product       = PurchaseList[i].Service->ServiceName;
            ((PLLS_LICENSE_INFO_0W) BufPtr)[j].Quantity      = PurchaseList[i].NumberLicenses;
            ((PLLS_LICENSE_INFO_0W) BufPtr)[j].Date          = PurchaseList[i].Date;
            ((PLLS_LICENSE_INFO_0W) BufPtr)[j].Admin         = PurchaseList[i].Admin;
            ((PLLS_LICENSE_INFO_0W) BufPtr)[j].Comment       = PurchaseList[i].Comment;
         }
         else
         {
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].Product        = ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT )
                                                                  ? PurchaseList[i].Service->ServiceName
                                                                  : PurchaseList[i].PerServerService->ServiceName;
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].Vendor         = PurchaseList[i].Vendor;
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].Quantity       = PurchaseList[i].NumberLicenses;
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].MaxQuantity    = PurchaseList[i].MaxQuantity;
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].Date           = PurchaseList[i].Date;
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].Admin          = PurchaseList[i].Admin;
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].Comment        = PurchaseList[i].Comment;
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].AllowedModes   = PurchaseList[i].AllowedModes;
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].CertificateID  = PurchaseList[i].CertificateID;
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].Source         = PurchaseList[i].Source;
            ((PLLS_LICENSE_INFO_1W) BufPtr)[j].ExpirationDate = PurchaseList[i].ExpirationDate;
            memcpy( ((PLLS_LICENSE_INFO_1W) BufPtr)[j].Secrets, PurchaseList[i].Secrets, LLS_NUM_SECRETS * sizeof( *PurchaseList[i].Secrets ) );
         }

         j++;
      }

      i++;
   }

LlsrLicenseEnumWExit:
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("   TotalEntries: %lu EntriesRead: %lu ResumeHandle: 0x%lX\n"), TotalEntries, EntriesRead, i);
#endif
   *pTotalEntries = TotalEntries;

   if (pResumeHandle != NULL)
      *pResumeHandle = (ULONG) i;

   if ( 0 == Level )
   {
      pLicenseInfo->LlsLicenseInfo.Level0->EntriesRead = EntriesRead;
      pLicenseInfo->LlsLicenseInfo.Level0->Buffer = (PLLS_LICENSE_INFO_0W) BufPtr;
   }
   else
   {
      pLicenseInfo->LlsLicenseInfo.Level1->EntriesRead = EntriesRead;
      pLicenseInfo->LlsLicenseInfo.Level1->Buffer = (PLLS_LICENSE_INFO_1W) BufPtr;
   }

   return Status;
} // LlsrLicenseEnumW

void LlsrLicenseEnumW_notify_flag(
                                  boolean fNotify
                                  )
{
    if (fNotify)
    {
        RtlReleaseResource(&LicenseListLock);
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrLicenseEnumA(
    LLS_HANDLE Handle,
    PLLS_LICENSE_ENUM_STRUCTA LicenseInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLicenseEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrLicenseEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrLicenseAddW(
    LLS_HANDLE          Handle,
    DWORD               Level,
    PLLS_LICENSE_INFOW  BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;
   RPC_STATUS rpcstat;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLicenseAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

#if 0
   //
   // Check that client is an administrator
   //
   rpcstat = RpcImpersonateClient(0);
   if (rpcstat != RPC_S_OK)
   {
       return STATUS_ACCESS_DENIED;
   }

   if (!IsAdmin())
   {
       RpcRevertToSelf();
       return STATUS_ACCESS_DENIED;
   }

   RpcRevertToSelf();
#endif

   if ( 0 == Level )
   {
      if (    ( NULL == BufPtr                        )
           || ( NULL == BufPtr->LicenseInfo0.Product  )
           || ( NULL == BufPtr->LicenseInfo0.Admin    )
           || ( NULL == BufPtr->LicenseInfo0.Comment  )  )
      {
         Status = STATUS_INVALID_PARAMETER;
      }
      else
      {
         Status = LicenseAdd( BufPtr->LicenseInfo0.Product,
                              TEXT("Microsoft"),
                              BufPtr->LicenseInfo0.Quantity,
                              0,
                              BufPtr->LicenseInfo0.Admin,
                              BufPtr->LicenseInfo0.Comment,
                              0,
                              LLS_LICENSE_MODE_ALLOW_PER_SEAT,
                              0,
                              TEXT("None"),
                              0,
                              NULL );
      }
   }
   else if ( 1 == Level )
   {
      if (    ( NULL == BufPtr                        )
           || ( NULL == BufPtr->LicenseInfo1.Product  )
           || ( NULL == BufPtr->LicenseInfo1.Admin    )
           || ( NULL == BufPtr->LicenseInfo1.Comment  )
           || ( 0    == BufPtr->LicenseInfo1.Quantity )
           || ( 0    == (   BufPtr->LicenseInfo1.AllowedModes
                          & (   LLS_LICENSE_MODE_ALLOW_PER_SERVER
                              | LLS_LICENSE_MODE_ALLOW_PER_SEAT   ) ) ) )
      {
         Status = STATUS_INVALID_PARAMETER;
      }
      else
      {
         // check to see if this certificate is already maxed out in the enterprise
         BOOL                                      bIsMaster                        = TRUE;
         BOOL                                      bMayInstall                      = TRUE;
         HINSTANCE                                 hDll                             = NULL;
         PLLS_CONNECT_ENTERPRISE_W                 pLlsConnectEnterpriseW           = NULL;
         PLLS_CLOSE                                pLlsClose                        = NULL;
         PLLS_CAPABILITY_IS_SUPPORTED              pLlsCapabilityIsSupported        = NULL;
         PLLS_CERTIFICATE_CLAIM_ADD_CHECK_W        pLlsCertificateClaimAddCheckW    = NULL;
         PLLS_CERTIFICATE_CLAIM_ADD_W              pLlsCertificateClaimAddW         = NULL;
         PLLS_FREE_MEMORY                          pLlsFreeMemory                   = NULL;
         LLS_HANDLE                                hEnterpriseLls                   = NULL;
         TCHAR                                     szComputerName[ 1 + MAX_COMPUTERNAME_LENGTH ];

         szComputerName[0] = 0;

         ConfigInfoUpdate(NULL);

         RtlEnterCriticalSection( &ConfigInfoLock );
         bIsMaster = ConfigInfo.IsMaster;
         if (ConfigInfo.ComputerName != NULL)
             lstrcpy( szComputerName, ConfigInfo.ComputerName );
         RtlLeaveCriticalSection( &ConfigInfoLock );

         if( !bIsMaster && ( 0 != BufPtr->LicenseInfo1.CertificateID ) )
         {
            // ask enterprise server if we can install this certfificate
            hDll = LoadLibraryA( "LLSRPC.DLL" );

            if ( NULL == hDll )
            {
               // LLSRPC.DLL should be available!
               ASSERT( FALSE );
            }
            else
            {
               pLlsConnectEnterpriseW         = (PLLS_CONNECT_ENTERPRISE_W          ) GetProcAddress( hDll, "LlsConnectEnterpriseW" );
               pLlsClose                      = (PLLS_CLOSE                         ) GetProcAddress( hDll, "LlsClose" );
               pLlsCapabilityIsSupported      = (PLLS_CAPABILITY_IS_SUPPORTED       ) GetProcAddress( hDll, "LlsCapabilityIsSupported" );
               pLlsCertificateClaimAddCheckW  = (PLLS_CERTIFICATE_CLAIM_ADD_CHECK_W ) GetProcAddress( hDll, "LlsCertificateClaimAddCheckW" );
               pLlsCertificateClaimAddW       = (PLLS_CERTIFICATE_CLAIM_ADD_W       ) GetProcAddress( hDll, "LlsCertificateClaimAddW" );
               pLlsFreeMemory                 = (PLLS_FREE_MEMORY                   ) GetProcAddress( hDll, "LlsFreeMemory" );

               if (    ( NULL == pLlsConnectEnterpriseW        )
                    || ( NULL == pLlsClose                     )
                    || ( NULL == pLlsCapabilityIsSupported     )
                    || ( NULL == pLlsCertificateClaimAddCheckW )
                    || ( NULL == pLlsCertificateClaimAddW      )
                    || ( NULL == pLlsFreeMemory                ) )
               {
                  // All of these functions should be exported!
                  ASSERT( FALSE );
               }
               else
               {
                  PLLS_CONNECT_INFO_0  pConnectInfo;

                  Status = (*pLlsConnectEnterpriseW)( NULL, &hEnterpriseLls, 0, (LPBYTE *)&pConnectInfo );

                  if ( STATUS_SUCCESS == Status )
                  {
                     (*pLlsFreeMemory)( pConnectInfo );

                     if ( (*pLlsCapabilityIsSupported)( hEnterpriseLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) )
                     {
                        Status = (*pLlsCertificateClaimAddCheckW)( hEnterpriseLls, Level, (LPBYTE) BufPtr, &bMayInstall );

                        if ( STATUS_SUCCESS != Status )
                        {
                           bMayInstall = TRUE;
                        }
                     }
                  }
               }
            }
         }

         if ( !bMayInstall )
         {
            // denied!
            Status = STATUS_ALREADY_COMMITTED;
         }
         else
         {
            // approved! (or an error occurred trying to get approval...)
            Status = LicenseAdd( BufPtr->LicenseInfo1.Product,
                                 BufPtr->LicenseInfo1.Vendor,
                                 BufPtr->LicenseInfo1.Quantity,
                                 BufPtr->LicenseInfo1.MaxQuantity,
                                 BufPtr->LicenseInfo1.Admin,
                                 BufPtr->LicenseInfo1.Comment,
                                 0,
                                 BufPtr->LicenseInfo1.AllowedModes,
                                 BufPtr->LicenseInfo1.CertificateID,
                                 BufPtr->LicenseInfo1.Source,
                                 BufPtr->LicenseInfo1.ExpirationDate,
                                 BufPtr->LicenseInfo1.Secrets );

            if (    ( STATUS_SUCCESS == Status )
                 && ( NULL != hEnterpriseLls   )
                 && ( (*pLlsCapabilityIsSupported)( hEnterpriseLls, LLS_CAPABILITY_SECURE_CERTIFICATES ) ) )
            {
               // certificate successfully installed on this machine; register it
               (*pLlsCertificateClaimAddW)( hEnterpriseLls, szComputerName, Level, (LPBYTE) BufPtr );
            }
         }

         if ( NULL != hEnterpriseLls )
         {
            (*pLlsClose)( hEnterpriseLls );
         }

         if ( NULL != hDll )
         {
            FreeLibrary( hDll );
         }
      }
   }
   else
   {
      Status = STATUS_INVALID_LEVEL;
   }


   if ( STATUS_SUCCESS == Status )
   {
      Status = LicenseListSave();
   }

   return Status;
} // LlsrLicenseAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrLicenseAddA(
    LLS_HANDLE Handle,
    DWORD Level,
    PLLS_LICENSE_INFOA BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLicenseAddA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrLicenseAddA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductEnumW(
    LLS_HANDLE Handle,
    PLLS_PRODUCT_ENUM_STRUCTW pProductInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   DWORD Level;
   ULONG RecSize;
   PVOID BufPtr = NULL;
   ULONG BufSize = 0;
   ULONG EntriesRead = 0;
   ULONG TotalEntries = 0;
   ULONG i = 0;
   ULONG j = 0;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&MasterServiceListLock, TRUE);

   if ((NULL == pTotalEntries) || (NULL == pProductInfo))
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pTotalEntries = 0;

   //
   // Get size of each record based on info level.  Only 0 and 1 supported.
   //
   Level = pProductInfo->Level;
   if (Level == 0)
   {
       if (NULL == pProductInfo->LlsProductInfo.Level0)
       {
           return STATUS_INVALID_PARAMETER;
       }

      RecSize = sizeof(LLS_PRODUCT_INFO_0W);
   }
   else if (Level == 1)
   {
       if (NULL == pProductInfo->LlsProductInfo.Level1)
       {
           return STATUS_INVALID_PARAMETER;
       }

      RecSize = sizeof(LLS_PRODUCT_INFO_1W);
   }
   else {
      return STATUS_INVALID_LEVEL;
   }

   //
   // Calculate how many records will fit into PrefMaxLen buffer.  This is
   // the record size * # records + space for the string data.  If MAX_ULONG
   // is passed in then we return all records.
   //
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;
   while ((i < MasterServiceListSize) && (BufSize < pPrefMaxLen)) {
      BufSize += RecSize;
      EntriesRead++;

      i++;
   }

   TotalEntries = EntriesRead;

   //
   // If we overflowed the buffer then back up one record.
   //
   if (BufSize > pPrefMaxLen) {
     BufSize -= RecSize;
     EntriesRead--;
   }

   if (i < MasterServiceListSize)
      Status = STATUS_MORE_ENTRIES;

   //
   // Now walk to the end of the list to see how many more records are still
   // available.
   //
   TotalEntries += (MasterServiceListSize - i);

   //
   // Reset Enum to correct place.
   //
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;

   //
   // We now know how many records will fit into the buffer, so allocate space
   // and fix up pointers so we can copy the information.
   //
   BufPtr = MIDL_user_allocate(BufSize);
   if (BufPtr == NULL) {
      Status = STATUS_NO_MEMORY;
      goto LlsrProductEnumWExit;
   }

   RtlZeroMemory((PVOID) BufPtr, BufSize);

   //
   // Buffers are all setup, so loop through records and copy the data.
   //
   while ((j < EntriesRead) && (i < MasterServiceListSize)) {
      if (Level == 0)
         ((PLLS_PRODUCT_INFO_0) BufPtr)[j].Product = MasterServiceList[i]->Name;
      else {
         ((PLLS_PRODUCT_INFO_1) BufPtr)[j].Product = MasterServiceList[i]->Name;
         ((PLLS_PRODUCT_INFO_1) BufPtr)[j].Purchased = MasterServiceList[i]->Licenses;
         ((PLLS_PRODUCT_INFO_1) BufPtr)[j].InUse = MasterServiceList[i]->LicensesUsed;
         ((PLLS_PRODUCT_INFO_1) BufPtr)[j].ConcurrentTotal = MasterServiceList[i]->MaxSessionCount;
         ((PLLS_PRODUCT_INFO_1) BufPtr)[j].HighMark = MasterServiceList[i]->HighMark;
      }

      i++; j++;
   }

LlsrProductEnumWExit:
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("   TotalEntries: %lu EntriesRead: %lu ResumeHandle: 0x%lX\n"), TotalEntries, EntriesRead, i);
#endif
   *pTotalEntries = TotalEntries;

   if (pResumeHandle != NULL)
      *pResumeHandle = (ULONG) i;

   if (Level == 0) {
      pProductInfo->LlsProductInfo.Level0->EntriesRead = EntriesRead;
      pProductInfo->LlsProductInfo.Level0->Buffer = (PLLS_PRODUCT_INFO_0W) BufPtr;
   } else {
      pProductInfo->LlsProductInfo.Level1->EntriesRead = EntriesRead;
      pProductInfo->LlsProductInfo.Level1->Buffer = (PLLS_PRODUCT_INFO_1W) BufPtr;
   }

   return Status;

} // LlsrProductEnumW

void LlsrProductEnumW_notify_flag(
                                  boolean fNotify
                                  )
{
    if (fNotify)
    {
        RtlReleaseResource(&MasterServiceListLock);
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductEnumA(
    LLS_HANDLE Handle,
    PLLS_PRODUCT_ENUM_STRUCTA ProductInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrProductEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductAddW(
    LLS_HANDLE Handle,
    LPWSTR ProductFamily,
    LPWSTR Product,
    LPWSTR lpVersion
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   PMASTER_SERVICE_RECORD Service;
   DWORD Version;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ((ProductFamily == NULL) || (Product == NULL) || (lpVersion == NULL))
      return STATUS_INVALID_PARAMETER;

   Version = VersionToDWORD(lpVersion);
   RtlAcquireResourceExclusive(&MasterServiceListLock,TRUE);
   Service = MasterServiceListAdd(ProductFamily, Product, Version);
   RtlReleaseResource(&MasterServiceListLock);

   if (Service == NULL)
      return STATUS_NO_MEMORY;

   return STATUS_SUCCESS;
} // LlsrProductAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductAddA(
    LLS_HANDLE Handle,
    IN LPSTR ProductFamily,
    IN LPSTR Product,
    IN LPSTR Version
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductAddA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrProductAddA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductUserEnumW(
    LLS_HANDLE Handle,
    LPWSTR Product,
    PLLS_PRODUCT_USER_ENUM_STRUCTW pProductUserInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   DWORD Level;
   ULONG RecSize;
   PVOID BufPtr = NULL;
   ULONG BufSize = 0;
   ULONG EntriesRead = 0;
   ULONG TotalEntries = 0;
   ULONG i = 0;
   PUSER_RECORD UserRec = NULL;
   PVOID RestartKey = NULL, RestartKeySave = NULL;
   PSVC_RECORD pService;
   DWORD Flags;
   ULONG j, AccessCount;
   DWORD LastAccess;
   PCLIENT_CONTEXT_TYPE pClient;
   PVOID *pTableTmp;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductUserEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   RtlAcquireResourceShared(&UserListLock, TRUE);

   if ((Product == NULL) || (NULL == pTotalEntries))
      return STATUS_INVALID_PARAMETER;

   *pTotalEntries = 0;

   //
   // Reset Enum to correct place.
   //
   if (pResumeHandle != NULL)
   {
       if (NULL == Handle)
           return STATUS_INVALID_PARAMETER;

       pClient = (PCLIENT_CONTEXT_TYPE) Handle;

       if (0 != memcmp(pClient->Signature,LLS_SIG,LLS_SIG_SIZE))
       {
           return STATUS_INVALID_PARAMETER;
       }

       if (*pResumeHandle != 0)
       {
           if ((NULL == pClient->ProductUserEnumWRestartTable)
               || (*pResumeHandle >= pClient->ProductUserEnumWRestartTableSize))
           {
               return STATUS_INVALID_PARAMETER;
           }

           RestartKey = RestartKeySave = pClient->ProductUserEnumWRestartTable[(*pResumeHandle)-1];
       }
   }

   UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);

   //
   // Get size of each record based on info level.  Only 0 and 1 supported.
   //
   Level = pProductUserInfo->Level;
   if (Level == 0)
   {
       if (NULL == pProductUserInfo->LlsProductUserInfo.Level0)
       {
           return STATUS_INVALID_PARAMETER;
       }

      RecSize = sizeof(LLS_PRODUCT_USER_INFO_0);
   }
   else if (Level == 1)
   {
       if (NULL == pProductUserInfo->LlsProductUserInfo.Level1)
       {
           return STATUS_INVALID_PARAMETER;
       }

      RecSize = sizeof(LLS_PRODUCT_USER_INFO_1);
   }
   else {
      return STATUS_INVALID_LEVEL;
   }

   //
   // Calculate how many records will fit into PrefMaxLen buffer.  This is
   // the record size * # records + space for the string data.  If MAX_ULONG
   // is passed in then we return all records.
   //
   if (lstrcmpi(Product, BackOfficeStr))
      while ((UserRec != NULL) && (BufSize < pPrefMaxLen)) {
         if ( !(UserRec->Flags & LLS_FLAG_DELETED) ) {
            RtlEnterCriticalSection(&UserRec->ServiceTableLock);
            pService = SvcListFind( Product, UserRec->Services, UserRec->ServiceTableSize );
            RtlLeaveCriticalSection(&UserRec->ServiceTableLock);

            if (pService != NULL) {
               BufSize += RecSize;
               EntriesRead++;
            }
         }

         // Get next record
         UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);
      }
   else
      while ((UserRec != NULL) && (BufSize < pPrefMaxLen)) {
         if (UserRec->Mapping != NULL)
            Flags = UserRec->Mapping->Flags;
         else
            Flags = UserRec->Flags;

         if (!(UserRec->Flags & LLS_FLAG_DELETED))
            if (Flags & LLS_FLAG_SUITE_USE) {
               BufSize += RecSize;
               EntriesRead++;
            }

         // Get next record
         UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);
      }

   TotalEntries = EntriesRead;

   //
   // If we overflowed the buffer then back up one record.
   //
   if (BufSize > pPrefMaxLen) {
     BufSize -= RecSize;
     EntriesRead--;
   }

   if (UserRec != NULL)
      Status = STATUS_MORE_ENTRIES;

   //
   // Now walk to the end of the list to see how many more records are still
   // available.
   //
   while (UserRec != NULL) {
      TotalEntries++;

      UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);
   }

   //
   // Reset Enum to correct place.
   //
   RestartKey = RestartKeySave;
   UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);

   //
   // We now know how many records will fit into the buffer, so allocate space
   // and fix up pointers so we can copy the information.
   //
   BufPtr = MIDL_user_allocate(BufSize);
   if (BufPtr == NULL) {
      Status = STATUS_NO_MEMORY;
      goto LlsrProductUserEnumWExit;
   }

   RtlZeroMemory((PVOID) BufPtr, BufSize);

   //
   // Buffers are all setup, so loop through records and copy the data.
   //
   if (lstrcmpi(Product, BackOfficeStr))
      while ((i < EntriesRead) && (UserRec != NULL)) {
         if (!(UserRec->Flags & LLS_FLAG_DELETED)) {
            RtlEnterCriticalSection(&UserRec->ServiceTableLock);
            pService = SvcListFind( Product, UserRec->Services, UserRec->ServiceTableSize );
            if (pService != NULL) {

               if (Level == 0)
                  ((PLLS_PRODUCT_USER_INFO_0) BufPtr)[i].User = (LPTSTR) UserRec->UserID;
               else {
                  ((PLLS_PRODUCT_USER_INFO_1) BufPtr)[i].User = (LPTSTR) UserRec->UserID;
                  ((PLLS_PRODUCT_USER_INFO_1) BufPtr)[i].Flags = pService->Flags;
                  ((PLLS_PRODUCT_USER_INFO_1) BufPtr)[i].LastUsed = pService->LastAccess;
                  ((PLLS_PRODUCT_USER_INFO_1) BufPtr)[i].UsageCount = pService->AccessCount;
               }

               i++;
            }

            RtlLeaveCriticalSection(&UserRec->ServiceTableLock);
         }

         UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);
      }
   else
      while ((i < EntriesRead) && (UserRec != NULL)) {
         if (!(UserRec->Flags & LLS_FLAG_DELETED)) {
            if (UserRec->Mapping != NULL)
               Flags = UserRec->Mapping->Flags;
            else
               Flags = UserRec->Flags;

            if (!(UserRec->Flags & LLS_FLAG_DELETED))
               if (Flags & LLS_FLAG_SUITE_USE) {
                  AccessCount = 0;
                  LastAccess = 0;

                  RtlEnterCriticalSection(&UserRec->ServiceTableLock);
                  for (j = 0; j < UserRec->ServiceTableSize; j++) {
                     if (UserRec->Services[j].LastAccess > LastAccess)
                        LastAccess = UserRec->Services[j].LastAccess;

                     if (UserRec->Services[j].AccessCount > AccessCount)
                        AccessCount = UserRec->Services[j].AccessCount;
                  }

                  RtlLeaveCriticalSection(&UserRec->ServiceTableLock);
                  if (Level == 0)
                     ((PLLS_PRODUCT_USER_INFO_0) BufPtr)[i].User = (LPTSTR) UserRec->UserID;
                  else {
                     ((PLLS_PRODUCT_USER_INFO_1) BufPtr)[i].User = (LPTSTR) UserRec->UserID;
                     ((PLLS_PRODUCT_USER_INFO_1) BufPtr)[i].Flags = UserRec->Flags;
                     ((PLLS_PRODUCT_USER_INFO_1) BufPtr)[i].LastUsed = LastAccess;
                     ((PLLS_PRODUCT_USER_INFO_1) BufPtr)[i].UsageCount = AccessCount;
                  }

                  i++;
               }

         }

         UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);
      }

LlsrProductUserEnumWExit:
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("   TotalEntries: %lu EntriesRead: %lu ResumeHandle: 0x%lX\n"), TotalEntries, EntriesRead, RestartKey);
#endif
   *pTotalEntries = TotalEntries;

   if (pResumeHandle != NULL)
   {
       if (NULL == pClient->ProductUserEnumWRestartTable)
       {
           pTableTmp = (PVOID *) LocalAlloc(LPTR,sizeof(PVOID));
       } else
       {
           pTableTmp = (PVOID *) LocalReAlloc(pClient->ProductUserEnumWRestartTable,sizeof(PVOID) * (pClient->ProductUserEnumWRestartTableSize + 1),LHND);
       }

       if (NULL == pTableTmp)
       {
           if (BufPtr != NULL)
           {
               MIDL_user_free(BufPtr);
           }

           return STATUS_NO_MEMORY;
       } else {
           pClient->ProductUserEnumWRestartTable = pTableTmp;
       }

      pClient->ProductUserEnumWRestartTable[pClient->ProductUserEnumWRestartTableSize++] = RestartKey;

      *pResumeHandle = pClient->ProductUserEnumWRestartTableSize;
   }

   pProductUserInfo->LlsProductUserInfo.Level0->EntriesRead = EntriesRead;
   pProductUserInfo->LlsProductUserInfo.Level0->Buffer = (PLLS_PRODUCT_USER_INFO_0W) BufPtr;

   return Status;
} // LlsrProductUserEnumW

void LlsrProductUserEnumW_notify_flag(
                                      boolean fNotify
                                      )
{
    if (fNotify)
    {
        RtlReleaseResource(&UserListLock);
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductUserEnumA(
    LLS_HANDLE Handle,
    LPSTR Product,
    PLLS_PRODUCT_USER_ENUM_STRUCTA ProductUserInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductUserEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrProductUserEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductServerEnumW(
    LLS_HANDLE Handle,
    LPTSTR Product,
    PLLS_SERVER_PRODUCT_ENUM_STRUCTW pProductServerInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   DWORD Level;
   ULONG RecSize;
   PVOID BufPtr = NULL;
   ULONG BufSize = 0;
   ULONG EntriesRead = 0;
   ULONG TotalEntries = 0;
   ULONG i = 0;
   ULONG j;
   ULONG RestartKey = 0;
   PSERVER_SERVICE_RECORD pSvc;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductServerEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   RtlAcquireResourceShared(&ServerListLock, TRUE);

   if ((Product == NULL) || (NULL == pTotalEntries) || (NULL == pProductServerInfo))
      return STATUS_INVALID_PARAMETER;

   *pTotalEntries = 0;

   //
   // Reset Enum to correct place.
   //
   RestartKey = (ULONG) (pResumeHandle != NULL) ? *pResumeHandle : 0;

   //
   // Get size of each record based on info level.  Only 0 and 1 supported.
   //
   Level = pProductServerInfo->Level;

   if (Level == 0)
   {
      if (pProductServerInfo->LlsServerProductInfo.Level0 == NULL)
      {
          return STATUS_INVALID_PARAMETER;
      }
      RecSize = sizeof(LLS_SERVER_PRODUCT_INFO_0);
   }
   else if (Level == 1)
   {
      if (pProductServerInfo->LlsServerProductInfo.Level1 == NULL)
      {
          return STATUS_INVALID_PARAMETER;
      }
      RecSize = sizeof(LLS_SERVER_PRODUCT_INFO_1);
   }
   else {
      return STATUS_INVALID_LEVEL;
   }


   //
   // Calculate how many records will fit into PrefMaxLen buffer.  This is
   // the record size * # records + space for the string data.  If MAX_ULONG
   // is passed in then we return all records.
   //

   RtlAcquireResourceShared(&MasterServiceListLock,TRUE); // required for ServerServiceListFind

   for (i = RestartKey; i < ServerListSize; i++) {
      pSvc = ServerServiceListFind( Product, ServerList[i]->ServiceTableSize, ServerList[i]->Services );

      if (pSvc != NULL) {
         BufSize += RecSize;
         EntriesRead++;
      }

   }

   RtlReleaseResource(&MasterServiceListLock);

   TotalEntries = EntriesRead;

   //
   // We now know how many records will fit into the buffer, so allocate space
   // and fix up pointers so we can copy the information.
   //
   BufPtr = MIDL_user_allocate(BufSize);
   if (BufPtr == NULL) {
      Status = STATUS_NO_MEMORY;
      goto LlsrProductServerEnumWExit;
   }

   RtlZeroMemory((PVOID) BufPtr, BufSize);

   //
   // Buffers are all setup, so loop through records and copy the data.
   //
   j = 0;

   RtlAcquireResourceShared(&MasterServiceListLock,TRUE); // required for ServerServiceListFind
   for (i = RestartKey; i < ServerListSize; i++) {
      pSvc = ServerServiceListFind( Product, ServerList[i]->ServiceTableSize, ServerList[i]->Services );

      if (pSvc != NULL) {

         if (Level == 0)
            ((PLLS_SERVER_PRODUCT_INFO_0) BufPtr)[j].Name = ServerList[i]->Name;
         else {
            ((PLLS_SERVER_PRODUCT_INFO_1) BufPtr)[j].Name = ServerList[i]->Name;
            ((PLLS_SERVER_PRODUCT_INFO_1) BufPtr)[j].Flags = pSvc->Flags;
            ((PLLS_SERVER_PRODUCT_INFO_1) BufPtr)[j].MaxUses = pSvc->MaxSessionCount;
            ((PLLS_SERVER_PRODUCT_INFO_1) BufPtr)[j].MaxSetUses = pSvc->MaxSetSessionCount;
            ((PLLS_SERVER_PRODUCT_INFO_1) BufPtr)[j].HighMark = pSvc->HighMark;
         }

         j++;
      }

   }
   RtlReleaseResource(&MasterServiceListLock);

LlsrProductServerEnumWExit:
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("   TotalEntries: %lu EntriesRead: %lu ResumeHandle: 0x%lX\n"), TotalEntries, EntriesRead, RestartKey);
#endif
   *pTotalEntries = TotalEntries;
   if (pResumeHandle != NULL)
      *pResumeHandle = (ULONG) RestartKey;
   pProductServerInfo->LlsServerProductInfo.Level0->EntriesRead = EntriesRead;
   pProductServerInfo->LlsServerProductInfo.Level0->Buffer = (PLLS_SERVER_PRODUCT_INFO_0W) BufPtr;

   return Status;
} // LlsrProductServerEnumW

void LlsrProductServerEnumW_notify_flag(
                                        boolean fNotify
                                        )
{
    if (fNotify)
    {
        RtlReleaseResource(&ServerListLock);
    }
}


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductServerEnumA(
    LLS_HANDLE Handle,
    LPSTR Product,
    PLLS_SERVER_PRODUCT_ENUM_STRUCTA ProductServerInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductServerEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrProductServerEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductLicenseEnumW(
    LLS_HANDLE Handle,
    LPWSTR Product,
    PLLS_PRODUCT_LICENSE_ENUM_STRUCTW pProductLicenseInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS    Status = STATUS_SUCCESS;
   DWORD       Level;
   PVOID       BufPtr = NULL;
   ULONG       BufSize = 0;
   ULONG       EntriesRead = 0;
   ULONG       TotalEntries = 0;
   ULONG       i = 0;
   ULONG       j = 0;
   DWORD       RecordSize;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductLicenseEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&LicenseListLock, TRUE);

   if ((NULL == pTotalEntries) || (NULL == pProductLicenseInfo))
   {
       return STATUS_INVALID_PARAMETER;
   }

   Level = pProductLicenseInfo->Level;

   *pTotalEntries = 0;

   if ( 0 == Level )
   {
       if (NULL == pProductLicenseInfo->LlsProductLicenseInfo.Level0)
       {
           return STATUS_INVALID_PARAMETER;
       }

      RecordSize = sizeof( LLS_PRODUCT_LICENSE_INFO_0W );
   }
   else if ( 1 == Level )
   {
       if (NULL == pProductLicenseInfo->LlsProductLicenseInfo.Level1)
       {
           return STATUS_INVALID_PARAMETER;
       }

      RecordSize = sizeof( LLS_PRODUCT_LICENSE_INFO_1W );
   }
   else
   {
      return STATUS_INVALID_LEVEL;
   }

   //
   // Calculate how many records will fit into PrefMaxLen buffer.
   //
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;
   while ( ( i < PurchaseListSize ) && ( BufSize < pPrefMaxLen ) )
   {
      // level 0 enums return only per seat licenses for backwards compatibility
      if (    (    (    ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT )
                     && !lstrcmpi( PurchaseList[i].Service->ServiceName, Product ) )
                || (    ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SERVER )
                     && !lstrcmpi( PurchaseList[i].PerServerService->ServiceName, Product ) ) )
           && (    ( Level > 0 )
                || ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT ) ) )
      {
         BufSize += RecordSize;
         EntriesRead++;
      }

      i++;
   }

   TotalEntries = EntriesRead;

   //
   // If we overflowed the buffer then back up one record.
   //
   if (BufSize > pPrefMaxLen)
   {
      BufSize -= RecordSize;
      EntriesRead--;
   }

   //
   // Now walk to the end of the list to see how many more records are still
   // available.
   //
   while ( i < PurchaseListSize )
   {
      if (    (    (    ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT )
                     && !lstrcmpi( PurchaseList[i].Service->ServiceName, Product ) )
                || (    ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SERVER )
                     && !lstrcmpi( PurchaseList[i].PerServerService->ServiceName, Product ) ) )
           && (    ( Level > 0 )
                || ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT ) ) )
      {
         TotalEntries++;
      }

      i++;
   }

   if (TotalEntries > EntriesRead)
      Status = STATUS_MORE_ENTRIES;

   //
   // Reset Enum to correct place.
   //
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;

   //
   // We now know how many records will fit into the buffer, so allocate space
   // and fix up pointers so we can copy the information.
   //
   BufPtr = MIDL_user_allocate(BufSize);
   if (BufPtr == NULL) {
      Status = STATUS_NO_MEMORY;
      goto LlsrLicenseEnumWExit;
   }

   RtlZeroMemory((PVOID) BufPtr, BufSize);

   //
   // Buffers are all setup, so loop through records and copy the data.
   //
   while ((j < EntriesRead) && (i < PurchaseListSize))
   {
      if (    (    (    ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT )
                     && !lstrcmpi( PurchaseList[i].Service->ServiceName, Product ) )
                || (    ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SERVER )
                     && !lstrcmpi( PurchaseList[i].PerServerService->ServiceName, Product ) ) )
           && (    ( Level > 0 )
                || ( PurchaseList[i].AllowedModes & LLS_LICENSE_MODE_ALLOW_PER_SEAT ) ) )
      {
         if ( 0 == Level )
         {
            ((PLLS_PRODUCT_LICENSE_INFO_0W) BufPtr)[j].Quantity      = PurchaseList[i].NumberLicenses;
            ((PLLS_PRODUCT_LICENSE_INFO_0W) BufPtr)[j].Date          = PurchaseList[i].Date;
            ((PLLS_PRODUCT_LICENSE_INFO_0W) BufPtr)[j].Admin         = PurchaseList[i].Admin;
            ((PLLS_PRODUCT_LICENSE_INFO_0W) BufPtr)[j].Comment       = PurchaseList[i].Comment;
         }
         else
         {
            ((PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr)[j].Quantity       = PurchaseList[i].NumberLicenses;
            ((PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr)[j].MaxQuantity    = PurchaseList[i].MaxQuantity;
            ((PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr)[j].Date           = PurchaseList[i].Date;
            ((PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr)[j].Admin          = PurchaseList[i].Admin;
            ((PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr)[j].Comment        = PurchaseList[i].Comment;
            ((PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr)[j].AllowedModes   = PurchaseList[i].AllowedModes;
            ((PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr)[j].CertificateID  = PurchaseList[i].CertificateID;
            ((PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr)[j].Source         = PurchaseList[i].Source;
            ((PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr)[j].ExpirationDate = PurchaseList[i].ExpirationDate;
            memcpy( ((PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr)[j].Secrets, PurchaseList[i].Secrets, LLS_NUM_SECRETS * sizeof( *PurchaseList[i].Secrets ) );
         }

         j++;
      }

      i++;
   }

LlsrLicenseEnumWExit:
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("   TotalEntries: %lu EntriesRead: %lu ResumeHandle: 0x%lX\n"), TotalEntries, EntriesRead, i);
#endif
   *pTotalEntries = TotalEntries;

   if (pResumeHandle != NULL)
      *pResumeHandle = (ULONG) i;

   if ( 0 == Level )
   {
      pProductLicenseInfo->LlsProductLicenseInfo.Level0->EntriesRead = EntriesRead;
      pProductLicenseInfo->LlsProductLicenseInfo.Level0->Buffer = (PLLS_PRODUCT_LICENSE_INFO_0W) BufPtr;
   }
   else
   {
      pProductLicenseInfo->LlsProductLicenseInfo.Level1->EntriesRead = EntriesRead;
      pProductLicenseInfo->LlsProductLicenseInfo.Level1->Buffer = (PLLS_PRODUCT_LICENSE_INFO_1W) BufPtr;
   }

   return Status;

} // LlsrProductLicenseEnumW

void LlsrProductLicenseEnumW_notify_flag(
                                         boolean fNotify
                                         )
{
    if (fNotify)
    {
        RtlReleaseResource(&LicenseListLock);
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductLicenseEnumA(
    LLS_HANDLE Handle,
    LPSTR Product,
    PLLS_PRODUCT_LICENSE_ENUM_STRUCTA ProductLicenseInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductLicenseEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrProductLicenseEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserEnumW(
    LLS_HANDLE Handle,
    PLLS_USER_ENUM_STRUCTW pUserInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:

    pPrefMaxLen - Supplies the number of bytes of information to return
        in the buffer.  If this value is MAXULONG, all available information
        will be returned.

    pTotalEntries - Returns the total number of entries available.  This value
        is only valid if the return code is STATUS_SUCCESS or STATUS_MORE_ENTRIES.

    pResumeHandle - Supplies a handle to resume the enumeration from where it
        left off the last time through.  Returns the resume handle if return
        code is STATUS_MORE_ENTRIES.

Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   DWORD Level;
   ULONG RecSize;
   PVOID BufPtr = NULL;
   ULONG BufSize = 0;
   ULONG EntriesRead = 0;
   ULONG TotalEntries = 0;
   ULONG i = 0;
   ULONG j;
   PUSER_RECORD UserRec = NULL;
   PVOID RestartKey = NULL,RestartKeySave = NULL;
   ULONG StrSize;
   LPTSTR ProductString = NULL;
   PCLIENT_CONTEXT_TYPE pClient;
   PVOID *pTableTmp;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   //
   // Need AddEnum lock, but just shared UserListLock (as we just read
   // the data).
   //
   RtlAcquireResourceShared(&UserListLock, TRUE);

   if ((NULL == pTotalEntries) || (NULL == pUserInfo))
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pTotalEntries = 0;

   //
   // Reset Enum to correct place.
   //
   if (pResumeHandle != NULL)
   {
       pClient = (PCLIENT_CONTEXT_TYPE) Handle;

       if ((NULL == pClient) || (0 != memcmp(pClient->Signature,LLS_SIG,LLS_SIG_SIZE)))
       {
           return STATUS_INVALID_PARAMETER;
       }


       if (*pResumeHandle != 0)
       {
           if ((NULL == pClient->UserEnumWRestartTable)
               || (*pResumeHandle > pClient->UserEnumWRestartTableSize))
           {
               return STATUS_INVALID_PARAMETER;
           }

           RestartKey = RestartKeySave = pClient->UserEnumWRestartTable[(*pResumeHandle)-1];
       }
   }

   UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);

   //
   // Get size of each record based on info level.  Only 0 and 1 supported.
   //
   Level = pUserInfo->Level;
   if (Level == 0)
   {
      if (NULL == pUserInfo->LlsUserInfo.Level0)
      {
          return STATUS_INVALID_PARAMETER;
      }

      RecSize = sizeof(LLS_USER_INFO_0);
   }
   else if (Level == 1)
   {
      if (NULL == pUserInfo->LlsUserInfo.Level1)
      {
          return STATUS_INVALID_PARAMETER;
      }

      RecSize = sizeof(LLS_USER_INFO_1);
   }
   else if (Level == 2)
   {
      if (NULL == pUserInfo->LlsUserInfo.Level2)
      {
          return STATUS_INVALID_PARAMETER;
      }

      RecSize = sizeof(LLS_USER_INFO_2);
   }
   else {
      return STATUS_INVALID_LEVEL;
   }

   //
   // Calculate how many records will fit into PrefMaxLen buffer.  This is
   // the record size * # records + space for the string data.  If MAX_ULONG
   // is passed in then we return all records.
   //
   while ((UserRec != NULL) && (BufSize < pPrefMaxLen)) {
      if (!(UserRec->Flags & LLS_FLAG_DELETED)) {
         BufSize += RecSize;
         EntriesRead++;
      }

      // Get next record
      UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);
   }

   TotalEntries = EntriesRead;

   //
   // If we overflowed the buffer then back up one record.
   //
   if (BufSize > pPrefMaxLen) {
     BufSize -= RecSize;
     EntriesRead--;
   }

   if (UserRec != NULL)
      Status = STATUS_MORE_ENTRIES;

   //
   // Now walk to the end of the list to see how many more records are still
   // available.
   //
   while (UserRec != NULL) {
      TotalEntries++;

      UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);
   }

   //
   // Reset Enum to correct place.
   //
   RestartKey = RestartKeySave;
   UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);

   //
   // We now know how many records will fit into the buffer, so allocate space
   // and fix up pointers so we can copy the information.
   //
   BufPtr = MIDL_user_allocate(BufSize);
   if (BufPtr == NULL) {
      Status = STATUS_NO_MEMORY;
      goto LlsrUserEnumWExit;
   }

   RtlZeroMemory((PVOID) BufPtr, BufSize);

   //
   // Buffers are all setup, so loop through records and copy the data.
   //
   while ((i < EntriesRead) && (UserRec != NULL)) {
      if (!(UserRec->Flags & LLS_FLAG_DELETED)) {

         if (Level == 0)
            ((PLLS_USER_INFO_0) BufPtr)[i].Name = (LPTSTR) UserRec->UserID;
         else if (Level == 1) {
            ((PLLS_USER_INFO_1) BufPtr)[i].Name = (LPTSTR) UserRec->UserID;

            if (UserRec->Mapping != NULL)
               ((PLLS_USER_INFO_1) BufPtr)[i].Group = UserRec->Mapping->Name;
            else
               ((PLLS_USER_INFO_1) BufPtr)[i].Group = NULL;

            ((PLLS_USER_INFO_1) BufPtr)[i].Licensed = UserRec->LicensedProducts;
            ((PLLS_USER_INFO_1) BufPtr)[i].UnLicensed = UserRec->ServiceTableSize - UserRec->LicensedProducts;

            ((PLLS_USER_INFO_1) BufPtr)[i].Flags = UserRec->Flags;
         } else {
            ((PLLS_USER_INFO_2) BufPtr)[i].Name = (LPTSTR) UserRec->UserID;

            if (UserRec->Mapping != NULL)
               ((PLLS_USER_INFO_2) BufPtr)[i].Group = UserRec->Mapping->Name;
            else
               ((PLLS_USER_INFO_2) BufPtr)[i].Group = NULL;

            ((PLLS_USER_INFO_2) BufPtr)[i].Licensed = UserRec->LicensedProducts;
            ((PLLS_USER_INFO_2) BufPtr)[i].UnLicensed = UserRec->ServiceTableSize - UserRec->LicensedProducts;

            ((PLLS_USER_INFO_2) BufPtr)[i].Flags = UserRec->Flags;

            //
            // Walk product table and build up product string
            //
            RtlEnterCriticalSection(&UserRec->ServiceTableLock);
            StrSize = 0;

            for (j = 0; j < UserRec->ServiceTableSize; j++)
               StrSize += ((lstrlen(UserRec->Services[j].Service->Name) + 2) * sizeof(TCHAR));

            if (StrSize != 0) {
               ProductString = MIDL_user_allocate(StrSize);
               if (ProductString != NULL) {
                  lstrcpy(ProductString, TEXT(""));

                  for (j = 0; j < UserRec->ServiceTableSize; j++) {
                     if (j != 0)
                        lstrcat(ProductString, TEXT(", "));

                     lstrcat(ProductString, UserRec->Services[j].Service->Name);
                  }

                  ((PLLS_USER_INFO_2) BufPtr)[i].Products = ProductString;
               }
            }

            if ((StrSize == 0) || (ProductString == NULL)) {
               ProductString = MIDL_user_allocate(2 * sizeof(TCHAR));
               if (ProductString != NULL) {
                  lstrcpy(ProductString, TEXT(""));
                  ((PLLS_USER_INFO_2) BufPtr)[i].Products = ProductString;
               }
            }

            RtlLeaveCriticalSection(&UserRec->ServiceTableLock);
         }

         i++;
      }

      UserRec = (PUSER_RECORD) LLSEnumerateGenericTableWithoutSplaying(&UserList, (VOID **) &RestartKey);
   }

LlsrUserEnumWExit:
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("   TotalEntries: %lu EntriesRead: %lu ResumeHandle: 0x%lX\n"), TotalEntries, EntriesRead, RestartKey);
#endif

   *pTotalEntries = TotalEntries;

   if (NULL != pResumeHandle)
   {
       if (NULL == pClient->UserEnumWRestartTable)
       {
           pTableTmp = (PVOID *) LocalAlloc(LPTR,sizeof(PVOID));
       } else
       {
           pTableTmp = (PVOID *) LocalReAlloc(pClient->UserEnumWRestartTable,sizeof(PVOID) * (pClient->UserEnumWRestartTableSize + 1),LHND);
       }

       if (NULL == pTableTmp)
       {
           if (BufPtr != NULL)
           {
               MIDL_user_free(BufPtr);
           }

           return STATUS_NO_MEMORY;
       } else
       {
           pClient->UserEnumWRestartTable = pTableTmp;
       }

      pClient->UserEnumWRestartTable[pClient->UserEnumWRestartTableSize++] = RestartKey;

      *pResumeHandle = pClient->UserEnumWRestartTableSize;
   }

   pUserInfo->LlsUserInfo.Level0->EntriesRead = EntriesRead;
   pUserInfo->LlsUserInfo.Level0->Buffer = (PLLS_USER_INFO_0W) BufPtr;

   return Status;
} // LlsrUserEnumW

void LlsrUserEnumW_notify_flag(
                               boolean fNotify
                               )
{
    if (fNotify)
    {
        RtlReleaseResource(&UserListLock);
    }
}


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserEnumA(
    LLS_HANDLE Handle,
    PLLS_USER_ENUM_STRUCTA UserInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrUserEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserInfoGetW(
    LLS_HANDLE Handle,
    LPWSTR User,
    DWORD Level,
    PLLS_USER_INFOW *BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PUSER_RECORD UserRec = NULL;
   PLLS_USER_INFOW pUser = NULL;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserInfoGetW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   RtlAcquireResourceExclusive(&UserListLock, TRUE);

   if ((User == NULL) || (BufPtr == NULL))
      return STATUS_INVALID_PARAMETER;

   *BufPtr = NULL;

   if (Level != 1)
      return STATUS_INVALID_LEVEL;

   UserRec = UserListFind(User);

   if (UserRec != NULL) {
      pUser = MIDL_user_allocate(sizeof(LLS_USER_INFOW));
      if (pUser != NULL) {
         pUser->UserInfo1.Name = (LPTSTR) UserRec->UserID;

         if (UserRec->Mapping != NULL) {
            pUser->UserInfo1.Mapping = UserRec->Mapping->Name;
            pUser->UserInfo1.Licensed = UserRec->Mapping->Licenses;
            pUser->UserInfo1.UnLicensed = 0;
         } else {
            pUser->UserInfo1.Mapping = NULL;
            pUser->UserInfo1.Licensed = 1;
            pUser->UserInfo1.UnLicensed = 0;
         }

         pUser->UserInfo1.Flags = UserRec->Flags;
      }
   }

   if (UserRec == NULL)
      return STATUS_OBJECT_NAME_NOT_FOUND;

   if (pUser == NULL)
      return STATUS_NO_MEMORY;

   *BufPtr = (PLLS_USER_INFOW) pUser;
   return STATUS_SUCCESS;
} // LlsrUserInfoGetW

void LlsrUserInfoGetW_notify_flag(
                                  boolean fNotify
                                  )
{
    if (fNotify)
    {
        RtlReleaseResource(&UserListLock);
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserInfoGetA(
    LLS_HANDLE Handle,
    LPSTR User,
    DWORD Level,
    PLLS_USER_INFOA *BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserInfoGetA\n"));
#endif

   if (NULL == BufPtr)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *BufPtr = NULL;

   return STATUS_NOT_SUPPORTED;
} // LlsrUserInfoGetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserInfoSetW(
    LLS_HANDLE Handle,
    LPWSTR User,
    DWORD Level,
    PLLS_USER_INFOW BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;
   PUSER_RECORD UserRec = NULL;
   PLLS_USER_INFO_1 pUser;
   PMAPPING_RECORD pMap;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserInfoSetW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (Level != 1)
      return STATUS_INVALID_LEVEL;

   if ((User == NULL) || (BufPtr == NULL))
      return STATUS_INVALID_PARAMETER;

   RtlAcquireResourceExclusive(&UserListLock, TRUE);

   UserRec = UserListFind(User);

   if (UserRec != NULL) {
      pUser = (PLLS_USER_INFO_1) BufPtr;

      //
      // If in a mapping can't change SUITE_USE, since it is based on the
      // License Group
      //
      if (UserRec->Mapping != NULL) {
         RtlReleaseResource(&UserListLock);
         return STATUS_MEMBER_IN_GROUP;
      }

      //
      // Reset SUITE_USE and turn off SUITE_AUTO
      //
      pUser->Flags &= LLS_FLAG_SUITE_USE;
      UserRec->Flags &= ~LLS_FLAG_SUITE_USE;
      UserRec->Flags |= pUser->Flags;
      UserRec->Flags &= ~LLS_FLAG_SUITE_AUTO;

      //
      // Run though and clean up all old licenses
      //
      UserLicenseListFree( UserRec );

      //
      // Now assign new ones
      //
      RtlEnterCriticalSection(&UserRec->ServiceTableLock);
      SvcListLicenseUpdate( UserRec );
      RtlLeaveCriticalSection(&UserRec->ServiceTableLock);

   }

   RtlReleaseResource(&UserListLock);

   if (UserRec == NULL)
      Status = STATUS_OBJECT_NAME_NOT_FOUND;
   else
      Status = LLSDataSave();

   return Status;
} // LlsrUserInfoSetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserInfoSetA(
    LLS_HANDLE Handle,
    LPSTR User,
    DWORD Level,
    PLLS_USER_INFOA BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserInfoSetA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrUserInfoSetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserDeleteW(
    LLS_HANDLE Handle,
    LPTSTR User
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;
   PUSER_RECORD UserRec = NULL;
   PLLS_USER_INFO_1 pUser;
   PMAPPING_RECORD pMap;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      if (User != NULL)
         dprintf(TEXT("LLS TRACE: LlsUserDeleteW: %s\n"), User);
      else
         dprintf(TEXT("LLS TRACE: LlsUserDeleteW: <NULL>\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (User == NULL)
      return STATUS_INVALID_PARAMETER;

   RtlAcquireResourceExclusive(&UserListLock, TRUE);

   UserRec = UserListFind(User);

   if (UserRec != NULL) {
      UserRec->Flags |= LLS_FLAG_DELETED;
      UsersDeleted = TRUE;
      RtlEnterCriticalSection(&UserRec->ServiceTableLock);
      SvcListLicenseFree(UserRec);
      UserLicenseListFree(UserRec);
      RtlLeaveCriticalSection(&UserRec->ServiceTableLock);

      if (UserRec->Services != NULL)
         LocalFree(UserRec->Services);

      UserRec->Services = NULL;
      UserRec->ServiceTableSize = 0;
   }

   RtlReleaseResource(&UserListLock);

   if (UserRec == NULL)
      Status = STATUS_OBJECT_NAME_NOT_FOUND;
   else
      Status = LLSDataSave();

   return Status;

} // LlsrUserDeleteW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserDeleteA(
    LLS_HANDLE Handle,
    LPSTR User
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserDeleteA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrUserDeleteA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserProductEnumW(
    LLS_HANDLE Handle,
    LPWSTR pUser,
    PLLS_USER_PRODUCT_ENUM_STRUCTW pUserProductInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   DWORD Level;
   ULONG RecSize;
   PVOID BufPtr = NULL;
   ULONG BufSize = 0;
   ULONG EntriesRead = 0;
   ULONG TotalEntries = 0;
   ULONG i = 0;
   ULONG j = 0;
   PUSER_RECORD UserRec = NULL;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserProductEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   //
   // Need to find the user-rec
   //
   RtlAcquireResourceExclusive(&UserListLock, TRUE);

   if ((NULL == pTotalEntries) || (pUser == NULL) || (NULL == pUserProductInfo))
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pTotalEntries = 0;

   //
   // Get size of each record based on info level.  Only 0 and 1 supported.
   //
   Level = pUserProductInfo->Level;
   if (Level == 0)
   {
      if (pUserProductInfo->LlsUserProductInfo.Level0 == NULL)
      {
          return STATUS_INVALID_PARAMETER;
      }
      RecSize = sizeof(LLS_USER_PRODUCT_INFO_0);
   }
   else if (Level == 1)
   {
      if (pUserProductInfo->LlsUserProductInfo.Level1 == NULL)
      {
          return STATUS_INVALID_PARAMETER;
      }
      RecSize = sizeof(LLS_USER_PRODUCT_INFO_1);
   }
   else {
      return STATUS_INVALID_LEVEL;
   }

   //
   // Reset Enum to correct place.
   //
   UserRec = UserListFind(pUser);
   if (UserRec == NULL) {
      Status = STATUS_OBJECT_NAME_NOT_FOUND;
      goto LlsrUserProductEnumWExit;
   }

   i = (ULONG) (pResumeHandle != NULL) ? *pResumeHandle : 0;
   RtlEnterCriticalSection(&UserRec->ServiceTableLock);

   //
   // Calculate how many records will fit into PrefMaxLen buffer.  This is
   // the record size * # records + space for the string data.  If MAX_ULONG
   // is passed in then we return all records.
   //
   while ((i < UserRec->ServiceTableSize) && (BufSize < pPrefMaxLen)) {
      BufSize += RecSize;
      EntriesRead++;
      i++;
   }

   TotalEntries = EntriesRead;

   //
   // If we overflowed the buffer then back up one record.
   //
   if (BufSize > pPrefMaxLen) {
     BufSize -= RecSize;
     EntriesRead--;
   }

   if (i < UserRec->ServiceTableSize)
      Status = STATUS_MORE_ENTRIES;

   //
   // Now walk to the end of the list to see how many more records are still
   // available.
   //
   TotalEntries += (UserRec->ServiceTableSize - i);

   //
   // We now know how many records will fit into the buffer, so allocate space
   // and fix up pointers so we can copy the information.
   //
   BufPtr = MIDL_user_allocate(BufSize);
   if (BufPtr == NULL) {
      Status = STATUS_NO_MEMORY;
      RtlLeaveCriticalSection(&UserRec->ServiceTableLock);
      goto LlsrUserProductEnumWExit;
   }

   RtlZeroMemory((PVOID) BufPtr, BufSize);

   //
   // Buffers are all setup, so loop through records and copy the data.
   //
   j = 0;
   i = (ULONG) (pResumeHandle != NULL) ? *pResumeHandle : 0;
   while ((j < EntriesRead) && (i < UserRec->ServiceTableSize)) {

      if (Level == 0)
         ((PLLS_USER_PRODUCT_INFO_0) BufPtr)[j].Product = UserRec->Services[i].Service->Name;
      else {
         ((PLLS_USER_PRODUCT_INFO_1) BufPtr)[j].Product = UserRec->Services[i].Service->Name;
         ((PLLS_USER_PRODUCT_INFO_1) BufPtr)[j].Flags = UserRec->Services[i].Flags;
         ((PLLS_USER_PRODUCT_INFO_1) BufPtr)[j].LastUsed = UserRec->Services[i].LastAccess;
         ((PLLS_USER_PRODUCT_INFO_1) BufPtr)[j].UsageCount = UserRec->Services[i].AccessCount;
      }

      i++; j++;
   }

   RtlLeaveCriticalSection(&UserRec->ServiceTableLock);

LlsrUserProductEnumWExit:
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("   TotalEntries: %lu EntriesRead: %lu ResumeHandle: 0x%lX\n"), TotalEntries, EntriesRead, i);
#endif
   *pTotalEntries = TotalEntries;
   if (pResumeHandle != NULL)
      *pResumeHandle = (ULONG) i;
   pUserProductInfo->LlsUserProductInfo.Level0->EntriesRead = EntriesRead;
   pUserProductInfo->LlsUserProductInfo.Level0->Buffer = (PLLS_USER_PRODUCT_INFO_0W) BufPtr;

   return Status;
} // LlsrUserProductEnumW

void LlsrUserProductEnumW_notify_flag(
                                      boolean fNotify
                                      )
{
    if (fNotify)
    {
        RtlReleaseResource(&UserListLock);
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserProductEnumA(
    LLS_HANDLE Handle,
    LPSTR User,
    PLLS_USER_PRODUCT_ENUM_STRUCTA UserProductInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserProductEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrUserProductEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserProductDeleteW(
    LLS_HANDLE Handle,
    LPWSTR User,
    LPWSTR Product
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserProductDeleteW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ((User == NULL) || (Product == NULL))
      return STATUS_INVALID_PARAMETER;

   RtlAcquireResourceExclusive(&UserListLock, TRUE);
   Status = SvcListDelete(User, Product);
   RtlReleaseResource(&UserListLock);

   if ( STATUS_SUCCESS == Status )
   {
      // save modified data
      Status = LLSDataSave();
   }

   return Status;
} // LlsrUserProductDeleteW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrUserProductDeleteA(
    LLS_HANDLE Handle,
    LPSTR User,
    LPSTR Product
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsUserProductDeleteA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrUserProductDeleteA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingEnumW(
    LLS_HANDLE Handle,
    PLLS_MAPPING_ENUM_STRUCTW pMappingInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   DWORD Level;
   ULONG RecSize;
   PVOID BufPtr = NULL;
   ULONG BufSize = 0;
   ULONG EntriesRead = 0;
   ULONG TotalEntries = 0;
   ULONG i = 0;
   ULONG j = 0;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&MappingListLock, TRUE);

   if ((NULL == pTotalEntries) || (NULL == pMappingInfo))
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pTotalEntries = 0;

   //
   // Get size of each record based on info level.  Only 0 and 1 supported.
   //
   Level = pMappingInfo->Level;
   if (Level == 0)
   {
      if (pMappingInfo->LlsMappingInfo.Level0 == NULL)
      {
          return STATUS_INVALID_PARAMETER;
      }
      RecSize = sizeof(LLS_MAPPING_INFO_0W);
   }
   else if (Level == 1)
   {
      if (pMappingInfo->LlsMappingInfo.Level0 == NULL)
      {
          return STATUS_INVALID_PARAMETER;
      }
      RecSize = sizeof(LLS_MAPPING_INFO_1W);
   }
   else {
      return STATUS_INVALID_LEVEL;
   }

   //
   // Calculate how many records will fit into PrefMaxLen buffer.  This is
   // the record size * # records + space for the string data.  If MAX_ULONG
   // is passed in then we return all records.
   //
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;
   while ((i < MappingListSize) && (BufSize < pPrefMaxLen)) {
      BufSize += RecSize;
      EntriesRead++;

      i++;
   }

   TotalEntries = EntriesRead;

   //
   // If we overflowed the buffer then back up one record.
   //
   if (BufSize > pPrefMaxLen) {
     BufSize -= RecSize;
     EntriesRead--;
   }

   if (i < MappingListSize)
      Status = STATUS_MORE_ENTRIES;

   //
   // Now walk to the end of the list to see how many more records are still
   // available.
   //
   TotalEntries += (MappingListSize - i);

   //
   // Reset Enum to correct place.
   //
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;

   //
   // We now know how many records will fit into the buffer, so allocate space
   // and fix up pointers so we can copy the information.
   //
   BufPtr = MIDL_user_allocate(BufSize);
   if (BufPtr == NULL) {
      Status = STATUS_NO_MEMORY;
      goto LlsrMappingEnumWExit;
   }

   RtlZeroMemory((PVOID) BufPtr, BufSize);

   //
   // Buffers are all setup, so loop through records and copy the data.
   //
   j = 0;
   while ((j < EntriesRead) && (i < MappingListSize)) {
      if (Level == 0)
         ((PLLS_GROUP_INFO_0) BufPtr)[j].Name = MappingList[i]->Name;
      else {
         ((PLLS_GROUP_INFO_1) BufPtr)[j].Name = MappingList[i]->Name;
         ((PLLS_GROUP_INFO_1) BufPtr)[j].Comment = MappingList[i]->Comment;
         ((PLLS_GROUP_INFO_1) BufPtr)[j].Licenses = MappingList[i]->Licenses;
      }

      i++; j++;
   }

LlsrMappingEnumWExit:
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("   TotalEntries: %lu EntriesRead: %lu ResumeHandle: 0x%lX\n"), TotalEntries, EntriesRead, i);
#endif
   *pTotalEntries = TotalEntries;

   if (pResumeHandle != NULL)
      *pResumeHandle = (ULONG) i;
   if (Level == 0) {
      pMappingInfo->LlsMappingInfo.Level0->EntriesRead = EntriesRead;
      pMappingInfo->LlsMappingInfo.Level0->Buffer = (PLLS_MAPPING_INFO_0W) BufPtr;
   } else {
      pMappingInfo->LlsMappingInfo.Level1->EntriesRead = EntriesRead;
      pMappingInfo->LlsMappingInfo.Level1->Buffer = (PLLS_MAPPING_INFO_1W) BufPtr;
   }

   return Status;

} // LlsrMappingEnumW

void LlsrMappingEnumW_notify_flag(
                                  boolean fNotify
                                  )
{
    if (fNotify)
    {
        RtlReleaseResource(&MappingListLock);
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingEnumA(
    LLS_HANDLE Handle,
    PLLS_MAPPING_ENUM_STRUCTA MappingInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrMappingEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingInfoGetW(
    LLS_HANDLE Handle,
    LPWSTR Mapping,
    DWORD Level,
    PLLS_MAPPING_INFOW *BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PMAPPING_RECORD pMapping = NULL;
   PLLS_GROUP_INFO_1 pMap = NULL;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingInfoGetW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   RtlAcquireResourceShared(&MappingListLock, TRUE);

   if ((Mapping == NULL) || (BufPtr == NULL))
      return STATUS_INVALID_PARAMETER;

   *BufPtr = NULL;

   if (Level != 1)
      return STATUS_INVALID_LEVEL;

   pMapping = MappingListFind(Mapping);

   if (pMapping != NULL) {
      pMap = MIDL_user_allocate(sizeof(LLS_GROUP_INFO_1));
      if (pMap != NULL) {
         pMap->Name = pMapping->Name;
         pMap->Comment = pMapping->Comment;
         pMap->Licenses = pMapping->Licenses;
      }
   }

   if (pMapping == NULL)
      return STATUS_OBJECT_NAME_NOT_FOUND;

   if (pMap == NULL)
      return STATUS_NO_MEMORY;

   *BufPtr = (PLLS_MAPPING_INFOW) pMap;
   return STATUS_SUCCESS;

} // LlsrMappingInfoGetW

void LlsrMappingInfoGetW_notify_flag(
                                     boolean fNotify
                                     )
{
    if (fNotify)
    {
        RtlReleaseResource(&MappingListLock);
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingInfoGetA(
    LLS_HANDLE Handle,
    LPSTR Mapping,
    DWORD Level,
    PLLS_MAPPING_INFOA *BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingInfoGetA\n"));
#endif

   if (NULL == BufPtr)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *BufPtr = NULL;

   return STATUS_NOT_SUPPORTED;
} // LlsrMappingInfoGetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingInfoSetW(
    LLS_HANDLE Handle,
    LPWSTR Mapping,
    DWORD Level,
    PLLS_MAPPING_INFOW BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;
   PMAPPING_RECORD pMapping = NULL;
   PLLS_GROUP_INFO_1 pMap;
   LPTSTR NewComment;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingInfoSetW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (Level != 1)
      return STATUS_INVALID_LEVEL;

   if ((Mapping == NULL) || (BufPtr == NULL))
      return STATUS_INVALID_PARAMETER;

   RtlAcquireResourceExclusive(&UserListLock, TRUE);
   RtlAcquireResourceExclusive(&MappingListLock, TRUE);

   pMapping = MappingListFind(Mapping);

   if (pMapping != NULL) {
      pMap = (PLLS_GROUP_INFO_1) BufPtr;

      //
      // Check if comment has changed
      //
      if (pMap->Comment != NULL)
         if (lstrcmp(pMap->Comment, pMapping->Comment)) {
            NewComment = (LPTSTR) LocalAlloc(LPTR, (lstrlen(pMap->Comment) + 1) * sizeof(TCHAR));
            if (NewComment != NULL) {
               LocalFree(pMapping->Comment);
               pMapping->Comment = NewComment;
               lstrcpy(pMapping->Comment, pMap->Comment);
            }
         }

      if ( pMapping->Licenses != pMap->Licenses )
      {
         MappingLicenseListFree( pMapping );
         pMapping->Licenses = pMap->Licenses;
         MappingLicenseUpdate( pMapping, TRUE );
      }
   }

   RtlReleaseResource(&MappingListLock);
   RtlReleaseResource(&UserListLock);

   if (pMapping == NULL)
      Status = STATUS_OBJECT_NAME_NOT_FOUND;
   else
      Status = MappingListSave();

   return Status;

} // LlsrMappingInfoSetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingInfoSetA(
    LLS_HANDLE Handle,
    LPSTR Mapping,
    DWORD Level,
    PLLS_MAPPING_INFOA BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingInfoSetA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrMappingInfoSetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingUserEnumW(
    LLS_HANDLE Handle,
    LPWSTR Mapping,
    PLLS_USER_ENUM_STRUCTW pMappingUserInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   PMAPPING_RECORD pMapping;
   DWORD Level;
   PVOID BufPtr = NULL;
   ULONG BufSize = 0;
   ULONG EntriesRead = 0;
   ULONG TotalEntries = 0;
   ULONG i = 0;
   ULONG j = 0;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingUserEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&MappingListLock, TRUE);

   if ((NULL == pTotalEntries) || (NULL == pMappingUserInfo))
   {
       return STATUS_INVALID_PARAMETER;
   }

   Level = pMappingUserInfo->Level;

   *pTotalEntries = 0;

   if (Level != 0)
      return STATUS_INVALID_LEVEL;

   if (pMappingUserInfo->LlsUserInfo.Level0 == NULL)
       return STATUS_INVALID_PARAMETER;

   pMapping = MappingListFind(Mapping);
   if (pMapping == NULL) {
      Status = STATUS_OBJECT_NAME_NOT_FOUND;
      goto LlsrMappingUserEnumWExit;
   }

   //
   // Calculate how many records will fit into PrefMaxLen buffer.  This is
   // the record size * # records + space for the string data.  If MAX_ULONG
   // is passed in then we return all records.
   //
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;
   while ((i < pMapping->NumMembers) && (BufSize < pPrefMaxLen)) {
      BufSize += sizeof(LLS_USER_INFO_0);
      EntriesRead++;

      i++;
   }

   TotalEntries = EntriesRead;

   //
   // If we overflowed the buffer then back up one record.
   //
   if (BufSize > pPrefMaxLen) {
     BufSize -= sizeof(LLS_USER_INFO_0);
     EntriesRead--;
   }

   if (i < pMapping->NumMembers)
      Status = STATUS_MORE_ENTRIES;

   //
   // Now walk to the end of the list to see how many more records are still
   // available.
   //
   TotalEntries += (pMapping->NumMembers - i);

   //
   // Reset Enum to correct place.
   //
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;

   //
   // We now know how many records will fit into the buffer, so allocate space
   // and fix up pointers so we can copy the information.
   //
   BufPtr = MIDL_user_allocate(BufSize);
   if (BufPtr == NULL) {
      Status = STATUS_NO_MEMORY;
      goto LlsrMappingUserEnumWExit;
   }

   RtlZeroMemory((PVOID) BufPtr, BufSize);

   //
   // Buffers are all setup, so loop through records and copy the data.
   //
   while ((j < EntriesRead) && (i < pMapping->NumMembers)) {
      ((PLLS_USER_INFO_0) BufPtr)[j].Name = pMapping->Members[i];
      i++; j++;
   }

LlsrMappingUserEnumWExit:
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("   TotalEntries: %lu EntriesRead: %lu ResumeHandle: 0x%lX\n"), TotalEntries, EntriesRead, i);
#endif
   *pTotalEntries = TotalEntries;

   if (pResumeHandle != NULL)
      *pResumeHandle = (ULONG) i;
   pMappingUserInfo->LlsUserInfo.Level0->EntriesRead = EntriesRead;
   pMappingUserInfo->LlsUserInfo.Level0->Buffer = (PLLS_USER_INFO_0W) BufPtr;

   return Status;

} // LlsrMappingUserEnumW

void LlsrMappingUserEnumW_notify_flag(
                                      boolean fNotify
                                      )
{
    if (fNotify)
    {
        RtlReleaseResource(&MappingListLock);
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingUserEnumA(
    LLS_HANDLE Handle,
    LPSTR Mapping,
    PLLS_USER_ENUM_STRUCTA MappingUserInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingUserEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrMappingUserEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingUserAddW(
    LLS_HANDLE Handle,
    LPWSTR Mapping,
    LPWSTR User
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   PUSER_RECORD pUserRec;
   PMAPPING_RECORD pMap;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingUserAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ((Mapping == NULL) || (User == NULL))
      return STATUS_INVALID_PARAMETER;

   RtlAcquireResourceExclusive(&UserListLock, TRUE);
   RtlAcquireResourceExclusive(&MappingListLock, TRUE);
   pMap = MappingUserListAdd( Mapping, User );

   if (pMap == NULL)
      Status = STATUS_OBJECT_NAME_NOT_FOUND;
   else {
      pUserRec = UserListFind(User);

      if (pUserRec != NULL)
         UserMappingAdd(pMap, pUserRec);
   }

   RtlReleaseResource(&MappingListLock);
   RtlReleaseResource(&UserListLock);

   if (Status == STATUS_SUCCESS)
   {
      Status = MappingListSave();

      if (Status == STATUS_SUCCESS)
         Status = LLSDataSave();
   }

   return Status;

} // LlsrMappingUserAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingUserAddA(
    LLS_HANDLE Handle,
    LPSTR Mapping,
    LPSTR User
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingUserAddA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrMappingUserAddA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingUserDeleteW(
    LLS_HANDLE Handle,
    LPWSTR Mapping,
    LPWSTR User
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;
   PUSER_RECORD pUser;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingUserDeleteW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ((Mapping == NULL) || (User == NULL))
      return STATUS_INVALID_PARAMETER;

   RtlAcquireResourceExclusive(&MappingListLock, TRUE);
   Status = MappingUserListDelete(Mapping, User);
   RtlReleaseResource(&MappingListLock);

   RtlAcquireResourceExclusive(&UserListLock, TRUE);
   pUser = UserListFind( User );
   RtlReleaseResource(&UserListLock);

   if (pUser != NULL) {
      //
      // if auto switch to BackOffice then turn BackOffice off
      //
      if (pUser->Flags & LLS_FLAG_SUITE_AUTO)
         pUser->Flags &= ~ LLS_FLAG_SUITE_USE;

      //
      // Free up any licenses used by the user
      //
      RtlEnterCriticalSection(&pUser->ServiceTableLock);
      SvcListLicenseFree( pUser );
      pUser->Mapping = NULL;

      //
      // And claim any needed new-ones
      //
      SvcListLicenseUpdate( pUser );
      RtlLeaveCriticalSection(&pUser->ServiceTableLock);
   }

   if (Status == STATUS_SUCCESS)
   {
      Status = MappingListSave();

      if (Status == STATUS_SUCCESS)
         Status = LLSDataSave();
   }

   return Status;
} // LlsrMappingUserDeleteW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingUserDeleteA(
    LLS_HANDLE Handle,
    LPSTR Mapping,
    LPSTR User
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingUserDeleteA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrMappingUserDeleteA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingAddW(
    LLS_HANDLE Handle,
    DWORD Level,
    PLLS_MAPPING_INFOW BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status = STATUS_SUCCESS;
   PMAPPING_RECORD pMap;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (Level != 1)
      return STATUS_INVALID_LEVEL;

   if ((BufPtr == NULL) ||
       (BufPtr->MappingInfo1.Name == NULL) ||
       (BufPtr->MappingInfo1.Comment == NULL))
      return STATUS_INVALID_PARAMETER;

   RtlAcquireResourceExclusive(&MappingListLock, TRUE);

   pMap = MappingListAdd(BufPtr->MappingInfo1.Name,
                         BufPtr->MappingInfo1.Comment,
                         BufPtr->MappingInfo1.Licenses,
                         &Status);

   RtlReleaseResource(&MappingListLock);
   if (pMap == NULL)
   {
      if (STATUS_SUCCESS == Status)
          Status = STATUS_NO_MEMORY;
   }

   if (Status == STATUS_SUCCESS)
      Status = MappingListSave();

   return Status;
} // LlsrMappingAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingAddA(
    LLS_HANDLE Handle,
    DWORD Level,
    PLLS_MAPPING_INFOA BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingAddA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrMappingAddA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingDeleteW(
    LLS_HANDLE Handle,
    LPWSTR Mapping
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingDeleteW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (Mapping == NULL)
      return STATUS_INVALID_PARAMETER;

   RtlAcquireResourceExclusive(&MappingListLock, TRUE);
   Status = MappingListDelete(Mapping);
   RtlReleaseResource(&MappingListLock);

   if (Status == STATUS_SUCCESS)
      Status = MappingListSave();

   return Status;
} // LlsrMappingDeleteW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrMappingDeleteA(
    LLS_HANDLE Handle,
    LPSTR Mapping
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsMappingDeleteA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrMappingDeleteA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrServerEnumW(
    LLS_HANDLE Handle,
    LPWSTR Server,
    PLLS_SERVER_ENUM_STRUCTW pServerProductInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsServerEnumW\n"));
#endif

   if (NULL == pTotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pTotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrServerEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrServerEnumA(
    LLS_HANDLE Handle,
    LPSTR Server,
    PLLS_SERVER_ENUM_STRUCTA pServerProductInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsServerEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrServerEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrServerProductEnumW(
    LLS_HANDLE Handle,
    LPWSTR Server,
    PLLS_SERVER_PRODUCT_ENUM_STRUCTW pServerProductInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsServerProductEnumW\n"));
#endif

   if (NULL == pTotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pTotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrServerProductEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrServerProductEnumA(
    LLS_HANDLE Handle,
    LPSTR Server,
    PLLS_SERVER_PRODUCT_ENUM_STRUCTA pServerProductInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsServerProductEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrServerProductEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrLocalProductEnumW(
    LLS_HANDLE Handle,
    PLLS_SERVER_PRODUCT_ENUM_STRUCTW pServerProductInfo,
    DWORD pPrefMaxLen,
    LPDWORD pTotalEntries,
    LPDWORD pResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalProductEnumW\n"));
#endif

   if (NULL == pTotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pTotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrLocalProductEnumW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrLocalProductEnumA(
    LLS_HANDLE Handle,
    PLLS_SERVER_PRODUCT_ENUM_STRUCTA pServerProductInfo,
    DWORD PrefMaxLen,
    LPDWORD TotalEntries,
    LPDWORD ResumeHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalProductEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsrLocalProductEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrLocalProductInfoGetW(
    LLS_HANDLE Handle,
    LPWSTR Product,
    DWORD Level,
    PLLS_SERVER_PRODUCT_INFOW *BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalProductInfoGetW\n"));
#endif

   if (NULL == BufPtr)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *BufPtr = NULL;

   return STATUS_NOT_SUPPORTED;
} // LlsrLocalProductInfoGetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrLocalProductInfoGetA(
    LLS_HANDLE Handle,
    LPSTR Product,
    DWORD Level,
    PLLS_SERVER_PRODUCT_INFOA *BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalProductInfoGetA\n"));
#endif

   if (NULL == BufPtr)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *BufPtr = NULL;

   return STATUS_NOT_SUPPORTED;
} // LlsrLocalProductInfoGetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrLocalProductInfoSetW(
    LLS_HANDLE Handle,
    LPWSTR Product,
    DWORD Level,
    PLLS_SERVER_PRODUCT_INFOW BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalProductInfoSetW\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrLocalProductInfoSetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrLocalProductInfoSetA(
    LLS_HANDLE Handle,
    LPSTR Product,
    DWORD Level,
    PLLS_SERVER_PRODUCT_INFOA BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalProductInfoSetA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrLocalProductInfoSetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrServiceInfoGetW(
    LLS_HANDLE Handle,
    DWORD Level,
    PLLS_SERVICE_INFOW *BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   NTSTATUS             Status = STATUS_SUCCESS;
   PLLS_SERVICE_INFO_0  pInfo;
   FILETIME             ftTimeStartedLocal;
   LARGE_INTEGER        llTimeStartedLocal;
   LARGE_INTEGER        llTimeStartedSystem;


#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsServiceInfoGetW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   // make sure the config info is up-to-date
   ConfigInfoUpdate(NULL);

   RtlEnterCriticalSection(&ConfigInfoLock);

   if (BufPtr == NULL)
      return STATUS_INVALID_PARAMETER;

   *BufPtr = NULL;

   if (Level != 0)
      return STATUS_INVALID_LEVEL;

   pInfo = (PLLS_SERVICE_INFO_0) MIDL_user_allocate(sizeof(LLS_SERVICE_INFO_0));
   if (pInfo == NULL)
      return STATUS_NO_MEMORY;

   pInfo->Version          = ConfigInfo.Version;
   pInfo->Mode             = LLS_MODE_ENTERPRISE_SERVER;
   pInfo->ReplicateTo      = ConfigInfo.ReplicateTo;
   pInfo->EnterpriseServer = ConfigInfo.EnterpriseServer;
   pInfo->ReplicationType  = ConfigInfo.ReplicationType;
   pInfo->ReplicationTime  = ConfigInfo.ReplicationTime;
   pInfo->LastReplicated   = ConfigInfo.LastReplicatedSeconds;
   pInfo->UseEnterprise    = ConfigInfo.UseEnterprise;

   SystemTimeToFileTime( &ConfigInfo.Started, &ftTimeStartedLocal );

   // convert time started (a local SYSTEMTIME) to a system time DWORD in seconds since 1980
   llTimeStartedLocal.u.LowPart  = ftTimeStartedLocal.dwLowDateTime;
   llTimeStartedLocal.u.HighPart = ftTimeStartedLocal.dwHighDateTime;

   RtlLocalTimeToSystemTime( &llTimeStartedLocal, &llTimeStartedSystem );
   RtlTimeToSecondsSince1980( &llTimeStartedSystem, &pInfo->TimeStarted );

   *BufPtr = (PLLS_SERVICE_INFOW) pInfo;

   return STATUS_SUCCESS;

} // LlsrServiceInfoGetW

void LlsrServiceInfoGetW_notify_flag(
                                     boolean fNotify
                                     )
{
    if (fNotify)
    {
        RtlLeaveCriticalSection(&ConfigInfoLock);
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrServiceInfoGetA(
    LLS_HANDLE Handle,
    DWORD Level,
    PLLS_SERVICE_INFOA *BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsServiceInfoGetA\n"));
#endif

   if (BufPtr == NULL)
      return STATUS_INVALID_PARAMETER;

   *BufPtr = NULL;

   return STATUS_NOT_SUPPORTED;
} // LlsrServiceInfoGetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrServiceInfoSetW(
    LLS_HANDLE Handle,
    DWORD Level,
    PLLS_SERVICE_INFOW BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsServiceInfoSetW\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrServiceInfoSetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrServiceInfoSetA(
    LLS_HANDLE Handle,
    DWORD Level,
    PLLS_SERVICE_INFOA BufPtr
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsServiceInfoSetA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrServiceInfoSetA


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//  Replication Functions

/////////////////////////////////////////////////////////////////////////
VOID __RPC_USER LLS_REPL_HANDLE_rundown(
   LLS_REPL_HANDLE Handle
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   REPL_CONTEXT_TYPE *pClient;
   LLS_REPL_HANDLE xHandle;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LLS_REPL_HANDLE_rundown\n"));
#endif

   if (Handle == NULL)
      return;

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   pClient = (REPL_CONTEXT_TYPE *) Handle;

   if (pClient != NULL)
      if (pClient->Active) {
        xHandle = Handle;
        LlsrReplClose(&xHandle);
      }

} // LLS_REPL_HANDLE_rundown


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrReplConnect(
    PLLS_REPL_HANDLE Handle,
    LPTSTR Name
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   REPL_CONTEXT_TYPE *pClient;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsReplConnect: %s\n"), Name);
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (NULL == Handle)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *Handle = NULL;

   pClient = (REPL_CONTEXT_TYPE *) midl_user_allocate(sizeof(REPL_CONTEXT_TYPE));
   if (pClient == NULL)
   {
       return STATUS_NO_MEMORY;
   }

   memcpy(pClient->Signature,LLS_REPL_SIG,LLS_REPL_SIG_SIZE);

   if (Name != NULL)
      lstrcpyn(pClient->Name, Name,MAX_COMPUTERNAME_LENGTH+1);
   else
      lstrcpy(pClient->Name, TEXT(""));

   pClient->Active = TRUE;
   pClient->Replicated = FALSE;

   pClient->ServicesSent = FALSE;
   pClient->ServiceTableSize = 0;
   pClient->Services = NULL;

   pClient->ServersSent = FALSE;
   pClient->ServerTableSize = 0;
   pClient->Servers = NULL;

   pClient->ServerServicesSent = FALSE;
   pClient->ServerServiceTableSize = 0;
   pClient->ServerServices = NULL;

   pClient->UsersSent = FALSE;
   pClient->UserLevel = 0;
   pClient->UserTableSize = 0;
   pClient->Users = NULL;

   pClient->CertDbSent              = FALSE;
   pClient->CertDbProductStringSize = 0;
   pClient->CertDbProductStrings    = NULL;
   pClient->CertDbNumHeaders        = 0;
   pClient->CertDbHeaders           = NULL;
   pClient->CertDbNumClaims         = 0;
   pClient->CertDbClaims            = NULL;

   pClient->ProductSecuritySent       = FALSE;
   pClient->ProductSecurityStringSize = 0;
   pClient->ProductSecurityStrings    = NULL;

   *Handle = pClient;

   return STATUS_SUCCESS;
} // LlsrReplConnect


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrReplClose(
    LLS_REPL_HANDLE *pHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;
   BOOL Replicated = TRUE;
   LLS_REPL_HANDLE Handle = NULL;
   REPL_CONTEXT_TYPE *pClient;
   PSERVER_RECORD Server;
   ULONG i;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsReplClose\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (NULL == pHandle)
   {
       return STATUS_INVALID_PARAMETER;
   }

   Handle = *pHandle;
   pClient = (REPL_CONTEXT_TYPE *) Handle;

   if ((NULL == pClient) || (0 != memcmp(pClient->Signature,LLS_REPL_SIG,LLS_REPL_SIG_SIZE)))
   {
       return STATUS_INVALID_PARAMETER;
   }

   pClient->Active = FALSE;

   //
   // Check to see if we have all the information from the client - if we do
   // then munge this information into our internal tables.
   //
   if (pClient->ServersSent && pClient->UsersSent && pClient->ServicesSent && pClient->ServerServicesSent) {
#if DBG
      if (TraceFlags & TRACE_RPC)
         dprintf(TEXT("LLS Replication - Munging Data\n"));
#endif

      UnpackAll (
         pClient->ServiceTableSize,
         pClient->Services,
         pClient->ServerTableSize,
         pClient->Servers,
         pClient->ServerServiceTableSize,
         pClient->ServerServices,
         pClient->UserLevel,
         pClient->UserTableSize,
         pClient->Users
         );

      if ( pClient->CertDbSent )
      {
         CertDbUnpack(
            pClient->CertDbProductStringSize,
            pClient->CertDbProductStrings,
            pClient->CertDbNumHeaders,
            pClient->CertDbHeaders,
            pClient->CertDbNumClaims,
            pClient->CertDbClaims,
            TRUE );
      }

      if ( pClient->ProductSecuritySent )
      {
         ProductSecurityUnpack(
            pClient->ProductSecurityStringSize,
            pClient->ProductSecurityStrings );
      }
   } else
      Replicated = FALSE;

   //////////////////////////////////////////////////////////////////
   //
   // Replication Finished - clean up the context data.
   //
#if DBG
      if (TraceFlags & TRACE_RPC)
         dprintf(TEXT("LLS Replication - Munging Finished\n"));
#endif

   if (pClient->Servers != NULL) {
      for (i = 0; i < pClient->ServerTableSize; i++)
         MIDL_user_free(pClient->Servers[i].Name);

      MIDL_user_free(pClient->Servers);
   }

   if (pClient->Services != NULL) {
      for (i = 0; i < pClient->ServiceTableSize; i++) {
         MIDL_user_free(pClient->Services[i].Name);
         MIDL_user_free(pClient->Services[i].FamilyName);
      }

      MIDL_user_free(pClient->Services);
   }

   if (pClient->ServerServices != NULL)
      MIDL_user_free(pClient->ServerServices);

   if (pClient->Users != NULL) {
      for (i = 0; i < pClient->UserTableSize; i++)
      {
         if ( 0 == pClient->UserLevel )
         {
            MIDL_user_free( ((PREPL_USER_RECORD_0) (pClient->Users))[i].Name );
         }
         else
         {
            ASSERT( 1 == pClient->UserLevel );
            MIDL_user_free( ((PREPL_USER_RECORD_1) (pClient->Users))[i].Name );
         }
      }

      MIDL_user_free(pClient->Users);
   }

   if (pClient->CertDbProductStrings != NULL)
   {
      MIDL_user_free(pClient->CertDbProductStrings);
   }

   if (pClient->CertDbHeaders != NULL)
   {
      MIDL_user_free(pClient->CertDbHeaders);
   }

   if (pClient->CertDbClaims != NULL)
   {
      MIDL_user_free(pClient->CertDbClaims);
   }

   if (pClient->ProductSecurityStrings != NULL)
   {
      MIDL_user_free(pClient->ProductSecurityStrings);
   }

   if (pClient->Replicated) {
      if (Replicated) {
         RtlAcquireResourceShared(&ServerListLock, TRUE);
         Server = ServerListFind(pClient->Name);
         RtlReleaseResource(&ServerListLock);

         ASSERT(Server != NULL);
         if (Server != NULL)
            Server->LastReplicated = pClient->ReplicationStart;
      }

      RtlEnterCriticalSection(&ConfigInfoLock);
      i = --ConfigInfo.NumReplicating;
      RtlLeaveCriticalSection(&ConfigInfoLock);

      if ( !i )
      {
         // no one's replicating; save all our data files
         SaveAll();
      }
   }

   MIDL_user_free(pClient);

   //
   // Let RPC know were done with it.
   //

   *pHandle = NULL;

   return STATUS_SUCCESS;
} // LlsrReplClose


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrReplicationRequestW(
   LLS_HANDLE Handle,
   DWORD Version,
   PREPL_REQUEST pRequest
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   TCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
   REPL_CONTEXT_TYPE *pClient;
   PSERVER_RECORD Server;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC | TRACE_REPLICATION))
      dprintf(TEXT("LLS TRACE: LlsReplicationRequestW: %s\n"), ((PCLIENT_CONTEXT_TYPE) Handle)->Name);
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (Version != REPL_VERSION) {
      return STATUS_INVALID_LEVEL;
   }

   if (pRequest == NULL)
      return STATUS_INVALID_PARAMETER;

   ComputerName[0] = 0;
   pRequest->EnterpriseServer[0] = 0;

   //
   // Check Enterprise server date from client to see if we need to update
   // ours.  Also, send back new one for the client.
   //
   RtlEnterCriticalSection(&ConfigInfoLock);
   if (ConfigInfo.ComputerName != NULL)
       lstrcpy(ComputerName, ConfigInfo.ComputerName);

#ifdef DISABLED_FOR_NT5
   if (ConfigInfo.EnterpriseServerDate < pRequest->EnterpriseServerDate) {
      if (lstrlen(pRequest->EnterpriseServer) != 0) {
         lstrcpy(ConfigInfo.EnterpriseServer, pRequest->EnterpriseServer);
         ConfigInfo.EnterpriseServerDate = pRequest->EnterpriseServerDate;
      }
   }
#endif // DISABLED_FOR_NT5

   if (ConfigInfo.EnterpriseServer != NULL)
       lstrcpy(pRequest->EnterpriseServer, ConfigInfo.EnterpriseServer);
   pRequest->EnterpriseServerDate = ConfigInfo.EnterpriseServerDate;

   //
   // Increment Repl Count
   //
   ConfigInfo.NumReplicating++;
   RtlLeaveCriticalSection(&ConfigInfoLock);

   //
   // Find this server in our server list (add it if not there)
   //
   pClient = (REPL_CONTEXT_TYPE *) Handle;

   if ((NULL == pClient) || (0 != memcmp(pClient->Signature,LLS_REPL_SIG,LLS_REPL_SIG_SIZE)))
   {
       return STATUS_INVALID_PARAMETER;
   }

   pClient->Replicated = TRUE;
   RtlAcquireResourceExclusive(&ServerListLock, TRUE);
   Server = ServerListAdd(pClient->Name, ComputerName);
   RtlReleaseResource(&ServerListLock);

   if (Server == NULL) {
      return STATUS_NO_MEMORY;
   }

   pClient->ReplicationStart = pRequest->CurrentTime;
   pRequest->LastReplicated = Server->LastReplicated;
   return STATUS_SUCCESS;
} // LlsrReplicationRequestW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrReplicationServerAddW(
   LLS_HANDLE Handle,
   ULONG NumRecords,
   PREPL_SERVER_RECORD Servers
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   REPL_CONTEXT_TYPE *pClient;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsReplicationServerAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   pClient = (REPL_CONTEXT_TYPE *) Handle;

   if ((NULL == pClient) || (0 != memcmp(pClient->Signature,LLS_REPL_SIG,LLS_REPL_SIG_SIZE)))
   {
       return STATUS_INVALID_PARAMETER;
   }

   if (pClient->ServersSent)
   {
       // don't accept more than one Add
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }

   pClient->ServersSent = TRUE;
   pClient->ServerTableSize = NumRecords;
   pClient->Servers = Servers;

   return STATUS_SUCCESS;
} // LlsrReplicationServerAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrReplicationServerServiceAddW(
   LLS_HANDLE Handle,
   ULONG NumRecords,
   PREPL_SERVER_SERVICE_RECORD ServerServices
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   REPL_CONTEXT_TYPE *pClient;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsReplicationServerServiceAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   pClient = (REPL_CONTEXT_TYPE *) Handle;

   if ((NULL == pClient) || (0 != memcmp(pClient->Signature,LLS_REPL_SIG,LLS_REPL_SIG_SIZE)))
   {
       return STATUS_INVALID_PARAMETER;
   }

   if (pClient->ServerServicesSent)
   {
       // don't accept more than one Add
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }

   pClient->ServerServicesSent = TRUE;
   pClient->ServerServiceTableSize = NumRecords;
   pClient->ServerServices = ServerServices;

   return STATUS_SUCCESS;
} // LlsrReplicationServerServiceAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrReplicationServiceAddW(
   LLS_HANDLE Handle,
   ULONG NumRecords,
   PREPL_SERVICE_RECORD Services
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   REPL_CONTEXT_TYPE *pClient;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsReplicationServiceAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   pClient = (REPL_CONTEXT_TYPE *) Handle;

   if ((NULL == pClient) || (0 != memcmp(pClient->Signature,LLS_REPL_SIG,LLS_REPL_SIG_SIZE)))
   {
       return STATUS_INVALID_PARAMETER;
   }

   if (pClient->ServicesSent)
   {
       // don't accept more than one Add
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }

   pClient->ServicesSent = TRUE;
   pClient->ServiceTableSize = NumRecords;
   pClient->Services = Services;

   return STATUS_SUCCESS;
} // LlsrReplicationServiceAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrReplicationUserAddW(
   LLS_HANDLE Handle,
   ULONG NumRecords,
   PREPL_USER_RECORD_0 Users
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   REPL_CONTEXT_TYPE *pClient;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsReplicationUserAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   pClient = (REPL_CONTEXT_TYPE *) Handle;

   if ((NULL == pClient) || (0 != memcmp(pClient->Signature,LLS_REPL_SIG,LLS_REPL_SIG_SIZE)))
   {
       return STATUS_INVALID_PARAMETER;
   }

   if (pClient->UsersSent)
   {
       // don't accept more than one Add
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }

   pClient->UsersSent = TRUE;
   pClient->UserLevel = 0;
   pClient->UserTableSize = NumRecords;
   pClient->Users = Users;

   return STATUS_SUCCESS;
} // LlsrReplicationUserAddW



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//  Licensing Functions

/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrLicenseRequestW(
   PLICENSE_HANDLE pLicenseHandle,
   LPWSTR ProductID,
   ULONG VersionIndex,
   BOOLEAN IsAdmin,
   ULONG DataType,
   ULONG DataSize,
   PBYTE Data
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   NTSTATUS Status;
   ULONG Handle = 0xFFFFFFFFL;

#if DBG
   if ( TraceFlags & (TRACE_FUNCTION_TRACE) )
      dprintf(TEXT("LLS TRACE: LlsrLicenseRequestW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ((NULL == pLicenseHandle) || (NULL == ProductID) || (NULL == Data))
   {
       return STATUS_INVALID_PARAMETER;
   }

   Status = DispatchRequestLicense(DataType, Data, ProductID, VersionIndex, IsAdmin, &Handle);

   // Can't allow Handle value of zero
   *pLicenseHandle = (LICENSE_HANDLE) ULongToPtr(Handle+1);

   return Status;
} // LlsrLicenseRequestW


NTSTATUS
LlsrLicenseFree(
   PLICENSE_HANDLE pLicenseHandle
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DBG
   if ( TraceFlags & (TRACE_FUNCTION_TRACE) )
      dprintf(TEXT("LLS TRACE: LlsrLicenseFree\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (NULL == pLicenseHandle)
       return STATUS_INVALID_PARAMETER;

   DispatchFreeLicense(PtrToUlong(*pLicenseHandle) - 1);

   *pLicenseHandle = NULL;

   return STATUS_SUCCESS;
} // LlsrLicenseFree

void __RPC_USER LICENSE_HANDLE_rundown(
    LICENSE_HANDLE LicenseHandle
    )

/*++

Routine Description: Called by RPC when client quits without calling
                        LlsrLicenseFree (i.e. when it crashes)


Arguments: LicenseHandle - Handle given to client


Return Value: none


--*/
{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LICENSE_HANDLE_rundown\n"));
#endif

    if (LicenseHandle != NULL)
    {
        DispatchFreeLicense(PtrToUlong(LicenseHandle) - 1);
    }
}


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


#if DBG

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//  Debugging API's

/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrDbgTableDump(
   DWORD Table
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DELAY_INITIALIZATION
    EnsureInitialized();
#endif

   //
   // FreeHandle is actually TableID
   //
   switch(Table) {
      case SERVICE_TABLE_NUM:
         ServiceListDebugDump();
         break;

      case USER_TABLE_NUM:
         UserListDebugDump();
         break;

      case SID_TABLE_NUM:
         SidListDebugDump();
         break;

      case LICENSE_TABLE_NUM:
         LicenseListDebugDump();
         break;

      case ADD_CACHE_TABLE_NUM:
         AddCacheDebugDump();
         break;

      case MASTER_SERVICE_TABLE_NUM:
         MasterServiceListDebugDump();
         break;

      case SERVICE_FAMILY_TABLE_NUM:
         MasterServiceRootDebugDump();
         break;

      case MAPPING_TABLE_NUM:
         MappingListDebugDump();
         break;

      case SERVER_TABLE_NUM:
         ServerListDebugDump();
         break;

      case SECURE_PRODUCT_TABLE_NUM:
         ProductSecurityListDebugDump();
         break;

      case CERTIFICATE_TABLE_NUM:
         CertDbDebugDump();
         break;
   }

   return STATUS_SUCCESS;
} // LlsrDbgTableDump


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrDbgTableInfoDump(
   DWORD Table,
   LPTSTR Item
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (NULL == Item)
   {
       return STATUS_INVALID_PARAMETER;
   }

   switch(Table) {
      case SERVICE_TABLE_NUM:
         ServiceListDebugInfoDump((PVOID) Item);
         break;

      case USER_TABLE_NUM:
         UserListDebugInfoDump((PVOID) Item);
         break;

//      case SID_TABLE_NUM:
//         SidListDebugInfoDump((PVOID) Item);
//         break;

//      case LICENSE_TABLE_NUM:
//         LicenseListInfoDebugDump((PVOID) Item);
//         break;

//      case ADD_CACHE_TABLE_NUM:
//         AddCacheDebugDump((PVOID) Item);
//         break;

      case MASTER_SERVICE_TABLE_NUM:
         MasterServiceListDebugInfoDump((PVOID) Item);
         break;

      case SERVICE_FAMILY_TABLE_NUM:
         MasterServiceRootDebugInfoDump((PVOID) Item);
         break;

      case MAPPING_TABLE_NUM:
         MappingListDebugInfoDump((PVOID) Item);
         break;

      case SERVER_TABLE_NUM:
         ServerListDebugInfoDump((PVOID) Item);
         break;
   }

   return STATUS_SUCCESS;
} // LlsrDbgTableInfoDump


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrDbgTableFlush(
   DWORD Table
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   return STATUS_SUCCESS;
} // LlsrDbgTableFlush


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrDbgTraceSet(
   DWORD Flags
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   TraceFlags = Flags;
   return STATUS_SUCCESS;
} // LlsrDbgTraceSet


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrDbgConfigDump(
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   ConfigInfoDebugDump();
   return STATUS_SUCCESS;
} // LlsrDbgConfigDump


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrDbgReplicationForce(
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   NtSetEvent( ReplicationEvent, NULL );
   return STATUS_SUCCESS;
} // LlsrDbgReplicationForce


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrDbgReplicationDeny(
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
   return STATUS_SUCCESS;
} // LlsrDbgReplicationDeny


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrDbgRegistryUpdateForce(
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   ServiceListResynch();
   return STATUS_SUCCESS;
} // LlsrDbgRegistryUpdateForce


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrDbgDatabaseFlush(
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   LLSDataSave();
   return STATUS_SUCCESS;
} // LlsrDbgDatabaseFlush



#endif // #if DBG


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
//  Extended RPC

NTSTATUS LlsrProductSecurityGetA(
    LLS_HANDLE    Handle,
    LPSTR         Product,
    LPBOOL        pIsSecure
    )

/*++

Routine Description:

   Retrieve the "security" of a product.  A product is deemed secure iff
   it requires a secure certificate.  In such a case, licenses for the
   product may not be entered via the Honesty ("enter the number of
   licenses you purchased") method.

   NOTE: Not yet implemented.  Use LlsrProductSecurityGetW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   Product (LPSTR)
      The name of the product ("DisplayName") for which to receive the
      security.
   pIsSecure (LPBOOL)
      On return, and if successful, indicates whether the product is
      secure.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrProductSecurityGetA\n"));
#endif

   if (NULL == pIsSecure)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pIsSecure = FALSE;

   return STATUS_NOT_SUPPORTED;
} // LlsrProductSecurityGetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductSecurityGetW(
    LLS_HANDLE    Handle,
    LPWSTR        DisplayName,
    LPBOOL        pIsSecure
    )

/*++

Routine Description:

   Retrieve the "security" of a product.  A product is deemed secure iff
   it requires a secure certificate.  In such a case, licenses for the
   product may not be entered via the Honesty ("enter the number of
   licenses you purchased") method.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   Product (LPWSTR)
      The name of the product ("DisplayName") for which to receive the
      security.
   pIsSecure (LPBOOL)
      On return, and if successful, indicates whether the product is
      secure.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   DWORD i;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrProductSecurityGetW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (NULL == pIsSecure)
   {
       return STATUS_INVALID_PARAMETER;
   }

   RtlAcquireResourceShared( &LocalServiceListLock, TRUE );

   *pIsSecure = ServiceIsSecure( DisplayName );

   RtlReleaseResource( &LocalServiceListLock );

   return STATUS_SUCCESS;
} // LlsrProductSecurityGetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductSecuritySetA(
    LLS_HANDLE    Handle,
    LPSTR         Product
    )

/*++

Routine Description:

   Flags the given product as secure.  A product is deemed secure iff
   it requires a secure certificate.  In such a case, licenses for the
   product may not be entered via the Honesty ("enter the number of
   licenses you purchased") method.

   This designation is not reversible and is propagated up the
   replication tree.

   NOTE: Not yet implemented.  Use LlsrProductSecuritySetW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   Product (LPSTR)
      The name of the product ("DisplayName") for which to activate
      security.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrProductSecuritySetA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrProductSecuritySetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS LlsrProductSecuritySetW(
    LLS_HANDLE    Handle,
    LPWSTR        DisplayName
    )

/*++

Routine Description:

   Flags the given product as secure.  A product is deemed secure iff
   it requires a secure certificate.  In such a case, licenses for the
   product may not be entered via the Honesty ("enter the number of
   licenses you purchased") method.

   This designation is not reversible and is propagated up the
   replication tree.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   Product (LPWSTR)
      The name of the product ("DisplayName") for which to activate
      security.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS    nt;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrProductSecuritySetW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (NULL == DisplayName)
   {
       return STATUS_INVALID_PARAMETER;
   }

   nt = ServiceSecuritySet( DisplayName );

   return nt;
} // LlsrProductSecuritySetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrProductLicensesGetA(
   LLS_HANDLE  Handle,
   LPSTR       DisplayName,
   DWORD       Mode,
   LPDWORD     pQuantity )

/*++

Routine Description:

   Returns the number of licenses installed for use in the given mode.

   NOTE: Not yet implemented.  Use LlsrProductLicensesGetW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   Product (LPSTR)
      The name of the product for which to tally licenses.
   Mode (DWORD)
      Mode for which to tally licenses.
   pQuantity (LPDWORD)
      On return (and if successful), holds the total number of licenses
      for use by the given product in the given license mode.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductLicensesGetA\n"));
#endif

   if (NULL == pQuantity)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pQuantity = 0;

   return STATUS_NOT_SUPPORTED;
} // LlsProductLicensesGetA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrProductLicensesGetW(
   LLS_HANDLE  Handle,
   LPWSTR      DisplayName,
   DWORD       Mode,
   LPDWORD     pQuantity )

/*++

Routine Description:

   Returns the number of licenses installed for use in the given mode.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   Product (LPWSTR)
      The name of the product for which to tally licenses.
   Mode (DWORD)
      Mode for which to tally licenses.
   pQuantity (LPDWORD)
      On return (and if successful), holds the total number of licenses
      for use by the given product in the given license mode.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsProductLicensesGetW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (NULL == pQuantity)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pQuantity = 0;

   if ( !Mode || ServiceIsSecure( DisplayName ) )
   {
      // get limit from purchase list
      *pQuantity = ProductLicensesGet( DisplayName, Mode );
   }
   else
   {
      DWORD       i;

      LocalServiceListUpdate();
      LocalServerServiceListUpdate();
      ServiceListResynch();

      RtlAcquireResourceShared( &LocalServiceListLock, TRUE );

      // get limit from concurrent limit setting from the registry
      for ( i=0; i < LocalServiceListSize; i++ )
      {
         if ( !lstrcmpi( LocalServiceList[i]->DisplayName, DisplayName ) )
         {
            // get concurrent limit straight from the registry, not from LocalServiceList!
            // (if the mode is set to per seat, the per server licenses in the
            //  LocalServiceList will always be 0!)
            TCHAR    szKeyName[ 512 ];
            HKEY     hKeyService;
            DWORD    dwSize;
            DWORD    dwType;

            wsprintf( szKeyName, TEXT("System\\CurrentControlSet\\Services\\LicenseInfo\\%s"), LocalServiceList[i]->Name );

            // if error encountered, return STATUS_SUCCESS with *pQuantity = 0
            if ( STATUS_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_READ, &hKeyService ) )
            {
               dwSize = sizeof( *pQuantity );
               RegQueryValueEx( hKeyService, TEXT("ConcurrentLimit"), NULL, &dwType, (LPBYTE) pQuantity, &dwSize );

               RegCloseKey( hKeyService );
            }

            break;
         }
      }

      RtlReleaseResource( &LocalServiceListLock );
   }

   return STATUS_SUCCESS;
} // LlsProductLicensesGetW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrCertificateClaimEnumA(
   LLS_HANDLE              Handle,
   DWORD                   LicenseLevel,
   PLLS_LICENSE_INFOA   LicensePtr,
   PLLS_CERTIFICATE_CLAIM_ENUM_STRUCTA TargetInfo )

/*++

Routine Description:

   Enumerates the servers on which a given secure certificate is installed.
   This function is normally invoked when an attempt to add licenses from
   a certificate is denied.

   NOTE: Not yet implemented.  Use LlsrCertificateClaimEnumW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   LicensePtr (PLLS_LICENSE_INFOA)
      Describes a license for which the certificate targets are requested.
   TargetInfo (PLLS_CERTIFICATE_CLAIM_ENUM_STRUCTA)
      Container in which to return the target information.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrCertificateClaimEnumA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrCertificateClaimEnumA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrCertificateClaimEnumW(
   LLS_HANDLE              Handle,
   DWORD                   LicenseLevel,
   PLLS_LICENSE_INFOW   LicensePtr,
   PLLS_CERTIFICATE_CLAIM_ENUM_STRUCTW TargetInfo )

/*++

Routine Description:

   Enumerates the servers on which a given secure certificate is installed.
   This function is normally invoked when an attempt to add licenses from
   a certificate is denied.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   LicensePtr (PLLS_LICENSE_INFOW)
      Describes a license for which the certificate targets are requested.
   TargetInfo (PLLS_CERTIFICATE_CLAIM_ENUM_STRUCTA)
      Container in which to return the target information.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS    nt;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrCertificateClaimEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   RtlAcquireResourceShared( &CertDbHeaderListLock, TRUE );

   if ((NULL == TargetInfo) || (NULL == LicensePtr))
   {
       return STATUS_INVALID_PARAMETER;
   }

   if ( ( 1 != LicenseLevel ) || ( 0 != TargetInfo->Level ) )
   {
      return STATUS_INVALID_LEVEL;
   }

   if (TargetInfo->LlsCertificateClaimInfo.Level0 == NULL)
   {
       return STATUS_INVALID_PARAMETER;
   }

   nt = CertDbClaimsGet( (PLLS_LICENSE_INFO_1) &LicensePtr->LicenseInfo1,
                         &TargetInfo->LlsCertificateClaimInfo.Level0->EntriesRead,
                         (PLLS_CERTIFICATE_CLAIM_INFO_0 *) &TargetInfo->LlsCertificateClaimInfo.Level0->Buffer );
   
   if ( STATUS_SUCCESS != nt )
   {
       TargetInfo->LlsCertificateClaimInfo.Level0->EntriesRead = 0;
       TargetInfo->LlsCertificateClaimInfo.Level0->Buffer = NULL;
   }


   return nt;
} // LlsrCertificateClaimEnumW

void LlsrCertificateClaimEnumW_notify_flag(
                                           boolean fNotify
                                           )
{
    if (fNotify)
    {
        RtlReleaseResource( &CertDbHeaderListLock );
    }
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrCertificateClaimAddCheckA(
   LLS_HANDLE              Handle,
   DWORD                   LicenseLevel,
   PLLS_LICENSE_INFOA   LicensePtr,
   LPBOOL                  pbMayInstall )

/*++

Routine Description:

   Verify that no more licenses from a given certificate are installed in
   a licensing enterprise than are allowed by the certificate.

   NOTE: Not yet implemented.  Use LlsrCertificateClaimAddCheckW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   LicensePtr (PLLS_LICENSE_INFOA)
      Describes a license for which permission is requested.
   pbMayInstall (LPBOOL)
      On return (and if successful), indicates whether the certificate
      may be legally installed.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrCertificateClaimAddCheckA\n"));
#endif

   if (NULL == pbMayInstall)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pbMayInstall = FALSE;

   return STATUS_NOT_SUPPORTED;
} // LlsrCertificateClaimAddCheckA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrCertificateClaimAddCheckW(
   LLS_HANDLE              Handle,
   DWORD                   LicenseLevel,
   PLLS_LICENSE_INFOW   LicensePtr,
   LPBOOL                  pbMayInstall )

/*++

Routine Description:

   Verify that no more licenses from a given certificate are installed in
   a licensing enterprise than are allowed by the certificate.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   LicensePtr (PLLS_LICENSE_INFOW)
      Describes a license for which permission is requested.
   pbMayInstall (LPBOOL)
      On return (and if successful), indicates whether the certificate
      may be legally installed.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS    nt;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrCertificateClaimAddCheckW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ((NULL == pbMayInstall) || (NULL == LicensePtr))
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pbMayInstall = FALSE;

   if ( 1 != LicenseLevel )
   {
      return STATUS_INVALID_LEVEL;
   }

   *pbMayInstall = CertDbClaimApprove( (PLLS_LICENSE_INFO_1) &LicensePtr->LicenseInfo1 );
   nt = STATUS_SUCCESS;

   return nt;
} // LlsrCertificateClaimAddCheckW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrCertificateClaimAddA(
   LLS_HANDLE              Handle,
   LPSTR                   ServerName,
   DWORD                   LicenseLevel,
   PLLS_LICENSE_INFOA   LicensePtr )

/*++

Routine Description:

   Declare a number of licenses from a given certificate as being installed
   on the target machine.

   NOTE: Not yet implemented.  Use LlsCertificateClaimAddW().

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle.
   ServerName (LPWSTR)
      Name of the server on which the licenses are installed.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   LicensePtr (PLLS_LICENSE_INFOA)
      Describes the installed license.

Return Value:

   STATUS_NOT_SUPPORTED.

--*/

{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrCertificateClaimAddA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
} // LlsrCertificateClaimAddA


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrCertificateClaimAddW(
   LLS_HANDLE              Handle,
   LPWSTR                  ServerName,
   DWORD                   LicenseLevel,
   PLLS_LICENSE_INFOW   LicensePtr )

/*++

Routine Description:

   Declare a number of licenses from a given certificate as being installed
   on the target machine.

Arguments:

   Handle (LLS_HANDLE)
      An open LLS handle to the target license server.
   ServerName (LPWSTR)
      Name of the server on which the licenses are installed.
   LicenseLevel (DWORD)
      The level of the license structure pointed to by pLicenseInfo.
   LicensePtr (PLLS_LICENSE_INFOW)
      Describes the installed license.

Return Value:

   STATUS_SUCCESS or NTSTATUS error code.

--*/

{
   NTSTATUS    nt;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrCertificateClaimAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ( 1 != LicenseLevel )
   {
      return STATUS_INVALID_LEVEL;
   }

   if (NULL == LicensePtr)
   {
       return STATUS_INVALID_PARAMETER;
   }

   nt = CertDbClaimEnter( ServerName, (PLLS_LICENSE_INFO_1) &LicensePtr->LicenseInfo1, FALSE, 0 );
   
   if ( STATUS_SUCCESS == nt )
   {
       nt = CertDbSave();
   }

   return nt;
} // LlsrCertificateClaimAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrReplicationCertDbAddW(
   LLS_REPL_HANDLE            Handle,
   DWORD                      Level,
   REPL_CERTIFICATES          Certificates )

/*++

Routine Description:

   Called as an optional part of replication, this function receives
   the contents of the remote certificate database.

Arguments:

   Handle (LLS_REPL_HANDLE)
      An open replication handle.
   Level (DWORD)
      Level of replicated certificate information.
   Certificates (REPL_CERTIFICATES)
      Replicated certificate information.

Return Value:

   STATUS_SUCCESS or STATUS_INVALID_LEVEL.

--*/

{
   NTSTATUS             nt;
   REPL_CONTEXT_TYPE *  pClient;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrReplicationCertDbAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (    ( 0 != Level                                          )
        || (    ( NULL != Certificates                           )
             && (    ( 0 != Certificates->Level0.ClaimLevel  )
                  || ( 0 != Certificates->Level0.HeaderLevel ) ) ) )
   {
      nt = STATUS_INVALID_LEVEL;
   }

   else
   {
      pClient = (REPL_CONTEXT_TYPE *) Handle;

      if ((NULL == pClient) || (0 != memcmp(pClient->Signature,LLS_REPL_SIG,LLS_REPL_SIG_SIZE)))
      {
          return STATUS_INVALID_PARAMETER;
      }

      if (pClient->CertDbSent)
      {
          // don't accept more than one Add
          return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
      }

      pClient->CertDbSent              = TRUE;

      if ( NULL != Certificates )
      {
         pClient->CertDbProductStringSize = Certificates->Level0.StringSize;
         pClient->CertDbProductStrings    = Certificates->Level0.Strings;
         pClient->CertDbNumHeaders        = Certificates->Level0.HeaderContainer.Level0.NumHeaders;
         pClient->CertDbHeaders           = Certificates->Level0.HeaderContainer.Level0.Headers;
         pClient->CertDbNumClaims         = Certificates->Level0.ClaimContainer.Level0.NumClaims;
         pClient->CertDbClaims            = Certificates->Level0.ClaimContainer.Level0.Claims;

         // free container only
         MIDL_user_free( Certificates );
      }

      nt = STATUS_SUCCESS;
   }

   return nt;
} // LlsrReplicationCertDbAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrReplicationProductSecurityAddW(
   LLS_REPL_HANDLE            Handle,
   DWORD                      Level,
   REPL_SECURE_PRODUCTS       SecureProducts )

/*++

Routine Description:

   Called as an optional part of replication, this function receives
   the list of products which require secure certificates.

Arguments:

   Handle (LLS_REPL_HANDLE)
      An open replication handle.
   Level (DWORD)
      Level of replicated secure product information.
   SecureProducts (REPL_SECURE_PRODUCTS)
      Replicated secure product information.

Return Value:

   STATUS_SUCCESS or STATUS_INVALID_LEVEL.

--*/

{
   NTSTATUS             nt;
   REPL_CONTEXT_TYPE *  pClient;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrReplicationProductSecurityAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ( 0 != Level )
   {
      nt = STATUS_INVALID_LEVEL;
   }
   else
   {
      pClient = (REPL_CONTEXT_TYPE *) Handle;

      if ((NULL == pClient) || (0 != memcmp(pClient->Signature,LLS_REPL_SIG,LLS_REPL_SIG_SIZE)))
      {
          return STATUS_INVALID_PARAMETER;
      }

      if (pClient->ProductSecuritySent)
      {
          // don't accept more than one Add
          return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
      }

      pClient->ProductSecuritySent       = TRUE;

      if ( NULL != SecureProducts )
      {
         pClient->ProductSecurityStringSize = SecureProducts->Level0.StringSize;
         pClient->ProductSecurityStrings    = SecureProducts->Level0.Strings;
      }

      nt = STATUS_SUCCESS;
   }

   return nt;
} // LlsrReplicationProductSecurityAddW


/////////////////////////////////////////////////////////////////////////
NTSTATUS
LlsrReplicationUserAddExW(
   LLS_REPL_HANDLE            Handle,
   DWORD                      Level,
   REPL_USERS                 Users )

/*++

Routine Description:

   Replacement for LlsrReplicationUserAddW().  (This function, unlike its
   counterpart, supports structure levels.)  This function replicates the
   user list.

Arguments:

   Handle (LLS_REPL_HANDLE)
      An open replication handle.
   Level (DWORD)
      Level of replicated user information.
   Users (REPL_USERS)
      Replicated user information.

Return Value:

   STATUS_SUCCESS or STATUS_INVALID_LEVEL.

--*/

{
   NTSTATUS             nt;
   REPL_CONTEXT_TYPE *  pClient;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrReplicationUserAddExW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ( ( 0 != Level ) && ( 1 != Level ) )
   {
      nt = STATUS_INVALID_LEVEL;
   }
   else
   {
      pClient = (REPL_CONTEXT_TYPE *) Handle;

      if ((NULL == pClient) || (0 != memcmp(pClient->Signature,LLS_REPL_SIG,LLS_REPL_SIG_SIZE)))
      {
          return STATUS_INVALID_PARAMETER;
      }

      if (pClient->UsersSent)
      {
          // don't accept more than one Add
          return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
      }

      pClient->UsersSent = TRUE;
      pClient->UserLevel = Level;

      if ( NULL != Users )
      {
         if ( 0 == Level )
         {
            pClient->UserTableSize = Users->Level0.NumUsers;
            pClient->Users         = Users->Level0.Users;
         }
         else
         {
            pClient->UserTableSize = Users->Level1.NumUsers;
            pClient->Users         = Users->Level1.Users;
         }

         // free container only
         MIDL_user_free( Users );
      }

      nt = STATUS_SUCCESS;
   }

   return nt;
} // LlsrReplicationUserAddExW


NTSTATUS
LlsrCapabilityGet(
   LLS_HANDLE  Handle,
   DWORD       cbCapabilities,
   LPBYTE      pbCapabilities )
{
   static DWORD adwCapabilitiesSupported[] =
   {
      LLS_CAPABILITY_SECURE_CERTIFICATES,
      LLS_CAPABILITY_REPLICATE_CERT_DB,
      LLS_CAPABILITY_REPLICATE_PRODUCT_SECURITY,
      LLS_CAPABILITY_REPLICATE_USERS_EX,
      LLS_CAPABILITY_SERVICE_INFO_GETW,
      LLS_CAPABILITY_LOCAL_SERVICE_API,
      (DWORD) -1L
   };

   DWORD    i;
   DWORD    dwCapByte;
   DWORD    dwCapBit;

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if (NULL == pbCapabilities)
   {
       return STATUS_INVALID_PARAMETER;
   }

   ZeroMemory( pbCapabilities, cbCapabilities );

   for ( i=0; (DWORD) -1L != adwCapabilitiesSupported[ i ]; i++ )
   {
      dwCapByte = adwCapabilitiesSupported[ i ] / 8;
      dwCapBit  = adwCapabilitiesSupported[ i ] - 8 * dwCapByte;

      if ( dwCapByte < cbCapabilities )
      {
         pbCapabilities[ dwCapByte ] |= ( 1 << dwCapBit );
      }
   }

   return STATUS_SUCCESS;
}


NTSTATUS
LlsrLocalServiceEnumW(
   LLS_HANDLE                       Handle,
   PLLS_LOCAL_SERVICE_ENUM_STRUCTW  LocalServiceInfo,
   DWORD                            PrefMaxLen,
   LPDWORD                          pTotalEntries,
   LPDWORD                          pResumeHandle )
{
   NTSTATUS    Status = STATUS_SUCCESS;
   PVOID       BufPtr = NULL;
   ULONG       BufSize = 0;
   ULONG       EntriesRead = 0;
   ULONG       TotalEntries = 0;
   ULONG       i = 0;
   ULONG       j = 0;
   const DWORD RecordSize = sizeof( LLS_LOCAL_SERVICE_INFO_0W );

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrLocalServiceEnumW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   // Need to scan list so get read access.
   RtlAcquireResourceShared(&LocalServiceListLock, TRUE);

   if ((NULL == pTotalEntries) || (NULL == LocalServiceInfo))
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pTotalEntries = 0;

   if ( 0 != LocalServiceInfo->Level )
   {
      return STATUS_INVALID_LEVEL;
   }

   if (LocalServiceInfo->LlsLocalServiceInfo.Level0 == NULL)
   {
       return STATUS_INVALID_PARAMETER;
   }

   // Calculate how many records will fit into PrefMaxLen buffer.
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;
   while ( ( i < LocalServiceListSize ) && ( BufSize < PrefMaxLen ) )
   {
      BufSize += RecordSize;
      EntriesRead++;
      i++;
   }

   TotalEntries = EntriesRead;

   // If we overflowed the buffer then back up one record.
   if (BufSize > PrefMaxLen)
   {
      BufSize -= RecordSize;
      EntriesRead--;
   }

   // Now walk to the end of the list to see how many more records are still
   // available.
   TotalEntries += LocalServiceListSize - i;

   if (TotalEntries > EntriesRead)
      Status = STATUS_MORE_ENTRIES;

   // Reset Enum to correct place.
   i = (pResumeHandle != NULL) ? *pResumeHandle : 0;

   // We now know how many records will fit into the buffer, so allocate space
   // and fix up pointers so we can copy the information.
   BufPtr = MIDL_user_allocate(BufSize);
   if (BufPtr == NULL)
   {
      Status = STATUS_NO_MEMORY;
      goto LlsrLocalServiceEnumWExit;
   }

   RtlZeroMemory((PVOID) BufPtr, BufSize);

   // Buffers are all setup, so loop through records and copy the data.
   while ((j < EntriesRead) && (i < LocalServiceListSize))
   {
      ((PLLS_LOCAL_SERVICE_INFO_0W) BufPtr)[j].KeyName           = LocalServiceList[i]->Name;
      ((PLLS_LOCAL_SERVICE_INFO_0W) BufPtr)[j].DisplayName       = LocalServiceList[i]->DisplayName;
      ((PLLS_LOCAL_SERVICE_INFO_0W) BufPtr)[j].FamilyDisplayName = LocalServiceList[i]->FamilyDisplayName;
      ((PLLS_LOCAL_SERVICE_INFO_0W) BufPtr)[j].Mode              = LocalServiceList[i]->Mode;
      ((PLLS_LOCAL_SERVICE_INFO_0W) BufPtr)[j].FlipAllow         = LocalServiceList[i]->FlipAllow;
      ((PLLS_LOCAL_SERVICE_INFO_0W) BufPtr)[j].ConcurrentLimit   = LocalServiceList[i]->ConcurrentLimit;
      ((PLLS_LOCAL_SERVICE_INFO_0W) BufPtr)[j].HighMark          = LocalServiceList[i]->HighMark;

      j++;
      i++;
   }

LlsrLocalServiceEnumWExit:
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("   TotalEntries: %lu EntriesRead: %lu ResumeHandle: 0x%lX\n"), TotalEntries, EntriesRead, i);
#endif
   *pTotalEntries = TotalEntries;

   if (pResumeHandle != NULL)
      *pResumeHandle = (ULONG) i;

   LocalServiceInfo->LlsLocalServiceInfo.Level0->EntriesRead = EntriesRead;
   LocalServiceInfo->LlsLocalServiceInfo.Level0->Buffer = (PLLS_LOCAL_SERVICE_INFO_0W) BufPtr;

   return Status;
}

void LlsrLocalServiceEnumW_notify_flag(
                                       boolean fNotify
                                       )
{
    if (fNotify)
    {
        RtlReleaseResource(&LocalServiceListLock);
    }
}

NTSTATUS
LlsrLocalServiceEnumA(
   LLS_HANDLE                       Handle,
   PLLS_LOCAL_SERVICE_ENUM_STRUCTA  LocalServiceInfo,
   DWORD                            PrefMaxLen,
   LPDWORD                          TotalEntries,
   LPDWORD                          ResumeHandle )
{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalServiceEnumA\n"));
#endif

   if (NULL == TotalEntries)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *TotalEntries = 0;

   return STATUS_NOT_SUPPORTED;
}


NTSTATUS
LlsrLocalServiceAddW(
   LLS_HANDLE                 Handle,
   DWORD                      Level,
   PLLS_LOCAL_SERVICE_INFOW   LocalServiceInfo )
{
   NTSTATUS    Status;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrLocalServiceAddW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ( 0 != Level )
   {
      Status = STATUS_INVALID_LEVEL;
   }
   else if ( ( NULL == LocalServiceInfo)
             || ( NULL == LocalServiceInfo->LocalServiceInfo0.KeyName        )
             || ( NULL == LocalServiceInfo->LocalServiceInfo0.DisplayName    )
             || ( NULL == LocalServiceInfo->LocalServiceInfo0.FamilyDisplayName ) )
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else
   {
      LONG  lError;
      HKEY  hKeyLicenseInfo;
      HKEY  hKeyService;
      DWORD dwDisposition;

      lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_KEY_LICENSE, 0, KEY_WRITE, &hKeyLicenseInfo );

      if ( ERROR_SUCCESS == lError )
      {
         // create key
         lError = RegCreateKeyEx( hKeyLicenseInfo, LocalServiceInfo->LocalServiceInfo0.KeyName, 0, NULL, 0, KEY_WRITE, NULL, &hKeyService, &dwDisposition );

         if ( ERROR_SUCCESS == lError )
         {
            // set DisplayName
            lError = RegSetValueEx( hKeyService,
                                    REG_VALUE_NAME,
                                    0,
                                    REG_SZ,
                                    (LPBYTE) LocalServiceInfo->LocalServiceInfo0.DisplayName,
                                    (   sizeof( *LocalServiceInfo->LocalServiceInfo0.DisplayName )
                                      * ( 1 + lstrlen( LocalServiceInfo->LocalServiceInfo0.DisplayName ) ) ) );

            if ( ERROR_SUCCESS == lError )
            {
               // set FamilyDisplayName
               lError = RegSetValueEx( hKeyService,
                                       REG_VALUE_FAMILY,
                                       0,
                                       REG_SZ,
                                       (LPBYTE) LocalServiceInfo->LocalServiceInfo0.FamilyDisplayName,
                                       (   sizeof( *LocalServiceInfo->LocalServiceInfo0.FamilyDisplayName )
                                         * ( 1 + lstrlen( LocalServiceInfo->LocalServiceInfo0.FamilyDisplayName ) ) ) );
            }

            RegCloseKey( hKeyService );
         }

         RegCloseKey( hKeyLicenseInfo );
      }

      switch ( lError )
      {
      case ERROR_SUCCESS:
         Status = STATUS_SUCCESS;
         break;
      case ERROR_FILE_NOT_FOUND:
      case ERROR_PATH_NOT_FOUND:
         Status = STATUS_OBJECT_NAME_NOT_FOUND;
         break;
      default:
         Status = STATUS_UNSUCCESSFUL;
         break;
      }

      if ( STATUS_SUCCESS == Status )
      {
         // set remaining items and update LocalServiceList
         Status = LlsrLocalServiceInfoSetW( Handle, LocalServiceInfo->LocalServiceInfo0.KeyName, Level, LocalServiceInfo );
      }
   }

   return Status;
}


NTSTATUS
LlsrLocalServiceAddA(
   LLS_HANDLE                 Handle,
   DWORD                      Level,
   PLLS_LOCAL_SERVICE_INFOA   LocalServiceInfo )
{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalServiceAddA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
}


NTSTATUS
LlsrLocalServiceInfoSetW(
   LLS_HANDLE                 Handle,
   LPWSTR                     KeyName,
   DWORD                      Level,
   PLLS_LOCAL_SERVICE_INFOW   LocalServiceInfo )
{
   NTSTATUS    Status;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalServiceInfoSetW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   if ( 0 != Level )
   {
      Status = STATUS_INVALID_LEVEL;
   }
   else if (( NULL == KeyName ) || ( NULL == LocalServiceInfo ))
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else
   {
      LONG  lError;
      HKEY  hKeyLicenseInfo;
      HKEY  hKeyService;

      lError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_KEY_LICENSE, 0, KEY_WRITE, &hKeyLicenseInfo );

      if ( ERROR_SUCCESS == lError )
      {
         lError = RegOpenKeyEx( hKeyLicenseInfo, KeyName, 0, KEY_WRITE, &hKeyService );

         if ( ERROR_SUCCESS == lError )
         {
            // set Mode
            lError = RegSetValueEx( hKeyService, REG_VALUE_MODE, 0, REG_DWORD, (LPBYTE) &LocalServiceInfo->LocalServiceInfo0.Mode, sizeof( LocalServiceInfo->LocalServiceInfo0.Mode ) );

            if ( ERROR_SUCCESS == lError )
            {
               // set FlipAllow
               lError = RegSetValueEx( hKeyService, REG_VALUE_FLIP, 0, REG_DWORD, (LPBYTE) &LocalServiceInfo->LocalServiceInfo0.FlipAllow, sizeof( LocalServiceInfo->LocalServiceInfo0.FlipAllow ) );

               if ( ERROR_SUCCESS == lError )
               {
                  // set ConcurrentLimit
                  lError = RegSetValueEx( hKeyService, REG_VALUE_LIMIT, 0, REG_DWORD, (LPBYTE) &LocalServiceInfo->LocalServiceInfo0.ConcurrentLimit, sizeof( LocalServiceInfo->LocalServiceInfo0.ConcurrentLimit ) );
               }
            }

            RegCloseKey( hKeyService );
         }

         RegCloseKey( hKeyLicenseInfo );
      }

      switch ( lError )
      {
      case ERROR_SUCCESS:
         Status = STATUS_SUCCESS;
         break;
      case ERROR_FILE_NOT_FOUND:
      case ERROR_PATH_NOT_FOUND:
         Status = STATUS_OBJECT_NAME_NOT_FOUND;
         break;
      default:
         Status = STATUS_UNSUCCESSFUL;
         break;
      }

      if ( STATUS_SUCCESS == Status )
      {
         LocalServiceListUpdate();
         LocalServerServiceListUpdate();
         ServiceListResynch();
      }
   }

   return Status;
}


NTSTATUS
LlsrLocalServiceInfoSetA(
   LLS_HANDLE                 Handle,
   LPSTR                      KeyName,
   DWORD                      Level,
   PLLS_LOCAL_SERVICE_INFOA   LocalServiceInfo )
{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalServiceInfoSetA\n"));
#endif

   return STATUS_NOT_SUPPORTED;
}


NTSTATUS
LlsrLocalServiceInfoGetW(
   LLS_HANDLE                 Handle,
   LPWSTR                     KeyName,
   DWORD                      Level,
   PLLS_LOCAL_SERVICE_INFOW * pLocalServiceInfo )
{
   NTSTATUS    Status;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsrLocalServiceInfoGetW\n"));
#endif

#if DELAY_INITIALIZATION
   EnsureInitialized();
#endif

   RtlAcquireResourceShared(&LocalServiceListLock, TRUE);

   if (NULL == pLocalServiceInfo)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pLocalServiceInfo = NULL;

   if ( 0 != Level )
   {
      Status = STATUS_INVALID_LEVEL;
   }
   else if ( NULL == KeyName )
   {
      Status = STATUS_INVALID_PARAMETER;
   }
   else
   {
      PLOCAL_SERVICE_RECORD   pRecord;

      pRecord = LocalServiceListFind( KeyName );

      if ( NULL == pRecord )
      {
         Status = STATUS_OBJECT_NAME_NOT_FOUND;
      }
      else
      {
         *pLocalServiceInfo = MIDL_user_allocate( sizeof( **pLocalServiceInfo ) );

         if ( NULL == *pLocalServiceInfo )
         {
            Status = STATUS_NO_MEMORY;
         }
         else
         {
            (*pLocalServiceInfo)->LocalServiceInfo0.KeyName           = pRecord->Name;
            (*pLocalServiceInfo)->LocalServiceInfo0.DisplayName       = pRecord->DisplayName;
            (*pLocalServiceInfo)->LocalServiceInfo0.FamilyDisplayName = pRecord->FamilyDisplayName;
            (*pLocalServiceInfo)->LocalServiceInfo0.Mode              = pRecord->Mode;
            (*pLocalServiceInfo)->LocalServiceInfo0.FlipAllow         = pRecord->FlipAllow;
            (*pLocalServiceInfo)->LocalServiceInfo0.ConcurrentLimit   = pRecord->ConcurrentLimit;
            (*pLocalServiceInfo)->LocalServiceInfo0.HighMark          = pRecord->HighMark;

            Status = STATUS_SUCCESS;
         }
      }
   }

   return Status;
}

void LlsrLocalServiceInfoGetW_notify_flag(
                                          boolean fNotify
                                          )
{
    if (fNotify)
    {
        RtlReleaseResource(&LocalServiceListLock);
    }
}

NTSTATUS
LlsrLocalServiceInfoGetA(
   LLS_HANDLE                 Handle,
   LPSTR                      KeyName,
   DWORD                      Level,
   PLLS_LOCAL_SERVICE_INFOA * pLocalServiceInfo )
{
#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_RPC))
      dprintf(TEXT("LLS TRACE: LlsLocalServiceInfoGetA\n"));
#endif

   if (NULL == pLocalServiceInfo)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pLocalServiceInfo = NULL;

   return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\scaven.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   scaven.c

Abstract:

Author:

   Arthur Hanson (arth) 06-Jan-1995

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added periodic logging of certificate agreement violations.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dsgetdc.h>

#include "llsapi.h"
#include "debug.h"
#include "llsutil.h"
#include "llssrv.h"
#include "registry.h"
#include "ntlsapi.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "purchase.h"
#include "perseat.h"
#include "server.h"
#include "repl.h"
#include "llsevent.h"
#include "llsrpc_s.h"
#include "certdb.h"

NTSTATUS LLSDataSave();


/////////////////////////////////////////////////////////////////////////
VOID
ScavengerThread (
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

Arguments:

    ThreadParameter - Indicates how many active threads there currently
        are.

Return Value:

   None.

--*/

{
   ULONG i;
   ULONG Count = 0;

   //
   // Just wait around forver waiting to service things.
   //
   while (TRUE) {
      //
      // Wait 15 minutes before checking things out.
      //
      Sleep(900000L);

#if DELAY_INITIALIZATION
      EnsureInitialized();
#endif

#if DBG
      if (TraceFlags & TRACE_FUNCTION_TRACE)
         dprintf(TEXT("LLS TRACE: ScavengerThread waking up\n"));
#endif
      //
      // Update HighMark for local table
      //
      LocalServerServiceListHighMarkUpdate();

      //
      // Hmm, lets check replication...
      //
      ConfigInfoRegistryUpdate();

      RtlEnterCriticalSection(&ConfigInfoLock);
      if (ConfigInfo.Replicate) {
         //
         // If we are past replication time then do it
         //
         if (DateLocalGet() > ConfigInfo.NextReplication) {
            RtlLeaveCriticalSection(&ConfigInfoLock);
            NtSetEvent( ReplicationEvent, NULL );
         }
         else {
            RtlLeaveCriticalSection(&ConfigInfoLock);
         }
      }
      else {
         RtlLeaveCriticalSection(&ConfigInfoLock);
      }

      //
      // Now update our last used time
      //
      RtlAcquireResourceExclusive(&UserListLock, TRUE);
      LastUsedTime = DateSystemGet();
      RtlReleaseResource(&UserListLock);

      //
      // Check stuff every 6 hours (4 * 15 minutes)
      //
      Count++;
      if (Count > (6 * 4)) {
         // Reset counter
         Count = 0;

         //
         // Save out the data
         //
         LLSDataSave();

         //
         // Save HighMark to registry
         //
         LocalServiceListHighMarkSet();

         if (IsMaster) {
            //
            // Check for license compliance
            //
            RtlAcquireResourceShared(&MasterServiceListLock, TRUE);

            for (i = 0; i < MasterServiceListSize; i++) {
               if (MasterServiceList[i]->LicensesUsed > MasterServiceList[i]->Licenses) {
                  LPWSTR SubString[1];

                  //
                  // Notify the system
                  //
                  SubString[0] = (LPWSTR) MasterServiceList[i]->Name;

                  LogEvent(LLS_EVENT_PRODUCT_NO_LICENSE, 1, SubString, ERROR_SUCCESS);
               }
            }

            RtlReleaseResource(&MasterServiceListLock);

            // log certificate violations
            CertDbLogViolations();
         }
      }
   }

} // ScavengerThread


/////////////////////////////////////////////////////////////////////////
VOID
ScavengerInit( )

/*++

Routine Description:

   Looks in registry for given service and sets values accordingly.

Arguments:

Return Value:

   None.

--*/

{
   HANDLE Thread;
   DWORD Ignore;

   //
   // Just dispatch our scavenger thread
   //
   Thread = CreateThread(
                 NULL,
                 0L,
                 (LPTHREAD_START_ROUTINE) ScavengerThread,
                 0L,
                 0L,
                 &Ignore
                 );

   if (NULL != Thread)
       CloseHandle(Thread);

} // ScavengerInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\registry.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

   registry.c

Abstract:

   Registry reading routines for License Server.  Can Scan the registry
   for all License Service entries, or for a specific service.

Author:

   Arthur Hanson (arth) 07-Dec-1994

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Removed unnecessary RegConnect() to local server.
      o  Added secure service list.  This list tracks the products that
         require "secure" license certificates for all licenses; i.e., the
         products that do not accept the 3.51 Honesty method of "enter the
         number of license you purchased."
      o  Added routine to update the concurrent limit value in the registry
         to accurately reflect the connection limit of secure products.

--*/

#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <rpcndr.h>
#include <dsgetdc.h>


#include "llsapi.h"
#include "debug.h"
#include "llssrv.h"
#include "registry.h"
#include "ntlsapi.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "purchase.h"
#include "perseat.h"
#include "server.h"
#include "llsutil.h"

// #define API_TRACE 1

#define NUM_MAPPING_ENTRIES 2

const LPTSTR NameMappingTable2[] = {
   TEXT("Microsoft SQL Server"),
   TEXT("Microsoft SNA Server")
}; // NameMappingTable2


ULONG NumFilePrintEntries = 0;
LPTSTR *FilePrintTable = NULL;

#define KEY_NAME_SIZE 512

HANDLE LLSRegistryEvent;


ULONG LocalServiceListSize = 0;
PLOCAL_SERVICE_RECORD *LocalServiceList = NULL;

RTL_RESOURCE LocalServiceListLock;

static ULONG          SecureServiceListSize    = 0;
static LPTSTR *       SecureServiceList        = NULL;
static ULONG          SecureServiceBufferSize  = 0;       // in bytes!
static TCHAR *        SecureServiceBuffer      = NULL;


/////////////////////////////////////////////////////////////////////////
VOID
ConfigInfoRegistryInit(
   DWORD *  pReplicationType,
   DWORD *  pReplicationTime,
   DWORD *  pLogLevel,
   BOOL *   pPerServerCapacityWarning
   )
{
   HKEY           hKey2 = NULL;
   DWORD          dwType, dwSize;
   static BOOL    ReportedError = FALSE;
   static const TCHAR   RegKeyText[] = TEXT("System\\CurrentControlSet\\Services\\LicenseService\\Parameters");
   LONG           Status;
   BOOL           ret = FALSE;
   DWORD          ReplicationType, ReplicationTime;
   DWORD          LogLevel;
   DWORD          DisableCapacityWarning;

   ReplicationType = ReplicationTime = LogLevel = 0;

   //
   // Create registry key-name we are looking for
   //

   if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegKeyText, 0, KEY_READ, &hKey2)) == ERROR_SUCCESS)
   {
      dwSize = sizeof(ReplicationType);
      Status = RegQueryValueEx(hKey2, TEXT("ReplicationType"), NULL, &dwType, (LPBYTE) &ReplicationType, &dwSize);

      if (Status == ERROR_SUCCESS)
      {
         dwSize = sizeof(ReplicationTime);
         Status = RegQueryValueEx(hKey2, TEXT("ReplicationTime"), NULL, &dwType, (LPBYTE) &ReplicationTime, &dwSize);

         if (Status == ERROR_SUCCESS)
         {
            *pReplicationType = ReplicationType;
            *pReplicationTime = ReplicationTime;
         }
         else
         {
            if (!ReportedError)
            {
               ReportedError = TRUE;
#ifdef DEBUG
               dprintf(TEXT("LLS: (WARNING) No registry parm for ReplicationTime\n"));
#endif
            }
         }

      }
      else
      {
         if (!ReportedError)
         {
            ReportedError = TRUE;
#ifdef DEBUG
            dprintf(TEXT("LLS: (WARNING) No registry parm for ReplicationType\n"));
#endif
         }
      }

      // LogLevel (REG_DWORD): determines how much info is dumped to the EventLog.
      //   Higher values imply more logging.  Default: 0.
      dwSize = sizeof( LogLevel );
      Status = RegQueryValueEx( hKey2, TEXT("LogLevel"), NULL, &dwType, (LPBYTE) &LogLevel, &dwSize);
      if ( ERROR_SUCCESS == Status )
         *pLogLevel = LogLevel;
      else
         *pLogLevel = 0;

      //
      // Read the per server capacity warning value. A warning when the per
      // server license usage nears 90-95% of the total number of licenses.
      // A non-zero registry value disables the per server capacity warning
      // mechanism.
      //
      // It is not likely this value wll be present. Default to warn.
      //

      dwSize = sizeof( DisableCapacityWarning );

      Status = RegQueryValueEx( hKey2,
                                TEXT("DisableCapacityWarning"),
                                NULL,
                                &dwType,
                                (LPBYTE)&DisableCapacityWarning,
                                &dwSize);

      if ( ERROR_SUCCESS == Status && DisableCapacityWarning ) {
         *pPerServerCapacityWarning = FALSE;
      }
      else {
         *pPerServerCapacityWarning = TRUE;
      }

      // ProductData (REG_BINARY): an encrypted buffer of concatenated service names
      //    that determine which services need to have secure certificates
      //    for license entry
      Status = RegQueryValueEx( hKey2, TEXT("ProductData"), NULL, &dwType, NULL, &dwSize );
      if ( ERROR_SUCCESS == Status )
      {
         TCHAR *     NewSecureServiceBuffer     = NULL;
         LPTSTR *    NewSecureServiceList       = NULL;
         ULONG       NewSecureServiceListSize   = 0;
         ULONG       NewSecureServiceBufferSize;

         NewSecureServiceBufferSize = dwSize;
         NewSecureServiceBuffer = LocalAlloc( LMEM_FIXED, NewSecureServiceBufferSize );

         if ( NULL != NewSecureServiceBuffer )
         {
            Status = RegQueryValueEx( hKey2, TEXT("ProductData"), NULL, &dwType, (LPBYTE) NewSecureServiceBuffer, &dwSize);

            if ( ERROR_SUCCESS == Status )
            {
               Status = DeBlock( NewSecureServiceBuffer, dwSize );

               if (    ( STATUS_SUCCESS == Status )
                    && (    ( NULL == SecureServiceBuffer )
                         || ( memcmp( NewSecureServiceBuffer, SecureServiceBuffer, dwSize ) ) ) )
               {
                  // process changes in secure product list
                  DWORD    i;
                  DWORD    ProductNdx;

                  NewSecureServiceListSize = 0;

                  // count number of product names contained in the buffer
                  for ( i=0; ( i < dwSize ) && ( NewSecureServiceBuffer[i] != TEXT( '\0' ) ); i++ )
                  {
                     // skip to beginning of next product name
                     for ( ; ( i < dwSize ) && ( NewSecureServiceBuffer[i] != TEXT( '\0' ) ); i++ );
                     i++;

                     if ( i * sizeof( TCHAR) < dwSize )
                     {
                        // properly null-terminated product name
                        NewSecureServiceListSize++;
                     }
                  }

                  if ( 0 != NewSecureServiceListSize )
                  {
                     NewSecureServiceList = LocalAlloc( LMEM_FIXED, sizeof( LPTSTR ) * NewSecureServiceListSize );

                     if ( NULL != NewSecureServiceList )
                     {
                        for ( i = ProductNdx = 0; ProductNdx < NewSecureServiceListSize; ProductNdx++ )
                        {
                           NewSecureServiceList[ ProductNdx ] = &NewSecureServiceBuffer[i];

                           // skip to beginning of next product name
                           for ( ; NewSecureServiceBuffer[i] != TEXT( '\0' ); i++ );
                           i++;
                        }

                        // new secure product list read successfully; use it
                        if ( NULL != SecureServiceBuffer )
                        {
                           LocalFree( SecureServiceBuffer );
                        }
                        if ( NULL != SecureServiceList )
                        {
                           LocalFree( SecureServiceList );
                        }

                        SecureServiceBuffer     = NewSecureServiceBuffer;
                        SecureServiceList       = NewSecureServiceList;
                        SecureServiceListSize   = NewSecureServiceListSize;
                        SecureServiceBufferSize = NewSecureServiceBufferSize;
                     }
                  }
               }
            }
         }

         // free buffers if we aren't using them anymore
         if (    ( NULL              != NewSecureServiceList )
              && ( SecureServiceList != NewSecureServiceList ) )
         {
            LocalFree( NewSecureServiceList );
         }

         if (    ( NULL                != NewSecureServiceBuffer )
              && ( SecureServiceBuffer != NewSecureServiceBuffer ) )
         {
            LocalFree( NewSecureServiceBuffer );
         }
      }

      RegCloseKey(hKey2);
   }

} // ConfigInfoRegistryInit


/////////////////////////////////////////////////////////////////////////
NTSTATUS
FilePrintTableInit(
   )

/*++

Routine Description:

   Builds up the FilePrint mapping table by enumerating the keys in the
   registry init'd by the various install programs.

Arguments:


Return Value:

   None.

--*/

{
   HKEY hKey2;
   static const TCHAR RegKeyText[] = TEXT("System\\CurrentControlSet\\Services\\LicenseService\\FilePrint");
   static TCHAR KeyText[KEY_NAME_SIZE], ClassText[KEY_NAME_SIZE];
   NTSTATUS Status;
   DWORD index = 0;
   DWORD KeySize, ClassSize, NumKeys, NumValue, MaxKey, MaxClass, MaxValue, MaxValueData, MaxSD;
   FILETIME LastWrite;
   LPTSTR *pFilePrintTableTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: FilePrintTableInit\n"));
#endif
   //
   // Create registry key-name we are looking for
   //

   if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegKeyText, 0, KEY_READ, &hKey2)) == ERROR_SUCCESS) {
      //
      // Find out how many sub-keys there are to intialize our table size.
      // The table can still grow dynamically, this just makes having to
      // realloc it a rare occurance.
      //
      ClassSize = KEY_NAME_SIZE;
      Status = RegQueryInfoKey(hKey2, ClassText, &ClassSize, NULL,
                               &NumKeys, &MaxKey, &MaxClass, &NumValue,
                               &MaxValue, &MaxValueData, &MaxSD, &LastWrite);

      if (Status == ERROR_SUCCESS) {
         FilePrintTable = (LPTSTR *) LocalAlloc(LPTR, sizeof(LPTSTR) * NumKeys);

         while ((Status == ERROR_SUCCESS) && (FilePrintTable != NULL)) {
             //
             // Double check in-case we need to expand the table.
             //
             if (index > NumKeys) {
                pFilePrintTableTmp = (LPTSTR *) LocalReAlloc(FilePrintTable, sizeof(LPTSTR) * (NumKeys+1), LHND);

                if (pFilePrintTableTmp == NULL)
                {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                } else
                {
                    NumKeys++;
                    FilePrintTable = pFilePrintTableTmp;
                }
             }

             //
             // Now read in the key name and add it to the table
             //
             KeySize = KEY_NAME_SIZE;
             Status = RegEnumKeyEx(hKey2, index, KeyText, &KeySize, NULL, NULL, NULL, &LastWrite);
             if (Status == ERROR_SUCCESS) {
                 //
                 // Allocate space in our table and copy the key
                 //
                 FilePrintTable[index] = (LPTSTR) LocalAlloc(LPTR, (KeySize + 1) * sizeof(TCHAR));
                 
                 if (FilePrintTable[index] != NULL) {
                     lstrcpy(FilePrintTable[index], KeyText);
                     index++;
                 } else
                     Status = ERROR_NOT_ENOUGH_MEMORY;

             }
         }
      }
#ifdef DEBUG
        else {
           dprintf(TEXT("LLS FilePrintTable Error: 0x%lx\n"), Status);
        }
#endif

      RegCloseKey( hKey2 );
   }

   if (FilePrintTable != NULL)
      NumFilePrintEntries = index;
   else
      NumFilePrintEntries = 0;

   return Status;

} // FilePrintTableInit


/////////////////////////////////////////////////////////////////////////
NTSTATUS
RegistryMonitor (
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

   Watches for any changes in the Licensing Keys, and if any updates our
   internal information.

Arguments:

    ThreadParameter - Indicates how many active threads there currently
        are.

Return Value:

   None.

--*/

{
   LONG Status = 0;
   HKEY hKey1 = NULL;
   HKEY hKey2 = NULL;
   NTSTATUS NtStatus = STATUS_SUCCESS;
   static const TCHAR RegKeyText1[] = TEXT("System\\CurrentControlSet\\Services\\LicenseService");
   static const TCHAR RegKeyText2[] = TEXT("System\\CurrentControlSet\\Services\\LicenseInfo");
   HANDLE Events[2];
   DWORD dwWhichEvent = 0;      // Keeps track of which event was last triggered

   //
   // Open registry key-name we are looking for
   //

   if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegKeyText1, 0, KEY_ALL_ACCESS, &hKey1)) != ERROR_SUCCESS) {
#if DBG
      dprintf(TEXT("LLS RegistryMonitor - RegOpenKeyEx failed: 0x%lX\n"), Status);
#endif
      return (NTSTATUS) Status;
   }

   if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegKeyText2, 0, KEY_ALL_ACCESS, &hKey2)) != ERROR_SUCCESS) {
#if DBG
      dprintf(TEXT("LLS RegistryMonitor - RegOpenKeyEx 2 failed: 0x%lX\n"), Status);
#endif
      RegCloseKey(hKey1);

      return (NTSTATUS) Status;
   }

   if ((Status = NtCreateEvent(Events,EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE,NULL,SynchronizationEvent,FALSE)) != ERROR_SUCCESS)
   {
#if DBG
      dprintf(TEXT("LLS RegistryMonitor - RegOpenKeyEx 2 failed: 0x%lX\n"), Status);
#endif
      RegCloseKey(hKey1);
      RegCloseKey(hKey2);

      return (NTSTATUS) Status;
   }

   Events[1] = LLSRegistryEvent;

   //
   // Loop forever
   //
   for ( ; ; ) {

      if ((dwWhichEvent == 0) || (dwWhichEvent == 2))
      {
          Status = RegNotifyChangeKeyValue(hKey1, TRUE, REG_NOTIFY_CHANGE_LAST_SET, LLSRegistryEvent, TRUE);
          if (Status != ERROR_SUCCESS) {
#if DBG
              dprintf(TEXT("LLS RegNotifyChangeKeyValue Failed: %lu\n"), Status);
#endif
          }
      }

      if ((dwWhichEvent == 0) || (dwWhichEvent == 1))
      {
          Status = RegNotifyChangeKeyValue(hKey2, TRUE, REG_NOTIFY_CHANGE_LAST_SET, Events[0], TRUE);
          if (Status != ERROR_SUCCESS) {
#if DBG
              dprintf(TEXT("LLS RegNotifyChangeKeyValue 2 Failed: %lu\n"), Status);
#endif
          }
      }

      NtStatus = NtWaitForMultipleObjects( 2, Events, WaitAny, TRUE, NULL );

      switch (NtStatus)
      {
          case 0:
              dwWhichEvent = 1;
              break;
          case 1:
              dwWhichEvent = 2;
              break;
          default:
              dwWhichEvent = 0;
              break;
      }

#if DELAY_INITIALIZATION
      EnsureInitialized();
#endif

      //
      // Re-synch the lists
      //
      LocalServiceListUpdate();
      LocalServerServiceListUpdate();
      ServiceListResynch();
      ConfigInfoRegistryUpdate();
      LocalServiceListConcurrentLimitSet();

      if (dwWhichEvent == 0)
      {
#if DBG
         dprintf(TEXT("LLS Registry Event Notification Failed: %lu\n"), NtStatus);
#endif
         //
         // If we failed - sleep for 2 minutes before looping
         //
         Sleep(120000L);
      }
   }

   return NtStatus;

} // RegistryMonitor


/////////////////////////////////////////////////////////////////////////
VOID
RegistryInit( )

/*++

Routine Description:

   Looks in registry for given service and sets values accordingly.

Arguments:

Return Value:

   None.

--*/

{
   NTSTATUS       Status;
   BOOL           ret = FALSE;
   DWORD          Mode, ConcurrentLimit;

   Mode = 0;
   ConcurrentLimit = 0;

   //
   // Create a key to tell us about any changes in the registry
   //
   Status = NtCreateEvent(
                &LLSRegistryEvent,
                EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE,
                NULL,
                SynchronizationEvent,
                FALSE
                );

   ASSERT(NT_SUCCESS(Status));

} // RegistryInit


/////////////////////////////////////////////////////////////////////////
VOID
RegistryStartMonitor( )

/*++

Routine Description:

   Looks in registry for given service and sets values accordingly.

Arguments:

Return Value:

   None.

--*/

{
   HANDLE Thread;
   DWORD Ignore;

   //
   // Now dispatch a thread to watch for any registry changes
   //
   Thread = CreateThread(
                 NULL,
                 0L,
                 (LPTHREAD_START_ROUTINE) RegistryMonitor,
                 0L,
                 0L,
                 &Ignore
                 );

   if (Thread != NULL)
       CloseHandle(Thread);

} // RegistryStartMonitor


/////////////////////////////////////////////////////////////////////////
VOID
RegistryInitValues(
   LPTSTR ServiceName,
   BOOL *PerSeatLicensing,
   ULONG *SessionLimit
   )

/*++

Routine Description:

   Looks in registry for given service and sets values accordingly.

Arguments:

   Service Name -

   PerSeatLicensing -

   SessionLimit -

Return Value:

   None.

--*/

{
   HKEY hKey2 = NULL;
   DWORD dwType, dwSize;
   static TCHAR RegKeyText[512];
   LONG Status;
   DWORD Mode, ConcurrentLimit;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: RegistryInitValues\n"));
#endif

#ifdef SPECIAL_USER_LIMIT
   *PerSeatLicensing = FALSE;
   *SessionLimit     = SPECIAL_USER_LIMIT;
#else // #ifdef SPECIAL_USER_LIMIT
   Mode = 0;
   ConcurrentLimit = 0;

   //
   // Create registry key-name we are looking for
   //
   lstrcpy(RegKeyText, TEXT("System\\CurrentControlSet\\Services\\LicenseInfo\\"));
   lstrcat(RegKeyText, ServiceName);

   if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegKeyText, 0, KEY_READ, &hKey2)) == ERROR_SUCCESS) {
      //
      // First Get Mode
      //
      dwSize = sizeof(Mode);
      Status = RegQueryValueEx(hKey2, TEXT("Mode"), NULL, &dwType, (LPBYTE) &Mode, &dwSize);

#if DBG
      if ((TraceFlags & TRACE_REGISTRY) && (Status == ERROR_SUCCESS))
         dprintf(TEXT("Found Reg-Key for [%s] Mode: %ld\n"), ServiceName, Mode);
#endif
      //
      // Now Concurrent Limit
      //
      dwSize = sizeof(ConcurrentLimit);
      Status = RegQueryValueEx(hKey2, TEXT("ConcurrentLimit"), NULL, &dwType, (LPBYTE) &ConcurrentLimit, &dwSize);

#if DBG
      if ((TraceFlags & TRACE_REGISTRY) && (Status == ERROR_SUCCESS))
         dprintf(TEXT("Found Reg-Key for [%s] ConcurrentLimit: %ld\n"), ServiceName, ConcurrentLimit);
#endif
      RegCloseKey(hKey2);

   }


   if (Mode == 0) {
      *PerSeatLicensing = TRUE;
      *SessionLimit = 0;
   } else {
      *PerSeatLicensing = FALSE;
      *SessionLimit = ConcurrentLimit;
   }
#endif // #else // #ifdef SPECIAL_USER_LIMIT
} // RegistryInitValues


/////////////////////////////////////////////////////////////////////////
VOID
RegistryDisplayNameGet(
   LPTSTR ServiceName,
   LPTSTR DefaultName,
   LPTSTR *pDisplayName
   )

/*++

Routine Description:


Arguments:

   Service Name -

Return Value:

   None.

--*/

{
   HKEY                    hKey2 = NULL;
   DWORD                   dwType, dwSize;
   static TCHAR            RegKeyText[512];
   static TCHAR            DisplayName[512];
   LONG                    Status;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: RegistryDisplayNameGet\n"));
#endif

   lstrcpy(DisplayName, DefaultName);

   //
   // Create registry key-name we are looking for
   //
   lstrcpy(RegKeyText, TEXT("System\\CurrentControlSet\\Services\\LicenseInfo\\"));
   lstrcat(RegKeyText, ServiceName);

   if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegKeyText, 0, KEY_READ, &hKey2)) == ERROR_SUCCESS) {
      dwSize = sizeof(DisplayName);
      Status = RegQueryValueEx(hKey2, TEXT("DisplayName"), NULL, &dwType, (LPBYTE) DisplayName, &dwSize);

#  if DBG
      if ((TraceFlags & TRACE_REGISTRY) && (Status == ERROR_SUCCESS))
         dprintf(TEXT("Found Reg-Key for [%s] DisplayName: %s\n"), ServiceName, DisplayName);
#  endif
      RegCloseKey(hKey2);

   }

   *pDisplayName = LocalAlloc(LPTR, (lstrlen(DisplayName) + 1) * sizeof(TCHAR));
   if (*pDisplayName != NULL)
      lstrcpy(*pDisplayName, DisplayName);

} // RegistryDisplayNameGet


/////////////////////////////////////////////////////////////////////////
VOID
RegistryFamilyDisplayNameGet(
   LPTSTR ServiceName,
   LPTSTR DefaultName,
   LPTSTR *pDisplayName
   )

/*++

Routine Description:


Arguments:

   Service Name -

Return Value:

   None.

--*/

{
   HKEY hKey2 = NULL;
   DWORD dwType, dwSize;
   static TCHAR RegKeyText[512];
   static TCHAR DisplayName[MAX_PATH + 1];
   LONG Status;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: RegistryFamilyDisplayNameGet\n"));
#endif

   lstrcpy(DisplayName, DefaultName);

   //
   // Create registry key-name we are looking for
   //
   lstrcpy(RegKeyText, TEXT("System\\CurrentControlSet\\Services\\LicenseInfo\\"));
   lstrcat(RegKeyText, ServiceName);

   if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegKeyText, 0, KEY_READ, &hKey2)) == ERROR_SUCCESS) {
      dwSize = sizeof(DisplayName);
      Status = RegQueryValueEx(hKey2, TEXT("FamilyDisplayName"), NULL, &dwType, (LPBYTE) DisplayName, &dwSize);

#  if DBG
      if ((TraceFlags & TRACE_REGISTRY) && (Status == ERROR_SUCCESS))
         dprintf(TEXT("Found Reg-Key for [%s] FamilyDisplayName: %s\n"), ServiceName, DisplayName);
#  endif
      RegCloseKey(hKey2);

   }

   *pDisplayName = LocalAlloc(LPTR, (lstrlen(DisplayName) + 1) * sizeof(TCHAR));
   if (*pDisplayName != NULL)
      lstrcpy(*pDisplayName, DisplayName);
} // RegistryFamilyDisplayNameGet


/////////////////////////////////////////////////////////////////////////
LPTSTR
ServiceFindInTable(
   LPTSTR ServiceName,
   const LPTSTR Table[],
   ULONG TableSize,
   ULONG *TableIndex
   )

/*++

Routine Description:

   Does search of table to find matching service name.

Arguments:

   Service Name -

   Table -

   TableSize -

   TableIndex -

Return Value:

   Pointer to found service or NULL if not found.

--*/

{
   ULONG i = 0;
   BOOL Found = FALSE;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServiceFindInTable\n"));
#endif
   while ((i < TableSize) && (!Found)) {
      Found = !lstrcmpi(ServiceName, Table[i]);
      i++;
   }

   if (Found) {
      i--;
      *TableIndex = i;
      return Table[i];
   } else
      return NULL;

} // ServiceFindInTable


/////////////////////////////////////////////////////////////////////////
VOID
RegistryInitService(
   LPTSTR ServiceName,
   BOOL *PerSeatLicensing,
   ULONG *SessionLimit
   )

/*++

Routine Description:

   Gets init values for a given service from the registry.  If not found
   then just returns default values.

Arguments:

   ServiceName -

   PerSeatLicensing -

   SessionLimit -

Return Value:

--*/

{
   //
   // These are the default values
   //
   ULONG TableEntry;
   LPTSTR SvcName = NULL;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: RegistryInitService\n"));
#endif
   *PerSeatLicensing = FALSE;
   *SessionLimit = 0;

   //
   // Check if it is a file/print service - if so don't worry about rest
   // of registry entries.
   //
   if (ServiceFindInTable(ServiceName, FilePrintTable, NumFilePrintEntries, &TableEntry)) {
      return;
   }

   //
   // Not FilePrint - see if we need to map the name.
   //
   SvcName = ServiceFindInTable(ServiceName, NameMappingTable2, NUM_MAPPING_ENTRIES, &TableEntry);

   // if it wasn't found, use original ServiceName
   if (SvcName == NULL)
      SvcName = ServiceName;

    RegistryInitValues(SvcName, PerSeatLicensing, SessionLimit);

#if DBG
      if (TraceFlags & TRACE_REGISTRY)
         if (*PerSeatLicensing)
            dprintf(TEXT("LLS - Registry Init: PerSeat: Y Svc: %s\n"), SvcName);
         else
            dprintf(TEXT("LLS - Registry Init: PerSeat: N Svc: %s\n"), SvcName);
#endif

} // RegistryInitService



/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////
NTSTATUS
LocalServiceListInit()

/*++

Routine Description:

Arguments:

   None.

Return Value:

   None.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;

   try
   {
       RtlInitializeResource(&LocalServiceListLock);
   } except(EXCEPTION_EXECUTE_HANDLER ) {
       status = GetExceptionCode();
   }

   if (!NT_SUCCESS(status))
       return status;

   //
   // Now scan the registry and add all the services
   //
   LocalServiceListUpdate();

   return STATUS_SUCCESS;
} // LocalServiceListInit


/////////////////////////////////////////////////////////////////////////
int __cdecl LocalServiceListCompare(const void *arg1, const void *arg2) {
   PLOCAL_SERVICE_RECORD Svc1, Svc2;

   Svc1 = (PLOCAL_SERVICE_RECORD) *((PLOCAL_SERVICE_RECORD *) arg1);
   Svc2 = (PLOCAL_SERVICE_RECORD) *((PLOCAL_SERVICE_RECORD *) arg2);

   return lstrcmpi( Svc1->Name, Svc2->Name );

} // LocalServiceListCompare


/////////////////////////////////////////////////////////////////////////
PLOCAL_SERVICE_RECORD
LocalServiceListFind(
   LPTSTR Name
   )

/*++

Routine Description:

   Internal routine to actually do binary search on LocalServiceList, this
   does not do any locking as we expect the wrapper routine to do this.
   The search is a simple binary search.

Arguments:

   ServiceName -

Return Value:

   Pointer to found server table entry or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end = (LONG) LocalServiceListSize - 1;
   LONG cur;
   int match;
   PLOCAL_SERVICE_RECORD Service;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LocalServiceListFind\n"));
#endif

   if ((LocalServiceListSize == 0) || (Name == NULL))
      return NULL;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;
      Service = LocalServiceList[cur];

      // compare the two result into match
      match = lstrcmpi(Name, Service->Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return Service;
   }

   return NULL;

} // LocalServiceListFind


/////////////////////////////////////////////////////////////////////////
PLOCAL_SERVICE_RECORD
LocalServiceListAdd(
   LPTSTR Name,
   LPTSTR DisplayName,
   LPTSTR FamilyDisplayName,
   DWORD ConcurrentLimit,
   DWORD FlipAllow,
   DWORD Mode,
   DWORD HighMark
   )

/*++

Routine Description:


Arguments:

   ServiceName -

Return Value:

   Pointer to added service table entry, or NULL if failed.

--*/

{
   LPTSTR NewName;
   PLOCAL_SERVICE_RECORD Service;
   PLOCAL_SERVICE_RECORD *pLocalServiceListTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LocalServiceListAdd\n"));
#endif

   if ((Name == NULL) || (*Name == TEXT('\0'))) {
#if DBG
      dprintf(TEXT("Error LLS: LocalServiceListAdd Bad Parms\n"));
#endif
      ASSERT(FALSE);
      return NULL;
   }

   //
   // Try to find the name
   //
   Service = LocalServiceListFind(Name);
   if (Service != NULL) {
      Service->ConcurrentLimit = ConcurrentLimit;
      Service->FlipAllow = FlipAllow;
      Service->Mode = Mode;
      return Service;
   }

   //
   // No record - so create a new one
   //
   if (LocalServiceList == NULL) {
      pLocalServiceListTmp = (PLOCAL_SERVICE_RECORD *) LocalAlloc(LPTR, sizeof(PLOCAL_SERVICE_RECORD));
   } else {
      pLocalServiceListTmp = (PLOCAL_SERVICE_RECORD *) LocalReAlloc(LocalServiceList, sizeof(PLOCAL_SERVICE_RECORD) * (LocalServiceListSize + 1), LHND);
   }

   //
   // Make sure we could allocate server table
   //
   if (pLocalServiceListTmp == NULL) {
      return NULL;
   } else {
       LocalServiceList = pLocalServiceListTmp;
   }

   //
   // Allocate space for Record.
   //
   Service = (PLOCAL_SERVICE_RECORD) LocalAlloc(LPTR, sizeof(LOCAL_SERVICE_RECORD));
   if (Service == NULL) {
      ASSERT(FALSE);
      return NULL;
   }

   LocalServiceList[LocalServiceListSize] = Service;

   //
   // Name
   //
   NewName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(Name) + 1) * sizeof(TCHAR));
   if (NewName == NULL) {
      ASSERT(FALSE);
      LocalFree(Service);
      return NULL;
   }

   // now copy it over...
   Service->Name = NewName;
   lstrcpy(NewName, Name);

   //
   // DisplayName
   //
   NewName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(DisplayName) + 1) * sizeof(TCHAR));
   if (NewName == NULL) {
      ASSERT(FALSE);
      LocalFree(Service->Name);
      LocalFree(Service);
      return NULL;
   }

   // now copy it over...
   Service->DisplayName = NewName;
   lstrcpy(NewName, DisplayName);

   //
   // FamilyDisplayName
   //
   NewName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(FamilyDisplayName) + 1) * sizeof(TCHAR));
   if (NewName == NULL) {
      ASSERT(FALSE);
      LocalFree(Service->Name);
      LocalFree(Service->DisplayName);
      LocalFree(Service);
      return NULL;
   }

   // now copy it over...
   Service->FamilyDisplayName = NewName;
   lstrcpy(NewName, FamilyDisplayName);

   //
   // Initialize other stuff
   //
   Service->ConcurrentLimit = ConcurrentLimit;
   Service->FlipAllow = FlipAllow;
   Service->Mode = Mode;
   Service->HighMark = HighMark;

   LocalServiceListSize++;

   // Have added the entry - now need to sort it in order of the service names
   qsort((void *) LocalServiceList, (size_t) LocalServiceListSize, sizeof(PLOCAL_SERVICE_RECORD), LocalServiceListCompare);

   return Service;

} // LocalServiceListAdd


/////////////////////////////////////////////////////////////////////////
VOID
LocalServiceListUpdate( )

/*++

Routine Description:

   Looks in registry for given service and sets values accordingly.

Arguments:

Return Value:

   None.

--*/

{
   HKEY hKey2 = NULL;
   HKEY hKey3 = NULL;
   static TCHAR KeyName[MAX_PATH + 1];
   static TCHAR DisplayName[MAX_PATH + 1];
   static TCHAR FamilyDisplayName[MAX_PATH + 1];
   LONG EnumStatus;
   NTSTATUS Status;
   DWORD iSubKey = 0;
   DWORD dwType, dwSize;
   DWORD ConcurrentLimit, FlipAllow, Mode, HighMark;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LocalServiceListUpdate\n"));
#endif

   RtlAcquireResourceExclusive(&LocalServiceListLock, TRUE);

   EnumStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Services\\LicenseInfo"), 0, KEY_READ, &hKey2);

   while (EnumStatus == ERROR_SUCCESS) {
      EnumStatus = RegEnumKey(hKey2, iSubKey, KeyName, MAX_PATH + 1);
      iSubKey++;

      if (EnumStatus == ERROR_SUCCESS) {
         if ((Status = RegOpenKeyEx(hKey2, KeyName, 0, KEY_READ, &hKey3)) == ERROR_SUCCESS) {
            dwSize = sizeof(DisplayName);
            Status = RegQueryValueEx(hKey3, TEXT("DisplayName"), NULL, &dwType, (LPBYTE) DisplayName, &dwSize);

            dwSize = sizeof(FamilyDisplayName);
            if (Status == ERROR_SUCCESS) {
               Status = RegQueryValueEx(hKey3, TEXT("FamilyDisplayName"), NULL, &dwType, (LPBYTE) FamilyDisplayName, &dwSize);

               if (Status != ERROR_SUCCESS) {
                  lstrcpy(FamilyDisplayName, DisplayName);
                  Status = ERROR_SUCCESS;
               }
            }

            dwSize = sizeof(Mode);
            if (Status == ERROR_SUCCESS)
               Status = RegQueryValueEx(hKey3, TEXT("Mode"), NULL, &dwType, (LPBYTE) &Mode, &dwSize);

            dwSize = sizeof(FlipAllow);
            if (Status == ERROR_SUCCESS)
               Status = RegQueryValueEx(hKey3, TEXT("FlipAllow"), NULL, &dwType, (LPBYTE) &FlipAllow, &dwSize);

            dwSize = sizeof(ConcurrentLimit);
            if (Status == ERROR_SUCCESS)
               if (Mode == 0)
                  ConcurrentLimit = 0;
               else
                  Status = RegQueryValueEx(hKey3, TEXT("ConcurrentLimit"), NULL, &dwType, (LPBYTE) &ConcurrentLimit, &dwSize);

            dwSize = sizeof(HighMark);
            if (Status == ERROR_SUCCESS) {
               Status = RegQueryValueEx(hKey3, TEXT("LocalKey"), NULL, &dwType, (LPBYTE) &HighMark, &dwSize);
               if (Status != ERROR_SUCCESS) {
                  Status = ERROR_SUCCESS;
                  HighMark = 0;
               }
            }

            //
            // If we read in everything then add to our table
            //
            if (Status == ERROR_SUCCESS)
               LocalServiceListAdd(KeyName, DisplayName, FamilyDisplayName, ConcurrentLimit, FlipAllow, Mode, HighMark);

            RegCloseKey(hKey3);
         }
      }
   }

   RegCloseKey(hKey2);

   RtlReleaseResource(&LocalServiceListLock);
} // LocalServiceListUpdate


/////////////////////////////////////////////////////////////////////////
VOID
LocalServiceListHighMarkSet( )

/*++

Routine Description:

Arguments:

Return Value:

   None.

--*/

{
   HKEY hKey2 = NULL;
   static TCHAR RegKeyText[512];
   LONG Status;
   ULONG i, j;
   PSERVICE_RECORD Service;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LocalServiceListHighMarkSet\n"));
#endif

   RtlAcquireResourceExclusive(&LocalServiceListLock, TRUE);

   for (i = 0; i < LocalServiceListSize; i++) {
      RtlAcquireResourceShared(&ServiceListLock, TRUE);
      j = 0;
      Service = NULL;

      while ( (j < ServiceListSize) && (Service == NULL) ) {
         if (!lstrcmpi(LocalServiceList[i]->DisplayName, ServiceList[j]->DisplayName) )
            Service = ServiceList[j];

         j++;
      }

      RtlReleaseResource(&ServiceListLock);

      if (Service != NULL) {
         //
         // Create registry key-name we are looking for
         //
         lstrcpy(RegKeyText, TEXT("System\\CurrentControlSet\\Services\\LicenseInfo\\"));
         lstrcat(RegKeyText, LocalServiceList[i]->Name);

         Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegKeyText, 0, KEY_WRITE, &hKey2);

         if (Status == ERROR_SUCCESS)
         {
            Status = RegSetValueEx(hKey2, TEXT("LocalKey"), 0, REG_DWORD, (LPBYTE) &Service->HighMark, sizeof(Service->HighMark));
            RegCloseKey( hKey2 );
         }
      }
   }

   RtlReleaseResource(&LocalServiceListLock);
} // LocalServiceListHighMarkSet


///////////////////////////////////////////////////////////////////////////////
VOID
LocalServiceListConcurrentLimitSet( )

/*++

Routine Description:

   Write concurrent limit to the registry for all secure services.

   Modified from LocalServiceListHighMarkSet() implementation.

Arguments:

   None.

Return Value:

   None.

--*/

{
   HKEY hKey2 = NULL;
   TCHAR RegKeyText[512];
   LONG Status;
   ULONG i, j;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LocalServiceListConcurrentLimitSet\n"));
#endif

   RtlAcquireResourceExclusive(&LocalServiceListLock, TRUE);

   for (i = 0; i < LocalServiceListSize; i++)
   {
      //
      // Create registry key-name we are looking for
      //
      lstrcpy(RegKeyText, TEXT("System\\CurrentControlSet\\Services\\LicenseInfo\\"));
      lstrcat(RegKeyText, LocalServiceList[i]->Name);

      Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegKeyText, 0, KEY_READ, &hKey2);

      if (Status == ERROR_SUCCESS)
      {
         DWORD    dwConcurrentLimit;
         DWORD    cbConcurrentLimit = sizeof( dwConcurrentLimit );
         DWORD    dwType;

         // don't write unless we have to (to avoid triggering the registry monitor thread)
         Status = RegQueryValueEx(hKey2, TEXT("ConcurrentLimit"), NULL, &dwType, (LPBYTE) &dwConcurrentLimit, &cbConcurrentLimit );

         if ( ServiceIsSecure( LocalServiceList[i]->DisplayName ) )
         {
            LocalServiceList[i]->ConcurrentLimit = LocalServiceList[i]->Mode ? ProductLicensesGet( LocalServiceList[i]->DisplayName, TRUE ) : 0;

            // secure product
            if (    ( ERROR_SUCCESS != Status )
                 || ( REG_DWORD != dwType )
                 || ( dwConcurrentLimit != LocalServiceList[i]->ConcurrentLimit ) )
            {
               RegCloseKey( hKey2 );
               Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegKeyText, 0, KEY_WRITE, &hKey2);

               ASSERT( ERROR_SUCCESS == Status );
               if ( ERROR_SUCCESS == Status )
               {
                  Status = RegSetValueEx(hKey2, TEXT("ConcurrentLimit"), 0, REG_DWORD, (LPBYTE) &LocalServiceList[i]->ConcurrentLimit, sizeof( LocalServiceList[i]->ConcurrentLimit ) );
               }
            }
         }

         RegCloseKey( hKey2 );
      }
   }

   RtlReleaseResource(&LocalServiceListLock);
} // LocalServiceListConcurrentLimitSet


///////////////////////////////////////////////////////////////////////////////
BOOL ServiceIsSecure( LPTSTR ServiceName )

/*++

Routine Description:

   Determine whether a given service disallows 3.51 Honesty-style
   license purchases.

Arguments:

   ServiceName (LPTSTR)
      Service to check.

Return Value:

   TRUE if service requires secure certificate,
   FALSE if it accepts 3.51 Honesty-style license purchases.

--*/

{
   BOOL  IsSecure = FALSE;

   if ( NULL != SecureServiceList )
   {
      DWORD    i;

      RtlEnterCriticalSection( &ConfigInfoLock );

      for ( i=0; i < SecureServiceListSize; i++ )
      {
         if ( !lstrcmpi( SecureServiceList[i], ServiceName ) )
         {
            IsSecure = TRUE;
            break;
         }
      }

      RtlLeaveCriticalSection( &ConfigInfoLock );
   }

   return IsSecure;
}


///////////////////////////////////////////////////////////////////////////////
NTSTATUS ServiceSecuritySet( LPTSTR ServiceName )

/*++

Routine Description:

   Add a given service to the secure service list.

Arguments:

   ServiceName (LPTSTR)
      Service to add.

Return Value:

   STATUS_SUCCESS or Win error or NTSTATUS error code.

--*/

{
   NTSTATUS    nt;
   DWORD       i;
   BOOL        bChangedValue = FALSE;

   RtlEnterCriticalSection( &ConfigInfoLock );

   for ( i=0; i < SecureServiceListSize; i++ )
   {
      if ( !lstrcmpi( SecureServiceList[i], ServiceName ) )
      {
         // product already registered as secure
         break;
      }
   }

   if ( i < SecureServiceListSize )
   {
      // product already registered as secure
      nt = STATUS_SUCCESS;
   }
   else
   {
      TCHAR *     NewSecureServiceBuffer;
      ULONG       NewSecureServiceBufferSize;

      NewSecureServiceBufferSize = ( SecureServiceBufferSize ? SecureServiceBufferSize : sizeof( TCHAR ) ) + sizeof( TCHAR ) * ( 1 + lstrlen( ServiceName ) );
      NewSecureServiceBuffer     = LocalAlloc( LPTR, NewSecureServiceBufferSize );

      if ( NULL == NewSecureServiceBuffer )
      {
         nt = STATUS_NO_MEMORY;
         ASSERT( FALSE );
      }
      else
      {
         if ( NULL != SecureServiceBuffer )
         {
            // copy over current secure service strings
            memcpy( NewSecureServiceBuffer, SecureServiceBuffer, SecureServiceBufferSize - sizeof( TCHAR ) );

            // add new secure service (don't forget last string is followed by 2 nulls)
            memcpy( (LPBYTE) NewSecureServiceBuffer + SecureServiceBufferSize - sizeof( TCHAR ), ServiceName, NewSecureServiceBufferSize - SecureServiceBufferSize - sizeof( TCHAR ) );
         }
         else
         {
            // add new secure service (don't forget last string is followed by 2 nulls)
            memcpy( NewSecureServiceBuffer, ServiceName, NewSecureServiceBufferSize - sizeof( TCHAR ) );
         }

         ASSERT( 0 == *( (LPBYTE) NewSecureServiceBuffer + NewSecureServiceBufferSize - 2 * sizeof( TCHAR ) ) );
         ASSERT( 0 == *( (LPBYTE) NewSecureServiceBuffer + NewSecureServiceBufferSize -     sizeof( TCHAR ) ) );

         // encrypt buffer
         nt = EBlock( NewSecureServiceBuffer, NewSecureServiceBufferSize );
         ASSERT( STATUS_SUCCESS == nt );

         if ( STATUS_SUCCESS == nt )
         {
            HKEY     hKeyParameters;

            // save new list to registry
            nt = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Services\\LicenseService\\Parameters"), 0, KEY_WRITE, &hKeyParameters );
            ASSERT( STATUS_SUCCESS == nt );

            if ( STATUS_SUCCESS == nt )
            {
               nt = RegSetValueEx( hKeyParameters, TEXT( "ProductData" ), 0, REG_BINARY, (LPBYTE) NewSecureServiceBuffer, NewSecureServiceBufferSize );
               ASSERT( STATUS_SUCCESS == nt );

               if ( STATUS_SUCCESS == nt )
               {
                  bChangedValue = TRUE;
               }
            }

            RegCloseKey( hKeyParameters );
         }

         LocalFree( NewSecureServiceBuffer );
      }
   }

   RtlLeaveCriticalSection( &ConfigInfoLock );

   if ( ( STATUS_SUCCESS == nt ) && bChangedValue )
   {
      // key updated, now update internal copy
      ConfigInfoRegistryUpdate();
   }

   return nt;
}


///////////////////////////////////////////////////////////////////////////////
NTSTATUS ProductSecurityPack( LPDWORD pcchProductSecurityStrings, WCHAR ** ppchProductSecurityStrings )

/*++

Routine Description:

   Pack the secure service list into a contiguous buffer for transmission.

   NOTE: If the routine succeeds, the caller must later MIDL_user_free() the
   buffer at *ppchProductSecurityStrings.

Arguments:

   pcchProductSecurityStrings (LPDWORD)
      On return, holds the size (in characters) of the buffer pointed to
      by *ppchProductSecurityStrings.
   ppchProductSecurityStrings (WCHAR **)
      On return, holds the address of the buffer allocated to hold the names
      of the secure products.

Return Value:

   STATUS_SUCCESS or STATUS_NO_MEMORY.

--*/

{
   NTSTATUS    nt;

   RtlEnterCriticalSection( &ConfigInfoLock );

   *ppchProductSecurityStrings = MIDL_user_allocate( SecureServiceBufferSize );

   if ( NULL == *ppchProductSecurityStrings )
   {
      nt = STATUS_NO_MEMORY;
      ASSERT( FALSE );
   }
   else
   {
      memcpy( *ppchProductSecurityStrings, SecureServiceBuffer, SecureServiceBufferSize );
      *pcchProductSecurityStrings = SecureServiceBufferSize / sizeof( TCHAR );

      nt = STATUS_SUCCESS;
   }

   RtlLeaveCriticalSection( &ConfigInfoLock );

   return nt;
}


///////////////////////////////////////////////////////////////////////////////
NTSTATUS ProductSecurityUnpack( DWORD cchProductSecurityStrings, WCHAR * pchProductSecurityStrings )

/*++

Routine Description:

   Unpack a secure service list packed by ProductSecurityPack().  The products
   contained in the pack are added to the current secure product list.

Arguments:

   cchProductSecurityStrings (DWORD)
      The size (in characters) of the buffer pointed to by pchProductSecurityStrings.
   pchProductSecurityStrings (WCHAR *)
      The address of the buffer allocated to hold the names of the secure products.

Return Value:

   STATUS_SUCCESS.

--*/

{
   DWORD    i;

   for ( i=0;
            ( i < cchProductSecurityStrings )
         && ( TEXT('\0') != pchProductSecurityStrings[i] );
         i += 1 + lstrlen( &pchProductSecurityStrings[i] ) )
   {
      ServiceSecuritySet( &pchProductSecurityStrings[i] );
   }

   return STATUS_SUCCESS;
}

#if DBG
///////////////////////////////////////////////////////////////////////////////
void ProductSecurityListDebugDump()

/*++

Routine Description:

   Dump contents of product security list to debug console.

Arguments:

   None.

Return Value:

   None.

--*/

{
   if ( NULL == SecureServiceList )
   {
      dprintf( TEXT( "No secure products.\n" ) );
   }
   else
   {
      DWORD    i;

      RtlEnterCriticalSection( &ConfigInfoLock );

      for ( i=0; i < SecureServiceListSize; i++ )
      {
         dprintf( TEXT( "(%3ld) %s\n" ), (long)i, SecureServiceList[i] );
      }

      RtlLeaveCriticalSection( &ConfigInfoLock );
   }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\repl.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

   repl.c

Abstract:

Author:

   Arthur Hanson (arth) 06-Jan-1995

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Added replication of certificate database and secure service list.
      o  Log failure to connect during replication only if the target server
         is running a build in which license server should be available (i.e.,
         1057 (3.51) or greater).  If the target server does not support
         license server, log a message to that effect only once.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dsgetdc.h>

#include "debug.h"
#include "llsutil.h"
#include <llsapi.h>
#include "llssrv.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "perseat.h"
#include "server.h"
#include "repl.h"
#include "llsrpc_s.h"
#include "pack.h"
#include "llsevent.h"
#include "certdb.h"
#include "registry.h"

HANDLE ReplicationEvent;

volatile HANDLE LlsRPCHandle = NULL;    // Make sure it's reread after we enter critsec
PLLS_REPL_CONNECT_W pLlsReplConnect = NULL;
PLLS_REPL_CLOSE pLlsReplClose = NULL;
PLLS_FREE_MEMORY pLlsFreeMemory = NULL;

PLLS_REPLICATION_REQUEST_W pLlsReplicationRequestW = NULL;
PLLS_REPLICATION_SERVER_ADD_W pLlsReplicationServerAddW = NULL;
PLLS_REPLICATION_SERVER_SERVICE_ADD_W pLlsReplicationServerServiceAddW = NULL;
PLLS_REPLICATION_SERVICE_ADD_W pLlsReplicationServiceAddW = NULL;
PLLS_REPLICATION_USER_ADD_W pLlsReplicationUserAddW = NULL;

PLLS_CAPABILITY_IS_SUPPORTED              pLlsCapabilityIsSupported           = NULL;
PLLS_REPLICATION_CERT_DB_ADD_W            pLlsReplicationCertDbAddW           = NULL;
PLLS_REPLICATION_PRODUCT_SECURITY_ADD_W   pLlsReplicationProductSecurityAddW  = NULL;
PLLS_REPLICATION_USER_ADD_EX_W            pLlsReplicationUserAddExW           = NULL;
PLLS_CONNECT_W                            pLlsConnectW                        = NULL;
PLLS_CLOSE                                pLlsClose                           = NULL;
PLLS_LICENSE_ADD_W                        pLlsLicenseAddW                     = NULL;

NTSTATUS
ReplicationInitDelayed ()
{

    if (LlsRPCHandle != NULL)
    {
        return NOERROR;
    }

    RtlEnterCriticalSection(&g_csLock);

    if (LlsRPCHandle == NULL)
    {
        //
        // Open up our RPC DLL and init our function references.
        //
        LlsRPCHandle = LoadLibrary(TEXT("LLSRPC.DLL"));
        ASSERT(LlsRPCHandle != NULL);

        if (LlsRPCHandle != NULL) {
            pLlsReplConnect = (PLLS_REPL_CONNECT_W)GetProcAddress(LlsRPCHandle, ("LlsReplConnectW"));
            pLlsReplClose = (PLLS_REPL_CLOSE)GetProcAddress(LlsRPCHandle, ("LlsReplClose"));
            pLlsFreeMemory = (PLLS_FREE_MEMORY)GetProcAddress(LlsRPCHandle, ("LlsFreeMemory"));
            pLlsReplicationRequestW = (PLLS_REPLICATION_REQUEST_W)GetProcAddress(LlsRPCHandle, ("LlsReplicationRequestW"));
            pLlsReplicationServerAddW = (PLLS_REPLICATION_SERVER_ADD_W)GetProcAddress(LlsRPCHandle, ("LlsReplicationServerAddW"));
            pLlsReplicationServerServiceAddW = (PLLS_REPLICATION_SERVER_SERVICE_ADD_W)GetProcAddress(LlsRPCHandle, ("LlsReplicationServerServiceAddW"));
            pLlsReplicationServiceAddW = (PLLS_REPLICATION_SERVICE_ADD_W)GetProcAddress(LlsRPCHandle, ("LlsReplicationServiceAddW"));
            pLlsReplicationUserAddW = (PLLS_REPLICATION_USER_ADD_W)GetProcAddress(LlsRPCHandle, ("LlsReplicationUserAddW"));
            pLlsReplicationCertDbAddW = (PLLS_REPLICATION_CERT_DB_ADD_W) GetProcAddress(LlsRPCHandle, ("LlsReplicationCertDbAddW"));
            pLlsReplicationProductSecurityAddW = (PLLS_REPLICATION_PRODUCT_SECURITY_ADD_W) GetProcAddress(LlsRPCHandle, ("LlsReplicationProductSecurityAddW"));
            pLlsReplicationUserAddExW = (PLLS_REPLICATION_USER_ADD_EX_W) GetProcAddress(LlsRPCHandle, ("LlsReplicationUserAddExW"));
            pLlsCapabilityIsSupported = (PLLS_CAPABILITY_IS_SUPPORTED) GetProcAddress(LlsRPCHandle, ("LlsCapabilityIsSupported"));
            pLlsConnectW = (PLLS_CONNECT_W) GetProcAddress(LlsRPCHandle, ("LlsConnectW"));
            pLlsClose = (PLLS_CLOSE) GetProcAddress(LlsRPCHandle, ("LlsClose"));
            pLlsLicenseAddW = (PLLS_LICENSE_ADD_W) GetProcAddress(LlsRPCHandle, ("LlsLicenseAddW"));
            
            ASSERT (pLlsReplConnect != NULL);
            ASSERT (pLlsReplClose != NULL);
            ASSERT (pLlsFreeMemory != NULL);
            ASSERT (pLlsReplicationRequestW != NULL);
            ASSERT (pLlsReplicationServerAddW != NULL);
            ASSERT (pLlsReplicationServerServiceAddW != NULL);
            ASSERT (pLlsReplicationServiceAddW != NULL);
            ASSERT (pLlsReplicationUserAddW != NULL);
            ASSERT (pLlsReplicationCertDbAddW != NULL);
            ASSERT (pLlsReplicationProductSecurityAddW != NULL);
            ASSERT (pLlsReplicationUserAddExW != NULL);
            ASSERT (pLlsCapabilityIsSupported != NULL);
            ASSERT (pLlsConnectW != NULL);
            ASSERT (pLlsClose != NULL);
            ASSERT (pLlsLicenseAddW != NULL);

        }
    }

    RtlLeaveCriticalSection(&g_csLock);

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////
NTSTATUS
ReplicationInit ( )

/*++

Routine Description:


Arguments:


Return Value:

--*/

{
   DWORD Ignore;
   HANDLE Thread;
   NTSTATUS Status;
   DWORD Time;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_REPLICATION))
      dprintf(TEXT("LLS TRACE: ReplicationInit\n"));
#endif

   //
   // Create the Replication Management event
   //
   Status = NtCreateEvent(
                          &ReplicationEvent,
                          EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE,
                          NULL,
                          SynchronizationEvent,
                          FALSE
                          );

   ASSERT(NT_SUCCESS(Status));

   //
   // Fire off the thread to watch for replication.
   //
   Thread = CreateThread(
                         NULL,
                         0L,
                         (LPTHREAD_START_ROUTINE) ReplicationManager,
                         0L,
                         0L,
                         &Ignore
                         );

   if (NULL != Thread)
       CloseHandle(Thread);

   return STATUS_SUCCESS;
} // ReplicationInit


/////////////////////////////////////////////////////////////////////////
NTSTATUS
ReplicationDo (
   LLS_HANDLE        LlsHandle,
   LLS_REPL_HANDLE   ReplHandle,
   DWORD             LastReplicated
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS Status;
   PREPL_SERVICE_RECORD Services = NULL;
   ULONG ServicesTotalRecords = 0;
   PREPL_SERVER_RECORD Servers = NULL;
   ULONG ServersTotalRecords = 0;
   PREPL_SERVER_SERVICE_RECORD ServerServices = NULL;
   ULONG ServerServicesTotalRecords = 0;

   REPL_CERTIFICATE_DB_0         CertificateDB;
   REPL_PRODUCT_SECURITY_0       ProductSecurity;

   DWORD                         UserLevel = 0;
   REPL_USER_RECORD_CONTAINER    UserDB;


#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_REPLICATION))
      dprintf(TEXT("LLS TRACE: ReplicationDo\n"));
#endif

   //
   // Pack all of our data into linear / self-relative buffers so we
   // can send them over.
   //
   ZeroMemory( &UserDB, sizeof( UserDB ) );
   ZeroMemory( &CertificateDB, sizeof( CertificateDB ) );
   ZeroMemory( &ProductSecurity, sizeof( ProductSecurity ) );

   if ( (*pLlsCapabilityIsSupported)( LlsHandle, LLS_CAPABILITY_REPLICATE_USERS_EX ) )
   {
      UserLevel = 1;
      Status = PackAll( LastReplicated, &ServicesTotalRecords, &Services, &ServersTotalRecords, &Servers, &ServerServicesTotalRecords, &ServerServices, 1, &UserDB.Level1.NumUsers, &UserDB.Level1.Users );
      if (Status != STATUS_SUCCESS)
         goto ReplicationDoExit;
   }
   else
   {
      UserLevel = 0;
      Status = PackAll( LastReplicated, &ServicesTotalRecords, &Services, &ServersTotalRecords, &Servers, &ServerServicesTotalRecords, &ServerServices, 0, &UserDB.Level0.NumUsers, &UserDB.Level0.Users );
      if (Status != STATUS_SUCCESS)
         goto ReplicationDoExit;
   }

   if ( (*pLlsCapabilityIsSupported)( LlsHandle, LLS_CAPABILITY_REPLICATE_CERT_DB ) )
   {
      Status = CertDbPack( &CertificateDB.StringSize, &CertificateDB.Strings, &CertificateDB.HeaderContainer.Level0.NumHeaders, &CertificateDB.HeaderContainer.Level0.Headers, &CertificateDB.ClaimContainer.Level0.NumClaims, &CertificateDB.ClaimContainer.Level0.Claims );
      if (Status != STATUS_SUCCESS)
         goto ReplicationDoExit;
   }

   if ( (*pLlsCapabilityIsSupported)( LlsHandle, LLS_CAPABILITY_REPLICATE_PRODUCT_SECURITY ) )
   {
      Status = ProductSecurityPack( &ProductSecurity.StringSize, &ProductSecurity.Strings );
      if (Status != STATUS_SUCCESS)
         goto ReplicationDoExit;
   }

   //
   // Transmit...
   //

   Status = (*pLlsReplicationServiceAddW) ( ReplHandle, ServicesTotalRecords, Services );
   if (Status != STATUS_SUCCESS)
      goto ReplicationDoExit;

   Status = (*pLlsReplicationServerAddW) ( ReplHandle, ServersTotalRecords, Servers );
   if (Status != STATUS_SUCCESS)
      goto ReplicationDoExit;

   Status = (*pLlsReplicationServerServiceAddW) ( ReplHandle, ServerServicesTotalRecords, ServerServices );
   if (Status != STATUS_SUCCESS)
      goto ReplicationDoExit;

   if ( (*pLlsCapabilityIsSupported)( LlsHandle, LLS_CAPABILITY_REPLICATE_USERS_EX ) )
   {
      Status = (*pLlsReplicationUserAddExW)( ReplHandle, UserLevel, &UserDB );
      if (Status != STATUS_SUCCESS)
         goto ReplicationDoExit;
   }
   else
   {
      Status = (*pLlsReplicationUserAddW) ( ReplHandle, UserDB.Level0.NumUsers, UserDB.Level0.Users );
      if (Status != STATUS_SUCCESS)
         goto ReplicationDoExit;
   }

   if ( (*pLlsCapabilityIsSupported)( LlsHandle, LLS_CAPABILITY_REPLICATE_CERT_DB ) )
   {
      Status = (*pLlsReplicationCertDbAddW)( ReplHandle, 0, &CertificateDB );
      if (Status != STATUS_SUCCESS)
         goto ReplicationDoExit;
   }

   if ( (*pLlsCapabilityIsSupported)( LlsHandle, LLS_CAPABILITY_REPLICATE_PRODUCT_SECURITY ) )
   {
      Status = (*pLlsReplicationProductSecurityAddW)( ReplHandle, 0, &ProductSecurity );
   }

ReplicationDoExit:
   if (Status != STATUS_SUCCESS) {
#if DBG
      dprintf(TEXT("LLS Replication ABORT: 0x%lX\n"), Status);
#endif
   }

   if (Services != NULL)
      MIDL_user_free(Services);

   if (Servers != NULL)
      MIDL_user_free(Servers);

   if ( 0 == UserLevel )
   {
      if (UserDB.Level0.Users != NULL)
         MIDL_user_free(UserDB.Level0.Users);
   }
   else
   {
      if (UserDB.Level1.Users != NULL)
         MIDL_user_free(UserDB.Level1.Users);
   }

   if (CertificateDB.Strings != NULL)
      MIDL_user_free(CertificateDB.Strings);

   if (CertificateDB.HeaderContainer.Level0.Headers != NULL)
      MIDL_user_free(CertificateDB.HeaderContainer.Level0.Headers);

   if (CertificateDB.ClaimContainer.Level0.Claims != NULL)
      MIDL_user_free(CertificateDB.ClaimContainer.Level0.Claims);

   if (ProductSecurity.Strings != NULL)
      MIDL_user_free(ProductSecurity.Strings);

#if DBG
   if (TraceFlags & TRACE_REPLICATION)
      dprintf(TEXT("   LLS Replication Finished\n"));
#endif

   return Status;

} // ReplicationDo


/////////////////////////////////////////////////////////////////////////
VOID
ReplicationManager (
    IN PVOID ThreadParameter
    )

/*++

Routine Description:


Arguments:

    ThreadParameter - Not used.


Return Value:

    This thread never exits.

--*/

{
   BOOL DoReplication = FALSE;
   NTSTATUS Status;
   LLS_REPL_HANDLE ReplHandle = NULL;
   LLS_HANDLE LlsHandle = NULL;
   PLLS_CONNECT_INFO_0 pConnectInfo;
   PREPL_REQUEST pReplInfo;
   TCHAR ReplicateTo[MAX_PATH + 1];
   DWORD LastReplicated;
   LPTSTR pReplicateTo = ReplicateTo;
   TCHAR LastFailedConnectionDownlevelReplicateTo[MAX_PATH + 1] = TEXT("");
   BOOL Replicate;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_REPLICATION))
      dprintf(TEXT("LLS TRACE: ReplicationManager\n"));
#endif

   //
   // Loop forever waiting to be given the opportunity to serve the
   // greater good.
   //
   for ( ; ; ) {
      //
      // Wait to be notified that there is work to be done
      //
      Status = NtWaitForSingleObject( ReplicationEvent, TRUE, NULL );

#if DELAY_INITIALIZATION
      EnsureInitialized();
#endif

      // Delayed LoadLibrary
      ReplicationInitDelayed();

      // Update the replication-related ConfigInfo information.
      //
      ConfigInfoUpdate(NULL);

      RtlEnterCriticalSection(&ConfigInfoLock);
      Replicate = ConfigInfo.Replicate;
      RtlLeaveCriticalSection(&ConfigInfoLock);

      if (Replicate) {
         //
         // So they said, go replicate my son...  Yeah, but first we must ask
         // the master for permission.
         //

         //
         // Construct our repl record
         //
         pReplInfo = MIDL_user_allocate(sizeof(REPL_REQUEST));
         ASSERT(pReplInfo != NULL);
         if (pReplInfo != NULL) {
            ReplicateTo[0] = 0;
            pReplInfo->EnterpriseServer[0] = 0;

            RtlEnterCriticalSection(&ConfigInfoLock);
            if (ConfigInfo.ReplicateTo != NULL)
            {
                lstrcpyn(ReplicateTo,
                         ConfigInfo.ReplicateTo,
                         min(MAX_PATH, lstrlen(ConfigInfo.ReplicateTo) + 1));
            }

            if (ConfigInfo.EnterpriseServer != NULL)
                lstrcpy(pReplInfo->EnterpriseServer, ConfigInfo.EnterpriseServer);
            pReplInfo->EnterpriseServerDate = ConfigInfo.EnterpriseServerDate;

            pReplInfo->LastReplicated = ConfigInfo.LastReplicatedSeconds;
            pReplInfo->CurrentTime = LastUsedTime;
            pReplInfo->NumberServices = 0;
            pReplInfo->NumberUsers = 0;

            pReplInfo->ReplSize = MAX_REPL_SIZE;

            pReplInfo->Backoff = 0;
            RtlLeaveCriticalSection(&ConfigInfoLock);

#if DBG
            if (TraceFlags & TRACE_REPLICATION)
               dprintf(TEXT("LLS Starting Replication to: %s @ %s\n"),
                       ReplicateTo, TimeToString(pReplInfo->CurrentTime));
#endif

            Status = (*pLlsReplConnect) ( ReplicateTo,
                                          &ReplHandle );


            if ( STATUS_SUCCESS != Status ) {
#if DBG
               dprintf(TEXT("LLS Error: LlsReplConnect failed: 0x%lX\n"),
                       Status);
#endif
               ReplHandle = NULL;
            }
            else {
               Status = (*pLlsConnectW)( ReplicateTo, &LlsHandle );

               if ( STATUS_SUCCESS != Status ) {
#if DBG
                  dprintf(TEXT("LLS Error: LlsConnectW failed: 0x%lX\n"),
                          Status);
#endif
                  LlsHandle = NULL;
               }
            }

            if (Status != STATUS_SUCCESS) {
               DWORD          dwWinError;
               DWORD          dwBuildNumber;

               dwWinError = WinNtBuildNumberGet( ReplicateTo,
                                                 &dwBuildNumber );

               if ( (ERROR_SUCCESS == dwWinError) &&
                    (dwBuildNumber < 1057L) ) {
                  // the ReplicateTo machine does not support the license
                  // service
                  if ( lstrcmpi(ReplicateTo,
                                LastFailedConnectionDownlevelReplicateTo ) ) {
                     lstrcpy( LastFailedConnectionDownlevelReplicateTo,
                              ReplicateTo );

                     LogEvent( LLS_EVENT_REPL_DOWNLEVEL_TARGET,
                               1,
                               &pReplicateTo,
                               Status );
                  }
               }
               else {
                  // the ReplicateTo machine should be running the license
                  // service
                  *LastFailedConnectionDownlevelReplicateTo = TEXT( '\0' );

                  ThrottleLogEvent( LLS_EVENT_REPL_NO_CONNECTION,
                            1,
                            &pReplicateTo,
                            Status );
               }
            }
            else {
               *LastFailedConnectionDownlevelReplicateTo = TEXT( '\0' );

               Status = (*pLlsReplicationRequestW) ( ReplHandle,
                                                     REPL_VERSION,
                                                     pReplInfo );

               if (Status != STATUS_SUCCESS) {
                  LogEvent( LLS_EVENT_REPL_REQUEST_FAILED,
                            1,
                            &pReplicateTo,
                            Status );
               }
               else {
                  RtlEnterCriticalSection(&ConfigInfoLock);
#ifdef DISABLED_FOR_NT5
                  lstrcpy(ConfigInfo.EnterpriseServer,
                          pReplInfo->EnterpriseServer);
#endif // DISABLED_FOR_NT5

                  ConfigInfo.EnterpriseServerDate =
                                    pReplInfo->EnterpriseServerDate;
                  ConfigInfo.IsReplicating = TRUE;
                  LastReplicated = pReplInfo->LastReplicated;

                  //
                  //  And lo, thou may proceed...
                  //
                  if (pReplInfo->Backoff == 0) {
                     if ( ConfigInfo.LogLevel ) {
                        LogEvent( LLS_EVENT_REPL_START,
                                  1,
                                  &pReplicateTo,
                                  ERROR_SUCCESS );
                     }

                     Status = ReplicationDo( LlsHandle,
                                             ReplHandle,
                                             LastReplicated );

                     if ( STATUS_SUCCESS != Status ) {
                        LogEvent( LLS_EVENT_REPL_FAILED,
                                  1,
                                  &pReplicateTo,
                                  Status );
                     }
                     else if ( ConfigInfo.LogLevel ) {
                        LogEvent( LLS_EVENT_REPL_END,
                                  1,
                                  &pReplicateTo,
                                  ERROR_SUCCESS );
                     }

                     //
                     // Need to update when next we should replicate
                     //
                     ConfigInfo.LastReplicatedSeconds = DateSystemGet();
                     GetLocalTime(&ConfigInfo.LastReplicated);
                     ReplicationTimeSet();
                  }
                  else {
                     LogEvent( LLS_EVENT_REPL_BACKOFF,
                               1,
                               &pReplicateTo,
                               ERROR_SUCCESS );
                  }

                  ConfigInfo.IsReplicating = FALSE;
                  RtlLeaveCriticalSection(&ConfigInfoLock);
               }
            }

            //
            // Disconnect from Master Server
            //
            if ( NULL != LlsHandle ) {
               (*pLlsClose)( LlsHandle );
               LlsHandle = NULL;
            }

            if ( NULL != ReplHandle ) {
               Status = (*pLlsReplClose) ( &ReplHandle );
               if ((STATUS_SUCCESS != Status) && (NULL != ReplHandle))
               {
                  RpcSmDestroyClientContext( &ReplHandle );

                  ReplHandle = NULL;
               }
            }

            MIDL_user_free( pReplInfo );
         }
      }
   }

} // ReplicationManager


/////////////////////////////////////////////////////////////////////////
VOID
ReplicationTimeSet ( )

/*++

Routine Description:


Arguments:


Return Value:

--*/

{
   DWORD CurrTime, ReplTime, Time;

#if DBG
   if (TraceFlags & (TRACE_FUNCTION_TRACE | TRACE_REPLICATION))
      dprintf(TEXT("LLS TRACE: ReplicationTimeSet\n"));
#endif

   ReplTime = Time = 0;

   //
   // Figure out what new time to set it to
   //
   if (!ConfigInfo.Replicate)
      return;

   //
   // If REPLICATE_DELTA it is easy as we just take the delta and apply it to
   // the last replication time.  Otherwise we have to convert the time from
   // midnight.
   //

   //
   // Figure out how long since we last replicated
   //
   ReplTime = ConfigInfo.ReplicationTime;

   if (ConfigInfo.ReplicationType == REPLICATE_DELTA) {
      Time = DateSystemGet() - ConfigInfo.LastReplicatedSeconds;

      //
      // If we have already gone past when we should replicate then schedule
      // one real soon now (10 minutes).
      //
      if (Time > ReplTime)
         Time = 10 * 60;
      else
         Time = ReplTime - Time;

      Time += DateLocalGet();
   } else {
      //
      // Need to adjust time to midnight - do this by MOD of seconds
      // per day.
      //
      CurrTime = DateLocalGet();
      Time = CurrTime - ((CurrTime / (60 * 60 * 24)) * (60 * 60 * 24));
      CurrTime = CurrTime - Time;

      //
      // Time = seconds past midnight.
      // CurrTime = Todays @ 12:00 AM
      // Figure out if we are past the replication time, if so schedule it
      // for tomorrow, else today.
      //
      if (Time > ReplTime)
         Time = CurrTime + (60 * 60 * 24) + ReplTime;
      else
         Time = CurrTime + ReplTime;

   }

   ConfigInfo.NextReplication = Time;

} // ReplicationTimeSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\server.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Server.h

Abstract:


Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

--*/


#ifndef _LLS_SERVERTBL_H
#define _LLS_SERVERTBL_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct _SERVER_SERVICE_RECORD {
   ULONG Service;
   DWORD Flags;

   ULONG MaxSessionCount;    // Max # simultaneous sessions
   ULONG MaxSetSessionCount; // Max # simultaneous sessions ever set
   ULONG HighMark;           // Max # simultaneous sessions ever attempted
} SERVER_SERVICE_RECORD, *PSERVER_SERVICE_RECORD;


typedef struct _SERVER_RECORD {
   ULONG Index;
   LPTSTR Name;

   DWORD LastReplicated;
   BOOL IsReplicating;

   ULONG MasterServer;
   ULONG SlaveServer;
   ULONG NextServer;
   ULONG ServiceTableSize;
   PSERVER_SERVICE_RECORD *Services;
} SERVER_RECORD, *PSERVER_RECORD;


extern ULONG ServerListSize;
extern PSERVER_RECORD *ServerList;
extern PSERVER_RECORD *ServerTable;

extern RTL_RESOURCE ServerListLock;


NTSTATUS ServerListInit();
PSERVER_RECORD ServerListFind( LPTSTR Name );
PSERVER_RECORD ServerListAdd( LPTSTR Name, LPTSTR Master );

PSERVER_SERVICE_RECORD ServerServiceListFind( LPTSTR Name, ULONG ServiceTableSize, PSERVER_SERVICE_RECORD *ServiceList );
PSERVER_SERVICE_RECORD ServerServiceListAdd( LPTSTR Name, ULONG ServiceIndex, PULONG pServiceTableSize, PSERVER_SERVICE_RECORD **pServiceList );
VOID LocalServerServiceListUpdate();
VOID LocalServerServiceListHighMarkUpdate();


#if DBG

VOID ServerListDebugDump( );
VOID ServerListDebugInfoDump( PVOID Data );
#endif


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1989 - 1998

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=lls
MINORCOMP=server

TARGETNAME=llssrv
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..\..\inc;..\..\idl\$(O);..\..\client\$(O);$(BASE_INC_PATH);

SOURCES= \
         certdb.c   \
         llsutil.c  \
         service.c  \
         msvctbl.c  \
         registry.c \
         mapping.c  \
         purchase.c \
         perseat.c  \
         server.c   \
         repl.c     \
         rpc.c      \
         pack.c     \
         scaven.c   \
         llsrpc_s_stub.c \
         lsapi_s_stub.c  \
         llsdbg_s_stub.c \
         gentable.c \
         llssrv.c   \
         svctbl.c   \
         llssrv.rc

UMTYPE=windows
UMAPPL=llssrv
UMRES=$(@R).res

NTTARGETFILE1=$(O)\llssrv.res

UMLIBS= \
       $(SDK_LIB_PATH)\activeds.lib   \
       $(SDK_LIB_PATH)\adsiid.lib     \
       ..\..\common\$(O)\llscomm.lib \
       $(O)\llssrv.lib                           \
       $(SDK_LIB_PATH)\rpcutil.lib    \
       $(SDK_LIB_PATH)\rpcrt4.lib     \
       $(SDK_LIB_PATH)\samlib.lib     \
       $(SDK_LIB_PATH)\samsrv.lib     \
       $(SDK_LIB_PATH)\ntdll.lib      \
       $(SDK_LIB_PATH)\ntdsapi.lib    \
       $(SDK_LIB_PATH)\ole32.lib      \
       $(SDK_LIB_PATH)\oleaut32.lib   \
       $(SDK_LIB_PATH)\netapi32.lib   \
       $(SDK_LIB_PATH)\wsock32.lib

TARGETLIBS= \
       ..\..\common\$(O)\llscomm.lib \
       $(SDK_LIB_PATH)\rpcutil.lib    \
       $(SDK_LIB_PATH)\rpcrt4.lib     \
       $(SDK_LIB_PATH)\rpcndr.lib     \
       $(SDK_LIB_PATH)\kernel32.lib   \
       $(SDK_LIB_PATH)\advapi32.lib   \
       $(SDK_LIB_PATH)\samsrv.lib     \
       $(SDK_LIB_PATH)\netapi32.lib   \

C_DEFINES=$(C_DEFINES) -DRPC_NO_WINDOWS_H -DUNICODE -D_UNICODE

USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\service.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Service.h

Abstract:


Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

--*/

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif


// name of the executable
#define SZAPPNAME            "LLSrv"

// internal name of the service
#define SZSERVICENAME        "LicenseLoggingService"

// displayed name of the service
#define SZSERVICEDISPLAYNAME "License Logging Service"

// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       ""

// Wait Hint for Service Control Manager
#define NSERVICEWAITHINT    30000
//////////////////////////////////////////////////////////////////////////////



VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID ServiceStop();



BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\nfr10usr\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\svctbl.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

   svctbl.c

Abstract:

   Service Table routines.  Handles all access to service table
   for keeping track of running services and session counts to those
   services.


Author:

   Arthur Hanson (arth) 07-Dec-1994

Revision History:

   Jeff Parham (jeffparh) 05-Dec-1995
      o  Integrated per seat and per server purchase models for secure
         certificates.
      o  Added logging of per server license rejections.

--*/

#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <dsgetdc.h>

#include "llsapi.h"
#include "debug.h"
#include "llssrv.h"
#include "registry.h"
#include "ntlsapi.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "perseat.h"
#include "llsevent.h"
#include "llsutil.h"
#include "purchase.h"


//
// Must have ending space for version number placeholder!
//
#define FILE_PRINT       "FilePrint "
#define FILE_PRINT_BASE  "FilePrint"
#define FILE_PRINT_VERSION_NDX ( 9 )

#define REMOTE_ACCESS "REMOTE_ACCESS "
#define REMOTE_ACCESS_BASE "REMOTE_ACCESS"

#define THIRTY_MINUTES  (30 * 60)       // 30 minutes in seconds
#define TWELVE_HOURS    (12 * 60 * 60)  // 12 hours in seconds

extern ULONG NumFilePrintEntries;
extern LPTSTR *FilePrintTable;


ULONG ServiceListSize = 0;
PSERVICE_RECORD *ServiceList = NULL;
static PSERVICE_RECORD *ServiceFreeList = NULL;
static DWORD gdwLastWarningTime = 0;


RTL_RESOURCE ServiceListLock;

DWORD AssessPerServerLicenseCapacity(
                        ULONG cLicensesPurchased,
                        ULONG cLicensesConsumed);
int __cdecl MServiceRecordCompare(
                        const void *arg1,
                        const void *arg2);
DWORD GetUserNameFromSID(
                        PSID  UserSID,
                        DWORD ccFullUserName,
                        TCHAR szFullUserName[]);


/////////////////////////////////////////////////////////////////////////
NTSTATUS
ServiceListInit()

/*++

Routine Description:

   Creates the service table, used for tracking the services and session
   count.  This will pull the initial services from the registry.

   The table is linear so a binary search can be used on the table, so
   some extra records are initialized so that each time we add a new
   service we don't have to do a realloc.  We also assume that adding
   new services is a relatively rare occurance, since we need to sort
   it each time.

   The service table is guarded by a read and write semaphore.  Multiple
   reads can occur, but a write blocks everything.

   The service table has two default entries for FilePrint and REMOTE_ACCESS.

Arguments:

   None.

Return Value:

   None.

--*/

{
   BOOL PerSeatLicensing;
   ULONG SessionLimit;
   PSERVICE_RECORD Service;
   NTSTATUS status = STATUS_SUCCESS;

   try
   {
       RtlInitializeResource(&ServiceListLock);
   } except(EXCEPTION_EXECUTE_HANDLER ) {
       status = GetExceptionCode();
   }

   if (!NT_SUCCESS(status))
       return status;

   //
   // Just need to init FilePrint values...
   //
   Service = ServiceListAdd(TEXT(FILE_PRINT), FILE_PRINT_VERSION_NDX );
   RegistryInitValues(TEXT(FILE_PRINT_BASE), &PerSeatLicensing, &SessionLimit);

   //
   // Need to init RAS separatly as it uses File/Print Licenses.
   //
   Service = ServiceListAdd(TEXT(REMOTE_ACCESS), lstrlen(TEXT(REMOTE_ACCESS)) - 1);
   if (Service != NULL) {
      Service->MaxSessionCount = SessionLimit;
      Service->PerSeatLicensing = PerSeatLicensing;
   }

   return STATUS_SUCCESS;

} // ServiceListInit


/////////////////////////////////////////////////////////////////////////
int __cdecl ServiceListCompare(const void *arg1, const void *arg2) {
   PSERVICE_RECORD Svc1, Svc2;

   Svc1 = (PSERVICE_RECORD) *((PSERVICE_RECORD *) arg1);
   Svc2 = (PSERVICE_RECORD) *((PSERVICE_RECORD *) arg2);

   return lstrcmpi( Svc1->Name, Svc2->Name);

} // ServiceListCompare


PSERVICE_RECORD
ServiceListFind(
   LPTSTR ServiceName
   )

/*++

Routine Description:

   Internal routine to actually do binary search on ServiceList, this
   does not do any locking as we expect the wrapper routine to do this.
   The search is a simple binary search.

Arguments:

   ServiceName -

Return Value:

   Pointer to found service table entry or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end = (LONG) ServiceListSize - 1;
   LONG cur;
   int match;
   PSERVICE_RECORD Service;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServiceListFind\n"));
#endif
   if ((ServiceName == NULL) || (ServiceListSize == 0))
      return NULL;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;
      Service = ServiceList[cur];

      // compare the two result into match
      match = lstrcmpi(ServiceName, Service->Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return Service;
   }

   return NULL;

} // ServiceListFind


/////////////////////////////////////////////////////////////////////////
DWORD
VersionToDWORD(LPTSTR Version)

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPSTR pVer;
   DWORD Ver = 0;
   char tmpStr[12];     // two extra chars for null-termination just in case

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: VersionToDWORD\n"));
#endif

   if ((Version == NULL) || (*Version == TEXT('\0')))
      return Ver;

   //
   // Do major version number
   //
   memset(tmpStr,0,12);
   if (0 ==WideCharToMultiByte(CP_ACP, 0, Version, -1, tmpStr, 10, NULL, NULL))
   {
       // Error
       return 0;
   }

   Ver = (ULONG) atoi(tmpStr);
   Ver *= 0x10000;

   //
   // Now minor - look for period
   //
   pVer = tmpStr;
   while ((*pVer != '\0') && (*pVer != '.'))
      pVer++;

   if (*pVer == '.') {
      pVer++;
      Ver += atoi(pVer);
   }

   return Ver;

} // VersionToDWORD


/////////////////////////////////////////////////////////////////////////
PSERVICE_RECORD
ServiceListAdd(
   LPTSTR ServiceName,
   ULONG VersionIndex
   )

/*++

Routine Description:

   Adds a service to the service table.  This will also cause a poll of
   the registry to get the initial values for session limits and the
   type of licensing being used.

Arguments:

   ServiceName -

Return Value:

   Pointer to added service table entry, or NULL if failed.

--*/

{
   ULONG i;
   ULONG SessionLimit = 0;
   BOOL PerSeatLicensing = FALSE;
   PSERVICE_RECORD NewService;
   LPTSTR NewServiceName, pDisplayName, pFamilyDisplayName;
   PSERVICE_RECORD CurrentRecord = NULL;
   PMASTER_SERVICE_RECORD mService;
   NTSTATUS status;
   PSERVICE_RECORD *pServiceListTmp, *pServiceFreeListTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServiceListAdd\n"));
#endif
   //
   // We do a double check here to see if another thread just got done
   // adding the service, between when we checked last and actually got
   // the write lock.
   //
   CurrentRecord = ServiceListFind(ServiceName);
   if (CurrentRecord != NULL) {
      return CurrentRecord;
   }

   //
   // Allocate space for table (zero init it).
   //
   if (ServiceList == NULL) {
      pServiceListTmp = (PSERVICE_RECORD *) LocalAlloc(LPTR, sizeof(PSERVICE_RECORD) );
      pServiceFreeListTmp = (PSERVICE_RECORD *) LocalAlloc(LPTR, sizeof(PSERVICE_RECORD) );
   } else {
      pServiceListTmp = (PSERVICE_RECORD *) LocalReAlloc(ServiceList, sizeof(PSERVICE_RECORD) * (ServiceListSize + 1), LHND);
      pServiceFreeListTmp = (PSERVICE_RECORD *) LocalReAlloc(ServiceFreeList, sizeof(PSERVICE_RECORD) * (ServiceListSize + 1), LHND);
   }

   //
   // Make sure we could allocate service table
   //
   if ((pServiceListTmp == NULL) || (pServiceFreeListTmp == NULL)) {
      if (pServiceListTmp != NULL)
          LocalFree(pServiceListTmp);

      if (pServiceFreeListTmp != NULL)
          LocalFree(pServiceFreeListTmp);

      return NULL;
   } else {
      ServiceList = pServiceListTmp;
      ServiceFreeList = pServiceFreeListTmp;
   }

   //
   // Allocate space for saving off Service Name - we will take a space, then
   // the version string onto the end of the Product Name.  Therefore the
   // product name will be something like "Microsoft SQL 4.2a".  We maintain
   // a pointer to the version, so that we can convert the space to a NULL
   // and then get the product and version string separatly.  Keeping them
   // together simplifies the qsort and binary search routines.
   //
   NewService = (PSERVICE_RECORD) LocalAlloc(LPTR, sizeof(SERVICE_RECORD));
   if (NewService == NULL) {
      ASSERT(FALSE);
      return NULL;
   }

   ServiceList[ServiceListSize] = NewService;
   ServiceFreeList[ServiceListSize] = NewService;

   NewServiceName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(ServiceName) + 1) * sizeof(TCHAR));
   if (NewServiceName == NULL) {
      ASSERT(FALSE);
      LocalFree(NewService);
      return NULL;
   }

   // now copy it over...
   NewService->Name = NewServiceName;
   lstrcpy(NewService->Name, ServiceName);

   //
   // Allocate space for Root Name
   //
   NewService->Name[VersionIndex] = TEXT('\0');
   NewServiceName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(NewService->Name) + 1) * sizeof(TCHAR));

   if (NewServiceName == NULL) {
      ASSERT(FALSE);
      LocalFree(NewService->Name);
      LocalFree(NewService);
      return NULL;
   }

   lstrcpy(NewServiceName, NewService->Name);
   NewService->Name[VersionIndex] = TEXT(' ');

   // point service structure to it...
   NewService->FamilyName = NewServiceName;

   //
   // Allocate space for Display Name
   //
   RegistryDisplayNameGet(NewService->FamilyName, NewService->Name, &pDisplayName);

   if (pDisplayName == NULL) {
      ASSERT(FALSE);
      LocalFree(NewService->Name);
      LocalFree(NewService->FamilyName);
      LocalFree(NewService);
      return NULL;
   }

   // point service structure to it...
   NewService->DisplayName = pDisplayName;

   RegistryFamilyDisplayNameGet(NewService->FamilyName, NewService->DisplayName, &pFamilyDisplayName);

   if (pFamilyDisplayName == NULL) {
      ASSERT(FALSE);
      LocalFree(NewService->Name);
      LocalFree(NewService->FamilyName);
      LocalFree(NewService->DisplayName);
      LocalFree(NewService);
      return NULL;
   }

   // point service structure to it...
   NewService->FamilyDisplayName = pFamilyDisplayName;

   //
   // Update table size and init entry, including reading init values
   // from registry.
   //
   NewService->Version = VersionToDWORD(&ServiceName[VersionIndex + 1]);

   // Init values from registry...
   RegistryInitService(NewService->FamilyName, &PerSeatLicensing, &SessionLimit);

   if ( PerSeatLicensing )
   {
      // per seat mode
      NewService->MaxSessionCount = 0;
   }
   else if ( ServiceIsSecure( NewService->DisplayName ) )
   {
      // per server mode with a secure product; requires certificate
      NewService->MaxSessionCount = ProductLicensesGet( NewService->DisplayName, TRUE );
   }
   else
   {
      // per server mode with an unsecure product; use limit from registry
      NewService->MaxSessionCount = SessionLimit;
   }

   NewService->PerSeatLicensing = PerSeatLicensing;
   NewService->SessionCount = 0;
   NewService->Index = ServiceListSize;
   status = RtlInitializeCriticalSection(&NewService->ServiceLock);
   if (!NT_SUCCESS(status))
   {
      LocalFree(NewService->Name);
      LocalFree(NewService->FamilyName);
      LocalFree(NewService->DisplayName);
      LocalFree(NewService);
      return NULL;
   }

   if (lstrcmpi(ServiceName, TEXT(REMOTE_ACCESS))) {
      RtlAcquireResourceExclusive(&MasterServiceListLock, TRUE);
      mService = MasterServiceListAdd( NewService->FamilyDisplayName, NewService->DisplayName, NewService->Version);

      if (mService == NULL) {
         ASSERT(FALSE);
      } else {
         NewService->MasterService = mService;

         //
         // In case this got added from the local service list table and we
         // didn't have a version # yet.
         //
         if (mService->Version == 0) {
            PMASTER_SERVICE_ROOT ServiceRoot = NULL;

            //
            // Fixup next pointer chain
            //
            ServiceRoot = mService->Family;
            i = 0;
            while ((i < ServiceRoot->ServiceTableSize) && (MasterServiceTable[ServiceRoot->Services[i]]->Version < NewService->Version))
               i++;

            mService->next = 0;
            mService->Version = NewService->Version;
            if (i > 0) {
               if (MasterServiceTable[ServiceRoot->Services[i - 1]]->next == mService->Index + 1)
                  mService->next = 0;
               else
                  mService->next = MasterServiceTable[ServiceRoot->Services[i - 1]]->next;

               if (MasterServiceTable[ServiceRoot->Services[i - 1]] != mService)
                  MasterServiceTable[ServiceRoot->Services[i - 1]]->next = mService->Index + 1;
            }

            // Resort it in order of the versions
            qsort((void *) ServiceRoot->Services, (size_t) ServiceRoot->ServiceTableSize, sizeof(ULONG), MServiceRecordCompare);
         }
      }
      RtlReleaseResource(&MasterServiceListLock);
   }

   ServiceListSize++;

   // Have added the entry - now need to sort it in order of the service names
   qsort((void *) ServiceList, (size_t) ServiceListSize, sizeof(PSERVICE_RECORD), ServiceListCompare);

   return NewService;
} // ServiceListAdd


/////////////////////////////////////////////////////////////////////////
VOID
ServiceListResynch( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSERVICE_RECORD Service;
   BOOL PerSeatLicensing;
   ULONG SessionLimit;
   ULONG i = 0;
   PSERVICE_RECORD FilePrintService;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServiceListReSynch\n"));
#endif
   if (ServiceList == NULL)
      return;

   //
   // Need to update list so get exclusive access.
   //
   RtlAcquireResourceExclusive(&ServiceListLock, TRUE);

   for (i = 0; i < ServiceListSize; i++) {
      //
      // Note:  We will init REMOTE_ACCESS with bogus values here, but we
      // reset it to the correct values below.  Since we have exclusive access
      // to the table, this is fine (and faster than always checking for
      // REMOTE_ACCESS).
      //
      RegistryInitService((ServiceList[i])->FamilyName, &PerSeatLicensing, &SessionLimit);

      if ( PerSeatLicensing )
      {
         // per seat mode
         (ServiceList[i])->MaxSessionCount = 0;
      }
      else if ( ServiceIsSecure( (ServiceList[i])->DisplayName ) )
      {
         // per server mode with a secure product; requires certificate
         (ServiceList[i])->MaxSessionCount = ProductLicensesGet( (ServiceList[i])->DisplayName, TRUE );
      }
      else
      {
         // per server mode with an unsecure product; use limit from registry
         (ServiceList[i])->MaxSessionCount = SessionLimit;
      }

      (ServiceList[i])->PerSeatLicensing = PerSeatLicensing;
   }

   //
   // Need to init RAS separatly as it uses File/Print Licenses.
   //
   Service = ServiceListFind(TEXT(REMOTE_ACCESS));
   FilePrintService = ServiceListFind(TEXT(FILE_PRINT));

   ASSERT( NULL != Service );
   ASSERT( NULL != FilePrintService );

   if ( ( NULL != Service ) && ( NULL != FilePrintService ) )
   {
      Service->MaxSessionCount  = FilePrintService->MaxSessionCount;
      Service->PerSeatLicensing = FilePrintService->PerSeatLicensing;
   }

   RtlReleaseResource(&ServiceListLock);

   return;
} // ServiceListResynch


/////////////////////////////////////////////////////////////////////////
NTSTATUS
DispatchRequestLicense(
   ULONG DataType,
   PVOID Data,
   LPTSTR ServiceID,
   ULONG VersionIndex,
   BOOL IsAdmin,
   ULONG *Handle
   )

/*++

Routine Description:


Arguments:

   ServiceID -

   IsAdmin -

   Handle -

Return Value:


--*/

{
#define FULL_USERNAME_LENGTH (MAX_DOMAINNAME_LENGTH + \
                                        MAX_USERNAME_LENGTH + 3)

   LPWSTR            apszSubString[ 2 ];
   NTSTATUS          Status = STATUS_SUCCESS;
   PSERVICE_RECORD   Service;
   ULONG             SessionCount;
   ULONG             TableEntry;
   LPTSTR            pServiceID;
   BOOL              NoLicense = FALSE;
   BOOL              PerSeat;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: DispatchRequestLicense\n"));
#endif

   *Handle     = 0xFFFFFFFF;
   pServiceID  = ServiceID;

   // we only need read access since we aren't adding at this point
   RtlAcquireResourceShared( &ServiceListLock, TRUE );

   // check if in FilePrint table, if so then we use FilePrint as the name
   ServiceID[ VersionIndex ] = TEXT('\0');
   if ( ServiceFindInTable( ServiceID, FilePrintTable, NumFilePrintEntries, &TableEntry ) )
   {
      pServiceID = TEXT(FILE_PRINT);
   }
   ServiceID[ VersionIndex ] = TEXT(' ');

   Service = ServiceListFind( pServiceID );

   if (Service == NULL)
   {
      // couldn't find service in list, so add it
      RtlConvertSharedToExclusive(&ServiceListLock);
      Service = ServiceListAdd( pServiceID, VersionIndex );
      RtlConvertExclusiveToShared(&ServiceListLock);
   }

   if (Service != NULL)
   {
      // service found or added successfully

      *Handle = (ULONG) Service->Index;

      RtlEnterCriticalSection(&Service->ServiceLock);
      SessionCount = Service->SessionCount + 1;

#if DBG
      if (TraceFlags & TRACE_LICENSE_REQUEST)
         dprintf(TEXT("LLS: [0x%lX] %s License: %ld of %ld\n"), Service, Service->Name, SessionCount, Service->MaxSessionCount);
#endif

      if (SessionCount > Service->HighMark)
      {
         Service->HighMark = SessionCount;
      }

      PerSeat = Service->PerSeatLicensing;

      if ( !PerSeat ) {
         if ( !IsAdmin ) {
            TCHAR szFullUserName[ FULL_USERNAME_LENGTH ] = TEXT("");
            DWORD dwCapacityState;
            DWORD dwError;
            DWORD dwInsertsCount;
            DWORD dwMessageID;

            dwCapacityState = AssessPerServerLicenseCapacity(
                                            Service->MaxSessionCount,
                                            SessionCount);

            if ( dwCapacityState == LICENSE_CAPACITY_NORMAL ) {
               //
               // Within normal capacity.
               //
               Service->SessionCount++;
            }
            else if ( dwCapacityState == LICENSE_CAPACITY_NEAR_MAXIMUM ) {
               //
               // Within the threshold of near 100% capacity.
               //
               dwInsertsCount = 1;
               apszSubString[ 0 ] = Service->DisplayName;
               dwMessageID = LLS_EVENT_LOG_PER_SERVER_NEAR_MAX;
               dwError = ERROR_SUCCESS;
               Service->SessionCount++;
            }
            else if ( dwCapacityState == LICENSE_CAPACITY_AT_MAXIMUM ) {
               //
               // Exceeding 100% capacity, but still within the grace range.
               //
               dwInsertsCount = 1;
               apszSubString[ 0 ] = Service->DisplayName;
               dwMessageID = LLS_EVENT_LOG_PER_SERVER_AT_MAX;
               dwError = ERROR_SUCCESS;
               Service->SessionCount++;
            }
            else {
               //
               // License maximum exceeded. Zero tolerance for exceeding
               // limits on concurrent licenses
               //
               if ( NT_LS_USER_NAME == DataType )
               {
                  apszSubString[ 0 ] = (LPWSTR) Data;
                  dwError = ERROR_SUCCESS;
               }
               else
               {
                  dwError = GetUserNameFromSID((PSID)Data,
                                               FULL_USERNAME_LENGTH,
                                               szFullUserName);
                  apszSubString[ 0 ] = szFullUserName;
               }

               dwInsertsCount = 2;
               apszSubString[ 1 ] = ServiceID;
               dwMessageID = LLS_EVENT_USER_NO_LICENSE;
               NoLicense = TRUE;
            }

            if ( dwCapacityState != LICENSE_CAPACITY_NORMAL ) {
               //
               // Log warning and put up warning dialog locally.
               // Limit the log/ui warning to a low frequency. Specifically:
               //     Once per every 12 hours for warnings.
               //     Every 30 minutes when the license maximum is exceeded
               //       causing licenses to no longer be provided.
               //
               LARGE_INTEGER liTime;
               DWORD         dwCurrentTime;

               NtQuerySystemTime(&liTime);
               RtlTimeToSecondsSince1970(&liTime, &dwCurrentTime);

               if ( dwCurrentTime - gdwLastWarningTime >
                    (DWORD)(NoLicense ? THIRTY_MINUTES : TWELVE_HOURS) ) {
                  LogEvent(dwMessageID, dwInsertsCount, apszSubString,
                           dwError);
                  LicenseCapacityWarningDlg(dwCapacityState);
                  gdwLastWarningTime = dwCurrentTime;
               }
            }
         }
         else {
            Service->SessionCount++;
         }
      }
      else {
         Service->SessionCount++;
      }

      RtlLeaveCriticalSection(&Service->ServiceLock);
      RtlReleaseResource(&ServiceListLock);

      if ( PerSeat )
      {
         // per node ("per seat") license

         // translate REMOTE_ACCESS into FILE_PRINT before adding to
         // per seat license records
         if ( !lstrcmpi( ServiceID, TEXT( REMOTE_ACCESS ) ) )
         {
            RtlAcquireResourceShared(&ServiceListLock, TRUE);
            Service = ServiceListFind(TEXT(FILE_PRINT));
            RtlReleaseResource(&ServiceListLock);

            ASSERT(Service != NULL);
         }

         if (Service == NULL)
         {
             // shouldn't ever happen
             *Handle = 0xFFFFFFFF;
             return LS_UNKNOWN_STATUS;
         }

         UserListUpdate( DataType, Data, Service );
      }
      else
      {
         // concurrent use ("per server") license
         if (NoLicense)
         {
            Status = LS_INSUFFICIENT_UNITS;
            *Handle = 0xFFFFFFFF;
         }
      }
   }
   else
   {
      // could neither find nor create service entry

      RtlReleaseResource(&ServiceListLock);
#if DBG
      dprintf( TEXT( "DispatchRequestLicense(): Could neither find nor create service entry.\n" ) );
#endif
   }

   return Status;
} // DispatchRequestLicense



/////////////////////////////////////////////////////////////////////////
VOID
DispatchFreeLicense(
   ULONG Handle
   )

/*++

Routine Description:


Arguments:

   Handle -

Return Value:

   None.

--*/

{
   PSERVICE_RECORD Service;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: DispatchFreeLicense\n"));
#endif
   //
   // We only need read access since we aren't adding at this point.
   //
   RtlAcquireResourceShared(&ServiceListLock, TRUE);

#if DBG
   if (TraceFlags & TRACE_LICENSE_FREE)
      dprintf(TEXT("Free Handle: 0x%lX\n"), Handle);
#endif
   if (Handle < ServiceListSize) {
      Service = ServiceFreeList[Handle];
      RtlEnterCriticalSection(&Service->ServiceLock);
      if (Service->SessionCount > 0)
         Service->SessionCount--;
      RtlLeaveCriticalSection(&Service->ServiceLock);
   } else {
#if DBG
      dprintf(TEXT("Passed invalid Free Handle: 0x%lX\n"), Handle);
#endif
   }

   RtlReleaseResource(&ServiceListLock);

} // DispatchFreeLicense


/////////////////////////////////////////////////////////////////////////
DWORD
GetUserNameFromSID(
    PSID  UserSID,
    DWORD ccFullUserName,
    TCHAR szFullUserName[]
    )

/*++

Routine Description:


Arguments:

   UserSID -
   ccFullUserName -
   szFullUserName -

Return Value:

   None.

--*/

{
    TCHAR        szUserName[ MAX_USERNAME_LENGTH + 1 ];
    TCHAR        szDomainName[ MAX_DOMAINNAME_LENGTH + 1 ];
    DWORD        Status = ERROR_SUCCESS;
    DWORD        cbUserName;
    DWORD        cbDomainName;
    SID_NAME_USE snu;

    cbUserName   = sizeof( szUserName );
    cbDomainName = sizeof( szDomainName );

    if ((UserSID == NULL) || (!IsValidSid(UserSID))) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( LookupAccountSid( NULL,
                           UserSID,
                           szUserName,
                           &cbUserName,
                           szDomainName,
                           &cbDomainName,
                           &snu ) )
    {
        if ( ccFullUserName >=
             ( cbUserName + cbDomainName + sizeof(TEXT("\\")) ) /
                        sizeof(TCHAR) ) {
            lstrcpy( szFullUserName, szDomainName );
            lstrcat( szFullUserName, TEXT( "\\" ) );
            lstrcat( szFullUserName, szUserName );
        }
        else {
            Status = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    else {
        Status = GetLastError();
    }

    return(Status);
}


/////////////////////////////////////////////////////////////////////////
DWORD
AssessPerServerLicenseCapacity(
    ULONG cLicensesPurchased,
    ULONG cLicensesConsumed
    )

/*++

Routine Description:

    Determine the license capacity state given the number of licenses
    purchased and used according to the following table:

 # of Purchased   Warning Message    Violation Message   License not provided
    Licenses        Sent at %           Sent at %               at %
 --------------   ---------------    -----------------   --------------------
       0-9       # of licenses - 1   # of licenses + 1    # of licenses + 2
     10-500      90% <= x <= 100%     100% < x <= 110%         x > 110%
       501+      95% <= x <= 100%     100% < x <= 105%         x > 105%



Arguments:

    cLicensesPurchased -- License purchase total
    cLicensesConsumed -- Number of licenses used

Return Value:

   Returned state.

--*/

{
    ULONG GracePercentage;
    ULONG Divisor;

    if ( cLicensesPurchased == 0 ) {
        Divisor = 0;
    }
    else if ( cLicensesPurchased < 10 ) {
        Divisor = 1;
    }
    else if ( cLicensesPurchased <= 500 ) {
        Divisor = 10;
    }
    else {
        Divisor = 20;
    }

    GracePercentage = Divisor > 1 ? cLicensesPurchased / Divisor : Divisor;

    if ( cLicensesConsumed <= cLicensesPurchased ) {
        if ( cLicensesConsumed >= cLicensesPurchased - GracePercentage ) {
            return LICENSE_CAPACITY_NEAR_MAXIMUM;
        }
        else {
            return LICENSE_CAPACITY_NORMAL;
        }
    }
    else {
        if ( cLicensesConsumed > cLicensesPurchased + GracePercentage ) {
            return LICENSE_CAPACITY_EXCEEDED;
        }
        else {
            return LICENSE_CAPACITY_AT_MAXIMUM;
        }
    }
} // AssessPerServerLicenseCapacity


#if DBG
/////////////////////////////////////////////////////////////////////////
VOID
ServiceListDebugDump( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&ServiceListLock, TRUE);

   dprintf(TEXT("Service Table, # Entries: %lu\n"), ServiceListSize);
   if (ServiceList == NULL)
      goto ServiceListDebugDumpExit;

   for (i = 0; i < ServiceListSize; i++) {
      if ((ServiceList[i])->PerSeatLicensing)
         dprintf(TEXT("%3lu) PerSeat: Y MS: %4lu CS: %4lu HM: %4lu [%3lu] Svc: %s\n"),
            i + 1, ServiceList[i]->MaxSessionCount, ServiceList[i]->SessionCount, ServiceList[i]->HighMark, ServiceList[i]->Index, ServiceList[i]->Name);
      else
         dprintf(TEXT("%3lu) PerSeat: N MS: %4lu CS: %4lu HM: %4lu [%3lu] Svc: %s\n"),
            i + 1, ServiceList[i]->MaxSessionCount, ServiceList[i]->SessionCount, ServiceList[i]->HighMark, ServiceList[i]->Index, ServiceList[i]->Name);
   }

ServiceListDebugDumpExit:
   RtlReleaseResource(&ServiceListLock);

   return;
} // ServiceListDebugDump


/////////////////////////////////////////////////////////////////////////
VOID
ServiceListDebugInfoDump( PVOID Data )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSERVICE_RECORD CurrentRecord = NULL;

   dprintf(TEXT("Service Table, # Entries: %lu\n"), ServiceListSize);

   if (lstrlen((LPWSTR) Data) > 0) {
      CurrentRecord = ServiceListFind((LPWSTR) Data);
      if (CurrentRecord != NULL) {
         if (CurrentRecord->PerSeatLicensing)
            dprintf(TEXT("   PerSeat: Y MS: %4lu CS: %4lu HM: %4lu [%3lu] Svc: %s\n"),
               CurrentRecord->MaxSessionCount, CurrentRecord->SessionCount, CurrentRecord->HighMark, CurrentRecord->Index, CurrentRecord->Name);
         else
            dprintf(TEXT("   PerSeat: N MS: %4lu CS: %4lu HM: %4lu [%3lu] Svc: %s\n"),
               CurrentRecord->MaxSessionCount, CurrentRecord->SessionCount, CurrentRecord->HighMark, CurrentRecord->Index, CurrentRecord->Name);
      }
   }

} // ServiceListDebugInfoDump

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\service.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Service.c

Abstract:

    License Logging Service - Common routines for all service.

Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include <shellapi.h>

#include "service.h"
#include "debug.h"

// internal variables
static SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle = 0;
static DWORD                   dwErr = 0;
BOOL                    bDebug = FALSE;
TCHAR                   szErr[256];

// internal function prototypes
VOID WINAPI ServiceCtrl(DWORD dwCtrlCode);
VOID WINAPI ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService();
VOID CmdRemoveService();
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );


/////////////////////////////////////////////////////////////////////////
VOID __cdecl
main(
   int argc,
   char **argv
   )
/*++

Routine Description:

   Main routine to setup the exception handlers and initialize everything
   before spawning threads to listen to LPC and RPC port requests.

   main() either performs the command line task, or calls
   StartServiceCtrlDispatcher to register the main service thread.  When the
   this call returns, the service has stopped, so exit.

Arguments:

    argc - number of command line arguments
    argv - array of command line arguments

Return Values:

    None.

--*/
{
    SERVICE_TABLE_ENTRY dispatchTable[] = {
        { TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION) ServiceMain },
        { NULL, NULL }
    };

    if ( (argc > 1) && ((*argv[1] == '-') || (*argv[1] == '/')) ) {
        if ( _stricmp( "install", argv[1]+1 ) == 0 ) {
            CmdInstallService();
        } else if ( _stricmp( "remove", argv[1]+1 ) == 0 ) {
            CmdRemoveService();
        } else if ( _stricmp( "debug", argv[1]+1 ) == 0 ) {
            bDebug = TRUE;
            CmdDebugService(argc, argv);
        } else {
            goto dispatch;
        }

        exit(0);
    }

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher
    dispatch:
#ifdef DEBUG
        // this is just to be friendly
        printf( "%s -install          to install the service\n", SZAPPNAME );
        printf( "%s -remove           to remove the service\n", SZAPPNAME );
        printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
        printf( "\nStartServiceCtrlDispatcher being called.\n" );
        printf( "This may take several seconds.  Please wait.\n" );
#endif

        if (!StartServiceCtrlDispatcher(dispatchTable))
            dprintf(TEXT("LLS TRACE: StartServiceCtrlDispatcher failed\n"));

} // main



/////////////////////////////////////////////////////////////////////////
VOID WINAPI
ServiceMain(
   DWORD dwArgc,
   LPTSTR *lpszArgv
   )
/*++

Routine Description:

   Performs the service initialization and then calls the ServiceStart()
   routine to perform majority of the work.

Arguments:

    dwArgc   - number of command line arguments ***UNUSED***
    lpszArgv - array of command line arguments ***UNUSED***

Return Values:

    None.

--*/
{

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), ServiceCtrl);

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        NSERVICEWAITHINT))                 // wait hint
        goto cleanup;


    ServiceStart( dwArgc, lpszArgv );

cleanup:

    // try to report the stopped status to the service control manager.
    //
    if (sshStatusHandle)
        (VOID)ReportStatusToSCMgr(
                            SERVICE_STOPPED,
                            dwErr,
                            0);

    return;
} // ServiceMain



/////////////////////////////////////////////////////////////////////////
VOID WINAPI
ServiceCtrl(
   DWORD dwCtrlCode
   )
/*++

Routine Description:

   Called by the SCM whenever ControlService() is called on this service.

Arguments:

   dwCtrlCode - type of control requested

Return Values:

    None.

--*/
{
    DWORD dwState = SERVICE_RUNNING;


    // Handle the requested control code.
    //
    switch(dwCtrlCode) {
        // Stop the service.
        //
        case SERVICE_CONTROL_STOP:
            dwState = SERVICE_STOP_PENDING;
            ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            break;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(dwState, NO_ERROR, 0);

    if ( SERVICE_CONTROL_STOP == dwCtrlCode )
    {
        ServiceStop();
    }
} // ServiceCtrl



/////////////////////////////////////////////////////////////////////////
BOOL
ReportStatusToSCMgr(
   DWORD dwCurrentState,
   DWORD dwWin32ExitCode,
   DWORD dwWaitHint
   )
/*++

Routine Description:

   Sets the current status of the service and reports it to the SCM.

Arguments:

   dwCurrentState - the state of the service
   dwWin32ExitCode - error code to report
   dwWaitHint - worst case estimate to next checkpoint

Return Values:

    None.

--*/
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;

    if (sshStatusHandle == 0)
    {
        return FALSE;
    }

    ssStatus.dwControlsAccepted = 0;
    if ( !bDebug ) { // when debugging we don't report to the SCM
        if (dwCurrentState == SERVICE_START_PENDING)
            ssStatus.dwControlsAccepted = 0;
        else
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) )
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;


        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
            dprintf(TEXT("LLS TRACE: SetServiceStatus failed\n"));
        }
    }
    return fResult;
} // ReportStatusToSCMgr



/////////////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
VOID
CmdInstallService()
/*++

Routine Description:

   Installs the service.

Arguments:

   None.

Return Values:

   None.

--*/
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 ) {
        _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager ) {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZSERVICENAME),        // name of service
            TEXT(SZSERVICEDISPLAYNAME), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService ) {
            _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            CloseServiceHandle(schService);
        } else {
            _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    } else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
} // CmdInstallService



/////////////////////////////////////////////////////////////////////////
VOID
CmdRemoveService()
/*++

Routine Description:

   Stops and removes the service.

Arguments:

   None.

Return Values:

   None.

--*/
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager ) {
        schService = OpenService(schSCManager, TEXT(SZSERVICENAME), SERVICE_ALL_ACCESS);

        if (schService) {
            // try to stop the service
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) ) {
                _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) ) {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING ) {
                        _tprintf(TEXT("."));
                        Sleep( 1000 );
                    } else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                    _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                else
                    _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) );

            }

            // now remove the service
            if( DeleteService(schService) )
                _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            else
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));


            CloseServiceHandle(schService);
        } else
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));

        CloseServiceHandle(schSCManager);
    } else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));

} // CmdRemoveService




/////////////////////////////////////////////////////////////////////////
//
//  Routines for running the service as a console app
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
VOID CmdDebugService(
   int argc,
   char ** argv
   )
/*++

Routine Description:

   Runs the service as a console application

Arguments:

   argc - number of command line arguments ***UNUSED***
   argv - array of command line arguments ***UNUSED***

Return Values:

    None.

--*/
{
    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    // assumption: argv and argc unused
    ServiceStart( 0, NULL );
} // CmdDebugService


/////////////////////////////////////////////////////////////////////////
BOOL WINAPI
ControlHandler (
   DWORD dwCtrlType
   )
/*++

Routine Description:

   Handle console control events.

Arguments:

   dwCtrlType - type of control event
   lpszMsg - text for message

Return Values:

    True - handled
    False - unhandled

--*/
{

    switch( dwCtrlType ) {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
            ServiceStop();
            return TRUE;
            break;

    }

    return FALSE;

} // ControlHandler


/////////////////////////////////////////////////////////////////////////
LPTSTR
GetLastErrorText(
   LPTSTR lpszBuf,
   DWORD dwSize
   )
/*++

Routine Description:

   Copies last error message text to string.

Arguments:

   lpszBuf - destination buffer
   dwSize - size of buffer

Return Values:

    destination buffer

--*/
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
} // GetLastErrorText
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\server.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    server.c

Abstract:


Author:

    Arthur Hanson (arth) 07-Dec-1994

Revision History:

--*/

#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dsgetdc.h>

#include "llsapi.h"
#include "debug.h"
#include "llsutil.h"
#include "llssrv.h"
#include "registry.h"
#include "ntlsapi.h"
#include "mapping.h"
#include "msvctbl.h"
#include "svctbl.h"
#include "purchase.h"
#include "perseat.h"
#include "server.h"

#define NO_LLS_APIS
#include "llsapi.h"


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

ULONG ServerListSize = 0;
PSERVER_RECORD *ServerList = NULL;
PSERVER_RECORD *ServerTable = NULL;

RTL_RESOURCE ServerListLock;


/////////////////////////////////////////////////////////////////////////
NTSTATUS
ServerListInit()

/*++

Routine Description:

Arguments:

   None.

Return Value:

   None.

--*/

{
   NTSTATUS status = STATUS_SUCCESS;

   try
   {
       RtlInitializeResource(&ServerListLock);
   } except(EXCEPTION_EXECUTE_HANDLER ) {
       status = GetExceptionCode();
   }

   if (!NT_SUCCESS(status))
       return status;

   //
   // Add ourself as the first server (master server)
   //
   RtlEnterCriticalSection(&ConfigInfoLock);
   ServerListAdd( ConfigInfo.ComputerName, NULL);
   RtlLeaveCriticalSection(&ConfigInfoLock);
   LocalServerServiceListUpdate();

   return STATUS_SUCCESS;

} // ServerListInit


/////////////////////////////////////////////////////////////////////////
int __cdecl ServerListCompare(const void *arg1, const void *arg2) {
   PSERVER_RECORD Svc1, Svc2;

   Svc1 = (PSERVER_RECORD) *((PSERVER_RECORD *) arg1);
   Svc2 = (PSERVER_RECORD) *((PSERVER_RECORD *) arg2);

   return lstrcmpi( Svc1->Name, Svc2->Name );

} // ServerListCompare


/////////////////////////////////////////////////////////////////////////
int __cdecl ServerServiceListCompare(const void *arg1, const void *arg2) {
   PSERVER_SERVICE_RECORD Svc1, Svc2;

   Svc1 = (PSERVER_SERVICE_RECORD) *((PSERVER_SERVICE_RECORD *) arg1);
   Svc2 = (PSERVER_SERVICE_RECORD) *((PSERVER_SERVICE_RECORD *) arg2);

   return lstrcmpi( MasterServiceTable[Svc1->Service]->Name, MasterServiceTable[Svc2->Service]->Name );

} // ServerServiceListCompare


/////////////////////////////////////////////////////////////////////////
PSERVER_SERVICE_RECORD
ServerServiceListFind(
   LPTSTR Name,
   ULONG ServiceTableSize,
   PSERVER_SERVICE_RECORD *ServiceList
   )

/*++

Routine Description:

   Internal routine to actually do binary search on ServerServiceList, this
   does not do any locking as we expect the wrapper routine to do this.
   The search is a simple binary search.

Arguments:


Return Value:

   Pointer to found service table entry or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end;
   LONG cur;
   int match;
   PMASTER_SERVICE_RECORD Service;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServerServiceListFind\n"));
#endif

   if (ServiceTableSize == 0)
      return NULL;

   end = (LONG) ServiceTableSize - 1;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;
      Service = MasterServiceTable[ServiceList[cur]->Service];

      // compare the two result into match
      match = lstrcmpi(Name, Service->Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return ServiceList[cur];
   }

   return NULL;

} // ServerServiceListFind


/////////////////////////////////////////////////////////////////////////
PSERVER_RECORD
ServerListFind(
   LPTSTR Name
   )

/*++

Routine Description:

   Internal routine to actually do binary search on ServerList, this
   does not do any locking as we expect the wrapper routine to do this.
   The search is a simple binary search.

Arguments:

   ServiceName -

Return Value:

   Pointer to found server table entry or NULL if not found.

--*/

{
   LONG begin = 0;
   LONG end = (LONG) ServerListSize - 1;
   LONG cur;
   int match;
   PSERVER_RECORD Server;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServerListFind\n"));
#endif

   if ((ServerListSize == 0) || (Name == NULL))
      return NULL;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;
      Server = ServerList[cur];

      // compare the two result into match
      match = lstrcmpi(Name, Server->Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return Server;
   }

   return NULL;

} // ServerListFind


/////////////////////////////////////////////////////////////////////////
PSERVER_SERVICE_RECORD
ServerServiceListAdd(
   LPTSTR Name,
   ULONG ServiceIndex,
   PULONG pServiceTableSize,
   PSERVER_SERVICE_RECORD **pServiceList
   )

/*++

Routine Description:


Arguments:

   ServiceName -

Return Value:

   Pointer to added service table entry, or NULL if failed.

--*/

{
   LPTSTR NewName;
   PSERVER_SERVICE_RECORD Service = NULL;
   PSERVER_SERVICE_RECORD *ServiceList;
   ULONG ServiceListSize;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServerServiceListAdd\n"));
#endif

   if ((Name == NULL) || (*Name == TEXT('\0')) || (pServiceTableSize == NULL) || (pServiceList == NULL)) {
#if DBG
      dprintf(TEXT("Error LLS: ServerServiceListAdd Bad Parms\n"));
#endif
      ASSERT(FALSE);
      return NULL;
   }

   ServiceListSize = *pServiceTableSize;
   ServiceList = *pServiceList;

   //
   // Try to find the name
   //
   Service = ServerServiceListFind(Name, ServiceListSize, ServiceList);
   if (Service != NULL) {
      Service->Service = ServiceIndex;
      return Service;
   }

   //
   // No record - so create a new one
   //
   if (ServiceList == NULL) {
      ServiceList = (PSERVER_SERVICE_RECORD *) LocalAlloc(LPTR, sizeof(PSERVER_SERVICE_RECORD));
   } else {
      ServiceList = (PSERVER_SERVICE_RECORD *) LocalReAlloc(ServiceList, sizeof(PSERVER_SERVICE_RECORD) * (ServiceListSize + 1), LHND);
   }

   //
   // Make sure we could allocate server table
   //
   if (ServiceList == NULL) {
      goto ServerServiceListAddExit;
   }

   //
   // Allocate space for Record.
   //
   Service = (PSERVER_SERVICE_RECORD) LocalAlloc(LPTR, sizeof(SERVER_SERVICE_RECORD));
   if (Service == NULL) {
      ASSERT(FALSE);

      LocalFree(ServiceList);
      return NULL;
   }

   ServiceList[ServiceListSize] = Service;

   //
   // Initialize other stuff
   //
   Service->Service = ServiceIndex;
   Service->MaxSessionCount = 0;
   Service->MaxSetSessionCount = 0;
   Service->HighMark = 0;
   Service->Flags = 0;

   ServiceListSize++;

   // Have added the entry - now need to sort it in order of the service names
   qsort((void *) ServiceList, (size_t) ServiceListSize, sizeof(PSERVER_SERVICE_RECORD), ServerServiceListCompare);

ServerServiceListAddExit:
   if (ServiceList != NULL)
   {
       *pServiceTableSize = ServiceListSize;
       *pServiceList = ServiceList;
   }
   return Service;

} // ServerServiceListAdd


/////////////////////////////////////////////////////////////////////////
PSERVER_RECORD
ServerListAdd(
   LPTSTR Name,
   LPTSTR Master
   )

/*++

Routine Description:


Arguments:

   ServiceName -

Return Value:

   Pointer to added service table entry, or NULL if failed.

--*/

{
   LPTSTR NewName;
   PSERVER_RECORD Server;
   PSERVER_RECORD pMaster;
   PSERVER_RECORD *pServerListTmp, *pServerTableTmp;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: ServerListAdd\n"));
#endif

   if ((Name == NULL) || (*Name == TEXT('\0'))) {
#if DBG
      dprintf(TEXT("Error LLS: ServerListAdd Bad Parms\n"));
#endif
      ASSERT(FALSE);
      return NULL;
   }

   //
   // Try to find the name
   //
   Server = ServerListFind(Name);
   if (Server != NULL) {
      return Server;
   }

   //
   // No record - so create a new one
   //
   if (ServerList == NULL) {
      pServerListTmp = (PSERVER_RECORD *) LocalAlloc(LPTR, sizeof(PSERVER_RECORD));
      pServerTableTmp = (PSERVER_RECORD *) LocalAlloc(LPTR, sizeof(PSERVER_RECORD));
   } else {
      pServerListTmp = (PSERVER_RECORD *) LocalReAlloc(ServerList, sizeof(PSERVER_RECORD) * (ServerListSize + 1), LHND);
      pServerTableTmp = (PSERVER_RECORD *) LocalReAlloc(ServerTable, sizeof(PSERVER_RECORD) * (ServerListSize + 1), LHND);
   }

   //
   // Make sure we could allocate server table
   //
   if ((pServerListTmp == NULL) || (pServerTableTmp == NULL)) {
      if (pServerListTmp != NULL)
          LocalFree(pServerListTmp);

      if (pServerTableTmp != NULL)
          LocalFree(pServerTableTmp);

      return NULL;
   } else {
       ServerList = pServerListTmp;
       ServerTable = pServerTableTmp;
   }

   //
   // Allocate space for Record.
   //
   Server = (PSERVER_RECORD) LocalAlloc(LPTR, sizeof(SERVER_RECORD));
   if (Server == NULL) {
      ASSERT(FALSE);
      return NULL;
   }

   ServerList[ServerListSize] = Server;
   ServerTable[ServerListSize] = Server;

   NewName = (LPTSTR) LocalAlloc(LPTR, (lstrlen(Name) + 1) * sizeof(TCHAR));
   if (NewName == NULL) {
      ASSERT(FALSE);
      LocalFree(Server);
      return NULL;
   }

   // now copy it over...
   Server->Name = NewName;
   lstrcpy(NewName, Name);

   //
   // Initialize other stuff
   //
   Server->Index = ServerListSize + 1;
   Server->LastReplicated = 0;
   Server->IsReplicating = FALSE;

   //
   // Fixup slave/master chain
   //
   Server->MasterServer = 0;
   Server->NextServer = 0;
   if (Master != NULL) {
      pMaster = ServerListFind(Master);

      if (pMaster != NULL) {
         Server->MasterServer = pMaster->Index;
         Server->NextServer = pMaster->SlaveServer;
         pMaster->SlaveServer = Server->Index;
      } else {
         ASSERT(FALSE);
      }
   }

   Server->SlaveServer = 0;

   Server->ServiceTableSize = 0;
   Server->Services = NULL;

   ServerListSize++;

   // Have added the entry - now need to sort it in order of the service names
   qsort((void *) ServerList, (size_t) ServerListSize, sizeof(PSERVER_RECORD), ServerListCompare);

   return Server;

} // ServerListAdd


/////////////////////////////////////////////////////////////////////////
VOID
LocalServerServiceListUpdate(
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PSERVER_RECORD Server;
   PMASTER_SERVICE_RECORD Service;
   PSERVER_SERVICE_RECORD ServerService;
   ULONG i, Index;

#if DBG
   if (TraceFlags & TRACE_FUNCTION_TRACE)
      dprintf(TEXT("LLS TRACE: LocalServerServiceListUpdate\n"));
#endif

   //
   // Find our local server in the Server table
   //
   RtlEnterCriticalSection(&ConfigInfoLock);
   RtlAcquireResourceShared(&ServerListLock, TRUE);
   Server = ServerListFind( ConfigInfo.ComputerName );
   RtlReleaseResource(&ServerListLock);
   RtlLeaveCriticalSection(&ConfigInfoLock);

   ASSERT(Server != NULL);
   if (Server == NULL)
      return;

   RtlAcquireResourceShared(&LocalServiceListLock, TRUE);
   RtlAcquireResourceShared(&MasterServiceListLock, TRUE);

   for (i = 0; i < LocalServiceListSize; i++) {
      Service = MasterServiceListFind(LocalServiceList[i]->DisplayName);
      if (Service == NULL) {
         RtlConvertSharedToExclusive(&MasterServiceListLock);
         Service = MasterServiceListAdd(LocalServiceList[i]->FamilyDisplayName, LocalServiceList[i]->DisplayName, 0);
         RtlConvertExclusiveToShared(&MasterServiceListLock);
      }

      if (Service != NULL) {
         ServerService = ServerServiceListAdd( Service->Name, Service->Index, &Server->ServiceTableSize, &Server->Services );

         ASSERT(ServerService != NULL);
         if (ServerService != NULL) {
            //
            // Update high mark if needed
            //
            if ( LocalServiceList[i]->HighMark > ServerService->HighMark )
            {
               ServerService->HighMark = LocalServiceList[i]->HighMark;
            }

            //
            // Subtract any old licenses we might have
            //
            Service->MaxSessionCount -= ServerService->MaxSessionCount;

            //
            // Now update to current Licenses
            //
            ServerService->MaxSessionCount = LocalServiceList[i]->ConcurrentLimit;
            if (LocalServiceList[i]->ConcurrentLimit > ServerService->MaxSetSessionCount)
               ServerService->MaxSetSessionCount = LocalServiceList[i]->ConcurrentLimit;

            Service->MaxSessionCount += ServerService->MaxSessionCount;
            ServerService->Flags &= ~LLS_FLAG_PRODUCT_PERSEAT;

            if (LocalServiceList[i]->Mode == 0)
               ServerService->Flags |= LLS_FLAG_PRODUCT_PERSEAT;

         }

      }

   }

   RtlReleaseResource(&MasterServiceListLock);
   RtlReleaseResource(&LocalServiceListLock);

} // LocalServerServiceListUpdate


/////////////////////////////////////////////////////////////////////////
VOID
LocalServerServiceListHighMarkUpdate(
   )

/*++

Routine Description:

   We've got to do this separatly because it locks the Service Table
   and it needs to be done in reverse.  I.E.  We need to run through
   the Service Table to get the display names and then look it up in
   the ServerServicesList instead of running through the
   ServerServicesList.

Arguments:


Return Value:


--*/

{
   PSERVER_RECORD Server;
   PSERVER_SERVICE_RECORD ServerService;
   PMASTER_SERVICE_RECORD Service;
   ULONG i;

   //
   // Find our local server in the Server table
   //
   RtlEnterCriticalSection(&ConfigInfoLock);
   RtlAcquireResourceShared(&ServerListLock, TRUE);
   Server = ServerListFind( ConfigInfo.ComputerName );
   RtlReleaseResource(&ServerListLock);
   RtlLeaveCriticalSection(&ConfigInfoLock);

   ASSERT(Server != NULL);
   if (Server == NULL)
      return;

   RtlAcquireResourceShared(&MasterServiceListLock, TRUE);
   RtlAcquireResourceShared(&ServiceListLock, TRUE);

   for (i = 0; i < ServiceListSize; i++) {

      ServerService = ServerServiceListFind( ServiceList[i]->DisplayName, Server->ServiceTableSize, Server->Services );

      if (ServerService != NULL) {
         Service = MasterServiceListFind(ServiceList[i]->DisplayName);
         ASSERT(Service != NULL);

         if (Service != NULL) {
            //
            // Subtract any old info we might have
            //
            if (Service->HighMark != 0)
            {
               Service->HighMark -= ServerService->HighMark;
            }

            //
            // Now update to current Licenses
            //
            ServerService->HighMark = ServiceList[i]->HighMark;
            Service->HighMark += ServerService->HighMark;
         }
      }

   }

   RtlReleaseResource(&ServiceListLock);
   RtlReleaseResource(&MasterServiceListLock);

} // LocalServerServiceListHighMarkUpdate



#if DBG

/////////////////////////////////////////////////////////////////////////
VOID
ServerListDebugDump( )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&ServerListLock, TRUE);

   dprintf(TEXT("Server Table, # Entries: %lu\n"), ServerListSize);
   if (ServerList == NULL)
      goto ServerListDebugDumpExit;

   for (i = 0; i < ServerListSize; i++) {
      dprintf(TEXT("%3lu) [%3lu] LR: %s #Svc: %4lu M: %3lu S: %3lu N: %3lu Server: %s\n"),
         i + 1, ServerList[i]->Index, TimeToString(ServerList[i]->LastReplicated), ServerList[i]->ServiceTableSize,
         ServerList[i]->MasterServer, ServerList[i]->SlaveServer, ServerList[i]->NextServer, ServerList[i]->Name);
   }

ServerListDebugDumpExit:
   RtlReleaseResource(&ServerListLock);

   return;
} // ServerListDebugDump


/////////////////////////////////////////////////////////////////////////
VOID
ServerListDebugInfoDump( PVOID Data )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;
   PSERVER_RECORD Server = NULL;

   //
   // Need to scan list so get read access.
   //
   RtlAcquireResourceShared(&ServerListLock, TRUE);

   dprintf(TEXT("Server Table, # Entries: %lu\n"), ServerListSize);
   if (ServerList == NULL)
      goto ServerListDebugInfoDumpExit;

   if (Data == NULL)
      goto ServerListDebugInfoDumpExit;

   Server = ServerListFind( (LPTSTR) Data );
   if (Server == NULL) {
      dprintf(TEXT("Server not found: %s\n"), (LPTSTR) Data );
      goto ServerListDebugInfoDumpExit;
   }

   //
   // Show server
   //
   dprintf(TEXT("[%3lu] LR: %s #Svc: %4lu M: %3lu S: %3lu N: %3lu Server: %s\n"),
         Server->Index, TimeToString(Server->LastReplicated), Server->ServiceTableSize,
         Server->MasterServer, Server->SlaveServer, Server->NextServer, Server->Name);

   //
   // Now all the services for this server
   //
   RtlAcquireResourceShared(&MasterServiceListLock, TRUE);
   for (i = 0; i < Server->ServiceTableSize; i++) {
      dprintf(TEXT("   %3lu) Flags: 0x%4lX MS: %3lu HM: %3lu SHM: %3lu Service: %s\n"),
            i + 1, Server->Services[i]->Flags, Server->Services[i]->MaxSessionCount, Server->Services[i]->HighMark,
            Server->Services[i]->MaxSetSessionCount, MasterServiceTable[Server->Services[i]->Service]->Name);

   }
   RtlReleaseResource(&MasterServiceListLock);

ServerListDebugInfoDumpExit:
   RtlReleaseResource(&ServerListLock);

   return;
} // ServerListDebugInfoDump

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\svctbl.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    SvcTbl.h

Abstract:


Author:

    Arthur Hanson       (arth)      Dec 07, 1994

Environment:

Revision History:

--*/


#ifndef _LLS_SVCTBL_H
#define _LLS_SVCTBL_H


#ifdef __cplusplus
extern "C" {
#endif

typedef struct _SERVICE_RECORD {
   DWORD Index;
   LPTSTR Name;
   LPTSTR DisplayName;
   DWORD Version;
   LPTSTR FamilyName;
   LPTSTR FamilyDisplayName;

   PMASTER_SERVICE_RECORD MasterService;

   BOOL PerSeatLicensing;

   RTL_CRITICAL_SECTION ServiceLock;
   ULONG SessionCount;       // # sessions current active
   ULONG MaxSessionCount;    // Max # simultaneous sessions
   ULONG HighMark;           // Max # simultaneous sessions ever attempted
} SERVICE_RECORD, *PSERVICE_RECORD;


extern ULONG ServiceListSize;
extern PSERVICE_RECORD *ServiceList;
extern PSERVICE_RECORD *ServiceFreeList;
extern RTL_RESOURCE ServiceListLock;


NTSTATUS ServiceListInit();
PSERVICE_RECORD ServiceListAdd( LPTSTR ServiceName, ULONG VersionIndex );
PSERVICE_RECORD ServiceListFind( LPTSTR ServiceName );
VOID ServiceListResynch( );
NTSTATUS DispatchRequestLicense( ULONG DataType, PVOID Data, LPTSTR ServiceID, ULONG VersionIndex, BOOL IsAdmin, ULONG *Handle );
VOID DispatchFreeLicense( ULONG Handle );
DWORD VersionToDWORD(LPTSTR Version);

#if DBG
VOID ServiceListDebugDump( );
VOID ServiceListDebugInfoDump( );
#endif


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\nfr3user\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1996 - 1996

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\lls\server\retail\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\getdclst.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    getdclst.c

Abstract:

    I_NetGetDCList API

Author:

    04-Feb-1992 (CliffV)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <rpc.h>
#include <logon_c.h>// includes lmcons.h, lmaccess.h, netlogon.h, ssi.h, windef.h

#include <debuglib.h>   // IF_DEBUG()
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmserver.h>   // SV_TYPE_* defines
#include <netdebug.h>   // NetpKdPrint
#include <netlib.h>     // NetpGetDomainName
#include <ntlsa.h>      // LsaTrust list
#include <tstring.h>    // STRLEN
#include <stdlib.h>      // wcslen


DBGSTATIC NET_API_STATUS
InternalNetGetDCList (
    IN  LPWSTR ServerName OPTIONAL,
    IN  LPWSTR TrustedDomainName,
    OUT PULONG DCCount,
    OUT PUNICODE_STRING * DCNames
    )

/*++

Routine Description:

    Get the names of the NT Domain Controllers in a domain.  The information
    is returned in a form suitable for storing in the LSA's
    TRUSTED_CONTROLLERS_INFO structure.

    Ideally, ServerName should be the name of a Domain Controller in the
    specified domain.  However, one should first try specifying ServerName
    as the name of the PDC in the trusting domain.  If that fails,
    the UI can prompt for the name of a DC in the domain.


Arguments:

    ServerName - name of remote server (null for local).

    TrustedDomainName - name of domain.

    DCCount - Returns the number of entries in the DCNames array.

    DCNames - Returns a pointer to an array of names of NT Domain Controllers
        in the specified domain.  The first entry is the name of the NT PDC.
        The first entry will be NULL if the PDC cannot be found.
        The buffer should be deallocated using NetApiBufferFree.

Return Value:

        NERR_Success - Success.
        ERROR_INVALID_NAME  Badly formed domain name
        NERR_DCNotFound - No DC's were found in the domain

--*/
{
    NET_API_STATUS NetStatus;

    PSERVER_INFO_101 ServerInfo101 = NULL;
    DWORD EntriesRead;
    DWORD TotalEntries;

    DWORD Size = 0;
    BOOLEAN PdcFound = FALSE;
    PUNICODE_STRING ReturnBuffer = NULL;
    ULONG ReturnCount = 0;

    PUNICODE_STRING CurrentBuffer;
    ULONG CurrentIndex;
    LPWSTR Where;

    DWORD i;



    //
    // Enumerate ALL PDCs and BDCs in the domain.
    //  We'll filter out NT DC's ourselves.
    //
    *DCCount = 0;

    NetStatus = NetServerEnum( ServerName,
                               101,
                               (LPBYTE *) &ServerInfo101,
                               MAX_PREFERRED_LENGTH,
                               &EntriesRead,
                               &TotalEntries,
                               SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL,
                               TrustedDomainName,
                               NULL );          // Resume Handle

    if ( NetStatus != NERR_Success ) {
        IF_DEBUG( LOGON ) {
            NetpKdPrint((
                "InternalNetGetDCList: cannot NetServerEnum '%ws': %ld 0X%lx\n",
                ServerName, NetStatus, NetStatus));
        }
        goto Cleanup;
    }

    //
    // Compute the size of the information to return.
    //

    for ( i=0; i<EntriesRead; i++ ) {

        IF_DEBUG( LOGON ) {
            NetpKdPrint((
                "InternalNetGetDCList: '%ws': enumerated %ws\n",
                ServerName,
                ServerInfo101[i].sv101_name ));
        }

        //
        // Skip non-NT entries
        //

        if ( (ServerInfo101[i].sv101_type & SV_TYPE_NT) == 0 ) {
            IF_DEBUG( LOGON ) {
                NetpKdPrint((
                    "InternalNetGetDCList: '%ws': %ws is not NT\n",
                    ServerName,
                    ServerInfo101[i].sv101_name ));
            }
            continue;
        }

        //
        // Remember whether the PDC was found
        //

        if ( ServerInfo101[i].sv101_type & SV_TYPE_DOMAIN_CTRL ) {
            IF_DEBUG( LOGON ) {
                NetpKdPrint((
                    "InternalNetGetDCList: '%ws': %ws is the PDC\n",
                    ServerName,
                    ServerInfo101[i].sv101_name ));
            }
            PdcFound = TRUE;
        }

        //
        // Leave room for for the UNICODE_STRING structure and the string
        //  itself (including leadind \\'s.
        //

        (*DCCount) ++;
        Size += sizeof(UNICODE_STRING) +
                (STRLEN(ServerInfo101[i].sv101_name) + 3) * sizeof(WCHAR);

    }

    //
    // We must find at least one NT server.
    //

    if ( *DCCount == 0 ) {
        NetStatus = NERR_DCNotFound;
        goto Cleanup;
    }

    if ( !PdcFound ) {
        IF_DEBUG( LOGON ) {
            NetpKdPrint((
                "InternalNetGetDCList: '%ws': PDC not found\n",
                ServerName ));
        }
        (*DCCount) ++;
        Size += sizeof(UNICODE_STRING);
    }

    //
    // Allocate the return buffer.
    //

    NetStatus = NetApiBufferAllocate( Size, (LPVOID *) &ReturnBuffer );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    Where = (LPWSTR) (ReturnBuffer + *DCCount);


    //
    // Fill in the return buffer.
    //

    CurrentIndex = 1;   // The first (zeroeth) entry is for the PDC.
    RtlInitUnicodeString( ReturnBuffer, NULL );

    for ( i=0; i<EntriesRead; i++ ) {

        //
        // Skip non-NT entries
        //

        if ( (ServerInfo101[i].sv101_type & SV_TYPE_NT) == 0 ) {
            continue;
        }

        //
        // Determine which entry to fill in.
        //
        // If multiple PDC's were found, the first one is assumed
        // to be the real PDC>
        //

        if ( (ServerInfo101[i].sv101_type & SV_TYPE_DOMAIN_CTRL) &&
              ReturnBuffer->Buffer == NULL ) {
            CurrentBuffer = ReturnBuffer;

        } else {

            NetpAssert( CurrentIndex < *DCCount );

            CurrentBuffer = &ReturnBuffer[CurrentIndex];
            CurrentIndex++;
        }

        //
        // Copy the string itself to the return buffer
        //
        NetpAssert( ServerInfo101[i].sv101_name[0] != L'\\' );
        *(Where) = '\\';
        *(Where+1) = '\\';
        NetpCopyTStrToWStr( Where+2, ServerInfo101[i].sv101_name );

        //
        // Set the UNICODE_STRING to point to it.
        //

        RtlInitUnicodeString( CurrentBuffer, Where );

        Where += (wcslen(Where) + 1);

    }

    NetpAssert( CurrentIndex == *DCCount );

    NetStatus = NERR_Success;


    //
    // Cleanup locally used resources
    //
Cleanup:

    if ( ServerInfo101 != NULL ) {
        NetApiBufferFree( ServerInfo101 );
    }

    if ( NetStatus != NERR_Success ) {
        if ( ReturnBuffer != NULL ) {
            NetApiBufferFree( ReturnBuffer );
            ReturnBuffer = NULL;
        }
        *DCCount = 0;
    }

    //
    // Return the information to the caller.
    //

    *DCNames = ReturnBuffer;

    return NetStatus;

}



NET_API_STATUS NET_API_FUNCTION
I_NetGetDCList (
    IN  LPWSTR ServerName OPTIONAL,
    IN  LPWSTR TrustedDomainName,
    OUT PULONG DCCount,
    OUT PUNICODE_STRING * DCNames
    )

/*++

Routine Description:

    Get the names of the NT Domain Controllers in a domain.  The information
    is returned in a form suitable for storing in the LSA's
    TRUSTED_CONTROLLERS_INFO structure.

    Ideally, ServerName should be the name of a Domain Controller in the
    specified domain.  However, one should first try specifying ServerName
    as NULL in which case this API will try the the following machines:

        * The local machine.
        * The PDC of the primary domain of the local machine,
        * The PDC of the named trusted domain,
        * Each of the DC's in the LSA's current DC list for the named trusted
            domain.

    If this "NULL" case fails, the UI should prompt for the name of a DC
    in the trusted domain.  This handles the case where the trusted domain
    cannot be reached via the above listed servers.

Arguments:

    ServerName - name of remote server (null for special case).

    TrustedDomainName - name of domain.

    DCCount - Returns the number of entries in the DCNames array.

    DCNames - Returns a pointer to an array of names of NT Domain Controllers
        in the specified domain.  The first entry is the name of the NT PDC.
        The first entry will be NULL if the PDC cannot be found.
        The buffer should be deallocated using NetApiBufferFree.

Return Value:

        NERR_Success - Success.
        ERROR_INVALID_NAME  Badly formed domain name
        NERR_DCNotFound - No DC's were found in the domain.  Perhaps,
            a ServerName should be specified.

--*/
{
    NET_API_STATUS NetStatus;
    NET_API_STATUS SavedNetStatus;

    LPWSTR DCName = NULL;

    //
    // Initialization
    //
    *DCCount = 0;



    //
    // Try straight forward way to get the DC list.
    //

    NetStatus = InternalNetGetDCList( ServerName,
                                      TrustedDomainName,
                                      DCCount,
                                      DCNames );

    if ( NetStatus == NERR_Success || ServerName != NULL ) {
        SavedNetStatus = NetStatus;
        goto Cleanup;
    }

    SavedNetStatus = NetStatus;



    //
    // Simply use the PDC name as the DC list.
    //
    // NetServerEnum might be several minutes out of date.  NetGetDCName
    // broadcasts to find the server, so that information will be more
    // current.
    //

    NetStatus = NetGetDCName( NULL, TrustedDomainName, (LPBYTE*)&DCName);

    if ( NetStatus == NERR_Success ) {

        PUNICODE_STRING ReturnBuffer = NULL;
        DWORD Size;
        LPWSTR Where;

        Size = sizeof(UNICODE_STRING) +
                (wcslen(DCName) + 1) * sizeof(WCHAR);

        NetStatus = NetApiBufferAllocate( Size, (LPVOID *) &ReturnBuffer );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        Where = (LPWSTR)((LPBYTE)ReturnBuffer + sizeof(UNICODE_STRING));

        wcscpy( Where, DCName );

        RtlInitUnicodeString( ReturnBuffer, Where );


        *DCNames = ReturnBuffer;
        *DCCount = 1;

        SavedNetStatus = NERR_Success;
    }


    //
    // Cleanup locally used resources.
    //
Cleanup:

    if( DCName != NULL ) {
       (VOID) NetApiBufferFree( DCName );
    }

    //
    // Return the status code from the original request.
    //
    return SavedNetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\cpdata.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpData.c

Abstract:

    include file for private\net\netlib\data.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1998

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1998 ChandanS
        Created.
--*/

#include "..\..\..\..\netlib\data.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\rpcbind.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    rpcbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the Timesource
    Service.

Author:

    Rajen Shah      (rajens)    02-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    02-Apr-1991     RajenS
        created
    22-May-1992 JohnRo
        RAID 9829: winsvc.h and related file cleanup.

--*/

//
// INCLUDES
//
#define NOSERVICE       // Avoid <winsvc.h> vs. <lmsvc.h> conflicts.
#include <nt.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>
#include <logon_c.h>    // includes lmcons.h, lmaccess.h, netlogon.h, ssi.h, windef.h
#include <lmerr.h>      // NERR_ and ERROR_ equates.
#include <lmsvc.h>
#include <ntrpcp.h>
#include <tstring.h>    // IS_PATH_SEPARATOR ...
#include <nlbind.h>     // Prototypes for these routines
#include <icanon.h>     // NAMETYPE_*

//
// DataTypes
//

typedef struct _CACHE_ENTRY {
    LIST_ENTRY Next;
    UNICODE_STRING UnicodeServerNameString;
    RPC_BINDING_HANDLE RpcBindingHandle;
    ULONG ReferenceCount;
} CACHE_ENTRY, *PCACHE_ENTRY;

//
// STATIC GLOBALS
//

//
// Maintain a cache of RPC binding handles.
//

CRITICAL_SECTION NlGlobalBindingCacheCritSect;
LIST_ENTRY NlGlobalBindingCache;



NET_API_STATUS
NlBindingAttachDll (
    VOID
    )

/*++

Routine Description:

    Initialize the RPC binding handle cache on process attach.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Initialize the Global Cache Critical Section
    //

    try {
        InitializeCriticalSection( &NlGlobalBindingCacheCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        return STATUS_NO_MEMORY;
    }
    InitializeListHead( &NlGlobalBindingCache );

    return NO_ERROR;

}


VOID
NlBindingDetachDll (
    VOID
    )

/*++

Routine Description:

    Cleanup the RPC binding handle cache on process detach.

Arguments:

    None.

Return Value:

    None.

--*/
{

    //
    // The binding cache must be empty,
    //  Netlogon cleans up after itself,
    //  no one else uses the cache.
    //

    ASSERT( IsListEmpty( &NlGlobalBindingCache ) );
    DeleteCriticalSection( &NlGlobalBindingCacheCritSect );
}


PCACHE_ENTRY
NlBindingFindCacheEntry (
    IN LPWSTR UncServerName
    )

/*++

Routine Description:

    Find the specfied cache entry.

    Entered with the NlGlobalBindingCacheCritSect locked.

Arguments:

    UncServerName - Name of the server to lookup

Return Value:

    NULL - Cache entry not found.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    PCACHE_ENTRY CacheEntry;

    UNICODE_STRING UnicodeServerNameString;

    //
    // Ensure the passed in parameter is really a UNC name
    //

    if ( UncServerName == NULL ||
         !IS_PATH_SEPARATOR( UncServerName[0] ) ||
         !IS_PATH_SEPARATOR( UncServerName[1] ) ) {
        return NULL;
    }


    //
    // Loop through the cache finding the entry.
    //

    RtlInitUnicodeString( &UnicodeServerNameString, UncServerName+2 );
    for ( ListEntry = NlGlobalBindingCache.Flink;
          ListEntry != &NlGlobalBindingCache;
          ListEntry = ListEntry->Flink ) {

        CacheEntry = CONTAINING_RECORD( ListEntry, CACHE_ENTRY, Next );

        // Consider using RtlEqualMemory since the strings will really be
        // bit for bit identical since Netlogon flushes this cache before it
        // changes the name.
        if ( RtlEqualUnicodeString( &UnicodeServerNameString,
                                    &CacheEntry->UnicodeServerNameString,
                                    TRUE ) ) {
            return CacheEntry;
        }

    }

    return NULL;
}


NTSTATUS
NlBindingAddServerToCache (
    IN LPWSTR UncServerName,
    IN NL_RPC_BINDING RpcBindingType
    )

/*++

Routine Description:

    Bind to the specified server and add it to the binding cache.

Arguments:

    UncServerName - UNC Name of the server to bind to.

    RpcBindingType - Determines whether to use unauthenticated TCP/IP transport instead of
        named pipes.

Return Value:

    Status of the operation

--*/
{
    NTSTATUS Status;
    RPC_STATUS  RpcStatus;
    PCACHE_ENTRY CacheEntry;

    ASSERT ( UncServerName != NULL &&
         IS_PATH_SEPARATOR( UncServerName[0] ) &&
         IS_PATH_SEPARATOR( UncServerName[1] ) );

    //
    // If there already is an entry in the cache,
    //  just increment the reference count.
    //

    EnterCriticalSection( &NlGlobalBindingCacheCritSect );

    CacheEntry = NlBindingFindCacheEntry( UncServerName );

    if ( CacheEntry != NULL ) {

        CacheEntry->ReferenceCount++;
        Status = STATUS_SUCCESS;

    //
    // Otherwise, allocate an entry and bind to the named server.
    //

    } else {

        UNICODE_STRING UnicodeServerNameString;

        //
        // Allocate the cache entry
        //

        RtlInitUnicodeString( &UnicodeServerNameString, UncServerName+2 );

        CacheEntry = LocalAlloc( 0,
                                 sizeof(CACHE_ENTRY) +
                                    UnicodeServerNameString.Length );

        if ( CacheEntry == NULL ) {

            Status = STATUS_NO_MEMORY;

        } else {


            //
            // Initialize the cache entry.
            //
            // The caller has a 'reference' to the entry.
            //

            CacheEntry->UnicodeServerNameString.Buffer = (LPWSTR)(CacheEntry+1);
            CacheEntry->UnicodeServerNameString.Length =
                CacheEntry->UnicodeServerNameString.MaximumLength =
                UnicodeServerNameString.Length;
            RtlCopyMemory( CacheEntry->UnicodeServerNameString.Buffer,
                           UnicodeServerNameString.Buffer,
                           CacheEntry->UnicodeServerNameString.Length );

            CacheEntry->ReferenceCount = 1;

            //
            // Bind to the server
            //  (Don't hold the crit sect for this potentially very long time.)
            //

            LeaveCriticalSection( &NlGlobalBindingCacheCritSect );
            RpcStatus = NlRpcpBindRpc (
                            UncServerName,
                            SERVICE_NETLOGON,
                            L"Security=Impersonation Dynamic False",
                            RpcBindingType,
                            &CacheEntry->RpcBindingHandle );
            EnterCriticalSection( &NlGlobalBindingCacheCritSect );

            if ( RpcStatus == 0 ) {

                //
                // Link the cache entry into the list
                //
                // If this were a general purpose routine, I'd have to check
                // if someone inserted this cache entry already while we had
                // the crit sect unlocked.  However, the only caller is the
                // netlogon service that has exclusive access to this client.
                //
                // Insert the entry at the front of the list.  Specifically,
                // insert it in front of the binding entry for the same
                // name but a different binding type.  That'll ensure a
                // newer binding type is used instead of an older binding type.
                //

                InsertHeadList( &NlGlobalBindingCache, &CacheEntry->Next );
                Status = STATUS_SUCCESS;

            } else {

                Status = I_RpcMapWin32Status( RpcStatus );

                (VOID) LocalFree( CacheEntry );
            }

        }

    }

    //
    // Return to the caller.
    //

    LeaveCriticalSection( &NlGlobalBindingCacheCritSect );

    return Status;
}


NTSTATUS
NlBindingSetAuthInfo (
    IN LPWSTR UncServerName,
    IN NL_RPC_BINDING RpcBindingType,
    IN BOOL SealIt,
    IN PVOID ClientContext,
    IN LPWSTR ServerContext
    )

/*++

Routine Description:

    Bind to the specified server and add it to the binding cache.

Arguments:

    UncServerName - UNC Name of the server to bind to.

    RpcBindingType - Determines whether to use unauthenticated TCP/IP transport instead of
        named pipes.

    SealIt - Specifies that the secure channel should be sealed (rather than
        simply signed)

    ClientContext - Context used by the client side of the NETLOGON security
        package to associate this call with the existing secure channel.

    ServerContext - Context used by the server side of the NETLOGON security
        package to associate this call with the existing secure channel.

Return Value:

    Status of the operation

--*/
{
    NTSTATUS Status;
    RPC_STATUS  RpcStatus;
    PCACHE_ENTRY CacheEntry;

    ASSERT ( UncServerName != NULL &&
         IS_PATH_SEPARATOR( UncServerName[0] ) &&
         IS_PATH_SEPARATOR( UncServerName[1] ) );

    //
    // Find the cache entry.
    //

    EnterCriticalSection( &NlGlobalBindingCacheCritSect );

    CacheEntry = NlBindingFindCacheEntry( UncServerName );

    if ( CacheEntry == NULL ) {
        LeaveCriticalSection( &NlGlobalBindingCacheCritSect );
        return RPC_NT_INVALID_BINDING;
    }


    //
    // Tell RPC to start doing secure RPC
    //

    RpcStatus = RpcBindingSetAuthInfoW(
                        CacheEntry->RpcBindingHandle,
                        ServerContext,
                        SealIt ? RPC_C_AUTHN_LEVEL_PKT_PRIVACY : RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                        RPC_C_AUTHN_NETLOGON,   // Netlogon's own security package
                        ClientContext,
                        RPC_C_AUTHZ_NAME );

    if ( RpcStatus != 0 ) {
        LeaveCriticalSection( &NlGlobalBindingCacheCritSect );
        return I_RpcMapWin32Status( RpcStatus );
    }

    LeaveCriticalSection( &NlGlobalBindingCacheCritSect );
    return STATUS_SUCCESS;
}


NTSTATUS
NlBindingDecrementAndUnlock (
    IN PCACHE_ENTRY CacheEntry
    )

/*++

Routine Description:

    Decrement the reference count and unlock the NlGlobalBindingCacheCritSect.

    If the reference count reaches 0, unbind the interface, unlink the cache
    entry and delete it.

    Entered with the NlGlobalBindingCacheCritSect locked.

Arguments:

    UncServerName - UNC Name of the server to bind to.

Return Value:

    Status of the operation

--*/
{
    NTSTATUS Status;
    RPC_STATUS RpcStatus;

    //
    // Decrement the reference count
    //
    // If it didn't reach zero, just unlock the crit sect and return.
    //

    if ( (--CacheEntry->ReferenceCount) != 0 ) {

        LeaveCriticalSection( &NlGlobalBindingCacheCritSect );
        return STATUS_PENDING;

    }

    //
    // Remove the entry from the list and unlock the crit sect.
    //
    // Once the entry is removed from the list, we can safely unlock the
    // crit sect.  Then we can unbind (a potentially lengthy operation) with
    // the crit sect unlocked.
    //

    RemoveEntryList( &CacheEntry->Next );
    LeaveCriticalSection( &NlGlobalBindingCacheCritSect );

    //
    // Unbind and delete the cache entry.
    //

    RpcStatus = RpcpUnbindRpc( CacheEntry->RpcBindingHandle );

    if ( RpcStatus != 0 ) {
        Status = I_RpcMapWin32Status( RpcStatus );
    } else {
        Status = STATUS_SUCCESS;
    }

    (VOID) LocalFree( CacheEntry );

    return Status;

}


NTSTATUS
NlBindingRemoveServerFromCache (
    IN LPWSTR UncServerName,
    IN NL_RPC_BINDING RpcBindingType
    )

/*++

Routine Description:

    Unbind to the specified server and remove it from the binding cache.

Arguments:

    UncServerName - UNC Name of the server to unbind from.

    RpcBindingType - Determines whether to use unauthenticated TCP/IP transport instead of
        named pipes.

Return Value:

    Status of the operation

--*/
{
    NTSTATUS Status;
    PCACHE_ENTRY CacheEntry;

    ASSERT ( UncServerName != NULL &&
         IS_PATH_SEPARATOR( UncServerName[0] ) &&
         IS_PATH_SEPARATOR( UncServerName[1] ) );

    //
    // If there is no cache entry,
    //  silently ignore the situation.
    //

    EnterCriticalSection( &NlGlobalBindingCacheCritSect );

    CacheEntry = NlBindingFindCacheEntry( UncServerName );

    if ( CacheEntry == NULL ) {

        ASSERT( FALSE );
        LeaveCriticalSection( &NlGlobalBindingCacheCritSect );
        return STATUS_SUCCESS;
    }

    //
    // Decrement the reference count and unlock the crit sect.
    //

    Status = NlBindingDecrementAndUnlock( CacheEntry );

    return Status;
}



handle_t
LOGONSRV_HANDLE_bind (
    LOGONSRV_HANDLE UncServerName)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.

Arguments:

    UncServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t RpcBindingHandle;
    RPC_STATUS RpcStatus;
    PCACHE_ENTRY CacheEntry;


    //
    // If there is a cache entry,
    //  increment the reference count and use the cached handle
    //

    EnterCriticalSection( &NlGlobalBindingCacheCritSect );

    CacheEntry = NlBindingFindCacheEntry( UncServerName );

    if ( CacheEntry != NULL ) {

        CacheEntry->ReferenceCount ++;
        RpcBindingHandle = CacheEntry->RpcBindingHandle;
        LeaveCriticalSection( &NlGlobalBindingCacheCritSect );

        return RpcBindingHandle;
    }

    LeaveCriticalSection( &NlGlobalBindingCacheCritSect );

    //
    // If there is no cache entry,
    //  simply create a new binding.
    //

    RpcStatus = NlRpcpBindRpc (
                    UncServerName,
                    SERVICE_NETLOGON,
                    L"Security=Impersonation Dynamic False",
                    UseNamedPipe,  // Always use named pipe.
                    &RpcBindingHandle );

    if ( RpcStatus != 0 ) {
        RpcBindingHandle = NULL;
    }

    return RpcBindingHandle;

}



void
LOGONSRV_HANDLE_unbind (
    LOGONSRV_HANDLE UncServerName,
    handle_t RpcBindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.


Arguments:

    UncServerName - This is the name of the server from which to unbind.

    RpcBindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS RpcStatus;
    PLIST_ENTRY ListEntry;
    PCACHE_ENTRY CacheEntry;

    //
    // Loop through the cache finding the entry.
    //

    EnterCriticalSection( &NlGlobalBindingCacheCritSect );
    for ( ListEntry = NlGlobalBindingCache.Flink;
          ListEntry != &NlGlobalBindingCache;
          ListEntry = ListEntry->Flink ) {

        CacheEntry = CONTAINING_RECORD( ListEntry, CACHE_ENTRY, Next );

        //
        // If the cache entry was found,
        //  decrement the reference count and unlock the crit sect.
        //

        if ( RpcBindingHandle == CacheEntry->RpcBindingHandle ) {
            (VOID) NlBindingDecrementAndUnlock( CacheEntry );
            return;
        }

    }
    LeaveCriticalSection( &NlGlobalBindingCacheCritSect );


    //
    // Just Unbind the handle
    //

    RpcStatus = RpcpUnbindRpc( RpcBindingHandle );
    return;

    UNREFERENCED_PARAMETER(UncServerName);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\apibuff.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    ApiBuff.c

Abstract:

    This module contains routines for allocating and freeing API buffers.

Author:

    John Rogers (JohnRo) 25-Jan-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    Parts of the commentary for this file are extracted from material written
    by Alec Barker (AlecB@Microsoft).

Revision History:

    15-Mar-91 JohnRo
        Use <netdebug.h> and netlib routines.
    25-Apr-1991 JohnRo
        Call MIDL_user_allocate and MIDL_user_free.  Delete tabs.
    03-Dec-1991 JohnRo
        Added public NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.
        Make sure buffers are aligned for worst case use.
    10-May-1992 JohnRo
        Treat alloc and realloc of size zero as non-error (return NULL ptr).
        Use <prefix.h> equates.
        Include my own prototypes so compiler can check them.
    18-May-1992 JohnRo
        RAID 9258: return non-null pointer when allocating zero bytes.

--*/

// These must be included first:

#include <windef.h>     // IN, LPVOID, etc.
#include <lmcons.h>     // NET_API_FUNCTION, etc.
#include <rpc.h>        // rpc prototypes

// These may be included in any order:

#include <align.h>      // POINTER_IS_ALIGNED(), ALIGN_WORST.
#include <lmapibuf.h>   // My prototypes.
#ifndef WIN32_CHICAGO
#include <netdebug.h>   // NetpAssert(), NetpKdPrint(()), FORMAT_.
#else // WIN32_CHICAGO
#include <nldebug.h>   // NetpAssert(), NetpKdPrint(()), FORMAT_.
#endif // WIN32_CHICAGO
#include <prefix.h>     // PREFIX_ equates.
#include <rpcutil.h>    // MIDL_user_allocate(), etc.
#include <winerror.h>   // NO_ERROR and ERROR_ equates.

#ifdef WIN32_CHICAGO
#include <assert.h>
PVOID
MIDL_user_allocate(
    IN size_t BufferSize
    )
{
    return (LocalAlloc(0, BufferSize));
}

VOID
MIDL_user_free(
    IN PVOID Buffer
    )
{
    LocalFree(Buffer);
}
#endif // WIN32_CHICAGO

NET_API_STATUS NET_API_FUNCTION
NetApiBufferAllocate(
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    )

/*++

Routine Description:

    NetApiBufferAllocate is an internal function that allocates buffers
    which the APIs will return to the application.  (Usually these are for
    get-info operations.)

Arguments:

    ByteCount - Supplies the size (in bytes) that must be allocated for this
        buffer.  This may be zero, in which case a non-null pointer is
        passed-back and NO_ERROR is returned.

    Buffer - On return a pointer to the allocated area is returned in the
        address pointed to by Buffer.  (This is set to NULL on error.)
        The allocated area is guaranteed to be worst-case aligned for any
        use whatsoever.

Return Value:

    NET_API_STATUS - NO_ERROR if size is zero or memory was allocated.
        ERROR_NOT_ENOUGH_MEMORY if memory is not available.
        ERROR_INVALID_PARAMETER if a parameter is in error.

--*/

{

    if (Buffer == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Allocate the space.  Note that MIDL_user_allocate must allow zero
    // bytes to be allocated.
    //
    *Buffer = MIDL_user_allocate(ByteCount);

    if (*Buffer == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
#ifndef WIN32_CHICAGO
    NetpAssert( POINTER_IS_ALIGNED( *Buffer, ALIGN_WORST) );
#else // WIN32_CHICAGO
    assert( POINTER_IS_ALIGNED( *Buffer, ALIGN_WORST) );
#endif // WIN32_CHICAGO

    return (NO_ERROR);

} // NetApiBufferAllocate



NET_API_STATUS NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    )

/*++

Routine Description:

    NetApiBufferFree is called to deallocate memory which was acquired by
    a previous Net API call (e.g. NetApiBufferAllocate, NetWkstaGetInfo, and
    so on).

Arguments:

    Buffer - Supplies a pointer to an API information buffer previously
        returned on a Net API call.  (This would have been allocated by
        NetapipAllocateBuffer on behalf of one of the end-user Net API calls,
        e.g. NetWkstaGetInfo.)

Return Value:

    NET_API_STATUS.  Returns NO_ERROR if Buffer is null or memory was freed.
        Returns ERROR_INVALID_PARAMETER if Buffer points to an unaligned area.

--*/

{
    if (Buffer == NULL) {
        return (NO_ERROR);
    }

    if ( !POINTER_IS_ALIGNED( Buffer, ALIGN_WORST ) ) {
#ifndef WIN32_CHICAGO
        NetpKdPrint(( PREFIX_NETAPI "NetApiBufferFree: unaligned input ptr: "
                FORMAT_LPVOID "!\n", (LPVOID) Buffer ));
#endif // WIN32_CHICAGO
        return (ERROR_INVALID_PARAMETER);
    }

    MIDL_user_free(Buffer);

    return (NO_ERROR);

} // NetApiBufferFree


#ifndef WIN32_CHICAGO
NET_API_STATUS NET_API_FUNCTION
NetApiBufferReallocate(
    IN LPVOID OldBuffer OPTIONAL,
    IN DWORD NewByteCount,
    OUT LPVOID * NewBuffer
    )
{
    LPVOID NewPointer;

    if ( (OldBuffer==NULL) && (NewByteCount==0) ) {
        *NewBuffer = NULL;
        return (NO_ERROR);
    }

    NewPointer = (void *)MIDL_user_reallocate(  // may alloc, realloc, or free.
            (void *) OldBuffer,
            (unsigned long) NewByteCount);

    if (NewByteCount == 0) {                    // free
        *NewBuffer = NULL;
        return (NO_ERROR);
    } else if (NewPointer == NULL) {            // out of memory
        *NewBuffer = OldBuffer;                 // (don't lose old buffer)
        return (ERROR_NOT_ENOUGH_MEMORY);
    } else {                                    // alloc or realloc
        *NewBuffer = NewPointer;
        return (NO_ERROR);
    }

    /*NOTREACHED*/


} // NetApiBufferReallocate


NET_API_STATUS NET_API_FUNCTION
NetApiBufferSize(
    IN LPVOID Buffer,
    OUT LPDWORD ByteCount
    )
{
    DWORD AllocedSize;

    if ( (Buffer==NULL) || (ByteCount==NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    } else if (POINTER_IS_ALIGNED( ByteCount, ALIGN_DWORD ) == FALSE) {
        return (ERROR_INVALID_PARAMETER);
    } else if (POINTER_IS_ALIGNED( Buffer, ALIGN_WORST ) == FALSE) {
        // Caller didn't get this pointer from us!
        return (ERROR_INVALID_PARAMETER);
    }

    AllocedSize = (unsigned long)MIDL_user_size(
            (void *) Buffer);

    NetpAssert( AllocedSize > 0 );

    *ByteCount = AllocedSize;
    return (NO_ERROR);


} // NetApiBufferSize
#endif // WIN32_CHICAGO



NET_API_STATUS NET_API_FUNCTION
NetapipBufferAllocate (
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    )

/*++

Routine Description:

    NetapipBufferAllocate is an old internal function that allocates buffers
    which the APIs will return to the application.  All calls to this routine
    should eventually be replaced by calls to NetApiBufferAllocate.

Arguments:

    (Same as NetApiBufferAllocate.)

Return Value:

    (Same as NetApiBufferAllocate.)

--*/

{
    return (NetApiBufferAllocate( ByteCount, Buffer ));

} // NetapipBufferAllocate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\getdcnam.c ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    getdcnam.c

Abstract:

    NetGetDCName API

Author:

    Ported from Lan Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Feb-1989 (PaulC)
        Created file, to hold NetGetDCName.

    18-Apr-1989 (Ericpe)
        Implemented NetGetDCName.

    30-May-1989 (DannyGl)
        Reduced DosReadMailslot timeout.

    07-Jul-1989 (NealF)
        Use I_NetNameCanonicalize

    27-Jul-1989 (WilliamW)
        Use WIN3 manifest for WIN3.0 compatibility

    03-Jan-1990 (WilliamW)
        canonicalize domain and use I_NetCompareName

    08-Jun-1991 (CliffV)
        Ported to NT

    23-Jul-1991 JohnRo
        Implement downlevel NetGetDCName.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifndef WIN32_CHICAGO
#include <rpc.h>
#include <ntrpcp.h>   // needed by rpcasync.h
#include <rpcasync.h> // I_RpcExceptionFilter
#include <logon_c.h>// includes lmcons.h, lmaccess.h, netlogon.h, ssi.h, windef.h
#else // WIN32_CHICAGO
#include <windef.h>
#include <lmcons.h>
#endif // WIN32_CHICAGO
#include <stdio.h>

#include <winbase.h>
#include <winsock2.h>

#ifndef WIN32_CHICAGO
#include <accessp.h>
#include <align.h>
#endif // WIN32_CHICAGO
#include <debuglib.h>   // IF_DEBUG()
#include <dsgetdc.h>    // DsGetDcName()
#include <dsgetdcp.h>   // DsGetDcNameWithAccount()
#include <icanon.h>     // NAMETYPE_* defines NetpIsRemote(), NIRFLAG_ equates.
#include <lmapibuf.h>
#include <lmerr.h>
#ifndef WIN32_CHICAGO
#include <lmremutl.h>   // SUPPORTS_* defines
#include <lmserver.h>   // SV_TYPE_* defines
#include <lmsvc.h>      // SERVICE_* defines
#include <lmwksta.h>
#include <logonp.h>     // NetpLogon routines
#include <nlbind.h>     // Netlogon RPC binding cache init routines
#endif // WIN32_CHICAGO
#include <netdebug.h>   // NetpKdPrint
#include <netlib.h>     // NetpMemoryFree
#ifndef WIN32_CHICAGO
#include <netlibnt.h>   // NetpApiStatusToNtStatus
#include <netrpc.h>
#include <rxdomain.h>   // RxNetGetDCName().
#include <string.h>
#include <stdlib.h>
#endif // WIN32_CHICAGO
#include <tstring.h>    // NetpCopyStrToWStr()

#if DBG
#define NETLOGONDBG 1
#endif // DBG
#include <nldebug.h>    // NlPrint()
#include <ntddbrow.h>   // Needed by nlcommon.h
#include <nlcommon.h>   // Definitions shared with netlogon



//
// Only dynamically initialize winsock.
//
CRITICAL_SECTION GlobalDCNameCritSect;
BOOLEAN DsGetDcWsaInitialized;

#define LOCKDOMAINSEM() EnterCriticalSection( &GlobalDCNameCritSect )
#define UNLOCKDOMAINSEM() LeaveCriticalSection( &GlobalDCNameCritSect )

// end global dll data

#ifdef WIN32_CHICAGO // from net\inc\logonp.h
NET_API_STATUS
NetpLogonWriteMailslot(
    IN LPWSTR MailslotName,
    IN LPVOID Buffer,
    IN DWORD BufferSize
    );
NTSTATUS
NetpApiStatusToNtStatus(
    NET_API_STATUS  NetStatus
    );
#endif // WIN32_CHICAGO


NET_API_STATUS
DCNameInitialize(
    VOID
    )
/*++

Routine Description:

    Perform per-process initialization.

Arguments:

    None.

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;


#ifndef NETTEST_UTILITY
#ifndef WIN32_CHICAGO
    //
    // Initialize the RPC binding cache.
    //

    NetStatus = NlBindingAttachDll();

    if ( NetStatus != NO_ERROR ) {
        return NetStatus;
    }
#endif // WIN32_CHICAGO
#endif // NETTEST_UTILITY

    //
    // Initialize the DLL critsects.
    //

    try {
        InitializeCriticalSection( &GlobalDCNameCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NlPrint((0,"NETAPI32.DLL: Cannot initialize GlobalDCNameCritSect\n"));
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
    }

    if ( NetStatus == NO_ERROR ) {

        //
        // Initialize globals
        //

        DsGetDcWsaInitialized = FALSE;

        //
        // Initialize the cache of discovered domains.
        //

        NetStatus = NetpDcInitializeCache();

        if ( NetStatus != NO_ERROR ) {
            NlPrint((0,"NETAPI32.DLL: Cannot NetpDcinitializeCache\n"));
        }
    }

    return NetStatus;
}


VOID
DCNameClose(
    VOID
    )
/*++

Routine Description:

    Perform per-process cleanup.

Arguments:

    None.

Return Value:

    None.

--*/
{

#ifndef NETTEST_UTILITY
#ifndef WIN32_CHICAGO
    //
    // Shutdown the RPC binding cache.
    //

    NlBindingDetachDll();
#endif // WIN32_CHICAGO
#endif // NETTEST_UTILITY

    //
    // If we initialized winsock,
    //  cleanup.
    //

    LOCKDOMAINSEM();
    if ( DsGetDcWsaInitialized ) {
        WSACleanup();
        DsGetDcWsaInitialized = FALSE;
    }
    UNLOCKDOMAINSEM();

    //
    // Delete the critsect that protects the DCName cache
    //

    DeleteCriticalSection( &GlobalDCNameCritSect );

    //
    // Free the cache of discovered DCs.
    //

    NetpDcUninitializeCache();

}


#if NETLOGONDBG
#define MAX_PRINTF_LEN 1024        // Arbitrary.


VOID
NlPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
/*++

Routine Description:

    Local version of NlPrintRoutine for those instances where we're not
    compiled directly into the netlogon service.

Arguments:

Return Value:

--*/
{
#ifdef NETTEST_UTILITY
    extern BOOL ReallyVerbose;
#endif // NETTEST_UTILITY

#ifndef NETTEST_UTILITY
    // NetlibpTrace |= NETLIB_DEBUG_LOGON; // ?? Force verbosity
#ifndef WIN32_CHICAGO
    IF_DEBUG( LOGON ) {
#endif // WIN32_CHICAGO
#endif // NETTEST_UTILITY
        va_list arglist;
        char OutputBuffer[MAX_PRINTF_LEN];
        ULONG length = 0;
        static BeginningOfLine = TRUE;

        //
        // Handle the beginning of a new line.
        //
        //

        if ( BeginningOfLine ) {
#ifdef NETTEST_UTILITY
            if ( ReallyVerbose ) {
                 printf( "        " );
            }
#endif // NETTEST_UTILITY
        }

        va_start(arglist, Format);

#ifndef WIN32_CHICAGO
        length = (ULONG) vsprintf(OutputBuffer, Format, arglist);

#else // WIN32_CHICAGO
        length = (ULONG) vsprintf(OutputBuffer + length - 1, Format, arglist);
#endif // WIN32_CHICAGO
        va_end(arglist);
        BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );

        // Output buffer may contain percent signs (like "%SystemRoot%"), so
        // print it without parsing it.
#ifndef WIN32_CHICAGO
#ifdef NETTEST_UTILITY
        if ( ReallyVerbose ) {
             printf( "%s", (PCH) OutputBuffer);
        }
#else  NETTEST_UTILITY
        (void) DbgPrint( "%s", (PCH) OutputBuffer);
#endif // NETTEST_UTILITY
#else // WIN32_CHICAGO
        OutputDebugString( OutputBuffer);
#endif // WIN32_CHICAGO

#ifndef NETTEST_UTILITY
#ifndef WIN32_CHICAGO
    }
#endif // WIN32_CHICAGO
#endif // NETTEST_UTILITY

}

#endif // DBG

#ifndef WIN32_CHICAGO

#if NETLOGONDBG
//
// Have my own version of RtlAssert so debug versions of netlogon really assert on
// free builds.
//
VOID
NlAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{

#ifdef NETTEST_UTILITY
    NlPrint((0, "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                ));
#else  NETTEST_UTILITY
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );
#endif  NETTEST_UTILITY
}
#endif // DBG
#endif //WIN32_CHICAGO

#if NETLOGONDBG

VOID
NlpDumpBuffer(
    IN DWORD DebugFlag,
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    DebugFlag: Debug flag to pass on to NlPrintRoutine

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            NlPrint((0,"%02x ", BufferPtr[i]));

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            NlPrint((0,"   "));
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            NlPrint((0,"  %s\n", TextBuffer));
        }

    }

    UNREFERENCED_PARAMETER( DebugFlag );
}
#endif // DBG


NTSTATUS
NlBrowserSendDatagram(
    IN PVOID ContextDomainInfo,
    IN ULONG IpAddress,
    IN LPWSTR UnicodeDestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR TransportName,
    IN LPSTR OemMailslotName,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN OUT PBOOL FlushNameOnOneIpTransport OPTIONAL
    )
/*++

Routine Description:

    Send the specified mailslot message to the specified mailslot on the
    specified server on the specified transport..

Arguments:

    DomainInfo - Hosted domain sending the datagram

    IpAddress - IpAddress of the machine to send the pind to.
        If zero, UnicodeDestinationName must be specified.
        If ALL_IP_TRANSPORTS, UnicodeDestination must be specified but the datagram
            will only be sent on IP transports.

    UnicodeDestinationName -- Name of the server to send to.

    NameType -- Type of name represented by UnicodeDestinationName.

    TransportName -- Name of the transport to send on.
        Use NULL to send on all transports.

    OemMailslotName -- Name of the mailslot to send to.

    Buffer -- Specifies a pointer to the mailslot message to send.

    BufferSize -- Size in bytes of the mailslot message

    FlushNameOnOneIpTransport -- Ignored in this implementation

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    WCHAR NetlogonMailslotName[MAX_PATH+1];

    //
    // Sanity check.
    //

    if ( ContextDomainInfo != NULL ||
         TransportName != NULL ) {

        NlPrint((NL_CRITICAL, "NETAPI32: NlBrowserSendDatagram internal error.\n" ));
        return STATUS_INTERNAL_ERROR;
    }

    //
    // Start building the destination mailslot name.
    //

    NetlogonMailslotName[0] = '\\';
    NetlogonMailslotName[1] = '\\';

    if ( UnicodeDestinationName != NULL ) {
        wcscpy(NetlogonMailslotName + 2, UnicodeDestinationName );
    } else {
        NlPrint((NL_CRITICAL, "NETAPI32: NlBrowserSendDatagram internal error 2.\n" ));
        return STATUS_INTERNAL_ERROR;
    }

    switch ( NameType ) {
    case PrimaryDomain:              // Primary domain (signature 0), group
        break;
    case DomainName:                 // DC Domain name (domain name, signature 1c)
        wcscat( NetlogonMailslotName, L"*" );
        break;
    case PrimaryDomainBrowser:       // PDC Browser name (domain name, signature 1b), unique
        wcscat( NetlogonMailslotName, L"**" );
        break;
    default:
        return STATUS_INVALID_PARAMETER;
    }

    NetpCopyStrToWStr( &NetlogonMailslotName[wcslen(NetlogonMailslotName)],
                       OemMailslotName );

    NetStatus = NetpLogonWriteMailslot(
                    NetlogonMailslotName,
                    Buffer,
                    BufferSize );

#ifndef WIN32_CHICAGO
    NlPrint((NL_MAILSLOT,
             "Sent out '%s' message to %ws on all transports.\n",
             NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)Buffer)->Opcode),
             NetlogonMailslotName));
#endif // WIN32_CHICAGO

#if NETLOGONDBG
    NlpDumpBuffer( NL_MAILSLOT_TEXT, Buffer, BufferSize );
#endif // NETLOGONDBG
    if ( NetStatus != NERR_Success ) {

        Status = NetpApiStatusToNtStatus( NetStatus );

        NlPrint(( NL_CRITICAL,
                "NetpDcSendPing: cannot write netlogon mailslot: %ws 0x%lx %ld\n",
                UnicodeDestinationName,
                IpAddress,
                NetStatus));

    } else {
        Status = STATUS_SUCCESS;
    }

    NlPrint(( NL_MISC, "NlBrowserSendDatagram : returned 0x%lx\n", NetStatus));
    return Status;
}

NET_API_STATUS
DsWsaInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize winsock.

Arguments:

    None.

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;

    WORD wVersionRequested;
    WSADATA wsaData;
    int err;

    LOCKDOMAINSEM();

    if ( !DsGetDcWsaInitialized ) {
        //
        // Initialize winsock.
        //

        wVersionRequested = MAKEWORD( 1, 1 );

        NetStatus = WSAStartup( wVersionRequested, &wsaData );
        if ( NetStatus != 0 ) {
            UNLOCKDOMAINSEM();
            NlPrint((NL_CRITICAL, "NETAPI32.DLL: Cannot initialize winsock %ld.\n", NetStatus ));
            return NetStatus;
        }

        if ( LOBYTE( wsaData.wVersion ) != 1 ||
             HIBYTE( wsaData.wVersion ) != 1 ) {
            WSACleanup();
            UNLOCKDOMAINSEM();
            NlPrint((NL_CRITICAL, "NETAPI32.DLL: Wrong winsock version %ld.\n", wsaData.wVersion ));
            return WSANOTINITIALISED;
        }

        DsGetDcWsaInitialized = TRUE;
    }

    UNLOCKDOMAINSEM();
    return NO_ERROR;
}

DWORD
DsWsaGetDcName(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    IN ULONG InternalFlags,
    IN DWORD Timeout,
    IN LPWSTR NetbiosPrimaryDomainName OPTIONAL,
    IN LPWSTR DnsPrimaryDomainName OPTIONAL,
    IN GUID *PrimaryDomainGuid OPTIONAL,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    Wrapper for DsIGetDcName that ensures WSA has been initialized.
                        i
Arguments:

    (See DsIGetDcName).


Return Value:

    (See DsIGetDcName).

--*/
{
    NET_API_STATUS NetStatus;


    //
    // Pass the call through to DsIGetDcName
    //

    NetStatus = DsIGetDcName(
                    ComputerName,
                    AccountName,
                    AllowableAccountControlBits,
                    DomainName,
                    NULL,   // Tree name is not known
                    DomainGuid,
                    SiteName,
                    Flags,
                    InternalFlags,
                    NULL,   // No send datagram context
                    Timeout,
                    NetbiosPrimaryDomainName,
                    DnsPrimaryDomainName,
                    PrimaryDomainGuid,
                    NULL,
                    NULL,
                    DomainControllerInfo );

    //
    // If Winsock has not yet been initialized,
    //  initialize it.
    //

    if ( NetStatus == WSANOTINITIALISED ) {

        //
        // Initialize WSA.
        //

        NetStatus = DsWsaInitialize();

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Repeat the call.
        //

        NetStatus = DsIGetDcName(
                        ComputerName,
                        AccountName,
                        AllowableAccountControlBits,
                        DomainName,
                        NULL,   // Tree name is not known
                        DomainGuid,
                        SiteName,
                        Flags,
                        InternalFlags,
                        NULL,   // No send datagram context
                        Timeout,
                        NetbiosPrimaryDomainName,
                        DnsPrimaryDomainName,
                        PrimaryDomainGuid,
                        NULL,
                        NULL,
                        DomainControllerInfo );
    }

    //
    // Free locally used resouces.
    //

Cleanup:
    return NetStatus;

}

DWORD
DsLocalGetDcName(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    IN ULONG InternalFlags,
    IN DWORD Timeout,
    IN LPWSTR NetbiosPrimaryDomainName OPTIONAL,
    IN LPWSTR DnsPrimaryDomainName OPTIONAL,
    IN LPWSTR DnsPrimaryForestName OPTIONAL,
    IN GUID *PrimaryDomainGuid OPTIONAL,
    OUT PBOOLEAN Local,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    Wrapper for DsWsaGetDcName that ensures this is a local call.

Arguments:

    (See DsIGetDcName).

    Local - Returns TRUE if the call is local and this routine performed
        the requested operation.


Return Value:

    (See DsIGetDcName).

--*/
{
    NET_API_STATUS NetStatus;

    DWORD LocalOrRemote;

    //
    // If no computername was specified,
    //  mark this as a local call.
    //

    *Local = TRUE;

#ifndef WIN32_CHICAGO
    if ( ComputerName == NULL || ComputerName[0] == '\0' ) {

        LocalOrRemote = ISLOCAL;

    //
    // Check if the ComputerName specifies this machine.
    //

    } else {

        NetStatus = NetpIsRemote(
                (LPWSTR) ComputerName,    // uncanon server name
                &LocalOrRemote,
                NULL,
                0 );

        if (NetStatus != NERR_Success) {
            goto Cleanup;
        }

    }
#else // WIN32_CHICAGO
        LocalOrRemote = ISLOCAL;
#endif // WIN32_CHICAGO

    //
    // If the call is local,
    //  just do it.
    //

    if ( LocalOrRemote == ISLOCAL ) {

        //
        // Initialize WSA.
        //  (Ignore errors since WSA isn't always needed.)
        //

        (VOID) DsWsaInitialize();

        NetStatus = DsIGetDcName(
                        NULL,   // Don't use computer name.  This has to be netbios name
                        AccountName,
                        AllowableAccountControlBits,
                        DomainName,
                        DnsPrimaryForestName,
                        DomainGuid,
                        SiteName,
                        Flags,
                        InternalFlags,
                        NULL,   // No send datagram context
                        Timeout,
                        NetbiosPrimaryDomainName,
                        DnsPrimaryDomainName,
                        PrimaryDomainGuid,
                        NULL,
                        NULL,
                        DomainControllerInfo );

    } else {
        *Local = FALSE;
        NetStatus = NO_ERROR;
    }

    //
    // Cleanup all locally used resources
    //
#ifndef WIN32_CHICAGO
Cleanup:
#endif // WIN32_CHICAGO
    return NetStatus;
}

DWORD
WINAPI
DsGetDcOpenW(
    IN LPCWSTR DnsName,
    IN ULONG OptionFlags,
    IN LPCWSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR DnsForestName OPTIONAL,
    IN ULONG DcFlags,
    OUT PHANDLE RetGetDcContext
    )
/*++

Routine Description:

    Open a context for retrieval of the addresses of machines that have
    registered LDAP.TCP.<xxx> SRV records.

Arguments:

    DnsName - Unicode DNS name of the LDAP server to lookup

    OptionFlags - Flags affecting the operation of the routine.

        DS_ONLY_DO_SITE_NAME - Non-site names should be ignored.

        DS_NOTIFY_AFTER_SITE_RECORDS - Return ERROR_FILEMARK_DETECTED
            after all site specific records have been processed.

    SiteName - Name of site the client is in.

    DomainGuid -  Specifies the GUID of the domain specified by DnsName.
        This value is used to handle the case of domain renames.  If this
        value is specified and DomainName has been renamed, DsGetDcName will
        attempt to locate a DC in the domain having this specified DomainGuid.

    DnsForestName - Specifies the name of the domain at the root of the tree
        containing DnsName.  This value is used in conjunction with DomainGuid
        for finding DnsName if the domain has been renamed.

    DcFlags - Passes additional information to be used to process the request.
        DcFlags can be a combination values bitwise or'ed together.

        Any of the following flags are allowed and have the same meaning as
        for DsGetDcName:

        DS_PDC_REQUIRED
        DS_GC_SERVER_REQUIRED
        DS_WRITABLE_REQUIRED
        DS_FORCE_REDISCOVERY - Avoids DNS cache

        If no flags are specified, no special DC role is required.

    RetGetDcContext - Returns an opaque context.
        This context must be freed using DsGetDcClose.

Return Value:

    Status of the operation.

    NO_ERROR: GetDcContext was returned successfully.

--*/

{
    NET_API_STATUS NetStatus = NO_ERROR;
    LPSTR DnsNameUtf8 = NULL;
    LPSTR DnsForestNameUtf8 = NULL;

    //
    // Validate the input
    //

    if ( DnsName == NULL || *DnsName == UNICODE_NULL ) {
        NetStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( RetGetDcContext == NULL ) {
        NetStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Convert DnsName and DnsForestName to UTF-8
    //

    DnsNameUtf8 = NetpAllocUtf8StrFromWStr( DnsName );
    if ( DnsNameUtf8 == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if ( DnsForestName != NULL ) {
        DnsForestNameUtf8 = NetpAllocUtf8StrFromWStr( DnsForestName );
        if ( DnsForestNameUtf8 == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    NetStatus = NetpDcGetDcOpen( DnsNameUtf8,
                              OptionFlags,
                              SiteName,
                              DomainGuid,
                              DnsForestNameUtf8,
                              DcFlags,
                              RetGetDcContext );
Cleanup:

    if ( DnsNameUtf8 != NULL ) {
        NetpMemoryFree( DnsNameUtf8 );
    }

    if ( DnsForestNameUtf8 != NULL ) {
        NetpMemoryFree( DnsForestNameUtf8 );
    }

    return NetStatus;
}

DWORD
WINAPI
DsGetDcOpenA(
    IN LPCSTR DnsName,
    IN ULONG OptionFlags,
    IN LPCSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR DnsForestName OPTIONAL,
    IN ULONG DcFlags,
    OUT PHANDLE RetGetDcContext
    )
/*++

Routine Description:

    Open a context for retrieval of the addresses of machines that have
    registered LDAP.TCP.<xxx> SRV records.

Arguments:

    DnsName - Unicode DNS name of the LDAP server to lookup

    OptionFlags - Flags affecting the operation of the routine.

        DS_ONLY_DO_SITE_NAME - Non-site names should be ignored.

        DS_NOTIFY_AFTER_SITE_RECORDS - Return ERROR_FILEMARK_DETECTED
            after all site specific records have been processed.

    SiteName - Name of site the client is in.

    DomainGuid -  Specifies the GUID of the domain specified by DnsName.
        This value is used to handle the case of domain renames.  If this
        value is specified and DomainName has been renamed, DsGetDcName will
        attempt to locate a DC in the domain having this specified DomainGuid.

    DnsForestName - Specifies the name of the domain at the root of the tree
        containing DnsName.  This value is used in conjunction with DomainGuid
        for finding DnsName if the domain has been renamed.

    DcFlags - Passes additional information to be used to process the request.
        DcFlags can be a combination values bitwise or'ed together.

        Any of the following flags are allowed and have the same meaning as
        for DsGetDcName:

        DS_PDC_REQUIRED
        DS_GC_SERVER_REQUIRED
        DS_WRITABLE_REQUIRED
        DS_FORCE_REDISCOVERY - Avoids DNS cache

        If no flags are specified, no special DC role is required.

    RetGetDcContext - Returns an opaque context.
        This context must be freed using DsGetDcClose.

Return Value:

    Status of the operation.

    NO_ERROR: GetDcContext was returned successfully.

--*/

{
    NET_API_STATUS NetStatus = NO_ERROR;
    LPWSTR DnsNameW = NULL;
    LPWSTR SiteNameW = NULL;
    LPWSTR DnsForestNameW = NULL;

    //
    // Convert DnsName and DnsForestName to UTF-8
    //

    if ( DnsName != NULL && *DnsName != '\0' ) {
        DnsNameW = NetpAllocWStrFromAStr( DnsName );
        if ( DnsNameW == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    if ( SiteName != NULL && *SiteName != '\0') {
        SiteNameW = NetpAllocWStrFromAStr( SiteName );
        if ( SiteNameW == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    if ( DnsForestName != NULL && *DnsForestName != '\0' ) {
        DnsForestNameW = NetpAllocWStrFromAStr( DnsForestName );
        if ( DnsForestNameW == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    NetStatus = DsGetDcOpenW( DnsNameW,
                              OptionFlags,
                              SiteNameW,
                              DomainGuid,
                              DnsForestNameW,
                              DcFlags,
                              RetGetDcContext );
Cleanup:

    if ( DnsNameW != NULL ) {
        NetApiBufferFree( DnsNameW );
    }

    if ( SiteNameW != NULL ) {
        NetApiBufferFree( SiteNameW );
    }

    if ( DnsForestNameW != NULL ) {
        NetApiBufferFree( DnsForestNameW );
    }

    return NetStatus;
}


DWORD
WINAPI
DsGetDcNextW(
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPWSTR *DnsHostName OPTIONAL
    )
/*++

Routine Description:

    Returns the next logical SRV record for the name opened by DsGetDcOpen.
    The returned record takes into account the weights and priorities specified
    in the SRV records.

Arguments:

    GetDcContextHandle - An opaque context describing the SRV records.

    SockAddressCount - Returns the number of Addresses in SockAddresses.
        If NULL, addresses will not be looked up.

    SockAddresses - Returns an array SOCKET_ADDRESS structures for the server.
        All returned addresses will be of family AF_INET or AF_INET6.
        The returned sin_port field contains port from the SRV record.
            A Port of 0 indicate no port is available from DNS.
        This buffer should be freed using LocalFree().

    DnsHostName - Returns a pointer to the DnsHostName in the SRV record.
        A NULL is returned if no host name is known. Must be freed by
        calling NetApiBufferFree.

Return Value:

    NO_ERROR: Addresses were returned

    ERROR_NO_MORE_ITEMS: No more addresses are available.

    ERROR_FILEMARK_DETECTED: Caller has specified the DS_NOTIFY_AFTER_SITE_RECORDS flag
        and DsGetDcNext has processed all of the site specific SRV records.  The caller
        should take any action based on no site specific DCs being available, then
        should call DsGetDcNext to continue on to other DCs.

    Any other errors returned are those detected while trying to find the A
        records associated with the host of the SRV record.  The caller can
        note the error (perhaps so the caller can return this status to
        his caller if no usefull server is found) then call DsGetDcNext
        again to get the next SRV record.  The caller can inspect this error
        and return immediately if the caller deems the error serious.

    The following interesting errors might be returned:

    DNS_ERROR_RCODE_NAME_ERROR: No A records are available for this SRV record.

    ERROR_TIMEOUT: DNS server didn't respond in a reasonable time

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    LPSTR DnsHostNameUtf8 = NULL;
    LPWSTR LocalDnsHostName = NULL;
    ULONG LocalSockAddressCount = 0;
    LPSOCKET_ADDRESS LocalSockAddresses = NULL;

    //
    // Call the internal version
    //

    NetStatus = NetpDcGetDcNext( GetDcContextHandle,
                              SockAddressCount != NULL ?
                                &LocalSockAddressCount :
                                NULL,
                              SockAddresses != NULL ?
                                &LocalSockAddresses :
                                NULL,
                              DnsHostName != NULL ?
                                &DnsHostNameUtf8 :
                                NULL );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the host name to Unicode, if needed
    //

    if ( DnsHostName != NULL ) {
        LocalDnsHostName = NetpAllocWStrFromUtf8Str( DnsHostNameUtf8 );
        if ( LocalDnsHostName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

Cleanup:

    //
    // Return the data on success or clean up on error
    //  (No need to free DnsHostNameUtf8 as it isn't allocated)
    //

    if ( NetStatus == NO_ERROR ) {

        if ( SockAddressCount != NULL ) {
            *SockAddressCount = LocalSockAddressCount;
        }
        if ( SockAddresses != NULL ) {
            *SockAddresses = LocalSockAddresses;
        }
        if ( DnsHostName != NULL ) {
            *DnsHostName = LocalDnsHostName;
        }

    } else {

        if ( LocalSockAddresses != NULL ) {
            LocalFree( LocalSockAddresses );
        }
        if ( LocalDnsHostName != NULL ) {
            NetApiBufferFree( LocalDnsHostName );
        }
    }

    return NetStatus;
}

DWORD
WINAPI
DsGetDcNextA(
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPSTR *DnsHostName OPTIONAL
    )
/*++

Routine Description:

    Returns the next logical SRV record for the name opened by DsGetDcOpen.
    The returned record takes into account the weights and priorities specified
    in the SRV records.

Arguments:

    GetDcContextHandle - An opaque context describing the SRV records.

    SockAddressCount - Returns the number of Addresses in SockAddresses.
        If NULL, addresses will not be looked up.

    SockAddresses - Returns an array SOCKET_ADDRESS structures for the server.
        All returned addresses will be of family AF_INET or AF_INET6.
        The returned sin_port field contains port from the SRV record.
            A Port of 0 indicate no port is available from DNS.
        This buffer should be freed using LocalFree().

    DnsHostName - Returns a pointer to the DnsHostName in the SRV record.
        A NULL is returned if no host name is known. Must be freed by
        calling NetApiBufferFree.

Return Value:

    NO_ERROR: Addresses were returned

    ERROR_NO_MORE_ITEMS: No more addresses are available.

    ERROR_FILEMARK_DETECTED: Caller has specified the DS_NOTIFY_AFTER_SITE_RECORDS flag
        and DsGetDcNext has processed all of the site specific SRV records.  The caller
        should take any action based on no site specific DCs being available, then
        should call DsGetDcNext to continue on to other DCs.

    Any other errors returned are those detected while trying to find the A
        records associated with the host of the SRV record.  The caller can
        note the error (perhaps so the caller can return this status to
        his caller if no usefull server is found) then call DsGetDcNext
        again to get the next SRV record.  The caller can inspect this error
        and return immediately if the caller deems the error serious.

    The following interesting errors might be returned:

    DNS_ERROR_RCODE_NAME_ERROR: No A records are available for this SRV record.

    ERROR_TIMEOUT: DNS server didn't respond in a reasonable time

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    LPWSTR DnsHostNameW = NULL;
    LPSTR LocalDnsHostName = NULL;
    ULONG LocalSockAddressCount = 0;
    LPSOCKET_ADDRESS LocalSockAddresses = NULL;

    //
    // Call the Unicode version
    //

    NetStatus = DsGetDcNextW( GetDcContextHandle,
                              SockAddressCount != NULL ?
                                &LocalSockAddressCount :
                                NULL,
                              SockAddresses != NULL ?
                                &LocalSockAddresses :
                                NULL,
                              DnsHostName != NULL ?
                                &DnsHostNameW :
                                NULL );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the host name to Unicode, if needed
    //

    if ( DnsHostName != NULL ) {
        LocalDnsHostName = NetpAllocAStrFromWStr( DnsHostNameW );
        if ( LocalDnsHostName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

Cleanup:

    if ( DnsHostNameW != NULL ) {
        NetApiBufferFree( DnsHostNameW );
    }

    //
    // Return the data on success or clean up on error
    //

    if ( NetStatus == NO_ERROR ) {

        if ( SockAddressCount != NULL ) {
            *SockAddressCount = LocalSockAddressCount;
        }
        if ( SockAddresses != NULL ) {
            *SockAddresses = LocalSockAddresses;
        }
        if ( DnsHostName != NULL ) {
            *DnsHostName = LocalDnsHostName;
        }

    } else {

        if ( LocalSockAddresses != NULL ) {
            LocalFree( LocalSockAddresses );
        }
        if ( LocalDnsHostName != NULL ) {
            NetApiBufferFree( LocalDnsHostName );
        }
    }

    return NetStatus;
}

VOID
WINAPI
DsGetDcCloseW(
    IN HANDLE GetDcContextHandle
    )
/*++

Routine Description:

    Free the context allocated by DsGetDcOpen

Arguments:

    GetDcContextHandle - An opaque context describing the SRV records.

Return Value:

    None

--*/

{
    //
    // Just call the internal version
    //
    NetpDcGetDcClose( GetDcContextHandle );
}

DWORD
WINAPI
DsGetDcNameA(
    IN LPCSTR ComputerName OPTIONAL,
    IN LPCSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOA *DomainControllerInfo
)
/*++

Routine Description:

    Same as DsGetDcNameW except it takes and returns ASCII.

Arguments:

    Same as DsGetDcNameW except it takes and returns ASCII.

Return Value:

    Same as DsGetDcNameW except it takes and returns ASCII.

--*/
{
    return DsGetDcNameWithAccountA( ComputerName,
                         NULL,
                         0,
                         DomainName,
                         DomainGuid,
                         SiteName,
                         Flags,
                         DomainControllerInfo );
}

DWORD
WINAPI
DsGetDcNameWithAccountA(
    IN LPCSTR ComputerName OPTIONAL,
    IN LPCSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOA *DomainControllerInfo
)
/*++

Routine Description:

    Same as DsGetDcNameW except it takes and returns ASCII.

Arguments:

    Same as DsGetDcNameW except it takes and returns ASCII.

Return Value:

    Same as DsGetDcNameW except it takes and returns ASCII.

--*/
{
    DWORD WinStatus;
    LPWSTR UnicodeComputerName = NULL;
    LPWSTR UnicodeAccountName = NULL;
    LPWSTR UnicodeDomainName = NULL;
    LPWSTR UnicodeSiteName = NULL;

    LPSTR AnsiDomainControllerName = NULL;
    ULONG AnsiDomainControllerNameSize = 0;
    LPSTR AnsiDomainControllerAddress = NULL;
    ULONG AnsiDomainControllerAddressSize = 0;
    LPSTR AnsiDomainName = NULL;
    ULONG AnsiDomainNameSize = 0;
    LPSTR AnsiForestName = NULL;
    ULONG AnsiForestNameSize = 0;
    LPSTR AnsiDcSiteName = NULL;
    ULONG AnsiDcSiteNameSize = 0;
    LPSTR AnsiClientSiteName = NULL;
    ULONG AnsiClientSiteNameSize = 0;
    CHAR szBuf[] = "";

    LPBYTE Where;

    PDOMAIN_CONTROLLER_INFOW DomainControllerInfoW = NULL;

    //
    // Convert input parameters to Unicode.
    //

    *DomainControllerInfo = NULL;

    if ( ComputerName != NULL ) {
        UnicodeComputerName = NetpAllocWStrFromAStr( ComputerName );

        if ( UnicodeComputerName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    if ( AccountName != NULL ) {
        UnicodeAccountName = NetpAllocWStrFromAStr( AccountName );

        if ( UnicodeAccountName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    if ( DomainName != NULL ) {
        UnicodeDomainName = NetpAllocWStrFromAStr( DomainName );

        if ( UnicodeDomainName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    if ( SiteName != NULL ) {
        UnicodeSiteName = NetpAllocWStrFromAStr( SiteName );

        if ( UnicodeSiteName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Call the Unicode version of the routine.
    //

    WinStatus = DsGetDcNameWithAccountW(
                    UnicodeComputerName,
                    UnicodeAccountName,
                    AllowableAccountControlBits,
                    UnicodeDomainName,
                    DomainGuid,
                    UnicodeSiteName,
                    Flags,
                    &DomainControllerInfoW );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the output structure to Ansi character set.
    //

    if ( DomainControllerInfoW->DomainControllerName != NULL ) {
        AnsiDomainControllerName = NetpAllocAStrFromWStr( DomainControllerInfoW->DomainControllerName );

        if ( AnsiDomainControllerName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        AnsiDomainControllerNameSize = lstrlenA( AnsiDomainControllerName ) + 1;
    }

    if ( DomainControllerInfoW->DomainControllerAddress != NULL ) {
        AnsiDomainControllerAddress = NetpAllocAStrFromWStr( DomainControllerInfoW->DomainControllerAddress );

        if ( AnsiDomainControllerAddress == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        AnsiDomainControllerAddressSize = lstrlenA( AnsiDomainControllerAddress ) + 1;
    }

    if ( DomainControllerInfoW->DomainName != NULL ) {
        AnsiDomainName = NetpAllocAStrFromWStr( DomainControllerInfoW->DomainName );

        if ( AnsiDomainName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        AnsiDomainNameSize = lstrlenA( AnsiDomainName ) + 1;
    }

    if ( DomainControllerInfoW->DnsForestName != NULL ) {
        AnsiForestName = NetpAllocAStrFromWStr( DomainControllerInfoW->DnsForestName );

        if ( AnsiForestName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        AnsiForestNameSize = lstrlenA( AnsiForestName ) + 1;
    }

    if ( DomainControllerInfoW->DcSiteName != NULL ) {
        AnsiDcSiteName = NetpAllocAStrFromWStr( DomainControllerInfoW->DcSiteName );

        if ( AnsiDcSiteName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        AnsiDcSiteNameSize = lstrlenA( AnsiDcSiteName ) + 1;
    }

    if ( DomainControllerInfoW->ClientSiteName != NULL ) {
        AnsiClientSiteName = NetpAllocAStrFromWStr( DomainControllerInfoW->ClientSiteName );

        if ( AnsiClientSiteName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        AnsiClientSiteNameSize = lstrlenA( AnsiClientSiteName ) + 1;
    }

    //
    // Allocate the Ansi version of the structure.
    //

    WinStatus = NetApiBufferAllocate(
                    sizeof(DOMAIN_CONTROLLER_INFOA) +
                        AnsiDomainControllerNameSize +
                        AnsiDomainControllerAddressSize +
                        AnsiDomainNameSize +
                        AnsiForestNameSize +
                        AnsiDcSiteNameSize +
                        AnsiClientSiteNameSize,
                    DomainControllerInfo );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    Where = (LPBYTE)((*DomainControllerInfo) + 1);

    //
    // Copy information into the allocated buffer.
    //

    *(*DomainControllerInfo) = *(PDOMAIN_CONTROLLER_INFOA)DomainControllerInfoW;

    if ( AnsiDomainControllerName != NULL ) {
        (*DomainControllerInfo)->DomainControllerName = Where;
        RtlCopyMemory( Where,
                       AnsiDomainControllerName,
                       AnsiDomainControllerNameSize );
        Where += AnsiDomainControllerNameSize;
    }

    if ( AnsiDomainControllerAddress != NULL ) {
        (*DomainControllerInfo)->DomainControllerAddress = Where;
        RtlCopyMemory( Where,
                       AnsiDomainControllerAddress,
                       AnsiDomainControllerAddressSize );
        Where += AnsiDomainControllerAddressSize;
    }

    if ( AnsiDomainName != NULL ) {
        (*DomainControllerInfo)->DomainName = Where;
        RtlCopyMemory( Where,
                       AnsiDomainName,
                       AnsiDomainNameSize );
        Where += AnsiDomainNameSize;
    }

    if ( AnsiForestName != NULL ) {
        (*DomainControllerInfo)->DnsForestName = Where;
        RtlCopyMemory( Where,
                       AnsiForestName,
                       AnsiForestNameSize );
        Where += AnsiForestNameSize;
    }

    if ( AnsiDcSiteName != NULL ) {
        (*DomainControllerInfo)->DcSiteName = Where;
        RtlCopyMemory( Where,
                       AnsiDcSiteName,
                       AnsiDcSiteNameSize );
        Where += AnsiDcSiteNameSize;
    }

    if ( AnsiClientSiteName != NULL ) {
        (*DomainControllerInfo)->ClientSiteName = Where;
        RtlCopyMemory( Where,
                       AnsiClientSiteName,
                       AnsiClientSiteNameSize );
        Where += AnsiClientSiteNameSize;
    }

#ifdef WIN32_CHICAGO
    NlPrint((NL_MISC, "DomainControllerName: \t\t\"%s\"\n", AnsiDomainControllerName  ? AnsiDomainControllerName : szBuf));
    NlPrint((NL_MISC, "DomainControllerAddress:\t\t\"%s\"\n", AnsiDomainControllerAddress ? AnsiDomainControllerAddress : szBuf ));
    NlPrint((NL_MISC, "DomainControllerAddressType: \t%d\n", DomainControllerInfoW->DomainControllerAddressType ));
    NlPrint((NL_MISC, "DomainGuid : \t\n"));
    NlPrint((NL_MISC, "DomainName: \t\t\t\"%s\"\n", AnsiDomainName ? AnsiDomainName : szBuf));
    NlPrint((NL_MISC, "DnsForestName: \t\t\t\"%s\"\n", AnsiForestName ? AnsiForestName : szBuf));
    NlPrint((NL_MISC, "Flags: \t\t\t\t 0x%x\n", DomainControllerInfoW->Flags));
    NlPrint((NL_MISC, "DcSiteName: \t\t\t\"%s\"\n", AnsiDcSiteName ? AnsiDcSiteName : szBuf));
    NlPrint((NL_MISC, "ClientSiteName: \t\t\t\"%s\"\n", AnsiClientSiteName ? AnsiClientSiteName : szBuf));
#endif // WIN32_CHICAGO

    WinStatus = NO_ERROR;

    //
    // Clean up locally used resources.
    //

Cleanup:
    if ( UnicodeComputerName != NULL ) {
        NetApiBufferFree( UnicodeComputerName );
    }
    if ( UnicodeAccountName != NULL ) {
        NetApiBufferFree( UnicodeAccountName );
    }
    if ( UnicodeDomainName != NULL ) {
        NetApiBufferFree( UnicodeDomainName );
    }
    if ( UnicodeSiteName != NULL ) {
        NetApiBufferFree( UnicodeSiteName );
    }
    if ( DomainControllerInfoW != NULL ) {
        NetApiBufferFree( DomainControllerInfoW );
    }
    if ( AnsiDomainControllerName != NULL ) {
        NetApiBufferFree( AnsiDomainControllerName );
    }
    if ( AnsiDomainControllerAddress != NULL ) {
        NetApiBufferFree( AnsiDomainControllerAddress );
    }
    if ( AnsiDomainName != NULL ) {
        NetApiBufferFree( AnsiDomainName );
    }
    if ( AnsiForestName != NULL ) {
        NetApiBufferFree( AnsiForestName );
    }
    if ( AnsiDcSiteName != NULL ) {
        NetApiBufferFree( AnsiDcSiteName );
    }
    if ( AnsiClientSiteName != NULL ) {
        NetApiBufferFree( AnsiClientSiteName );
    }
    if ( WinStatus != NO_ERROR ) {
        if ( *DomainControllerInfo != NULL ) {
            NetApiBufferFree( *DomainControllerInfo );
            *DomainControllerInfo = NULL;
        }
    }

    return WinStatus;

}

#ifndef WIN32_CHICAGO

NTSTATUS
NlWaitForEvent(
    LPWSTR EventName,
    ULONG Timeout
    )

/*++

Routine Description:

    Wait up to Timeout seconds for EventName to be triggered.

Arguments:

    EventName - Name of event to wait on

    Timeout - Timeout for event (in seconds).

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
    STATUS_NETLOGON_NOT_STARTED - Timeout occurred.

--*/

{
    NTSTATUS Status;

    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventNameString;
    LARGE_INTEGER LocalTimeout;


    //
    // Create an event for us to wait on.
    //

    RtlInitUnicodeString( &EventNameString, EventName);
    InitializeObjectAttributes( &EventAttributes, &EventNameString, 0, 0, NULL);

    Status = NtCreateEvent(
                   &EventHandle,
                   SYNCHRONIZE,
                   &EventAttributes,
                   NotificationEvent,
                   (BOOLEAN) FALSE      // The event is initially not signaled
                   );

    if ( !NT_SUCCESS(Status)) {

        //
        // If the event already exists, the server beat us to creating it.
        // Just open it.
        //

        if( Status == STATUS_OBJECT_NAME_EXISTS ||
            Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = NtOpenEvent( &EventHandle,
                                  SYNCHRONIZE,
                                  &EventAttributes );

        }
        if ( !NT_SUCCESS(Status)) {
            NlPrint((0,"[NETAPI32] OpenEvent failed %lx\n", Status ));
            return Status;
        }
    }


    //
    // Wait for NETLOGON to initialize.  Wait a maximum of Timeout seconds.
    //

    LocalTimeout.QuadPart = ((LONGLONG)(Timeout)) * (-10000000);
    Status = NtWaitForSingleObject( EventHandle, (BOOLEAN)FALSE, &LocalTimeout);
    (VOID) NtClose( EventHandle );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        if ( Status == STATUS_TIMEOUT ) {
            Status = STATUS_NETLOGON_NOT_STARTED;   // Map to an error condition
        }
        return Status;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
NlWaitForNetlogon(
    ULONG Timeout
    )

/*++

Routine Description:

    Wait up to Timeout seconds for the netlogon service to start.

Arguments:

    Timeout - Timeout for event (in seconds).

Return Status:

    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
    STATUS_NETLOGON_NOT_STARTED - Timeout occurred.

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    LPQUERY_SERVICE_CONFIG AllocServiceConfig = NULL;
    QUERY_SERVICE_CONFIG DummyServiceConfig;
    DWORD ServiceConfigSize;

    //
    // If the netlogon service is currently running,
    //  skip the rest of the tests.
    //

    Status = NlWaitForEvent( L"\\NETLOGON_SERVICE_STARTED", 0 );

    if ( NT_SUCCESS(Status) ) {
        return Status;
    }

    //
    // If we're in setup,
    //  don't bother waiting for netlogon to start.
    //

    if ( NlDoingSetup() ) {
        return STATUS_NETLOGON_NOT_STARTED;
    }

    //
    // Open a handle to the Netlogon Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        NlPrint((0, "[NETAPI32] NlWaitForNetlogon: OpenSCManager failed: "
                      "%lu\n", GetLastError()));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        SERVICE_NETLOGON,
                        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        NlPrint((0, "[NETAPI32] NlWaitForNetlogon: OpenService failed: "
                      "%lu\n", GetLastError()));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }


    //
    // If the Netlogon service isn't configured to be automatically started
    //  by the service controller, don't bother waiting for it to start.
    //
    // ?? Pass "DummyServiceConfig" and "sizeof(..)" since QueryService config
    //  won't allow a null pointer, yet.

    if ( QueryServiceConfig(
            ServiceHandle,
            &DummyServiceConfig,
            sizeof(DummyServiceConfig),
            &ServiceConfigSize )) {

        ServiceConfig = &DummyServiceConfig;

    } else {

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_INSUFFICIENT_BUFFER ) {
            NlPrint((0, "[NETAPI32] NlWaitForNetlogon: QueryServiceConfig failed: "
                      "%lu\n", NetStatus));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        AllocServiceConfig = LocalAlloc( 0, ServiceConfigSize );
        ServiceConfig = AllocServiceConfig;

        if ( AllocServiceConfig == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !QueryServiceConfig(
                ServiceHandle,
                ServiceConfig,
                ServiceConfigSize,
                &ServiceConfigSize )) {

            NlPrint((0, "[NETAPI32] NlWaitForNetlogon: QueryServiceConfig "
                      "failed again: %lu\n", GetLastError()));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }
    }

    if ( ServiceConfig->dwStartType != SERVICE_AUTO_START ) {
        NlPrint((0, "[NETAPI32] NlWaitForNetlogon: Netlogon start type invalid:"
                          "%lu\n", ServiceConfig->dwStartType ));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }



    //
    // Loop waiting for the netlogon service to start.
    //  (Convert Timeout to a number of 10 second iterations)
    //

    Timeout = (Timeout+9)/10;
    for (;;) {


        //
        // Query the status of the Netlogon service.
        //

        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

            NlPrint((0, "[NETAPI32] NlWaitForNetlogon: QueryServiceStatus failed: "
                          "%lu\n", GetLastError() ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the netlogon service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            Status = STATUS_SUCCESS;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If Netlogon failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){
#if NETLOGONDBG
                NlPrint((0, "[NETAPI32] NlWaitForNetlogon: "
                          "Netlogon service couldn't start: %lu %lx\n",
                          ServiceStatus.dwWin32ExitCode,
                          ServiceStatus.dwWin32ExitCode ));
                if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
                    NlPrint((0, "         Service specific error code: %lu %lx\n",
                              ServiceStatus.dwServiceSpecificExitCode,
                              ServiceStatus.dwServiceSpecificExitCode ));
                }
#endif // DBG
                Status = STATUS_NETLOGON_NOT_STARTED;
                goto Cleanup;
            }

            //
            // If Netlogon has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If Netlogon is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
            NlPrint((0, "[NETAPI32] NlWaitForNetlogon: "
                      "Invalid service state: %lu\n",
                      ServiceStatus.dwCurrentState ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;

        }


        //
        // Wait ten seconds for the netlogon service to start.
        //  If it has successfully started, just return now.
        //

        Status = NlWaitForEvent( L"\\NETLOGON_SERVICE_STARTED", 10 );

        if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
            goto Cleanup;
        }

        //
        // If we've waited long enough for netlogon to start,
        //  time out now.
        //

        if ( (--Timeout) == 0 ) {
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }


    }

    /* NOT REACHED */

Cleanup:
    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }
    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }
    if ( AllocServiceConfig != NULL ) {
        LocalFree( AllocServiceConfig );
    }
    return Status;
}
#endif // WIN32_CHICAGO



DWORD
WINAPI
#ifdef NETTEST_UTILITY
NettestDsGetDcNameW(
#else // NETTEST_UTILITY
DsGetDcNameW(
#endif // NETTEST_UTILITY
        IN LPCWSTR ComputerName OPTIONAL,
        IN LPCWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN LPCWSTR SiteName OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    The DsGetDcName API returns the name of a DC in a specified domain.
    The domain may be trusted (directly or indirectly) by the caller or
    may be untrusted.  DC selection criteria are supplied to the API to
    indicate preference for a DC with particular characteristics.

    The DsGetDcName API is available in an ANSI and UNICODE versions.
    This is the Unicode version.

    The DsGetDcName API does not require any particular access to the
    specified domain.  DsGetDcName does not ensure the returned domain
    controller is currently available by default.  Rather, the caller
    should attempt to use the returned domain controller.  If the domain
    controller is indeed not available, the caller should repeat the
    DsGetDcName call specifying the DS_FORCE_REDISCOVERY flag.

    The DsGetDcName API is remoted to the Netlogon service on the machine
    specified by ComputerName.

Arguments:

    ComputerName - Specifies the name of the server to remote this API to.
        Typically, this parameter should be specified as NULL.

    DomainName - The name of the domain to query.  This name can either be a
        DNS-style name (e.g., microsoft.com) or a flat-style name
        (e.g., microsoft).

    DomainGuid - Specifies the Domain GUID of the domain being queried.
        This value is used to handle the case of domain renames.  If this
        value is specified and DomainName has been renamed, DsGetDcName will
        attempt to locate a DC in the domain having this specified DomainGuid.

    SiteName - Specifies the site name of the site the returned DC should be
        "close" to.  The parameter should typically be the site name of the
        site the client is in.  If not specified, the site name defaults to
        the site of ComputerName.

    Flags - Passes additional information to be used to process the request.
        Flags can be a combination values bitwise or'ed together.

    DomainControllerInfo - Returns a pointer to a DOMAIN_CONTROLLER_INFO
        structure describing the domain controller selected.  The returned
        structure must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

    ERROR_INVALID_DOMAINNAME - The format of the specified domain name is
        invalid.

    ERROR_NO_SUCH_DOMAIN: No DC is available for the specified domain or
        the domain does not exist.

    ERROR_NO_SUCH_USER: A DC responded that the specified user account
        doesn't exist

    ERROR_INVALID_FLAGS - The flags parameter has conflicting or superfluous
        bits set.

    ERROR_INTERNAL_ERROR: Unhandled situation detected.

    Various Winsock errors.

--*/
{
    NET_API_STATUS NetStatus;

    return DsGetDcNameWithAccountW(
                    ComputerName,
                    NULL,   // no AccountName,
                    0,      // no AllowableAccountControlBits,
                    DomainName,
                    DomainGuid,
                    SiteName,
                    Flags,
                    DomainControllerInfo );
}



DWORD
WINAPI
DsGetDcNameWithAccountW(
        IN LPCWSTR ComputerName OPTIONAL,
        IN LPCWSTR AccountName OPTIONAL,
        IN ULONG AllowableAccountControlBits,
        IN LPCWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN LPCWSTR SiteName OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    The DsGetDcName API returns the name of a DC in a specified domain.
    The domain may be trusted (directly or indirectly) by the caller or
    may be untrusted.  DC selection criteria are supplied to the API to
    indicate preference for a DC with particular characteristics.

    The DsGetDcName API is available in an ANSI and UNICODE versions.
    This is the Unicode version.

    The DsGetDcName API does not require any particular access to the
    specified domain.  DsGetDcName does not ensure the returned domain
    controller is currently available by default.  Rather, the caller
    should attempt to use the returned domain controller.  If the domain
    controller is indeed not available, the caller should repeat the
    DsGetDcName call specifying the DS_FORCE_REDISCOVERY flag.

    The DsGetDcName API is remoted to the Netlogon service on the machine
    specified by ComputerName.

Arguments:

    ComputerName - Specifies the name of the server to remote this API to.
        Typically, this parameter should be specified as NULL.

    AccountName - Account name to pass on the ping request.
        If NULL, no account name will be sent.

    AllowableAccountControlBits - Mask of allowable account types for AccountName.
        Valid bits are those specified by UF_MACHINE_ACCOUNT_MASK.
        Invalid bits are ignored.  If more than one bit is specified, the
        account can be of any of the specified types.

    DomainName - The name of the domain to query.  This name can either be a
        DNS-style name (e.g., microsoft.com) or a flat-style name
        (e.g., microsoft).

    DomainGuid - Specifies the Domain GUID of the domain being queried.
        This value is used to handle the case of domain renames.  If this
        value is specified and DomainName has been renamed, DsGetDcName will
        attempt to locate a DC in the domain having this specified DomainGuid.

    SiteName - Specifies the site name of the site the returned DC should be
        "close" to.  The parameter should typically be the site name of the
        site the client is in.  If not specified, the site name defaults to
        the site of ComputerName.

    Flags - Passes additional information to be used to process the request.
        Flags can be a combination values bitwise or'ed together.

    DomainControllerInfo - Returns a pointer to a DOMAIN_CONTROLLER_INFO
        structure describing the domain controller selected.  The returned
        structure must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

    ERROR_INVALID_DOMAINNAME - The format of the specified domain name is
        invalid.

    ERROR_NO_SUCH_DOMAIN: No DC is available for the specified domain or
        the domain does not exist.

    ERROR_NO_SUCH_USER: A DC responded that the specified user account
        doesn't exist

    ERROR_INVALID_FLAGS - The flags parameter has conflicting or superfluous
        bits set.

    ERROR_INTERNAL_ERROR: Unhandled situation detected.

    Various Winsock errors.

--*/
{
    NET_API_STATUS NetStatus;

    GUID *PrimaryDomainGuid = NULL;
    LPWSTR NetbiosPrimaryDomainName = NULL;
    LPWSTR DnsPrimaryDomainName = NULL;
    LPWSTR DnsPrimaryForestName = NULL;
    BOOLEAN IsWorkgroupName;
    BOOLEAN Local;


    //
    // Determine the PrimaryDomainName
    //

#ifdef WIN32_CHICAGO
    NetStatus = NetpGetDomainNameExEx( &NetbiosPrimaryDomainName,
                                       &DnsPrimaryDomainName,
                                       &IsWorkgroupName );
#else // WIN32_CHICAGO
    NetStatus = NetpGetDomainNameExExEx( &NetbiosPrimaryDomainName,
                                         &DnsPrimaryDomainName,
                                         &DnsPrimaryForestName,
                                         &PrimaryDomainGuid,
                                         &IsWorkgroupName );
#endif // WIN32_CHICAGO

    if ( NetStatus != NERR_Success ) {
        NlPrint(( 0, "DsGetDcNameW: cannot call NetpGetDomainName: %ld\n",
                          NetStatus));
        goto Cleanup;
    }
#ifdef WIN32_CHICAGO
    IsWorkgroupName = TRUE;
#endif // WIN32_CHICAGO
#ifdef NETTEST_UTILITY
    IsWorkgroupName = TRUE;
#endif // NETTEST_UTILITY

    //
    // Sanity check the domain name since LSA doesn't and I'll AV below
    //

    if ( NetbiosPrimaryDomainName != NULL &&
         wcslen( NetbiosPrimaryDomainName) > DNLEN ) {
        NlPrint(( 0, "DsGetDcNameW: Workgroup name is too long: %ld\n",
                     wcslen( NetbiosPrimaryDomainName ) ));
        NetStatus = ERROR_INVALID_DOMAINNAME;
        goto Cleanup;
    }



    //
    // If this machine is a member of a workgroup (not a domain),
    //  and the API isn't remoted,
    //  do the algorithm here.
    //  Netlogon isn't running on this machine.
    //

    if ( IsWorkgroupName ) {
        DWORD Timeout = NL_DC_MAX_TIMEOUT;   // 15 seconds
        DWORD DialUpDelayInSeconds;

        //
        // Read the dial up delay from the registry. Add it to the
        // maximum DC discovery timeout to account for dial up
        // connections. If the value cannot be read, ignore it.
        //

        if ( NlReadDwordNetlogonRegValue("ExpectedDialupDelay",
                                         &DialUpDelayInSeconds) ) {
            NlPrint(( 0, "DsGetDcNameWithAccountW: Read dial up delay of %ld seconds\n",
                      DialUpDelayInSeconds ));
            Timeout += DialUpDelayInSeconds * 1000;
        }

        NetStatus = DsLocalGetDcName(
                        ComputerName,
                        AccountName,
                        AllowableAccountControlBits,
                        DomainName,
                        DomainGuid,
                        SiteName,
                        Flags,
                        DS_PRIMARY_NAME_IS_WORKGROUP,
                        Timeout,
                        NetbiosPrimaryDomainName,
                        DnsPrimaryDomainName,
                        DnsPrimaryForestName,
                        PrimaryDomainGuid,
                        &Local,
                        DomainControllerInfo );

        //
        // If the call was performed locally,
        //   We're all done regardless of the status.
        //

        if ( Local ) {
            goto Cleanup;
        }

    }

#ifndef NETTEST_UTILITY
#ifndef WIN32_CHICAGO
    //
    // Remote the API to the Netlogon service.
    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {
        //
        // Call RPC version of the API.
        //

        *DomainControllerInfo = NULL;  // Force RPC to allocate

        NetStatus = DsrGetDcNameEx2(
                            (LPWSTR) ComputerName,
                            (LPWSTR) AccountName,
                            AllowableAccountControlBits,
                            (LPWSTR) DomainName,
                            DomainGuid,
                            (LPWSTR) SiteName,
                            Flags,
                            DomainControllerInfo );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // If the netlogon service isn't running,
    //  and it's in the process of starting,
    //  wait for it to start.
    //

    if ( NetStatus == RPC_S_UNKNOWN_IF ) {
        NTSTATUS TempStatus;

        TempStatus = NlWaitForNetlogon( 90 );


        if ( NT_SUCCESS(TempStatus) ) {

            RpcTryExcept {
                //
                // Call RPC version of the API.
                //

                *DomainControllerInfo = NULL;  // Force RPC to allocate

                NetStatus = DsrGetDcNameEx2(
                                    (LPWSTR) ComputerName,
                                    (LPWSTR) AccountName,
                                    AllowableAccountControlBits,
                                    (LPWSTR) DomainName,
                                    DomainGuid,
                                    (LPWSTR) SiteName,
                                    Flags,
                                    DomainControllerInfo );

            } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

                NetStatus = RpcExceptionCode();

            } RpcEndExcept;
        }
    }

    //
    // If Netlogon isn't running on the local machine,
    //  or Netlogon is the NT 4.0 version of netlogon (the upgrade case),
    //  try doing the call in-process.
    //

    if ( NetStatus == RPC_S_UNKNOWN_IF ||
         NetStatus == RPC_S_PROCNUM_OUT_OF_RANGE ) {
        NET_API_STATUS TempStatus;
        DWORD Timeout = NL_DC_MAX_TIMEOUT;   // 15 seconds
        DWORD DialUpDelayInSeconds;

        //
        // Read the dial up delay from the registry. Add it to the
        // maximum DC discovery timeout to account for dial up
        // connections. If the value cannot be read, ignore it.
        //

        if ( NlReadDwordNetlogonRegValue("ExpectedDialupDelay",
                                         &DialUpDelayInSeconds) ) {
            NlPrint(( 0, "DsGetDcNameWithAccountW: Read dial up delay of %ld seconds\n",
                      DialUpDelayInSeconds ));
            Timeout += DialUpDelayInSeconds * 1000;
        }

        TempStatus = DsLocalGetDcName(
                        ComputerName,
                        AccountName,
                        AllowableAccountControlBits,
                        DomainName,
                        DomainGuid,
                        SiteName,
                        Flags,
                        IsWorkgroupName ?
                            DS_PRIMARY_NAME_IS_WORKGROUP : 0,
                        Timeout,
                        NetbiosPrimaryDomainName,
                        DnsPrimaryDomainName,
                        DnsPrimaryForestName,
                        PrimaryDomainGuid,
                        &Local,
                        DomainControllerInfo );

        //
        // If the call was performed locally,
        //   We're all done regardless of the status.
        //

        if ( Local ) {
            NetStatus = TempStatus;
            goto Cleanup;
        }

    }
#endif // WIN32_CHICAGO
#endif // NETTEST_UTILITY

    IF_DEBUG( LOGON ) {
#ifndef WIN32_CHICAGO
        NetpKdPrint(("DsrGetDcName rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
#else // WIN32_CHICAGO
        NlPrint((0, "DsrGetDcName rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
#endif // WIN32_CHICAGO
    }

Cleanup:

    //
    // Cleanup all locally used resources
    //

    if ( NetbiosPrimaryDomainName != NULL ) {
        NetApiBufferFree( NetbiosPrimaryDomainName );
    }

    if ( DnsPrimaryDomainName != NULL ) {
        NetApiBufferFree( DnsPrimaryDomainName );
    }

    if ( DnsPrimaryForestName != NULL ) {
        NetApiBufferFree( DnsPrimaryForestName );
    }

    if ( PrimaryDomainGuid != NULL ) {
        NetApiBufferFree( PrimaryDomainGuid );
    }
#ifdef WIN32_CHICAGO
        NlPrint((NL_MISC, "DsGetDcNameWithAccountW rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
#endif // WIN32_CHICAGO

    return NetStatus;
}

#ifndef NETTEST_UTILITY
#ifndef WIN32_CHICAGO

NET_API_STATUS NET_API_FUNCTION
NetGetDCName (
    IN  LPCWSTR   ServerName OPTIONAL,
    IN  LPCWSTR   DomainName OPTIONAL,
    OUT LPBYTE  *Buffer
    )

/*++

Routine Description:

    Get the name of the primary domain controller for a domain.

Arguments:

    ServerName - name of remote server (null for local)

    DomainName - name of domain (null for primary)

    Buffer - Returns a pointer to an allcated buffer containing the
        servername of the PDC of the domain.  The server name is prefixed
        by \\.  The buffer should be deallocated using NetApiBufferFree.

Return Value:

        NERR_Success - Success.  Buffer contains PDC name prefixed by \\.
        NERR_DCNotFound     No DC found for this domain.
        ERROR_INVALID_NAME  Badly formed domain name

--*/
{
    NET_API_STATUS NetStatus = 0;
    PDOMAIN_CONTROLLER_INFOW DomainControllerInfo = NULL;


    //
    // API SECURITY - Anyone can call anytime.  No code required.
    //

    //
    // Check if API is to be remoted, and handle downlevel case if so.
    //

    if ( (ServerName != NULL) && ( ServerName[0] != '\0') ) {
        WCHAR UncCanonServerName[UNCLEN+1];
        DWORD LocalOrRemote;

        NetStatus = NetpIsRemote(
                (LPWSTR) ServerName,    // uncanon server name
                & LocalOrRemote,
                UncCanonServerName,     // output: canon
                NIRFLAG_MAPLOCAL        // flags: map null to local name
                );
        if (NetStatus != NERR_Success) {
            goto Cleanup;
        }
        if (LocalOrRemote == ISREMOTE) {


            //
            // Do the RPC call with an exception handler since RPC will raise an
            // exception if anything fails. It is up to us to figure out what
            // to do once the exception is raised.
            //

            NET_REMOTE_TRY_RPC

                //
                // Call RPC version of the API.
                //
                *Buffer = NULL;

                NetStatus = NetrGetDCName(
                                    (LPWSTR) ServerName,
                                    (LPWSTR) DomainName,
                                    (LPWSTR *)Buffer );

            NET_REMOTE_RPC_FAILED(
                    "NetGetDCName",
                    UncCanonServerName,
                    NetStatus,
                    NET_REMOTE_FLAG_NORMAL,
                    SERVICE_NETLOGON )

                //
                // We should probaly check if it's really a downlevel machine
                //

                NetStatus = RxNetGetDCName(
                        UncCanonServerName,
                        (LPWSTR) DomainName,
                        (LPBYTE *) Buffer  // may be allocated
                        );


            NET_REMOTE_END

            goto Cleanup;

        }

        //
        // Must be explicit reference to local machine.  Fall through and
        // handle it.
        //

    }

    //
    // Simply call DsGetDcName to find the PDC.
    //
    // NT 3.x cached the response for the primary domain.  The was Lanman
    // legacy to avoid the expensive discovery.  However, NT discovery is
    // cheaper than the API calls Lanman used to verify the cached information.
    //
    //

    NetStatus = DsGetDcNameW(
                    NULL,       // Not remoted
                    DomainName,
                    NULL,       // No Domain GUID
                    NULL,       // No Site GUID
                    DS_FORCE_REDISCOVERY |
                        DS_PDC_REQUIRED |
                        DS_IS_FLAT_NAME |
                        DS_RETURN_FLAT_NAME,
                    &DomainControllerInfo );

    //
    // Map the status codes to be compatible.
    //

    if ( NetStatus != NO_ERROR ) {
        if ( NlDcUseGenericStatus(NetStatus) ) {
            NetStatus = NERR_DCNotFound;
        }
        goto Cleanup;
    }

    //
    // Allocate a buffer to return to the caller and fill it in
    //

    NetStatus = NetapipBufferAllocate(
                      (wcslen(DomainControllerInfo->DomainControllerName) + 1) * sizeof(WCHAR),
                      (LPVOID *) Buffer );

    if ( NetStatus != NO_ERROR ) {
        IF_DEBUG( LOGON ) {
            NetpKdPrint(( "NetGetDCName: cannot allocate response buffer.\n"));
        }
        goto Cleanup;
    }

    wcscpy((LPWSTR)*Buffer, DomainControllerInfo->DomainControllerName );

Cleanup:

    //
    // Cleanup all locally used resources
    //

    if ( DomainControllerInfo != NULL ) {
        NetApiBufferFree( DomainControllerInfo );
    }

    return NetStatus;
}


NET_API_STATUS NET_API_FUNCTION
NetGetAnyDCName (
    IN  LPCWSTR   ServerName OPTIONAL,
    IN  LPCWSTR   DomainName OPTIONAL,
    OUT LPBYTE  *Buffer
    )

/*++

Routine Description:

    Get the name of the any domain controller for a domain that is directly trusted
    by ServerName.


    If ServerName is a standalone Windows NT Workstation or standalone Windows NT Server,
        no DomainName is valid.

    If ServerName is a Windows NT Workstation that is a member of a domain or a
        Windows NT Server member server,
        the DomainName must the the domain ServerName is a member of.

    If ServerName is a Windows NT Server domain controller,
        the DomainName must be one of the domains trusted by the
        domain the server is a controller for.

    The domain controller found is guaranteed to have been up at one point during
    this API call.

Arguments:

    ServerName - name of remote server (null for local)

    DomainName - name of domain (null for primary domain)

    Buffer - Returns a pointer to an allcated buffer containing the
        servername of a DC of the domain.  The server name is prefixed
        by \\.  The buffer should be deallocated using NetApiBufferFree.

Return Value:

    ERROR_SUCCESS - Success.  Buffer contains DC name prefixed by \\.

    ERROR_NO_LOGON_SERVERS - No DC could be found

    ERROR_NO_SUCH_DOMAIN - The specified domain is not a trusted domain.

    ERROR_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken.

    ERROR_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken.

    ERROR_DOMAIN_TRUST_INCONSISTENT - The server that responded is not a proper
        domain controller of the specified domain.

--*/
{
    NET_API_STATUS          NetStatus;


    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        *Buffer = NULL;  // Force RPC to allocate

        //
        // Call RPC version of the API.
        //

        NetStatus = NetrGetAnyDCName(
                            (LPWSTR) ServerName,
                            (LPWSTR) DomainName,
                            (LPWSTR *) Buffer );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("NetGetAnyDCName rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}

DWORD
WINAPI
DsValidateSubnetNameA(
    IN LPCSTR SubnetName
)
/*++

Routine Description:

    Routine to validate a subnet name of the form xxx.xxx.xxx.xxx/yy

Arguments:

    SubnetName - Name of the subnet to validate.

Return Value:

    NO_ERROR: Subnet name is valid

    ERROR_INVALID_NAME: Subnet name is not valid

--*/
{
    DWORD WinStatus;
    LPWSTR UnicodeSubnetName = NULL;

    //
    // Convert to unicode.
    //

    if ( SubnetName == NULL ) {
        return ERROR_INVALID_NAME;
    }

    UnicodeSubnetName = NetpAllocWStrFromAStr( SubnetName );

    if ( UnicodeSubnetName == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Validate the name
    //

    WinStatus = DsValidateSubnetNameW( UnicodeSubnetName );

    //
    // Clean up locally used resources.
    //

Cleanup:
    if ( UnicodeSubnetName != NULL ) {
        NetApiBufferFree( UnicodeSubnetName );
    }

    return WinStatus;

}

DWORD
WINAPI
DsValidateSubnetNameW(
    IN LPCWSTR SubnetName
)
/*++

Routine Description:

    Routine to validate a subnet name of the form xxx.xxx.xxx.xxx/yy

Arguments:

    SubnetName - Name of the subnet to validate.

Return Value:

    NO_ERROR: Subnet name is valid

    ERROR_INVALID_NAME: Subnet name is not valid

--*/
{
    DWORD WinStatus;
    ULONG SubnetAddress;
    ULONG SubnetMask;
    BYTE SubnetBitCount;


    //
    // Caller the worker routine to do the real work
    //

    WinStatus = NlParseSubnetString( SubnetName,
                                     &SubnetAddress,
                                     &SubnetMask,
                                     &SubnetBitCount );

    //
    // If Winsock has not yet been initialized,
    //  initialize it.
    //

    if ( WinStatus == WSANOTINITIALISED ) {

        //
        // Initialize WSA.
        //

        WinStatus = DsWsaInitialize();

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Repeat the call.
        //


        WinStatus = NlParseSubnetString( SubnetName,
                                         &SubnetAddress,
                                         &SubnetMask,
                                         &SubnetBitCount );

    }

    //
    // Free locally used resouces.
    //

Cleanup:
    return WinStatus;

}

DWORD
WINAPI
DsGetSiteNameA(
    IN LPCSTR ComputerName OPTIONAL,
    OUT LPSTR *SiteName
    )
/*++

Routine Description:

    Same as DsGetSiteNameW except it takes and returns ASCII.

Arguments:

    Same as DsGetSiteNameW except it takes and returns ASCII.

Return Value:

    Same as DsGetSiteNameW except it takes and returns ASCII.

--*/
{
    DWORD WinStatus;
    LPWSTR UnicodeComputerName = NULL;
    LPWSTR UnicodeSiteName = NULL;


    //
    // Convert input parameters to Unicode.
    //

    *SiteName = NULL;

    if ( ComputerName != NULL ) {
        UnicodeComputerName = NetpAllocWStrFromAStr( ComputerName );

        if ( UnicodeComputerName == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Call the Unicode version of the routine.
    //

    WinStatus = DsGetSiteNameW(
                    UnicodeComputerName,
                    &UnicodeSiteName );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the output structure to ANSI character set.
    //

    *SiteName = NetpAllocAStrFromWStr( UnicodeSiteName );

    if ( *SiteName == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

    //
    // Clean up locally used resources.
    //

Cleanup:
    if ( UnicodeComputerName != NULL ) {
        NetApiBufferFree( UnicodeComputerName );
    }
    if ( UnicodeSiteName != NULL ) {
        NetApiBufferFree( UnicodeSiteName );
    }

    return WinStatus;

}

DWORD
WINAPI
DsGetSiteNameW(
    IN LPCWSTR ComputerName OPTIONAL,
    OUT LPWSTR *SiteName
    )
/*++

Routine Description:

    The DsGetSiteName API returns the name site a computer is in.

    For a DC, the SiteName is the site the DC is configured to be in.

    For a member workstation or member server, this is the name of the site
    the workstation is in as configured in the domain the machine is a member of.

    A standalone workstation or standalone server will always return
    ERROR_NO_SITENAME.

Arguments:

    ComputerName - Specifies the name of the server to remote this API to.
        Typically, this parameter should be specified as NULL.

    SiteName - Returns the site name of the site this machine is in.
        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

    ERROR_NO_SITENAME - The machine is not in a site.

--*/
{
    NET_API_STATUS NetStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        *SiteName = NULL;  // Force RPC to allocate

        //
        // Call RPC version of the API.
        //

        NetStatus = DsrGetSiteName(
                            (LPWSTR) ComputerName,
                            SiteName );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // If Netlogon isn't running on the local machine,
    //  or Netlogon is the NT 4.0 version of netlogon (the upgrade case),
    //  Simply indicate that there is no site.
    //

    if ( NetStatus == RPC_S_UNKNOWN_IF ||
         NetStatus == RPC_S_PROCNUM_OUT_OF_RANGE ) {

        NetStatus = ERROR_NO_SITENAME;

    }

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("DsrGetSiteName rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}

DWORD
WINAPI
DsAddressToSiteNamesA(
    IN LPCSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT LPSTR **SiteNames
    )
/*++

Routine Description:

    The DsAddressToSiteNames API returns the site names that correspond to
    the specified addresses.

Arguments:

    ComputerName - Specifies the name of the domain controller to remote this API to.

    EntryCount - Number of addresses to convert.

    SocketAddresses - Specifies an EntryCount element array of addresses
        to convert.  Each address must be of type AF_INET.

    SiteNames - Returns an array of pointers to site names.  EntryCount entries
        are returned.  An entry will be returned as NULL if the corresponding
        address does not map to any site or if the address is malformed.

        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_SITE_NAME_ARRAY SiteNameArray;
    LPWSTR UnicodeComputerName = NULL;

    //
    // Initialization
    //
    *SiteNames = NULL;
    if ( EntryCount == 0 ) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Convert input parameters to Unicode.
    //

    if ( ComputerName != NULL ) {
        UnicodeComputerName = NetpAllocWStrFromAStr( ComputerName );

        if ( UnicodeComputerName == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }



    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        SiteNameArray  = NULL;  // Force RPC to allocate

        //
        // Call RPC version of the API.
        //

        NetStatus = DsrAddressToSiteNamesW(
                            UnicodeComputerName,
                            EntryCount,
                            (PNL_SOCKET_ADDRESS)SocketAddresses,
                            &SiteNameArray );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Convert the site names to what the caller expects.
    //

    if ( NetStatus == NO_ERROR && SiteNameArray != NULL ) {

        //
        // Sanity check
        //

        if ( EntryCount != SiteNameArray->EntryCount ) {
            NetStatus = ERROR_INVALID_PARAMETER;


        } else {
            ULONG Size;
            ULONG i;

            //
            // Allocate a buffer to return to the caller
            //

            Size = sizeof(LPSTR) * EntryCount;
            for ( i=0; i<EntryCount; i++) {
                Size += RtlUnicodeStringToAnsiSize( &SiteNameArray->SiteNames[i] );
            }

            *SiteNames = MIDL_user_allocate( Size );

            if ( *SiteNames == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                LPBYTE Where;

                //
                // Loop copying names to the caller.
                //

                Where = ((LPBYTE)(*SiteNames)) + sizeof(LPSTR) * EntryCount;
                for ( i=0; i<EntryCount; i++) {

                    //
                    // If no name was returned,
                    //  pass a NULL back to the caller.
                    //

                    if ( SiteNameArray->SiteNames[i].Length == 0 ) {
                        (*SiteNames)[i] = NULL;

                    //
                    // Copy the site name into the return buffer.
                    //
                    } else {
                        ANSI_STRING TempString;
                        NTSTATUS Status;

                        (*SiteNames)[i] = (LPSTR) Where;
                        TempString.Buffer = Where;
                        TempString.MaximumLength = (USHORT) RtlUnicodeStringToAnsiSize( &SiteNameArray->SiteNames[i] );
                        Status = RtlUnicodeStringToAnsiString(
                                        &TempString,
                                        &SiteNameArray->SiteNames[i],
                                        FALSE );

                        if ( !NT_SUCCESS(Status) ) {
                            MIDL_user_free( *SiteNames );
                            *SiteNames = NULL;
                            NetStatus = NetpNtStatusToApiStatus( Status );
                            break;
                        }

                        Where += TempString.MaximumLength;

                    }
                }

            }
        }

        MIDL_user_free( SiteNameArray );
    }

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("DsAddressToSiteNames rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    if ( UnicodeComputerName != NULL ) {
        NetApiBufferFree( UnicodeComputerName );
    }

    return NetStatus;
}

DWORD
WINAPI
DsAddressToSiteNamesW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT LPWSTR **SiteNames
    )
/*++

Routine Description:

    The DsAddressToSiteNames API returns the site names that correspond to
    the specified addresses.

Arguments:

    ComputerName - Specifies the name of the domain controller to remote this API to.

    EntryCount - Number of addresses to convert.

    SocketAddresses - Specifies an EntryCount element array of addresses
        to convert.  Each address must be of type AF_INET.

    SiteNames - Returns an array of pointers to site names.  EntryCount entries
        are returned.  An entry will be returned as NULL if the corresponding
        address does not map to any site or if the address is malformed.

        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_SITE_NAME_ARRAY SiteNameArray;

    //
    // Initialization
    //
    *SiteNames = NULL;
    if ( EntryCount == 0 ) {
        return ERROR_INVALID_PARAMETER;
    }



    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        SiteNameArray  = NULL;  // Force RPC to allocate

        //
        // Call RPC version of the API.
        //

        NetStatus = DsrAddressToSiteNamesW(
                            (LPWSTR) ComputerName,
                            EntryCount,
                            (PNL_SOCKET_ADDRESS)SocketAddresses,
                            &SiteNameArray );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Convert the site names to what the caller expects.
    //

    if ( NetStatus == NO_ERROR && SiteNameArray != NULL ) {

        //
        // Sanity check
        //

        if ( EntryCount != SiteNameArray->EntryCount ) {
            NetStatus = ERROR_INVALID_PARAMETER;


        } else {
            ULONG Size;
            ULONG i;

            //
            // Allocate a buffer to return to the caller
            //

            Size = sizeof(LPWSTR) * EntryCount;
            for ( i=0; i<EntryCount; i++) {
                Size += SiteNameArray->SiteNames[i].Length + sizeof(WCHAR);
            }

            *SiteNames = MIDL_user_allocate( Size );

            if ( *SiteNames == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                LPBYTE Where;

                //
                // Loop copying names to the caller.
                //

                Where = ((LPBYTE)(*SiteNames)) + sizeof(LPWSTR) * EntryCount;
                for ( i=0; i<EntryCount; i++) {

                    //
                    // If no name was returned,
                    //  pass a NULL back to the caller.
                    //

                    if ( SiteNameArray->SiteNames[i].Length == 0 ) {
                        (*SiteNames)[i] = NULL;

                    //
                    // Copy the site name into the return buffer.
                    //
                    } else {

                        (*SiteNames)[i] = (LPWSTR) Where;
                        RtlCopyMemory( Where,
                                       SiteNameArray->SiteNames[i].Buffer,
                                       SiteNameArray->SiteNames[i].Length );
                        Where += SiteNameArray->SiteNames[i].Length;
                        *(LPWSTR)Where = L'\0';
                        Where += sizeof(WCHAR);

                    }
                }

            }
        }

        MIDL_user_free( SiteNameArray );
    }

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("DsAddressToSiteNames rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}

DWORD
WINAPI
DsAddressToSiteNamesExA(
    IN LPCSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT LPSTR **SiteNames,
    OUT LPSTR **SubnetNames
    )
/*++

Routine Description:

    The DsAddressToSiteNamesEx API returns the site names and subnet names
    that correspond to the specified addresses.

Arguments:

    ComputerName - Specifies the name of the domain controller to remote this API to.

    EntryCount - Number of addresses to convert.

    SocketAddresses - Specifies an EntryCount element array of addresses
        to convert.  Each address must be of type AF_INET.

    SiteNames - Returns an array of pointers to site names.  EntryCount entries
        are returned.  An entry will be returned as NULL if the corresponding
        address does not map to any site or if the address is malformed.

        The returned buffer must be deallocated using NetApiBufferFree.

    SubnetNames - Returns an array of pointers to subnet names which were used
        to perform the address to site name mappings.  EntryCount entries
        are returned.  An entry will be returned as NULL if the corresponding address
        to site mapping was not determined or if no subnet was used to perform the
        corresponding address to site mapping which is the case when there is exactly
        one site in the enterprise with no subnet objects mapped to it.

        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_SITE_NAME_EX_ARRAY SiteNameArray;
    LPWSTR UnicodeComputerName = NULL;

    //
    // Initialization
    //
    *SiteNames = NULL;
    *SubnetNames = NULL;
    if ( EntryCount == 0 ) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Convert input parameters to Unicode.
    //

    if ( ComputerName != NULL ) {
        UnicodeComputerName = NetpAllocWStrFromAStr( ComputerName );

        if ( UnicodeComputerName == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }



    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        SiteNameArray  = NULL;  // Force RPC to allocate

        //
        // Call RPC version of the API.
        //

        NetStatus = DsrAddressToSiteNamesExW(
                            UnicodeComputerName,
                            EntryCount,
                            (PNL_SOCKET_ADDRESS)SocketAddresses,
                            &SiteNameArray );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Convert the site names to what the caller expects.
    //

    if ( NetStatus == NO_ERROR && SiteNameArray != NULL ) {

        //
        // Sanity check
        //

        if ( EntryCount != SiteNameArray->EntryCount ) {
            NetStatus = ERROR_INVALID_PARAMETER;


        } else {
            ULONG Size;
            ULONG i;

            //
            // Allocate a buffer to return to the caller
            //

            Size = sizeof(LPSTR) * EntryCount;
            for ( i=0; i<EntryCount; i++) {
                Size += RtlUnicodeStringToAnsiSize( &SiteNameArray->SiteNames[i] );
            }

            *SiteNames = MIDL_user_allocate( Size );

            if ( *SiteNames == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            } else {

                Size = sizeof(LPSTR) * EntryCount;
                for ( i=0; i<EntryCount; i++) {
                    Size += RtlUnicodeStringToAnsiSize( &SiteNameArray->SubnetNames[i] );
                }

                *SubnetNames = MIDL_user_allocate( Size );

                if ( *SubnetNames == NULL ) {
                    MIDL_user_free( *SiteNames );
                    *SiteNames = NULL;
                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    LPBYTE Where;
                    LPBYTE Where2;

                    //
                    // Loop copying names to the caller.
                    //

                    Where = ((LPBYTE)(*SiteNames)) + sizeof(LPSTR) * EntryCount;
                    Where2 = ((LPBYTE)(*SubnetNames)) + sizeof(LPSTR) * EntryCount;
                    for ( i=0; i<EntryCount; i++) {

                        //
                        // If no name was returned,
                        //  pass a NULL back to the caller.
                        //

                        if ( SiteNameArray->SiteNames[i].Length == 0 ) {
                            (*SiteNames)[i] = NULL;

                        //
                        // Copy the site name into the return buffer.
                        //
                        } else {
                            ANSI_STRING TempString;
                            NTSTATUS Status;

                            (*SiteNames)[i] = (LPSTR) Where;
                            TempString.Buffer = Where;
                            TempString.MaximumLength = (USHORT) RtlUnicodeStringToAnsiSize( &SiteNameArray->SiteNames[i] );
                            Status = RtlUnicodeStringToAnsiString(
                                            &TempString,
                                            &SiteNameArray->SiteNames[i],
                                            FALSE );

                            if ( !NT_SUCCESS(Status) ) {
                                MIDL_user_free( *SiteNames );
                                *SiteNames = NULL;
                                MIDL_user_free( *SubnetNames );
                                *SubnetNames = NULL;
                                NetStatus = NetpNtStatusToApiStatus( Status );
                                break;
                            }

                            Where += TempString.MaximumLength;

                        }

                        //
                        // If no name was returned,
                        //  pass a NULL back to the caller.
                        //

                        if ( SiteNameArray->SubnetNames[i].Length == 0 ) {
                            (*SubnetNames)[i] = NULL;

                        //
                        // Copy the Subnet name into the return buffer.
                        //
                        } else {
                            ANSI_STRING TempString;
                            NTSTATUS Status;

                            (*SubnetNames)[i] = (LPSTR) Where2;
                            TempString.Buffer = Where2;
                            TempString.MaximumLength = (USHORT) RtlUnicodeStringToAnsiSize( &SiteNameArray->SubnetNames[i] );
                            Status = RtlUnicodeStringToAnsiString(
                                            &TempString,
                                            &SiteNameArray->SubnetNames[i],
                                            FALSE );

                            if ( !NT_SUCCESS(Status) ) {
                                MIDL_user_free( *SubnetNames );
                                *SubnetNames = NULL;
                                MIDL_user_free( *SubnetNames );
                                *SubnetNames = NULL;
                                NetStatus = NetpNtStatusToApiStatus( Status );
                                break;
                            }

                            Where2 += TempString.MaximumLength;

                        }
                    }
                }

            }
        }

        MIDL_user_free( SiteNameArray );
    }

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("DsAddressToSiteNames rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}

DWORD
WINAPI
DsAddressToSiteNamesExW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN DWORD EntryCount,
    IN PSOCKET_ADDRESS SocketAddresses,
    OUT LPWSTR **SiteNames,
    OUT LPWSTR **SubnetNames
    )
/*++

Routine Description:

    The DsAddressToSiteNames API returns the site names that correspond to
    the specified addresses.

Arguments:

    ComputerName - Specifies the name of the domain controller to remote this API to.

    EntryCount - Number of addresses to convert.

    SocketAddresses - Specifies an EntryCount element array of addresses
        to convert.  Each address must be of type AF_INET.

    SiteNames - Returns an array of pointers to site names.  EntryCount entries
        are returned.  An entry will be returned as NULL if the corresponding
        address does not map to any site or if the address is malformed.

        The returned buffer must be deallocated using NetApiBufferFree.

    SubnetNames - Returns an array of pointers to subnet names which were used
        to perform the address to site name mappings.  EntryCount entries
        are returned.  An entry will be returned as NULL if the corresponding address
        to site mapping was not determined or if no subnet was used to perform the
        corresponding address to site mapping which is the case when there is exactly
        one site in the enterprise with no subnet objects mapped to it.

        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_SITE_NAME_EX_ARRAY SiteNameArray;

    //
    // Initialization
    //
    *SiteNames = NULL;
    *SubnetNames = NULL;
    if ( EntryCount == 0 ) {
        return ERROR_INVALID_PARAMETER;
    }



    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        SiteNameArray  = NULL;  // Force RPC to allocate

        //
        // Call RPC version of the API.
        //

        NetStatus = DsrAddressToSiteNamesExW(
                            (LPWSTR) ComputerName,
                            EntryCount,
                            (PNL_SOCKET_ADDRESS)SocketAddresses,
                            &SiteNameArray );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Convert the site names to what the caller expects.
    //

    if ( NetStatus == NO_ERROR && SiteNameArray != NULL ) {

        //
        // Sanity check
        //

        if ( EntryCount != SiteNameArray->EntryCount ) {
            NetStatus = ERROR_INVALID_PARAMETER;


        } else {
            ULONG Size;
            ULONG i;

            //
            // Allocate a buffer to return to the caller
            //

            Size = sizeof(LPWSTR) * EntryCount;
            for ( i=0; i<EntryCount; i++) {
                Size += SiteNameArray->SiteNames[i].Length + sizeof(WCHAR);
            }

            *SiteNames = MIDL_user_allocate( Size );

            if ( *SiteNames == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            } else {

                //
                // Allocate a buffer to return to the caller
                //

                Size = sizeof(LPWSTR) * EntryCount;
                for ( i=0; i<EntryCount; i++) {
                    Size += SiteNameArray->SubnetNames[i].Length + sizeof(WCHAR);
                }

                *SubnetNames = MIDL_user_allocate( Size );

                if ( *SubnetNames == NULL ) {
                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    LPBYTE Where;
                    LPBYTE Where2;

                    //
                    // Loop copying names to the caller.
                    //

                    Where = ((LPBYTE)(*SiteNames)) + sizeof(LPWSTR) * EntryCount;
                    Where2 = ((LPBYTE)(*SubnetNames)) + sizeof(LPWSTR) * EntryCount;
                    for ( i=0; i<EntryCount; i++) {

                        //
                        // If no name was returned,
                        //  pass a NULL back to the caller.
                        //

                        if ( SiteNameArray->SiteNames[i].Length == 0 ) {
                            (*SiteNames)[i] = NULL;

                        //
                        // Copy the site name into the return buffer.
                        //
                        } else {

                            (*SiteNames)[i] = (LPWSTR) Where;
                            RtlCopyMemory( Where,
                                           SiteNameArray->SiteNames[i].Buffer,
                                           SiteNameArray->SiteNames[i].Length );
                            Where += SiteNameArray->SiteNames[i].Length;
                            *(LPWSTR)Where = L'\0';
                            Where += sizeof(WCHAR);

                        }

                        //
                        // If no name was returned,
                        //  pass a NULL back to the caller.
                        //

                        if ( SiteNameArray->SubnetNames[i].Length == 0 ) {
                            (*SubnetNames)[i] = NULL;

                        //
                        // Copy the Subnet name into the return buffer.
                        //
                        } else {

                            (*SubnetNames)[i] = (LPWSTR) Where2;
                            RtlCopyMemory( Where2,
                                           SiteNameArray->SubnetNames[i].Buffer,
                                           SiteNameArray->SubnetNames[i].Length );
                            Where2 += SiteNameArray->SubnetNames[i].Length;
                            *(LPWSTR)Where2 = L'\0';
                            Where2 += sizeof(WCHAR);

                        }
                    }
                }

            }
        }

        MIDL_user_free( SiteNameArray );
    }

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("DsAddressToSiteNames rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}

DWORD
WINAPI
DsGetDcSiteCoverageA(
    IN LPCSTR ComputerName OPTIONAL,
    OUT PULONG EntryCount,
    OUT LPSTR **SiteNames
    )
/*++

Routine Description:

    This API returns the site names of all sites covered by a DC.

Arguments:

    ComputerName - Specifies the name of the domain controller to remote this API to.

    EntryCount - Returns the number of sites covered by DC.

    SiteNames - Returns an array of pointers to site names.
        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_SITE_NAME_ARRAY SiteNameArray;
    LPWSTR UnicodeComputerName = NULL;

    //
    // Initialization
    //

    *SiteNames = NULL;

    //
    // Convert input parameters to Unicode.
    //

    if ( ComputerName != NULL ) {
        UnicodeComputerName = NetpAllocWStrFromAStr( (LPSTR)ComputerName );

        if ( UnicodeComputerName == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }


    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        SiteNameArray = NULL;  // Force RPC to allocate

        //
        // Call RPC version of the API.
        //

        NetStatus = DsrGetDcSiteCoverageW(
                            UnicodeComputerName,
                            &SiteNameArray );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Convert the site names to what the caller expects.
    //

    if ( NetStatus == NO_ERROR && SiteNameArray != NULL ) {

        ULONG Size;
        ULONG i;

        //
        // Set the size of the array
        //

        *EntryCount = SiteNameArray->EntryCount;

        //
        // Allocate a buffer to return to the caller
        //

        Size = sizeof(LPSTR) * SiteNameArray->EntryCount;
        for ( i=0; i<*EntryCount; i++ ) {
            Size += RtlUnicodeStringToAnsiSize( &SiteNameArray->SiteNames[i] );
        }

        *SiteNames = MIDL_user_allocate( Size );

        if ( *SiteNames == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            LPBYTE Where;

            //
            // Loop copying names to the caller.
            //

            Where = ((LPBYTE)(*SiteNames)) + sizeof(LPSTR) * SiteNameArray->EntryCount;
            for ( i=0; i<*EntryCount; i++) {

                //
                // Copy the site name into the return buffer.
                //
                ANSI_STRING TempString;
                NTSTATUS Status;

                (*SiteNames)[i] = (LPSTR) Where;
                TempString.Buffer = Where;
                TempString.MaximumLength = (USHORT) RtlUnicodeStringToAnsiSize( &SiteNameArray->SiteNames[i] );
                Status = RtlUnicodeStringToAnsiString(
                                &TempString,
                                &SiteNameArray->SiteNames[i],
                                FALSE );

                if ( !NT_SUCCESS(Status) ) {
                    MIDL_user_free( *SiteNames );
                    *SiteNames = NULL;
                    NetStatus = NetpNtStatusToApiStatus( Status );
                    break;
                }

                Where += TempString.MaximumLength;

            }

        }

        MIDL_user_free( SiteNameArray );
    }

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("DsGetDcSiteCoverage rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    if ( UnicodeComputerName != NULL ) {
        NetApiBufferFree( UnicodeComputerName );
    }

    return NetStatus;
}

DWORD
WINAPI
DsGetDcSiteCoverageW(
    IN LPCWSTR ComputerName OPTIONAL,
    OUT PULONG EntryCount,
    OUT LPWSTR **SiteNames
    )
/*++

Routine Description:

    This API returns the site names of all sites covered by a DC.

Arguments:

    ComputerName - Specifies the name of the domain controller to remote this API to.

    EntryCount - Returns the number of sites covered by DC.

    SiteNames - Returns an array of pointers to site names.
        The returned buffer must be deallocated using NetApiBufferFree.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the
        operation.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_SITE_NAME_ARRAY SiteNameArray;

    //
    // Initialization
    //

    *SiteNames = NULL;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        SiteNameArray = NULL;  // Force RPC to allocate

        //
        // Call RPC version of the API.
        //

        NetStatus = DsrGetDcSiteCoverageW(
                            (LPWSTR) ComputerName,
                            &SiteNameArray );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    //
    // Convert the site names to what the caller expects.
    //

    if ( NetStatus == NO_ERROR && SiteNameArray != NULL ) {

        ULONG Size;
        ULONG i;

        //
        // Set the size of the array
        //

        *EntryCount = SiteNameArray->EntryCount;

        //
        // Allocate a buffer to return to the caller
        //

        Size = sizeof(LPWSTR) * SiteNameArray->EntryCount;
        for ( i=0; i<*EntryCount; i++) {
            Size += SiteNameArray->SiteNames[i].Length + sizeof(WCHAR);
        }

        *SiteNames = MIDL_user_allocate( Size );

        if ( *SiteNames == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            LPBYTE Where;

            //
            // Loop copying names to the caller.
            //

            Where = ((LPBYTE)(*SiteNames)) + sizeof(LPWSTR) * SiteNameArray->EntryCount;
            for ( i=0; i<*EntryCount; i++) {

                //
                // Copy the site name into the return buffer.
                //

                (*SiteNames)[i] = (LPWSTR) Where;
                RtlCopyMemory( Where,
                               SiteNameArray->SiteNames[i].Buffer,
                               SiteNameArray->SiteNames[i].Length );
                Where += SiteNameArray->SiteNames[i].Length;
                *(LPWSTR)Where = L'\0';
                Where += sizeof(WCHAR);

            }

        }

        MIDL_user_free( SiteNameArray );
    }

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("DsGetDcSiteCoverage rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}

#endif // WIN32_CHICAGO
#endif // NETTEST_UTILITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\logonapi.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    logonapi.c

Abstract:

    This module contains the Netlogon API RPC client stubs.


Author:

    Cliff Van Dyke  (CliffV)    27-Jun-1991

[Environment:]

    User Mode - Win32

Revision History:

    27-Jun-1991     CliffV
        Created

--*/

//
// INCLUDES
//

#include <nt.h>
#include <ntrtl.h>

#include <rpc.h>
#include <ntrpcp.h>   // needed by rpcasync.h
#include <rpcasync.h> // I_RpcExceptionFilter
#include <logon_c.h>// includes lmcons.h, lmaccess.h, netlogon.h, ssi.h, windef.h

#include <crypt.h>      // Encryption routines.
#include <debuglib.h>   // IF_DEBUG()
#include <lmerr.h>      // NERR_ and ERROR_ equates.
#include <netdebug.h>   // NetpKdPrint


NET_API_STATUS NET_API_FUNCTION
I_NetLogonUasLogon (
    IN LPWSTR UserName,
    IN LPWSTR Workstation,
    OUT PNETLOGON_VALIDATION_UAS_INFO *ValidationInformation
)
/*++

Routine Description:

    This function is called by the XACT server when processing a
    I_NetWkstaUserLogon XACT SMB.  This feature allows a UAS client to
    logon to a SAM domain controller.

Arguments:

    UserName -- Account name of the user logging on.

    Workstation -- The workstation from which the user is logging on.

    ValidationInformation -- Returns the requested validation
        information.


Return Value:

    NERR_SUCCESS if there was no error. Otherwise, the error code is
    returned.


--*/
{
    NET_API_STATUS          NetStatus;
    LPWSTR ServerName = NULL;    // Not supported remotely

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        *ValidationInformation = NULL;  // Force RPC to allocate
        //
        // Call RPC version of the API.
        //

        NetStatus = NetrLogonUasLogon(
                            (LPWSTR) ServerName,
                            UserName,
                            Workstation,
                            ValidationInformation );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("NetrLogonUasLogon rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}


NET_API_STATUS
I_NetLogonUasLogoff (
    IN LPWSTR UserName,
    IN LPWSTR Workstation,
    OUT PNETLOGON_LOGOFF_UAS_INFO LogoffInformation
)
/*++

Routine Description:

    This function is called by the XACT server when processing a
    I_NetWkstaUserLogoff XACT SMB.  This feature allows a UAS client to
    logoff from a SAM domain controller.  The request is authenticated,
    the entry is removed for this user from the logon session table
    maintained by the Netlogon service for NetLogonEnum, and logoff
    information is returned to the caller.

    The server portion of I_NetLogonUasLogoff (in the Netlogon service)
    compares the user name and workstation name specified in the
    LogonInformation with the user name and workstation name from the
    impersonation token.  If they don't match, I_NetLogonUasLogoff fails
    indicating the access is denied.

    Group SECURITY_LOCAL is refused access to this function.  Membership
    in SECURITY_LOCAL implies that this call was made locally and not
    through the XACT server.

    The Netlogon service cannot be sure that this function was called by
    the XACT server.  Therefore, the Netlogon service will not simply
    delete the entry from the logon session table.  Rather, the logon
    session table entry will be marked invisible outside of the Netlogon
    service (i.e., it will not be returned by NetLogonEnum) until a valid
    LOGON_WKSTINFO_RESPONSE is received for the entry.  The Netlogon
    service will immediately interrogate the client (as described above
    for LOGON_WKSTINFO_RESPONSE) and temporarily increase the
    interrogation frequency to at least once a minute.  The logon session
    table entry will reappear as soon as a function of interrogation if
    this isn't a true logoff request.

Arguments:

    UserName -- Account name of the user logging off.

    Workstation -- The workstation from which the user is logging
        off.

    LogoffInformation -- Returns the requested logoff information.

Return Value:

    The Net status code.

--*/
{
    NET_API_STATUS          NetStatus;
    LPWSTR ServerName = NULL;    // Not supported remotely

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        NetStatus = NetrLogonUasLogoff(
                            (LPWSTR) ServerName,
                            UserName,
                            Workstation,
                            LogoffInformation );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("NetrLogonUasLogoff rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}


NTSTATUS
I_NetLogonSamLogon (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative
    )

/*++

Routine Description:

    This function is called by an NT client to process an interactive or
    network logon.  This function passes a domain name, user name and
    credentials to the Netlogon service and returns information needed to
    build a token.  It is called in three instances:

      *  It is called by the LSA's MSV1_0 authentication package for any
         NT system that has LanMan installed.  The MSV1_0 authentication
         package calls SAM directly if LanMan is not installed.  In this
         case, this function is a local function and requires the caller
         to have SE_TCB privilege.  The local Netlogon service will
         either handle this request directly (validating the request with
         the local SAM database) or will forward this request to the
         appropriate domain controller as documented in sections 2.4 and
         2.5.

      *  It is called by a Netlogon service on a workstation to a DC in
         the Primary Domain of the workstation as documented in section
         2.4.  In this case, this function uses a secure channel set up
         between the two Netlogon services.

      *  It is called by a Netlogon service on a DC to a DC in a trusted
         domain as documented in section 2.5.  In this case, this
         function uses a secure channel set up between the two Netlogon
         services.

    The Netlogon service validates the specified credentials.  If they
    are valid, adds an entry for this LogonId, UserName, and Workstation
    into the logon session table.  The entry is added to the logon
    session table only in the domain defining the specified user's
    account.

    This service is also used to process a re-logon request.


Arguments:

    LogonServer -- Supplies the name of the logon server to process
        this logon request.  This field should be null to indicate
        this is a call from the MSV1_0 authentication package to the
        local Netlogon service.

    ComputerName -- Name of the machine making the call.  This field
        should be null to indicate this is a call from the MSV1_0
        authentication package to the local Netlogon service.

    Authenticator -- supplied by the client.  This field should be
        null to indicate this is a call from the MSV1_0
        authentication package to the local Netlogon service.

    ReturnAuthenticator -- Receives an authenticator returned by the
        server.  This field should be null to indicate this is a call
        from the MSV1_0 authentication package to the local Netlogon
        service.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.

    ValidationLevel -- Specifies the level of information returned in
        ValidationInformation.  Must be NetlogonValidationSamInformation.

    ValidationInformation -- Returns the requested validation
        information.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_LOGON_SERVERS -- Either Pass-thru authentication or
        Trusted Domain Authentication could not contact the requested
        Domain Controller.

    STATUS_INVALID_INFO_CLASS -- Either LogonLevel or ValidationLevel is
        invalid.

    STATUS_INVALID_PARAMETER -- Another Parameter is invalid.

    STATUS_ACCESS_DENIED -- The caller does not have access to call this
        API.

    STATUS_NO_SUCH_USER -- Indicates that the user specified in
        LogonInformation does not exist.  This status should not be returned
        to the originally caller.  It should be mapped to STATUS_LOGON_FAILURE.

    STATUS_WRONG_PASSWORD -- Indicates that the password information in
        LogonInformation was incorrect.  This status should not be returned
        to the originally caller.  It should be mapped to STATUS_LOGON_FAILURE.

    STATUS_INVALID_LOGON_HOURES -- The user is not authorized to logon
        at this time.

    STATUS_INVALID_WORKSTATION -- The user is not authorized to logon
        from the specified workstation.

    STATUS_PASSWORD_EXPIRED -- The password for the user has expired.

    STATUS_ACCOUNT_DISABLED -- The user's account has been disabled.

    .
    .
    .



--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    NETLOGON_LEVEL RpcLogonInformation;
    NETLOGON_VALIDATION RpcValidationInformation;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        RpcLogonInformation.LogonInteractive =
            (PNETLOGON_INTERACTIVE_INFO) LogonInformation;

        RpcValidationInformation.ValidationSam = NULL;

        Status = NetrLogonSamLogon(
                            LogonServer,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            LogonLevel,
                            &RpcLogonInformation,
                            ValidationLevel,
                            &RpcValidationInformation,
                            Authoritative );

        *ValidationInformation = (LPBYTE)
            RpcValidationInformation.ValidationSam;

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        *Authoritative = TRUE;
        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonSamLogon rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}


NTSTATUS
I_NetLogonSamLogonWithFlags (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags
    )

/*++

Routine Description:

    Flag version of I_NetLogonSamLogon.

Arguments:

    Same as I_NetLogonSamLogon except:

    * ExtraFlags - Passes and returns a DWORD.  For later expansion.


Return Value:

    Same as I_NetLogonSamLogon.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    NETLOGON_LEVEL RpcLogonInformation;
    NETLOGON_VALIDATION RpcValidationInformation;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        RpcLogonInformation.LogonInteractive =
            (PNETLOGON_INTERACTIVE_INFO) LogonInformation;

        RpcValidationInformation.ValidationSam = NULL;

        Status = NetrLogonSamLogonWithFlags(
                            LogonServer,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            LogonLevel,
                            &RpcLogonInformation,
                            ValidationLevel,
                            &RpcValidationInformation,
                            Authoritative,
                            ExtraFlags );

        *ValidationInformation = (LPBYTE)
            RpcValidationInformation.ValidationSam;

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        *Authoritative = TRUE;
        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonSamLogonWithFlags rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}



NTSTATUS
I_NetLogonSamLogonEx (
    IN PVOID ContextHandle,
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags,
    OUT PBOOLEAN RpcFailed
    )

/*++

Routine Description:

    Concurrent API version of I_NetLogonSamLogon.

Arguments:

    Same as I_NetLogonSamLogon except:

    * No authenticator parameters.

    * Context Handle parameter

    * ExtraFlags - Passes and returns a DWORD.  For later expansion.


Return Value:

    Same as I_NetLogonSamLogon.


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    NETLOGON_LEVEL RpcLogonInformation;
    NETLOGON_VALIDATION RpcValidationInformation;
    *RpcFailed = FALSE;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        RpcLogonInformation.LogonInteractive =
            (PNETLOGON_INTERACTIVE_INFO) LogonInformation;

        RpcValidationInformation.ValidationSam = NULL;

        Status = NetrLogonSamLogonEx(
                            ContextHandle,
                            LogonServer,
                            ComputerName,
                            LogonLevel,
                            &RpcLogonInformation,
                            ValidationLevel,
                            &RpcValidationInformation,
                            Authoritative,
                            ExtraFlags );

        *ValidationInformation = (LPBYTE)
            RpcValidationInformation.ValidationSam;

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        *Authoritative = TRUE;
        *RpcFailed = TRUE;
        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonSamLogonEx rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}




NTSTATUS NET_API_FUNCTION
I_NetLogonSamLogoff (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation
)
/*++

Routine Description:

    This function is called by an NT client to process an interactive
    logoff.  It is not called for the network logoff case since the
    Netlogon service does not maintain any context for network logons.

    This function does the following.  It authenticates the request.  It
    updates the logon statistics in the SAM database on whichever machine
    or domain defines this user account.  It updates the logon session
    table in the primary domain of the machine making the request.  And
    it returns logoff information to the caller.

    This function is called in same scenarios that I_NetLogonSamLogon is
    called:

      *  It is called by the LSA's MSV1_0 authentication package to
         support LsaApLogonTerminated.  In this case, this function is a
         local function and requires the caller to have SE_TCB privilege.
         The local Netlogon service will either handle this request
         directly (if LogonDomainName indicates this request was
         validated locally) or will forward this request to the
         appropriate domain controller as documented in sections 2.4 and
         2.5.

      *  It is called by a Netlogon service on a workstation to a DC in
         the Primary Domain of the workstation as documented in section
         2.4.  In this case, this function uses a secure channel set up
         between the two Netlogon services.

      *  It is called by a Netlogon service on a DC to a DC in a trusted
         domain as documented in section 2.5.  In this case, this
         function uses a secure channel set up between the two Netlogon
         services.

    When this function is a remote function, it is sent to the DC over a
    NULL session.

Arguments:

    LogonServer -- Supplies the name of the logon server which logged
        this user on.  This field should be null to indicate this is
        a call from the MSV1_0 authentication package to the local
        Netlogon service.

    ComputerName -- Name of the machine making the call.  This field
        should be null to indicate this is a call from the MSV1_0
        authentication package to the local Netlogon service.

    Authenticator -- supplied by the client.  This field should be
        null to indicate this is a call from the MSV1_0
        authentication package to the local Netlogon service.

    ReturnAuthenticator -- Receives an authenticator returned by the
        server.  This field should be null to indicate this is a call
        from the MSV1_0 authentication package to the local Netlogon
        service.

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the logon domain name, logon Id,
        user name and workstation name of the user logging off.

Return Value:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    NETLOGON_LEVEL RpcLogonInformation;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        RpcLogonInformation.LogonInteractive =
            (PNETLOGON_INTERACTIVE_INFO) LogonInformation;

        Status = NetrLogonSamLogoff(
                            LogonServer,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            LogonLevel,
                            &RpcLogonInformation );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonSamLogoff rc = %lu 0x%lx\n", Status, Status));
    }
    return Status;
}




NTSTATUS NET_API_FUNCTION
I_NetLogonSendToSam (
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN LPBYTE OpaqueBuffer,
    IN ULONG OpaqueBufferSize
)
/*++

Routine Description:

    This function sends an opaque buffer from SAM on a BDC to SAM on the PDC.

    The original use of this routine will be to allow the BDC to forward user
    account password changes to the PDC.


Arguments:

    PrimaryName -- Computer name of the PDC to remote the call to.

    ComputerName -- Name of the machine making the call.

    Authenticator -- supplied by the client.

    ReturnAuthenticator -- Receives an authenticator returned by the
        server.

    OpaqueBuffer - Buffer to be passed to the SAM service on the PDC.
        The buffer will be encrypted on the wire.

    OpaqueBufferSize - Size (in bytes) of OpaqueBuffer.

Return Value:

    STATUS_SUCCESS: Message successfully sent to PDC

    STATUS_NO_MEMORY: There is not enough memory to complete the operation

    STATUS_NO_SUCH_DOMAIN: DomainName does not correspond to a hosted domain

    STATUS_NO_LOGON_SERVERS: PDC is not currently available

    STATUS_NOT_SUPPORTED: PDC does not support this operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrLogonSendToSam(
                            PrimaryName,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            OpaqueBuffer,
                            OpaqueBufferSize );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonSendToSam rc = %lu 0x%lx\n", Status, Status));
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\ssiapi.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    ssiapi.c

Abstract:

    Authentication and replication API routines (client side).

Author:

    Cliff Van Dyke (cliffv) 30-Jul-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>         // LARGE_INTEGER definition
#include <ntrtl.h>      // LARGE_INTEGER definition
#include <nturtl.h>     // LARGE_INTEGER definition

#include <rpc.h>        // Needed by logon.h
#include <ntrpcp.h>     // needed by rpcasync.h
#include <rpcasync.h>   // I_RpcExceptionFilter
#include <logon_c.h>    // includes lmcons.h, lmaccess.h, netlogon.h, ssi.h, windef.h

#include <debuglib.h>   // IF_DEBUG()
#include <lmerr.h>      // NERR_* defines
#include <lmapibuf.h>   // NetApiBufferFree()
#include <netdebug.h>   // NetpKdPrint
#include <netlibnt.h>   // NetpNtStatusToApiStatus()
#include "..\server\ssiapi.h"
#include <winsock2.h>   // Needed by nlcommon.h
#include <netlib.h>     // Needed by nlcommon.h
#include <ntddbrow.h>   // Needed by nlcommon.h
#include "nlcommon.h"
#include <netlogp.h>
#include <tstring.h>    // NetpCopyStrToWStr()
#include <align.h>      // ROUND_UP_COUNT ...
#include <strarray.h>   // NetpIsTStrArrayEmpty
#include <ftnfoctx.h>   // NetpMergeFtinfo


NTSTATUS
I_NetServerReqChallenge(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientChallenge,
    OUT PNETLOGON_CREDENTIAL ServerChallenge
    )
/*++

Routine Description:

    This is the client side of I_NetServerReqChallenge.

    I_NetLogonRequestChallenge is the first of two functions used by a client
    to process an authentication with a domain controller (DC).  (See
    I_NetServerAuthenticate below.)  It is called for
    a BDC (or member server) authenticating with a PDC for replication
    purposes.

    This function passes a challenge to the PDC and the PDC passes a challenge
    back to the caller.

Arguments:

    PrimaryName -- Supplies the name of the PrimaryDomainController we wish to
        authenticate with.

    ComputerName -- Name of the BDC or member server making the call.

    ClientChallenge -- 64 bit challenge supplied by the BDC or member server.

    ServerChallenge -- Receives 64 bit challenge from the PDC.

Return Value:

    The status of the operation.

--*/

{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrServerReqChallenge(
                            PrimaryName,
                            ComputerName,
                            ClientChallenge,
                            ServerChallenge );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetServerReqChallenge rc = %lu 0x%lx\n",
                      Status, Status));
    }

    return Status;
}


NTSTATUS
I_NetServerAuthenticate(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential
    )
/*++

Routine Description:

    This is the client side of I_NetServerAuthenticate

    I_NetServerAuthenticate is the second of two functions used by a client
    Netlogon service to authenticate with another Netlogon service.
    (See I_NetServerReqChallenge above.)  Both a SAM or UAS server authenticates
    using this function.

    This function passes a credential to the DC and the DC passes a credential
    back to the caller.


Arguments:

    PrimaryName -- Supplies the name of the DC we wish to authenticate with.

    AccountName -- Name of the Account to authenticate with.

    SecureChannelType -- The type of the account being accessed.  This field
        must be set to UasServerSecureChannel to indicate a call from
        downlevel (LanMan 2.x and below) BDC or member server.

    ComputerName -- Name of the BDC or member server making the call.

    ClientCredential -- 64 bit credential supplied by the BDC or member server.

    ServerCredential -- Receives 64 bit credential from the PDC.

Return Value:

    The status of the operation.

--*/
{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrServerAuthenticate(
                            PrimaryName,
                            AccountName,
                            AccountType,
                            ComputerName,
                            ClientCredential,
                            ServerCredential );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetServerAuthenticate rc = %lu 0x%lx\n",
                      Status, Status));
    }

    return Status;
}


NTSTATUS
I_NetServerAuthenticate2(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential,
    IN OUT PULONG NegotiatedFlags
    )
/*++

Routine Description:

    This is the client side of I_NetServerAuthenticate

    I_NetServerAuthenticate is the second of two functions used by a client
    Netlogon service to authenticate with another Netlogon service.
    (See I_NetServerReqChallenge above.)  Both a SAM or UAS server authenticates
    using this function.

    This function passes a credential to the DC and the DC passes a credential
    back to the caller.


Arguments:

    PrimaryName -- Supplies the name of the DC we wish to authenticate with.

    AccountName -- Name of the Account to authenticate with.

    SecureChannelType -- The type of the account being accessed.  This field
        must be set to UasServerSecureChannel to indicate a call from
        downlevel (LanMan 2.x and below) BDC or member server.

    ComputerName -- Name of the BDC or member server making the call.

    ClientCredential -- 64 bit credential supplied by the BDC or member server.

    ServerCredential -- Receives 64 bit credential from the PDC.

    NegotiatedFlags -- Specifies flags indicating what features the BDC supports.
        Returns a subset of those flags indicating what features the PDC supports.
        The PDC/BDC should ignore any bits that it doesn't understand.

Return Value:

    The status of the operation.

--*/
{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrServerAuthenticate2(
                            PrimaryName,
                            AccountName,
                            AccountType,
                            ComputerName,
                            ClientCredential,
                            ServerCredential,
                            NegotiatedFlags );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetServerAuthenticate2 rc = %lu 0x%lx\n",
                      Status, Status));
    }

    return Status;
}


NTSTATUS
I_NetServerAuthenticate3(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential,
    IN OUT PULONG NegotiatedFlags,
    OUT PULONG AccountRid
    )
/*++

Routine Description:

    This is the client side of I_NetServerAuthenticate

    I_NetServerAuthenticate is the second of two functions used by a client
    Netlogon service to authenticate with another Netlogon service.
    (See I_NetServerReqChallenge above.)  Both a SAM or UAS server authenticates
    using this function.

    This function passes a credential to the DC and the DC passes a credential
    back to the caller.


Arguments:

    PrimaryName -- Supplies the name of the DC we wish to authenticate with.

    AccountName -- Name of the Account to authenticate with.

    SecureChannelType -- The type of the account being accessed.  This field
        must be set to UasServerSecureChannel to indicate a call from
        downlevel (LanMan 2.x and below) BDC or member server.

    ComputerName -- Name of the BDC or member server making the call.

    ClientCredential -- 64 bit credential supplied by the BDC or member server.

    ServerCredential -- Receives 64 bit credential from the PDC.

    NegotiatedFlags -- Specifies flags indicating what features the BDC supports.
        Returns a subset of those flags indicating what features the PDC supports.
        The PDC/BDC should ignore any bits that it doesn't understand.

    AccountRid - Returns the relative ID of the account used for authentication.

Return Value:

    The status of the operation.

--*/
{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrServerAuthenticate3(
                            PrimaryName,
                            AccountName,
                            AccountType,
                            ComputerName,
                            ClientCredential,
                            ServerCredential,
                            NegotiatedFlags,
                            AccountRid );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetServerAuthenticate3 rc = %lu 0x%lx\n",
                      Status, Status));
    }

    return Status;
}


NTSTATUS
I_NetServerPasswordSet(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PENCRYPTED_LM_OWF_PASSWORD UasNewPassword
    )
/*++

Routine Description:

    This function is used to change the password for the account being
    used to maintain a secure channel.  This function can only be called
    by a server which has previously authenticated with a DC by calling
    I_NetServerAuthenticate.

    The call is made differently depending on the account type:

      *  A domain account password is changed from the PDC in the
         trusting domain.  The I_NetServerPasswordSet call is made to any
         DC in the trusted domain.

      *  A server account password is changed from the specific server.
         The I_NetServerPasswordSet call is made to the PDC in the domain
         the server belongs to.

      *  A workstation account password is changed from the specific
         workstation.  The I_NetServerPasswordSet call is made to a DC in
         the domain the server belongs to.

    For domain accounts and workstation accounts, the server being called
    may be a BDC in the specific domain.  In that case, the BDC will
    validate the request and pass it on to the PDC of the domain using
    the server account secure channel.  If the PDC of the domain is
    currently not available, the BDC will return STATUS_NO_LOGON_SERVERS.  Since
    the UasNewPassword is passed encrypted by the session key, such a BDC
    will decrypt the UasNewPassword using the original session key and
    will re-encrypt it with the session key for its session to its PDC
    before passing the request on.

    This function uses RPC to contact the DC named by PrimaryName.

Arguments:

    PrimaryName -- Name of the PDC to change the servers password
        with.  NULL indicates this call is a local call being made on
        behalf of a UAS server by the XACT server.

    AccountName -- Name of the account to change the password for.

    AccountType -- The type of account being accessed.  This field must
        be set to UasServerAccount to indicate a call from a downlevel

    ComputerName -- Name of the BDC or member making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    UasNewPassword -- The new password for the server. This
        Password is generated by automatic means using
        random number genertaor seeded with the current Time
        It is assumed that the machine generated password
        was used as key to encrypt STD text and "sesskey"
        obtained via Challenge/Authenticate sequence was
        used to further encrypt it before passing to this api.
        i.e. UasNewPassword = E2(E1(STD_TXT, PW), SK)

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrServerPasswordSet(
                            PrimaryName,
                            AccountName,
                            AccountType,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            UasNewPassword );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetServerPasswordSet rc = %lu 0x%lx\n",
                      Status, Status));
    }

    return Status;
}

NTSTATUS
I_NetServerPasswordSet2(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PNL_TRUST_PASSWORD ClearNewPassword
    )
/*++

Routine Description:

    This function is used to change the password for the account being
    used to maintain a secure channel.  This function can only be called
    by a server which has previously authenticated with a DC by calling
    I_NetServerAuthenticate.

    The call is made differently depending on the account type:

      *  A domain account password is changed from the PDC in the
         trusting domain.  The I_NetServerPasswordSet call is made to any
         DC in the trusted domain.

      *  A server account password is changed from the specific server.
         The I_NetServerPasswordSet call is made to the PDC in the domain
         the server belongs to.

      *  A workstation account password is changed from the specific
         workstation.  The I_NetServerPasswordSet call is made to a DC in
         the domain the server belongs to.

    For domain accounts and workstation accounts, the server being called
    may be a BDC in the specific domain.  In that case, the BDC will
    validate the request and pass it on to the PDC of the domain using
    the server account secure channel.  If the PDC of the domain is
    currently not available, the BDC will return STATUS_NO_LOGON_SERVERS.  Since
    the UasNewPassword is passed encrypted by the session key, such a BDC
    will decrypt the UasNewPassword using the original session key and
    will re-encrypt it with the session key for its session to its PDC
    before passing the request on.

    This function uses RPC to contact the DC named by PrimaryName.

Arguments:

    PrimaryName -- Name of the PDC to change the servers password
        with.  NULL indicates this call is a local call being made on
        behalf of a UAS server by the XACT server.

    AccountName -- Name of the account to change the password for.

    AccountType -- The type of account being accessed.  This field must
        be set to UasServerAccount to indicate a call from a downlevel

    ComputerName -- Name of the BDC or member making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    ClearNewPassword - The new password for the server.
        Appropriately encrypted.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrServerPasswordSet2(
                            PrimaryName,
                            AccountName,
                            AccountType,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            ClearNewPassword );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetServerPasswordSet2 rc = %lu 0x%lx\n",
                      Status, Status));
    }

    return Status;
}



NTSTATUS
I_NetDatabaseDeltas (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD DatabaseID,
    IN OUT PNLPR_MODIFIED_COUNT DomainModifiedCount,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArray,
    IN DWORD PreferredMaximumLength
    )
/*++

Routine Description:

    This function is used by a SAM BDC or SAM member server to request
    SAM-style account delta information from a SAM PDC.  This function
    can only be called by a server which has previously authenticated
    with the PDC by calling I_NetServerAuthenticate.  This function uses
    RPC to contact the Netlogon service on the PDC.

    This function returns a list of deltas.  A delta describes an
    individual domain, user or group and all of the field values for that
    object.  The PDC maintains a list of deltas not including all of the
    field values for that object.  Rather, the PDC retrieves the field
    values from SAM and returns those values from this call.  The PDC
    optimizes the data returned on this call by only returning the field
    values for a particular object once on a single invocation of this
    function.  This optimizes the typical case where multiple deltas
    exist for a single object (e.g., an application modified many fields
    of the same user during a short period of time using different calls
    to the SAM service).

Arguments:

    PrimaryName -- Name of the PDC to retrieve the deltas from.

    ComputerName -- Name of the BDC or member server making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    DomainModifiedCount -- Specifies the DomainModifiedCount of the
        last delta retrieved by the server.  Returns the
        DomainModifiedCount of the last delta returned from the PDC
        on this call.

    DeltaArray -- Receives a pointer to a buffer where the information
        is placed.  The information returned is an array of
        NETLOGON_DELTA_ENUM structures.

    PreferredMaximumLength - Preferred maximum length of returned
        data (in 8-bit bytes).  This is not a hard upper limit, but
        serves as a guide to the server.  Due to data conversion
        between systems with different natural data sizes, the actual
        amount of data returned may be greater than this value.

Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_SYNCHRONIZATION_REQUIRED -- The replicant is totally out of sync and
        should call I_NetDatabaseSync to do a full synchronization with
        the PDC.

    STATUS_MORE_ENTRIES -- The replicant should call again to get more
        data.

    STATUS_ACCESS_DENIED -- The replicant should re-authenticate with
        the PDC.


--*/
{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //
        *DeltaArray = NULL;     // Force RPC to allocate

        Status = NetrDatabaseDeltas(
                            PrimaryName,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            DatabaseID,
                            DomainModifiedCount,
                            DeltaArray,
                            PreferredMaximumLength );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    NetpKdPrint(("I_NetDatabaseDeltas rc = %lu 0x%lx\n", Status, Status));

    return Status;
}


NTSTATUS
I_NetDatabaseSync (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD DatabaseID,
    IN OUT PULONG SamSyncContext,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArray,
    IN DWORD PreferredMaximumLength
    )
/*++

Routine Description:

    This function is used by a SAM BDC or SAM member server to request
    the entire SAM database from a SAM PDC in SAM-style format.  This
    function can only be called by a server which has previously
    authenticated with the PDC by calling I_NetServerAuthenticate.  This
    function uses RPC to contact the Netlogon service on the PDC.

    This function uses the find-first find-next model to return portions
    of the SAM database at a time.  The SAM database is returned as a
    list of deltas like those returned from I_NetDatabaseDeltas.  The
    following deltas are returned for each domain:

    *  One AddOrChangeDomain delta, followed by

    *  One AddOrChangeGroup delta for each group, followed by,

    *  One AddOrChangeUser delta for each user, followed by

    *  One ChangeGroupMembership delta for each group


Arguments:

    PrimaryName -- Name of the PDC to retrieve the deltas from.

    ComputerName -- Name of the BDC or member server making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    SamSyncContext -- Specifies context needed to continue the
        operation.  The caller should treat this as an opaque
        value.  The value should be zero before the first call.

    DeltaArray -- Receives a pointer to a buffer where the information
        is placed.  The information returned is an array of
        NETLOGON_DELTA_ENUM structures.

    PreferredMaximumLength - Preferred maximum length of returned
        data (in 8-bit bytes).  This is not a hard upper limit, but
        serves as a guide to the server.  Due to data conversion
        between systems with different natural data sizes, the actual
        amount of data returned may be greater than this value.

Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_SYNCHRONIZATION_REQUIRED -- The replicant is totally out of sync and
        should call I_NetDatabaseSync to do a full synchronization with
        the PDC.

    STATUS_MORE_ENTRIES -- The replicant should call again to get more
        data.

    STATUS_ACCESS_DENIED -- The replicant should re-authenticate with
        the PDC.


--*/
{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //
        *DeltaArray = NULL;     // Force RPC to allocate

        Status = NetrDatabaseSync(
                            PrimaryName,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            DatabaseID,
                            SamSyncContext,
                            DeltaArray,
                            PreferredMaximumLength );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetDatabaseSync rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}


NTSTATUS
I_NetDatabaseSync2 (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD DatabaseID,
    IN SYNC_STATE RestartState,
    IN OUT PULONG SamSyncContext,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArray,
    IN DWORD PreferredMaximumLength
    )
/*++

Routine Description:

    This function is used by a SAM BDC or SAM member server to request
    the entire SAM database from a SAM PDC in SAM-style format.  This
    function can only be called by a server which has previously
    authenticated with the PDC by calling I_NetServerAuthenticate.  This
    function uses RPC to contact the Netlogon service on the PDC.

    This function uses the find-first find-next model to return portions
    of the SAM database at a time.  The SAM database is returned as a
    list of deltas like those returned from I_NetDatabaseDeltas.  The
    following deltas are returned for each domain:

    *  One AddOrChangeDomain delta, followed by

    *  One AddOrChangeGroup delta for each group, followed by,

    *  One AddOrChangeUser delta for each user, followed by

    *  One ChangeGroupMembership delta for each group


Arguments:

    PrimaryName -- Name of the PDC to retrieve the deltas from.

    ComputerName -- Name of the BDC or member server making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    RestartState -- Specifies whether this is a restart of the full sync and how
        to interpret SyncContext.  This value should be NormalState unless this
        is the restart of a full sync.

        However, if the caller is continuing a full sync after a reboot,
        the following values are used:

            GroupState - SyncContext is the global group rid to continue with.
            UserState - SyncContext is the user rid to continue with
            GroupMemberState - SyncContext is the global group rid to continue with
            AliasState - SyncContext should be zero to restart at first alias
            AliasMemberState - SyncContext should be zero to restart at first alias

        One cannot continue the LSA database in this way.

    SamSyncContext -- Specifies context needed to continue the
        operation.  The caller should treat this as an opaque
        value.  The value should be zero before the first call.

    DeltaArray -- Receives a pointer to a buffer where the information
        is placed.  The information returned is an array of
        NETLOGON_DELTA_ENUM structures.

    PreferredMaximumLength - Preferred maximum length of returned
        data (in 8-bit bytes).  This is not a hard upper limit, but
        serves as a guide to the server.  Due to data conversion
        between systems with different natural data sizes, the actual
        amount of data returned may be greater than this value.

Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_SYNCHRONIZATION_REQUIRED -- The replicant is totally out of sync and
        should call I_NetDatabaseSync to do a full synchronization with
        the PDC.

    STATUS_MORE_ENTRIES -- The replicant should call again to get more
        data.

    STATUS_ACCESS_DENIED -- The replicant should re-authenticate with
        the PDC.


--*/
{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //
        *DeltaArray = NULL;     // Force RPC to allocate

        Status = NetrDatabaseSync2(
                            PrimaryName,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            DatabaseID,
                            RestartState,
                            SamSyncContext,
                            DeltaArray,
                            PreferredMaximumLength );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetDatabaseSync rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}



NET_API_STATUS NET_API_FUNCTION
I_NetAccountDeltas (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PUAS_INFO_0 RecordId,
    IN DWORD Count,
    IN DWORD Level,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT PULONG CountReturned,
    OUT PULONG TotalEntries,
    OUT PUAS_INFO_0 NextRecordId
    )
/*++

Routine Description:

    This function is used by a UAS BDC or UAS member server to request
    UAS-style account change information.  This function can only be
    called by a server which has previously authenticated with the PDC by
    calling I_NetServerAuthenticate.

    This function is only called by the XACT server upon receipt of a
    I_NetAccountDeltas XACT SMB from a UAS BDC or a UAS member server.
    As such, many of the parameters are opaque since the XACT server
    doesn't need to interpret any of that data.  This function uses RPC
    to contact the Netlogon service.

    The LanMan 3.0 SSI Functional Specification describes the operation
    of this function.

Arguments:

    PrimaryName -- Must be NULL to indicate this call is a local call
        being made on behalf of a UAS server by the XACT server.

    ComputerName -- Name of the BDC or member making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    RecordId -- Supplies an opaque buffer indicating the last record
        received from a previous call to this function.

    Count -- Supplies the number of Delta records requested.

    Level -- Reserved.  Must be zero.

    Buffer -- Returns opaque data representing the information to be
        returned.

    BufferSize -- Size of buffer in bytes.

    CountReturned -- Returns the number of records returned in buffer.

    TotalEntries -- Returns the total number of records available.

    NextRecordId -- Returns an opaque buffer identifying the last
        record received by this function.


Return Value:

    Status code

--*/
{
    NET_API_STATUS NetStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        NetStatus = NetrAccountDeltas (
                     PrimaryName,
                     ComputerName,
                     Authenticator,
                     ReturnAuthenticator,
                     RecordId,
                     Count,
                     Level,
                     Buffer,
                     BufferSize,
                     CountReturned,
                     TotalEntries,
                     NextRecordId );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetAccountDeltas rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}



NET_API_STATUS NET_API_FUNCTION
I_NetAccountSync (
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD Reference,
    IN DWORD Level,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT PULONG CountReturned,
    OUT PULONG TotalEntries,
    OUT PULONG NextReference,
    OUT PUAS_INFO_0 LastRecordId
    )
/*++

Routine Description:

    This function is used by a UAS BDC or UAS member server to request
    the entire user accounts database.  This function can only be called
    by a server which has previously authenticated with the PDC by
    calling I_NetServerAuthenticate.

    This function is only called by the XACT server upon receipt of a
    I_NetAccountSync XACT SMB from a UAS BDC or a UAS member server.  As
    such, many of the parameters are opaque since the XACT server doesn't
    need to interpret any of that data.  This function uses RPC to
    contact the Netlogon service.

    The LanMan 3.0 SSI Functional Specification describes the operation
    of this function.

    "Reference" and "NextReference" are treated as below.

    1. "Reference" should hold either 0 or value of "NextReference"
       from previous call to this API.
    2. Send the modals and ALL group records in the first call. The API
       expects the bufffer to be large enough to hold this info (worst
       case size would be
            MAXGROUP * (sizeof(struct group_info_1) + MAXCOMMENTSZ)
                     + sizeof(struct user_modals_info_0)
       which, for now, will be 256 * (26 + 49) + 16 = 19216 bytes

Arguments:

    PrimaryName -- Must be NULL to indicate this call is a local call
        being made on behalf of a UAS server by the XACT server.

    ComputerName -- Name of the BDC or member making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    Reference -- Supplies find-first find-next handle returned by the
        previous call to this function or 0 if it is the first call.

    Level -- Reserved.  Must be zero.

    Buffer -- Returns opaque data representing the information to be
        returned.

    BufferLen -- Length of buffer in bytes.

    CountReturned -- Returns the number of records returned in buffer.

    TotalEntries -- Returns the total number of records available.

    NextReference -- Returns a find-first find-next handle to be
        provided on the next call.

    LastRecordId -- Returns an opaque buffer identifying the last
        record received by this function.


Return Value:

    Status code.

--*/

{
    NET_API_STATUS NetStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        NetStatus = NetrAccountSync (
                     PrimaryName,
                     ComputerName,
                     Authenticator,
                     ReturnAuthenticator,
                     Reference,
                     Level,
                     Buffer,
                     BufferSize,
                     CountReturned,
                     TotalEntries,
                     NextReference,
                     LastRecordId );


    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetAccountSync rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}




NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    OUT LPBYTE *QueryInformation
    )

/*++

Routine Description:

    This function controls various aspects of the Netlogon service.  It
    can be used to request that a BDC ensure that its copy of the SAM
    database is brought up to date.  It can, also, be used to determine
    if a BDC currently has a secure channel open to the PDC.

    Only an Admin, Account Operator or Server Operator may call this
    function.

Arguments:

    ServerName - The name of the remote server.

    FunctionCode - Defines the operation to be performed.  The valid
        values are:

        FunctionCode Values

        NETLOGON_CONTROL_QUERY - No operation.  Merely returns the
            information requested.

        NETLOGON_CONTROL_REPLICATE: Forces the SAM database on a BDC
            to be brought in sync with the copy on the PDC.  This
            operation does NOT imply a full synchronize.  The
            Netlogon service will merely replicate any outstanding
            differences if possible.

        NETLOGON_CONTROL_SYNCHRONIZE: Forces a BDC to get a
            completely new copy of the SAM database from the PDC.
            This operation will perform a full synchronize.

        NETLOGON_CONTROL_PDC_REPLICATE: Forces a PDC to ask each BDC
            to replicate now.

    QueryLevel - Indicates what information should be returned from
        the Netlogon Service.  Must be 1.

    QueryInformation - Returns a pointer to a buffer which contains the
        requested information.  The buffer must be freed using
        NetApiBufferFree.


Return Value:

    NERR_Success: the operation was successful

    ERROR_NOT_SUPPORTED: Function code is not valid on the specified
        server.  (e.g. NETLOGON_CONTROL_REPLICATE was passed to a PDC).

--*/
{
    NET_API_STATUS NetStatus;
    NETLOGON_CONTROL_QUERY_INFORMATION RpcQueryInformation;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        RpcQueryInformation.NetlogonInfo1 = NULL;   // Force RPC to allocate

        NetStatus = NetrLogonControl (
                        (LPWSTR) ServerName OPTIONAL,
                        FunctionCode,
                        QueryLevel,
                        &RpcQueryInformation );

        *QueryInformation = (LPBYTE) RpcQueryInformation.NetlogonInfo1;


    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonControl rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}


NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl2(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    IN LPBYTE InputData,
    OUT LPBYTE *QueryInformation
    )

/*++

Routine Description:

    This is similar to the I_NetLogonControl function but it accepts
    more generic input data according to the function code specified.

    This function controls various aspects of the Netlogon service.  It
    can be used to request that a BDC ensure that its copy of the SAM
    database is brought up to date.  It can, also, be used to determine
    if a BDC currently has a secure channel open to the PDC.

    Only an Admin, Account Operator or Server Operator may call this
    function.

Arguments:

    ServerName - The name of the remote server.

    FunctionCode - Defines the operation to be performed.  The valid
        values are:

        FunctionCode Values

        NETLOGON_CONTROL_QUERY - No operation.  Merely returns the
            information requested.

        NETLOGON_CONTROL_REPLICATE: Forces the SAM database on a BDC
            to be brought in sync with the copy on the PDC.  This
            operation does NOT imply a full synchronize.  The
            Netlogon service will merely replicate any outstanding
            differences if possible.

        NETLOGON_CONTROL_SYNCHRONIZE: Forces a BDC to get a
            completely new copy of the SAM database from the PDC.
            This operation will perform a full synchronize.

        NETLOGON_CONTROL_PDC_REPLICATE: Forces a PDC to ask each BDC
            to replicate now.

        NETLOGON_CONTROL_REDISCOVER: Forces a DC to rediscover the
            specified trusted domain DC.

        NETLOGON_CONTROL_TC_QUERY: Query the status of the specified
            trusted domain secure channel.

        NETLOGON_CONTROL_TC_VERIFY: Verify the status of the specified
            trusted domain secure channel. If the current status is
            success (which means that the last operation performed
            over the secure channel was successful), ping the DC. If the
            current status is not success or the ping fails, rediscover
            a new DC.

        NETLOGON_CONTROL_CHANGE_PASSWORD: Forces a password change on
            a secure channel to a trusted domain.

        NETLOGON_CONTROL_FORCE_DNS_REG: Forces the DC to re-register all
            of its DNS records.  QueryLevel parameter must be 1.

        NETLOGON_CONTROL_QUERY_DNS_REG: Query the status of DNS updates
            performed by netlogon. If there was any DNS registration or
            deregistration error for any of the records as they were
            updated last time, the query result will be negative;
            otherwise the query result will be positive.
            QueryLevel parameter must be 1.

    QueryLevel - Indicates what information should be returned from
        the Netlogon Service.

    InputData - According to the function code specified this parameter
        will carry input data. NETLOGON_CONTROL_REDISCOVER and
        NETLOGON_CONTROL_TC_QUERY function code specify the trusted
        domain name (LPWSTR type) here.

    QueryInformation - Returns a pointer to a buffer which contains the
        requested information.  The buffer must be freed using
        NetApiBufferFree.


Return Value:

    NERR_Success: the operation was successful

    ERROR_NOT_SUPPORTED: Function code is not valid on the specified
        server.  (e.g. NETLOGON_CONTROL_REPLICATE was passed to a PDC).

--*/
{
    NET_API_STATUS NetStatus;
    NETLOGON_CONTROL_QUERY_INFORMATION RpcQueryInformation;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //
        //  Use new Control2Ex if either QueryLevel or FunctionCode is new
        //

        RpcQueryInformation.NetlogonInfo1 = NULL;   // Force RPC to allocate

        switch ( FunctionCode ) {
        case NETLOGON_CONTROL_QUERY:
        case NETLOGON_CONTROL_REPLICATE:
        case NETLOGON_CONTROL_SYNCHRONIZE:
        case NETLOGON_CONTROL_PDC_REPLICATE:
        case NETLOGON_CONTROL_REDISCOVER:
        case NETLOGON_CONTROL_TC_QUERY:
        case NETLOGON_CONTROL_TRANSPORT_NOTIFY:
        case NETLOGON_CONTROL_BACKUP_CHANGE_LOG:
        case NETLOGON_CONTROL_TRUNCATE_LOG:
        case NETLOGON_CONTROL_SET_DBFLAG:
        case NETLOGON_CONTROL_BREAKPOINT:

            if ( QueryLevel >= 1 && QueryLevel <= 3 ) {
                NetStatus = NetrLogonControl2 (
                                (LPWSTR) ServerName OPTIONAL,
                                FunctionCode,
                                QueryLevel,
                                (PNETLOGON_CONTROL_DATA_INFORMATION)InputData,
                                &RpcQueryInformation );
            } else if ( QueryLevel == 4 ) {
                NetStatus = NetrLogonControl2Ex (
                                (LPWSTR) ServerName OPTIONAL,
                                FunctionCode,
                                QueryLevel,
                                (PNETLOGON_CONTROL_DATA_INFORMATION)InputData,
                                &RpcQueryInformation );
            } else {
                NetStatus = ERROR_INVALID_LEVEL;
            }
            break;
        case NETLOGON_CONTROL_FIND_USER:
        case NETLOGON_CONTROL_UNLOAD_NETLOGON_DLL:
        case NETLOGON_CONTROL_CHANGE_PASSWORD:
        case NETLOGON_CONTROL_TC_VERIFY:
        case NETLOGON_CONTROL_FORCE_DNS_REG:
        case NETLOGON_CONTROL_QUERY_DNS_REG:

            if ( QueryLevel >= 1 && QueryLevel <= 4 ) {
                NetStatus = NetrLogonControl2Ex (
                                (LPWSTR) ServerName OPTIONAL,
                                FunctionCode,
                                QueryLevel,
                                (PNETLOGON_CONTROL_DATA_INFORMATION)InputData,
                                &RpcQueryInformation );
            } else {
                NetStatus = ERROR_INVALID_LEVEL;
            }
            break;
        default:
            NetStatus = ERROR_INVALID_LEVEL;
        }

        *QueryInformation = (LPBYTE) RpcQueryInformation.NetlogonInfo1;

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonControl rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}


NTSTATUS
I_NetDatabaseRedo(
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN LPBYTE ChangeLogEntry,
    IN DWORD ChangeLogEntrySize,
    OUT PNETLOGON_DELTA_ENUM_ARRAY *DeltaArray
    )
/*++

Routine Description:

    This function is used by a SAM BDC to request infomation about a single
    account. This function can only be called by a server which has previously
    authenticated with the PDC by calling I_NetServerAuthenticate.  This
    function uses RPC to contact the Netlogon service on the PDC.

Arguments:

    PrimaryName -- Name of the PDC to retrieve the delta from.

    ComputerName -- Name of the BDC making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    ChangeLogEntry -- A description of the account to be queried.

    ChangeLogEntrySize -- Size (in bytes) of the ChangeLogEntry.

    DeltaArray -- Receives a pointer to a buffer where the information
        is placed.  The information returned is an array of
        NETLOGON_DELTA_ENUM structures.

Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_ACCESS_DENIED -- The replicant should re-authenticate with
        the PDC.

--*/
{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //
        *DeltaArray = NULL;     // Force RPC to allocate

        Status = NetrDatabaseRedo(
                            PrimaryName,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            ChangeLogEntry,
                            ChangeLogEntrySize,
                            DeltaArray );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetDatabaseSync rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}


NTSTATUS
NetEnumerateTrustedDomains (
    IN LPWSTR ServerName OPTIONAL,
    OUT LPWSTR *DomainNames
    )

/*++

Routine Description:

    This API returns the names of the domains trusted by the domain ServerName is a member of.
    ServerName must be an NT workstation or NT non-DC server.

    The returned list does not include the domain ServerName is directly a member of.

    Netlogon implements this API by calling LsaEnumerateTrustedDomains on a DC in the
    domain ServerName is a member of.  However, Netlogon returns cached information if
    it has been less than 5 minutes since the last call was made or if no DC is available.
    Netlogon's cache of Trusted domain names is maintained in the registry across reboots.
    As such, the list is available upon boot even if no DC is available.


Arguments:

    ServerName - name of remote server (null for local).  ServerName must be an NT workstation
        or NT non-DC server.

    DomainNames - Returns an allocated buffer containing the list of trusted domains in
        MULTI-SZ format (i.e., each string is terminated by a zero character, the next string
        immediately follows, the sequence is terminated by zero length domain name).  The
        buffer should be freed using NetApiBufferFree.

Return Value:


    ERROR_SUCCESS - Success.

    STATUS_NOT_SUPPORTED - ServerName is not an NT workstation or NT non-DC server.

    STATUS_NO_LOGON_SERVERS - No DC could be found and no cached information is available.

    STATUS_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken and no cached information is available.

    STATUS_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken and no cached information is available.

--*/
{
    NTSTATUS Status = 0;
    DOMAIN_NAME_BUFFER DomainNameBuffer;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //
        DomainNameBuffer.DomainNameByteCount = 0;
        DomainNameBuffer.DomainNames = NULL;     // Force RPC to allocate

        Status = NetrEnumerateTrustedDomains(
                            ServerName,
                            &DomainNameBuffer );

        if ( NT_SUCCESS(Status) ) {
            *DomainNames = (LPWSTR) DomainNameBuffer.DomainNames;
        }

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("NetEnumerateDomainNames rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}


NET_API_STATUS NET_API_FUNCTION
NlpEnumerateNt4DomainTrusts (
    IN LPWSTR ServerName OPTIONAL,
    IN ULONG Flags,
    OUT PDS_DOMAIN_TRUSTSW *Domains,
    OUT PULONG DomainCount
    )

/*++

Routine Description:

    This API returns the names of the domains trusted by the domain ServerName
    is a member of. ServerName is an NT4 machine.

    Netlogon's cache of Trusted domain names is maintained in a file across reboots.
    As such, the list is available upon boot even if no DC is available.


Arguments:

    ServerName - name of remote server (null for local).

    Flags - Specifies attributes of trusts which should be returned. These are the flags
        of the DS_DOMAIN_TRUSTSW strusture.  If a trust entry has any of the bits specified
        in Flags set, it will be returned.

    Domains - Returns an array of trusted domains.
        Buffer must be free using NetApiBufferFree().

    DomainCount - Returns a count of the number elements in the Domains array.

Return Value:


    NO_ERROR - Success.

    ERROR_NO_LOGON_SERVERS - No DC could be found and no cached information is available.

    ERROR_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken and no cached information is available.

    ERROR_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken and no cached information is available.

    ERROR_INVALID_FLAGS - The Flags parameter has invalid bit(s) set.

    ERROR_NOT_SUPPORTED - The server specified is not capable of returning the domain
        trusts requested.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    NTSTATUS Status;
    BUFFER_DESCRIPTOR BufferDescriptor;
    ULONG LocalDomainCount;
    LSA_HANDLE LsaHandle = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;
    LPWSTR DomainNames = NULL;
    PDS_DOMAIN_TRUSTSW TrustedDomain;
    ULONG DummySize;

    //
    // Initialization
    //

    BufferDescriptor.Buffer = NULL;
    LocalDomainCount = 0;
    *Domains = NULL;
    *DomainCount = 0;

    //
    // Validate Flags
    //

    if ( (Flags & DS_DOMAIN_VALID_FLAGS) == 0 ||
         (Flags & ~DS_DOMAIN_VALID_FLAGS) != 0 ) {
        NetStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }

    //
    // This routine uses old APIs which are not capable of returning
    // directly trusting domains.  So error out if such trusts are requested.
    //

    if ( (Flags & DS_DOMAIN_DIRECT_INBOUND) != 0 ) {
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // NetEnumerateTrustedDomains targeted at NT4 server returns directly
    // trusted domains only.  So call it only if such domains are requested.
    // Nothing will be returned for domains in forest if such were requested.
    //

    if ( Flags & DS_DOMAIN_DIRECT_OUTBOUND ) {
        LPTSTR_ARRAY TStrArray;

        Status = NetEnumerateTrustedDomains (
                            ServerName,
                            &DomainNames );

        if (!NT_SUCCESS(Status)) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            if ( NetStatus == RPC_S_PROCNUM_OUT_OF_RANGE ) {
                NetStatus = ERROR_NOT_SUPPORTED;
            }
            goto Cleanup;
        }

        //
        // Handle each trusted domain.
        //

        TStrArray = (LPTSTR_ARRAY) DomainNames;
        while ( !NetpIsTStrArrayEmpty(TStrArray) ) {
            UNICODE_STRING CurrentNetbiosDomainName;

            //
            // Add the domain to the list
            //
            RtlInitUnicodeString( &CurrentNetbiosDomainName, TStrArray );

            Status = NlAllocateForestTrustListEntry (
                                &BufferDescriptor,
                                &CurrentNetbiosDomainName,
                                NULL,   // No DNS domain name
                                DS_DOMAIN_DIRECT_OUTBOUND,
                                0,      // No ParentIndex
                                TRUST_TYPE_DOWNLEVEL,
                                0,      // No TrustAttributes
                                NULL,   // No Domain Sid
                                NULL,   // No DomainGuid
                                &DummySize,
                                &TrustedDomain );

            if ( !NT_SUCCESS(Status) ) {
                NetStatus = NetpNtStatusToApiStatus( Status );
                goto Cleanup;
            }

            //
            // Account for the newly allocated entry
            //

            LocalDomainCount ++;

            //
            // Move to the next entry
            //

            TStrArray = NetpNextTStrArrayEntry( TStrArray );
        }
    }

    //
    // NetEnumerateDomainTrusts doesn't return primary domain
    // in the list of trusted domains.  If the primary domain
    // is requested, add it here using info from LSA.
    //

    if ( Flags & DS_DOMAIN_PRIMARY ) {
        UNICODE_STRING UncServerNameString;
        OBJECT_ATTRIBUTES ObjectAttributes;

        //
        // First, open the policy database on the server.
        //

        RtlInitUnicodeString( &UncServerNameString, ServerName );

        InitializeObjectAttributes( &ObjectAttributes, NULL, 0,  NULL, NULL );

        Status = LsaOpenPolicy( &UncServerNameString,
                                &ObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &LsaHandle );

        if ( !NT_SUCCESS(Status) ) {
            LsaHandle = NULL;
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        //
        // Get the name of the primary domain from LSA
        //

        Status = LsaQueryInformationPolicy(
                       LsaHandle,
                       PolicyPrimaryDomainInformation,
                       (PVOID *) &PrimaryDomainInfo
                       );

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        //
        //  Now, add it to our list here.
        //

        Status = NlAllocateForestTrustListEntry (
                            &BufferDescriptor,
                            &PrimaryDomainInfo->Name,
                            NULL,   // No DNS domain name
                            DS_DOMAIN_PRIMARY,
                            0,      // No ParentIndex
                            TRUST_TYPE_DOWNLEVEL,
                            0,      // No TrustAttributes
                            PrimaryDomainInfo->Sid,
                            NULL,   // No DomainGuid
                            &DummySize,
                            &TrustedDomain );

        if ( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }

        //
        // And account for the newly allocated entry.
        //

        LocalDomainCount ++;
    }

    //
    // If we made it up to this point, it's a success!
    //

    NetStatus = NO_ERROR;

Cleanup:

    if ( DomainNames != NULL) {
        NetApiBufferFree( DomainNames );
    }

    if ( LsaHandle != NULL ) {
        (VOID) LsaClose( LsaHandle );
    }

    if ( PrimaryDomainInfo != NULL ) {
        (void) LsaFreeMemory( PrimaryDomainInfo );
    }

    //
    // Return the trusted domain list
    //

    if ( NetStatus == NO_ERROR ) {
        *Domains = (PDS_DOMAIN_TRUSTSW)BufferDescriptor.Buffer;
        *DomainCount = LocalDomainCount;
    } else {
        if ( BufferDescriptor.Buffer != NULL ) {
            NetApiBufferFree( BufferDescriptor.Buffer );
        }
        *Domains = NULL;
        *DomainCount = 0;
    }

    return NetStatus;
}


NET_API_STATUS NET_API_FUNCTION
DsEnumerateDomainTrustsW (
    IN LPWSTR ServerName OPTIONAL,
    IN ULONG Flags,
    OUT PDS_DOMAIN_TRUSTSW *Domains,
    OUT PULONG DomainCount
    )

/*++

Routine Description:

    This API returns the names of the domains trusting and trusted by the domain ServerName
    is a member of.

    Netlogon's cache of Trusted domain names is maintained in a file across reboots.
    As such, the list is available upon boot even if no DC is available.


Arguments:

    ServerName - name of remote server (null for local).

    Flags - Specifies attributes of trusts which should be returned. These are the flags
        of the DS_DOMAIN_TRUSTSW strusture.  If a trust entry has any of the bits specified
        in Flags set, it will be returned.

    Domains - Returns an array of trusted domains.
        Buffer must be free using NetApiBufferFree().

    DomainCount - Returns a count of the number elements in the Domains array.

Return Value:


    NO_ERROR - Success.

    ERROR_NO_LOGON_SERVERS - No DC could be found and no cached information is available.

    ERROR_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken and no cached information is available.

    ERROR_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken and no cached information is available.

    ERROR_INVALID_FLAGS - The Flags parameter has invalid bit(s) set.

    ERROR_NOT_SUPPORTED - The server specified is not capable of returning the domain
        trusts requested.

--*/
{
    NET_API_STATUS NetStatus;
    NETLOGON_TRUSTED_DOMAIN_ARRAY LocalDomains;

    //
    // Validate the Flags parameter
    //

    if ( (Flags & DS_DOMAIN_VALID_FLAGS) == 0 ||
         (Flags & ~DS_DOMAIN_VALID_FLAGS) != 0 ) {
        return ERROR_INVALID_FLAGS;
    }

    //
    // Initialization
    //

    *DomainCount = 0;
    *Domains = NULL;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        LocalDomains.Domains = NULL;
        LocalDomains.DomainCount = 0;

        NetStatus = DsrEnumerateDomainTrusts (
                        ServerName,
                        Flags,
                        &LocalDomains );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    if ( NetStatus == NO_ERROR ) {
        *Domains = LocalDomains.Domains;
        *DomainCount = LocalDomains.DomainCount;

    //
    // Handle the case where the server is an NT4 machine
    //

    } else if ( NetStatus == RPC_S_PROCNUM_OUT_OF_RANGE ) {

        NetStatus = NlpEnumerateNt4DomainTrusts (
                        ServerName,
                        Flags,
                        Domains,
                        DomainCount );

    }

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("DsEnumerateDomainTrustsW rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}


NET_API_STATUS NET_API_FUNCTION
DsEnumerateDomainTrustsA (
    IN LPSTR ServerName OPTIONAL,
    IN ULONG Flags,
    OUT PDS_DOMAIN_TRUSTSA *Domains,
    OUT PULONG DomainCount
    )

/*++

Routine Description:

    This API returns the names of the domains trusting and trusted by the domain ServerName
    is a member of.

    Netlogon's cache of Trusted domain names is maintained in a file across reboots.
    As such, the list is available upon boot even if no DC is available.


Arguments:

    ServerName - name of remote server (null for local).

    Flags - Specifies attributes of trusts which should be returned. These are the flags
        of the DS_DOMAIN_TRUSTSW strusture.  If a trust entry has any of the bits specified
        in Flags set, it will be returned.

    Domains - Returns an array of trusted domains.
        Buffer must be free using NetApiBufferFree().

    DomainCount - Returns a count of the number elements in the Domains array.

    ERROR_NOT_SUPPORTED - The server specified is not capable of returning the domain
        trusts requested.

Return Value:


    NO_ERROR - Success.

    ERROR_NO_LOGON_SERVERS - No DC could be found and no cached information is available.

    ERROR_NO_TRUST_LSA_SECRET - The client side of the trust relationship is
        broken and no cached information is available.

    ERROR_NO_TRUST_SAM_ACCOUNT - The server side of the trust relationship is
        broken or the password is broken and no cached information is available.

    ERROR_INVALID_FLAGS - The Flags parameter has invalid bit(s) set.

--*/
{
    NET_API_STATUS NetStatus;
    PDS_DOMAIN_TRUSTSW DomainsW = NULL;
    LPWSTR UnicodeServerName = NULL;
    LPSTR  *TmpNetbiosDomainNameArray = NULL;
    LPSTR  *TmpDnsDomainNameArray = NULL;

    ULONG Size;
    ULONG NameSize;
    ULONG i;

    LPBYTE Where;

    //
    // Initialization
    //
    *Domains = NULL;
    *DomainCount = 0;

    //
    // Convert input parameters to Unicode.
    //
    if ( ServerName != NULL ) {
        UnicodeServerName = NetpAllocWStrFromAStr( ServerName );

        if ( UnicodeServerName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Call the Unicode version of the API
    //

    NetStatus = DsEnumerateDomainTrustsW ( UnicodeServerName,
                                           Flags,
                                           &DomainsW,
                                           DomainCount );

    if ( NetStatus != NO_ERROR || *DomainCount == 0 ) {
        goto Cleanup;
    }

    //
    // Allocate the buffer to return to the caller
    //
    // First allocate temprory ANSI arrays to store the domain names.  This is needed
    // because there is no easy way to compute the size of ANSI names other than to
    // allocate them from Unicode strings and then compute the sizes of the resulting
    // ANSI strings.
    //

    NetStatus = NetApiBufferAllocate( (*DomainCount)*sizeof(LPSTR),
                                      (LPVOID *) &TmpNetbiosDomainNameArray );
    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }
    NetStatus = NetApiBufferAllocate( (*DomainCount)*sizeof(LPSTR),
                                      (LPVOID *) &TmpDnsDomainNameArray );
    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    RtlZeroMemory( TmpNetbiosDomainNameArray, (*DomainCount)*sizeof(LPSTR) );
    RtlZeroMemory( TmpDnsDomainNameArray, (*DomainCount)*sizeof(LPSTR) );

    Size = 0;
    for ( i = 0; i < *DomainCount; i++ ) {

        Size += sizeof(DS_DOMAIN_TRUSTSA);

        //
        // Add the size of the Netbios domain name
        //
        if ( DomainsW[i].NetbiosDomainName != NULL ) {
            TmpNetbiosDomainNameArray[i] = NetpAllocAStrFromWStr( DomainsW[i].NetbiosDomainName );
            if ( TmpNetbiosDomainNameArray[i] == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            Size += lstrlenA( TmpNetbiosDomainNameArray[i] ) + 1;
        } else {
            TmpNetbiosDomainNameArray[i] = NULL;
        }

        //
        // Add the size of the DNS domain name
        //
        if ( DomainsW[i].DnsDomainName != NULL ) {
            TmpDnsDomainNameArray[i] = NetpAllocAStrFromWStr( DomainsW[i].DnsDomainName );
            if ( TmpDnsDomainNameArray[i] == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            Size += lstrlenA( TmpDnsDomainNameArray[i] ) + 1;
        } else {
            TmpDnsDomainNameArray[i] = NULL;
        }

        //
        // Add the size of the SID
        //
        if ( DomainsW[i].DomainSid != NULL ) {
            Size += RtlLengthSid( DomainsW[i].DomainSid );
        }

        Size = ROUND_UP_COUNT( Size, ALIGN_DWORD );
    }

    NetStatus = NetApiBufferAllocate( Size, Domains );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Loop copying domains to the caller.
    //

    Where = (LPBYTE) &((*Domains)[*DomainCount]);
    for ( i = 0; i < *DomainCount; i++) {
        NTSTATUS Status;

        //
        // Copy constant length variables
        //
        (*Domains)[i].Flags = DomainsW[i].Flags;
        (*Domains)[i].ParentIndex = DomainsW[i].ParentIndex;
        (*Domains)[i].TrustType = DomainsW[i].TrustType;
        (*Domains)[i].TrustAttributes = DomainsW[i].TrustAttributes;
        (*Domains)[i].DomainGuid = DomainsW[i].DomainGuid;

        //
        // Copy the (DWORD aligned) SID into the return buffer
        //
        if ( DomainsW[i].DomainSid != NULL ) {
            ULONG SidSize;
            (*Domains)[i].DomainSid = (PSID) Where;
            SidSize = RtlLengthSid( DomainsW[i].DomainSid );
            RtlCopyMemory( Where,
                           DomainsW[i].DomainSid,
                           SidSize );
            Where += SidSize;
        } else {
            (*Domains)[i].DomainSid = NULL;
        }

        //
        // Copy the Netbios domain name into the return buffer.
        //
        if ( DomainsW[i].NetbiosDomainName != NULL ) {
            NameSize = lstrlenA( TmpNetbiosDomainNameArray[i] ) + 1;
            (*Domains)[i].NetbiosDomainName = (LPSTR) Where;
            RtlCopyMemory( Where,
                           TmpNetbiosDomainNameArray[i],
                           NameSize );
            Where += NameSize;
        } else {
            (*Domains)[i].NetbiosDomainName = NULL;
        }

        //
        // Copy the DNS domain name into the return buffer.
        //
        if ( DomainsW[i].DnsDomainName != NULL ) {
            NameSize = lstrlenA( TmpDnsDomainNameArray[i] ) + 1;
            (*Domains)[i].DnsDomainName = (LPSTR) Where;
            RtlCopyMemory( Where,
                           TmpDnsDomainNameArray[i],
                           NameSize );
            Where += NameSize;
        } else {
            (*Domains)[i].DnsDomainName = NULL;
        }


        Where = ROUND_UP_POINTER( Where, ALIGN_DWORD);

    }

Cleanup:

    if ( DomainsW != NULL ) {
        NetApiBufferFree( DomainsW );
    }

    if ( UnicodeServerName != NULL ) {
        NetApiBufferFree( UnicodeServerName );
    }

    if ( TmpNetbiosDomainNameArray != NULL ) {
        for ( i = 0; i < *DomainCount; i++ ) {
            if ( TmpNetbiosDomainNameArray[i] != NULL ) {
                NetApiBufferFree( TmpNetbiosDomainNameArray[i] );
            }
        }
        NetApiBufferFree( TmpNetbiosDomainNameArray );
    }

    if ( TmpDnsDomainNameArray != NULL ) {
        for ( i = 0; i < *DomainCount; i++ ) {
            if ( TmpDnsDomainNameArray[i] != NULL ) {
                NetApiBufferFree( TmpDnsDomainNameArray[i] );
            }
        }
        NetApiBufferFree( TmpDnsDomainNameArray );
    }

    if ( NetStatus != NO_ERROR && *Domains != NULL ) {
        NetApiBufferFree( *Domains );
        *Domains = NULL;
        *DomainCount = 0;
    }

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("DsEnumerateDomainTrustsA rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}


NTSTATUS
I_NetLogonGetDomainInfo(
    IN LPWSTR ServerName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD QueryLevel,
    IN LPBYTE InBuffer,
    OUT LPBYTE *OutBuffer
    )
/*++

Routine Description:

    This function is used by an NT workstation to query information about the
    domain it is a member of.

Arguments:

    ServerName -- Name of the DC to retrieve the data from.

    ComputerName -- Name of the workstation making the call.

    Authenticator -- supplied by the workstation.

    ReturnAuthenticator -- Receives an authenticator returned by the DC.

    QueryLevel - Level of information to return from the DC. Valid values are:

        1: Return NETLOGON_DOMAIN_INFO structure.

    InBuffer - Buffer to pass to DC

    OutBuffer - Returns a pointer to an allocated buffer containing the queried
        information.


Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_ACCESS_DENIED -- The workstations should re-authenticate with
        the DC.

--*/
{
    NTSTATUS Status = 0;
    NETLOGON_DOMAIN_INFORMATION  NetlogonDomainInfo;
    NETLOGON_WORKSTATION_INFORMATION  NetlogonWorkstationInfo;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    *OutBuffer = NULL;

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //
        NetlogonDomainInfo.DomainInfo = NULL;  // Force RPC to allocate
        NetlogonWorkstationInfo.WorkstationInfo = (PNETLOGON_WORKSTATION_INFO)InBuffer;

        Status = NetrLogonGetDomainInfo(
                            ServerName,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            QueryLevel,
                            &NetlogonWorkstationInfo,
                            &NetlogonDomainInfo );

        if ( NT_SUCCESS(Status) ) {
            *OutBuffer = (LPBYTE) NetlogonDomainInfo.DomainInfo;
        }

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonGetDomainInfo rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}

NTSTATUS
NetLogonSetServiceBits(
    IN LPWSTR ServerName,
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    )

/*++

Routine Description:

    Inidcates whether this DC is currently running the specified service.

    For instance,

        NetLogonSetServiceBits( DS_KDC_FLAG, DS_KDC_FLAG );

    tells Netlogon the KDC is running.  And

        NetLogonSetServiceBits( DS_KDC_FLAG, 0 );

    tells Netlogon the KDC is not running.

    This out of proc API can set only a certain set of bits:
        DS_TIMESERV_FLAG
        DS_GOOD_TIMESERV_FLAG

    If other bits are attempted to be set, access denied is returned.

Arguments:

    ServerName -- Name of the DC to retrieve the data from.

    ServiceBitsOfInterest - A mask of the service bits being changed, set,
        or reset by this call.  Only the following flags are valid:

            DS_KDC_FLAG
            DS_DS_FLAG
            DS_TIMESERV_FLAG

    ServiceBits - A mask indicating what the bits specified by ServiceBitsOfInterest
        should be set to.


Return Value:

    STATUS_SUCCESS - Success.

    STATUS_INVALID_PARAMETER - The parameters have extaneous bits set.

--*/
{
    NTSTATUS Status = 0;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrLogonSetServiceBits(
                            ServerName,
                            ServiceBitsOfInterest,
                            ServiceBits );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("NetLogonSetServiceBits rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}


NET_API_STATUS NET_API_FUNCTION
I_NetlogonGetTrustRid(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DomainName OPTIONAL,
    OUT PULONG Rid
    )

/*++

Routine Description:

    Returns the Rid of the account that ServerName uses in its secure channel to DomainName.

    Only an Admin or LocalSystem or LocalService may call this function.

Arguments:

    ServerName - The name of the remote server.

    DomainName - The name (DNS or Netbios) of the domain the trust is to.
        NULL implies the domain the machine is a member of.

    Rid - Rid is the RID of the account in the specified domain that represents the
        trust relationship between the ServerName and DomainName.


Return Value:

    NERR_Success: the operation was successful


--*/
{
    NET_API_STATUS NetStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        NetStatus = NetrLogonGetTrustRid (
                                ServerName,
                                DomainName,
                                Rid );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonGetTrustRid rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}


NET_API_STATUS NET_API_FUNCTION
I_NetlogonComputeServerDigest(
    IN LPWSTR ServerName OPTIONAL,
    IN ULONG Rid,
    IN LPBYTE Message,
    IN ULONG MessageSize,
    OUT CHAR NewMessageDigest[NL_DIGEST_SIZE],
    OUT CHAR OldMessageDigest[NL_DIGEST_SIZE]
    )

/*++

Routine Description:

    Compute the message digest for Message on the server.

    A digest is computed given the message and the password used on
    the account identified by teh account RID. Since there may be up
    to 2 passwords on the account (for interdomain trust), this routine
    returns 2 digets corresponding to the 2 passwords.  If the account
    has just one password on the server side (true for any account other
    than the intedomain trust account) or the two passwords are the same
    the 2 digests returned will be identical.

    Only an Admin or LocalSystem or LocalService may call this function.

Arguments:

    ServerName - The name of the remote server.

    Rid - The RID of the account to create the digest for.
        The RID must be the RID of a machine account or the API returns an error.

    Message - The message to compute the digest for.

    MessageSize - The size of Message in bytes.

    NewMessageDigest - Returns the 128-bit digest of the message corresponding to
        the new account password.

    OldMessageDigest - Returns the 128-bit digest of the message corresponding to
        the old account password.

Return Value:

    NERR_Success: the operation was successful


--*/
{
    NET_API_STATUS NetStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        NetStatus = NetrLogonComputeServerDigest(
                                ServerName,
                                Rid,
                                Message,
                                MessageSize,
                                NewMessageDigest,
                                OldMessageDigest );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonComputeServerDigest rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}


NET_API_STATUS NET_API_FUNCTION
I_NetlogonComputeClientDigest(
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DomainName OPTIONAL,
    IN LPBYTE Message,
    IN ULONG MessageSize,
    OUT CHAR NewMessageDigest[NL_DIGEST_SIZE],
    OUT CHAR OldMessageDigest[NL_DIGEST_SIZE]
    )

/*++

Routine Description:

    Compute the message digest for Message on the client.

    A digest is computed given the message and the password used on
    the account identified by the domain name. Since there are two
    passwords on the account on the client side, this routine
    returns 2 digests corresponding to the 2 passwords.  If the two
    passwords are the same the 2 digests returned will be identical.

    Only an Admin or LocalSystem or LocalService may call this function.

Arguments:

    ServerName - The name of the remote server.

    DomainName - The name (DNS or Netbios) of the domain the trust is to.
        NULL implies the domain the machine is a member of.

    Message - The message to compute the digest for.

    MessageSize - The size of Message in bytes.

    NewMessageDigest - Returns the 128-bit digest of the message corresponding
        to the new password

    NewMessageDigest - Returns the 128-bit digest of the message corresponding
        to the new password

Return Value:

    NERR_Success: the operation was successful


--*/
{
    NET_API_STATUS NetStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        NetStatus = NetrLogonComputeClientDigest(
                                ServerName,
                                DomainName,
                                Message,
                                MessageSize,
                                NewMessageDigest,
                                OldMessageDigest );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetLogonComputeClientDigest rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}


NTSTATUS
I_NetServerPasswordGet(
    IN LPWSTR PrimaryName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++

Routine Description:

    This function is used to by a BDC to get a machine account password
    from the PDC in the doamin.

    This function can only be called by a server which has previously
    authenticated with a DC by calling I_NetServerAuthenticate.

    This function uses RPC to contact the DC named by PrimaryName.

Arguments:

    PrimaryName -- Computer name of the PDC to remote the call to.

    AccountName -- Name of the account to get the password for.

    AccountType -- The type of account being accessed.

    ComputerName -- Name of the BDC making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    EncryptedNtOwfPassword -- Returns the OWF password of the account.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrServerPasswordGet (
                                PrimaryName,
                                AccountName,
                                AccountType,
                                ComputerName,
                                Authenticator,
                                ReturnAuthenticator,
                                EncryptedNtOwfPassword );


    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetServerPasswordGet rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}


NTSTATUS
I_NetServerTrustPasswordsGet(
    IN LPWSTR TrustedDcName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNewOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedOldOwfPassword
    )
/*++

Routine Description:

    This function is used by a trusting side DC/workstation to get the
    new and old passwords from the trusted side. The account name
    requested must match the account name used at the secure channel
    setup time unless the call is made by a BDC to its PDC; the BDC
    has full access to the entire trust info.

    This function can only be called by a server which has previously
    authenticated with a DC by calling I_NetServerAuthenticate.

    This function uses RPC to contact the DC named by TrustedDcName.

Arguments:

    TrustedDcName -- Computer name of the DC to remote the call to.

    AccountName -- Name of the account to get the password for.

    AccountType -- The type of account being accessed.

    ComputerName -- Name of the DC making the call.

    Authenticator -- supplied by this server.

    ReturnAuthenticator -- Receives an authenticator returned by the
        trusted side DC.

    EncryptedNewOwfPassword -- Returns the new OWF password of the account.

    EncryptedOldOwfPassword -- Returns the old OWF password of the account.

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrServerTrustPasswordsGet (
                                TrustedDcName,
                                AccountName,
                                AccountType,
                                ComputerName,
                                Authenticator,
                                ReturnAuthenticator,
                                EncryptedNewOwfPassword,
                                EncryptedOldOwfPassword );


    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetServerTrustPasswordsGet rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}


NTSTATUS
I_NetServerGetTrustInfo(
    IN LPWSTR TrustedDcName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNewOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedOldOwfPassword,
    OUT PNL_GENERIC_RPC_DATA *TrustInfo
    )
/*++

Routine Description:

    This function is used by a trusting side DC/workstation to get the
    trust info (new and old passwords and trust attributes) from the
    trusted side. The account name requested must match the account
    name used at the secure channel setup time unless the call is made
    by a BDC to its PDC; the BDC has full access to the entire trust info.

    This function can only be called by a server which has previously
    authenticated with a DC by calling I_NetServerAuthenticate.

    This function uses RPC to contact the DC named by TrustedDcName.

Arguments:

    TrustedDcName -- Computer name of the DC to remote the call to.

    AccountName -- Name of the account to get the password for.

    AccountType -- The type of account being accessed.

    ComputerName -- Name of the DC making the call.

    Authenticator -- supplied by this server.

    ReturnAuthenticator -- Receives an authenticator returned by the
        trusted side DC.

    EncryptedNewOwfPassword -- Returns the new OWF password of the account.

    EncryptedOldOwfPassword -- Returns the old OWF password of the account.

    TrustInfo -- Returns trust info data (currently trust attributes)

Return Value:

    NT status code.

--*/
{
    NTSTATUS Status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //
        *TrustInfo = NULL;     // Force RPC to allocate

        Status = NetrServerGetTrustInfo(
                                TrustedDcName,
                                AccountName,
                                AccountType,
                                ComputerName,
                                Authenticator,
                                ReturnAuthenticator,
                                EncryptedNewOwfPassword,
                                EncryptedOldOwfPassword,
                                TrustInfo );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetServerGetTrustInfo rc = %lu 0x%lx\n", Status, Status));
    }

    return Status;
}


NET_API_STATUS
NetLogonGetTimeServiceParentDomain(
        IN LPWSTR ServerName OPTIONAL,
        OUT LPWSTR *DomainName,
        OUT PBOOL PdcSameSite
    )

/*++

Routine Description:

    Returns the domain name of the domain that is logically the "parent" of this
    domain.  The returned domain name is suitable for passing into the
    NetLogonGetTrustRid and NetLogonComputeClientDigest API.

    On a workstation or member server, the returned domain name is that of the
    domain that ServerName is a member of.

    On a DC that is at the root of the forest, ERROR_NO_SUCH_DOMAIN is returned.

    On a DC that is at the root of a tree in the forest, the name of a trusted
        domain that is also at the root of a tree in the forest is returned.

    On any other DC, the name of the domain that is directly the parent domain
        is returned.

    (See the notes on multiple hosted domains in the code below.)

    Only an Admin or LocalSystem may call this function.

Arguments:

    ServerName - The name of the remote server.

    DomainName - Returns the name of the parent domain.
        The returned buffer should be freed using NetApiBufferFree

    PdcSameSite - Return TRUE if the PDC of ServerName's domain is in the same
        site as ServerName.
        (This value should be ignored if ServerName is not a DC.)

Return Value:

    NERR_Success: the operation was successful

    ERROR_NO_SUCH_DOMAIN: This server is a DC in the domain that is at the
        root of the forest.


--*/
{
    NET_API_STATUS NetStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        *DomainName = NULL;

        NetStatus = NetrLogonGetTimeServiceParentDomain (
                                ServerName,
                                DomainName,
                                PdcSameSite );


    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    return NetStatus;
}


NET_API_STATUS NET_API_FUNCTION
DsDeregisterDnsHostRecordsW (
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DnsDomainName OPTIONAL,
    IN GUID   *DomainGuid OPTIONAL,
    IN GUID   *DsaGuid OPTIONAL,
    IN LPWSTR DnsHostName
    )

/*++

Routine Description:

    This function deletes all DNS entries associated with a particular
    NtDsDsa object.

    This routine does NOT delete A records registered by the DC.  We have
    no way of finding out the IP addresses of the long gone DC.

    Only an Admin, Account Operator or Server Operator may call this
    function.

Arguments:

    ServerName - name of remote server (null for local).

    DnsDomainName - DNS domain name of the domain the DC was in.
        This need not be a domain hosted by this DC.
        If NULL, it is implied to be the DnsHostName with the leftmost label
            removed.

    DomainGuid - Domain Guid of the domain.
        If NULL, GUID specific names will not be removed.

    DsaGuid - GUID of the NtdsDsa object that will be deleted.
        If NULL, NtdsDsa specific names will not be removed.

    DnsHostName - DNS host name of the DC whose DNS records are being deleted.

Return Value:

    NO_ERROR - Success.

    ERROR_NOT_SUPPORTED - The server specified is not a DC.

    ERROR_ACCESS_DENIED - The caller is not allowed to perform this operation.

--*/
{
    NET_API_STATUS NetStatus;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        NetStatus = DsrDeregisterDnsHostRecords (
                        ServerName,
                        DnsDomainName,
                        DomainGuid,
                        DsaGuid,
                        DnsHostName );


    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;


    IF_DEBUG( LOGON ) {
        NetpKdPrint(("DsDeregisterDnsHostRecordsW rc = %lu 0x%lx\n",
                     NetStatus, NetStatus));
    }

    return NetStatus;
}


NET_API_STATUS NET_API_FUNCTION
DsDeregisterDnsHostRecordsA (
    IN LPSTR ServerName OPTIONAL,
    IN LPSTR DnsDomainName OPTIONAL,
    IN GUID  *DomainGuid OPTIONAL,
    IN GUID  *DsaGuid OPTIONAL,
    IN LPSTR DnsHostName
    )

/*++

Routine Description:

    This function deletes all DNS entries associated with a particular
    NtDsDsa object.

    This routine does NOT delete A records registered by the DC.  We have
    no way of finding out the IP addresses of the long gone DC.

    Only an Admin, Account Operator or Server Operator may call this
    function.

Arguments:

    ServerName - name of remote server (null for local).

    DnsDomainName - DNS domain name of the domain the DC was in.
        This need not be a domain hosted by this DC.
        If NULL, it is implied to be the DnsHostName with the leftmost label
            removed.

    DomainGuid - Domain Guid of the domain specified
        by DnsDomainName. If NULL, GUID specific names will not be removed.

    DsaGuid - GUID of the NtdsDsa object that will be deleted.
        If NULL, NtdsDsa specific names will not be removed.

    DnsHostName - DNS host name of the DC whose DNS records are being deleted.

Return Value:

    NO_ERROR - Success.

    ERROR_NOT_SUPPORTED - The server specified is not a DC.

    ERROR_ACCESS_DENIED - The caller is not allowed to perform this operation.

--*/
{
    NET_API_STATUS NetStatus;
    LPWSTR UnicodeServerName = NULL;
    LPWSTR UnicodeDnsDomainName = NULL;
    LPWSTR UnicodeDnsHostName = NULL;

    //
    // Convert input parameters to Unicode.
    //

    if ( ServerName != NULL ) {
        UnicodeServerName = NetpAllocWStrFromAStr( ServerName );
        if ( UnicodeServerName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    if ( DnsDomainName != NULL ) {
        UnicodeDnsDomainName = NetpAllocWStrFromAStr( DnsDomainName );
        if ( UnicodeDnsDomainName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    if ( DnsHostName != NULL ) {
        UnicodeDnsHostName = NetpAllocWStrFromAStr( DnsHostName );
        if ( UnicodeDnsHostName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Call the Unicode routine
    //

    NetStatus = DsDeregisterDnsHostRecordsW (
                    UnicodeServerName,
                    UnicodeDnsDomainName,
                    DomainGuid,
                    DsaGuid,
                    UnicodeDnsHostName );

Cleanup:

    if ( UnicodeServerName != NULL ) {
        NetApiBufferFree( UnicodeServerName );
    }

    if ( UnicodeDnsDomainName != NULL ) {
        NetApiBufferFree( UnicodeDnsDomainName );
    }

    if ( UnicodeDnsHostName != NULL ) {
        NetApiBufferFree( UnicodeDnsHostName );
    }

    return NetStatus;
}



NET_API_STATUS NET_API_FUNCTION
DsGetForestTrustInformationW (
    IN LPCWSTR ServerName OPTIONAL,
    IN LPCWSTR TrustedDomainName OPTIONAL,
    IN DWORD Flags,
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    )

/*++

Routine Description:

    DsGetForestTrustInformation returns an array of FTInfo records.  The records can
    be TLN or domain NscType records.


    The TLN records returned by DsGetForestTrustInformation are collected from three
    sources:
    * The DNS domain names of each tree in the forest.
    * The values of the Upn-Suffixes attribute on the Partitions container object
      within the config container.
    * The values of the Spn-Suffixes attribute on the Partitions container object
      within the config container.

    Each of these names is a candidate for being a TLN returned from the API.
    However, some names are not returned if they are a suffix of one of the other
    TLN candidates.  For instance, if acme.com is a Upn Suffix and a.acme.com is
    the dns domain name of one of the trees in the forest, only acme.com will be
    returned.

    The domain records returned from DsGetForestTrustInformation are collected by
    internally calling DsEnumerateDomainTrusts with the DS_DOMAIN_IN_FOREST.
    For each domain returned from that API, the Dns domain name, netbios domain name
    and domain sid are returned in the domain FTinfo entry.

    This section describes the DS_GFTI_UPDATE_TDO flag bit in more detail.  When
    this bit is specified, the FTinfo records written to the TDO is a combination
    of the FTInfo records currently on the TDO and the FTInfo records returned from
    the trusted domain.  The merge is done as described for the
    DsMergeForestTrustInformationW API.

Arguments:

    ServerName - The name of the domain controller this API is remoted to.
        The caller must be an "Authenticated User" on ServerName.
        If NULL is specified, the local server is implied.

    TrustedDomainName - The name of the TrustedDomain that the forest trust information
        is to be gathered for.  If TrustedDomainName is NULL, the forest trust
        information for the domain hosted by ServerName is returned.

        If TrustedDomainInformation is not null, it must specify the netbios domain
        name or dns domain name of an outbound trusted domain with the
        TRUST_ATTRIBUTE_FOREST_TRANSITIVE bit set.  In that case, this API obtains
        the forest trust information by making an RPC call over netlogon's secure
        channel to obtain the forest trust information from that domain.

    Flags - Specifies a set of bits that modify the behavior of the API.
        Valid bits are:

        DS_GFTI_UPDATE_TDO - If this bit is set, the API will update
            the FTinfo attribute of the TDO named by the TrustedDomainName
            parameter. The TrustedDomainName parameter may not be NULL.
            The caller must have access to modify the FTinfo attribute or
            ERROR_ACCESS_DENIED will be returned.  The algorithm describing
            how the FTinfo from the trusted domain is merged with the FTinfo
            from the TDO is described below.

            This bit in only valid if ServerName specifies the PDC of its domain.

    ForestTrustInfo - Returns a pointer to a structure containing a count and an
        array of FTInfo records describing the namespaces claimed by the
        domain specified by TrustedDomainName. The Accepted field and Time
        field of all returned records will be zero.  The buffer should be freed
        by calling NetApiBufferFree.


Return Value:


    NO_ERROR - Success.

    ERROR_INVALID_FLAGS - An invalid value was passed for FLAGS

    ERROR_INVALID_FUNCTION - The domain specified by TrustedDomainName does not have the
        TRUST_ATTRIBUTE_FOREST_TRANSITIVE bit set on the TDO on the trusted DC.

    ERROR_NO_SUCH_DOMAIN - The domain specified by TrustedDomainName does not exist or
        does not have that TRUST_ATTRIBUTE_FOREST_TRANSITIVE bit set on the TDO on ServerName.

--*/
{
    NET_API_STATUS NetStatus;
    PLSA_FOREST_TRUST_INFORMATION LocalForestTrustInfo = NULL;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        NetStatus = DsrGetForestTrustInformation (
                        (LPWSTR) ServerName,
                        (LPWSTR) TrustedDomainName,
                        Flags,
                        &LocalForestTrustInfo );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        NetStatus = RpcExceptionCode();

    } RpcEndExcept;

    if ( NetStatus == NO_ERROR ) {
        *ForestTrustInfo = LocalForestTrustInfo;
    }

    return NetStatus;
}



NTSTATUS
I_NetGetForestTrustInformation (
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD Flags,
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    )

/*++

Routine Description:

    The secure channel version of DsGetForestTrustInformation.

    The inbound secure channel identified by ComputerName must be for an interdomain trust
    and the inbound TDO must have the TRUST_ATTRIBUTE_FOREST_TRANSITIVE bit set.


Arguments:

    ServerName - The name of the domain controller this API is remoted to.

    ComputerName -- Name of the DC server making the call.

    Authenticator -- supplied by the server.

    ReturnAuthenticator -- Receives an authenticator returned by the PDC.

    Flags - Specifies a set of bits that modify the behavior of the API.
        No values are currently defined.  The caller should pass zero.

    ForestTrustInfo - Returns a pointer to a structure containing a count and an
        array of FTInfo records describing the namespaces claimed by the
        domain specified by TrustedDomainName. The Accepted field and Time
        field of all returned records will be zero.  The buffer should be freed
        by calling NetApiBufferFree.


Return Value:

    STATUS_SUCCESS -- The function completed successfully.

    STATUS_ACCESS_DENIED -- The replicant should re-authenticate with
        the PDC.

--*/
{
    NTSTATUS Status;

    //
    // Do the RPC call with an exception handler since RPC will raise an
    // exception if anything fails. It is up to us to figure out what
    // to do once the exception is raised.
    //

    RpcTryExcept {

        //
        // Call RPC version of the API.
        //

        Status = NetrGetForestTrustInformation(
                            ServerName,
                            ComputerName,
                            Authenticator,
                            ReturnAuthenticator,
                            Flags,
                            ForestTrustInfo );

    } RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) ) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    IF_DEBUG( LOGON ) {
        NetpKdPrint(("I_NetGetForestTrustInformation rc = %lu 0x%lx\n",
                      Status, Status));
    }

    return Status;
}


NET_API_STATUS NET_API_FUNCTION
DsMergeForestTrustInformationW(
    IN LPCWSTR DomainName,
    IN PLSA_FOREST_TRUST_INFORMATION NewForestTrustInfo,
    IN PLSA_FOREST_TRUST_INFORMATION OldForestTrustInfo OPTIONAL,
    OUT PLSA_FOREST_TRUST_INFORMATION *MergedForestTrustInfo
    )
/*++

Routine Description:

    This function merges the changes from a new FTinfo into an old FTinfo and
    produces the resultant FTinfo.

    This routine will be modified in future releases to support new forest trust record
    types.  It is intended that the OldForestTrustInfo describes the FTinfo as currently
    stored on the local TDO.  It is intended that the NewForestTrustInfo is the FTinfo as
    returned from DsGetForestTrustInformationW for DomainName.  The MergedForestTrustInfo is
    the resultant ForestTrustInfo that should be written to the local TDO.  Don't use this
    routine for any other purpose.

    The merged FTinfo records are a combinition of the new and old records.
    Here's where the merged records come from:

    ??? Add more here about where records are valid etc.
    * The TLN exclusion records are copied from the TDO intact.
    * The TLN record from the trusted domain that maps to the dns domain name of the
      TDO is copied enabled.  This reflects the LSA requirement that such a TLN not
      be disabled.  For instance, if the TDO is for a.acme.com and there is a TLN for
      a.acme.com that TLN will be enabled.  Also, if the TDO is for a.acme.com and
      there is a TLN for acme.com, that TLN will be enabled.
    * All other TLN records from the trusted domain are copied disabled with the
      following exceptions.  If there is an enabled TLN on the TDO, all TLNs from the
      trusted domain that equal (or are subordinate to) the TDO TLN are marked as
      enabled.  This follows the philosophy that new TLNs are imported as disabled.
      For instance, if the TDO had an enabled TLN for a.acme.com that TLN will still
      be enabled after the automatic update.  If the TDO had an enabled TLN for
      acme.com and the trusted forest now has a TLN for a.acme.com, the resultant
      FTinfo will have an enabled TLN for a.acme.com.
    * The domain records from the trusted domain are copied enabled with the
      following exceptions.  If there is a disabled domain record on the TDO whose
      dns domain name, or domain sid exactly matches the domain record, then the domain
      remains disabled.  If there is a domain record on the TDO whose netbios name is
      disabled and whose netbios name exactly matches the netbios name on a domain
      record, then the netbios name is disabled.


Arguments:

    TrustedDomainName - Trusted domain that is to be updated.

    NewForestTrustInfo - Specified the new array of FTinfo records as returned from the
        TrustedDomainName.
        The Flags field and Time field of the TLN entries are ignored.

    OldForestTrustInfo - Specified the array of FTinfo records as returned from the
        TDO.  This field may be NULL if there is no existing records.

    MergedForestTrustInfo - Returns the resulant FTinfo records.
        The caller should free this buffer using MIDL_user_free.

Return Value:

    NO_ERROR: Success

--*/
{
    NTSTATUS Status;
    UNICODE_STRING DomainNameString;

    RtlInitUnicodeString( &DomainNameString, DomainName );

    //
    // Call the worker routine
    //

    Status = NetpMergeFtinfo( &DomainNameString,
                              NewForestTrustInfo,
                              OldForestTrustInfo,
                              MergedForestTrustInfo );

    return NetpNtStatusToApiStatus( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\cpnetpdc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpNetPdc.c

Abstract:

    include file for private\net\svcdlls\logonsrv\netpdc.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1998

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1998 ChandanS
        Created.
--*/

#include "..\..\idl\netpdc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\cplogonp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpLogonP.c

Abstract:

    include file for private\net\netlib\logonp.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1998

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1998 ChandanS
        Created.
--*/

#include "..\..\..\..\netlib\logonp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\cpdnssrv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpDnsSrv.c

Abstract:

    include file for private\net\netlib\dnssrv.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1998

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1998 ChandanS
        Created.
--*/

#include "..\..\..\..\netlib\dnssrv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\cpnlcommon.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpNetPdc.c

Abstract:

    include file for private\net\svcdlls\logonsrv\netpdc.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1998

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1998 ChandanS
        Created.
--*/

#include "..\..\idl\nlcommon.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\cpnmcan.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpNmCan.c

Abstract:

    include file for private\net\netlib\namecan.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1998

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1998 ChandanS
        Created.
--*/

#include "..\..\..\..\netlib\namecan.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\cpnmval.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpNmVal.c

Abstract:

    include file for private\net\netlib\nameval.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1998

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1998 ChandanS
        Created.
--*/

#include "..\..\..\..\netlib\nameval.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\cpntstat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpNtStat.c

Abstract:

    include file for private\net\netlib\ntstatus.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1998

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1998 ChandanS
        Created.
--*/

#include "..\..\..\..\netlib\ntstatus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\ntcalls.h ===
#include <nldebug.h>
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#include <security.h>
#include <assert.h>


NET_API_STATUS DCNameInitialize(VOID);
VOID DCNameClose(VOID);

NET_API_STATUS NetpDcInitializeCache(VOID);
VOID NetpDcUninitializeCache(VOID);

VOID
MyRtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );

#define RtlAssert(a,b,c,d) MyRtlAssert(a,b,c,d)

VOID
MyRtlInitUnicodeString(
    PUNICODE_STRING DestinationString,
    PCWSTR SourceString
    );

#define RtlInitUnicodeString(x,y) MyRtlInitUnicodeString(x,y)

VOID
MyRtlInitString(
    PSTRING DestinationString,
    PCSTR SourceString
    );

#define RtlInitString(x,y) MyRtlInitString(x,y)

NTSTATUS
MyRtlOemStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN POEM_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );

#define RtlOemStringToUnicodeString(x,y,z) MyRtlOemStringToUnicodeString(x,y,z)

NTSTATUS                                                                    
MyRtlUnicodeStringToAnsiString(                                             
    PANSI_STRING DestinationString,                                         
    PUNICODE_STRING SourceString,                                           
    BOOLEAN AllocateDestinationString                                       
    );                                                                      
                                                                            
#define RtlUnicodeStringToAnsiString(x, y, z) MyRtlUnicodeStringToAnsiString (x, y, z)
                                                                            
NTSTATUS                                                                    
MyRtlAnsiStringToUnicodeString(                                             
    PUNICODE_STRING DestinationString,                                      
    PANSI_STRING SourceString,                                              
    BOOLEAN AllocateDestinationString                                       
    );                                                                      
                                                                            
#define RtlAnsiStringToUnicodeString(x, y, z) MyRtlAnsiStringToUnicodeString (x, y, z)

NTSTATUS
MyRtlUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );

#define RtlUnicodeStringToOemString(x,y,z) MyRtlUnicodeStringToOemString(x,y,z)

NTSTATUS
MyRtlUpcaseUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );

#define RtlUpcaseUnicodeStringToOemString(x,y,z) MyRtlUpcaseUnicodeStringToOemString(x,y,z)

ULONG
MyRtlxOemStringToUnicodeSize(
    POEM_STRING OemString
    );

#define RtlxOemStringToUnicodeSize(x) MyRtlxOemStringToUnicodeSize(x)

ULONG
MyRtlxUnicodeStringToOemSize(
    PUNICODE_STRING UnicodeString
    );

#define RtlxUnicodeStringToOemSize(x) MyRtlxUnicodeStringToOemSize(x)

NTSTATUS
MyNtQuerySystemTime (
    OUT PTimeStamp SystemTimeStamp
    );

#define NtQuerySystemTime(x) MyNtQuerySystemTime(x)

ULONG
MyRtlUniform (
    IN OUT PULONG Seed
    );

#define RtlUniform(x) MyRtlUniform(x)

NET_API_STATUS
NetpwNameCanonicalize(
    IN  LPWSTR  Name,
    OUT LPWSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    );

LPWSTR
NetpAllocWStrFromOemStr(
    IN LPCSTR Oem
    );

VOID
MyRtlFreeAnsiString(
    IN OUT PANSI_STRING AnsiString
    );

LPSTR
MyNetpLogonUnicodeToOem(
    IN LPWSTR Unicode
    );

LONG
NlpChcg_wcsicmp( 
    IN LPCWSTR string1, 
    IN LPCWSTR string2 
    );

#define _wcsicmp( _x, _y )  NlpChcg_wcsicmp( (_x), (_y) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\locdiag\cpnetpdc.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    cpNetpDc.c

Abstract:

    Just an include for ..\..\netpdc.c

Author:

    ChandanS 09-April-1998

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include "..\..\idl\netpdc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\locdiag\logon_c_stub.c ===
#include "logon_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\locdiag\nlcommon.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    nlcommon.c

Abstract:

    Just an include for ..\..\nlcommon.c

Author:

    ChandanS 09-April-1998

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include "..\..\idl\nlcommon.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\winnt5\logon_c_stub.c ===
#include "logon_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\winnt5\cpnetpdc.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    cpNetpDc.c

Abstract:

    Just an include for ..\..\netpdc.c

Author:

    ChandanS 09-April-1998

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include "..\..\idl\netpdc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\test\locator.cpp ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1998
//
// File:        ntlmtest.cpp
//
// Contents:
//
//
// History:     07-Dec-98       Created         ChandanS
//
// Comments:    This program tests DsGetDcName and logon on Win9x
//
//------------------------------------------------------------------------


// NT Headers

extern "C"
{
#ifndef WIN32_CHICAGO
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <windows.h>
}

#define UF_NORMAL_ACCOUNT               0x0200
// Cairo Headers

extern "C"
{
// #define SECURITY_NTLM
#include <security.h>
#include <dsgetdc.h>
#ifndef WIN32_CHICAGO
#include <secmisc.h>
#endif
}

// C headers

extern "C"
{
#include <conio.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <tchar.h>
#ifndef WIN32_CHICAGO
#include <wcstr.h>
#endif
#include <stdlib.h>
#include <dnsapi.h>
}

void
PrintFlags(DWORD DcFlags)
{
    DWORD Flags = DcFlags;
    printf("Flags: \t\t\t\t");
    if (Flags &  DS_PDC_FLAG)
    {
        printf(" DS_PDC_FLAG ");
    }
    if (Flags &  DS_GC_FLAG)
    {
        printf(" DS_GC_FLAG ");
    }
    if (Flags &  DS_LDAP_FLAG)
    {
        printf(" DS_LDAP_FLAG ");
    }
    if (Flags &  DS_DS_FLAG)
    {
        printf(" DS_DS_FLAG ");
    }
    if (Flags &  DS_KDC_FLAG)
    {
        printf(" DS_KDC_FLAG ");
    }
    if (Flags &  DS_TIMESERV_FLAG)
    {
        printf(" DS_TIMESERV_FLAG ");
    }
    if (Flags &  DS_CLOSEST_FLAG)
    {
        printf(" DS_CLOSEST_FLAG ");
    }
    if (Flags &  DS_WRITABLE_FLAG)
    {
        printf(" DS_WRITABLE_FLAG ");
    }
    if (Flags &  DS_GOOD_TIMESERV_FLAG)
    {
        printf(" DS_GOOD_TIMESERV_FLAG ");
    }
    if (Flags &  DS_PING_FLAGS)
    {
        printf(" DS_PING_FLAGS ");
    }
    if (Flags &  DS_DNS_CONTROLLER_FLAG)
    {
        printf(" DS_DNS_CONTROLLER_FLAG ");
    }
    if (Flags &  DS_DNS_DOMAIN_FLAG)
    {
        printf(" DS_DNS_DOMAIN_FLAG ");
    }
    if (Flags &  DS_DNS_FOREST_FLAG)
    {
        printf(" DS_DNS_FOREST_FLAG ");
    }
    printf("\n");
}

SECURITY_STATUS
test_dsgetdcnamea(LPSTR pDomain, LPSTR pUser, DWORD Flags)
{
    SECURITY_STATUS scRet;
    int i;
    DWORD (WINAPI *pDsGetDcNameA) (LPCSTR, LPCSTR, GUID *, LPCSTR, ULONG, PDOMAIN_CONTROLLER_INFOA *);
    DWORD (WINAPI *pDsGetDcNameWithAccountA) (LPCSTR, LPCSTR, ULONG, LPCSTR, GUID *, LPCSTR, ULONG, PDOMAIN_CONTROLLER_INFOA *);
    HINSTANCE hInstance = NULL;
    ULONG NetStatus = 0;
    PDOMAIN_CONTROLLER_INFOA Controller = NULL;
    PDOMAIN_CONTROLLER_INFOA ControllerWithAccount = NULL;
    CHAR szBuf[] = "";

    hInstance = LoadLibrary("logonsrv");

    if (hInstance == NULL)
    {
        printf("LOCATOR: Error %ld Can't load logonsrv.dll. trying netapi32\r\n", GetLastError());
    }
    if (hInstance == NULL)
    {
        hInstance = LoadLibrary("netapi32");
    }
    if (hInstance == NULL)
    {
        printf("LOCATOR: Error %ld Can't load netapi32.dll.\r\n", GetLastError());
    }
    if (hInstance != NULL)
    {
       pDsGetDcNameA = (DWORD (WINAPI *)(LPCSTR, LPCSTR, GUID *,
                                         LPCSTR, ULONG,
                                         PDOMAIN_CONTROLLER_INFOA *)) 
                               GetProcAddress(hInstance, "DsGetDcNameA");
       if (pDsGetDcNameA == NULL)
       {
            printf("LOCATOR: No DsGetDcNameA\n");
       }
       else
       {
           NetStatus = (*pDsGetDcNameA)(NULL,
                                        pDomain,
                                        NULL,
                                        NULL,
                                        Flags,
                                        &Controller);
           printf("LOCATOR: DsGetdcNameA returns 0x%x\r\n", NetStatus);

           if (NetStatus == 0)
           {
               printf("DomainControllerName: \t\t\"%s\"\n", Controller->DomainControllerName  ? Controller->DomainControllerName : szBuf);
               printf("DomainControllerAddress:\t\"%s\"\n", Controller->DomainControllerAddress ? Controller->DomainControllerAddress : szBuf );
               printf("DomainControllerAddressType: \t%d\n", Controller->DomainControllerAddressType );
               printf("DomainGuid : \t\n");
               printf("DomainName: \t\t\t\"%s\"\n", Controller->DomainName);
               printf("DnsForestName: \t\t\t\"%s\"\n", Controller->DnsForestName ? Controller->DnsForestName : szBuf);
               PrintFlags(Controller->Flags);
               printf("DcSiteName: \t\t\t\"%s\"\n", Controller->DcSiteName ? Controller->DcSiteName : szBuf);
               printf("ClientSiteName: \t\t\"%s\"\n", Controller->ClientSiteName ? Controller->ClientSiteName : szBuf);
           }
       }

       pDsGetDcNameWithAccountA = (DWORD (WINAPI *)(LPCSTR, LPCSTR, ULONG, LPCSTR, GUID *,
                                         LPCSTR, ULONG,
                                         PDOMAIN_CONTROLLER_INFOA *)) 
                               GetProcAddress(hInstance, "DsGetDcNameWithAccountA");
       if (pDsGetDcNameWithAccountA == NULL)
       {
            printf("LOCATOR: No DsGetDcNameWithAccountA\n");
       }
       else
       {
           NetStatus = (*pDsGetDcNameWithAccountA)(NULL,
                                        pUser,
                                        (pUser == NULL) ? 0 : UF_NORMAL_ACCOUNT,
                                        pDomain,
                                        NULL,
                                        NULL,
                                        Flags,
                                        &Controller);
           printf("LOCATOR: DsGetdcNameWithAccountA returns 0x%x\r\n", NetStatus);
           if (NetStatus == 0)
           {
               printf("DomainControllerName: \t\t\"%s\"\n", Controller->DomainControllerName  ? Controller->DomainControllerName : szBuf);
               printf("DomainControllerAddress:\t\"%s\"\n", Controller->DomainControllerAddress ? Controller->DomainControllerAddress : szBuf );
               printf("DomainControllerAddressType: \t%d\n", Controller->DomainControllerAddressType );
               printf("DomainGuid : \t\n");
               printf("DomainName: \t\t\t\"%s\"\n", Controller->DomainName);
               printf("DnsForestName: \t\t\t\"%s\"\n", Controller->DnsForestName ? Controller->DnsForestName : szBuf);
               PrintFlags(Controller->Flags);
               printf("DcSiteName: \t\t\t\"%s\"\n", Controller->DcSiteName ? Controller->DcSiteName : szBuf);
               printf("ClientSiteName: \t\t\"%s\"\n", Controller->ClientSiteName ? Controller->ClientSiteName : szBuf);
           }
       }

       if (hInstance)
       {
           FreeLibrary(hInstance);
       }
    }

#if 0
    hInstance = LoadLibrary("kerberos");

    if (hInstance == NULL)
    {
        printf("NTLMTEST: Can't load kerberos.dll.\r\n");
    }
    else
    {

        INIT_SECURITY_INTERFACE InitSecurityInterface = NULL;

        InitSecurityInterface = (INIT_SECURITY_INTERFACE) GetProcAddress(hInstance, SECURITY_ENTRYPOINTA);

        if ( NULL == InitSecurityInterface)
        {
            printf("NTLMTEST: No InitSecurityInterface\n");
        }
        else
        {
            PSecurityFunctionTable Table = InitSecurityInterface();

            if (Table != NULL)
            {
                if (Table->SspiLogonUser != NULL)
                {
            
                    if (pAuthData && pAuthData->User && pAuthData->Domain && pAuthData->Password)
                    {
                    scRet = Table->SspiLogonUser("kerberos", 
                                                 pAuthData->User,
                                                 pAuthData->Domain,
                                                 pAuthData->Password);

                    printf("NTLMTEST: SspiLogonUserA returns 0x%x\r\n", scRet);
                    }
                }
                else
                {
                    printf("NTLMTEST: No SspiLogonUser\n");
                }
            }
            else
            {
                printf("NTLMTEST: No table\n");
            }
        }

        printf("NTLMTEST: Freeing secur32.dll.\r\n");
        FreeLibrary(hInstance);
    }
#endif

    return(S_OK);
}


void
Usage(BOOL fVerbose)
{
    printf("Usage:\tlocator [/domain:Domain] [/user:User] [/force] [/dsreq] [/dspref] [/gc] [/pdc]\n      \t        [/ip] [/kdc] [/time] [/write] [/goodtime] [avoidself]\n      \t        [/onlyldap] [/isflatname] [/isdnsname] [/retdns] [/retflat]\n\tlocator /? \n");

    if (fVerbose)
    {
        printf("Domain: domain to look up the dc in.\n");
        printf("\n/? : Display this message.\n");
    }
    
    exit(1);
}


char *
ArgValue(char *arg)
{
    char *retval = strchr(arg + 2, ':');

    if (retval != NULL)
        retval++;
    else
        retval = arg + strlen(arg);
        
    return retval;
}    
    
    
enum {
    NoAction,
#define DOMAIN "/Domain"
    Domain,
#define USER "/User"
    User,
#define FORCE "/Force"
    Force,
#define DSREQ "/DsReq"
    DsReq,
#define DSPREF "/DsPref"
    DsPref,
#define GC "/Gc"
    Gc,
#define PDC "/pdc"
    pdc,
#define IP "/ip"
    ip,
#define KDC "/kdc"
    kdc,
#define TIME "/time"
    time,
#define WRITE "/write"
    write,
#define GOODTIME "/goodtime"
    goodtime,
#define AVOIDSELF "/avoidself"
    avoidself,
#define ONLYLDAP "/onlyldap"
    onlyldap,
#define ISFLATNAME "/isflatname"
    isflatname,
#define ISDNSNAME "/isdnsname"
    isdnsname,
#define RETDNS "/retdns"
    retdns,
#define RETFLAT "/retflat"
    retflat,
#define HELP "/?"
    help
    } Action = NoAction;
int
_cdecl main(int argc, char *argv[])
{
    LPTSTR Tmp = NULL, pDomain = NULL, pUser = NULL;
    int i = 1, Len = 0;
    LPSTR Arg = NULL;
    DWORD Flags = 0;

    for (i = 1; i < argc; i++)
    {
        Arg = argv[i];

#define DS_FORCE_REDISCOVERY            0x00000001
#define DS_DIRECTORY_SERVICE_REQUIRED   0x00000010
#define DS_DIRECTORY_SERVICE_PREFERRED  0x00000020
#define DS_GC_SERVER_REQUIRED           0x00000040
#define DS_PDC_REQUIRED                 0x00000080
#define DS_IP_REQUIRED                  0x00000200
#define DS_KDC_REQUIRED                 0x00000400
#define DS_TIMESERV_REQUIRED            0x00000800
#define DS_WRITABLE_REQUIRED            0x00001000
#define DS_GOOD_TIMESERV_PREFERRED      0x00002000
#define DS_AVOID_SELF                   0x00004000
#define DS_ONLY_LDAP_NEEDED             0x00008000
#define DS_IS_FLAT_NAME                 0x00010000
#define DS_IS_DNS_NAME                  0x00020000
#define DS_RETURN_DNS_NAME              0x40000000
#define DS_RETURN_FLAT_NAME             0x80000000

        if ( _strnicmp( Arg, DOMAIN, sizeof(DOMAIN)-1) == 0 ) {
            pDomain = ArgValue(argv[i]);
        }
        else if ( _strnicmp( Arg, USER, sizeof(USER)-1) == 0 ) {
            pUser = ArgValue(argv[i]);
        }
        else if ( _strnicmp( Arg, FORCE, sizeof(FORCE) -1) == 0 ) {
            Flags |= DS_FORCE_REDISCOVERY;
        }
        else if ( _strnicmp( Arg, DSREQ, sizeof(DSREQ) - 1) == 0 ) {
            Flags |= DS_DIRECTORY_SERVICE_REQUIRED;
        }
        else if ( _strnicmp( Arg, DSPREF, sizeof(DSPREF) -1) == 0 ) {
            Flags |= DS_DIRECTORY_SERVICE_PREFERRED;
        }
        else if ( _strnicmp( Arg, GC, sizeof(GC) -1) == 0 ) {
            Flags |= DS_GC_SERVER_REQUIRED;
        }
        else if ( _strnicmp( Arg, PDC, sizeof(PDC) -1) == 0 ) {
            Flags |= DS_PDC_REQUIRED;
        }
        else if ( _strnicmp( Arg, IP, sizeof(IP) -1) == 0 ) {
            Flags |= DS_IP_REQUIRED;
        }
        else if ( _strnicmp( Arg, KDC, sizeof(KDC) -1) == 0 ) {
            Flags |= DS_KDC_REQUIRED;
        }
        else if ( _strnicmp( Arg, TIME, sizeof(TIME) - 1) == 0 ) {
            Flags |= DS_TIMESERV_REQUIRED;
        }
        else if ( _strnicmp( Arg, WRITE, sizeof(WRITE) - 1) == 0 ) {
            Flags |= DS_WRITABLE_REQUIRED;
        }
        else if ( _strnicmp( Arg, GOODTIME, sizeof(GOODTIME) - 1) == 0 ) {
            Flags |= DS_GOOD_TIMESERV_PREFERRED;
        }
        else if ( _strnicmp( Arg, AVOIDSELF, sizeof(AVOIDSELF)-1) == 0 ) {
            Flags |= DS_AVOID_SELF;
        }
        else if ( _strnicmp( Arg, ONLYLDAP, sizeof(ONLYLDAP) -1 ) == 0 ) {
            Flags |= DS_ONLY_LDAP_NEEDED;
        }
        else if ( _strnicmp( Arg, ISFLATNAME, sizeof(ISFLATNAME)-1) == 0 ) {
            Flags |= DS_IS_FLAT_NAME;
        }
        else if ( _strnicmp( Arg, ISDNSNAME, sizeof(ISDNSNAME) - 1) == 0 ) {
            Flags |= DS_IS_DNS_NAME;
        }
        else if ( _strnicmp( Arg, RETDNS, sizeof(RETDNS) - 1) == 0 ) {
            Flags |= DS_RETURN_DNS_NAME;
        }
        else if ( _strnicmp( Arg, RETFLAT, sizeof(RETFLAT) -1 ) == 0 ) {
            Flags |= DS_RETURN_FLAT_NAME;
        }
        else if ( _strnicmp( Arg, HELP, sizeof(HELP) -1 ) == 0 ) {
            Usage(TRUE);
        }
    }

    if (pDomain != NULL)
    {
        Len = lstrlen(pDomain);
        Tmp = (LPTSTR) LocalAlloc(0, Len+1);
        strcpy(Tmp, pDomain);
        Tmp[Len] = '\0';
        pDomain = Tmp;
        Tmp = NULL;
    }

    if (pUser != NULL)
    {
        Len = lstrlen(pUser);
        Tmp = (LPTSTR) LocalAlloc(0, Len+1);
        strcpy(Tmp, pUser);
        Tmp[Len] = '\0';
        pUser = Tmp;
        Tmp = NULL;
    }
    // Call the test function to do the work

    test_dsgetdcnamea(pDomain, pUser, Flags);
    if (pDomain)
    {
        LocalFree(pDomain);
        pDomain = NULL;
    }
    if (pUser)
    {
        LocalFree(pUser);
        pUser = NULL;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\chicago\ntwin95.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lmcons.h>

#include <lmerr.h>
#include <align.h>
#include <netdebug.h>
#include <lmapibuf.h>
#define DEBUG_ALLOCATE
#include <nldebug.h>
#undef DEBUG_ALLOCATE
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif // SECURITY_WIN32
#include <security.h>
#include "ntcalls.h"
#include <icanon.h>
#include <tstring.h>

#define _DECL_DLLMAIN

BOOL WINAPI DllMain(
    HANDLE    hInstance,
    ULONG     dwReason,
    PVOID     lpReserved
    )
{
    NET_API_STATUS Status = NO_ERROR;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        Status = DCNameInitialize();
#if NETLOGONDBG
        NlGlobalTrace = 0xFFFFFFFF;
#endif // NETLOGONDBG
        if (Status != NO_ERROR)
        {
            return FALSE;
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DCNameClose();
    }

    return TRUE;
}

VOID
NetpAssertFailed(
    IN LPDEBUG_STRING FailedAssertion,
    IN LPDEBUG_STRING FileName,
    IN DWORD LineNumber,
    IN LPDEBUG_STRING Message OPTIONAL
    )
{
    assert(FALSE);
}

VOID
NlAssertFailed(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
    assert(FALSE);
}

VOID
MyRtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
    assert(FALSE);
}

/****************************************************************************/
NET_API_STATUS
NetpGetComputerName (
    OUT  LPWSTR   *ComputerNamePtr
    )

/*++

Routine Description:

    This routine obtains the computer name from a persistent database.
    Currently that database is the NT.CFG file.

    This routine makes no assumptions on the length of the computername.
    Therefore, it allocates the storage for the name using NetApiBufferAllocate.
    It is necessary for the user to free that space using NetApiBufferFree when
    finished.

Arguments:

    ComputerNamePtr - This is a pointer to the location where the pointer
        to the computer name is to be placed.

Return Value:

    NERR_Success - If the operation was successful.

    It will return assorted Net or Win32 error messages if not.

--*/
{
    NET_API_STATUS ApiStatus = NO_ERROR;
    ULONG Index;
    DWORD NameSize = MAX_COMPUTERNAME_LENGTH + 1;   // updated by win32 API.
    CHAR AnsiName[MAX_COMPUTERNAME_LENGTH + 1];

    //
    // Check for caller's errors.
    //
    if (ComputerNamePtr == NULL) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Allocate space for computer name.
    //
    *ComputerNamePtr = (LPWSTR)LocalAlloc( 0,
            (MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR) );

    if (*ComputerNamePtr == NULL) {
        ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Ask system what current computer name is.
    //
    if ( !GetComputerName(
            AnsiName,
            &NameSize ) ) {

        ApiStatus = (NET_API_STATUS) GetLastError();
        goto Cleanup;
    }

    Index = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                AnsiName,
                                NameSize,
                                *ComputerNamePtr,
                                (MAX_COMPUTERNAME_LENGTH) * sizeof(WCHAR)
                                );
    if (!Index)
    {
        ApiStatus = GetLastError();
        goto Cleanup;
    }

    *(*ComputerNamePtr + Index) = UNICODE_NULL;

    //
    // All done.
    //

Cleanup:
    if (ApiStatus != NO_ERROR)
    {
        if (ComputerNamePtr)
        {
            if (*ComputerNamePtr)
            {
                LocalFree( *ComputerNamePtr );
                *ComputerNamePtr = NULL;
            }
        }
    }
    return ApiStatus;
}

VOID
MyRtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}

VOID
MyRtlInitString(
    OUT PSTRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
}

// from net\netlib\memalloc.c

// Define memory alloc/realloc flags.  We are NOT using movable or zeroed
// on allocation here.

#define NETLIB_LOCAL_ALLOCATION_FLAGS   LMEM_FIXED
LPVOID
NetpMemoryAllocate(
    IN DWORD Size
    )

/*++

Routine Description:

    NetpMemoryAllocate will allocate memory, or return NULL if not available.

Arguments:

    Size - Supplies number of bytes of memory to allocate.

Return Value:

    LPVOID - pointer to allocated memory.
    NULL - no memory is available.

--*/

{
    LPVOID NewAddress;

    if (Size == 0) {
        return (NULL);
    }
#ifdef WIN32
    {
        HANDLE hMem;
        hMem = LocalAlloc(
                        NETLIB_LOCAL_ALLOCATION_FLAGS,
                        Size);                  // size in bytes
        NewAddress = (LPVOID) hMem;
    }
#else // ndef WIN32
#ifndef CDEBUG
    NewAddress = RtlAllocateHeap(
                RtlProcessHeap( ), 0,              // heap handle
                Size ));                        // bytes wanted
#else // def CDEBUG
    NetpAssert( Size == (DWORD) (size_t) Size );
    NewAddress = malloc( (size_t) Size ));
#endif // def CDEBUG
#endif // ndef WIN32

    NetpAssert( ROUND_UP_POINTER( NewAddress, ALIGN_WORST) == NewAddress);
    return (NewAddress);

} // NetpMemoryAllocate

VOID
NetpMemoryFree(
    IN LPVOID Address OPTIONAL
    )

/*++

Routine Description:

    Free memory at Address (must have been gotten from NetpMemoryAllocate or
    NetpMemoryReallocate).  (Address may be NULL.)

Arguments:

    Address - points to an area allocated by NetpMemoryAllocate (or
        NetpMemoryReallocate).

Return Value:

    None.

--*/

{
    NetpAssert( ROUND_UP_POINTER( Address, ALIGN_WORST) == Address);

#ifdef WIN32
    if (Address == NULL) {
        return;
    }
    if (LocalFree(Address) != NULL) {
        NetpAssert(FALSE);
    }
#else // ndef WIN32
#ifndef CDEBUG
    if (Address == NULL) {
        return;
    }
    RtlFreeHeap(
                RtlProcessHeap( ), 0,              // heap handle
                Address);                       // addr of alloc'ed space.
#else // def CDEBUG
    free( Address );
#endif // def CDEBUG
#endif // ndef WIN32
} // netpMemoryFree

/*
ULONG
MyRtlxOemStringToUnicodeSize(
    POEM_STRING OemString
)
{
    return ((OemString->Length + sizeof((UCHAR)NULL)) * sizeof(WCHAR));
}

ULONG
RtlxUnicodeStringToOemSize(
    PUNICODE_STRING UnicodeString
)
{
    return ((UnicodeString->Length + sizeof(UNICODE_NULL)) / sizeof(WCHAR));
}

*/
// from net\netlib\copystr.c

VOID
NetpCopyWStrToStr(
    OUT LPSTR  Dest,
    IN  LPWSTR Src
    )

/*++

Routine Description:

    NetpCopyWStrToStr copies characters from a source string
    to a destination, converting as it copies them.

Arguments:

    Dest - is an LPSTR indicating where the converted characters are to go.
        This string will be in the default codepage for the LAN.

    Src - is in LPWSTR indicating the source string.

Return Value:

    None.

--*/

{
    OEM_STRING DestAnsi;
    NTSTATUS NtStatus;
    UNICODE_STRING SrcUnicode;

    NetpAssert( Dest != NULL );
    NetpAssert( Src != NULL );
    NetpAssert( ((LPVOID)Dest) != ((LPVOID)Src) );
    NetpAssert( ROUND_UP_POINTER( Src, ALIGN_WCHAR ) == Src );

    *Dest = '\0';

    RtlInitString(
        & DestAnsi,             // output: struct
        Dest);                  // input: null terminated

    // Tell RTL routines there's enough memory out there.
    DestAnsi.MaximumLength = (USHORT) (wcslen(Src)+1);

    RtlInitUnicodeString(
        & SrcUnicode,           // output: struct
        Src);                   // input: null terminated

    NtStatus = RtlUnicodeStringToOemString(
        & DestAnsi,             // output: struct
        & SrcUnicode,           // input: struct
        (BOOLEAN) FALSE);       // don't allocate string.

    NetpAssert( NT_SUCCESS(NtStatus) );

} // NetpCopyWStrToStr



// from net\netlib\copystr.c

VOID
NetpCopyStrToWStr(
    OUT LPWSTR Dest,
    IN  LPSTR  Src
    )

/*++

Routine Description:

    NetpCopyStrToWStr copies characters from a source string
    to a destination, converting as it copies them.

Arguments:

    Dest - is an LPWSTR indicating where the converted characters are to go.

    Src - is in LPSTR indicating the source string.  This must be a string in
        the default codepage of the LAN.

Return Value:

    None.

--*/

{
    UNICODE_STRING DestUnicode;
    NTSTATUS NtStatus;
    OEM_STRING SrcAnsi;

    NetpAssert( Dest != NULL );
    NetpAssert( Src != NULL );
    NetpAssert( ((LPVOID)Dest) != ((LPVOID)Src) );
    NetpAssert( ROUND_UP_POINTER( Dest, ALIGN_WCHAR ) == Dest );

    *Dest = L'\0';

    RtlInitString(
        & SrcAnsi,              // output: struct
        Src);                   // input: null terminated

    RtlInitUnicodeString(
        & DestUnicode,          // output: struct
        Dest);                  // input: null terminated

    // Tell RTL routines there's enough memory out there.
    DestUnicode.MaximumLength = (USHORT)
        ((USHORT) (strlen(Src)+1)) * (USHORT) sizeof(wchar_t);

    NtStatus = RtlOemStringToUnicodeString(
        & DestUnicode,          // output: struct
        & SrcAnsi,              // input: struct
        (BOOLEAN) FALSE);       // don't allocate string.

    NetpAssert( NT_SUCCESS(NtStatus) );

} // NetpCopyStrToWStr

//
// Inline functions to convert between FILETIME and TimeStamp
//
#pragma warning( disable : 4035)    // Don't complain about no return

TimeStamp __inline
FileTimeToTimeStamp(
    const FILETIME *pft)
{
    _asm {
        mov edx, pft
        mov eax, [edx].dwLowDateTime
        mov edx, [edx].dwHighDateTime
    }
}

#pragma warning( default : 4035)    // Reenable warning

NTSTATUS
MyNtQuerySystemTime (
    OUT PTimeStamp SystemTimeStamp
    )
/*++

Routine Description:

    This routine returns the current system time (UTC), as a timestamp
    (a 64-bit unsigned integer, in 100-nanosecond increments).

Arguments:

    None.

Return Value:

    The current system time.

--*/

{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);

    *SystemTimeStamp = FileTimeToTimeStamp(&FileTime);

    return STATUS_SUCCESS; // WIN32_CHICAGO do something useful here
}

ULONG
MyUnicodeStringToMultibyteSize(
    IN PUNICODE_STRING UnicodeString,
    IN UINT CodePage
    )

/*++

Routine Description:

    This function computes the number of bytes required to store
    a NULL terminated oem/ansi string that is equivalent to the specified
    unicode string. If an oem/ansi string can not be formed or the specified
    unicode string is empty, the return value is 0.

Arguments:

    UnicodeString - Supplies a unicode string whose equivalent size as
        an oem string is to be calculated.

    CodePage - Specifies the code page used to perform the conversion.

Return Value:

    0 - The operation failed, the unicode string can not be translated
        into oem/ansi using the OEM/ANSI code page therefore no storage is
        needed for the oem/ansi string.

    !0 - The operation was successful.  The return value specifies the
        number of bytes required to hold an NULL terminated oem/ansi string
        equivalent to the specified unicode string.

--*/

{
    int cbMultiByteString = 0;

    if (UnicodeString->Length != 0) {
        cbMultiByteString = WideCharToMultiByte(
                                 CodePage,
                                 0, // WIN32_CHICAGO this is something else
                                 UnicodeString->Buffer,
                                 UnicodeString->Length / sizeof (WCHAR),
                                 NULL,
                                 0,
                                 NULL,
                                 NULL );
    }

    if ( cbMultiByteString > 0 ) {

        //
        // Add one byte for the NULL terminating character
        //
        return (ULONG) (cbMultiByteString + 1);

    } else {
        return 0;
    }

}

ULONG
MyMultibyteStringToUnicodeSize(
    IN PSTRING MultibyteString,
    IN UINT CodePage
    )

/*++

Routine Description:

    This function computes the number of bytes required to store
    a NULL terminated unicode string that is equivalent to the specified
    oem/ansi string. If a unicode string can not be formed or the specified
    ansi/oem string is empty, the return value is 0.

Arguments:

    UnicodeString - Supplies a unicode string whose equivalent size as
        an oem string is to be calculated.

    CodePage - Specifies the code page used to perform the conversion.

Return Value:

    0 - The operation failed, the oem/ansi string can not be translated
        into unicode using the OEM/ANSI code page therefore no storage is
        needed for the unicode string.

    !0 - The operation was successful.  The return value specifies the
        number of bytes required to hold an NULL terminated unicode string
        equivalent to the specified oem/ansi string.

--*/

{
    int ccUnicodeString = 0;

    if (MultibyteString->Length != 0) {
        ccUnicodeString = MultiByteToWideChar(
                                 CodePage,
                                 MB_PRECOMPOSED,
                                 MultibyteString->Buffer,
                                 MultibyteString->Length,
                                 NULL,
                                 0 );
    }

    if ( ccUnicodeString > 0 ) {

        //
        // Add the NULL terminating character
        //
        return (ULONG) ((ccUnicodeString + 1) * sizeof(WCHAR));

    } else {
        return 0;
    }

}

NTSTATUS
MyRtlOemStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN POEM_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified oem source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the oem source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the oem source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index = 0;
    NTSTATUS st = STATUS_SUCCESS;

    UnicodeLength = MyMultibyteStringToUnicodeSize( SourceString, CP_OEMCP );
    if ( UnicodeLength > MAXUSHORT || UnicodeLength == 0 ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (PWSTR) LocalAlloc(0, UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    if (SourceString->Length != 0)
    {
        Index = MultiByteToWideChar(
             CP_OEMCP,
             MB_PRECOMPOSED,
             SourceString->Buffer,
             SourceString->Length,
             DestinationString->Buffer,
             DestinationString->MaximumLength
             );

        if (Index == 0) {
            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
            }

            return STATUS_NO_MEMORY;
        }
    }

    DestinationString->Buffer[Index] = UNICODE_NULL;

    return st;
}

NTSTATUS
MyRtlUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    oem string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG OemLength;
    ULONG Index = 0;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;
    BOOL fUsed;

    OemLength = MyUnicodeStringToMultibyteSize( SourceString, CP_OEMCP );
    if ( OemLength > MAXUSHORT || OemLength == 0 ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (LPSTR)LocalAlloc(0, OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            /*
             * Return STATUS_BUFFER_OVERFLOW, but translate as much as
             * will fit into the buffer first.  This is the expected
             * behavior for routines such as GetProfileStringA.
             * Set the length of the buffer to one less than the maximum
             * (so that the trail byte of a double byte char is not
             * overwritten by doing DestinationString->Buffer[Index] = '\0').
             * RtlUnicodeToMultiByteN is careful not to truncate a
             * multibyte character.
             */
            if (!DestinationString->MaximumLength) {
                return STATUS_BUFFER_OVERFLOW;
            }
            ReturnStatus = STATUS_BUFFER_OVERFLOW;
            DestinationString->Length = DestinationString->MaximumLength - 1;
            }
        }

    if (SourceString->Length != 0)
    {
        Index = WideCharToMultiByte(
             CP_OEMCP,
             0, // WIN32_CHICAGO this is something else
             SourceString->Buffer,
             SourceString->Length / sizeof (WCHAR),
             DestinationString->Buffer,
             DestinationString->MaximumLength,
             NULL,
             &fUsed
             );

        if (Index == 0)
        { // WIN32_CHICAGO do something useful here
            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
            }
            return STATUS_NO_MEMORY;
        }
    }

    DestinationString->Buffer[Index] = '\0';

    return ReturnStatus;
}

NTSTATUS
MyRtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to ansi.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG AnsiLength;
    ULONG Index = 0;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;
    BOOL fUsed;

    AnsiLength = MyUnicodeStringToMultibyteSize( SourceString, CP_ACP );
    if ( AnsiLength > MAXUSHORT || AnsiLength == 0 ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)AnsiLength;
        DestinationString->Buffer = (LPSTR)LocalAlloc(0, AnsiLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            /*
             * Return STATUS_BUFFER_OVERFLOW, but translate as much as
             * will fit into the buffer first.  This is the expected
             * behavior for routines such as GetProfileStringA.
             * Set the length of the buffer to one less than the maximum
             * (so that the trail byte of a double byte char is not
             * overwritten by doing DestinationString->Buffer[Index] = '\0').
             * RtlUnicodeToMultiByteN is careful not to truncate a
             * multibyte character.
             */
            if (!DestinationString->MaximumLength) {
                return STATUS_BUFFER_OVERFLOW;
            }
            ReturnStatus = STATUS_BUFFER_OVERFLOW;
            DestinationString->Length = DestinationString->MaximumLength - 1;
            }
        }

    if (SourceString->Length != 0)
    {
        Index = WideCharToMultiByte(
             CP_ACP,
             0, // WIN32_CHICAGO this is something else
             SourceString->Buffer,
             SourceString->Length / sizeof (WCHAR),
             DestinationString->Buffer,
             DestinationString->MaximumLength,
             NULL,
             &fUsed
             );

        if (Index == 0)
        { // WIN32_CHICAGO do something useful here
            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
            }
            return STATUS_NO_MEMORY;
        }
    }

    DestinationString->Buffer[Index] = '\0';

    return ReturnStatus;
}

NTSTATUS
MyRtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the ansi source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the ansi source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index = 0;
    NTSTATUS st = STATUS_SUCCESS;

    UnicodeLength = MyMultibyteStringToUnicodeSize( SourceString, CP_ACP );
    if ( UnicodeLength > MAXUSHORT || UnicodeLength == 0 ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (PWSTR) LocalAlloc(0, UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    if (SourceString->Length != 0)
    {
        Index = MultiByteToWideChar(
             CP_ACP,
             MB_PRECOMPOSED,
             SourceString->Buffer,
             SourceString->Length,
             DestinationString->Buffer,
             DestinationString->MaximumLength
             );

        if (Index == 0) {
            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
            }

            return STATUS_NO_MEMORY;
        }
    }

    DestinationString->Buffer[Index] = UNICODE_NULL;

    return st;
}

// from ntos\rtl\random.c

#define Multiplier ((ULONG)(0x80000000ul - 19)) // 2**31 - 19
#define Increment  ((ULONG)(0x80000000ul - 61)) // 2**31 - 61
#define Modulus    ((ULONG)(0x80000000ul - 1))  // 2**31 - 1

ULONG
MyRtlUniform (
    IN OUT PULONG Seed
    )

/*++

Routine Description:

    A simple uniform random number generator, based on D.H. Lehmer's 1948
    alrogithm.

Arguments:

    Seed - Supplies a pointer to the random number generator seed.

Return Value:

    ULONG - returns a random number uniformly distributed over [0..MAXLONG]

--*/

{
    *Seed = ((Multiplier * (*Seed)) + Increment) % Modulus;
    return *Seed;
}

// from net\netlib\allocstr.c

LPSTR
NetpAllocAStrFromWStr (
    IN LPCWSTR Unicode
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding ASCII
    string.

Arguments:

    Unicode - Specifies the UNICODE zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated ASCII string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    OEM_STRING AnsiString = {0};
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    if(!NT_SUCCESS( RtlUnicodeStringToAnsiString( &AnsiString,
                                                  &UnicodeString,
                                                  TRUE))){
        return NULL;
    }

    return AnsiString.Buffer;

} // NetpAllocAStrFromWStr

// from net\netlib\allocstr.c

LPWSTR
NetpAllocWStrFromAStr(
    IN LPCSTR Ansi
    )

/*++

Routine Description:

    Convert an ASCII (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Ansi - Specifies the ASCII zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString = {0};

    RtlInitString( &AnsiString, Ansi );

    if(!NT_SUCCESS( RtlAnsiStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  TRUE))){
        return NULL;
    }

    return UnicodeString.Buffer;

} // NetpAllocWStrFromAStr

LPWSTR
NetpAllocWStrFromOemStr(
    IN LPCSTR Oem
    )

/*++

Routine Description:

    Convert an OEM (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Oem - Specifies the OEM zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    OEM_STRING OemString;
    UNICODE_STRING UnicodeString = {0};

    RtlInitString( &OemString, Oem );

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &OemString,
                                                  TRUE))){
        return NULL;
    }

    return UnicodeString.Buffer;

} // NetpAllocWStrFromOemStr

// from net\netlib\allocstr.c

LPWSTR
NetpAllocWStrFromWStr(
    IN LPWSTR Unicode
    )

/*++

Routine Description:

    Allocate and copy unicode string (wide character strdup)

Arguments:

    Unicode - pointer to wide character string to make copy of


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    NET_API_STATUS status;
    DWORD   size;
    LPWSTR  ptr;

    size = wcslen(Unicode);
    size = (size + 1) * sizeof (WCHAR);
    status = NetApiBufferAllocate(size, (LPVOID *) (LPVOID) &ptr);
    if (status != NO_ERROR) {
        return NULL;
    }
    RtlCopyMemory(ptr, Unicode, size);
    return ptr;
} // NetpAllocWStrFromWStr

NET_API_STATUS
NetpGetDomainNameExEx (
    OUT LPWSTR *DomainNamePtr,
    OUT LPWSTR *DnsDomainNamePtr OPTIONAL,
    OUT PBOOLEAN IsworkgroupName
    )
{
    NET_API_STATUS NetStatus = NO_ERROR;
    return NetStatus;
}

// from net\api\canonapi.c
NET_API_STATUS
NET_API_FUNCTION
NetpNameCanonicalize(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name,
    OUT LPWSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Canonicalizes a name

Arguments:

    ServerName  - where to run this API
    Name        - name to canonicalize
    Outbuf      - where to put canonicalized name
    OutbufLen   - length of Outbuf
    NameType    - type of name to canonicalize
    Flags       - control flags

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS status = 0;
    DWORD location;
    WCHAR serverName[MAX_PATH];
    DWORD val;
    WCHAR ch;

    //
    // validate parameters
    //

    try {
        if (ARGUMENT_PRESENT(ServerName)) {
//            val = STRLEN(ServerName);
            val = wcslen(ServerName);
        }
        if (ARGUMENT_PRESENT(Name)) {
//            val = STRLEN(Name);
            val = wcslen(Name);
        }
        if (ARGUMENT_PRESENT(Outbuf)) {
            ch = (volatile WCHAR)*Outbuf;
            *Outbuf = ch;
            ch = (volatile WCHAR)*(Outbuf + OutbufLen/sizeof(*Outbuf) - sizeof(*Outbuf));
            *(Outbuf + OutbufLen/sizeof(*Outbuf) - sizeof(*Outbuf)) = ch;
        } else {
            status = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_INVALID_PARAMETER;
    }
    if (status) {
        return status;
    }

    //
    // call client-side RPC routine or local canonicalization routine
    //

    return NetpwNameCanonicalize(Name, Outbuf, OutbufLen, NameType, Flags);
//      return NetpwNameValidate(Name, NameType, 0);
}

// from net\netlib\names.c
BOOL
NetpIsDomainNameValid(
    IN LPWSTR DomainName
    )

/*++

Routine Description:

    NetpIsDomainNameValid checks for "domain" format.
    The name is only checked syntactically; no attempt is made to determine
    whether or not a domain with that name actually exists.

Arguments:

    DomainName - Supplies an alleged Domain name.

Return Value:

    BOOL - TRUE if name is syntactically valid, FALSE otherwise.

--*/

{
    NET_API_STATUS ApiStatus = NO_ERROR;
    WCHAR CanonBuf[DNLEN+1];

    if (DomainName == (LPWSTR) NULL) {
        return (FALSE);
    }
    if ( (*DomainName) == TCHAR_EOS ) {
        return (FALSE);
    }

    ApiStatus = NetpNameCanonicalize(
            NULL,                       // no server name
            DomainName,                 // name to validate
            CanonBuf,                   // output buffer
            (DNLEN+1) * sizeof(WCHAR), // output buffer size
            NAMETYPE_DOMAIN,           // type
            0 );                       // flags: none

    return (ApiStatus == NO_ERROR);

} // NetpIsDomainNameValid

VOID
MyRtlFreeAnsiString(
    IN OUT PANSI_STRING AnsiString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToAnsiString.  Note that only AnsiString->Buffer
    is free'd by this routine.

Arguments:

    AnsiString - Supplies the address of the ansi string whose buffer
        was previously allocated by RtlUnicodeStringToAnsiString.

Return Value:

    None.

--*/

{
    if (AnsiString->Buffer) {
        LocalFree(AnsiString->Buffer);
        ZeroMemory( AnsiString, sizeof( *AnsiString ) );
        }
}

VOID
MyRtlFreeOemString(
    IN OUT POEM_STRING OemString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToOemString.  Note that only OemString->Buffer
    is free'd by this routine.

Arguments:

    OemString - Supplies the address of the oem string whose buffer
        was previously allocated by RtlUnicodeStringToOemString.

Return Value:

    None.

--*/

{
    if (OemString->Buffer) {
        LocalFree(OemString->Buffer);
        ZeroMemory( OemString, sizeof( *OemString ) );
        }
}

VOID
MyRtlFreeUnicodeString(
    IN OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlAnsiStringToUnicodeString.  Note that only UnicodeString->Buffer
    is free'd by this routine.

Arguments:

    UnicodeString - Supplies the address of the unicode string whose
        buffer was previously allocated by RtlAnsiStringToUnicodeString.

Return Value:

    None.

--*/

{

    if (UnicodeString->Buffer) {
        LocalFree(UnicodeString->Buffer);
        ZeroMemory( UnicodeString, sizeof( *UnicodeString ) );
        }
}

DWORD
MyUniToUpper(WCHAR *dest, WCHAR *src, DWORD len)
{
    WCHAR *wcp = dest;

    while (*src != L'\0') {
        *wcp++ = towupper(*src);
        src++;
    }

    return(wcp - dest);
}

NTSTATUS
MyRtlUpcaseUnicodeToOemN(
    IN PUNICODE_STRING SourceUnicodeString,
    OUT POEM_STRING DestinationOemString )

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into an oem string. The translation is done with respect
    to the OEM Code Page (OCP) loaded at boot time.  The resulting oem
    string is allocated by this routine and should be deallocated using
    MyRtlFreeOemString.

    This function mimics the behavior of RtlUpcaseUnicodeToOemN.  It first
    converts the supplied unicode string into the oem string and then
    converts the oem string back to a unicode string.  This is done because
    two different unicode strings may be converted into one oem string, but
    converting back to unicode will create the right unicode string according
    to the OEM Code Page (OCP) loaded at boot time.  The resulting unicode
    string is uppercased and then converted to the oem string returned to the
    caller.

Arguments:

    SourceUnicodeString - Supplies the unicode source string that is to be
        converted to oem.

    DestinationOemString - Returns an oem string that is equivalent to the
        upper case of the unicode source string.  If the translation can not
        be done, an error is returned.

Return Value:

    SUCCESS - The conversion was successful
    Otherwise, an error is returned

--*/

{
    NTSTATUS Status;
    OEM_STRING TmpOemString;
    UNICODE_STRING TmpUnicodeString;

    //
    // Initialization
    //

    TmpOemString.Buffer = NULL;
    TmpUnicodeString.Buffer = NULL;


    //
    // First convert the source unicode string into a
    // temprary oem string
    //

    Status = MyRtlUnicodeStringToOemString( &TmpOemString,
                                            SourceUnicodeString,
                                            TRUE );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Then convert the resulting oem string back to unicode
    //

    Status = MyRtlOemStringToUnicodeString( &TmpUnicodeString,
                                            &TmpOemString,
                                            TRUE );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Now uppercase the resulting unicode string in place
    //

    MyUniToUpper( TmpUnicodeString.Buffer, TmpUnicodeString.Buffer, TmpUnicodeString.Length );

    //
    // Finally, convert the unicode string into the resulting oem string
    //

    Status = MyRtlUnicodeStringToOemString( DestinationOemString,
                                            &TmpUnicodeString,
                                            TRUE );

Cleanup:

    MyRtlFreeOemString( &TmpOemString );
    MyRtlFreeUnicodeString( &TmpUnicodeString );

    return Status;
}

LPSTR
MyNetpLogonUnicodeToOem(
    IN LPWSTR Unicode
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding
    uppercased oem string.

Arguments:

    Unicode - Specifies the UNICODE zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated uppercased
    oem string in an allocated buffer.  The buffer can be freed using
    NetpMemoryFree.

--*/

{
    OEM_STRING OemString;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    MyRtlInitUnicodeString( &UnicodeString, Unicode );

    Status = MyRtlUpcaseUnicodeToOemN( &UnicodeString, &OemString);

    if( NT_SUCCESS(Status) ) {
        return OemString.Buffer;
    } else {
        return NULL;
    }
}

LONG
NlpChcg_wcsicmp(
    IN LPCWSTR string1,
    IN LPCWSTR string2
    )

/*++

Routine Description:

    Perform case insensitive, locale independent comparison of two
    unicode strings.  This matches the behavior of _wcsicmp that is
    broken on Win9x because it has no unicode support.

Arguments:

    string1, string2 - Specifies the UNICODE zero terminated strings to compare.


Return Value:

    0  if the strings are equal
    -1 if string1 is less than string2
    1  if string1 is greater than string2

--*/

{
    int cc;
    LPSTR AString1 = NULL;
    LPSTR AString2 = NULL;

    AString1 = NetpAllocAStrFromWStr( string1 );
    if ( AString1 == NULL ) {
        cc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    AString2 = NetpAllocAStrFromWStr( string2 );
    if ( AString2 == NULL ) {
        cc = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    cc = CompareStringA( 0,   // deliberately NOT locale sensitive
                         NORM_IGNORECASE | NORM_IGNOREWIDTH | NORM_IGNOREKANATYPE | SORT_STRINGSORT,
                         (LPCSTR) AString1, -1,
                         (LPCSTR) AString2, -1 );

Cleanup:

    if ( AString1 != NULL ) {
        NetApiBufferFree( AString1 );
    }

    if ( AString2 != NULL ) {
        NetApiBufferFree( AString2 );
    }

    switch ( cc ) {
    case ERROR_NOT_ENOUGH_MEMORY:
        return ERROR_NOT_ENOUGH_MEMORY;
    case CSTR_EQUAL:
        return 0;
    case CSTR_LESS_THAN:
        return -1;
    case CSTR_GREATER_THAN:
        return 1;
    case 0:
        NlPrint(( NL_CRITICAL, "Cannot CompareStringW: 0x%lx\n", GetLastError() ));
    default:
        return _NLSCMPERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <nt.h>         // LARGE_INTEGER definition
#include <lsass.h>      // OLD_LARGE_INTEGER definition
#include <windef.h>
#include <lmcons.h>
#include <ntsam.h>
#include <lmaccess.h>
#include <netlogon.h>
#include <crypt.h>
#include <logonmsv.h>
#include <ntlsa.h>
#include <ssi.h>
#include <dsgetdc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\winnt5\nlcommon.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    nlcommon.c

Abstract:

    Just an include for ..\..\nlcommon.c

Author:

    ChandanS 09-April-1998

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include "..\..\idl\nlcommon.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\client\winnt5\makefile.inc ===
nlcommon.c: ..\..\idl\nlcommon.c
cpnetpdc.c: ..\..\idl\netpdc.c
logon_c_stub.c: ..\..\idl\$(O)\logon_c.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

!INCLUDE $(NTMAKEENV)\makefile.plt

IDL_NAME = logon
IMPORT   = imports

CLIENT_H = logon_c.h
SERVER_H = logon_s.h

CLIENT_ACF = logoncli.acf
SERVER_ACF = logonsrv.acf

!IFNDEF DISABLE_NET_UNICODE
UNICODE=1
NET_C_DEFINES=-DUNICODE
!ENDIF

INCS  = -I$(SDK_INC_PATH) -I$(CRT_INC_PATH) -I$(PROJECT_ROOT)\netapi\inc \
        -I$(DS_INC_PATH) -I$(NET_INC_PATH) -I$(BASE_INC_PATH) -I$(PROJECT_ROOT)\inc

CLIENT_TARGETS = $(O)\$(IDL_NAME)_c.c $(O)\$(CLIENT_H)
SERVER_TARGETS = $(O)\$(IDL_NAME)_s.c $(O)\$(SERVER_H)

TARGETS = $(CLIENT_TARGETS) $(SERVER_TARGETS)

CLIENT_FLAGS = -acf $(CLIENT_ACF) -header $(CLIENT_H) -oldnames -server none -out .\$(O)
SERVER_FLAGS = -acf $(SERVER_ACF) -header $(SERVER_H) -oldnames -client none -out .\$(O)

CPP = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES)

#
# MIDL COMPILE
#

$(CLIENT_TARGETS) : .\$(IDL_NAME).idl .\$(IMPORT).idl .\$(IMPORT).h .\$(CLIENT_ACF)
    midl $(MIDL_OPTIMIZATION) -ms_ext -c_ext $(CPP) $(CLIENT_FLAGS) $(INCS) .\$(IDL_NAME).idl


$(SERVER_TARGETS) : .\$(IDL_NAME).idl .\$(IMPORT).idl .\$(IMPORT).h .\$(SERVER_ACF)
    midl $(MIDL_OPTIMIZATION) -ms_ext -c_ext $(CPP) $(SERVER_FLAGS) $(INCS) .\$(IDL_NAME).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\idl\nlbind.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nlbind.h

Abstract:

    Interface to the Netlogon service RPC handle cacheing routines

Author:

    Cliff Van Dyke (01-Oct-1993)

Revision History:

--*/

//
// Interface between RPC and Netlogon's security package.
//
#ifndef RPC_C_AUTHN_NETLOGON
#define RPC_C_AUTHN_NETLOGON 0x44
#define NL_PACKAGE_NAME            L"NetlogonSspi"
#endif // RPC_C_AUTHN_NETLOGON

////////////////////////////////////////////////////////////////////////////
//
// Procedure forwards
//
////////////////////////////////////////////////////////////////////////////

typedef enum _NL_RPC_BINDING {
    UseAny = 0,
    UseNamedPipe,
    UseTcpIp
} NL_RPC_BINDING;

NET_API_STATUS
NlBindingAttachDll (
    VOID
    );

VOID
NlBindingDetachDll (
    VOID
    );

NTSTATUS
NlBindingAddServerToCache (
    IN LPWSTR UncServerName,
    IN NL_RPC_BINDING RpcBindingType
    );

NTSTATUS
NlBindingSetAuthInfo (
    IN LPWSTR UncServerName,
    IN NL_RPC_BINDING RpcBindingType,
    IN BOOL SealIt,
    IN PVOID ClientContext,
    IN LPWSTR ServerContext
    );

NTSTATUS
NlBindingRemoveServerFromCache (
    IN LPWSTR UncServerName,
    IN NL_RPC_BINDING RpcBindingType
    );

NTSTATUS
NlRpcpBindRpc(
    IN LPWSTR ServerName,
    IN LPWSTR ServiceName,
    IN LPWSTR NetworkOptions,
    IN NL_RPC_BINDING RpcBindingType,
    OUT RPC_BINDING_HANDLE *pBindingHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\idl\netpdc.c ===
//depot/Lab02_N/DS/netapi/svcdlls/logonsrv/idl/netpdc.c#6 - integrate change 5756 (text)
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    NetpDc.c

Abstract:

    Routines shared by logonsrv\server and logonsrv\common

Author:

    Cliff Van Dyke (cliffv) 20-July-1996

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#ifndef _NETLOGON_SERVER
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>      // Needed by netlogon.h
#include <ntlsa.h>
#include <rpc.h>        // RPC_STATUS

#include <windef.h>
#include <winbase.h>
#include <winsock2.h>

#include <lmcons.h>     // General net defines
#include <dsgetdc.h>    // DsGetDcName()
#include <dsgetdcp.h>

#include <align.h>      // ROUND_UP_COUNT()
#include <config.h>     // NetConfig
#include <lmsname.h>    // SERVICE_TCPIP
#include <lmerr.h>      // System Error Log definitions
#include <icanon.h>     // NetpNameValidate()
#include <lmapibuf.h>   // NetapipBufferAllocate
#include <lmaccess.h>   // UF_*
#include <names.h>      // NetpIsDomainNameValid()
#include <netlib.h>     // NetpMemoryAllcate(
#include <netlibnt.h>   // NetpApiStatusToNtStatus();
#include <netlogon.h>   // Definition of mailslot messages
#include <ntddbrow.h>   // Needed by nlcommon.h
#include <ntrpcp.h>
#include <logonp.h>     // NetpLogon.. routines
#include <tstring.h>    // NetpCopyStrToWStr()
#include <time.h>       // time() function from C runtime
#if DBG
#define NETLOGONDBG 1
#endif // DBG
#include <nldebug.h>    // NlPrint()
#include <nlbind.h>   // Definitions shared with netlogon
#include <nlcommon.h>   // Definitions shared with netlogon
#ifdef WIN32_CHICAGO
#include "ntcalls.h"
BOOLEAN CodePage = TRUE; // Alway be DBCS
BOOLEAN *NlsMbOemCodePageTag = &CodePage;
#endif // WIN32_CHICAGO
#include <iniparm.h>

#endif // _NETLOGON_SERVER
#include <svcguid.h>     // SVCID_INET_HOSTADDRBYNAME
#define OLD_DNS_RECORD 1 // Needed for dnsapi.h
#include <dnsapi.h>      // DnsNameCompare_W
#include <dnssrv.h>      // NetpSrv...
#include <winldap.h>     // ldap_...

//
// Include nlcommon.h again allocating the actual variables
// this time around.
//

#define NLCOMMON_ALLOCATE
#include "nlcommon.h"
#undef NLCOMMON_ALLOCATE



//
// Context describing the SRV records for a DNS name.
//
typedef struct _DSGETDC_CONTEXT {

    //
    // Original parameters passed by the caller.
    //
    LPSTR QueriedDnsName;
    LPWSTR QueriedSiteName;
    GUID QueriedDomainGuid;
    LPSTR QueriedDnsForestName;
    DWORD QueriedInternalFlags;
    // NL_DNS_NAME_TYPE QueriedNlDnsNameType;

    //
    // Type of this DNS name being queried.
    //
    NL_DNS_NAME_TYPE NlDnsNameType;

    //
    // Context of the current DNS name.
    //
    HANDLE SrvContextHandle;


    //
    // Flags
    //

    ULONG QueriedFlags;         // Flags passed to DsGetDcOpen
    BOOLEAN FirstTime;          // This is the first DnsGetDcNext call

} DSGETDC_CONTEXT, *PDSGETDC_CONTEXT;


//
// List of previously cached responses.
//
CRITICAL_SECTION NlDcCritSect;
LIST_ENTRY NlDcDomainList;
ULONG NlDcDomainCount;
#define NL_DC_MAX_DOMAINS 2000  // Avoid infinite domains.

GUID NlDcZeroGuid;
DWORD NlDcDnsFailureTime;


//
// Determine if the passed in DWORD has precisely one bit set.
//

#define JUST_ONE_BIT( _x ) (((_x) != 0 ) && ( ( (~(_x) + 1) & (_x) ) == (_x) ))


// If the caller passes ANY of these flags,
//  only an NT 5.0 (or newer) DC should respond.
#define DS_NT50_REQUIRED    (DS_DIRECTORY_SERVICE_REQUIRED | \
                             DS_GC_SERVER_REQUIRED | \
                             DS_IP_REQUIRED | \
                             DS_RETURN_DNS_NAME | \
                             DS_KDC_REQUIRED | \
                             DS_TIMESERV_REQUIRED | \
                             DS_IS_DNS_NAME )

// If the caller passes ANY of these flags,
//  an NT 5.0 (or newer) DC should respond.
#define DS_NT50_WANTED      (DS_NT50_REQUIRED | \
                             DS_DIRECTORY_SERVICE_PREFERRED )



//
// Define an exception filter to improve debuggin capabilities.
//
#ifdef _NETLOGON_SERVER
#define NL_EXCEPTION    NlExceptionFilter(GetExceptionInformation())

LONG
NlExceptionFilter( EXCEPTION_POINTERS *    pException)
{
#if DBG
    DbgPrint("[Netlogon] exception in DsGetDcName.\n" );
    DbgBreakPoint();
#endif // DBG
    return EXCEPTION_EXECUTE_HANDLER;
    UNREFERENCED_PARAMETER( pException );
}
#endif // _NETLOGON_SERVER




/*++

Routine Description:

    This macro clears all of the negative cache fields for a particular DC entry.

Arguments:

    _DcEntry -- Address of the entry to flush

Return Value:

    None

--*/
#ifdef _NETLOGON_SERVER
#define NlFlushNegativeCacheEntry( _DcEntry ) \
        (_DcEntry)->NegativeCacheTime = 0; \
        (_DcEntry)->ExpBackoffPeriod = 0; \
        (_DcEntry)->BackgroundRetryInitTime.QuadPart = 0; \
        (_DcEntry)->PermanentNegativeCache = FALSE;
#else // _NETLOGON_SERVER
#define NlFlushNegativeCacheEntry( _DcEntry )
#endif // _NETLOGON_SERVER




#if NETLOGONDBG
LPSTR
NlMailslotOpcode(
    IN WORD Opcode
    )

/*++

Routine Description:

    Return string describing mailslot message.

Arguments:

    Opcode: Opcode of message

Return Value:

    String corresponding to opcode

--*/

{
    switch ( Opcode ) {
    case LOGON_REQUEST:
        return "UAS Logon";
    case LOGON_RESPONSE:
        return "UAS Logon Response <old>";
    case LOGON_CENTRAL_QUERY:
        return "CENTRAL_QUERY";
    case LOGON_DISTRIB_QUERY:
        return "DISTRIB_QUERY";
    case LOGON_CENTRAL_RESPONSE:
        return "CENTRAL_RESPONSE";
    case LOGON_DISTRIB_RESPONSE:
        return "DISTRIB_RESPONSE";
    case LOGON_RESPONSE2:
        return "Uas Logon Response";
    case LOGON_PRIMARY_QUERY:
        return "Primary Query";
    case LOGON_START_PRIMARY:
        return "Start Primary";
    case LOGON_FAIL_PRIMARY:
        return "Fail Primary";
    case LOGON_UAS_CHANGE:
        return "Uas Change";
    case LOGON_NO_USER:
        return "Uas No User <old>";
    case LOGON_PRIMARY_RESPONSE:
        return "Primary Response";
    case LOGON_RELOGON_RESPONSE:
        return "RELOGON_RESPONSE";
    case LOGON_WKSTINFO_RESPONSE:
        return "WKSTINFO_RESPONSE";
    case LOGON_PAUSE_RESPONSE:
        return "Uas Pause Response";
    case LOGON_USER_UNKNOWN:
        return "Uas No User";
    case LOGON_UPDATE_ACCOUNT:
        return "UPDATE_ACCOUNT";
    case LOGON_SAM_LOGON_REQUEST:
        return "Sam Logon";
    case LOGON_SAM_LOGON_RESPONSE:
        return "Sam Logon Response";
    case LOGON_SAM_PAUSE_RESPONSE:
        return "Sam Pause Response";
    case LOGON_SAM_USER_UNKNOWN:
        return "Sam User Unknown";
    case LOGON_SAM_LOGON_RESPONSE_EX:
        return "Sam Logon Response Ex";
    case LOGON_SAM_PAUSE_RESPONSE_EX:
        return "Sam Pause Response Ex";
    case LOGON_SAM_USER_UNKNOWN_EX:
        return "Sam User Unknown Ex";
    default:
        return "<Unknown>";
    }
}

LPSTR
NlDgrNameType(
    IN DGRECEIVER_NAME_TYPE NameType
    )

/*++

Routine Description:

    Return string describing datagram receiver name type.

Arguments:

    NameType: Name type of interest.

Return Value:

    String corresponding to name type

--*/

{
    switch ( NameType ) {
    case ComputerName:
        return "00";
    case PrimaryDomain:
        return "00";
    case LogonDomain:
        return "LogonDomain";
    case OtherDomain:
        return "OtherDomain";
    case DomainAnnouncement:
        return "__MSBROWSE__";
    case MasterBrowser:
        return "1D";
    case BrowserElection:
        return "1E";
    case BrowserServer:
        return "20";
    case DomainName:
        return "1C";
    case PrimaryDomainBrowser:
        return "1B";
    case AlternateComputerName:
        return "Alternate";
    default:
        return "<Unknown>";
    }
}
#endif // NETLOGONDBG


BOOLEAN
NlReadDwordHklmRegValue(
    IN LPCSTR SubKey,
    IN LPCSTR ValueName,
    OUT PDWORD ValueRead
    )

/*++

Routine Description:

    Reads a DWORD from the specified registry location.

Arguments:

    SubKey - Subkey of the value to read.

    ValueName - The name of the value to read.

    ValueRead - Returns the value read from the registry.

Return Status:

    TRUE - We've successfully read the data.
    FALSE - We've not been able to read the data successfully.

--*/

{
    LONG RegStatus;

    HKEY KeyHandle = NULL;
    DWORD ValueType;
    DWORD Value;
    DWORD ValueSize;

    //
    // Open the key
    //

    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    SubKey,
                    0,      //Reserved
                    KEY_QUERY_VALUE,
                    &KeyHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        NlPrint(( 0,
                  "NlReadDwordHklmRegValue: Cannot open registy key 'HKLM\\%s' %ld.\n",
                  SubKey,
                  RegStatus ));
        return FALSE;
    }

    //
    // Get the value
    //

    ValueSize = sizeof(Value);
    RegStatus = RegQueryValueExA(
                    KeyHandle,
                    ValueName,
                    0,
                    &ValueType,
                    (LPBYTE)&Value,
                    &ValueSize );

    RegCloseKey( KeyHandle );

    if ( RegStatus != ERROR_SUCCESS ) {
        NlPrint(( 0,
                  "NlReadDwordHklmRegValue: Cannot query value of 'HKLM\\%s\\%s' %ld.\n",
                  SubKey,
                  ValueName,
                  RegStatus ));
        return FALSE;
    }

    if ( ValueType != REG_DWORD ) {
        NlPrint(( 0,
                  "NlReadDwordHklmRegValue: value of 'HKLM\\%s\\%s'is not a REG_DWORD %ld.\n",
                  SubKey,
                  ValueName,
                  ValueType ));
        return FALSE;
    }

    if ( ValueSize != sizeof(Value) ) {
        NlPrint(( 0,
                  "NlReadDwordHklmRegValue: value size of 'HKLM\\%s\\%s'is not 4 %ld.\n",
                  SubKey,
                  ValueName,
                  ValueSize ));
        return FALSE;
    }

    //
    // We've successfully read the data
    //

    *ValueRead = Value;
    return TRUE;

}


BOOLEAN
NlReadDwordNetlogonRegValue(
    IN LPCSTR ValueName,
    OUT PDWORD Value
    )

/*++

Routine Description:

    This is common code (i.e. not netlogon specific) that reads
    a DWORD from Netlogon specific locations in registry. It
    first reads the value from the Netlogon Group Policy section.
    If the value is not specified in teh GP section, this routine
    reads the value from the Netlogon PArameters section.

Arguments:

    ValueName - The name of the value to read.

    Value - Returns the value read from the registry.

Return Status:

    TRUE - We've successfully read the data.
    FALSE - We've not been able to read the data successfully.

--*/

{
    BOOLEAN Result = FALSE;
    DWORD LocalValue = 0;

    //
    // The value given in Netlogon GP section takes precedence.
    //

    Result = NlReadDwordHklmRegValue( NL_GPPARAM_KEY,  // GP section
                                      ValueName,
                                      &LocalValue );

    //
    // If the value is not specified in the netlogon GP section,
    //  see if it is in the Netlogon Parameters section.
    //

    if ( !Result ) {
        Result = NlReadDwordHklmRegValue( NL_PARAM_KEY,  // Netlogon Parameters section
                                          ValueName,
                                          &LocalValue );
    }

    if ( Result ) {
        *Value = LocalValue;
        return TRUE;
    }

    return FALSE;
}

VOID
NetpIpAddressToStr(
    ULONG IpAddress,
    CHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1]
    )
/*++

Routine Description:

    Convert an IP address to a string.

Arguments:

    IpAddress - IP Address to convert

    IpAddressString - resultant string.

Return Value:

    None.

--*/
{
    struct in_addr InetAddr;
    char * InetAddrString;

    //
    // Convert the address to ascii
    //
    InetAddr.s_addr = IpAddress;
    InetAddrString = inet_ntoa( InetAddr );

    //
    // Copy the string our to the caller.
    //

    if ( InetAddrString == NULL ||
         strlen(InetAddrString) > NL_IP_ADDRESS_LENGTH ) {
        *IpAddressString = L'\0';
    } else {
        strcpy( IpAddressString, InetAddrString );
    }

    return;
}

VOID
NetpIpAddressToWStr(
    ULONG IpAddress,
    WCHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1]
    )
/*++

Routine Description:

    Convert an IP address to a string.

Arguments:

    IpAddress - IP Address to convert

    IpAddressString - resultant string.

Return Value:

    None.

--*/
{
    CHAR IpAddressStr[NL_IP_ADDRESS_LENGTH+1];
    NetpIpAddressToStr( IpAddress, IpAddressStr );
    NetpCopyStrToWStr( IpAddressString, IpAddressStr );
}


NET_API_STATUS
NetpSockAddrToStr(
    PSOCKADDR SockAddr,
    ULONG SockAddrSize,
    CHAR SockAddrString[NL_SOCK_ADDRESS_LENGTH+1]
    )
/*++

Routine Description:

    Convert an socket address to a string.

Arguments:

    SockAddr - Socket Address to convert

    SockAddrSize - Size (in bytes) of SockAddr

    SockAddrString - resultant string.

Return Value:

    NO_ERROR: if translation was successful

--*/
{
    int WsaError;
    ULONG AddressLength;
#ifdef WIN32_CHICAGO
    LPSTR pTemp;
#endif // WIN32_CHICAGO

    //
    // Convert the address to text.
    //

    AddressLength = NL_SOCK_ADDRESS_LENGTH+1;
#ifndef WIN32_CHICAGO // Needs Winsock2
    WsaError = WSAAddressToStringA( SockAddr,
                                    SockAddrSize,
                                    NULL,
                                    SockAddrString,
                                    &AddressLength );

    if ( WsaError != 0 ) {
        *SockAddrString = '\0';
        WsaError = WSAGetLastError();
        NlPrint(( NL_CRITICAL,
                  "NetpSockAddrToStr: Cannot convert socket address %ld\n",
                  WsaError ));
        return WsaError;
    }
#else // WIN32_CHICAGO
    // cast the PSOCKADDR to a sockaddr_in and access sin_addr
     pTemp = inet_ntoa(((SOCKADDR_IN *) SockAddr)->sin_addr);
     if ( pTemp != NULL ) {
         strcpy(SockAddrString, pTemp);
     } else {
         *SockAddrString = '\0';
         return ERROR_INTERNAL_ERROR;
     }
#endif // WIN32_CHICAGO

    return NO_ERROR;
}

NET_API_STATUS
NetpSockAddrToWStr(
    PSOCKADDR SockAddr,
    ULONG SockAddrSize,
    WCHAR SockAddrString[NL_SOCK_ADDRESS_LENGTH+1]
    )
/*++

Routine Description:

    Convert an socket address to a string.

Arguments:

    SockAddr - Socket Address to convert

    SockAddrSize - Size (in bytes) of SockAddr

    SockAddrString - resultant string.

Return Value:

    TRUE if translation was successful

--*/
{
    int WsaError;
    ULONG AddressLength;
#ifdef WIN32_CHICAGO
    CHAR OemSockAddrString[NL_SOCK_ADDRESS_LENGTH+1];
    OEM_STRING OemString;
    UNICODE_STRING UnicodeString;
#endif // WIN32_CHICAGO

    //
    // Convert the address to text.
    //

    AddressLength = NL_SOCK_ADDRESS_LENGTH+1;
#ifndef WIN32_CHICAGO
    WsaError = WSAAddressToStringW( SockAddr,
                                    SockAddrSize,
                                    NULL,
                                    SockAddrString,
                                    &AddressLength );

    if ( WsaError != 0 ) {
        *SockAddrString = '\0';
        WsaError = WSAGetLastError();
        NlPrint(( NL_CRITICAL,
                  "NetpSockAddrToWStr: Cannot convert socket address %ld\n",
                  WsaError ));
        return WsaError;
    }
#else // WIN32_CHICAGO
    // cast the PSOCKADDR to a sockaddr_in and access sin_addr
    WsaError = NetpSockAddrToStr( SockAddr,
                                 SockAddrSize,
                                 OemSockAddrString);

     RtlInitString(&OemString, OemSockAddrString);
     UnicodeString.MaximumLength = ((USHORT)AddressLength) * sizeof(WCHAR);
     UnicodeString.Buffer = SockAddrString;
     RtlOemStringToUnicodeString(&UnicodeString, &OemString, FALSE);
#endif // WIN32_CHICAGO

    return WsaError;
}

LPWSTR
NetpAllocWStrFromUtf8Str(
    IN LPSTR Utf8String
    )

/*++

Routine Description:

    Convert a UTF8 (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Utf8String - Specifies the UTF8 zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    return NetpAllocWStrFromUtf8StrEx( Utf8String, -1 );
}

ULONG
NetpUtf8ToUnicodeLen(
    IN LPSTR Utf8String
    )

/*++

Routine Description:

    Returns the number of UNICODE characters that will result if the
    specified UTF8 (zero terminated) string is converted to UNICODE.
    The resultant character count does not include the trailing zero terminator.

Arguments:

    Utf8String - Specifies the UTF8 zero terminated string to convert.


Return Value:

    Number of characters.

--*/

{

    ULONG UnicodeLen;

    //
    // Determine the length of the Unicode string.
    //

#ifndef WIN32_CHICAGO
    // No support for UTF8/7 char on Win95. Use the entry points
    // exported in wldap32.dll

    UnicodeLen = MultiByteToWideChar(
                        CP_UTF8,
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,     // NULL terminated.
                        NULL,
                        0 );
    if ( UnicodeLen == 0 ) {
        return 0;
    }
    return UnicodeLen - 1;

#else // WIN32_CHICAGO
    UnicodeLen = LdapUTF8ToUnicode(
                        Utf8String,
                        strlen(Utf8String),
                        NULL,
                        0 );

    return UnicodeLen ;

#endif // WIN32_CHICAGO

}

VOID
NetpCopyUtf8StrToWStr(
    OUT LPWSTR UnicodeString,
    IN LPSTR Utf8String
    )

/*++

Routine Description:

    Convert a UTF8 (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    UnicodeString - Specifies the buffer the UTF8 string is to be copied to.

    Utf8String - Specifies the UTF8 zero terminated string to convert.

Return Value:

    None.

--*/
{
    int UnicodeStringLen;

    //
    // Translate the string to Unicode.
    //

#ifndef WIN32_CHICAGO
    // No support for UTF8/7 char on Win95. Use the entry points
    // exported in wldap32.dll
    UnicodeStringLen = MultiByteToWideChar(
                        CP_UTF8,
                        0,      // All characters can be mapped.
                        Utf8String,
                        -1,     // NULL terminated.
                        UnicodeString,
                        0x7FFFFFFF );
#else // WIN32_CHICAGO
    UnicodeStringLen = LdapUTF8ToUnicode(
                        Utf8String,
                        strlen(Utf8String),
                        UnicodeString,
                        0x7FFFFFFF );
#endif // WIN32_CHICAGO

    if ( UnicodeStringLen == 0 ) {
        *UnicodeString = L'\0';
    }
}

NET_API_STATUS
NetpAllocWStrFromUtf8StrAsRequired(
    IN LPSTR Utf8String,
    IN ULONG Utf8StringLength,
    IN ULONG UnicodeStringBufferSize,
    OUT LPWSTR UnicodeStringBuffer OPTIONAL,
    OUT LPWSTR *AllocatedUnicodeString OPTIONAL
    )

/*++

Routine Description:

    Convert a UTF8 (zero terminated) string to the corresponding UNICODE
    string. Allocate memory as required.

Arguments:

    Utf8String - Specifies the UTF8 zero terminated string to convert.

    Utf8StringLength - Length in bytes of Utf8String excluding the NULL
        terminator. (-1 for zero terminated)

    UnicodeStringBuffer -- Buffer to copy the covnverted string to. If NULL,
        the function will allocate the needed memory and return it in
        AllocatedUnicodeString.

    UnicodeStringBufferSize - Size in wide charactes of UnicodeStringBuffer.
        If this size is less than what's needed to store the resulting
        NULL terminated unicode string, the function will allocate the
        needed memory and return it in AllocatedUnicodeString.

    AllocatedUnicodeString - If the passed in buffer for the resulting
        unicode string isn't large enough, the function will allocate
        the needed memory and the pointer to the allocated memory will
        be returned in this parameter. If NULL and the passed in buffer
        isn't large enough to store the resulting NULl terminated string,
        the function returns ERROR_INSUFFICIENT_BUFFER. The allocated buffer
        must be freed using NetApiBufferFree.

Return Value:

    NO_ERROR - The strinf has been successfully converted.

    ERROR_INVALID_PARAMETER - The paramer combination is invalid.

    ERROR_INSUFFICIENT_BUFFER - The passed in buffer isn't large enough
        and the caller doesn't want this fi=unction to allocate needed
        memory (i.e. AllocatedUnicodeString is NULL).

    ERROR_NOT_ENOUGH_MEMORY - Couldn't allocate the needed memory.

--*/

{
    NET_API_STATUS NetStatus = NO_ERROR;
    LPWSTR UnicodeString = NULL;
    int UnicodeStringLen = 0;

    //
    // Sanity check the parameters
    //

    if ( (UnicodeStringBuffer == NULL || UnicodeStringBufferSize == 0) &&
         AllocatedUnicodeString == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initilization
    //

    if ( AllocatedUnicodeString != NULL ) {
        *AllocatedUnicodeString = NULL;
    }

    //
    // Determine the length of the Unicode string.
    //

#ifndef WIN32_CHICAGO
    // No support for UTF8/7 char on Win95. Use the entry points
    // exported in wldap32.dll
    UnicodeStringLen = MultiByteToWideChar(
                        CP_UTF8,
                        0,      // All characters can be mapped.
                        Utf8String,
                        Utf8StringLength,
                        UnicodeString,
                        0 );
#else // WIN32_CHICAGO
    UnicodeStringLen = LdapUTF8ToUnicode(
                        Utf8String,
                        Utf8StringLength,
                        UnicodeString,
                        0 );
#endif // WIN32_CHICAGO

    if ( UnicodeStringLen == 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Allocate a buffer for the Unicode string,
    //  if the passed buffer isn't large enough
    //

    if ( UnicodeStringBuffer == NULL ||
         ((ULONG)UnicodeStringLen+1 > UnicodeStringBufferSize) ) {

        //
        // If the caller doesn't want us to allocate the
        //  space needed, tell him his buffer isn't large enough
        //
        if ( AllocatedUnicodeString == NULL ) {
            return ERROR_INSUFFICIENT_BUFFER;
        }

        NetStatus = NetApiBufferAllocate( (UnicodeStringLen+1)*sizeof(WCHAR),
                                          AllocatedUnicodeString );

        if ( NetStatus != NO_ERROR ) {
            return NetStatus;
        }

        UnicodeString = *AllocatedUnicodeString;

    } else {
        UnicodeString = UnicodeStringBuffer;
    }


    //
    // Translate the string to Unicode.
    //

#ifndef WIN32_CHICAGO
    // No support for UTF8/7 char on Win95. Use the entry points
    // exported in wldap32.dll
    UnicodeStringLen = MultiByteToWideChar(
                        CP_UTF8,
                        0,      // All characters can be mapped.
                        Utf8String,
                        Utf8StringLength,
                        UnicodeString,
                        UnicodeStringLen );
#else // WIN32_CHICAGO
    UnicodeStringLen = LdapUTF8ToUnicode(
                        Utf8String,
                        Utf8StringLength,
                        UnicodeString,
                        UnicodeStringLen );
#endif // WIN32_CHICAGO

    if ( UnicodeStringLen == 0 ) {

        //
        // If we have allocated the memory, free it
        //
        if ( AllocatedUnicodeString != NULL &&
             *AllocatedUnicodeString != NULL ) {
            NetApiBufferFree( *AllocatedUnicodeString );
            *AllocatedUnicodeString = NULL;
        }
        return ERROR_INVALID_PARAMETER;
    }

    UnicodeString[UnicodeStringLen] = L'\0';

    return NO_ERROR;
}

LPWSTR
NetpAllocWStrFromUtf8StrEx(
    IN LPSTR Utf8String,
    IN ULONG Length
    )

/*++

Routine Description:

    Convert a UTF8 (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Utf8String - Specifies the UTF8 zero terminated string to convert.

    Length - Length in bytes of Utf8String. (-1 for zero terminated).


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/
{
    NET_API_STATUS NetStatus;
    LPWSTR UnicodeString = NULL;

    NetStatus = NetpAllocWStrFromUtf8StrAsRequired( Utf8String,
                                                    Length,
                                                    0,
                                                    NULL,
                                                    &UnicodeString );

    if ( NetStatus == NO_ERROR ) {
        return UnicodeString;
    } else {
        return NULL;
    }
}

LPSTR
NetpCreateUtf8StrFromWStr(
    IN LPCWSTR UnicodeString,
    IN LPSTR TargetDestination OPTIONAL,
    IN int TargetDestinationBufferSize
    )

/*++

Routine Description:

    Convert a Unicode (zero terminated) string to the corresponding
    zero terminated UTF8 string.

Arguments:

    UnicodeString - Specifies the Unicode zero terminated string to convert.

    TargetDestination - Specifies the address in the preallocated buffer to
        which to copy the converted string.  If NULL, memory is allocated
        by this routine.

    TargetDestinationBufferSize - The size of the preallocated destination
        buffer in bytes. If TargetDestination isn't NULL, TargetDestinationBufferSize
        will be used to make  sure that the routine does not write beyond the
        preallocated buffer limit.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise: if TargetDestination is NULL, it returns a pointer to the
        zero terminated UTF8 string in an allocated buffer. The buffer must be
        freed using NetpMemoryFree.  If TargetDestination isn't NULL, it
        returns a pointer whose value is equal to TargetDestination.

--*/

{
    LPSTR Utf8String = NULL;
    int Utf8StringLen;

    //
    // Determine the length of the Unicode string.
    //

#ifndef WIN32_CHICAGO
    // No support for UTF8/7 char on Win95. Use the entry points
    // exported in wldap32.dll
    Utf8StringLen = WideCharToMultiByte(
                        CP_UTF8,
                        0,      // All characters can be mapped.
                        UnicodeString,
                        -1,     // Zero terminated
                        Utf8String,
                        0,
                        NULL,
                        NULL );
#else // WIN32_CHICAGO
    Utf8StringLen = LdapUnicodeToUTF8(
                        UnicodeString,
                        wcslen(UnicodeString),
                        Utf8String,
                        0
                        );
#endif // WIN32_CHICAGO

    if ( Utf8StringLen == 0 ||
         (TargetDestination != NULL && (Utf8StringLen+1 > TargetDestinationBufferSize)) ) {
        return NULL;
    }

    //
    // Allocate a buffer for the UTF8 string as needed.
    //

    if ( TargetDestination == NULL ) {
        Utf8String = NetpMemoryAllocate( Utf8StringLen+1 );
    } else {
        Utf8String = TargetDestination;
    }


    if ( Utf8String == NULL ) {
        return NULL;
    }

    //
    // Translate the string to Unicode.
    //

#ifndef WIN32_CHICAGO
    // No support for UTF8/7 char on Win95. Use the entry points
    // exported in wldap32.dll
    Utf8StringLen = WideCharToMultiByte(
                        CP_UTF8,
                        0,      // All characters can be mapped.
                        UnicodeString,
                        -1,     // Zero terminated
                        Utf8String,
                        Utf8StringLen,
                        NULL,
                        NULL );
#else // WIN32_CHICAGO
    Utf8StringLen = LdapUnicodeToUTF8(
                        UnicodeString,
                        wcslen(UnicodeString),
                        Utf8String,
                        Utf8StringLen
                        );
#endif // WIN32_CHICAGO

    if ( Utf8StringLen == 0 ) {
        if ( TargetDestination == NULL ) {
            NetpMemoryFree( Utf8String );
        }
        return NULL;
    }

    Utf8String[Utf8StringLen] = '\0';

    return Utf8String;

}

LPSTR
NetpAllocUtf8StrFromWStr(
    IN LPCWSTR UnicodeString
    )

/*++

Routine Description:

    Convert a Unicode (zero terminated) string to the corresponding UTF8
    string.

Arguments:

    UnicodeString - Specifies the Unicode zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UTF8 string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    return NetpCreateUtf8StrFromWStr( UnicodeString, NULL, 0 );
}

LPSTR
NetpAllocUtf8StrFromUnicodeString(
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    Convert a Unicode string to the corresponding UTF8
    string.

Arguments:

    UnicodeString - Specifies the Unicode string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UTF8 string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    LPSTR Utf8String = NULL;
    int Utf8StringLen;

    //
    // Sanity check.
    //
    if ( UnicodeString == NULL || UnicodeString->Buffer == NULL ) {
        return NULL;
    }

    //
    // Determine the length of the Unicode string.
    //

    Utf8StringLen = WideCharToMultiByte(
                        CP_UTF8,
                        0,      // All characters can be mapped.
                        UnicodeString->Buffer,
                        UnicodeString->Length/sizeof(WCHAR),
                        Utf8String,
                        0,
                        NULL,
                        NULL );

    if ( Utf8StringLen == 0 ) {
        return NULL;
    }

    //
    // Allocate a buffer for the Unicode string.
    //

    Utf8String = NetpMemoryAllocate( Utf8StringLen+1 );

    if ( Utf8String == NULL ) {
        return NULL;
    }

    //
    // Translate the string to Unicode.
    //

    Utf8StringLen = WideCharToMultiByte(
                        CP_UTF8,
                        0,      // All characters can be mapped.
                        UnicodeString->Buffer,
                        UnicodeString->Length/sizeof(WCHAR),
                        Utf8String,
                        Utf8StringLen,
                        NULL,
                        NULL );

    if ( Utf8StringLen == 0 ) {
        NetpMemoryFree( Utf8String );
        return NULL;
    }

    Utf8String[Utf8StringLen] = '\0';

    return Utf8String;

}

BOOLEAN
NlpCompareUtf8(
    IN LPCSTR Utf8String1,
    IN ULONG Utf8String1Size,
    IN LPCSTR Utf8String2,
    IN ULONG Utf8String2Size
    )
/*++

Routine Description:

    Compare if two UTF8 strings are equal.  The comparison is case insensitive.

Arguments:

    Utf8String1 - First string of Utf8 characters to compare.

    Utf8String1Size - Size (in bytes) of Utf8String1

    Utf8String2 - Second string of Utf8 characters to compare.

    Utf8String2Size - Size (in bytes) of Utf8String2

Return Value:

    TRUE - if the strings are equal

--*/
{
    WCHAR UnicodeString1[NL_MAX_DNS_LABEL_LENGTH];
    WCHAR UnicodeString2[NL_MAX_DNS_LABEL_LENGTH];
    int UnicodeString1Len;
    int UnicodeString2Len;

    //
    // If the strings are bit for bit identical
    //  return so.
    //

    if ( Utf8String1Size == Utf8String2Size &&
         RtlEqualMemory( Utf8String1, Utf8String2, Utf8String1Size ) ) {

        return TRUE;
    }

    //
    // Convert the strings to UNICODE
    //

#ifndef WIN32_CHICAGO
    // No support for UTF8/7 char on Win95. Use the entry points
    // exported in wldap32.dll
    UnicodeString1Len = MultiByteToWideChar(
                        CP_UTF8,
                        0,      // All characters can be mapped.
                        Utf8String1,
                        Utf8String1Size,     // Zero terminated
                        UnicodeString1,
                        sizeof(UnicodeString1)/sizeof(WCHAR) );
#else // WIN32_CHICAGO
    UnicodeString1Len = LdapUTF8ToUnicode(
                        Utf8String1,
                        Utf8String1Size,     // Zero terminated
                        UnicodeString1,
                        sizeof(UnicodeString1)/sizeof(WCHAR) );
#endif// WIN32_CHICAGO

    if ( UnicodeString1Len == 0 ) {
        return FALSE;
    }

#ifndef WIN32_CHICAGO
    // No support for UTF8/7 char on Win95. Use the entry points
    // exported in wldap32.dll
    UnicodeString2Len = MultiByteToWideChar(
                        CP_UTF8,
                        0,      // All characters can be mapped.
                        Utf8String2,
                        Utf8String2Size,     // Zero terminated
                        UnicodeString2,
                        sizeof(UnicodeString2)/sizeof(WCHAR) );
#else // WIN32_CHICAGO
    UnicodeString2Len = LdapUTF8ToUnicode(
                        Utf8String2,
                        Utf8String2Size,     // Zero terminated
                        UnicodeString2,
                        sizeof(UnicodeString2)/sizeof(WCHAR) );
#endif// WIN32_CHICAGO

    if ( UnicodeString2Len == 0 ) {
        return FALSE;
    }

    //
    // Compare the Unicode strings
    //
    return CompareStringW( LOCALE_SYSTEM_DEFAULT,
                           NORM_IGNORECASE,
                           UnicodeString1,
                           UnicodeString1Len,
                           UnicodeString2,
                           UnicodeString2Len ) == 2;

}

NET_API_STATUS
NlpUnicodeToCutf8(
    IN LPBYTE MessageBuffer,
    IN LPCWSTR OrigUnicodeString,
    IN BOOLEAN IgnoreDots,
    IN OUT LPBYTE *Utf8String,
    IN OUT PULONG Utf8StringSize,
    IN OUT PULONG CompressCount,
    IN OUT LPWORD CompressOffset,
    IN OUT CHAR **CompressUtf8String
    )
/*++

Routine Description:

    Same as NlpUtf8ToCutf8 except the input string is in Unicode.

Arguments:

    Same as NlpUtf8ToCutf8 except the input string is in Unicode.

Return Value:

    Same as NlpUtf8ToCutf8 except the input string is in Unicode.


--*/
{
    NET_API_STATUS NetStatus;
    LPSTR LocalUtf8String;

    //
    // Convert the string to Utf8.
    //


    //
    // Default to an empty string.
    //

    if ( !ARGUMENT_PRESENT(OrigUnicodeString) || *OrigUnicodeString == '\0' ) {
        LocalUtf8String = NULL;
    } else {
        LocalUtf8String = NetpAllocUtf8StrFromWStr( OrigUnicodeString );

        if ( LocalUtf8String == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Pack it.
    //

    NetStatus = NlpUtf8ToCutf8( MessageBuffer,
                                LocalUtf8String,
                                IgnoreDots,
                                Utf8String,
                                Utf8StringSize,
                                CompressCount,
                                CompressOffset,
                                CompressUtf8String );

    NetApiBufferFree( LocalUtf8String );

    return NetStatus;

}


NET_API_STATUS
NlpUtf8ToCutf8(
    IN LPBYTE MessageBuffer,
    IN LPCSTR OrigUtf8String,
    IN BOOLEAN IgnoreDots,
    IN OUT LPBYTE *Utf8String,
    IN OUT PULONG Utf8StringSize,
    IN OUT PULONG CompressCount,
    IN OUT LPWORD CompressOffset,
    IN OUT CHAR **CompressUtf8String
    )
/*++

Routine Description:

    Convert the passed in OrigUtf8String into a counted UTF-8 string.  The
    resultant string is actually a series of counted strings in RFC 1035 DNS
    format.  Each label (up to 63 bytes terminated in a '.') is preceeded
    by a byte count byte.  The final byte count byte is a zero byte.

    This routine also support RFC 1035 compression.  In that format, the
    terminating 'byte count' byte might have the high two bits set.  In that
    case, that byte and the byte following it represent an "offset" to the
    actual remainder of the string.  This routine inputs an array of strings
    that will be matched for compression purposes.

    RFC 1035 limits the character set to A-Z, a-z, 0-9, - and ..  This routine
    returns RFC compatible results if the input is limited to that character set.
    The author expects DNS to be extended to include other characters and
    to encode those characters using UTF-8.

Arguments:

    Buffer - Pointer to the beginning of the buffer that all strings are
        being packed into.

    OrigUtf8String - Zero terminated Utf8 string to be converted.

    IgnoreDots - TRUE if .'s are to be treated as any other character.

    Utf8String - Address of pointer to buffer to copy counted Utf8 string as described above.
        Return a pointer to the byte immediately beyond the copied string.

    Utf8StringSize - On input, specifies the size of the Utf8String buffer.
        Returns the size (in bytes) of the space remaining in the buffer.

    CompressCount - Specifies the number of strings that are candidates for
        compressing the input string.
        Upon successful completion, this count is incremented by one and
        the newly packed string

    CompressOffset - Array of CompressCount offsets that represent the offset
        of the compression string.  This offset will be returned at the end of
        Utf8String if the string can indeed be compressed.

        This offset is in host-order and should not include any
        NL_DNS_COMPRESS_WORD_MASK.

    CompressUtf8String - Array of CompressCount strings that are already packed
        in the current message.

Return Value:

    NO_ERROR - String was coverted successfully.

    ERROR_INVALID_DOMAINNAME - The passed in unicode string contains one
        or more labels longer than 63 bytes (in UTF-8) or short than 1 byte.

    ERROR_INSUFFICIENT_BUFFER - The resultant UTF-8 string was longer than
        255 bytes.


--*/
{
    NET_API_STATUS NetStatus;
    ULONG CharCount;
    char *Period;
    char *Current;
    LPBYTE *AllocatedLabelPointer = NULL;
    LPBYTE *LabelPointer;
    ULONG LabelCount = 0;
    LPBYTE *CompressLabelPointer;
    ULONG CompressLabelCount;
    ULONG Index;

    //
    // Default to an empty string.
    //

    if ( !ARGUMENT_PRESENT(OrigUtf8String) || *OrigUtf8String == '\0' ) {
        if ( *Utf8StringSize < 1 ) {
            return ERROR_INSUFFICIENT_BUFFER;
        }
        **Utf8String = '\0';
        *Utf8StringSize -= 1;
        *Utf8String += 1;
        return NO_ERROR;
    }

    //
    // Copy the zero terminated utf8 string to the buffer.
    //  (Leave room for the initial character count.)
    //

    CharCount = strlen( OrigUtf8String ) + 1;

    if ( (*Utf8StringSize) < CharCount + 1 ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    RtlCopyMemory( (*Utf8String)+1, OrigUtf8String, CharCount );

    //
    // Allocate a temporary array to keep track of the compression.
    //  (At most every second character can be a .)
    //  (Allocate two arrays with a single call to LocalAlloc.)
    //

    AllocatedLabelPointer =
        LocalAlloc( 0, sizeof(LPBYTE) * (CharCount / 2) +
                       sizeof(LPBYTE) * (NL_MAX_DNS_LENGTH/2) );

    if ( AllocatedLabelPointer == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LabelPointer = AllocatedLabelPointer;
    CompressLabelPointer = &AllocatedLabelPointer[CharCount/2];

    //
    // Convert the string to a counted string.
    //  Simply replace '.'s with character counts
    //

    Current = (*Utf8String)+1;
    while ( *Current != '\0' ) {
        ULONG LabelSize;

        //
        // Find the end of the current label.
        //  use strchr not lstrchr to avoid DBCS semantics.
        //
        Period = strchr( Current, '.' );

        //
        // Special case ignoring dots.
        //
        // We can't totally ignore dots since we want to take advantage of
        //  RFC 1035 compression.  But we have to overcome syntax limitations
        //  imposed by the compression.
        //

        if ( IgnoreDots ) {
            //
            // When ignoring dots, two adjacent dots are legal.
            // But they confuse RFC 1035 compression.  So, put the second dot
            // into the following label
            //
            if ( Period == Current ) {
                Period = strchr( Current+1, '.' );
            }

            //
            // If the last character is a dot,
            //  include it in the last label.
            //

            if ( Period != NULL && *(Period+1) == '\0' ) {
                Period++;
            }
        }

        if ( Period == NULL ) {
            Period = strchr( Current, '\0' );
        }

        //
        // Compute the length of the label.
        //
        LabelSize = (ULONG)(Period - Current);
        if ( LabelSize > NL_MAX_DNS_LABEL_LENGTH || LabelSize < 1 ) {
            //
            // Enforce this even for IgnoreDots.  This is a restriction of
            //  RFC 1035 compression.
            //
            NetStatus = ERROR_INVALID_DOMAINNAME;
            goto Cleanup;
        }

        //
        // Save a pointer to the current label;
        //

        LabelPointer[LabelCount] = Current - 1;
        LabelCount ++;

        //
        // Save the size of the current label and move to the next label.
        //

        *(Current-1) = (char) LabelSize;
        Current += LabelSize;
        if ( *Current == '\0' ) {
            break;
        }
        if ( *Current == '.' && *(Current+1) == '\0' ) {
            // And ignore trailing .'s
            *Current = '\0';
            CharCount --;
            break;
        }
        Current += 1;
    }
    LabelPointer[LabelCount] = Current;
    NlAssert( ((ULONG)(Current - (*Utf8String))) == CharCount );

    //
    // Loop through the compression strings seeing if we can compress this string.
    //

    if ( CompressCount != NULL ) {
        for ( Index=0; Index<*CompressCount; Index++ ) {
            LPBYTE CurrentCompressString = CompressUtf8String[Index];
            LONG LabelIndex;
            LONG CompressLabelIndex;

            //
            // If we're already compressed as much as we can be,
            //  exit.
            //

            if ( LabelCount == 0 ) {
                break;
            }

            //
            // Compute label pointers for the next compress string.
            //

            Current = CurrentCompressString;
            CompressLabelCount = 0;
            while ( *Current != '\0' &&
                    ((*Current) & NL_DNS_COMPRESS_BYTE_MASK) != NL_DNS_COMPRESS_BYTE_MASK ) {
                CompressLabelPointer[CompressLabelCount] = Current;
                CompressLabelCount++;
                Current += *Current + 1;
            }
            CompressLabelPointer[CompressLabelCount] = Current;

            //
            // Skip this string if there are no labels
            //

            if ( CompressLabelCount == 0 ) {
                continue;
            }

            //
            // Skip this string if it is compressed to a different degree than
            //  we are now.
            //
            // If we compress with this string, upon decompressesion we'll
            //  append to our string anything that is appended to this string.
            //  So, we have to make sure the postfixes match.
            //

            if ( *CompressLabelPointer[CompressLabelCount] != *LabelPointer[LabelCount] ) {
                continue;
            }

            // Compare both bytes if there really was compression.
            if ( ((*LabelPointer[LabelCount]) & NL_DNS_COMPRESS_BYTE_MASK) == NL_DNS_COMPRESS_BYTE_MASK &&
                  *(CompressLabelPointer[CompressLabelCount]+1) != *(LabelPointer[LabelCount]+1) ) {
                continue;
            }


            //
            // Walk backward through the labels comparing them.
            //  While they continue to match,
            //      keep lobbing bytes off the end of our return string.
            //

            LabelIndex = LabelCount-1;
            CompressLabelIndex = CompressLabelCount-1;

            while ( LabelIndex >= 0 &&
                    CompressLabelIndex >= 0 &&
                    NlpCompareUtf8( LabelPointer[LabelIndex]+1,
                                   *(LabelPointer[LabelIndex]),
                                   CompressLabelPointer[CompressLabelIndex]+1,
                                   *(CompressLabelPointer[CompressLabelIndex]) )) {

                //
                // Put the offset onto the end of the current buffer.
                //

                SmbPutUshort( LabelPointer[LabelIndex],
                              htons((WORD)(NL_DNS_COMPRESS_WORD_MASK |
                                (CompressOffset[Index] +
                                    CompressLabelPointer[CompressLabelIndex] -
                                    CurrentCompressString))) );

                //
                // Adjust the total number of bytes returned.
                //

                CharCount = (ULONG)(LabelPointer[LabelIndex] - (*Utf8String)) + sizeof(WORD) - 1;

                //
                // Indicate we've ditched yet another label from the string.
                //

                LabelCount --;

                //
                // Adjust Index to next label.
                //
                LabelIndex --;
                CompressLabelIndex --;
            }

        }

        //
        // Save a pointer to this string so the next caller can compress
        //  into it.
        //

        CompressUtf8String[*CompressCount] = *Utf8String;
        CompressOffset[*CompressCount] = (USHORT)((*Utf8String) - MessageBuffer);
        *CompressCount += 1;
    }

    //
    // Return the character count.
    //  (Include the leading label length byte.)
    *Utf8StringSize -= CharCount+1;
    *Utf8String += CharCount+1;

    NetStatus = NO_ERROR;

    //
    // Done
    //
Cleanup:
    if ( AllocatedLabelPointer != NULL ) {
        LocalFree( AllocatedLabelPointer );
    }

    return NetStatus;


}

BOOL
NlEqualDnsNameU(
    IN PUNICODE_STRING Name1,
    IN PUNICODE_STRING Name2
    )
/*++

Routine Description:

    This routine compares two DNS names for equality.

    Case is ignored.  A single trailing . is ignored.
    Null is compared equal to a zero length string.

Arguments:

    Name1 - First DNS name to compare

    Name2 - Second DNS name to compare

Return Value:

    TRUE: DNS names are equal.

--*/
{
    BOOL Result = FALSE;
    LPWSTR String1 = NULL;
    LPWSTR String2 = NULL;

    //
    // Sanity check
    //
    if ( Name1 == NULL ) {
        return (Name2 == NULL);
    } else if ( Name2 == NULL ) {
        return FALSE;
    }

    //
    // Do the work
    //
    String1 = LocalAlloc( 0, Name1->Length + sizeof(WCHAR) );
    if ( String1 == NULL ) {
        goto Cleanup;
    }

    String2 = LocalAlloc( 0, Name2->Length + sizeof(WCHAR) );
    if ( String2 == NULL ) {
        goto Cleanup;
    }

    RtlCopyMemory( String1, Name1->Buffer, Name1->Length );
    String1[ Name1->Length/sizeof(WCHAR) ] = L'\0';

    RtlCopyMemory( String2, Name2->Buffer, Name2->Length );
    String2[ Name2->Length/sizeof(WCHAR) ] = L'\0';

    Result = NlEqualDnsName( (LPCWSTR) String1, (LPCWSTR) String2 );

Cleanup:

    if ( String1 != NULL ) {
        LocalFree( String1 );
    }
    if ( String2 != NULL ) {
        LocalFree( String2 );
    }
    return Result;
}

BOOL
NlEqualDnsName(
    IN LPCWSTR Name1,
    IN LPCWSTR Name2
    )
/*++

Routine Description:

    This routine compares two DNS names for equality.

    Case is ignored.  A single trailing . is ignored.
    Null is compared equal to a zero length string.

Arguments:

    Name1 - First DNS name to compare

    Name2 - Second DNS name to compare

Return Value:

    TRUE: DNS names are equal.

--*/
{
    if ( Name1 == NULL ) {
        return (Name2 == NULL);
    } else if ( Name2 == NULL ) {
        return FALSE;
    }

    return DnsNameCompare_W( (LPWSTR) Name1, (LPWSTR) Name2 );
}

BOOL
NlEqualDnsNameUtf8(
    IN LPCSTR Name1,
    IN LPCSTR Name2
    )
/*++

Routine Description:

    This routine compares two DNS names for equality.

    Case is ignored.  A single trailing . is ignored.
    Null is compared equal to a zero length string.

Arguments:

    Name1 - First DNS name to compare

    Name2 - Second DNS name to compare

Return Value:

    TRUE: DNS names are equal.

--*/
{
    if ( Name1 == NULL ) {
        return (Name2 == NULL);
    } else if ( Name2 == NULL ) {
        return FALSE;
    }

    return DnsNameCompare_UTF8( (LPSTR)Name1, (LPSTR)Name2 );
}


BOOL
NetpDcValidDnsDomain(
    IN LPCWSTR DnsDomainName
)
/*++

Routine Description:

    Returns whether the specified string is a valid DNS Domain name.

Arguments:


    DnsDomainName - DNS domain name to validate.

Return Value:

    TRUE - The specified name is syntactically a DNS Domain name.

    FALSE - The specified name in not syntactically a DNS Domain name.

--*/
{
    DNS_STATUS DnsStatus;

    DnsStatus = DnsValidateDnsName_W( DnsDomainName );

    if ( DnsStatus == ERROR_SUCCESS ||
         DnsStatus == DNS_ERROR_NON_RFC_NAME ) {
        return TRUE;
    }

    return FALSE;

}



ULONG
NetpDcElapsedTime(
    IN ULONG StartTime
)
/*++

Routine Description:

    Returns the time (in milliseconds) that has elapsed is StartTime.

Arguments:

    StartTime - A time stamp from GetTickCount()

Return Value:

    Returns the time (in milliseconds) that has elapsed is StartTime.

--*/
{
    ULONG CurrentTime;

    //
    // If time has has wrapped,
    //  account for it.
    //

    CurrentTime = GetTickCount();

    if ( CurrentTime >= StartTime ) {
        return CurrentTime - StartTime;
    } else {
        return (0xFFFFFFFF-StartTime) + CurrentTime;
    }
}


BOOL
NetpLogonGetCutf8String(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    OUT LPSTR *Data
)
/*++

Routine Description:

    Get a counted UTF-8 string (potentially compressed) from a message.
    Return the uncompressed string as a . seperated zero-terminated string.

    A trailing . is returned on the name since all packed strings are assumed
    to be absolute names.

Arguments:

    Message - Points to a buffer containing the message.

    MessageSize - The number of bytes in the message buffer.

    Where - Indirectly points to the current location in the buffer.  The
        data at the current location is validated (i.e., checked to ensure
        its length is within the bounds of the message buffer and not too
        long).  If the data is valid, this current location is updated
        to point to the byte following the data in the message buffer.

    Data - Points to a location to return the DNS name.
        A zero length string is returned as a NULL buffer.
        The buffer returned should be freed via NetpMemoryFree.

Return Value:

    TRUE - the data is valid.

    FALSE - the data is invalid (e.g., DataSize is too big for the buffer.

--*/
{
    CHAR DnsName[NL_MAX_DNS_LENGTH+1];
    ULONG DnsNameLength = 0;

    ULONG InitialOffset;
    BYTE LabelSize;
    LPBYTE LocalWhere;
    BYTE PointerBytes[2];
    WORD Pointer;
    BOOLEAN WhereUpdated = FALSE;
    BOOLEAN FirstLabel = TRUE;

    LocalWhere = *Where;
    InitialOffset = (ULONG)(*Where - ((LPBYTE)Message));

    //
    // Loop getting counted strings from the message.
    //

    for (;;) {

        //
        // Get the length of the current label from the buffer.
        //

        if ( !NetpLogonGetBytes( Message, MessageSize, &LocalWhere, 1, &LabelSize ) ) {
            NlPrint(( NL_CRITICAL, "NetpLogonGetCutf8String: Can't get label size.\n" ));
            return FALSE;
        }

        //
        // If this is the end of the string,
        //  process it.
        //

        if ( LabelSize == 0 ) {

            //
            // If this is, then we've not updated the callers 'Where',
            //  do it now.
            //

            if ( !WhereUpdated ) {
                WhereUpdated = TRUE;
                *Where = LocalWhere;
            }

            //
            // If the string is empty,
            //  return the empty string to the caller.
            //

            if ( DnsNameLength == 0 ) {
                *Data = NULL;
                return TRUE;
            }


            //
            // Copy the DNS name to an allocated buffer.
            //

            DnsName[DnsNameLength] = '\0';
            DnsNameLength++;

            *Data = NetpMemoryAllocate( DnsNameLength );
            if ( *Data == NULL ) {
                NlPrint(( NL_CRITICAL, "NetpLogonGetCutf8String: Can't allocate buffer.\n" ));
                return FALSE;
            }
            RtlCopyMemory( *Data, DnsName, DnsNameLength );

            return TRUE;

        //
        // If this is a pointer,
        //  get rest of pointer.
        //

        } else if ( LabelSize & NL_DNS_COMPRESS_BYTE_MASK ) {

            //
            // Get the second byte of the pointer.
            //

            if ( !NetpLogonGetBytes( Message, MessageSize, &LocalWhere, 1, &PointerBytes[1] ) ) {
                NlPrint(( NL_CRITICAL, "NetpLogonGetCutf8String: Can't get pointer byte.\n" ));
                return FALSE;
            }

            //
            // Convert the pointer to host order.
            //

            PointerBytes[0] = LabelSize;
            Pointer = ntohs( *((LPWORD)PointerBytes) ) & ~NL_DNS_COMPRESS_WORD_MASK;

            //
            // Ensure the pointer points to before the beginning of this string.
            //  This ensures we terminate.
            //

            if ( Pointer >= InitialOffset ) {
                NlPrint(( NL_CRITICAL,
                          "NetpLogonGetCutf8String: Pointer offset too large 0x%lx 0x%lx.\n",
                          Pointer,
                          InitialOffset ));
                return FALSE;
            }

            //
            // If we've not updated the callers 'Where',
            //  do it now.
            //

            if ( !WhereUpdated ) {
                WhereUpdated = TRUE;
                *Where = LocalWhere;
            }

            //
            // Prepare the start processing the pointed to string.
            //

            InitialOffset = Pointer;
            LocalWhere = ((LPBYTE)Message) + Pointer;

        //
        // If this is simply a counted label,
        //  process it.
        //
        } else {

            //
            // If this isn't the first label,
            //  add a '.' after the previous label.
            //

            if ( !FirstLabel ) {
                DnsName[DnsNameLength] = '.';
                DnsNameLength++;
            } else {
                FirstLabel = FALSE;
            }

            //
            // Ensure the current label fits in the local buffer.
            //

            if ( DnsNameLength + LabelSize + 2 >= sizeof(DnsName) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpLogonGetCutf8String: Label to long %ld %ld.\n",
                          DnsNameLength,
                          LabelSize ));
                return FALSE;
            }

            //
            // Copy the label into the local buffer.
            //  (Leave an extra byte for a trailing '\0' and '.')
            //

            if ( !NetpLogonGetBytes(
                            Message,
                            MessageSize,
                            &LocalWhere,
                            LabelSize,
                            &DnsName[DnsNameLength] ))  {

                NlPrint(( NL_CRITICAL, "NetpLogonGetCutf8String: Can't get label.\n" ));
                return FALSE;
            }

            DnsNameLength += LabelSize;

        }
    }
}





NET_API_STATUS
NetpDcBuildPing(
    IN BOOL PdcOnly,
    IN ULONG RequestCount,
    IN LPCWSTR UnicodeComputerName,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN LPCSTR ResponseMailslotName,
    IN ULONG AllowableAccountControlBits,
    IN PSID RequestedDomainSid OPTIONAL,
    IN ULONG NtVersion,
    OUT PVOID *Message,
    OUT PULONG MessageSize
    )

/*++

Routine Description:

    Build the message to ping a DC to see if it exists.

Arguments:

    PdcOnly - True if only the PDC should respond.

    RequestCount - Retry count of this operation.

    UnicodeComputerName - Netbios computer name of the machine to respond to.

    UnicodeUserName - Account name of the user being pinged.
        If NULL, DC will always respond affirmatively.

    ResponseMailslotName - Name of the mailslot DC is to respond to.

    AllowableAccountControlBits - Mask of allowable account types for UnicodeUserName.

    RequestedDomainSid - Sid of the domain the message is destined to.

    NtVersion - Version of the message.
        0: For backward compatibility.
        NETLOGON_NT_VERSION_5: for NT 5.0 message.
        NETLOGON_NT_VERSION_5EX: for extended NT 5.0 message

    Message - Returns the message to be sent to the DC in question.
        Buffer must be free using NetpMemoryFree().

    MessageSize - Returns the size (in bytes) of the returned message


Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - The message could not be allocated.

--*/
{
    NET_API_STATUS NetStatus;
    LPSTR Where;
    PNETLOGON_SAM_LOGON_REQUEST SamLogonRequest = NULL;
    LPSTR OemComputerName = NULL;

    //
    // If only the PDC should respond,
    //  build a primary query packet.
    //

    if ( PdcOnly ) {
        PNETLOGON_LOGON_QUERY LogonQuery;

        //
        // Allocate memory for the primary query message.
        //

        SamLogonRequest = NetpMemoryAllocate( sizeof(NETLOGON_LOGON_QUERY) );

        if( SamLogonRequest == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        LogonQuery = (PNETLOGON_LOGON_QUERY)SamLogonRequest;



        //
        // Translate to get an Oem computer name.
        //

#ifndef WIN32_CHICAGO
        OemComputerName = NetpLogonUnicodeToOem( (LPWSTR)UnicodeComputerName );
#else
        OemComputerName = MyNetpLogonUnicodeToOem( (LPWSTR)UnicodeComputerName );
#endif

        if ( OemComputerName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Build the query message.
        //

        LogonQuery->Opcode = LOGON_PRIMARY_QUERY;

        Where = LogonQuery->ComputerName;

        NetpLogonPutOemString(
                    OemComputerName,
                    sizeof(LogonQuery->ComputerName),
                    &Where );

        NetpLogonPutOemString(
                    (LPSTR) ResponseMailslotName,
                    sizeof(LogonQuery->MailslotName),
                    &Where );

        NetpLogonPutUnicodeString(
                    (LPWSTR) UnicodeComputerName,
                    sizeof( LogonQuery->UnicodeComputerName ),
                    &Where );

        // Join common code to add NT 5 specific data.


    //
    // If any DC can respond,
    //  build a logon query packet.
    //

    } else {
        ULONG DomainSidSize;

        //
        // Allocate memory for the logon request message.
        //

#ifndef WIN32_CHICAGO
        if ( RequestedDomainSid != NULL ) {
            DomainSidSize = RtlLengthSid( RequestedDomainSid );
        } else {
            DomainSidSize = 0;
        }
#else // WIN32_CHICAGO
        DomainSidSize = 0;
#endif // WIN32_CHICAGO

        SamLogonRequest = NetpMemoryAllocate(
                        sizeof(NETLOGON_SAM_LOGON_REQUEST) +
                        DomainSidSize +
                        sizeof(DWORD) // for SID alignment on 4 byte boundary
                        );

        if( SamLogonRequest == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        //
        // Build the query message.
        //

        SamLogonRequest->Opcode = LOGON_SAM_LOGON_REQUEST;
        SamLogonRequest->RequestCount = (WORD) RequestCount;

        Where = (PCHAR) &SamLogonRequest->UnicodeComputerName;

        NetpLogonPutUnicodeString(
                (LPWSTR) UnicodeComputerName,
                sizeof(SamLogonRequest->UnicodeComputerName),
                &Where );

        NetpLogonPutUnicodeString(
                (LPWSTR) UnicodeUserName,
                sizeof(SamLogonRequest->UnicodeUserName),
                &Where );

        NetpLogonPutOemString(
                (LPSTR) ResponseMailslotName,
                sizeof(SamLogonRequest->MailslotName),
                &Where );

        NetpLogonPutBytes(
                &AllowableAccountControlBits,
                sizeof(SamLogonRequest->AllowableAccountControlBits),
                &Where );

        //
        // Place domain SID in the message.
        //

        NetpLogonPutBytes( &DomainSidSize, sizeof(DomainSidSize), &Where );
        NetpLogonPutDomainSID( RequestedDomainSid, DomainSidSize, &Where );

    }

    NetpLogonPutNtToken( &Where, NtVersion );

    //
    // Return the message to the caller.
    //

    *Message = SamLogonRequest;
    *MessageSize = (ULONG)(Where - (PCHAR)SamLogonRequest);
    SamLogonRequest = NULL;

    NetStatus = NO_ERROR;


    //
    // Free locally used resources.
    //
Cleanup:

    if ( OemComputerName != NULL ) {
        NetpMemoryFree( OemComputerName );
    }

    if ( SamLogonRequest != NULL ) {
        NetpMemoryFree( SamLogonRequest );
    }
    return NetStatus;
}


NET_API_STATUS
NetpDcPackFilterBinary(
    IN LPCSTR Name,
    IN LPBYTE Buffer,
    IN ULONG BufferSize,
    IN LPSTR *FilterBuffer,
    IN PULONG FilterSize
    )

/*++

Routine Description:

    Pack a binary blob into an LDAP filter.

Arguments:

    Name - Name of the string.

    Buffer - Pointer to bytes to pack pack.
        If NULL, this routine successfully returns after doing nothing.

    BufferSize - Number of bytes in Buffer.

    FilterBuffer - Specifies a pointer to the address of the buffer.
        This buffer is reallocated as needed to extend the string.
        If the buffer does not exist, it is allocated.
        Buffer must be free using NetpMemoryFree().

    FilterSize - Specifies/Returns the length of FilterBuffer.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - The message could not be allocated.

--*/
{
    NET_API_STATUS NetStatus;
    ULONG NewSize;
    LPSTR NewBuffer;
    ULONG NameSize;
    LPBYTE Where;
    LPSTR FilterElement = NULL;
    ULONG FilterElementSize;
#define LDAP_BINARY_EQUAL "="
#define LDAP_BINARY_EQUAL_SIZE (sizeof(LDAP_BINARY_EQUAL)-1)
#define LDAP_BINARY_TEMP_SIZE 1024

    //
    // If there's nothing to pack,
    //  Pack nothing.
    //

    if ( Buffer == NULL || BufferSize == 0 ) {
        return NO_ERROR;
    }

    //
    // Allocate a buffer for storage local to this procedure.
    //  (Don't put in on the stack since we don't want to commit a huge stack.)
    //

    FilterElement = LocalAlloc( 0, LDAP_BINARY_TEMP_SIZE );

    if ( FilterElement == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Build an escaped version of the buffer.
    //

    NetStatus = ldap_escape_filter_elementA (
                    Buffer,
                    BufferSize,
                    FilterElement,
                    LDAP_BINARY_TEMP_SIZE );

    if ( NetStatus != NO_ERROR ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Compute the size of the new buffer.
    //

    if ( *FilterBuffer == NULL ) {
        *FilterSize = 4;   // (&)\0
    }

    NameSize = strlen( Name );
    FilterElementSize = strlen( FilterElement );
    NewSize = *FilterSize +
              1 +   // (
              NameSize +
              LDAP_BINARY_EQUAL_SIZE +
              FilterElementSize +
              1;   // )

    //
    // Allocate a new buffer
    //

    NewBuffer = NetpMemoryAllocate( NewSize );

    if ( NewBuffer == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Copy the existing buffer into the newly allocated space.
    //  (Initialize the buffer if this is the first allocation).
    //

    if ( *FilterBuffer == NULL ) {
        strcpy( NewBuffer, "(&" );
    } else {
        RtlCopyMemory( NewBuffer, *FilterBuffer, *FilterSize );
        NetpMemoryFree( *FilterBuffer );
        *FilterBuffer = NULL;
    }

    //
    // Append the new information
    //

    Where = NewBuffer + *FilterSize - 2;

    strcpy( Where, "(");
    Where ++;

    RtlCopyMemory( Where, Name, NameSize );
    Where += NameSize;

    RtlCopyMemory( Where, LDAP_BINARY_EQUAL, LDAP_BINARY_EQUAL_SIZE );
    Where += LDAP_BINARY_EQUAL_SIZE;

    RtlCopyMemory( Where, FilterElement, FilterElementSize );
    Where += FilterElementSize;

    strcpy( Where, "))");
    Where += 2;

    //
    // Tell the caller about the new filter.
    //
    *FilterBuffer = NewBuffer;
    *FilterSize = NewSize;
    NetStatus = NO_ERROR;

    //
    // Free locally used resources.
    //
Cleanup:
    if ( FilterElement != NULL ) {
        LocalFree( FilterElement );
    }
    return NetStatus;

}


NET_API_STATUS
NetpDcPackFilterString(
    IN LPCSTR Name,
    IN LPCWSTR UnicodeString OPTIONAL,
    IN LPSTR *FilterBuffer,
    IN PULONG FilterSize
    )

/*++

Routine Description:

    Pack a Unicode String into the LDAP filter.

    The actual packed string is the UTF-8 representation since that takes
    less space on the wire.

Arguments:

    Name - Name of the string.

    UnicodeString - String to pack.
        If NULL, this routine successfully returns after doing nothing.

    FilterBuffer - Specifies a pointer to the address of the buffer.
        This buffer is reallocated as needed to extend the string.
        If the buffer does not exist, it is allocated.
        Buffer must be free using NetpMemoryFree().

    FilterSize - Specifies/Returns the length of FilterBuffer.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - The message could not be allocated.

--*/
{
    NET_API_STATUS NetStatus;
    LPSTR Utf8String = NULL;
    ULONG Utf8StringSize;

    //
    // If there's nothing to pack,
    //  Pack nothing.
    //

    if ( UnicodeString == NULL || *UnicodeString == L'\0') {
        return NO_ERROR;
    }

    //
    // Convert to utf8.
    //

    Utf8String = NetpAllocUtf8StrFromWStr( UnicodeString );

    if ( Utf8String == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Utf8StringSize = strlen( Utf8String );

    //
    // Pack the UTF-8 string as binary.
    //  LDAP filters have a limited character set (UTF-8 doesn't).
    //  The LDAP API will put the UTF-8 string on the wire bit-for-bit
    //  indentical to the Utf8String (even though the filter buffer
    //  will contain jibberish).
    //

    NetStatus = NetpDcPackFilterBinary( Name,
                                        Utf8String,
                                        Utf8StringSize,
                                        FilterBuffer,
                                        FilterSize );


    //
    // Free locally used resources.
    //
Cleanup:

    if ( Utf8String != NULL ) {
        NetpMemoryFree( Utf8String );
    }

    return NetStatus;

}


NET_API_STATUS
NetpDcBuildLdapFilter(
    IN LPCWSTR UnicodeComputerName,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN PSID RequestedDomainSid OPTIONAL,
    IN LPCWSTR RequestedDnsDomainName OPTIONAL,
    IN GUID *RequestedDomainGuid OPTIONAL,
    IN ULONG NtVersion,
    OUT LPSTR *Message
    )

/*++

Routine Description:

    Build the LDAP filter to ping a DC to see if it exists.

Arguments:

    UnicodeComputerName - Netbios computer name of the machine to respond to.

    UnicodeUserName - Account name of the user being pinged.
        If NULL, DC will always respond affirmatively.

    AllowableAccountControlBits - Mask of allowable account types for UnicodeUserName.

    RequestedDomainSid - Sid of the domain the message is destined to.

    RequestedDnsDomainName - DNS Host Name.  Host name of the domain the message
        is destined to.

    RequestedDomainGuid - Domain GUID of the domain this message is
        destined to.

    NtVersion - Version of the message.
        0: For backward compatibility.
        NETLOGON_NT_VERSION_5: for NT 5.0 message.
        NETLOGON_NT_VERSION_5EX: for extended NT 5.0 message

    Message - Returns the message to be sent to the DC in question.
        Buffer must be free using NetpMemoryFree().

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - The message could not be allocated.

--*/
{
    NET_API_STATUS NetStatus;
    LPSTR FilterBuffer = NULL;
    ULONG FilterSize = 0;

    //
    // Pack the text strings into the filter.
    //

    NetStatus = NetpDcPackFilterString(
                    NL_FILTER_DNS_DOMAIN_NAME,
                    RequestedDnsDomainName,
                    &FilterBuffer,
                    &FilterSize );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    NetStatus = NetpDcPackFilterString(
                    NL_FILTER_HOST_NAME,
                    UnicodeComputerName,
                    &FilterBuffer,
                    &FilterSize );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    NetStatus = NetpDcPackFilterString(
                    NL_FILTER_USER_NAME,
                    UnicodeUserName,
                    &FilterBuffer,
                    &FilterSize );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Pack the binary blobs into the filter
    //

    if ( AllowableAccountControlBits != 0 ) {

        NetStatus = NetpDcPackFilterBinary(
                        NL_FILTER_ALLOWABLE_ACCOUNT_CONTROL,
                        (LPBYTE)&AllowableAccountControlBits,
                        sizeof(AllowableAccountControlBits),
                        &FilterBuffer,
                        &FilterSize );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    if ( RequestedDomainSid != NULL  ) {

        NetStatus = NetpDcPackFilterBinary(
                        NL_FILTER_DOMAIN_SID,
                        RequestedDomainSid,
#ifndef WIN32_CHICAGO
                        RtlLengthSid( RequestedDomainSid ),
#else // WIN32_CHICAGO
                        0,
#endif // WIN32_CHICAGO
                        &FilterBuffer,
                        &FilterSize );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    if ( RequestedDomainGuid != NULL  ) {

        NetStatus = NetpDcPackFilterBinary(
                        NL_FILTER_DOMAIN_GUID,
                        (LPBYTE)RequestedDomainGuid,
                        sizeof(GUID),
                        &FilterBuffer,
                        &FilterSize );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    if ( NtVersion != NETLOGON_NT_VERSION_5 ) {

        NetStatus = NetpDcPackFilterBinary(
                        NL_FILTER_NT_VERSION,
                        (LPBYTE)&NtVersion,
                        sizeof(NtVersion),
                        &FilterBuffer,
                        &FilterSize );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    //
    // Return the filter to the caller.
    //

    NlAssert( FilterBuffer != NULL );
    if ( FilterBuffer == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    *Message = FilterBuffer;
    NetStatus = NO_ERROR;

    //
    // Free locally used resources.
    //
Cleanup:

    if ( NetStatus != NO_ERROR ) {
        if ( FilterBuffer != NULL ) {
            NetpMemoryFree( FilterBuffer );
        }
    }

    return NetStatus;
}


PNL_DC_CACHE_ENTRY
NetpDcAllocateCacheEntry(
    IN LPWSTR ServerName OPTIONAL,
    IN LPSTR OemPrimaryDcName OPTIONAL,
    IN LPWSTR UserName OPTIONAL,
    IN LPWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid,
    IN LPSTR DnsForestName OPTIONAL,
    IN LPSTR DnsDomainName OPTIONAL,
    IN LPSTR DnsHostName OPTIONAL,
    IN LPSTR Utf8NetbiosDomainName OPTIONAL,
    IN LPSTR Utf8NetbiosComputerName OPTIONAL,
    IN LPSTR Utf8UserName OPTIONAL,
    IN LPSTR Utf8DcSiteName OPTIONAL,
    IN LPSTR Utf8ClientSiteName OPTIONAL,
    IN ULONG Flags
    )

/*++

Routine Description:

    Allocate a cache entry and fill it in.

Arguments:

    Various fields to fill into an allocated cache entry.

Return Value:

    Pointer to a newly allocated cache entry
    The cache entry should be freed by calling NetpDcDerefCacheEntry

    NULL: The entry could not be allocated.

--*/
{
    NET_API_STATUS NetStatus;


    ULONG ServerNameSize = 0;
    ULONG UserNameSize = 0;
    ULONG DomainNameSize = 0;
    ULONG DnsForestNameSize = 0;
    ULONG DnsDomainNameSize = 0;
    ULONG DnsHostNameSize = 0;
    ULONG DcSiteNameSize = 0;
    ULONG ClientSiteNameSize = 0;
    ULONG CacheEntrySize;

    PCHAR Where;
    PNL_DC_CACHE_ENTRY NlDcCacheEntry;

    //
    // Determine the size of the cache entry to return.
    //

    // Sizeof the server name.
    if ( Utf8NetbiosComputerName != NULL && Utf8NetbiosComputerName[0] != '\0' ) {
        ServerNameSize = (NetpUtf8ToUnicodeLen( Utf8NetbiosComputerName ) + 1) * sizeof(WCHAR);
    } else if ( ServerName != NULL && ServerName[0] != '\0') {
        ServerNameSize = (wcslen(ServerName) + 1) * sizeof(WCHAR);
    } else if ( OemPrimaryDcName != NULL ) {
        ServerNameSize = (strlen(OemPrimaryDcName) + 1) * sizeof(WCHAR);
    }

    // Sizeof the user name.
    if ( Utf8UserName != NULL && Utf8UserName[0] != '\0' ) {
        UserNameSize = NetpUtf8ToUnicodeLen( Utf8UserName ) * sizeof(WCHAR) + sizeof(WCHAR);
    } else if ( UserName != NULL && UserName[0] != '\0') {
        UserNameSize = (wcslen(UserName) + 1) * sizeof(WCHAR);
    }

    // Sizeof the netbios domain name.
    if ( Utf8NetbiosDomainName != NULL && Utf8NetbiosDomainName[0] != '\0' ) {
        DomainNameSize = NetpUtf8ToUnicodeLen( Utf8NetbiosDomainName ) * sizeof(WCHAR) + sizeof(WCHAR);
    } else if ( DomainName != NULL && DomainName[0] != '\0') {
        DomainNameSize = (wcslen(DomainName) + 1) * sizeof(WCHAR);
    }

    // Sizeof the Dns Tree name.
    if ( DnsForestName != NULL ) {
        DnsForestNameSize = NetpUtf8ToUnicodeLen( DnsForestName ) * sizeof(WCHAR) + sizeof(WCHAR);
    }

    // Sizeof the Dns Domain name.
    if ( DnsDomainName != NULL ) {
        DnsDomainNameSize = NetpUtf8ToUnicodeLen( DnsDomainName ) * sizeof(WCHAR) + sizeof(WCHAR);
    }

    // Sizeof the Dns Host name.
    if ( DnsHostName != NULL ) {
        DnsHostNameSize = NetpUtf8ToUnicodeLen( DnsHostName ) * sizeof(WCHAR) + sizeof(WCHAR);
    }

    // Sizeof the Dc Site name.
    if ( Utf8DcSiteName != NULL ) {
        DcSiteNameSize = NetpUtf8ToUnicodeLen( Utf8DcSiteName ) * sizeof(WCHAR) + sizeof(WCHAR);
    }

    // Sizeof the Client Site name.
    if ( Utf8ClientSiteName != NULL ) {
        ClientSiteNameSize = NetpUtf8ToUnicodeLen( Utf8ClientSiteName ) * sizeof(WCHAR) + sizeof(WCHAR);
    }



    //
    // Allocate the buffer to return.
    //

    CacheEntrySize = sizeof( NL_DC_CACHE_ENTRY ) +
        ServerNameSize +
        UserNameSize +
        DomainNameSize +
        DnsForestNameSize +
        DnsDomainNameSize +
        DnsHostNameSize +
        DcSiteNameSize +
        ClientSiteNameSize;

    NlDcCacheEntry = NetpMemoryAllocate( CacheEntrySize );

    if ( NlDcCacheEntry == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NetpDcAllocateCacheEntry: %ws: not enough memory.\n" ));
        return NULL;
    }

    RtlZeroMemory( NlDcCacheEntry, CacheEntrySize );
    Where = (LPBYTE) (NlDcCacheEntry + 1 );

    // Local reference.
    NlDcCacheEntry->ReferenceCount = 1;

    //
    // Copy the collected information out to the caller.
    //

    NlDcCacheEntry->DomainGuid = *DomainGuid;
    NlDcCacheEntry->ReturnFlags = Flags & DS_PING_FLAGS;

    // Copy the server name (removing any \\)
    if ( Utf8NetbiosComputerName != NULL && Utf8NetbiosComputerName[0] != '\0' ) {
        NlDcCacheEntry->UnicodeNetbiosDcName = (LPWSTR) Where;
        if ( Utf8NetbiosComputerName[0] == '\\' && Utf8NetbiosComputerName[1] == '\\' ) {
            NetpCopyUtf8StrToWStr( (LPWSTR)Where, Utf8NetbiosComputerName+2 );
        } else {
            NetpCopyUtf8StrToWStr( (LPWSTR)Where, Utf8NetbiosComputerName );
        }
    } else if ( ServerName != NULL && ServerName[0] != '\0') {
        NlDcCacheEntry->UnicodeNetbiosDcName = (LPWSTR) Where;
        if ( ServerName[0] == L'\\' && ServerName[1] == L'\\' ) {
            wcscpy( (LPWSTR)Where, ServerName+2 );
        } else {
            wcscpy( (LPWSTR)Where, ServerName );
        }
    } else if ( OemPrimaryDcName != NULL ) {
        NlDcCacheEntry->UnicodeNetbiosDcName = (LPWSTR) Where;
        if ( OemPrimaryDcName[0] == '\\' && OemPrimaryDcName[1] == '\\') {
            NetpCopyStrToWStr( (LPWSTR)Where, OemPrimaryDcName+2 );
        } else {
            NetpCopyStrToWStr( (LPWSTR)Where, OemPrimaryDcName );
        }
    }
    Where += ServerNameSize;

    // Copy the user name,
    if ( Utf8UserName != NULL && Utf8UserName[0] != '\0' ) {
        NlDcCacheEntry->UnicodeUserName = (LPWSTR) Where;
        NetpCopyUtf8StrToWStr( (LPWSTR)Where, Utf8UserName );
    } else if ( UserName != NULL && UserName[0] != '\0') {
        NlDcCacheEntry->UnicodeUserName = (LPWSTR) Where;
        wcscpy( (LPWSTR)Where, UserName );
    }
    Where += UserNameSize;


    // Copy the domain name.
    if ( Utf8NetbiosDomainName != NULL && Utf8NetbiosDomainName[0] != '\0' ) {
        NlDcCacheEntry->UnicodeNetbiosDomainName = (LPWSTR) Where;
        NetpCopyUtf8StrToWStr( (LPWSTR)Where, Utf8NetbiosDomainName );
    } else if ( DomainName != NULL && DomainName[0] != '\0') {
        NlDcCacheEntry->UnicodeNetbiosDomainName = (LPWSTR) Where;
        wcscpy( (LPWSTR)Where, DomainName );
    }
    Where += DomainNameSize;

    // Copy the DnsForestName
    if ( DnsForestName != NULL ) {
        NlDcCacheEntry->UnicodeDnsForestName = (LPWSTR) Where;
        NetpCopyUtf8StrToWStr( (LPWSTR)Where, DnsForestName );
    }
    Where += DnsForestNameSize;

    // Copy the DnsDomainName
    if ( DnsDomainName != NULL ) {
        NlDcCacheEntry->UnicodeDnsDomainName = (LPWSTR) Where;
        NetpCopyUtf8StrToWStr( (LPWSTR)Where, DnsDomainName );
    }
    Where += DnsDomainNameSize;

    // Copy the DnsHostName
    if ( DnsHostName != NULL ) {
        NlDcCacheEntry->UnicodeDnsHostName = (LPWSTR) Where;
        NetpCopyUtf8StrToWStr( (LPWSTR)Where, DnsHostName );
    }
    Where += DnsHostNameSize;

    // Copy the DcSiteName
    if ( Utf8DcSiteName != NULL ) {
        NlDcCacheEntry->UnicodeDcSiteName = (LPWSTR) Where;
        NetpCopyUtf8StrToWStr( (LPWSTR)Where, Utf8DcSiteName );
    }
    Where += DcSiteNameSize;

    // Copy the ClientSiteName
    if ( Utf8ClientSiteName != NULL ) {
        NlDcCacheEntry->UnicodeClientSiteName = (LPWSTR) Where;
        NetpCopyUtf8StrToWStr( (LPWSTR)Where, Utf8ClientSiteName );
    }
    Where += ClientSiteNameSize;

    //
    // Save the time when we created the entry
    //

    NlDcCacheEntry->CreationTime = GetTickCount();

    return NlDcCacheEntry;
}


NET_API_STATUS
NetpDcParsePingResponse(
    IN LPCWSTR DisplayDomainName,
    IN PVOID Message,
    IN ULONG MessageSize,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry
    )

/*++

Routine Description:

    Parse the response message for a ping.

Arguments:

    DisplayDomainName - Domain name to display on debugger if problems occur

    Message - The message returned from a DC in question.

    MessageSize - Specifies the size (in bytes) of the message

    NlDcCacheEntry - On success, returns a pointer to the cache entry
        describing the found DC.  This entry must be dereferenced using
        NetpDcDerefCacheEntry.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_INVALID_DATA - The message could not be recognized as a valid
        response message.

    ERROR_NOT_ENOUGH_MEMORY - The message could not be allocated.

--*/
{
    NET_API_STATUS NetStatus;

    PNETLOGON_SAM_LOGON_RESPONSE_EX SamLogonResponseEx;
    PNETLOGON_SAM_LOGON_RESPONSE SamLogonResponse;
    PNETLOGON_PRIMARY PrimaryResponse;
    DWORD SamLogonResponseSize;
    LPWSTR ServerName = NULL;
    LPSTR OemPrimaryDcName = NULL;
    LPWSTR UserName = NULL;
    LPWSTR DomainName = NULL;
    GUID DomainGuid = {0};
    GUID SiteGuid = {0};
    USHORT LocalOpcode;

    LPSTR DnsForestName = NULL;
    LPSTR DnsDomainName = NULL;
    LPSTR DnsHostName = NULL;
    LPSTR Utf8NetbiosDomainName = NULL;
    LPSTR Utf8NetbiosComputerName = NULL;
    LPSTR Utf8UserName = NULL;
    LPSTR Utf8DcSiteName = NULL;
    LPSTR Utf8ClientSiteName = NULL;
    ULONG LocalDcIpAddress;
    SOCKET_ADDRESS DcSocketAddress = {0,0};
    SOCKADDR_IN DcSockAddrIn;
    ULONG Flags;
    LPBYTE Where;

    DWORD Version;
    DWORD VersionFlags;

    //
    // Initialization.
    //

    SamLogonResponse = (PNETLOGON_SAM_LOGON_RESPONSE) Message;
    SamLogonResponseSize = MessageSize;
    *NlDcCacheEntry = NULL;

    //
    // Get the version of the responder.
    //

    Version = NetpLogonGetMessageVersion( SamLogonResponse,
                                          &SamLogonResponseSize,
                                          &VersionFlags );


    //
    // Process the message as a function of the opcode.
    //
    LocalOpcode = SamLogonResponse->Opcode;

    switch ( LocalOpcode ) {
    case LOGON_SAM_LOGON_RESPONSE:
    case LOGON_SAM_USER_UNKNOWN:
    case LOGON_SAM_PAUSE_RESPONSE:

        //
        // Ensure the version is expected.
        //

        if ( Version != LMNT_MESSAGE ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: Version bad. %ld\n",
                      DisplayDomainName,
                      Version ));
            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }



        //
        // Pick up the Netbios name of the server that responded.
        //

        Where = (PCHAR) &SamLogonResponse->UnicodeLogonServer;
        if ( !NetpLogonGetUnicodeString(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        sizeof(SamLogonResponse->UnicodeLogonServer),
                        &ServerName ) ) {

            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws server name bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }


        //
        // Ensure this is a UNC name.
        //

        if ( ServerName[0] != '\0' &&
             (ServerName[0] != '\\'  || ServerName[1] != '\\' )) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws server name not UNC.\n",
                      DisplayDomainName ));
            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;

        }

        //
        // Pick up the name of the account the response is for.
        //

        if ( !NetpLogonGetUnicodeString(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        sizeof(SamLogonResponse->UnicodeUserName ),
                        &UserName ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: user name bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }



        //
        // Pick up the name of the domain the response is from.
        //

        if ( !NetpLogonGetUnicodeString(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        sizeof(SamLogonResponse->UnicodeDomainName ),
                        &DomainName ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: domain name bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        //
        // Pick up the NT 5 specific responses.
        //

        if ( VersionFlags & NETLOGON_NT_VERSION_5) {

            //
            // Pick up the GUID of the domain the response is from.
            //

            if ( !NetpLogonGetGuid(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            &DomainGuid ) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws: domain guid bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }

            //
            // Pick up the GUID of the site the responding DC is in.
            //

            if ( !NetpLogonGetGuid(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            &SiteGuid ) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws site guid bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }

            //
            // Pick up the DNS domain name of the tree the responder is in.
            //

            if ( !NetpLogonGetCutf8String(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            &DnsForestName ) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws DNS forest bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }


            //
            // Pick up the DNS domain name the responding DC is in.
            //

            if ( !NetpLogonGetCutf8String(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            &DnsDomainName ) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws: DNS domain bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }



            //
            // Pick up the DNS host name of the responding DC.
            //

            if ( !NetpLogonGetCutf8String(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            &DnsHostName ) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws: DNS host bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }




            //
            // Pick up the IP Address of the responding DC.
            //

            if ( !NetpLogonGetBytes(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            sizeof(SamLogonResponse->DcIpAddress ),
                            &LocalDcIpAddress) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws: IP Address bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }

            //
            // Convert the IP address to a sockaddr
            //
            // One should find it mildly humorous that on the host we represent the
            // IP address in net order and that on the net we represent it in host order.
            // I'm chuckling as I write this.
            //

            if ( LocalDcIpAddress != 0 ) {
                DcSockAddrIn.sin_family = AF_INET;
                DcSockAddrIn.sin_port = 0;
                DcSockAddrIn.sin_addr.S_un.S_addr = htonl(LocalDcIpAddress);

                DcSocketAddress.lpSockaddr = (LPSOCKADDR) &DcSockAddrIn;
                DcSocketAddress.iSockaddrLength = sizeof(SOCKADDR_IN);
            }

            //
            // Pick up the flags desribing the responding DC.
            //

            if ( !NetpLogonGetBytes(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            sizeof(SamLogonResponse->Flags ),
                            &Flags) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws: Flags bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }

        //
        // If not version 5,
        //  indicate version 5 specific fields are not present.
        //
        } else {
            RtlZeroMemory( &DomainGuid, sizeof(DomainGuid) );
            Flags = 0;
        }


        break;

    case LOGON_SAM_LOGON_RESPONSE_EX:
    case LOGON_SAM_USER_UNKNOWN_EX:
    case LOGON_SAM_PAUSE_RESPONSE_EX:

        //
        // Map the opcode for easier use by the client.
        //
        switch ( LocalOpcode ) {
        case LOGON_SAM_LOGON_RESPONSE_EX:
            LocalOpcode = LOGON_SAM_LOGON_RESPONSE; break;
        case LOGON_SAM_USER_UNKNOWN_EX:
            LocalOpcode = LOGON_SAM_USER_UNKNOWN; break;
        case LOGON_SAM_PAUSE_RESPONSE_EX:
            LocalOpcode = LOGON_SAM_PAUSE_RESPONSE; break;
        }

        SamLogonResponseEx = (PNETLOGON_SAM_LOGON_RESPONSE_EX) SamLogonResponse;

        //
        // Ensure the version is expected.
        //

        if ( Version != LMNT_MESSAGE ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: Version bad. %ld\n",
                      DisplayDomainName,
                      Version ));
            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }


        //
        // Pick up the flags desribing the responding DC.
        //

        Where = (PCHAR) &SamLogonResponseEx->Flags;
        if ( !NetpLogonGetBytes(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        sizeof(SamLogonResponseEx->Flags ),
                        &Flags) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: Flags bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        //
        // Pick up the GUID of the domain the response is from.
        //

        if ( !NetpLogonGetGuid(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        &DomainGuid ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: domain guid bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        //
        // Pick up the DNS domain name of the tree the responder is in.
        //

        if ( !NetpLogonGetCutf8String(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        &DnsForestName ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws DNS forest bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }


        //
        // Pick up the DNS domain name the responding DC is in.
        //

        if ( !NetpLogonGetCutf8String(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        &DnsDomainName ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: DNS domain bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }



        //
        // Pick up the DNS host name of the responding DC.
        //

        if ( !NetpLogonGetCutf8String(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        &DnsHostName ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: DNS host bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }



        //
        // Pick up the Netbios domain name
        //

        if ( !NetpLogonGetCutf8String(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        &Utf8NetbiosDomainName ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: Netbios Domain name bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }



        //
        // Pick up the Netbios Computer name
        //

        if ( !NetpLogonGetCutf8String(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        &Utf8NetbiosComputerName ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: Netbios Computer name bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }


        //
        // Pick up the user name
        //

        if ( !NetpLogonGetCutf8String(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        &Utf8UserName ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: User name bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }



        //
        // Pick up the DC site name
        //

        if ( !NetpLogonGetCutf8String(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        &Utf8DcSiteName ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: DC site name bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }



        //
        // Pick up the client site name
        //

        if ( !NetpLogonGetCutf8String(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        &Utf8ClientSiteName ) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws: Client site name bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        //
        // If this message contains the IP address of the DC,
        //  grab it.
        //

        if ( VersionFlags & NETLOGON_NT_VERSION_5EX_WITH_IP ) {
            CHAR LocalSockAddrSize;

            //
            // Grab the size of the SockAddr
            //

            if ( !NetpLogonGetBytes(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            sizeof(SamLogonResponseEx->DcSockAddrSize ),
                            &LocalSockAddrSize ) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws: SockAddr size bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }

            if ( LocalSockAddrSize > sizeof(DcSockAddrIn) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws: SockAddr size too big %ld %ld.\n",
                          DisplayDomainName,
                          LocalSockAddrSize,
                          sizeof(DcSockAddrIn)));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }

            //
            // Grab the SockAddr itself.
            //

            if ( !NetpLogonGetBytes(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            LocalSockAddrSize,
                            &DcSockAddrIn ) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws: SockAddr size bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }

            //
            // Build a SocketAddress to point to the SockAddr
            //
            DcSocketAddress.lpSockaddr = (LPSOCKADDR) &DcSockAddrIn;
            DcSocketAddress.iSockaddrLength = LocalSockAddrSize;

        }
        break;

    //
    // Process a response to a primary query.
    //

    case LOGON_PRIMARY_RESPONSE:

        PrimaryResponse = (PNETLOGON_PRIMARY)SamLogonResponse;

        Where = PrimaryResponse->PrimaryDCName;

        //
        // Pick up the Netbios name of the server that responded.
        //

        if ( !NetpLogonGetOemString(
                        SamLogonResponse,
                        SamLogonResponseSize,
                        &Where,
                        sizeof(PrimaryResponse->PrimaryDCName),
                        &OemPrimaryDcName ) ) {

            NlPrint(( NL_CRITICAL,
                      "NetpDcParsePingResponse: %ws:OEM server name bad.\n",
                      DisplayDomainName ));

            NetStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }



        //
        // PDC for the specified domain is an NT PDC.
        //  Get the UNICODE machine name from the message.
        //

        if ( Version == LMNT_MESSAGE ) {

            //
            // Pick up the Netbios name of the server that responded.
            //

            if ( !NetpLogonGetUnicodeString(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            sizeof(PrimaryResponse->UnicodePrimaryDCName),
                            &ServerName ) ) {

                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws: server name bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }



            //
            // Pick up the Netbios domain name of the domain the response is from.
            //

            if ( !NetpLogonGetUnicodeString(
                            SamLogonResponse,
                            SamLogonResponseSize,
                            &Where,
                            sizeof(PrimaryResponse->UnicodeDomainName),
                            &DomainName ) ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcParsePingResponse: %ws: domain name bad.\n",
                          DisplayDomainName ));

                NetStatus = ERROR_INVALID_DATA;
                goto Cleanup;
            }
        }

        //
        // Ensure caller knows this is a PDC.
        //

        RtlZeroMemory( &DomainGuid, sizeof(DomainGuid) );

        Flags = DS_PDC_FLAG | DS_WRITABLE_FLAG;

        break;

    //
    // Unknown response opcode.
    //

    default:

        NlPrint(( NL_CRITICAL,
                  "NetpDcParsePingResponse: %ws: opcode bad. %ld\n",
                  DisplayDomainName,
                  LocalOpcode ));
        NetStatus = ERROR_INVALID_DATA;
        goto Cleanup;

    }


    //
    // ASSERT: DC has been found.
    //

    //
    // Allocate and initialize a cache entry.
    //

    *NlDcCacheEntry = NetpDcAllocateCacheEntry(
                            ServerName,
                            OemPrimaryDcName,
                            UserName,
                            DomainName,
                            &DomainGuid,
                            DnsForestName,
                            DnsDomainName,
                            DnsHostName,
                            Utf8NetbiosDomainName,
                            Utf8NetbiosComputerName,
                            Utf8UserName,
                            Utf8DcSiteName,
                            Utf8ClientSiteName,
                            Flags );

    if ( *NlDcCacheEntry == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NetpDcParsePingResponse: %ws: not enough memory.\n",
                  DisplayDomainName ));
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    (*NlDcCacheEntry)->Opcode = LocalOpcode;
    (*NlDcCacheEntry)->VersionFlags = VersionFlags;


    //
    // Fill the DC's SockAddr into the cache entry
    //

    if ( DcSocketAddress.iSockaddrLength != 0 ) {
        NlAssert( DcSocketAddress.iSockaddrLength <= sizeof( (*NlDcCacheEntry)->SockAddrIn) );

        RtlCopyMemory( &(*NlDcCacheEntry)->SockAddrIn,
                       DcSocketAddress.lpSockaddr,
                       DcSocketAddress.iSockaddrLength );

        (*NlDcCacheEntry)->SockAddr.lpSockaddr = (LPSOCKADDR)
            &(*NlDcCacheEntry)->SockAddrIn;
        (*NlDcCacheEntry)->SockAddr.iSockaddrLength = DcSocketAddress.iSockaddrLength;
    }


    NetStatus = NO_ERROR;

Cleanup:

    //
    // On failure,
    //  delete any strings we may have allocated for return to the caller.
    //
    if ( NetStatus != NO_ERROR ) {
        if ( *NlDcCacheEntry != NULL ) {
            NetpMemoryFree( *NlDcCacheEntry );
            *NlDcCacheEntry = NULL;
        }
    }

    //
    // Delete any buffers allocated locally.
    //

    if ( DnsForestName != NULL ) {
        NetpMemoryFree( DnsForestName );
    }
    if ( DnsDomainName != NULL ) {
        NetpMemoryFree( DnsDomainName );
    }
    if ( DnsHostName != NULL ) {
        NetpMemoryFree( DnsHostName );
    }
    if ( Utf8NetbiosDomainName != NULL ) {
        NetpMemoryFree( Utf8NetbiosDomainName );
    }
    if ( Utf8NetbiosComputerName != NULL ) {
        NetpMemoryFree( Utf8NetbiosComputerName );
    }
    if ( Utf8UserName != NULL ) {
        NetpMemoryFree( Utf8UserName );
    }
    if ( Utf8DcSiteName != NULL ) {
        NetpMemoryFree( Utf8DcSiteName );
    }
    if ( Utf8ClientSiteName != NULL ) {
        NetpMemoryFree( Utf8ClientSiteName );
    }

    return NetStatus;;
}


NET_API_STATUS
NetpDcFlagsToNameType(
    IN ULONG Flags,
    OUT PNL_DNS_NAME_TYPE NlDnsNameType
    )

/*++

Routine Description:

    Given the flags specified to DsGetDcName, return the type of the DNS
    name to query to discover that type of DC.

Arguments:

    Flags - Passes additional information to be used to process the request.
        Flags can be a combination values bitwise or'ed together.

    NlDnsNameType - Returns the type of DNS name to query.

Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_INVALID_FLAGS - The flags parameter has conflicting bits set.

--*/
{
    ULONG LocalFlags;

    //
    // If more than one of this bits is set,
    //  that's invalid.
    //
    LocalFlags = Flags & (DS_KDC_REQUIRED|DS_PDC_REQUIRED|DS_GC_SERVER_REQUIRED);

    if ( LocalFlags != 0 && !JUST_ONE_BIT( LocalFlags ) ) {
        return ERROR_INVALID_FLAGS;
    }


    //
    // Select the cache entry type based on the requested DC type.
    //
    if ( Flags & DS_PDC_REQUIRED ) {
        *NlDnsNameType = NlDnsPdc;
    } else if ( Flags & DS_ONLY_LDAP_NEEDED ) {
        if ( Flags & DS_GC_SERVER_REQUIRED ) {
            *NlDnsNameType = NlDnsGenericGc;
        } else {
            *NlDnsNameType = NlDnsLdap;
        }

    } else if ( Flags & DS_GC_SERVER_REQUIRED ) {
        *NlDnsNameType = NlDnsGc;
    } else if ( Flags & DS_KDC_REQUIRED ) {
        *NlDnsNameType = NlDnsKdc;
    } else {
        *NlDnsNameType = NlDnsDc;
    }
    return NO_ERROR;

}

BOOL
NetpAppendUtf8Str(
    IN OUT LPSTR To,
    IN LPCSTR From,
    IN ULONG ResultingStringLengthMax
    )
/*++

Routine Description:

    This routine appends a UTF8 string to a UTF8 string making sure
        that it doesn't write beyond the buffer limit.

Arguments:

    To - The string to append to.

    From - The string to append.

    ResultingStringLengthMax - Maximum allowed length of the resulting string
        in bytes not counting the terminating null character.


Return Value:

    TRUE: The string is successfully appended.

    Otherwise, returns FALSE.

--*/
{
    ULONG ToLen;
    ULONG FromLen;

    if ( To == NULL || From == NULL || ResultingStringLengthMax == 0 ) {
        return FALSE;
    }

    ToLen = strlen(To);
    FromLen = strlen(From);

    if ( ToLen+FromLen > ResultingStringLengthMax ) {
        return FALSE;
    }

    RtlCopyMemory( &To[ToLen], From, FromLen+1 );
    return TRUE;
}

NET_API_STATUS
NetpDcBuildDnsName(
    IN NL_DNS_NAME_TYPE NlDnsNameType,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN LPCSTR DnsDomainName,
    OUT char DnsName[NL_MAX_DNS_LENGTH+1]
    )
/*++

Routine Description:

    This routine returns the textual DNS name for a particular domain and
    name type.

Arguments:

    NlDnsNameType - The specific type of name.

    DomainGuid - Guid to append to DNS name.
        For NlDnsDcByGuid, this is the GUID of the domain being located.
        For NlDnsDsaCname, this is the GUID of the DSA being located.

    SiteName - Name of the site to append to DNS name.
        If NlDnsNameType is any of the *AtSite values,
        this is the name of the site the DC is in.

    DnsDomainName - Specifies the DNS domain for the name.

        For NlDnsDcByGuid or any of the GC names,
            this is the DNS domain name of the domain at the root of the tree of
            domains.
        For all others, this is the DNS domain for the DC.

    DnsName - Textual representation of the DNS name.
        The returned name is an absolute name (e.g., ends in a .)

Return Value:

    NO_ERROR: The name was returned;

    ERROR_INVALID_DOMAINNAME: Domain's name is too long. Additional labels
        cannot be concatenated.

--*/
{
    char *FinalString;
    ULONG DnsNameLength;

    //
    // All SRV record names names are prefixed by ldap.tcp (or kdc.tcp or gc.tcp),
    //  A records and CNAME records are not.
    //

    *DnsName = '\0';
    if ( NlDnsSrvRecord( NlDnsNameType ) ) {

        //
        // Output the name of the service.
        //
        if ( NlDnsNameType == NlDnsGenericGc ||
             NlDnsNameType == NlDnsGenericGcAtSite ) {

            if ( !NetpAppendUtf8Str(DnsName, NL_DNS_GC_SRV, NL_MAX_DNS_LENGTH) ) {
                return ERROR_INVALID_DOMAINNAME;
            }

        } else if ( NlDnsKpwdRecord( NlDnsNameType )) {

            if ( !NetpAppendUtf8Str(DnsName, NL_DNS_KPWD_SRV, NL_MAX_DNS_LENGTH) ) {
                return ERROR_INVALID_DOMAINNAME;
            }

        } else if ( NlDnsKdcRecord( NlDnsNameType ) ) {

            if ( !NetpAppendUtf8Str(DnsName, NL_DNS_KDC_SRV, NL_MAX_DNS_LENGTH) ) {
                return ERROR_INVALID_DOMAINNAME;
            }

        } else {

            if ( !NetpAppendUtf8Str(DnsName, NL_DNS_LDAP_SRV, NL_MAX_DNS_LENGTH) ) {
                return ERROR_INVALID_DOMAINNAME;
            }

        }

        //
        // Output the name of the transport.
        //
        if ( NlDcDnsNameTypeDesc[NlDnsNameType].IsTcp ) {

            if ( !NetpAppendUtf8Str(DnsName, NL_DNS_TCP, NL_MAX_DNS_LENGTH) ) {
                return ERROR_INVALID_DOMAINNAME;
            }

        } else {

            if ( !NetpAppendUtf8Str(DnsName, NL_DNS_UDP, NL_MAX_DNS_LENGTH) ) {
                return ERROR_INVALID_DOMAINNAME;
            }

        }
    }

    //
    // If this is a site specific name,
    //  append the site name and the .sites. constant.
    //

    if ( NlDcDnsNameTypeDesc[NlDnsNameType].IsSiteSpecific ) {
        if ( NULL == NetpCreateUtf8StrFromWStr( SiteName,
                                                &DnsName[strlen(DnsName)],
                                                NL_MAX_DNS_LENGTH+1-strlen(DnsName)) ) {
            return ERROR_INVALID_DOMAINNAME;
        }

        if ( !NetpAppendUtf8Str(DnsName, NL_DNS_AT_SITE, NL_MAX_DNS_LENGTH) ) {
            return ERROR_INVALID_DOMAINNAME;
        }
    }


    //
    // Add the first label (or two) of the DNS name as a function of the name type.
    //

    switch (NlDnsNameType) {
    case NlDnsLdap:
    case NlDnsLdapAtSite:
    case NlDnsRfc1510Kdc:
    case NlDnsRfc1510KdcAtSite:
    case NlDnsGenericGc:
    case NlDnsGenericGcAtSite:
    case NlDnsRfc1510UdpKdc:
    case NlDnsRfc1510Kpwd:
    case NlDnsRfc1510UdpKpwd:
        break;

    case NlDnsPdc:
        if ( !NetpAppendUtf8Str(DnsName, NL_DNS_PDC, NL_MAX_DNS_LENGTH) ) {
            return ERROR_INVALID_DOMAINNAME;
        }
        break;

    case NlDnsGc:
    case NlDnsGcAtSite:
        if ( !NetpAppendUtf8Str(DnsName, NL_DNS_GC, NL_MAX_DNS_LENGTH) ) {
            return ERROR_INVALID_DOMAINNAME;
        }
        break;

    case NlDnsDc:
    case NlDnsDcAtSite:
    case NlDnsKdc:
    case NlDnsKdcAtSite:
        if ( !NetpAppendUtf8Str(DnsName, NL_DNS_DC, NL_MAX_DNS_LENGTH) ) {
            return ERROR_INVALID_DOMAINNAME;
        }
        break;

    case NlDnsDcByGuid: {
        RPC_STATUS RpcStatus;
        char *StringGuid;

        RpcStatus = UuidToStringA( DomainGuid, &StringGuid );

        if ( RpcStatus != RPC_S_OK ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcBuildDnsName: not enough memory.\n" ));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( !NetpAppendUtf8Str(DnsName, StringGuid, NL_MAX_DNS_LENGTH) ) {
            return ERROR_INVALID_DOMAINNAME;
        }

        RpcStringFreeA( &StringGuid );
        if ( !NetpAppendUtf8Str(DnsName, NL_DNS_DC_BY_GUID, NL_MAX_DNS_LENGTH) ) {
            return ERROR_INVALID_DOMAINNAME;
        }

        break;
    }

    case NlDnsLdapIpAddress:
        if ( !NetpAppendUtf8Str(DnsName, NL_DNS_DC_IP_ADDRESS, NL_MAX_DNS_LENGTH) ) {
            return ERROR_INVALID_DOMAINNAME;
        }
        break;

    case NlDnsGcIpAddress:
        if ( !NetpAppendUtf8Str(DnsName, NL_DNS_GC_IP_ADDRESS, NL_MAX_DNS_LENGTH) ) {
            return ERROR_INVALID_DOMAINNAME;
        }
        break;

    case NlDnsDsaCname:
    {
        RPC_STATUS RpcStatus;
        char *StringGuid;

        RpcStatus = UuidToStringA( DomainGuid, &StringGuid );

        if ( RpcStatus != RPC_S_OK ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcBuildDnsName: not enough memory.\n" ));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( !NetpAppendUtf8Str(DnsName, StringGuid, NL_MAX_DNS_LENGTH) ) {
            return ERROR_INVALID_DOMAINNAME;
        }

        RpcStringFreeA( &StringGuid );

        if ( !NetpAppendUtf8Str(DnsName, NL_DNS_DSA_IP_ADDRESS, NL_MAX_DNS_LENGTH) ) {
            return ERROR_INVALID_DOMAINNAME;
        }

        break;
    }

    default:
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Add it to the correct DNS domain.
    //  Ensuring it isn't too long.
    //

    if ( !NetpAppendUtf8Str(DnsName, DnsDomainName, NL_MAX_DNS_LENGTH) ) {
        return ERROR_INVALID_DOMAINNAME;
    }

    DnsNameLength = strlen(DnsName);

    //
    // Ensure it is an absolute name.
    //

    if ( DnsName[DnsNameLength-1] != '.' ) {

        if ( DnsNameLength+1 > NL_MAX_DNS_LENGTH ) {
            return ERROR_INVALID_DOMAINNAME;
        }

        DnsName[DnsNameLength] = '.';
        DnsName[DnsNameLength+1] = '\0';
    }

    return NO_ERROR;

}




VOID
NetpDcDerefCacheEntry(
    IN PNL_DC_CACHE_ENTRY NlDcCacheEntry
    )
/*++

Routine Description:

    Decrement the reference count on a cache entry.  If the count reaches zero,
    delete the entry.

    The count will only reach zero if the entry is already removed from the
    global linked list.

Arguments:

    NlDcCacheEntry - Cache entry to dereference.

Return Value:

    None.

--*/
{
    ULONG LocalReferenceCount;

    EnterCriticalSection(&NlDcCritSect);
    LocalReferenceCount = -- NlDcCacheEntry->ReferenceCount;
    LeaveCriticalSection(&NlDcCritSect);

    if ( LocalReferenceCount == 0 ) {
        NetpMemoryFree(NlDcCacheEntry);
    }
}

BOOL
NetpDcMatchResponse(
    IN PNL_GETDC_CONTEXT Context,
    IN PNL_DC_CACHE_ENTRY NlDcCacheEntry,
    IN BOOL BeVerbose,
    OUT PBOOL UsedNetbios
    )
/*++

Routine Description:

    This routine determines if the characteristics specified as input
    parameters match the characteristics of the DC requested by the caller.

    This routine is used to determine if a received ping response is suitable
    to the original caller.  This routine is also used to determine if a cache entry
    is suitable to the original caller.

Arguments:

    Context - Context describing the GetDc operation.

    NlDcCacheEntry - Reponse to compare with.

    BeVerbose - TRUE if problems are to be logged

    UsedNetbios - Returns TRUE if the netbios domain name was used to do the
        successful comparison.

Return Value:

    TRUE - The parameters describe a suitable DC

--*/
{
    BOOLEAN LocalUsedNetbios = FALSE;

    //
    // Initialization
    //

    *UsedNetbios = FALSE;

#ifdef notdef
    // Only use GUID to be rename safe.  Not to prevent discovery of a re-installed
    // domain.
    //
    // Ensure the DomainGuid returned matches the one expected.
    //

    if ( Context->QueriedDomainGuid != NULL &&
         !IsEqualGUID( &NlDcCacheEntry->DomainGuid, &NlDcZeroGuid) &&
         !IsEqualGUID( &NlDcCacheEntry->DomainGuid, Context->QueriedDomainGuid) ) {

        if ( BeVerbose ) {
            NlPrint((NL_CRITICAL,
                    "NetpDcMatchResponse: %ws: %ws: Domain Guid isn't queried Guid\n",
                    NlDcCacheEntry->UnicodeNetbiosDcName,
                    Context->QueriedDisplayDomainName ));
        }
        return FALSE;
    }
#endif // notdef

    //
    // Either the Netbios DC name or DNS DC name must have been returned.
    //

    if ( NlDcCacheEntry->UnicodeNetbiosDcName == NULL && NlDcCacheEntry->UnicodeDnsHostName == NULL ) {
        if ( BeVerbose ) {
            NlPrint((NL_CRITICAL,
                    "NetpDcMatchResponse: %ws: %ws: Neither Netbios nor DNS DC name available\n",
                    NlDcCacheEntry->UnicodeNetbiosDcName,
                    Context->QueriedDisplayDomainName ));
        }
        return FALSE;
    }

    //
    // If we ping a DC, check that the responding DC name is the one requested.
    //
    // Process the special case when we ping a DC and the DC name can be both DNS and Netbios
    //

    if ( (Context->QueriedInternalFlags & (DS_PING_DNS_HOST|DS_PING_NETBIOS_HOST)) ==
         (DS_PING_DNS_HOST|DS_PING_NETBIOS_HOST)) {
        BOOL NameMatched = FALSE;

        //
        // Check if the DNS name matches
        //
        if ( NlDcCacheEntry->UnicodeDnsHostName != NULL &&
             Context->QueriedDcName != NULL &&
             NlEqualDnsName(NlDcCacheEntry->UnicodeDnsHostName,
                            Context->QueriedDcName) ) {
            NameMatched = TRUE;
        }

        //
        // If DNS name doesn't match, check if Netbios name does
        //
        if ( !NameMatched &&
             NlDcCacheEntry->UnicodeNetbiosDcName != NULL &&
             Context->QueriedDcName != NULL &&
             (NlNameCompare(NlDcCacheEntry->UnicodeNetbiosDcName,
                            (LPWSTR)Context->QueriedDcName,
                            NAMETYPE_COMPUTER) == 0) ) {
            NameMatched = TRUE;
        }

        //
        // If neither name matches, fail
        //
        if ( !NameMatched ) {
            if ( BeVerbose ) {
                NlPrint(( NL_CRITICAL,
                 "NetpDcMatchResponse: Ping response with unmatched host name %ws %ws %ws\n",
                 Context->QueriedDcName,
                 NlDcCacheEntry->UnicodeDnsHostName,
                 NlDcCacheEntry->UnicodeNetbiosDcName ));
            }
            return FALSE;
        }

    //
    // If the pinged DC name is exactly DNS,
    //  check that the returned DNS host name is same
    //

    } else if ( Context->QueriedInternalFlags & DS_PING_DNS_HOST ) {
        if ( (NlDcCacheEntry->UnicodeDnsHostName == NULL) ||
             (Context->QueriedDcName == NULL) ||
             !NlEqualDnsName(NlDcCacheEntry->UnicodeDnsHostName, Context->QueriedDcName) ) {

            if ( BeVerbose ) {
                NlPrint(( NL_CRITICAL,
                 "NetpDcMatchResponse: Ping response with unmatched DNS host name %ws %ws\n",
                 Context->QueriedDcName,
                 NlDcCacheEntry->UnicodeDnsHostName ));
            }
            return FALSE;
        }

    //
    // If the pinged DC name is exactly Netbios,
    //  check that the returned Netbios host name is same
    //

    } else if ( Context->QueriedInternalFlags & DS_PING_NETBIOS_HOST ) {
        if ( (NlDcCacheEntry->UnicodeNetbiosDcName == NULL) ||
             (Context->QueriedDcName == NULL) ||
             NlNameCompare(NlDcCacheEntry->UnicodeNetbiosDcName,
                           (LPWSTR)Context->QueriedDcName,
                           NAMETYPE_COMPUTER) != 0 ) {

            if ( BeVerbose ) {
                NlPrint(( NL_CRITICAL,
                 "NetpDcMatchResponse: Ping response with unmatched Netbios host name %ws %ws\n",
                 Context->QueriedDcName,
                 NlDcCacheEntry->UnicodeNetbiosDcName ));
            }
            return FALSE;
        }
    }

    //
    // If asking for a GC,
    //  ensure the Tree name of the responding DC matches the one
    //  we're asking for.
    //

    if ( NlDnsGcName( Context->QueriedNlDnsNameType ) ) {

        if (NlDcCacheEntry->UnicodeDnsForestName == NULL ||
          Context->QueriedDnsDomainName == NULL ||
          !NlEqualDnsName( NlDcCacheEntry->UnicodeDnsForestName, Context->QueriedDnsDomainName ) ) {

            if ( BeVerbose ) {
                NlPrint((NL_CRITICAL,
                        "NetpDcMatchResponse: %ws: asking for GC and tree name doesn't match request %ws %ws\n",
                        NlDcCacheEntry->UnicodeNetbiosDcName,
                        NlDcCacheEntry->UnicodeDnsForestName,
                        Context->QueriedDnsDomainName ));
            }
            return FALSE;
        }

    //
    // Ensure the domain name returned matches the one expected.
    //

    } else {
        BOOLEAN NetbiosSame;
        BOOLEAN DnsSame;


        //
        // If neither of the domain names compared,
        //  the domain names don't match
        //

        NetbiosSame =
            ( NlDcCacheEntry->UnicodeNetbiosDomainName != NULL &&
              Context->QueriedNetbiosDomainName != NULL &&
              NlNameCompare( (LPWSTR)NlDcCacheEntry->UnicodeNetbiosDomainName, (LPWSTR)Context->QueriedNetbiosDomainName, NAMETYPE_DOMAIN ) == 0 );

        DnsSame =
             NlDcCacheEntry->UnicodeDnsDomainName != NULL &&
             Context->QueriedDnsDomainName != NULL &&
             NlEqualDnsName( NlDcCacheEntry->UnicodeDnsDomainName, Context->QueriedDnsDomainName );

        if ( !NetbiosSame && !DnsSame ) {

            //
            // Lanman PDC's don't return the domain name.
            //  (So don't complain about lack of domain name if this is a PDC query.)
            //

            if ( Context->DcQueryType != NlDcQueryPdc ||
                 NlDcCacheEntry->UnicodeNetbiosDomainName != NULL ||
                 NlDcCacheEntry->UnicodeDnsDomainName != NULL ) {

                if ( BeVerbose ) {
                    NlPrint((NL_CRITICAL,
                            "NetpDcMatchResponse: %ws: Neither Netbios %ws nor DNS %ws domain matches queried name %ws %ws\n",
                            NlDcCacheEntry->UnicodeNetbiosDcName,
                            NlDcCacheEntry->UnicodeNetbiosDomainName,
                            NlDcCacheEntry->UnicodeDnsDomainName,
                            Context->QueriedNetbiosDomainName,
                            Context->QueriedDnsDomainName ));
                }

                //
                // Finally check if the domain GUID matches which
                //  may be the case if the domain has been renamed
                //
                if ( Context->QueriedDomainGuid != NULL &&
                     !IsEqualGUID( &NlDcCacheEntry->DomainGuid, &NlDcZeroGuid) &&
                     IsEqualGUID( &NlDcCacheEntry->DomainGuid, Context->QueriedDomainGuid) ) {

                    if ( BeVerbose ) {
                        NlPrint(( NL_CRITICAL,
                                  "NetpDcMatchResponse: %ws: But Domain Guid matches\n",
                                  NlDcCacheEntry->UnicodeNetbiosDcName ));
                    }

                } else {
                    return FALSE;
                }

            } else {
                // Lanman PDCs always used netbios.
                LocalUsedNetbios = TRUE;
            }
        }

        //
        // If only the domain name matched,
        //  tell the caller.
        //

        if ( NetbiosSame && !DnsSame ) {
            LocalUsedNetbios = TRUE;
        }
    }

    //
    // Ensure the queried account name is the correct.
    //

    if ( Context->QueriedAccountName != NULL ) {

        //
        // If this is an NT 4 PDC responding to a PDC query,
        //  ignore the fact we queried for an account.
        // We can't query both "PDC" and "account" at the same time
        // from NT 4.
        //

        if ( NlDcCacheEntry->Opcode == LOGON_PRIMARY_RESPONSE &&
             (NlDcCacheEntry->ReturnFlags & DS_DS_FLAG) == 0 &&
             (NlDcCacheEntry->ReturnFlags & DS_PDC_FLAG) != 0 ) {
            if ( BeVerbose ) {
                NlPrint((NL_SESSION_SETUP,
                        "NetpDcMatchResponse: %ws: %ws: response for wrong account '%ws' s.b. '%ws' (but message from NT 4 PDC so use it).\n",
                        NlDcCacheEntry->UnicodeNetbiosDcName,
                        Context->QueriedDisplayDomainName,
                        NlDcCacheEntry->UnicodeUserName,
                        Context->QueriedAccountName ));
            }

        } else if ( NlDcCacheEntry->UnicodeUserName == NULL ||
             _wcsicmp( (LPWSTR) Context->QueriedAccountName, NlDcCacheEntry->UnicodeUserName ) != 0 ) {

            if ( BeVerbose ) {
                NlPrint((NL_CRITICAL,
                        "NetpDcMatchResponse: %ws: %ws: response for wrong account '%ws' s.b. '%ws'\n",
                        NlDcCacheEntry->UnicodeNetbiosDcName,
                        Context->QueriedDisplayDomainName,
                        NlDcCacheEntry->UnicodeUserName,
                        Context->QueriedAccountName ));
            }
            return FALSE;
        }
    }

    //
    // Ensure the responding DC is still playing the correct role.
    //

    switch ( Context->DcQueryType ) {
    case NlDcQueryLdap:
    case NlDcQueryGenericDc:
        // All DCs are suitable
        break;

    case NlDcQueryPdc:
        if ( (NlDcCacheEntry->ReturnFlags & DS_PDC_FLAG) == 0 ) {
            if ( BeVerbose ) {
                NlPrint((NL_CRITICAL,
                        "NetpDcMatchResponse: %ws: %ws: Responder is not the PDC. 0x%lx\n",
                        NlDcCacheEntry->UnicodeNetbiosDcName,
                        Context->QueriedDisplayDomainName,
                        NlDcCacheEntry->ReturnFlags ));
            }
            return FALSE;
        }
        break;

    case NlDcQueryGc:
        if ( (NlDcCacheEntry->ReturnFlags & (DS_GC_FLAG|DS_DS_FLAG)) != (DS_GC_FLAG|DS_DS_FLAG) ) {
            if ( BeVerbose ) {
                NlPrint((NL_CRITICAL,
                        "NetpDcMatchResponse: %ws: %ws: Responder is not a GC server. 0x%lx\n",
                        NlDcCacheEntry->UnicodeNetbiosDcName,
                        Context->QueriedDisplayDomainName,
                        NlDcCacheEntry->ReturnFlags ));
            }
            return FALSE;
        }
        break;

    case NlDcQueryGenericGc:
        if ( (NlDcCacheEntry->ReturnFlags & DS_GC_FLAG) == 0 ) {
            if ( BeVerbose ) {
                NlPrint((NL_CRITICAL,
                        "NetpDcMatchResponse: %ws: %ws: Responder is not a GC server. 0x%lx\n",
                        NlDcCacheEntry->UnicodeNetbiosDcName,
                        Context->QueriedDisplayDomainName,
                        NlDcCacheEntry->ReturnFlags ));
            }
            return FALSE;
        }
        break;

    case NlDcQueryKdc:
        // Handle KDCs below.
        break;


    default:
        if ( BeVerbose ) {
            NlPrint((NL_CRITICAL,
                     "NetpDcMatchResponse: %ws: %ws: invalid query type 0x%lx 0x%lx\n",
                     NlDcCacheEntry->UnicodeNetbiosDcName,
                     Context->QueriedDisplayDomainName,
                     Context->DcQueryType,
                     NlDcCacheEntry->ReturnFlags ));
        }
        return FALSE;
    }

    //
    // If we are not doing an NDNC discovery (i.e. we are discovering a real
    //  domain DC), disregard a response from an LDAP server servicing this
    //  name as NDNC
    //

    if ( NlDnsNonNdncName( Context->QueriedNlDnsNameType ) &&
         (NlDcCacheEntry->ReturnFlags & DS_NDNC_FLAG) != 0 ) {
        if ( BeVerbose ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcMatchResponse: %ws: %ws: response not from real domain DC. 0x%lx\n",
                      NlDcCacheEntry->UnicodeNetbiosDcName,
                      Context->QueriedDisplayDomainName,
                      NlDcCacheEntry->ReturnFlags ));
        }
        return FALSE;
    }

    //
    // If we need a DS server, ensure the responding DC is one.
    //

    if ( (Context->QueriedFlags & DS_DIRECTORY_SERVICE_REQUIRED) &&
         (NlDcCacheEntry->ReturnFlags & DS_DS_FLAG) == 0 ) {
        if ( BeVerbose ) {
            NlPrint((NL_CRITICAL,
                    "NetpDcMatchResponse: %ws: %ws: response not from DS server. 0x%lx\n",
                    NlDcCacheEntry->UnicodeNetbiosDcName,
                    Context->QueriedDisplayDomainName,
                    NlDcCacheEntry->ReturnFlags ));
        }
        return FALSE;
    }

    //
    // If we need machine running the timeserv, ensure the responding DC is one.
    //

    if ( (Context->QueriedFlags & (DS_TIMESERV_REQUIRED|DS_GOOD_TIMESERV_PREFERRED)) &&
         (NlDcCacheEntry->ReturnFlags & DS_TIMESERV_FLAG) == 0 ) {
        if ( BeVerbose ) {
            NlPrint((NL_CRITICAL,
                    "NetpDcMatchResponse: %ws: %ws: response not from a Time Server. 0x%lx\n",
                    NlDcCacheEntry->UnicodeNetbiosDcName,
                    Context->QueriedDisplayDomainName,
                    NlDcCacheEntry->ReturnFlags ));
        }
        return FALSE;
    }

    //
    // If we need machine running that is writable, ensure the responding DC is.
    //

    if ( (Context->QueriedFlags & DS_WRITABLE_REQUIRED) &&
         (NlDcCacheEntry->ReturnFlags & DS_WRITABLE_FLAG) == 0 ) {
        if ( BeVerbose ) {
            NlPrint((NL_CRITICAL,
                    "NetpDcMatchResponse: %ws: %ws: Responder is not a writable server. 0x%lx\n",
                    NlDcCacheEntry->UnicodeNetbiosDcName,
                    Context->QueriedDisplayDomainName,
                    NlDcCacheEntry->ReturnFlags ));
        }
        return FALSE;
    }

    //
    // If we need an LDAP server, ensure the responding server is
    //

    if ( (Context->QueriedFlags & DS_ONLY_LDAP_NEEDED) &&
         (NlDcCacheEntry->ReturnFlags & DS_LDAP_FLAG) == 0 ) {
        if ( BeVerbose ) {
            NlPrint((NL_CRITICAL,
                    "NetpDcMatchResponse: %ws: %ws: Responder is not a LDAP server. 0x%lx\n",
                    NlDcCacheEntry->UnicodeNetbiosDcName,
                    Context->QueriedDisplayDomainName,
                    NlDcCacheEntry->ReturnFlags ));
        }
        return FALSE;
    }

    //
    // If the caller wants only netbios names,
    //  ensure one is available.
    //

    if ( Context->QueriedFlags & DS_RETURN_FLAT_NAME ) {
        if ( NlDcCacheEntry->UnicodeNetbiosDcName == NULL || NlDcCacheEntry->UnicodeNetbiosDomainName == NULL ) {
            if ( BeVerbose ) {
                NlPrint((NL_CRITICAL,
                        "NetpDcMatchResponse: %ws: %ws: Netbios server or domain name needed and missing.\n",
                        NlDcCacheEntry->UnicodeNetbiosDcName,
                        Context->QueriedDisplayDomainName ));
            }
            return FALSE;
        }
    }


    //
    // If the caller wants only dns names,
    //  ensure one is available.
    //

    if ( Context->QueriedFlags & DS_RETURN_DNS_NAME ) {
        if ( NlDcCacheEntry->UnicodeDnsHostName == NULL || NlDcCacheEntry->UnicodeDnsDomainName == NULL ) {
            if ( BeVerbose ) {
                NlPrint((NL_CRITICAL,
                        "NetpDcMatchResponse: %ws: Dns server or domain name needed and missing.\n",
                        Context->QueriedDisplayDomainName ));
            }
            return FALSE;
        }
    }

    //
    // If the caller explicitly specified a sitename,
    //  ensure the DC is in the specified site.
    //

    if ( Context->DoingExplicitSite ) {

        if ( NlDcCacheEntry->UnicodeDcSiteName == NULL ||
            _wcsicmp( NlDcCacheEntry->UnicodeDcSiteName,
                      Context->QueriedSiteName ) != 0 ) {
            if ( BeVerbose ) {
                NlPrint((NL_CRITICAL,
                        "NetpDcMatchResponse: %ws: Responder is in site '%ws' but site '%ws' asked for.\n",
                        Context->QueriedDisplayDomainName,
                        NlDcCacheEntry->UnicodeDcSiteName,
                        Context->QueriedSiteName ));
            }
            return FALSE;
        }
    }


    //
    // If we should ignored responses from ourself,
    //  do so now.
    //

    if ( (Context->QueriedFlags & DS_AVOID_SELF) != 0 &&
         NlDcCacheEntry->UnicodeNetbiosDcName != NULL ) {

        //
        // If response is from this computer,
        //  ignore it.
        //

        if ( NlNameCompare( NlDcCacheEntry->UnicodeNetbiosDcName,
                            (LPWSTR)Context->OurNetbiosComputerName,
                            NAMETYPE_COMPUTER ) == 0 ) {

            if ( BeVerbose ) {
                NlPrint((NL_SESSION_SETUP,
                         "NetpDcMatchResponse: %ws: response is from ourself and caller asked for AVOID_SELF.\n",
                         Context->QueriedDisplayDomainName ));
            }
            return FALSE;
        }

    }

    //
    // If we need machine running the KDC, ensure the responding DC is one.
    //

    if ( (Context->QueriedFlags & DS_KDC_REQUIRED) &&
         (NlDcCacheEntry->ReturnFlags & DS_KDC_FLAG) == 0 ) {

        if ( BeVerbose ) {
            NlPrint((NL_CRITICAL,
                    "NetpDcMatchResponse: %ws: %ws: response not from KDC. 0x%lx\n",
                    NlDcCacheEntry->UnicodeNetbiosDcName,
                    Context->QueriedDisplayDomainName,
                    NlDcCacheEntry->ReturnFlags ));
        }
        return FALSE;
    }



    //
    // If we need a DC running IP, ensure the responding DC has an IP address.
    //
    // Do this check after the KDC check.  Kerberos always asks for IP_REQUIRED.
    // We don't want this check to discard the entry for non-KDCs.
    //

    if ( (Context->QueriedFlags & DS_IP_REQUIRED) &&
         NlDcCacheEntry->SockAddr.iSockaddrLength == 0 ) {
        if ( BeVerbose ) {
            NlPrint((NL_CRITICAL,
                    "NetpDcMatchResponse: %ws: %ws: response not from IP transport\n",
                    NlDcCacheEntry->UnicodeNetbiosDcName,
                    Context->QueriedDisplayDomainName ));
        }
        return FALSE;
    }

    //
    // FINAL TEST!!!!
    //
    // Only do this test if the cache entry meets all of the other criteria.
    //
    // If we prefer a DS server and this DC is not one,
    //  just save this entry and continue looking.
    //  If we find no DS server, we'll use this entry as a last resort.
    //

    if ( (Context->QueriedFlags & DS_DIRECTORY_SERVICE_PREFERRED) &&
         (NlDcCacheEntry->ReturnFlags & DS_DS_FLAG) == 0 ) {

        //
        // Ditch the previously saved cache entry if the new DC is closer.
        //

        if ( Context->ImperfectCacheEntry != NULL &&
             (Context->ImperfectCacheEntry->ReturnFlags & DS_CLOSEST_FLAG) == 0 &&
             (NlDcCacheEntry->ReturnFlags & DS_CLOSEST_FLAG) != 0 ) {

            NetpDcDerefCacheEntry( Context->ImperfectCacheEntry );
            Context->ImperfectCacheEntry = NULL;

        }

        //
        // Only save the first entry
        //
        if ( Context->ImperfectCacheEntry == NULL ) {
            if ( BeVerbose ) {
                NlPrint((NL_SESSION_SETUP,
                        "NetpDcMatchResponse: %ws: non-DS server responded when DS preferred\n",
                        Context->QueriedDisplayDomainName ));
            }

            //
            // Reference the entry
            //
            NlDcCacheEntry->ReferenceCount ++;
            Context->ImperfectCacheEntry = NlDcCacheEntry;
            Context->ImperfectUsedNetbios = LocalUsedNetbios;
        }

        //
        // Tell the caller that the match failed.
        //  The caller will use the above stored entry at his discretion.
        return FALSE;
    }

    //
    // FINAL TEST!!!!
    //
    // Only do this test if the cache entry meets all of the other criteria.
    //
    // If we prefer a "good" time server and this DC is not one,
    //  just save this entry and continue looking.
    //  If we find no "good" time server server, we'll use this entry as a last resort.
    //

    if ( (Context->QueriedFlags & DS_GOOD_TIMESERV_PREFERRED) &&
         (NlDcCacheEntry->ReturnFlags & DS_GOOD_TIMESERV_FLAG) == 0 ) {


        //
        // Ditch the previously saved cache entry if the new DC is closer.
        //

        if ( Context->ImperfectCacheEntry != NULL &&
             (Context->ImperfectCacheEntry->ReturnFlags & DS_CLOSEST_FLAG) == 0 &&
             (NlDcCacheEntry->ReturnFlags & DS_CLOSEST_FLAG) != 0 ) {

            NetpDcDerefCacheEntry( Context->ImperfectCacheEntry );
            Context->ImperfectCacheEntry = NULL;

        }


        //
        // Only save the first entry
        //
        if ( Context->ImperfectCacheEntry == NULL ) {
            if ( BeVerbose ) {
                NlPrint((NL_SESSION_SETUP,
                        "NetpDcMatchResponse: %ws: non-good time server responded when one preferred\n",
                        Context->QueriedDisplayDomainName ));
            }

            //
            // Reference the entry
            //
            NlDcCacheEntry->ReferenceCount ++;
            Context->ImperfectCacheEntry = NlDcCacheEntry;
            Context->ImperfectUsedNetbios = LocalUsedNetbios;
        }

        //
        // Tell the caller that the match failed.
        //  The caller will use the above stored entry at his discretion.
        return FALSE;
    }

    //
    // All tests passed.
    //
    *UsedNetbios = LocalUsedNetbios;
    return TRUE;
}

PNL_DC_CACHE_ENTRY
NetpDcFindCacheEntry(
    IN PNL_GETDC_CONTEXT Context,
    OUT PBOOL UsedNetbios,
    OUT PBOOL ForcePing
    )
/*++

Routine Description:

    This routine finds a cache entry that matches the caller's query.

Arguments:

    Context - Context describing the GetDc operation.

    UsedNetbios - Returns TRUE if the netbios domain name was used to do the
        successful comparison.

    ForcePing - TRUE if the returned cache entry has to be pinged before it is used

Return Value:

    On success, returns a pointer to the cache entry describing the found DC.
        This entry must be dereferenced using NetpDcDerefCacheEntry.

    NULL - no matching cache entry could be found.

--*/
{
    PNL_DC_CACHE_ENTRY NlDcCacheEntry;
    BOOL LocalUsedNetbios;
    LONG QueryType; // Must be a signed number



    //
    // Check if there is a cache entry for this query type.
    //
    *ForcePing = FALSE;
    EnterCriticalSection(&NlDcCritSect);
    NlDcCacheEntry = Context->NlDcDomainEntry->Dc[Context->DcQueryType].NlDcCacheEntry;
    if ( NlDcCacheEntry != NULL ) {


        //
        // Ensure the cache entry matches all the criteria.
        //

        if ( NetpDcMatchResponse(
                    Context,
                    NlDcCacheEntry,
                    FALSE,
                    &LocalUsedNetbios) ) {

            NlPrint(( NL_DNS_MORE,
                      "Cache: %ws %ws: Cache entry %ld exists and was used.\n",
                      Context->NlDcDomainEntry->UnicodeNetbiosDomainName,
                      Context->NlDcDomainEntry->UnicodeDnsDomainName,
                      Context->DcQueryType ));

            goto Cleanup;

        } else {
            BOOL Matched;

            //
            // If the only thing different is the account name,
            //  don't ditch the cache entry just for that reason.
            //
            if ( Context->QueriedAccountName != NULL ) {
                LPCWSTR QueriedAccountName;
                ULONG QueriedAllowableAccountControlBits;

                QueriedAccountName = Context->QueriedAccountName;
                Context->QueriedAccountName = NULL;

                QueriedAllowableAccountControlBits = Context->QueriedAllowableAccountControlBits;
                Context->QueriedAllowableAccountControlBits = 0;

                Matched = NetpDcMatchResponse(
                                 Context,
                                 NlDcCacheEntry,
                                 FALSE,
                                 &LocalUsedNetbios);

                Context->QueriedAccountName = QueriedAccountName;
                Context->QueriedAllowableAccountControlBits = QueriedAllowableAccountControlBits;

                if ( Matched ) {

                    NlPrint(( NL_DNS_MORE,
                              "Cache: %ws %ws: Cache entry %ld exists and was used (but account wrong).\n",
                              Context->NlDcDomainEntry->UnicodeNetbiosDomainName,
                              Context->NlDcDomainEntry->UnicodeDnsDomainName,
                              Context->DcQueryType ));
                    *ForcePing = TRUE;
                    goto Cleanup;
                }

            }

            NlPrint(( NL_DNS_MORE,
                      "Cache: %ws %ws: Cache entry %ld exists and was NOT used.\n",
                      Context->NlDcDomainEntry->UnicodeNetbiosDomainName,
                      Context->NlDcDomainEntry->UnicodeDnsDomainName,
                      Context->DcQueryType ));
        }
    }




    //
    // Try to find a less specific cache entry that happens to match the criteria.
    //
    // For example, if I've previously cached an entry for a generic DC and it
    // happens to be a PDC.  If I later try to find a PDC, use the one I've already
    // found.
    //



    for ( QueryType = Context->DcQueryType-1; QueryType>=0; QueryType-- ) {

        //
        // Do not return a GC entry if this is a non-GC (PDC) discovery.
        //  Accordingly, do not return a non-GC entry if this is a GC discovery.
        //  We want to ensure this match to return the correct closeness bit.
        //
        if ( QueryType == NlDcQueryGc || QueryType == NlDcQueryGenericGc ) {
            if ( !NlDnsGcName( Context->QueriedNlDnsNameType ) ) {
                continue;
            }
        } else {
            if ( NlDnsGcName( Context->QueriedNlDnsNameType ) ) {
                continue;
            }
        }

        //
        // If the cache entry matches all the criteria,
        //     use it.
        //
        NlDcCacheEntry = Context->NlDcDomainEntry->Dc[QueryType].NlDcCacheEntry;
        if ( NlDcCacheEntry != NULL &&
             NetpDcMatchResponse(
                    Context,
                    NlDcCacheEntry,
                    FALSE,
                    &LocalUsedNetbios) ) {


            //
            // I considered saving this cache entry as the preferred cache
            // entry for this query type (by copying the pointer and
            // incrementing the reference count).  That'd ensure I'd
            // consistently get this entry for this query type.  But it'd
            // also mean that I'd get this old entry once the original
            // entry had been forced from the cache.
            //
            // Context->NlDcDomainEntry->Dc[Context->DcQueryType].NlDcCacheEntry = NlDcCacheEntry;

            NlPrint(( NL_DNS_MORE,
                      "Cache: %ws %ws: Cache entry %ld used for %ld query.\n",
                      Context->NlDcDomainEntry->UnicodeNetbiosDomainName,
                      Context->NlDcDomainEntry->UnicodeDnsDomainName,
                      QueryType,
                      Context->DcQueryType ));

            goto Cleanup;


        }
    }


    //
    // Entry isn't in the cache.
    //

    NlDcCacheEntry = NULL;

Cleanup:
    if ( NlDcCacheEntry != NULL ) {
        //
        // Reference this entry.
        //
        NlDcCacheEntry->ReferenceCount++;
        *UsedNetbios = LocalUsedNetbios;
    }
    LeaveCriticalSection(&NlDcCritSect);

    return NlDcCacheEntry;
}



PNL_DC_DOMAIN_ENTRY
NetpDcFindDomainEntry(
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    IN PNL_DC_DOMAIN_ENTRY NlDcDomainEntryToAvoid
    )
/*++

Routine Description:

    This routine finds a domain entry that matches the caller's query.

Arguments:

    DomainGuid - Specifies the GUID of the domain to find.

    NetbiosDomainName - Specifies the Netbios name of the domain to find.

    DnsDomainName - Specifies the Dns name of the domain to find.

    NlDcDomainEntryToAvoid - Specifies that this domain entry is not
        to be returned even if it matches the description.

Return Value:

    On success, returns a pointer to the domain cache entry describing a domain.
        This entry must be dereference using NetpDcDerefDomainEntry.

    NULL - no matching cache entry could be found.

--*/
{

    PLIST_ENTRY DomainEntry;
    PNL_DC_DOMAIN_ENTRY NlDcDomainEntry = NULL;
    ULONG EntryCount;



    //
    // Loop trying to find a cache entry that matches caller's query.
    //
    EnterCriticalSection(&NlDcCritSect);

    EntryCount = 0;
    for ( DomainEntry = NlDcDomainList.Flink ;
          DomainEntry != &NlDcDomainList;
          DomainEntry = DomainEntry->Flink ) {

        EntryCount ++;
        NlDcDomainEntry = CONTAINING_RECORD( DomainEntry, NL_DC_DOMAIN_ENTRY, Next);

        //
        // If this is the entry we're to avoid, skip it.
        //

        if ( NlDcDomainEntry == NlDcDomainEntryToAvoid ) {
            NlDcDomainEntry = NULL;
            continue;
        }

        //
        // Ensure the DomainGuid returned matches the one expected.
        //

        if ( DomainGuid != NULL &&
             !IsEqualGUID( &NlDcDomainEntry->DomainGuid, &NlDcZeroGuid) &&
             !IsEqualGUID( &NlDcDomainEntry->DomainGuid, DomainGuid) ) {

            NlDcDomainEntry = NULL;
            continue;
        }

        //
        // Ensure the Domain Name returned matches the one expected.
        //

        if ( ( NlDcDomainEntry->UnicodeNetbiosDomainName[0] == L'\0' ||
               NetbiosDomainName == NULL ||
                NlNameCompare( NlDcDomainEntry->UnicodeNetbiosDomainName, (LPWSTR)NetbiosDomainName, NAMETYPE_DOMAIN ) != 0 ) &&
             (NlDcDomainEntry->UnicodeDnsDomainName == NULL ||
             DnsDomainName == NULL ||
                !NlEqualDnsName( NlDcDomainEntry->UnicodeDnsDomainName, DnsDomainName )  ) ) {

            NlDcDomainEntry = NULL;
            continue;
        }

        //
        // If we've gotten this far,
        //  this entry matches the request.
        //
        // Reference this entry.
        //
        NlDcDomainEntry->ReferenceCount++;
        break;

    }

    if ( NlDcDomainEntry == NULL ) {
        NlAssert( EntryCount == NlDcDomainCount );
    }

    LeaveCriticalSection(&NlDcCritSect);

    return NlDcDomainEntry;

}



VOID
NetpDcDerefDomainEntry(
    IN PNL_DC_DOMAIN_ENTRY NlDcDomainEntry
    )
/*++

Routine Description:

    Decrement the reference count on a cache entry.  If the count reaches zero,
    delete the entry.

    The count will only reach zero if the entry is already removed from the
    global linked list.

Arguments:

    NlDcDomainEntry - Cache entry to dereference.

Return Value:

    None.

--*/
{
    ULONG LocalReferenceCount;

    EnterCriticalSection(&NlDcCritSect);
    LocalReferenceCount = -- NlDcDomainEntry->ReferenceCount;

    if ( LocalReferenceCount == 0 ) {
        ULONG QueryType;

        //
        // Remove our reference to all of the cache entries for this domain.
        //
        for ( QueryType = 0; QueryType < NlDcQueryTypeCount; QueryType ++ ) {
            if ( NlDcDomainEntry->Dc[QueryType].NlDcCacheEntry != NULL ) {
                NetpDcDerefCacheEntry( NlDcDomainEntry->Dc[QueryType].NlDcCacheEntry );
            }
        }

        //
        // Free DnsName
        //

        if ( NlDcDomainEntry->UnicodeDnsDomainName != NULL ) {
            NetpMemoryFree( NlDcDomainEntry->UnicodeDnsDomainName );
        }

        //
        // Free the entry itself.
        //

        NetpMemoryFree(NlDcDomainEntry);
    }
    LeaveCriticalSection(&NlDcCritSect);
}

VOID
NetpDcDeleteDomainEntry(
    IN PNL_DC_DOMAIN_ENTRY NlDcDomainEntry
    )
/*++

Routine Description:

    Remove a cache entry from the global list.

    Enter with NlDcCritSect locked.

Arguments:

    NlDcDomainEntry - Cache entry to remove.

Return Value:

    None.

--*/
{
    //
    // Remove it.
    //
    RemoveEntryList( &NlDcDomainEntry->Next );
    NlDcDomainCount --;

    //
    // Ensure any current references know it has been deleted.
    //

    NlDcDomainEntry->DeletedEntry = TRUE;

    //
    // Decrement the reference indicating it is on the list.
    //
    NetpDcDerefDomainEntry( NlDcDomainEntry );
}


BOOL
NetpDcUpdateDomainEntry(
    IN PNL_DC_DOMAIN_ENTRY NlDcDomainEntry,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL
    )
/*++

Routine Description:

    This routine updates the domain entry to contain the passed in domain
    name information.

Arguments:

    NlDcDomainEntry - Domain entry to update.

    DomainGuid - Specifies the GUID of the domain.

    NetbiosDomainName - Specifies the Netbios name of the domain.

    DnsDomainName - Specifies the Dns name of the domain.

Return Value:

    TRUE - all names updated as requested.
    FALSE - some names could not be updated.

--*/
{
    BOOL NamesChanged = FALSE;
    PNL_DC_DOMAIN_ENTRY DuplicateDomainEntry;


    //
    // If this entry has been deleted,
    //  don't bother updating it.
    //

    EnterCriticalSection(&NlDcCritSect);
    if ( NlDcDomainEntry->DeletedEntry ) {
        LeaveCriticalSection(&NlDcCritSect);
        return TRUE;
    }

    //
    // Fill in the Netbios domain name if it is not already filled in.
    //
    if ( NetbiosDomainName != NULL &&
         ( NlDcDomainEntry->UnicodeNetbiosDomainName[0] == L'\0' ||
           NlNameCompare( NlDcDomainEntry->UnicodeNetbiosDomainName, (LPWSTR)NetbiosDomainName, NAMETYPE_DOMAIN ) != 0 ) ) {

        wcscpy( NlDcDomainEntry->UnicodeNetbiosDomainName, NetbiosDomainName );
        NamesChanged = TRUE;
        NlPrint(( NL_DNS_MORE,
                  "Cache: %ws %ws: Set netbios domain name\n",
                  NlDcDomainEntry->UnicodeNetbiosDomainName,
                  NlDcDomainEntry->UnicodeDnsDomainName ));
    }


    //
    // Fill in the DNS domain name if it is not already filled in.
    //
    if ( DnsDomainName != NULL &&
         ( NlDcDomainEntry->UnicodeDnsDomainName == NULL ||
           !NlEqualDnsName( NlDcDomainEntry->UnicodeDnsDomainName, DnsDomainName )  ) ) {

        if ( NlDcDomainEntry->UnicodeDnsDomainName != NULL ) {
            NetApiBufferFree( NlDcDomainEntry->UnicodeDnsDomainName );
        }

        NlDcDomainEntry->UnicodeDnsDomainName = NetpAllocWStrFromWStr( (LPWSTR) DnsDomainName );

        if ( NlDcDomainEntry->UnicodeDnsDomainName == NULL ) {
            LeaveCriticalSection(&NlDcCritSect);
            return FALSE;
        }
        NamesChanged = TRUE;

        NlPrint(( NL_DNS_MORE,
                  "Cache: %ws %ws: Set DNS domain name\n",
                  NlDcDomainEntry->UnicodeNetbiosDomainName,
                  NlDcDomainEntry->UnicodeDnsDomainName ));

    }

    //
    // Fill in the GUID if its not already filled in.
    //

    if ( DomainGuid != NULL &&
         IsEqualGUID( &NlDcDomainEntry->DomainGuid, DomainGuid) ) {

        NamesChanged = TRUE;
        NlDcDomainEntry->DomainGuid = *DomainGuid;
    }

    //
    // If the names have changed,
    //  perhaps this domain cache entry now duplicates another entry.
    //
    // Find any duplicate entries and merge them into this one.
    //

    if ( NamesChanged ) {
        while ( (DuplicateDomainEntry = NetpDcFindDomainEntry(
                        &NlDcDomainEntry->DomainGuid,
                        NlDcDomainEntry->UnicodeNetbiosDomainName,
                        NlDcDomainEntry->UnicodeDnsDomainName,
                        NlDcDomainEntry )) != NULL ) {
            ULONG QueryType;

            NlPrint(( NL_DNS_MORE,
                      "Cache: %ws %ws: is now a duplicate of %ws %ws\n",
                      NlDcDomainEntry->UnicodeNetbiosDomainName,
                      NlDcDomainEntry->UnicodeDnsDomainName,
                      DuplicateDomainEntry->UnicodeNetbiosDomainName,
                      DuplicateDomainEntry->UnicodeDnsDomainName ));

            //
            // Move any cache entries from the duplicate to the new.
            // ?? We could theoretically keep the 'better' of the two entries.
            //
            for ( QueryType = 0; QueryType < NlDcQueryTypeCount; QueryType ++ ) {
                if ( NlDcDomainEntry->Dc[QueryType].NlDcCacheEntry == NULL &&
                     DuplicateDomainEntry->Dc[QueryType].NlDcCacheEntry != NULL ) {

                    NlDcDomainEntry->Dc[QueryType].NlDcCacheEntry =
                         DuplicateDomainEntry->Dc[QueryType].NlDcCacheEntry;
                    NlFlushNegativeCacheEntry( &NlDcDomainEntry->Dc[QueryType] );
                    DuplicateDomainEntry->Dc[QueryType].NlDcCacheEntry = NULL;

                    NlPrint(( NL_DNS_MORE,
                              "Cache: %ws %ws: grab entry %ld from %ws %ws\n",
                              NlDcDomainEntry->UnicodeNetbiosDomainName,
                              NlDcDomainEntry->UnicodeDnsDomainName,
                              QueryType,
                              DuplicateDomainEntry->UnicodeNetbiosDomainName,
                              DuplicateDomainEntry->UnicodeDnsDomainName ));
                }
            }

            //
            // Delete the duplicate entry.
            //  (There may be an outstanding reference to this entry.)
            //

            NetpDcDeleteDomainEntry( DuplicateDomainEntry );

            // Remove our reference.
            NetpDcDerefDomainEntry( DuplicateDomainEntry );

        }
    }



    LeaveCriticalSection(&NlDcCritSect);
    return TRUE;

}



VOID
NetpDcInsertCacheEntry(
    IN PNL_GETDC_CONTEXT Context,
    IN PNL_DC_CACHE_ENTRY NlDcCacheEntry
    )
/*++

Routine Description:

    This routine inserts a cache entry onto the domain entry.

Arguments:

    Context - Context describing the GetDc operation.

    NlDcCacheEntry - Cache entry to use.

Return Value:

    None.

--*/
{
    PNL_DC_CACHE_ENTRY *CacheEntryPtr;
    PNL_DC_DOMAIN_ENTRY NlDcDomainEntry = Context->NlDcDomainEntry;

    //
    // If the caller explicitly asked for a particular site,
    //  and that site isn't the closest site.
    //  Avoid polluting the cache with this entry.
    //
    if ( Context->DoingExplicitSite &&
         (NlDcCacheEntry->ReturnFlags & DS_CLOSEST_FLAG) == 0 ) {

        NlPrint(( NL_DNS_MORE,
                  "Cache: %ws %ws: don't cache this entry since an explicit site '%ws' was asked for.\n",
                  NlDcDomainEntry->UnicodeNetbiosDomainName,
                  NlDcDomainEntry->UnicodeDnsDomainName,
                  Context->QueriedSiteName ));
        return;
    }



    //
    // If there is no cache entry for this query type,
    //  or this cache entry is better than the old one,
    //  or the new cache entry was found via a 'force' rediscovery,
    //  or the new cache entry is for the same DC as the old entry,
    //      use the new cache entry.
    //
    EnterCriticalSection(&NlDcCritSect);
    CacheEntryPtr = &NlDcDomainEntry->Dc[Context->DcQueryType].NlDcCacheEntry;
    if ( *CacheEntryPtr == NULL ||
         NlDcCacheEntry->DcQuality >= (*CacheEntryPtr)->DcQuality ||
         (Context->QueriedFlags & DS_FORCE_REDISCOVERY) != 0 ||

         (NlDcCacheEntry->UnicodeNetbiosDcName != NULL  &&
          (*CacheEntryPtr)->UnicodeNetbiosDcName != NULL &&
          NlNameCompare( NlDcCacheEntry->UnicodeNetbiosDcName,
                         (*CacheEntryPtr)->UnicodeNetbiosDcName,
                          NAMETYPE_COMPUTER ) == 0 ) ||

         (NlDcCacheEntry->UnicodeDnsHostName != NULL  &&
          (*CacheEntryPtr)->UnicodeDnsHostName != NULL &&
          NlEqualDnsName( NlDcCacheEntry->UnicodeDnsHostName,
                         (*CacheEntryPtr)->UnicodeDnsHostName ) )

        ) {

        //
        // Delink any existing cache entry.
        //

        if ( *CacheEntryPtr != NULL ) {

           NlPrint(( NL_DNS_MORE,
                     "Cache: %ws %ws: Ditch existing cache entry %ld (Quality: %ld)\n",
                     NlDcDomainEntry->UnicodeNetbiosDomainName,
                     NlDcDomainEntry->UnicodeDnsDomainName,
                     Context->DcQueryType,
                     (*CacheEntryPtr)->DcQuality ));
            NetpDcDerefCacheEntry( *CacheEntryPtr );
            *CacheEntryPtr = NULL;
        }

        //
        // Link the cache entry onto the domain entry and increment the reference count
        // to account for the new reference.
        //
        *CacheEntryPtr = NlDcCacheEntry;
        NlDcCacheEntry->ReferenceCount ++;

        //
        // Indicate that the cache entry has been inserted
        //
        NlDcCacheEntry->CacheEntryFlags |= NL_DC_CACHE_ENTRY_INSERTED;

        //
        // Flush the negative cache.
        //

        NlFlushNegativeCacheEntry( &NlDcDomainEntry->Dc[Context->DcQueryType] );

        //
        // Update the domain entry to contain more information about the domain.
        //
        // If this is a GC discovery entry and the discovered forest name is different
        //  from the domain name of the GC, update the domain entry using the forest
        //  name only.
        //
        if ( NlDnsGcName( Context->QueriedNlDnsNameType ) &&
             (NlDcCacheEntry->UnicodeDnsForestName == NULL ||
              NlDcCacheEntry->UnicodeDnsDomainName == NULL ||
              !NlEqualDnsName( NlDcCacheEntry->UnicodeDnsForestName,
                               NlDcCacheEntry->UnicodeDnsDomainName )) ) {

            (VOID) NetpDcUpdateDomainEntry( NlDcDomainEntry,
                                            NULL,
                                            NULL,
                                            NlDcCacheEntry->UnicodeDnsForestName );
        } else {

            (VOID) NetpDcUpdateDomainEntry( NlDcDomainEntry,
                                            &NlDcCacheEntry->DomainGuid,
                                            NlDcCacheEntry->UnicodeNetbiosDomainName,
                                            NlDcCacheEntry->UnicodeDnsDomainName );
        }

        NlPrint(( NL_DNS_MORE,
                  "Cache: %ws %ws: Add cache entry %ld (Quality: %ld)\n",
                  NlDcDomainEntry->UnicodeNetbiosDomainName,
                  NlDcDomainEntry->UnicodeDnsDomainName,
                  Context->DcQueryType,
                  NlDcCacheEntry->DcQuality ));
    } else {

        NlPrint(( NL_DNS_MORE,
                  "Cache: %ws %ws: Existing cache entry for type %ld is better %ld %ld\n",
                  NlDcDomainEntry->UnicodeNetbiosDomainName,
                  NlDcDomainEntry->UnicodeDnsDomainName,
                  Context->DcQueryType,
                  NlDcCacheEntry->DcQuality,
                  (*CacheEntryPtr)->DcQuality ));
    }
    LeaveCriticalSection(&NlDcCritSect);

    return;
}




PNL_DC_DOMAIN_ENTRY
NetpDcCreateDomainEntry(
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL
    )
/*++

Routine Description:

    This routine finds an existing domain cache entry that matches the
    caller's query or creates one.


Arguments:

    DomainGuid - Specifies the GUID of the domain to find.

    NetbiosDomainName - Specifies the Netbios name of the domain to find.

    DnsDomainName - Specifies the Dns name of the domain to find.

Return Value:

    On success, returns a pointer to the domain cache entry describing a domain.
        This entry must be dereference using NetpDcDerefDomainEntry.

    NULL - Entry could not be allocated.

--*/
{

    PLIST_ENTRY DomainEntry;
    PNL_DC_DOMAIN_ENTRY NlDcDomainEntry;


    //
    // If there is an existing entry, use it.
    //

    EnterCriticalSection(&NlDcCritSect);
    NlDcDomainEntry = NetpDcFindDomainEntry( DomainGuid, NetbiosDomainName, DnsDomainName, NULL );

    if ( NlDcDomainEntry != NULL ) {

        //
        // Put the referenced entry at the front of the list.
        //

        RemoveEntryList( &NlDcDomainEntry->Next );
        InsertHeadList( &NlDcDomainList, &NlDcDomainEntry->Next );

        NlPrint(( NL_DNS_MORE,
                  "Cache: %ws %ws: Found existing domain cache entry\n",
                  NlDcDomainEntry->UnicodeNetbiosDomainName,
                  NlDcDomainEntry->UnicodeDnsDomainName ));


        //
        // Set the domain information in the domain entry.
        //
        // One might be tempted to put the domain name into the domain entry at this
        // time.  That'd be bogus since that caller doesn't know whether the passed
        // in netbios and DNS name is really correct.  For instance, in some instances,
        // both passed in names are the netbios domain name.
        //

        if ( !NetpDcUpdateDomainEntry( NlDcDomainEntry,
                                       DomainGuid,
                                       NULL,
                                       NULL ) ) {

            // Remove our reference.
            NetpDcDerefDomainEntry( NlDcDomainEntry );
            NlDcDomainEntry = NULL;

        }


    //
    // Otherwise allocate a new entry.
    //
    } else {

        //
        // Allocate a new entry.
        //

        NlDcDomainEntry = NetpMemoryAllocate( sizeof( NL_DC_DOMAIN_ENTRY ) );

        if ( NlDcDomainEntry == NULL ) {
            LeaveCriticalSection(&NlDcCritSect);
            return NULL;
        }

        NlPrint(( NL_DNS_MORE,
                  "Cache: %ws %ws: Create new domain cache entry\n",
                  NetbiosDomainName,
                  DnsDomainName ));


        //
        // Initialize the entry.
        //

        RtlZeroMemory( NlDcDomainEntry, sizeof(NL_DC_DOMAIN_ENTRY) );

        // One for our reference.  One for being in global list.
        NlDcDomainEntry->ReferenceCount = 2;

        //
        // Link a newly allocated entry into the global list.

        InsertHeadList( &NlDcDomainList, &NlDcDomainEntry->Next );
        NlDcDomainCount ++;

        //
        // If we already have enough entries,
        //  delete the LRU one.
        //

        if ( NlDcDomainCount > NL_DC_MAX_DOMAINS ) {
            PNL_DC_DOMAIN_ENTRY TempNlDcDomainEntry =
                CONTAINING_RECORD( NlDcDomainList.Blink, NL_DC_DOMAIN_ENTRY, Next);

            if ( TempNlDcDomainEntry != NlDcDomainEntry ) {
                NlAssert( TempNlDcDomainEntry->ReferenceCount == 1 );
                NetpDcDeleteDomainEntry( TempNlDcDomainEntry );

                NlPrint(( NL_CRITICAL,
                          "NetpDcGreateDomainEntry: LRU'ed out a domain entry.\n" ));
            }
        }


        //
        // Set the domain information in the domain entry.
        //
        //
        // Since we allocated the entry, we can put the potentially bogus names
        // on it.  All entries need a name.  Then if no DCs are found,
        // this entry can act as a negative cache entry.
        //

        if ( !NetpDcUpdateDomainEntry( NlDcDomainEntry,
                                       DomainGuid,
                                       NetbiosDomainName,
                                       DnsDomainName ) ) {

            // Remove from the global linked list.
            NetpDcDeleteDomainEntry( NlDcDomainEntry );

            // Remove our reference.
            NetpDcDerefDomainEntry( NlDcDomainEntry );

            NlDcDomainEntry = NULL;

        }



    }

    LeaveCriticalSection(&NlDcCritSect);
    return NlDcDomainEntry;

}

ULONG
NetpDcGetPingWaitTime(
    IN PNL_GETDC_CONTEXT Context
    )
/*++

Routine Description:

    This routine determines the wait time for a ping response
    for a new DC that has not yet been pinged. The wait time
    depends on the total number of DCs which have already been
    pinged as follows:

    For the first 5 DCs (including this new one) the wait time is the maximum timeout per ping
    For the next  5 DCs (including this new one) the wait time is the median  timeout per ping
    For the rest of DCs (including this new one) the wait time is the minimum timeout per ping

    The rational behind this distribution is that we want to reduce the network
    traffic and reduce chances for network flooding (that is harmful for DCs)
    in case all DCs are slow to respond due to high load. Thus, the first 10 DCs
    have higher chances to be discovered before we impose greater network traffic
    by pinging the rest of DCs. If the first 10 DCs happen to be slow we have to
    reduce the wait timeout to a minimum as we want to cover a reasonable number
    of DCs in the time left.

Arguments:

    Context - Context describing the GetDc operation. The DcsPinged
        field should be equal to the current total number of DCs on
        the list to be pinged.

Return Value:

    Wait time in milliseconds

--*/
{
    //
    // If there are at most 4 DCs already pinged ...
    //

    if ( Context->DcsPinged < 5 ) {
        return NL_DC_MAX_PING_TIMEOUT;    // 0.4 sec

    //
    // If there are 5 or more but less than 10 DCs pinged ...
    //

    } else if ( Context->DcsPinged < 10 ) {
        return NL_DC_MED_PING_TIMEOUT;    // 0.2 sec

    //
    // If there are already 10 or more DCs pinged ...
    //

    } else {
        return NL_DC_MIN_PING_TIMEOUT;    // 0.1 sec
    }
}

NET_API_STATUS
NetpDcProcessAddressList(
    IN  PNL_GETDC_CONTEXT Context,
    IN  LPWSTR DnsHostName OPTIONAL,
    IN  PSOCKET_ADDRESS SockAddressList,
    IN  ULONG SockAddressCount,
    IN  BOOLEAN SiteSpecificAddress,
    OUT PNL_DC_ADDRESS *FirstAddressInserted OPTIONAL
    )
/*++

Routine Description:

    This routine adds IP addresses to the list of addresses to ping
        ensuring that all addresses are unique in the resulted list.

Arguments:

    Context - Context describing the GetDc operation.

    DnsHostName - Server name whose address list is being processed.

    SockAddressList - List of socket addresses.

    SockAddressCount - The number of socket addresses in SockAddressList.

    SiteSpecificAddress - If TRUE, indicates that the addresses were
        retrieved as a result of site specific DNS lookups.

    FirstAddressInserted - Returns a pointer to the first entry inserted
        into the returned list.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_ENOUGH_MEMORY - Not enough memory to complete the operation.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_DC_ADDRESS DcAddress = NULL;
    ULONG AddressIndex;
    PLIST_ENTRY ListEntry;
    WORD SavedPort;

    //
    // Initialization
    //

    if ( FirstAddressInserted != NULL ) {
        *FirstAddressInserted = NULL;
    }

    //
    // Loop through the socket address list keeping only the new ones
    //

    for ( AddressIndex = 0; AddressIndex < SockAddressCount; AddressIndex++ ) {

        //
        // Ignore addresses that are too big.
        //
        if ( SockAddressList[AddressIndex].iSockaddrLength >
             sizeof(DcAddress->SockAddrIn) ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcGetNameIp: %ws: bogus address length. %ld %ld\n",
                      Context->QueriedDisplayDomainName,
                      SockAddressList[AddressIndex].iSockaddrLength,
                      sizeof(DcAddress->SockAddrIn) ));
            continue;
        }

        //
        // Force the port number to be zero.
        //
        if ( SockAddressList[AddressIndex].lpSockaddr->sa_family == AF_INET ) {
            ((SOCKADDR_IN *)(SockAddressList[AddressIndex].lpSockaddr))->sin_port = 0;
        }

        //
        // If this address is already on the list,
        //  update the new address.
        //

        DcAddress = NULL ;
        for ( ListEntry = Context->DcAddressList.Flink ;
              ListEntry != &Context->DcAddressList ;
              ListEntry = ListEntry->Flink) {

            DcAddress = CONTAINING_RECORD( ListEntry, NL_DC_ADDRESS, Next );

            if ( SockAddressList[AddressIndex].iSockaddrLength ==
                 DcAddress->SockAddress.iSockaddrLength &&
                 RtlEqualMemory( SockAddressList[AddressIndex].lpSockaddr,
                                 DcAddress->SockAddress.lpSockaddr,
                                 DcAddress->SockAddress.iSockaddrLength ) ) {
                break;
            }

            DcAddress = NULL ;
        }

        //
        // Update the site specific bit
        //

        if ( DcAddress != NULL ) {
            if ( SiteSpecificAddress ) {
                DcAddress->AddressFlags |= NL_DC_ADDRESS_SITE_SPECIFIC;
            }
            continue;
        }

        //
        // Allocate structure describing the new address.
        //

        DcAddress = LocalAlloc( LMEM_ZEROINIT, sizeof(NL_DC_ADDRESS) );

        if ( DcAddress == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Fill it in and link it at the end of the list.
        //

        DcAddress->SockAddress.iSockaddrLength =
                       SockAddressList[AddressIndex].iSockaddrLength;
        DcAddress->SockAddress.lpSockaddr =
                       (LPSOCKADDR) &DcAddress->SockAddrIn;
        RtlCopyMemory( DcAddress->SockAddress.lpSockaddr,
                       SockAddressList[AddressIndex].lpSockaddr,
                       SockAddressList[AddressIndex].iSockaddrLength );

        if ( DnsHostName != NULL ) {
            DcAddress->DnsHostName = NetpAllocWStrFromWStr( DnsHostName );
            if ( DcAddress->DnsHostName == NULL ) {
                LocalFree( DcAddress );
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Convert the address to text.
        //
        // The DC only supports UDP on port 389.  So ignore the
        //  port number returned from DNS.
        //

        SavedPort = DcAddress->SockAddrIn.sin_port;
        DcAddress->SockAddrIn.sin_port = 0;

        NetStatus = NetpSockAddrToStr(
                DcAddress->SockAddress.lpSockaddr,
                DcAddress->SockAddress.iSockaddrLength,
                DcAddress->SockAddrString );

        if ( NetStatus != NO_ERROR ) {
            NlPrint(( NL_CRITICAL,
                  "NetpDcGetNameSiteIp: %ws: Cannot NetpSockAddrToStr. %ld\n",
                  Context->QueriedDisplayDomainName,
                  NetStatus ));
            if ( DcAddress->DnsHostName != NULL ) {
                NetApiBufferFree( DcAddress->DnsHostName );
            }
            LocalFree( DcAddress );
            return NetStatus;
        }

        DcAddress->SockAddrIn.sin_port = SavedPort;

        DcAddress->LdapHandle = NULL;
        DcAddress->AddressFlags = 0;
        if ( SiteSpecificAddress ) {
            DcAddress->AddressFlags |= NL_DC_ADDRESS_SITE_SPECIFIC;
        }

        DcAddress->AddressPingWait = NetpDcGetPingWaitTime( Context );

        InsertTailList( &Context->DcAddressList, &DcAddress->Next );
        Context->DcAddressCount++;

        if ( FirstAddressInserted != NULL && *FirstAddressInserted == NULL ) {
            *FirstAddressInserted = DcAddress;
        }
    }

    return NO_ERROR;
}

#ifndef WIN32_CHICAGO
NET_API_STATUS
I_DsGetDcCache(
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    OUT PBOOLEAN InNt4Domain,
    OUT LPDWORD InNt4DomainTime
    )
/*++

Routine Description:

    This routine finds a domain entry that matches the caller's query.

Arguments:

    NetbiosDomainName - Specifies the Netbios name of the domain to find.

    DnsDomainName - Specifies the Dns name of the domain to find.

        At least one of the above parameters should be non-NULL.

    InNt4Domain - Returns true if the domain is an NT 4.0 domain.

    InNt4DomainTime - Returns the GetTickCount time of when the domain was
        detected to be an NT 4.0 domain.

Return Value:

    NO_ERROR: Information is returned about the domain.

    ERROR_NO_SUCH_DOMAIN: cached information is not available for this domain.

--*/
{
    PNL_DC_DOMAIN_ENTRY NlDcDomainEntry;

    NlDcDomainEntry = NetpDcFindDomainEntry(
                             NULL,
                             NetbiosDomainName,
                             DnsDomainName,
                             NULL );

    if ( NlDcDomainEntry == NULL ) {
        return ERROR_NO_SUCH_DOMAIN;
    }

    *InNt4Domain = NlDcDomainEntry->InNt4Domain;
    *InNt4DomainTime = NlDcDomainEntry->InNt4DomainTime;

    NetpDcDerefDomainEntry( NlDcDomainEntry );

    return NO_ERROR;

}
#endif // WIN32_CHICAGO

NET_API_STATUS
NetpDcCheckSiteCovered(
    IN  PNL_GETDC_CONTEXT Context,
    IN  LPWSTR DnsDcName OPTIONAL,
    OUT PBOOLEAN DcClose
    )
/*++

Routine Description:

    This routine determines whether the site passed in the context
    structure is covered by the passed DC. It does so by looking up
    SRV records registered for the name type specified in the passed
    context and the specified site. If there is a record that belongs
    to the specified DC, the site is covered by the DC. If no DC is
    specified, the routine determines if the site is covered by any
    DC in the domain specified in the passed context.

Arguments:

    Context - Context describing the GetDc operation.

    DnsDcName - DNS DC name.

    DcClose - On success, indicates whether the DC is close or not.

Return Value:

    NO_ERROR: The NlDcCacheEntry was returned;

    ERROR_DNS_NOT_CONFIGURED: IP or DNS is not available on this computer.

    ERROR_INTERNAL_ERROR: Unhandled situation detected.

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory is available to process
        this request.

    Various Winsock errors.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    BOOLEAN IsClose = FALSE;
    HANDLE DsGetDcHandle = NULL;

    PSOCKET_ADDRESS SockAddressList = NULL;
    ULONG SockAddressCount = 0;

    LPSTR Utf8DnsDomainName = NULL;
    LPSTR Utf8DnsDcName = NULL;
    LPSTR DnsHostName = NULL;

    //
    // Check that the site name is availbale
    //

    if ( Context->QueriedSiteName == NULL ) {
        goto Cleanup;
    }

    //
    // Convert the DNS name to Utf8
    //

    Utf8DnsDomainName = NetpAllocUtf8StrFromWStr( Context->QueriedDnsDomainName );

    if ( Utf8DnsDomainName == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if ( DnsDcName != NULL ) {
        Utf8DnsDcName = NetpAllocUtf8StrFromWStr( DnsDcName );

        if ( Utf8DnsDcName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Get a context for the DNS name queries.
    //

    NetStatus = NetpDcGetDcOpen( Utf8DnsDomainName,
                             DS_ONLY_DO_SITE_NAME,  // Do site specific names only
                             Context->QueriedSiteName,
                             Context->QueriedDomainGuid,
                             // No need to pass the forest name since it's used only
                             //  for the "by guid" name which is not site specific
                             NULL,
                             // Force fresh DNS lookups
                             (Context->QueriedFlags | DS_FORCE_REDISCOVERY) & DS_OPEN_VALID_FLAGS,
                             &DsGetDcHandle );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Loop getting addresses to query.
    //

    for ( ;; ) {

        //
        // Free any memory from a previous iteration.
        //

        if ( SockAddressList != NULL ) {
            LocalFree( SockAddressList );
            SockAddressList = NULL;
        }

        //
        // Get the next set of IP addresses from DNS
        //

        NetStatus = NetpDcGetDcNext( DsGetDcHandle,
                                 &SockAddressCount,
                                 &SockAddressList,
                                 &DnsHostName );

        //
        // Process the exeptional conditions
        //

        if ( NetStatus == NO_ERROR && SockAddressCount > 0 ) {

            //
            // If the DC is passed, check if this is its record.
            //
            if ( Utf8DnsDcName == NULL ||
                 NlEqualDnsNameUtf8(Utf8DnsDcName, DnsHostName) ) {
                IsClose = TRUE;
                break;
            }

        //
        // If we're done, break out of the loop.
        //
        } else if ( NetStatus == ERROR_NO_MORE_ITEMS ) {

            break;

        //
        // If DNS isn't available, blow this request away.
        //
        } else if ( NetStatus == ERROR_TIMEOUT ||
                    NetStatus == DNS_ERROR_RCODE_SERVER_FAILURE ) { // Server failed
            break;

        //
        // If IP or DNS is not configured, tell the caller.
        //
        } else if ( NetStatus == DNS_ERROR_NO_TCPIP ||        // TCP/IP not configured
                    NetStatus == DNS_ERROR_NO_DNS_SERVERS ) { // DNS not configured

            NlPrint(( NL_CRITICAL,
                      "NetpDcCheckSiteCovered: %ws: IP Not configured from DnsQuery.\n",
                      Context->QueriedDisplayDomainName ));
            NetStatus = ERROR_DNS_NOT_CONFIGURED;
            goto Cleanup;

        //
        // We don't handle any other error.
        //
        } else {
            NlPrint(( NL_CRITICAL,
                      "NetpDcCheckSiteCovered: %ws: Unknown error from DnsQuery. %ld 0x%lx\n",
                      Context->QueriedDisplayDomainName,
                      NetStatus,
                      NetStatus ));
            goto Cleanup;
        }
    }

Cleanup:

    if ( SockAddressList != NULL) {
        LocalFree( SockAddressList );
    }

    if ( DsGetDcHandle != NULL ) {
        NetpDcGetDcClose( DsGetDcHandle );
    }

    if ( Utf8DnsDomainName != NULL ) {
        NetpMemoryFree( Utf8DnsDomainName );
    }

    if ( Utf8DnsDcName != NULL ) {
        NetpMemoryFree( Utf8DnsDcName );
    }

    if ( NetStatus == NO_ERROR ) {
        *DcClose = IsClose;
    }

    return NetStatus;
}

NET_API_STATUS
NetpDcHandlePingResponse(
    IN PNL_GETDC_CONTEXT Context,
    IN PVOID ResponseBuffer,
    IN ULONG ResponseSize,
    IN ULONG PassedCacheEntryFlags,
    IN PNL_DC_ADDRESS ResponseDcAddress OPTIONAL,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry,
    OUT PBOOL UsedNetbios
    )
/*++

Routine Description:

    The response is parsed and a cache entry is created for the response.
    The cache entry is returned to the caller.

Arguments:

    Context - Context describing the GetDc operation.

    ResponseBuffer - Specifies the message returned by the DC in question.

    ResponseSize - Specifies the size (in bytes) of the message

    ResponseDcAddress - If specified, gives the DC address of the DC that responded.
        This address will be used rather than the one in the ResponseBuffer.
        NULL indicates that Netbios was used to discover the DC.

    PassedCacheEntryFlags - Passes flags indicating over which mechanism
        the response was received: either mailslot or ldap.

    NlDcCacheEntry - On success, returns a pointer to the cache entry
        describing the found DC.  This entry must be dereferenced using
        NetpDcDerefCacheEntry.

    UsedNetbios - Returns TRUE if the netbios domain name was used to match
        the returned cache entry.

Return Value:

    NO_ERROR: The NlDcCacheEntry was returned;

    ERROR_SEM_TIMEOUT: (Silly, but for consistency) Specifies that the message
        doesn't match the criteria in Context

    ERROR_INVALID_DATA - The message could not be recognized as a valid
        response message.

    ERROR_NOT_ENOUGH_MEMORY - The message could not be allocated.

    ERROR_SERVICE_NOT_ACTIVE - The netlogon service is paused on the server.
        Returned only for server pings.

--*/
{
    NET_API_STATUS NetStatus;
    DWORD StartTime;

    DWORD ElapsedTime;
    DWORD LocalTimeout;
    PNL_DC_CACHE_ENTRY LocalNlDcCacheEntry = NULL;
    BOOL LocalUsedNetbios;
    PDNS_RECORD DnsRecords = NULL;

    LPBYTE Where;

    //
    // Initialization
    //

    *NlDcCacheEntry = NULL;


    //
    // Verbosity
    //

#if NETLOGONDBG
    NlPrint(( NL_MAILSLOT_TEXT,
              "%ws: Received '%s' response.\n",
              Context->QueriedDisplayDomainName,
              NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)ResponseBuffer)->Opcode)));

    NlpDumpBuffer(NL_MAILSLOT_TEXT, ResponseBuffer, ResponseSize);
#endif // NETLOGONDBG


    //
    // Parse the response
    //

    NetStatus = NetpDcParsePingResponse(
                    Context->QueriedDisplayDomainName,
                    ResponseBuffer,
                    ResponseSize,
                    &LocalNlDcCacheEntry );


    if ( NetStatus != NO_ERROR ) {
        NlPrint((NL_CRITICAL,
                "NetpDcHandlePingResponse: %ws: cannot NetpDcParsePingResponse: %ld\n",
                Context->QueriedDisplayDomainName,
                NetStatus ));
        goto Cleanup;
    }

    //
    // Set the passed cache entry flags
    //

    LocalNlDcCacheEntry->CacheEntryFlags |= PassedCacheEntryFlags;

    //
    // If our caller knows the DC's SockAddr,
    //  override the one that came back from the DC.
    //


    if ( ResponseDcAddress != NULL ) {


        LocalNlDcCacheEntry->SockAddr.iSockaddrLength = ResponseDcAddress->SockAddress.iSockaddrLength;
        LocalNlDcCacheEntry->SockAddr.lpSockaddr = (LPSOCKADDR)
            &LocalNlDcCacheEntry->SockAddrIn;

        RtlCopyMemory( LocalNlDcCacheEntry->SockAddr.lpSockaddr,
                       ResponseDcAddress->SockAddress.lpSockaddr,
                       ResponseDcAddress->SockAddress.iSockaddrLength );

    }

    //
    // If a NT5 DC didn't return the close bit, perhaps
    //  our statically configured site (if any) is covered
    //  by the DC.  Check it.  But do this check only if
    //  the discovered domain is in our forest to avoid
    //  site name collisions between different forests.
    //

#ifdef  _NETLOGON_SERVER
    if ( (LocalNlDcCacheEntry->ReturnFlags & DS_DS_FLAG) != 0 &&
         (LocalNlDcCacheEntry->ReturnFlags & DS_CLOSEST_FLAG) == 0 &&
         // site is configured on DC by definition
         (!NlGlobalMemberWorkstation || NlGlobalParameters.SiteNameConfigured) &&
         NlEqualDnsName(LocalNlDcCacheEntry->UnicodeDnsForestName, Context->QueriedDnsForestName) ) {

        BOOLEAN ClosenessDetermined = FALSE;

        //
        // If we are querying for our configured site,
        //  check whether DC's site is the queried site or
        //  whether we got this DC as the result of site specific query
        //
        if ( Context->QueriedInternalFlags & DS_SITENAME_DEFAULTED ) {

            //
            // If the DC site name is the same as ours, the DC is obviously close
            //
            if ( LocalNlDcCacheEntry->UnicodeDcSiteName != NULL &&
                 _wcsicmp(Context->QueriedSiteName, LocalNlDcCacheEntry->UnicodeDcSiteName) == 0 ) {

                NlPrint(( NL_MISC, "NetpDchandlePingResponse: %ws DC marked as close (same queried site)\n",
                          Context->QueriedDisplayDomainName ));
                LocalNlDcCacheEntry->ReturnFlags |= DS_CLOSEST_FLAG;
                ClosenessDetermined = TRUE;

            //
            // Otherwise, if this is actual DC discovery (not just a DC ping),
            //  we might already queried DNS for our site specific records:
            //  the address structure indicates that.
            //
            } else if ( (Context->QueriedInternalFlags & (DS_PING_DNS_HOST|DS_PING_NETBIOS_HOST)) == 0 &&
                        ResponseDcAddress != NULL ) {

                if ( (ResponseDcAddress->AddressFlags & NL_DC_ADDRESS_SITE_SPECIFIC) != 0 ) {
                    NlPrint(( NL_MISC, "NetpDchandlePingResponse: %ws DC marked as close (via address)\n",
                              Context->QueriedDisplayDomainName ));
                    LocalNlDcCacheEntry->ReturnFlags |= DS_CLOSEST_FLAG;
                }
                ClosenessDetermined = TRUE;
            }

        //
        // Otherwise, get our configured site from the global
        //  and check whether DC's site is our configured site
        //
        } else {
            EnterCriticalSection( &NlGlobalSiteCritSect );
            if ( NlGlobalUnicodeSiteName != NULL &&
                 LocalNlDcCacheEntry->UnicodeDcSiteName != NULL &&
                 _wcsicmp(NlGlobalUnicodeSiteName, LocalNlDcCacheEntry->UnicodeDcSiteName) == 0 ) {

                NlPrint(( NL_MISC, "NetpDchandlePingResponse: %ws DC marked as close (same global site)\n",
                          Context->QueriedDisplayDomainName ));
                LocalNlDcCacheEntry->ReturnFlags |= DS_CLOSEST_FLAG;
                ClosenessDetermined = TRUE;
            }
            LeaveCriticalSection( &NlGlobalSiteCritSect );
        }

        //
        // If we haven't detemined the closeness given the info we've got,
        //  we have to ask DNS
        //
        if ( !ClosenessDetermined ) {
            BOOLEAN DcClose = FALSE;

            NetStatus = NetpDcCheckSiteCovered( Context,
                                                LocalNlDcCacheEntry->UnicodeDnsHostName,
                                                &DcClose );
            //
            // Fail on hard error
            //
            if ( NetStatus == ERROR_NOT_ENOUGH_MEMORY ||
                 NetStatus == ERROR_INTERNAL_ERROR ) {
                goto Cleanup;
            }

            //
            // If the DC is a close to our static site, mark it as such
            //
            if ( NetStatus == NO_ERROR && DcClose ) {
                NlPrint(( NL_MISC, "NetpDchandlePingResponse: %ws DC marked as close (via DNS)\n",
                          Context->QueriedDisplayDomainName ));
                LocalNlDcCacheEntry->ReturnFlags |= DS_CLOSEST_FLAG;
            }
        }
    }

    //
    // Decide whether we want to re-attempt to find a close DC in 15 minutes.
    //

    if ( (LocalNlDcCacheEntry->ReturnFlags & DS_DS_FLAG) != 0 &&
         (LocalNlDcCacheEntry->ReturnFlags & DS_CLOSEST_FLAG) == 0 ) {

        //
        // Mark the cache to expire if any of the following is true:
        //
        //  The DC returned our site name. Apparently our IP address
        //   maps to a site in a forest of the discovered DC but all
        //   DCs covering that site are currently down.
        //
        //  There were site specific DNS records. It is possible that
        //   all DCs that registered those records are currently down
        //   but will come back up later. But do this case only if the
        //   domain is from our forest to avoid site name collisions
        //   between different forests.
        //
        //  Our site name is statically configured. It is possible
        //   that our site got configured before a DC was installed
        //   into that site, so re-try to discover that DC later.
        //   But do this case only if the domain is from our forest
        //   because there is no reason to assume that there is some
        //   correlation in configuration between different forests.
        //

        //
        // Check the first case separately (for performance reasons)
        //
        if ( LocalNlDcCacheEntry->UnicodeClientSiteName != NULL ) {
            LocalNlDcCacheEntry->CacheEntryFlags |= NL_DC_CACHE_NONCLOSE_EXPIRE;

        //
        // If the first case didn't happen, try the other two
        //
        } else {

            if ( ((Context->ContextFlags & NL_GETDC_SITE_SPECIFIC_DNS_AVAIL) != 0 ||
                  // site is configured on DC by definition
                  (!NlGlobalMemberWorkstation || NlGlobalParameters.SiteNameConfigured)) &&

                 NlEqualDnsName(LocalNlDcCacheEntry->UnicodeDnsForestName, Context->QueriedDnsForestName) ) {

                LocalNlDcCacheEntry->CacheEntryFlags |= NL_DC_CACHE_NONCLOSE_EXPIRE;
            }
        }
    }
#endif  // _NETLOGON_SERVER

    if ( LocalNlDcCacheEntry->SockAddrIn.sin_family == AF_INET ) {
        // Force the port number to be zero.
        LocalNlDcCacheEntry->SockAddrIn.sin_port = 0;
        LocalNlDcCacheEntry->DcQuality += 2;    // IP is a good quality
    }


    //
    // Ensure the opcode is expected.
    //  (Ignore responses from paused DCs, too.)
    //

    switch ( LocalNlDcCacheEntry->Opcode ) {
    case LOGON_SAM_USER_UNKNOWN:

        //
        // If we asked for a specific account,
        //   then this is a negative answer.
        //

        if ( Context->QueriedAccountName != NULL ) {
            NlPrint((NL_CRITICAL,
                   "NetpDcHandlePingResponse: %ws: %ws: response says specified account not found.\n",
                   Context->QueriedDisplayDomainName,
                   Context->QueriedAccountName ));
            Context->NoSuchUserResponse = TRUE;
            NetStatus = ERROR_NO_SUCH_USER;
            goto Cleanup;
        }

        /* DROP THROUGH */

    case LOGON_SAM_LOGON_RESPONSE:
    case LOGON_PRIMARY_RESPONSE:
        break;

    case LOGON_SAM_PAUSE_RESPONSE:

        NlPrint((NL_CRITICAL,
                "NetpDcHandlePingResponse: %ws: Netlogon is paused on the server. 0x%lx\n",
                Context->QueriedDisplayDomainName,
                LocalNlDcCacheEntry->Opcode ));

        //
        // If we are pinging a server and the netlogon service is paused
        //  on the server, tell the caller about this.
        //

        if ( Context->QueriedInternalFlags & (DS_PING_DNS_HOST|DS_PING_NETBIOS_HOST) ) {
            NetStatus = ERROR_SERVICE_NOT_ACTIVE;
            goto Cleanup;
        }

        NetStatus = ERROR_SEM_TIMEOUT;
        goto Cleanup;

    default:
        NlPrint((NL_CRITICAL,
                "NetpDcHandlePingResponse: %ws: response opcode not valid. 0x%lx\n",
                Context->QueriedDisplayDomainName,
                LocalNlDcCacheEntry->Opcode ));
        NetStatus = ERROR_INVALID_DATA;
        goto Cleanup;

    }

    //
    // If we got any response from a DC that doesn't support the DS,
    //  note that fact for later.
    //
    // Check more than just DS_DS_FLAG since this might be an NT 5 DC where the
    // DS simply isn't started yet or an AD/UNIX server
    //

    if ( (LocalNlDcCacheEntry->VersionFlags & (NETLOGON_NT_VERSION_5|
                                               NETLOGON_NT_VERSION_5EX|
                                               NETLOGON_NT_VERSION_5EX_WITH_IP)) == 0 ) {
        Context->NonDsResponse = TRUE;
    } else {
        Context->DsResponse = TRUE;
    }

    //
    // If we got any response from any DC,
    //  don't cache the fact that we couldn't find a DC.
    //  We may just be looking for the wrong type of DC.
    //

    Context->AvoidNegativeCache = TRUE;


    //
    // Ensure the response matches the original caller's requirements.
    //

    if ( !NetpDcMatchResponse( Context,
                               LocalNlDcCacheEntry,
                               TRUE,
                               &LocalUsedNetbios ) ) {
        NetStatus = ERROR_SEM_TIMEOUT;
        goto Cleanup;
    }

    //
    // If we are doing a DC discovery (not just pings) and
    //  this is not a local call and
    //  we are going to return the DNS DC name,
    //  ensure that it can be resolved in DNS
    //
    // Note that we don't need to do this for pings as the
    //  caller will make the right choice w.r.t. which
    //  name (DNS or Netbios) to pick up given all the needed
    //  info in the internal structure we return to the caller.
    //
    // Note that we only ensure that the name can be resolved in DNS,
    //  we don't ensure that the IP adresses DNS returnes contain the one
    //  we used to ping the DC.

    if ( (Context->QueriedInternalFlags & DS_DOING_DC_DISCOVERY) != 0 &&  // doing DC discovery
         (PassedCacheEntryFlags & NL_DC_CACHE_LOCAL) == 0 &&   // not a local call
         ((Context->QueriedFlags & DS_RETURN_DNS_NAME) != 0 || // caller requires DNS name
          // caller doesn't require Netbios name and DNS domain name matched the query
          ((Context->QueriedFlags & DS_RETURN_FLAT_NAME) == 0 && !LocalUsedNetbios)) ) {

        //
        // If the DC returned a DNS host name and
        //  we didn't yet resolve the DC name in DNS (i.e. we used Netbios) or
        //  we've got a DNS name that is different from the one the DC returned,
        //  resolve the DNS name the DC returned
        //
        if ( LocalNlDcCacheEntry->UnicodeDnsHostName != NULL &&  // we have a DNS name
             (ResponseDcAddress == NULL ||                       // name not yet resolved in DNS
              ResponseDcAddress->DnsHostName == NULL ||          // name not yet resolved in DNS
              !NlEqualDnsName(LocalNlDcCacheEntry->UnicodeDnsHostName, // already resolved but names are different
                              ResponseDcAddress->DnsHostName)) ) {

            NetStatus = DnsQuery_W( LocalNlDcCacheEntry->UnicodeDnsHostName,
                                    DNS_TYPE_A,
                                    (Context->QueriedFlags & DS_FORCE_REDISCOVERY) ?
                                       DNS_QUERY_BYPASS_CACHE : 0,
                                    NULL,   // No list of DNS servers
                                    &DnsRecords,
                                    NULL );

            if ( NetStatus != NO_ERROR || DnsRecords == NULL ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcHandlePingResponse: %ws: Failed DNS resolution for %ws (%ws): 0x%lx\n",
                          Context->QueriedDisplayDomainName,
                          LocalNlDcCacheEntry->UnicodeDnsHostName,
                          (ResponseDcAddress != NULL) ?
                            ResponseDcAddress->DnsHostName :
                            L"none",
                          NetStatus ));
                NetStatus = ERROR_SEM_TIMEOUT;
                goto Cleanup;
            } else {
                NlPrint(( NL_MISC,
                          "NetpDcHandlePingResponse: %ws: Successful DNS resolution for %ws (%ws)\n",
                          Context->QueriedDisplayDomainName,
                          LocalNlDcCacheEntry->UnicodeDnsHostName,
                          (ResponseDcAddress != NULL) ?
                            ResponseDcAddress->DnsHostName :
                            L"none" ));
            }
        }
    }

    //
    // Compute the quality of this cache entry
    //
    // Some qualities are more important than others
    //

    if (LocalNlDcCacheEntry->ReturnFlags & DS_DS_FLAG) {
        LocalNlDcCacheEntry->DcQuality += 1;
    }
    if (LocalNlDcCacheEntry->ReturnFlags & DS_GOOD_TIMESERV_FLAG) {
        LocalNlDcCacheEntry->DcQuality += 1;
    }
    if (LocalNlDcCacheEntry->ReturnFlags & DS_KDC_FLAG) {
        LocalNlDcCacheEntry->DcQuality += 5;
    }
    if (LocalNlDcCacheEntry->ReturnFlags & DS_TIMESERV_FLAG) {
        LocalNlDcCacheEntry->DcQuality += 5;
    }
    if (LocalNlDcCacheEntry->ReturnFlags & DS_CLOSEST_FLAG) {
        LocalNlDcCacheEntry->DcQuality += 10;
    }





    //
    // We found it!
    //
    // Return the cache entry to the caller.

    NetStatus = NO_ERROR;
    *NlDcCacheEntry = LocalNlDcCacheEntry;
    *UsedNetbios = LocalUsedNetbios;
    LocalNlDcCacheEntry = NULL;

Cleanup:
    if ( LocalNlDcCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( LocalNlDcCacheEntry );
    }
    if ( DnsRecords != NULL ) {
        DnsRecordListFree( DnsRecords, DnsFreeRecordListDeep );
    }

    return NetStatus;
}

NET_API_STATUS
NetpDcGetPingResponse(
    IN PNL_GETDC_CONTEXT Context,
    IN ULONG Timeout,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry,
    OUT PBOOL UsedNetbios
    )
/*++

Routine Description:

    This routine reads a ping response from the specified mailslot.
    The response is parsed and a cache entry is created for the response.
    The cache entry is returned to the caller.

Arguments:

    Context - Context describing the GetDc operation.

    Timeout - Maximum time (in milliseconds) to wait for the response.

    NlDcCacheEntry - On success, returns a pointer to the cache entry
        describing the found DC.  This entry must be dereference using
        NetpDcDerefCacheEntry.

    UsedNetbios - Returns TRUE if the netbios domain name was used to match
        the returned cache entry.

Return Value:

    NO_ERROR: The NlDcCacheEntry was returned;

    ERROR_SEM_TIMEOUT: No response was available within Timeout milliseconds

    ERROR_INVALID_DATA: We pinged a DC with a particular IP address and that DC
        returned responce info that was in conflict with the requested info.

    ERROR_SERVICE_NOT_ACTIVE - The netlogon service is paused on the pinged
        server.  Returned only for DC pings.

--*/
{
    NET_API_STATUS NetStatus;
    DWORD StartTime;
    DWORD ElapsedTime;
    DWORD BeginElapsedTime;
    DWORD LocalTimeout;
    LPBYTE Response;
    DWORD ResponseSize;
    PLIST_ENTRY ListEntry;
    PNL_DC_ADDRESS DcAddress;
    PNL_DC_ADDRESS UsedDcAddress;
    PNL_DC_ADDRESS ResponseDcAddress;
    int LdapError;
    LDAP_TIMEVAL LdapTimeout;
    PLDAPMessage LdapMessage = NULL;
    PLDAPMessage CurrentEntry;
    PLDAP_BERVAL *Berval = NULL;
    ULONG LocalCacheEntryFlags = 0;

    //
    // Initialization
    //

    *NlDcCacheEntry = NULL;
    StartTime = GetTickCount();

    //
    // Some timeouts are computed.
    //  Prevent timeouts from being ridiculously small.
    //  However, if this is DC pinging, allow 0 timeout
    //  for just checking if a response is available.
    //

    if ( Timeout < NL_DC_MIN_PING_TIMEOUT &&
         (Context->QueriedInternalFlags & (DS_PING_DNS_HOST|DS_PING_NETBIOS_HOST)) == 0 ) {
        Timeout = NL_DC_MIN_PING_TIMEOUT;
    }


    //
    // Loop ignoring bogus responses.
    //

    for (;;) {

        //
        // Flag that we don't yet have a response.
        //

        Response = NULL;
        ResponseDcAddress = NULL;
        BeginElapsedTime = NetpDcElapsedTime( StartTime );
        UsedDcAddress = NULL;

        //
        // Loop through the list of DCs we've started LDAP calls to.
        //

        for ( ListEntry = Context->DcAddressList.Flink ;
              ListEntry != &Context->DcAddressList ;
              ListEntry = ListEntry->Flink) {

            //
            // Cleanup from previous iteration.

            if ( Berval != NULL ) {
                ldap_value_free_len( Berval );
                Berval = NULL;
            }
            if ( LdapMessage != NULL ) {
                ldap_msgfree( LdapMessage );
                LdapMessage = NULL;
            }



            //
            // Skip this entry if no LDAP search has been started.
            //

            DcAddress = CONTAINING_RECORD( ListEntry, NL_DC_ADDRESS, Next );
            if ( DcAddress->LdapHandle == NULL ) {
                continue;   // Continue with the next host
            }


            //
            // Poll to see if a result is available for ANY of the searches
            //  I've done to this host.
            //

            LdapTimeout.tv_sec = 0;
            LdapTimeout.tv_usec = 0;

            LdapError = ldap_result(
                                DcAddress->LdapHandle,
                                LDAP_RES_ANY,
                                TRUE,   // Return all of search
                                &LdapTimeout,   // poll
                                &LdapMessage );

            //
            // If the request timed out, continue with the next host.
            // We get this timeout if the response hasn't yet come back from the DC
            //
            if ( LdapError == 0 ) {
                continue;   // Continue with the next host

            //
            // Otherwise, check error conditions
            //
            } else if ( LdapError == -1 ) {

#if NETLOGONDBG
                NlPrint(( NL_CRITICAL,
                      "NetpDcGetPingResponse: %ws: Cannot ldap_result ip address %s: %ld %s\n",
                      Context->QueriedDisplayDomainName,
                      DcAddress->SockAddrString,
                      DcAddress->LdapHandle->ld_errno,
                      ldap_err2stringA(DcAddress->LdapHandle->ld_errno) ));
#endif // NETLOGONDBG

                //
                // LDAP_TIMEOUT means the IP address exists but there is no LDAP server at that address.
                //  Don't ever try this machine again.
                //
                // All other status codes are unknown. Keep trying this machine since we don't know
                //  if this is a client side or server side failure.
                //
                if ( DcAddress->LdapHandle->ld_errno == LDAP_TIMEOUT ) {
                    if ( (DcAddress->AddressFlags & NL_DC_ADDRESS_NEVER_TRY_AGAIN) == 0 ) {
                        DcAddress->AddressFlags |= NL_DC_ADDRESS_NEVER_TRY_AGAIN;
                        Context->DcAddressCount--;
                    }
                }

                //
                // ldap_result returned the answer.  No need calling ldap_result again.
                //
                ldap_unbind( DcAddress->LdapHandle );
                DcAddress->LdapHandle = NULL;
                continue;   // Continue with the next host
            }

            //
            // Get the first entry returned. (There should only be one.)
            //
            CurrentEntry = ldap_first_entry( DcAddress->LdapHandle, LdapMessage );

            if ( CurrentEntry == NULL ) {

                //
                // This means the server doesn't support the NETLOGON attribute.
                //  That's probably because the netlogon service is stopped.
                //
                NlPrint(( NL_MAILSLOT_TEXT,
                          "NetpDcGetPingResponse: %ws: Netlogon service stopped on DC at %s\n",
                          Context->QueriedDisplayDomainName,
                          DcAddress->SockAddrString ));

                //
                // Don't ever try this machine again.
                //
                if ( (DcAddress->AddressFlags & NL_DC_ADDRESS_NEVER_TRY_AGAIN) == 0 ) {
                    DcAddress->AddressFlags |= NL_DC_ADDRESS_NEVER_TRY_AGAIN;
                    Context->DcAddressCount--;
                }

                //
                // ldap_result returned the answer.  No need calling ldap_result again.
                //
                ldap_unbind( DcAddress->LdapHandle );
                DcAddress->LdapHandle = NULL;
                continue;   // Continue with the next host
            }

            //
            // Get the Netlogon attribute returned.  (There should only be one.)
            //

            Berval = ldap_get_values_lenA( DcAddress->LdapHandle,
                                           CurrentEntry,
                                           NETLOGON_LDAP_ATTRIBUTE );

            if ( Berval == NULL ) {
                if ( DcAddress->LdapHandle->ld_errno != 0 ) {
#if NETLOGONDBG
                    NlPrint(( NL_CRITICAL,
                              "NetpDcGetPingResponse: %ws: Cannot ldap_get_values_len ip address %s: %ld %s\n",
                              Context->QueriedDisplayDomainName,
                              DcAddress->SockAddrString,
                              DcAddress->LdapHandle->ld_errno,
                              ldap_err2stringA(DcAddress->LdapHandle->ld_errno) ));
#endif // NETLOGONDBG
                    // ?? Some should be fatal
                    //
                    // If the DC returned that there isn't a NETLOGON attribute,
                    //  then it really isn't a DC.
                    if ( DcAddress->LdapHandle->ld_errno == LDAP_NO_SUCH_ATTRIBUTE ) {
                        if ( (DcAddress->AddressFlags & NL_DC_ADDRESS_NEVER_TRY_AGAIN) == 0 ) {
                            DcAddress->AddressFlags |= NL_DC_ADDRESS_NEVER_TRY_AGAIN;
                            Context->DcAddressCount--;
                        }
                    }
                }

                //
                // ldap_result returned the answer.  No need calling ldap_result again.
                //

                ldap_unbind( DcAddress->LdapHandle );
                DcAddress->LdapHandle = NULL;

                continue;   // Continue with the next host
            }

            if ( Berval[0] == NULL ) {
                //
                // ldap_result returned the answer.  No need calling ldap_result again.
                //

                ldap_unbind( DcAddress->LdapHandle );
                DcAddress->LdapHandle = NULL;

                continue;   // Continue with the next host
            }

            //
            // Check to see if we have SockAddress
            //
            if ( DcAddress->SockAddress.iSockaddrLength != 0 ) {
                ResponseDcAddress = DcAddress;
            }

            Response = Berval[0]->bv_val;
            ResponseSize = Berval[0]->bv_len;
            UsedDcAddress = DcAddress;
            LocalCacheEntryFlags = NL_DC_CACHE_LDAP;

            //
            // ldap_result returned the answer.  No need calling ldap_result again.
            //

            ldap_unbind( DcAddress->LdapHandle );
            DcAddress->LdapHandle = NULL;
            break;

        }

        //
        // If we don't yet have a response,
        //  try mailslots.

        if ( Response == NULL && Context->ResponseMailslotHandle != NULL ) {

            //
            // Set the mailslot read to return after the appropriate time.
            //  ?? This is now common code.  I could set it when I create the mailslot.
            //

            if ( !SetMailslotInfo(
                     Context->ResponseMailslotHandle,
                     0 ) ) {    // zero timeout

                NetStatus = GetLastError();

                NlPrint((NL_CRITICAL,
                    "NetpDcGetPingResponse: %ws: cannot change temp mailslot timeout %ld\n",
                    Context->QueriedDisplayDomainName,
                    NetStatus ));

                goto Cleanup;
            }



            //
            // Read the response from the response mailslot
            //

            if ( !ReadFile( Context->ResponseMailslotHandle,
                            Context->ResponseBuffer,
                            Context->ResponseBufferSize,
                            &ResponseSize,
                            NULL )
#ifdef WIN32_CHICAGO
                            || (ResponseSize == 0)
#endif // WIN32_CHICAGO

                            ) {

                NetStatus = GetLastError();

#ifdef WIN32_CHICAGO
                if ((NetStatus == NO_ERROR) && (ResponseSize == 0))
                {
                    NetStatus = ERROR_SEM_TIMEOUT;
                }
#endif // WIN32_CHICAGO
                if ( NetStatus != ERROR_SEM_TIMEOUT ) {
                    NlPrint((NL_CRITICAL,
                        "NetpDcGetPingResponse: %ws: cannot read temp mailslot timeout %ld\n",
                        Context->QueriedDisplayDomainName,
                        NetStatus ));
                    goto Cleanup;
                }
                /* Just drop through with no response */
            } else {
                Response = (LPBYTE) Context->ResponseBuffer;
                LocalCacheEntryFlags = NL_DC_CACHE_MAILSLOT;
            }
        }

        //
        // See if this response meets our needs
        //

        if ( Response != NULL ) {
            NetStatus = NetpDcHandlePingResponse(
                            Context,
                            Response,
                            ResponseSize,
                            LocalCacheEntryFlags,
                            ResponseDcAddress,
                            NlDcCacheEntry,
                            UsedNetbios );

            //
            // We are done if we have any response for a ping
            //

            if ( Context->QueriedInternalFlags &
                     (DS_PING_DNS_HOST | DS_PING_NETBIOS_HOST) ) {
                //
                // If the response conflicts with the request,
                //  tell that the caller
                //
                if ( NetStatus == ERROR_SEM_TIMEOUT ) {
                    NetStatus = ERROR_INVALID_DATA;
                }
                goto Cleanup;
            }

            //
            // For a DC discovery, take an appropriate action depending
            //  on the response we got from the DC
            //

            switch ( NetStatus ) {
            case ERROR_INVALID_DATA:    // Response is garbled
                break;  // Continue processing more responses
            case ERROR_SEM_TIMEOUT:     // Doesn't match the request
            case ERROR_NO_SUCH_USER:    // User doesn't exist on this DC
                if ( UsedDcAddress != NULL) {
                    NlPrint((NL_MAILSLOT_TEXT,
                        "NetpDcGetPingResponse: %ws: marked DC as NeverTryAgain %ld\n",
                        Context->QueriedDisplayDomainName,
                        NetStatus ));

                    if ( (UsedDcAddress->AddressFlags & NL_DC_ADDRESS_NEVER_TRY_AGAIN) == 0 ) {
                        UsedDcAddress->AddressFlags |= NL_DC_ADDRESS_NEVER_TRY_AGAIN;
                        Context->DcAddressCount--;
                    }
                }
                break;  // Continue processing more responses
            default:
                goto Cleanup;
            }

        }

        //
        // If we still have no response,
        //  sleep a while waiting for one.
        //
        //  (It's too bad I have to poll.  But there's no way to create a
        //  wait on any of the above to come back.  Perhaps, if there is exactly
        //  one object to wait on ...) ??
        //
        if ( Response == NULL ) {

            ElapsedTime = NetpDcElapsedTime( StartTime );

#ifndef NETTEST_UTILITY
            if ( ElapsedTime != BeginElapsedTime &&
                 ElapsedTime-BeginElapsedTime > 25 ) {
                NlPrint((NL_CRITICAL,
                    "NetpDcGetPingResponse: it took %ld msecs to poll\n",
                    ElapsedTime-BeginElapsedTime ));
            }
#endif // NETTEST_UTILITY

            if ( ElapsedTime >= Timeout) {
                NetStatus = ERROR_SEM_TIMEOUT;
                goto Cleanup;
            }

            LocalTimeout = Timeout - ElapsedTime;

#ifdef notdef
            NlPrint((NL_CRITICAL,
                "NetpDcGetPingResponse: timeout is %ld %ld %ld %ld\n",
                StartTime,
                ElapsedTime,
                Timeout,
                LocalTimeout ));
#endif // notdef

            //
            // Since I'm polling, don't wait too long.
            //

            Sleep( min( LocalTimeout, NL_DC_MIN_PING_TIMEOUT ) );
        }

    }
    /* NOT REACHED */

Cleanup:
    if ( Berval != NULL ) {
        ldap_value_free_len( Berval );
    }
    if ( LdapMessage != NULL ) {
        ldap_msgfree( LdapMessage );
    }

    return NetStatus;
}

VOID
NetpDcFreeAddressList(
    IN PNL_GETDC_CONTEXT Context
    )
/*++

Routine Description:

    This routine frees the address list associated with the current context.

Arguments:

    Context - Context describing the GetDc operation.

Return Value:

    None.

--*/
{
    PNL_DC_ADDRESS DcAddress;
    PLIST_ENTRY ListEntry;

    //
    // Loop deleting existing addresses.
    //
    while ( !IsListEmpty( &Context->DcAddressList ) ) {
        ListEntry = RemoveHeadList( &Context->DcAddressList );
        DcAddress = CONTAINING_RECORD( ListEntry, NL_DC_ADDRESS, Next );

        //
        // Free this DcAddress
        //
        if ( DcAddress->LdapHandle != NULL ) {
            ldap_unbind( DcAddress->LdapHandle );
        }
        if ( DcAddress->DnsHostName != NULL ) {
            NetApiBufferFree( DcAddress->DnsHostName );
        }
        LocalFree( DcAddress );
    }
    Context->DcAddressCount = 0;
}


NET_API_STATUS
NetpDcPingListIp(
    IN PNL_GETDC_CONTEXT Context,
    IN PNL_DC_ADDRESS FirstAddress OPTIONAL,
    IN BOOL WaitForResponce,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry OPTIONAL,
    OUT PBOOL UsedNetbios OPTIONAL,
    OUT PULONG DcPingCount
    )
/*++

Routine Description:

    This routine determines the name/address of a DC with the specified
    characteristics using an IP-only algorithm.

Arguments:

    Context - Context describing the GetDc operation.

    FirstAddress - If specified, this must be one of the entries in
        Context->DcAddressList.  Only this entry and entries following it in
        the list will be pinged.

    WaitForResponce - TRUE if need to wait for ping responces (by calling
        NetpDcGetPingResponse after each ping).  TRUE is used when this is
        synchronous DC discovery as with DsGetDcName.  If FALSE, the pings
        are sent asynchronously.

    NlDcCacheEntry - On success, returns a pointer to the cache entry
        describing the found DC.  This entry must be dereferenced using
        NetpDcDerefCacheEntry. Optional if WaitForResponce is FALSE.

    UsedNetbios - Returns TRUE if the netbios domain name was used to match
        the returned cache entry. Optional if WaitForResponce is FALSE.

    DcPingCount - Returns the number of DC's pinged.
        If WaitForResponce is TRUE, use DcPingCount only if the return status is
        ERROR_SEM_TIMEOUT.

Return Value:

    NO_ERROR: The NlDcCacheEntry was returned if WaitForResponce was TRUE.
        If WaitForResponce was FALSE, pings have been attempted to all addresses
        specified in Context->DcAddressList, but there is no guarantee that all
        the pings were successfully sent. The caller should check the value of
        DcPingCount to determine the number of successfully pinged DCs.

    ERROR_NO_SUCH_DOMAIN: The specified domain does not exist.
        (Definitive status that we need not try again.)

    ERROR_SEM_TIMEOUT: No DC responded to the request.
        (Non-definitive status that we should try again.)

    ERROR_INTERNAL_ERROR: Unhandled situation detected.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    ULONG AddressIndex;
    PLIST_ENTRY ListEntry;
    PNL_DC_ADDRESS DcAddress;
    char *AttributeList[2];
    int LdapMessageId;

    NlAssert( NlDcCacheEntry != NULL ||
              (NlDcCacheEntry == NULL && !WaitForResponce) );

    NlAssert( UsedNetbios != NULL ||
              (UsedNetbios == NULL && !WaitForResponce) );

    //
    // Loop through the list pinging each entry.
    //

    *DcPingCount = 0;
    if ( FirstAddress == NULL ) {
        ListEntry = Context->DcAddressList.Flink;
    } else {
        ListEntry = &FirstAddress->Next;
    }

    for ( ;
          ListEntry != &Context->DcAddressList ;
          ListEntry = ListEntry->Flink) {

        DcAddress = CONTAINING_RECORD( ListEntry, NL_DC_ADDRESS, Next );

        //
        // If we're certain this DC won't work,
        //  skip it.
        //

        if ( DcAddress->AddressFlags & NL_DC_ADDRESS_NEVER_TRY_AGAIN ) {
            continue;
        }

        //
        // Send the ping.
        //
        //
        // Open a connection to the server unless we already have one
        //

        if ( DcAddress->LdapHandle == NULL ) {

            //
            // Get an LDAP handle to the server.
            //
            DcAddress->LdapHandle = cldap_openA( DcAddress->SockAddrString, 0 );

            if ( DcAddress->LdapHandle == NULL ) {

                NetStatus = GetLastError();

                NlPrint(( NL_CRITICAL,
                          "NetpDcPingListIp: %ws: Cannot LdapOpen ip address %s: %ld\n",
                          Context->QueriedDisplayDomainName,
                          DcAddress->SockAddrString,
                          NetStatus ));
                // Some statuses should be fatal ??
                continue;
            }
        }

        //
        // Ping the server using UDP LDAP.
        //
        //  Get the Netlogon parameters of the server.
        //

        NlPrint(( NL_MAILSLOT,
                  "NetpDcPingListIp: %ws: Sent UDP ping to %s\n",
                  Context->QueriedDisplayDomainName,
                  DcAddress->SockAddrString ));

        AttributeList[0] = NETLOGON_LDAP_ATTRIBUTE;
        AttributeList[1] = NULL;
        LdapMessageId = ldap_searchA(
                            DcAddress->LdapHandle,
                            NULL,       // DN
                            LDAP_SCOPE_BASE,
                            Context->LdapFilter,
                            AttributeList,
                            FALSE );      // Attributes and values

        if ( LdapMessageId == -1 ) {

            NlPrint(( NL_CRITICAL,
                      "NetpDcPingListIp: %ws: Cannot LdapOpen ip address %s: %ld %s\n",
                      Context->QueriedDisplayDomainName,
                      DcAddress->SockAddrString,
                      DcAddress->LdapHandle->ld_errno,
                      ldap_err2stringA(DcAddress->LdapHandle->ld_errno) ));

            // Some statuses should be fatal ??
            continue;
        }

        //
        // Count the number of DCs we've pinged.
        //

        (*DcPingCount) ++;


        if ( WaitForResponce ) {

            //
            // Get the response from the ping.
            //
            NlAssert( DcAddress->AddressPingWait != 0 );
            NetStatus = NetpDcGetPingResponse(
                            Context,
                            DcAddress->AddressPingWait,
                            NlDcCacheEntry,
                            UsedNetbios );

            if ( NetStatus != ERROR_SEM_TIMEOUT ) {
                if ( NetStatus != NO_ERROR ) {
                    NlPrint(( NL_CRITICAL,
                             "NetpDcPingListIp: %ws: Cannot NetpDcGetPingResponse. %ld\n",
                             Context->QueriedDisplayDomainName,
                             NetStatus ));
                }
                goto Cleanup;
            }
        }

    }


    if ( WaitForResponce ) {
        NetStatus = ERROR_SEM_TIMEOUT;
    } else {
        NetStatus = NO_ERROR;
    }

Cleanup:
    return NetStatus;
}


NET_API_STATUS
NetpDcPingIp(
    IN PNL_GETDC_CONTEXT Context,
    OUT PULONG DcPingCount
    )
/*++

Routine Description:

    This routine sends a ping to a DC with the specified
    characteristics using an IP-only algorithm.

Arguments:

    Context - Context describing the GetDc operation.

    DcPingCount - Returns the number of DC's pinged.

Return Value:

    NO_ERROR:  Pings have been attempted to all addresses
        specified in Context->DcAddressList, but there is no guarantee that all
        the pings were successfully sent. The caller should check the value of
        DcPingCount to determine the number of successfully pinged DCs.

    ERROR_NO_SUCH_DOMAIN: The specified domain does not exist.
        (Definitive status that we need not try again.)

    ERROR_SEM_TIMEOUT: No DC responded to the request.
        (Non-definitive status that we should try again.)

    ERROR_INTERNAL_ERROR: Unhandled situation detected.

--*/
{
    return NetpDcPingListIp( Context,
                             NULL,
                             FALSE,
                             NULL,
                             NULL,
                             DcPingCount );
}


NET_API_STATUS
NetpDcGetDcOpen(
    IN LPCSTR DnsName,
    IN ULONG OptionFlags,
    IN LPCWSTR SiteName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR DnsForestName OPTIONAL,
    IN ULONG Flags,
    OUT PHANDLE RetGetDcContext
    )
/*++

Routine Description:

    Open a context for retrieval of the addresses of machines that have
    registered LDAP.TCP.<xxx> SRV records.

Arguments:

    DnsName - UTF-8 DNS name of the LDAP server to lookup

    OptionFlags - Flags affecting the operation of the routine.

        DS_ONLY_DO_SITE_NAME - Non-site names should be ignored.

    SiteName - Name of site the client is in.

    DomainGuid -  Specifies the GUID of the domain specified by DnsName.
        This value is used to handle the case of domain renames.  If this
        value is specified and DomainName has been renamed, DsGetDcName will
        attempt to locate a DC in the domain having this specified DomainGuid.

    DnsForestName - Specifies the name of the domain at the root of the tree
        containing DnsName.  This value is used in conjunction with DomainGuid
        for finding DnsName if the domain has been renamed.

    Flags - Passes additional information to be used to process the request.
        Flags can be a combination values bitwise or'ed together.

        Any of the following flags are allowed and have the same meaning as
        for DsGetDcName:

        DS_PDC_REQUIRED
        DS_GC_SERVER_REQUIRED
        DS_WRITABLE_REQUIRED
        DS_FORCE_REDISCOVERY - Avoids DNS cache

        If no flags are specified, no special DC role is required.

    RetGetDcContext - Returns an opaque context.
        This context must be freed using NetpDcGetDcClose.

Return Value:

    Status of the operation.

    NO_ERROR: GetDcContext was returned successfully.

--*/

{
    NET_API_STATUS NetStatus = NO_ERROR;
    PDSGETDC_CONTEXT GetDcContext = NULL;
    ULONG Size;

    //
    // Verify the DC flags
    //

    if ( Flags & ~DS_OPEN_VALID_FLAGS ) {
        NetStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }

    //
    // Verify the option flags
    //

    if ( OptionFlags & ~DS_OPEN_VALID_OPTION_FLAGS ) {
        NetStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }

    //
    // Allocate a context
    //

    GetDcContext = LocalAlloc( LMEM_ZEROINIT, sizeof(DSGETDC_CONTEXT) );

    if ( GetDcContext == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // If the name has a well known prefix,
    //  strip off the prefix and convert it to a flag bit.
    //
    // An LDAP client gets a name of this from in a GC referral.  By converting
    //  that name to this form, I will find a site specific GC.
    //

    if ( Flags == 0 ) {
        if ( _strnicmp( DnsName, NL_DNS_GC, sizeof(NL_DNS_GC)-1) == 0 ) {
            DnsName += sizeof(NL_DNS_GC)-1;
            Flags |= DS_GC_SERVER_REQUIRED;
        } else if ( _strnicmp( DnsName, NL_DNS_PDC, sizeof(NL_DNS_PDC)-1) == 0 ) {
            DnsName += sizeof(NL_DNS_PDC)-1;
            Flags |= DS_PDC_REQUIRED;
        }
    }

    //
    // Fill in the DNS name
    //

    Size = (strlen(DnsName) + 1) * sizeof(char);
    GetDcContext->QueriedDnsName = LocalAlloc( 0, Size );
    if ( GetDcContext->QueriedDnsName == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    RtlCopyMemory( GetDcContext->QueriedDnsName, DnsName, Size );

    //
    // Fill in the forest name if specified
    //

    if ( ARGUMENT_PRESENT(DnsForestName) ) {
        Size = (strlen(DnsForestName) + 1) * sizeof(char);
        GetDcContext->QueriedDnsForestName = LocalAlloc( 0, Size );
        if ( GetDcContext->QueriedDnsForestName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        RtlCopyMemory( GetDcContext->QueriedDnsForestName, DnsForestName, Size );
    }

    //
    // Fill in the site name if specified
    //

    if ( ARGUMENT_PRESENT(SiteName) ) {
        Size = (wcslen(SiteName) + 1) * sizeof(WCHAR);
        GetDcContext->QueriedSiteName = LocalAlloc( 0, Size );
        if ( GetDcContext->QueriedSiteName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        RtlCopyMemory( GetDcContext->QueriedSiteName, SiteName, Size );
    }

    //
    // Fill in flags
    //

    GetDcContext->QueriedInternalFlags = OptionFlags;

    //
    // Fill in domain GUID if specified
    //

    if ( ARGUMENT_PRESENT( DomainGuid ) ) {
        GetDcContext->QueriedDomainGuid = *DomainGuid;
    }

    //
    // Compute the initial DNS name type to query.
    //

    GetDcContext->FirstTime = TRUE;
    GetDcContext->QueriedFlags = Flags;

    NetStatus = NetpDcFlagsToNameType( Flags, &GetDcContext->NlDnsNameType );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // If a site name was specified by the caller,
    //  and this name type supports a type specific query,
    //  start with the type specific query.
    //

    if ( GetDcContext->QueriedSiteName != NULL ) {
        if ( NlDcDnsNameTypeDesc[GetDcContext->NlDnsNameType].SiteSpecificDnsNameType != NlDnsInvalid ) {
            GetDcContext->NlDnsNameType = NlDcDnsNameTypeDesc[GetDcContext->NlDnsNameType].SiteSpecificDnsNameType;
        }
    }



    //
    // Return the context to the caller.
    //

    *RetGetDcContext = GetDcContext;
    NetStatus = NO_ERROR;

    //
    // Cleanup
    //
Cleanup:
    if ( NetStatus != NO_ERROR ) {
        if ( GetDcContext != NULL ) {
            NetpDcGetDcClose( GetDcContext );
        }
    }
    return NetStatus;
}


NET_API_STATUS
NetpDcGetDcNext(
    IN HANDLE GetDcContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPSTR *DnsHostName OPTIONAL
    )
/*++

Routine Description:

    Returns the next logical SRV record for the name opened by NetpDcGetDcOpen.
    The returned record takes into account the weights and priorities specified
    in the SRV records.

Arguments:

    GetDcContextHandle - An opaque context describing the SRV records.

    SockAddressCount - Returns the number of Addresses in SockAddresses.
        If NULL, addresses will not be looked up.

    SockAddresses - Returns an array SOCKET_ADDRESS structures for the server.
        All returned addresses will be of family AF_INET or AF_INET6.
        The returned sin_port field contains port from the SRV record.
            A Port of 0 indicate no port is available from DNS.
        This buffer should be freed using LocalFree().

    DnsHostName - Returns a pointer to the DnsHostName in the SRV record.
        A NULL is returned if no host name is known.
        This buffer need not be freed. The buffer is valid until the call to
            NetpDcGetDcClose or the next call to NetpDcGetDcNext.

Return Value:

    NO_ERROR: Addresses were returned

    ERROR_NO_MORE_ITEMS: No more addresses are available.

    ERROR_FILEMARK_DETECTED: Caller has specified the DS_NOTIFY_AFTER_SITE_RECORDS flag
        and NetpDcGetDcNext has processed all of the site specific SRV records.  The caller
        should take any action based on no site specific DCs being available, then
        should call NetpDcGetDcNext to continue on to other DCs.

    Any other errors returned are those detected while trying to find the A
        records associated with the host of the SRV record.  The caller can
        note the error (perhaps so the caller can return this status to
        his caller if no usefull server is found) then call NetpDcGetDcNext
        again to get the next SRV record.  The caller can inspect this error
        and return immediately if the caller deems the error serious.

    The following interesting errors might be returned:

    DNS_ERROR_RCODE_NAME_ERROR: No A records are available for this SRV record.

    ERROR_TIMEOUT: DNS server didn't respond in a reasonable time


--*/
{
    NET_API_STATUS NetStatus;

    PDSGETDC_CONTEXT GetDcContext = (PDSGETDC_CONTEXT) GetDcContextHandle;
    PDNS_RECORD *DnsArray;
    PDNS_RECORD SrvDnsRecord;
    PDNS_RECORD DnsARecords = NULL;
    CHAR DnsName[NL_MAX_DNS_LENGTH+1];
    BOOLEAN NotifySiteChange = FALSE;

    GUID *CurrentGuid;
    LPCSTR CurrentDnsRecordName;

    ULONG Index;

    //
    // Loop trying the various DNS record names.
    //

    for (;;) {

        //
        // If we aren't still processing a set of SRV records from the previous call,
        //  move on to the next name.
        //

        if ( GetDcContext->SrvContextHandle == NULL ) {

            CurrentDnsRecordName = GetDcContext->QueriedDnsName;

            //
            // If this isn't the first call,
            //  compute the next DNS name to query.
            //

            if ( !GetDcContext->FirstTime ) {

                //
                // If we just completed the site specific records,
                //  and we've been asked to tell the caller when that's done,
                //  remember to tell the caller.
                //
                // Don't actually notify the caller until right before we're going to hit
                //  the wire.
                //

                if ( NlDcDnsNameTypeDesc[GetDcContext->NlDnsNameType].IsSiteSpecific &&
                     (GetDcContext->QueriedInternalFlags & DS_NOTIFY_AFTER_SITE_RECORDS) != 0 ) {

                    NotifySiteChange = TRUE;
                }


                //
                // Compute the next name type to query.
                //

                GetDcContext->NlDnsNameType = NlDcDnsNameTypeDesc[GetDcContext->NlDnsNameType].NextDnsNameType;

                if ( GetDcContext->NlDnsNameType == NlDnsInvalid ) {
                    //
                    // No more names to process.
                    //
                    NetStatus = ERROR_NO_MORE_ITEMS;
                    goto Cleanup;
                }

                //
                // If the current name type is not a site specific name type,
                //  and we've been asked to do only site specific names.
                //  we're done.
                //

                if ( !NlDcDnsNameTypeDesc[GetDcContext->NlDnsNameType].IsSiteSpecific &&
                     (GetDcContext->QueriedInternalFlags & DS_ONLY_DO_SITE_NAME) != 0 ) {

                    NetStatus = ERROR_NO_MORE_ITEMS;
                    goto Cleanup;
                }


                //
                // If this is the "by guid" name but we don't have a guid or forest name,
                //  go to the next name.
                //
                if ( NlDnsDcGuid( GetDcContext->NlDnsNameType ) ) {

                    //
                    // If no domain GUID was specified,
                    //  go to the next name.
                    //

                    if  ( IsEqualGUID( &GetDcContext->QueriedDomainGuid, &NlDcZeroGuid) ) {
                        continue;
                    }

                    //
                    // Otherwise try to find the domain by GUID
                    //  This name is registered at the tree name.
                    //

                    if ( GetDcContext->QueriedDnsForestName == NULL ) {
                        continue;
                    }

                    CurrentDnsRecordName = GetDcContext->QueriedDnsForestName;

                }

            }
            GetDcContext->FirstTime = FALSE;

            //
            // If we are to notify the caller when we're done with the site specific records,
            //  do so now.
            //

            if ( NotifySiteChange ) {

                //
                // We've already decided what SRV records to look up next.
                //  Flag that we've done so.
                //
                GetDcContext->FirstTime = TRUE;

                NetStatus = ERROR_FILEMARK_DETECTED;
                goto Cleanup;
            }

            //
            // Build the DNS name to query.
            //

            NetStatus = NetpDcBuildDnsName(
                                GetDcContext->NlDnsNameType,
                                &GetDcContext->QueriedDomainGuid,
                                GetDcContext->QueriedSiteName,
                                CurrentDnsRecordName,
                                DnsName );

            if ( NetStatus != NO_ERROR ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetDcNext: %s: %ld: Cannot NetpDcBuildDnsName. %ld\n",
                          CurrentDnsRecordName,
                          GetDcContext->NlDnsNameType,
                          NetStatus ));
                goto Cleanup;
            }


            //
            // Get the SRV records from DNS.
            //

            NetStatus = NetpSrvOpen( DnsName,
                                     (GetDcContext->QueriedFlags & DS_FORCE_REDISCOVERY) != 0 ?
                                        DNS_QUERY_BYPASS_CACHE :
                                        0,
                                     &GetDcContext->SrvContextHandle );

            if ( NetStatus != NO_ERROR ) {

                //
                // If the specified record cannot be found in DNS,
                //  try the next name type.
                //
                if ( NlDcNoDnsRecord( NetStatus ) ) {
                    continue;
                }

                NlPrint(( NL_CRITICAL,
                          "NetpDcGetDcNext: %s: Cannot Query DNS. %ld 0x%lx\n",
                          DnsName,
                          NetStatus,
                          NetStatus ));

                goto Cleanup;
            }


        }

        //
        // If we've got more SRV records to process for this DnsName,
        //  get the next SRV record.
        //

        NetStatus = NetpSrvNext( GetDcContext->SrvContextHandle,
                                 SockAddressCount,
                                 SockAddresses,
                                 DnsHostName );

        if ( NetStatus == NO_ERROR ) {
            goto Cleanup;

        //
        // If we're done with this set of SRV records mark so for next time.
        //
        } else if ( NetStatus == ERROR_NO_MORE_ITEMS ) {
            NetpSrvClose( GetDcContext->SrvContextHandle );
            GetDcContext->SrvContextHandle = NULL;

            continue;

        //
        // All other statuses are simply returned to our caller.
        //

        } else {
            NlPrint(( NL_CRITICAL,
                      "NetpDcGetDcNext: %s: %ld: Cannot NetpSrvNext. %ld 0x%lx\n",
                      GetDcContext->QueriedDnsName,
                      GetDcContext->NlDnsNameType,
                      NetStatus,
                      NetStatus ));
            goto Cleanup;
        }


    }


    ASSERT( FALSE );

Cleanup:
    if ( NlDcNoDnsRecord( NetStatus ) ) {
        NetStatus = DNS_ERROR_RCODE_NAME_ERROR;
    }
    return NetStatus;

}

VOID
NetpDcGetDcClose(
    IN HANDLE GetDcContextHandle
    )
/*++

Routine Description:

    Free the context allocated by NetpDcGetDcOpen

Arguments:

    GetDcContextHandle - An opaque context describing the SRV records.

Return Value:

    Status of the operation.

    NO_ERROR: GetDcContext was returned successfully.

--*/

{
    PDSGETDC_CONTEXT GetDcContext = (PDSGETDC_CONTEXT) GetDcContextHandle;

    if ( GetDcContext != NULL ) {

        //
        // Free allocated names
        //

        if ( GetDcContext->QueriedDnsName != NULL ) {
            LocalFree( GetDcContext->QueriedDnsName );
        }

        if ( GetDcContext->QueriedSiteName != NULL ) {
            LocalFree( GetDcContext->QueriedSiteName );
        }

        if ( GetDcContext->QueriedDnsForestName != NULL ) {
            LocalFree( GetDcContext->QueriedDnsForestName );
        }

        //
        // Free the SRV context
        //

        if ( GetDcContext->SrvContextHandle != NULL ) {
            NetpSrvClose( GetDcContext->SrvContextHandle );
        }

        //
        // Free the context itself
        //
        LocalFree( GetDcContext );
    }
}

NET_API_STATUS
NetpDcGetNameSiteIp(
    IN PNL_GETDC_CONTEXT Context,
    IN ULONG InternalFlags,
    IN LPCWSTR SiteName OPTIONAL,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry,
    OUT PBOOL UsedNetbios
    )
/*++

Routine Description:

    This routine determines the name/address of a DC with the specified
    characteristics using an IP-only algorithm.

Arguments:

    Context - Context describing the GetDc operation.

    InternalFlags - Flags affecting the operation of the routine.

        DS_ONLY_DO_SITE_NAME - Non-site names should be ignored.

    SiteName - Specifies the name of the site the returned DC should be
        "close" to.  The parameter should typically be the site name of the
        site the client is in.  If not specified, the site name defaults to
        the site of ComputerName.

    NlDcCacheEntry - On success, returns a pointer to the cache entry
        describing the found DC.
        This entry must be dereferenced using NetpDcDerefCacheEntry.

    UsedNetbios - Returns TRUE if the netbios domain name was used to match
        the returned cache entry.

Return Value:

    NO_ERROR: The NlDcCacheEntry was returned;

    ERROR_NO_SUCH_DOMAIN: The specified domain does not exist.
        (Definitive status that we need not try again.)

    ERROR_SEM_TIMEOUT: No DC responded to the request.
        (Non-definitive status that we should try again.)

    ERROR_DNS_NOT_CONFIGURED: IP or DNS is not available on this computer.

    ERROR_INTERNAL_ERROR: Unhandled situation detected.

    ERROR_INVALID_DOMAINNAME: Domain's name is too long. Additional labels
        cannot be concatenated.

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory is available to process
        this request.

    Various Winsock errors.

--*/
{
    NET_API_STATUS NetStatus;

    HANDLE DsGetDcHandle = NULL;

    PSOCKET_ADDRESS SockAddressList = NULL;
    ULONG SockAddressCount;

    PNL_DC_ADDRESS FirstDcToQuery;
    PNL_DC_ADDRESS DcAddress;
    ULONG DcPingCount = 0;
    ULONG LocalMaxLdapServersPinged = 0xffffffff;

    BOOLEAN SiteSpecificRecords = FALSE;
    BOOLEAN DnsRecordFound = FALSE;

    LPSTR Utf8DnsDomainName = NULL;
    LPSTR Utf8DnsForestName = NULL;
    LPSTR Utf8DnsHostName = NULL;
    LPWSTR UnicodeDnsHostName = NULL;

     //
     // Ping the list of DCs found on the previous call.
     //

     NetStatus = NetpDcPingListIp(
                     Context,
                     NULL,
                     TRUE,           // Wait for ping responce
                     NlDcCacheEntry,
                     UsedNetbios,
                     &DcPingCount );

     if ( NetStatus != ERROR_SEM_TIMEOUT ) {
         if ( NetStatus != NO_ERROR ) {
             NlPrint(( NL_CRITICAL,
                       "NetpDcGetNameIp: %ws: Cannot NetpDcPingListIp. %ld\n",
                       Context->QueriedDisplayDomainName,
                       NetStatus ));
         }
         goto Cleanup;
     }


    //
    // Convert the DNS name to Utf8
    //

    Utf8DnsDomainName = NetpAllocUtf8StrFromWStr( Context->QueriedDnsDomainName );

    if ( Utf8DnsDomainName == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if ( Context->QueriedDnsForestName != NULL ) {
        Utf8DnsForestName = NetpAllocUtf8StrFromWStr( Context->QueriedDnsForestName );

        if ( Utf8DnsForestName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Determine if we are doing site specific discovery
    //

    if ( SiteName != NULL &&
         NlDcDnsNameTypeDesc[Context->QueriedNlDnsNameType].SiteSpecificDnsNameType != NlDnsInvalid ) {
        SiteSpecificRecords = TRUE;
    }

    //
    // Get a context for the DNS name queries.
    //

    NetStatus = NetpDcGetDcOpen( Utf8DnsDomainName,
                             DS_NOTIFY_AFTER_SITE_RECORDS | InternalFlags,
                             SiteName,
                             Context->QueriedDomainGuid,
                             Utf8DnsForestName,
                             Context->QueriedFlags & DS_OPEN_VALID_FLAGS,
                             &DsGetDcHandle );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Determine the maximum number of DCs we can ping
    //

#ifdef _NETLOGON_SERVER

    //
    // In netlogon, the value is kept in global parameters
    //

    LocalMaxLdapServersPinged = NlGlobalParameters.MaxLdapServersPinged;

#else

    //
    // If we are not running in netlogon, we need to read
    //  the value directly from the registry
    //

    if ( !NlReadDwordNetlogonRegValue("MaxLdapServersPinged",
                                      &LocalMaxLdapServersPinged) ) {
        //
        // If it's not set in registry, use the default
        //
        LocalMaxLdapServersPinged = DEFAULT_MAXLDAPSERVERSPINGED;
    } else {

        //
        // Ensure that the value set in registry is in the valid range
        //
        if ( LocalMaxLdapServersPinged < MIN_MAXLDAPSERVERSPINGED ||
             LocalMaxLdapServersPinged > MAX_MAXLDAPSERVERSPINGED ) {
            LocalMaxLdapServersPinged = DEFAULT_MAXLDAPSERVERSPINGED;
        }
    }

#endif // _NETLOGON_SERVER


    //
    // Loop getting addresses to query.
    //

    for ( ;; ) {

        //
        // Free any memory from a previous iteration.
        //

        FirstDcToQuery = NULL;
        if ( SockAddressList != NULL ) {
            LocalFree( SockAddressList );
            SockAddressList = NULL;
        }

        //
        // Get the next set of IP addresses from DNS
        //

        NetStatus = NetpDcGetDcNext( DsGetDcHandle,
                                 &SockAddressCount,
                                 &SockAddressList,
                                 &Utf8DnsHostName );



        //
        // Process the exeptional conditions
        //

        if ( NetStatus == NO_ERROR ) {

            //
            // Since a SRV record was found, the only reason to not find the DC is if
            //  the DC is down.  That isn't a permanent condition.
            //
            Context->AvoidPermanentNegativeCache = TRUE;

            //
            // Indicate that DNS is up and running.
            //
            Context->ResponseFromDnsServer = TRUE;

            //
            // Indicate whether site specific records are available
            //
            if ( SiteSpecificRecords ) {
                Context->ContextFlags |= NL_GETDC_SITE_SPECIFIC_DNS_AVAIL;
            }
            /* Drop out */

        //
        // If the A record cannot be found for the SRV record in DNS,
        //  try the other name type.
        //
        } else if ( NetStatus == DNS_ERROR_RCODE_NAME_ERROR) {
            //
            // Since a SRV record was found, the only reason to not find the DC is if
            //  the DC is down.  That isn't a permanent condition.
            //
            Context->AvoidPermanentNegativeCache = TRUE;

            //
            // Indicate that DNS is up and running.
            //
            Context->ResponseFromDnsServer = TRUE;

            NlPrint(( NL_CRITICAL,
                      "NetpDcGetNameIp: %ws: cannot find A record.\n",
                      Context->QueriedDisplayDomainName ));
            continue;

        //
        // If we've processed all of the site specific SRV records and are about to move on,
        //  wait a little longer for the site specific DCs to respond.
        //
        } else if ( NetStatus == ERROR_FILEMARK_DETECTED ) {

            //
            // Only do this if there actually were site specific SRV records.
            //

            if ( DcPingCount ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetNameIp: %ws: site specific SRV records done.\n",
                          Context->QueriedDisplayDomainName ));


                //
                // Get the response from the ping.
                //

                NetStatus = NetpDcGetPingResponse(
                                Context,
                                NL_DC_MED_PING_TIMEOUT,  // wait for median time
                                NlDcCacheEntry,
                                UsedNetbios );

                if ( NetStatus != ERROR_SEM_TIMEOUT ) {
                    if ( NetStatus != NO_ERROR ) {
                        NlPrint(( NL_CRITICAL,
                                 "NetpDcGetNameIp: %ws: Cannot NetpDcGetPingResponse. %ld\n",
                                 Context->QueriedDisplayDomainName,
                                 NetStatus ));
                    }
                    goto Cleanup;
                }
            }

            //
            // Indicate that all subsequent addresses are retrived as a result
            // of non-site-specific DNS record lookup.
            //

            SiteSpecificRecords = FALSE;

            continue;

        //
        // If we're done,
        //  break out of the loop.
        //
        } else if ( NetStatus == ERROR_NO_MORE_ITEMS ) {

            //
            // Indicate that DNS is up and running.
            //
            Context->ResponseFromDnsServer = TRUE;
            break;

        //
        // If DNS isn't available,
        //  blow this request away.
        //
        } else if ( NetStatus == ERROR_TIMEOUT ||
                    NetStatus == DNS_ERROR_RCODE_SERVER_FAILURE ) { // Server failed
            //
            // DNS servers being down isn't a permanent condition.
            //
            Context->AvoidPermanentNegativeCache = TRUE;
            break;

        //
        // If IP or DNS is not configured,
        //  tell the caller.
        //
        } else if ( NetStatus == DNS_ERROR_NO_TCPIP ||        // TCP/IP not configured
                    NetStatus == DNS_ERROR_NO_DNS_SERVERS ) { // DNS not configured
            NlPrint(( NL_CRITICAL,
                      "NetpDcGetNameIp: %ws: IP Not configured from DnsQuery.\n",
                      Context->QueriedDisplayDomainName ));
            NetStatus = ERROR_DNS_NOT_CONFIGURED;
            goto Cleanup;

        //
        // We don't handle any other error.
        //
        } else {
            NlPrint(( NL_CRITICAL,
                      "NetpDcGetNameIp: %ws: Unknown error from DnsQuery. %ld 0x%lx\n",
                      Context->QueriedDisplayDomainName,
                      NetStatus,
                      NetStatus ));
            goto Cleanup;
        }

        DnsRecordFound = TRUE;

        //
        // Add new addresses to the list
        //

        if ( UnicodeDnsHostName != NULL ) {
            NetApiBufferFree( UnicodeDnsHostName );
            UnicodeDnsHostName = NULL;
        }
        UnicodeDnsHostName = NetpAllocWStrFromUtf8Str( Utf8DnsHostName );
        if ( UnicodeDnsHostName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        NetStatus = NetpDcProcessAddressList( Context,
                                              UnicodeDnsHostName,
                                              SockAddressList,
                                              SockAddressCount,
                                              SiteSpecificRecords,
                                              &FirstDcToQuery );
        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Only process this list if new entries were added.
        //

        if ( FirstDcToQuery != NULL ) {
            ULONG LocalDcPingCount = 0;

            //
            // Ping the new list of DCs.
            //

            NetStatus = NetpDcPingListIp(
                            Context,
                            FirstDcToQuery,
                            TRUE,           // Wait for ping responce
                            NlDcCacheEntry,
                            UsedNetbios,
                            &LocalDcPingCount );

            //
            // If we sent a ping to at least one address for this DC,
            //  count this DC in the number of DCs pinged
            //
            if ( LocalDcPingCount > 0 ) {
                Context->DcsPinged ++;
            }

            //
            // Check error conditions
            //
            if ( NetStatus != ERROR_SEM_TIMEOUT ) {
                if ( NetStatus != NO_ERROR ) {
                    NlPrint(( NL_CRITICAL,
                              "NetpDcGetNameIp: %ws: Cannot NetpDcPingListIp. %ld\n",
                              Context->QueriedDisplayDomainName,
                              NetStatus ));
                }
                goto Cleanup;
            }

            //
            // Update the number of pings we sent
            //
            DcPingCount += LocalDcPingCount;

            //
            // Stop getting new addresses if we have reached
            //  the limit on the number of DCs we can ping
            //
            if ( Context->DcsPinged >= LocalMaxLdapServersPinged ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetNameSiteIp: %ws: Reached the DC limit %lu %lu\n",
                          Context->QueriedDisplayDomainName,
                          Context->DcsPinged,
                          LocalMaxLdapServersPinged ));
                break;
            }
        }
    }

    //
    // If no DNS records could be found,
    //  this is a definitive failure.
    //

    if ( !DnsRecordFound ) {
        NlPrint(( NL_CRITICAL,
                  "NetpDcGetNameIp: %ws: No data returned from DnsQuery.\n",
                  Context->QueriedDisplayDomainName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // If we could not send a ping to any of the DCs,
    //  or if there are no more DCs to ping,
    //  this is a definitive failure.
    //

    if ( DcPingCount == 0 || Context->DcAddressCount == 0 ) {
        NlPrint(( NL_CRITICAL,
                  "NetpDcGetNameIp: %ws: Couldn't ping any DCs.\n",
                  Context->QueriedDisplayDomainName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    NetStatus = ERROR_SEM_TIMEOUT;


Cleanup:
    if ( SockAddressList != NULL) {
        LocalFree( SockAddressList );
    }

    if ( DsGetDcHandle != NULL ) {
        NetpDcGetDcClose( DsGetDcHandle );
    }

    if ( Utf8DnsDomainName != NULL ) {
        NetpMemoryFree( Utf8DnsDomainName );
    }
    if ( Utf8DnsForestName != NULL ) {
        NetpMemoryFree( Utf8DnsForestName );
    }
    if ( UnicodeDnsHostName != NULL ) {
        NetApiBufferFree( UnicodeDnsHostName );
    }

    //
    // Note that Utf8DnsHostName should not be freed
    //  as it wasn't allocated
    //

    return NetStatus;
}

NET_API_STATUS
NetpDcGetNameIp(
    IN PNL_GETDC_CONTEXT Context,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry,
    OUT PBOOL UsedNetbios
    )
/*++

Routine Description:

    This routine determines the name/address of a DC with the specified
    characteristics using an IP-only algorithm.

    This routine handles the case where the site of the DC found isn't the
    'closest' site to the client.  In that case, the DC found will indicate
    which site is the closest site.  This routine will try to find a DC in that
    closest site.

Arguments:

    Context - Context describing the GetDc operation.

    NlDcCacheEntry - On success, returns a pointer to the cache entry
        describing the found DC.
        This entry must be dereferenced using NetpDcDerefCacheEntry.

    UsedNetbios - Returns TRUE if the netbios domain name was used to match
        the returned cache entry.

Return Value:

    NO_ERROR: The NlDcCacheEntry was returned;

    ERROR_NO_SUCH_DOMAIN: The specified domain does not exist.
        (Definitive status that we need not try again.)

    ERROR_SEM_TIMEOUT: No DC responded to the request.
        (Non-definitive status that we should try again.)

    ERROR_DNS_NOT_CONFIGURED: IP or DNS is not available on this computer.

    ERROR_INTERNAL_ERROR: Unhandled situation detected.

    ERROR_INVALID_DOMAINNAME: Domain's name is too long. Additional labels
        cannot be concatenated.

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory is available to process
        this request.

    Various Winsock errors.

--*/
{
    NET_API_STATUS NetStatus;
    PNL_DC_CACHE_ENTRY ClosestNlDcCacheEntry;
    BOOL ClosestUsedNetbios;


    //
    // Try the operation as it was passed to us.
    //

    NetStatus = NetpDcGetNameSiteIp( Context,
                                     Context->DoingExplicitSite ?
                                        DS_ONLY_DO_SITE_NAME :
                                        0, // No flags this time
                                     Context->QueriedSiteName,
                                     NlDcCacheEntry,
                                     UsedNetbios );

    if ( NetStatus != NO_ERROR ) {
        return NetStatus;
    }

    //
    // If the queried DC type doesn't have site specific DCs,
    //  return the found DC to the caller.
    //

    if ( NlDcDnsNameTypeDesc[Context->QueriedNlDnsNameType].SiteSpecificDnsNameType == NlDnsInvalid ) {
        return NO_ERROR;
    }

    //
    // If the caller explicitly specified a sitename,
    //  return the found DC to the caller.
    //

    if ( Context->DoingExplicitSite ) {
        return NO_ERROR;
    }


    //
    // If the responding DC is in the closest site,
    //  or the DC doesn't know the closest site,
    //  or we've already tried the closest site (this case shouldn't happen),
    //  return the found DC to the caller.
    //

    if ( ((*NlDcCacheEntry)->ReturnFlags & DS_CLOSEST_FLAG ) != 0 ||
          (*NlDcCacheEntry)->UnicodeClientSiteName == NULL ||
          (Context->QueriedSiteName != NULL &&
            _wcsicmp( (*NlDcCacheEntry)->UnicodeClientSiteName,
                      Context->QueriedSiteName ) == 0 ) ) {

        return NO_ERROR;
    }

    //
    // Free up any existing addresses that have been pinged.
    //
    // We're starting the operation over again.

    NetpDcFreeAddressList( Context );

    //
    // Try the operation again just trying to find a DC in the right site.
    //
    NlPrint(( NL_MISC,
              "NetpDcGetNameIp: %ws Trying to find a DC in a closer site: %ws\n",
              Context->QueriedDisplayDomainName,
              (*NlDcCacheEntry)->UnicodeClientSiteName ));

    NetStatus = NetpDcGetNameSiteIp( Context,
                                     DS_ONLY_DO_SITE_NAME,
                                     (*NlDcCacheEntry)->UnicodeClientSiteName,
                                     &ClosestNlDcCacheEntry,
                                     &ClosestUsedNetbios );

    if ( NetStatus != NO_ERROR ) {
        return NO_ERROR;
    }

    //
    // If we found a closer DC,
    //  ditch the first entry and use the new one.
    //

    NetpDcDerefCacheEntry( *NlDcCacheEntry );
    *NlDcCacheEntry = ClosestNlDcCacheEntry;
    *UsedNetbios = ClosestUsedNetbios;
    return NO_ERROR;

}

NET_API_STATUS
NetpDcGetNameNetbios(
    PNL_GETDC_CONTEXT Context,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry,
    OUT PBOOL UsedNetbios
    )
/*++

Routine Description:

    This routine determines the name/address of a DC with the specified
    characteristics using a Netbios algorithm.

Arguments:

    Context - Context describing the GetDc operation.

    NlDcCacheEntry - On success, returns a pointer to the cache entry
        describing the found DC.
        This entry must be dereferenced using NetpDcDerefCacheEntry.

    UsedNetbios - Returns TRUE if the netbios domain name was used to match
        the returned cache entry.

Return Value:

    NO_ERROR: The NlDcCacheEntry was returned;

    ERROR_NO_SUCH_DOMAIN: The specified domain does not exist.
        (Definitive status that we need not try again.)

    ERROR_SEM_TIMEOUT: No DC responded to the request.
        (Non-definitive status that we should try again.)

    ERROR_INTERNAL_ERROR: Unhandled situation detected.

    ERROR_INVALID_DOMAINNAME: Domain's name is too long. Additional labels
        cannot be concatenated.

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory is available to process
        this request.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    BOOL Flush1cName = FALSE;
    BOOL Flush1bName = FALSE;

    //
    // Avoid querying for GCs.
    //
    // GCs don't have their own Netbios name.  I could simply send to the 1C name, but
    //  1) It would be wasteful to send to all of the DCs when only some are GCs.
    //  2) WINS only registers a max of 25 DC addresses per name.
    //


    if ( NlDnsGcName(Context->QueriedNlDnsNameType) ) {
        NlPrint(( NL_CRITICAL,
                  "NetpDcGetNameNetbios: %ws: Cannot query for GC using netbios.\n",
                  Context->QueriedDisplayDomainName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Flush Netbios cache if this is forced rediscovery
    //

    if ( Context->QueriedFlags & DS_FORCE_REDISCOVERY ) {
        Flush1bName = TRUE;
        Flush1cName = TRUE;
    }

    //
    // If there is an alternate ping message,
    //  send it first.
    //

    if ( Context->AlternatePingMessageSize != 0 ) {

        //
        // If only the PDC should responsd,
        //  send the alternate ping to DomainName[1B].
        //
        // If any DC can respond,
        //  broadcast it to DomainName[1C] groupname.
        //
        //
        // If this is a request for a PDC with an account,
        //  the "primary" message is a normal "primary query" sent for
        //  backward compatibility with NT 4 and earlier.  This message
        //  is a "logon user" that NT 5 will understand.
        //
        // (More specifically, NT 4 understands this query but we'll discard
        // the response since the response from NT 4 doesn't flag the response
        // as being from the PDC.)
        //
        //
        // If this is a request for a writable DC,
        //  this request is the datagram send of the "logon user" message to DomainName[1C].
        //

#if NETLOGONDBG
        NlPrint((NL_MAILSLOT,
                 "Sent '%s' message to %ws[%s] on all transports.\n",
                 NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)(Context->AlternatePingMessage))->Opcode),
                 (LPWSTR) Context->QueriedNetbiosDomainName,
                 NlDgrNameType( Context->DcQueryType == NlDcQueryPdc ?
                                   PrimaryDomainBrowser :  // 0x1B name
                                   DomainName))); // 0x1C name
#endif // NETLOGONDBG


        Status = NlBrowserSendDatagram(
                        Context->SendDatagramContext,
                        (Context->QueriedFlags & DS_IP_REQUIRED ) ? ALL_IP_TRANSPORTS : 0,
                        (LPWSTR) Context->QueriedNetbiosDomainName,
                        Context->DcQueryType == NlDcQueryPdc ?
                            PrimaryDomainBrowser :  // 0x1B name
                            DomainName, // 0x1C name
                        NULL,       // All transports
                        NETLOGON_LM_MAILSLOT_A,
                        Context->AlternatePingMessage,
                        Context->AlternatePingMessageSize,
                        Context->DcQueryType == NlDcQueryPdc ?
                            &Flush1bName :
                            &Flush1cName );

        if ( !NT_SUCCESS(Status)) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            NlPrint(( NL_CRITICAL,
                      "NetpDcGetNameNetbios: %ws: Cannot NlBrowserSendDatagram. (ALT) %ld\n",
                      Context->QueriedDisplayDomainName,
                      NetStatus ));
            if ( NlDcUseGenericStatus(NetStatus) ) {
                NetStatus = ERROR_NO_SUCH_DOMAIN;
            }
            goto Cleanup;
        }

        //
        // Get the response from the ping.
        //

        NetStatus = NetpDcGetPingResponse(
                        Context,
                        NL_DC_MIN_PING_TIMEOUT,
                        NlDcCacheEntry,
                        UsedNetbios );

        if ( NetStatus != ERROR_SEM_TIMEOUT ) {
            if ( NetStatus != NO_ERROR ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetNameNetbios: %ws: Cannot NetpDcGetPingResponse. %ld\n",
                          Context->QueriedDisplayDomainName,
                          NetStatus ));
            }
            goto Cleanup;
        }

    }


    //
    // If this is a PDC query,
    //  Broadcast to DomainName[1B] unique name
    //  registered only by the PDC. (Currently, only NT 3.5 (and newer) PDCs register
    //  this name and accept incoming mailslot messages on the name.)
    //

    if ( Context->DcQueryType == NlDcQueryPdc ||
         (Context->QueriedFlags & DS_WRITABLE_REQUIRED) != 0 ) {
#if NETLOGONDBG
        NlPrint((NL_MAILSLOT,
                 "Sent '%s' message to %ws[%s] on all transports.\n",
                 NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)(Context->PingMessage))->Opcode),
                 (LPWSTR) Context->QueriedNetbiosDomainName,
                 NlDgrNameType(PrimaryDomainBrowser)));  // 0x1B name
#endif // NETLOGONDBG

        Status = NlBrowserSendDatagram(
                        Context->SendDatagramContext,
                        (Context->QueriedFlags & DS_IP_REQUIRED ) ? ALL_IP_TRANSPORTS : 0,
                        (LPWSTR) Context->QueriedNetbiosDomainName,
                        PrimaryDomainBrowser,  // 0x1B name
                        NULL,                  // All transports
                        NETLOGON_LM_MAILSLOT_A,
                        Context->PingMessage,
                        Context->PingMessageSize,
                        &Flush1bName );

        if ( !NT_SUCCESS(Status)) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            NlPrint(( NL_CRITICAL,
                      "NetpDcGetNameNetbios: %ws: Cannot NlBrowserSendDatagram. (1B) %ld\n",
                      Context->QueriedDisplayDomainName,
                      NetStatus ));
            if ( NlDcUseGenericStatus(NetStatus) ) {
                NetStatus = ERROR_NO_SUCH_DOMAIN;
            }
            goto Cleanup;
        }

        //
        // Get the response from the ping.
        //

        NetStatus = NetpDcGetPingResponse(
                        Context,
                        NL_DC_MIN_PING_TIMEOUT,
                        NlDcCacheEntry,
                        UsedNetbios );

        if ( NetStatus != ERROR_SEM_TIMEOUT ) {
            if ( NetStatus != NO_ERROR ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetNameNetbios: %ws: Cannot NetpDcGetPingResponse. %ld\n",
                          Context->QueriedDisplayDomainName,
                          NetStatus ));
            }
            goto Cleanup;
        }
    }



    //
    // If this is the second or third iteration,
    //  or if this isn't a PDC query,
    //  broadcast to DomainName[1C] groupname
    //  registered only by DCs. (Currently, only NT DCs register
    //  this name.)
    //
    // If this is a request for a writable DC,
    //  this request is the datagram send of the "primary query" message to DomainName[1C].
    //
    if ( Context->TryCount != 0 ||
         (Context->DcQueryType != NlDcQueryPdc &&
          (Context->QueriedFlags & DS_WRITABLE_REQUIRED) == 0 )) {
#if NETLOGONDBG
        NlPrint((NL_MAILSLOT,
                 "Sent '%s' message to %ws[%s] on all transports.\n",
                 NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)(Context->PingMessage))->Opcode),
                 (LPWSTR) Context->QueriedNetbiosDomainName,
                 NlDgrNameType(DomainName)));  // 0x1C name
#endif // NETLOGONDBG

        Status = NlBrowserSendDatagram(
                        Context->SendDatagramContext,
                        (Context->QueriedFlags & DS_IP_REQUIRED ) ? ALL_IP_TRANSPORTS : 0,
                        (LPWSTR) Context->QueriedNetbiosDomainName,
                        DomainName, // 0x1C name
                        NULL,       // All transports
                        NETLOGON_LM_MAILSLOT_A,
                        Context->PingMessage,
                        Context->PingMessageSize,
                        &Flush1cName );

        if ( !NT_SUCCESS(Status)) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            NlPrint(( NL_CRITICAL,
                      "NetpDcGetNameNetbios: %ws: Cannot NlBrowserSendDatagram. (1C) %ld\n",
                      Context->QueriedDisplayDomainName,
                      NetStatus ));
            if ( NlDcUseGenericStatus(NetStatus) ) {
                NetStatus = ERROR_NO_SUCH_DOMAIN;
            }
            goto Cleanup;
        }

        //
        // Get the response from the ping.
        //

        NetStatus = NetpDcGetPingResponse(
                        Context,
                        NL_DC_MIN_PING_TIMEOUT,
                        NlDcCacheEntry,
                        UsedNetbios );

        if ( NetStatus != ERROR_SEM_TIMEOUT ) {
            if ( NetStatus != NO_ERROR ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetNameNetbios: %ws: Cannot NetpDcGetPingResponse. %ld\n",
                          Context->QueriedDisplayDomainName,
                          NetStatus ));
            }
            goto Cleanup;
        }
    }

    NetStatus = ERROR_SEM_TIMEOUT;

Cleanup:
    return NetStatus;

}

DWORD
NetpDcInitializeContext(
    IN PVOID SendDatagramContext OPTIONAL,
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    IN LPCWSTR DnsForestName OPTIONAL,
    IN PSID RequestedDomainSid OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN LPCWSTR DcNameToPing OPTIONAL,
    IN PSOCKET_ADDRESS DcSocketAddressList OPTIONAL,
    IN ULONG DcSocketAddressCount,
    IN ULONG Flags,
    IN ULONG InternalFlags,
    IN ULONG InitializationType,
    IN OUT PNL_GETDC_CONTEXT Context
)

/*++

Routine Description:

    This routine initializes the Context data struct describing the GetDc operation.

Arguments:



    SendDatagramContext - Specifies context to pass a NlBrowserSendDatagram

    ComputerName - Specifies the NETBIOS name of this computer.
        If NULL, the name will be dynamically determined.

    AccountName - Account name to pass on the ping request.
        If NULL, no account name will be sent.

    AllowableAccountControlBits - Mask of allowable account types for AccountName.
        Valid bits are those specified by USER_MACHINE_ACCOUNT_MASK.
        Invalid bits are ignored.  If more than one bit is specified, the
        account can be of any of the specified types.

    NetbiosDomainName - The Netbios name of the domain to query.
        (e.g., microsoft). Either NetbiosDomainName or DnsDomainName or both
        must be specified.

    DnsDomainName - The DNS-style name of the domain to query.
        (e.g., microsoft.com)

    DnsForestName - The DNS-style name of the tree the queried domain is in.

    RequestedDomainSid - Sid of the domain the message is destined to.
        If NULL, no domain sid will be sent in the ping request.

    DomainGuid - Specifies the Domain GUID of the domain being queried.
        This value is used to handle the case of domain renames.  If this
        value is specified and DomainName has been renamed, DsGetDcName will
        attempt to locate a DC in the domain having this specified DomainGuid.

    SiteName - Specifies the site name of the site the returned DC should be
        "close" to.  The parameter should typically be the site name of the
        site the client is in.  If not specified, the site name defaults to
        the site of ComputerName.

    DcNameToPing - The name of the DC to ping.  If set, Context is the
        ping context, not a discovery one.

    DcSocketAddressList - A list of socket addresses to ping. Ignored if only
        Context flags need to be initialized.

    DcSocketAddressCount - The number of socket addresses in DcSocketAddressList.
        Ignored if only Context flags need to be initialized.

    Flags - Passes additional information to be used to process the request.
        Flags can be a combination values bitwise or'ed together.

    InternalFlags - Internal Flags used to pass additional information

    DoFlagInitialization - TRUE if only Contex flags need to be initialize.
        If FALSE, this must be the ping part initialization only.

    Context -  the Context data struct describing the GetDc operation.

Return Value:

    NO_ERROR: The initialization was successful

    ERROR_INVALID_FLAGS - The flags parameter has conflicting or superfluous
        bits set.

    ERROR_INVALID_PARAMETER - One of the parameters is invalid.

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory is available to process
        this request.

    Various Winsock errors.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;

    LPWSTR LocalComputerName = NULL;
    CHAR ResponseMailslotName[MAX_PATH+1];
    ULONG ExtraVersionBits = 0;
    PNL_DC_ADDRESS DcAddress = NULL;

    //
    // Do flag initialization
    //

    if ( InitializationType & NL_GETDC_CONTEXT_INITIALIZE_FLAGS ) {

        //
        // Treat zero length domain name as NULL.
        //

        if ( DnsDomainName != NULL && *DnsDomainName == L'\0' ) {
            DnsDomainName = NULL;
        }

        if ( DnsForestName != NULL && *DnsForestName == L'\0' ) {
            DnsForestName = NULL;
        }

        if ( NetbiosDomainName != NULL && *NetbiosDomainName == L'\0' ) {
            NetbiosDomainName = NULL;
        }

        if ( SiteName != NULL && *SiteName == L'\0' ) {
            SiteName = NULL;
        }

        if ( DcNameToPing != NULL && *DcNameToPing == L'\0' ) {
            DcNameToPing = NULL;
        }

        //
        // Initialization
        //

        RtlZeroMemory( Context, sizeof(*Context) );
        Context->FreeOurNetbiosComputerName = FALSE;
        Context->QueriedAccountName = AccountName;
        Context->QueriedAllowableAccountControlBits = AllowableAccountControlBits;
        Context->QueriedNetbiosDomainName = NetbiosDomainName;
        Context->QueriedDnsDomainName = DnsDomainName;
        Context->QueriedDnsForestName = DnsForestName;
        Context->QueriedDcName = DcNameToPing;
        if ( DnsDomainName != NULL ) {
            Context->QueriedDisplayDomainName = DnsDomainName;
        } else {
            Context->QueriedDisplayDomainName = NetbiosDomainName;
        }
        Context->QueriedDomainGuid = DomainGuid;
        Context->QueriedFlags = Flags;
        Context->QueriedInternalFlags = InternalFlags;
        Context->SendDatagramContext = SendDatagramContext;
        Context->ImperfectCacheEntry = NULL;
        InitializeListHead( &Context->DcAddressList );
        Context->DcAddressCount = 0;

        Context->QueriedSiteName = SiteName;
        Context->DoingExplicitSite = Context->QueriedSiteName != NULL &&
             (Context->QueriedInternalFlags & DS_SITENAME_DEFAULTED) == 0;

        Context->ResponseBuffer = NULL;
        Context->ResponseMailslotHandle = NULL;

        //
        // Don't pass confusing bits
        //

        if ( Context->QueriedAccountName == NULL ) {
            Context->QueriedAllowableAccountControlBits = 0;
        }

        //
        // Validate the passed in flags
        //

        if ( (Context->QueriedFlags & ~DSGETDC_VALID_FLAGS) != 0 ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcInitializeContext: %ws: invalid flags %lx\n",
                      Context->QueriedDisplayDomainName,
                      Flags ));
            NetStatus = ERROR_INVALID_FLAGS;
            goto Cleanup;
        }

        if ( Context->QueriedFlags & DS_GC_SERVER_REQUIRED ) {

            //
            // The DC ignores pings with superfluous info.
            //  So catch the caller here.
            //
            if ( Context->QueriedAccountName != NULL ||
                 Context->QueriedAllowableAccountControlBits != 0 ||
                 RequestedDomainSid != NULL ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcInitializeContext: %ws: GC queried and invalid parameters specified.\n",
                          Context->QueriedDisplayDomainName ));
                NetStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }


        //
        // The Only LDAP bit is mutually exclusive with almost everything.
        //
        //  Don't error out.  Rather, treat the only LDAP bit as an advisory
        //  that these other bits should affect the decision of which DC to find.
        //

        if ( Context->QueriedFlags & DS_ONLY_LDAP_NEEDED ) {
            Context->QueriedFlags &= ~(
                        DS_DIRECTORY_SERVICE_REQUIRED |
                        DS_DIRECTORY_SERVICE_PREFERRED |
                        DS_TIMESERV_REQUIRED |
                        DS_GOOD_TIMESERV_PREFERRED |
                        DS_PDC_REQUIRED |
                        DS_KDC_REQUIRED );
        }

        //
        // Convert the flags to the type of DNS name to lookup.
        //

        NetStatus = NetpDcFlagsToNameType( Context->QueriedFlags, &Context->QueriedNlDnsNameType );

        if ( NetStatus != NO_ERROR ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcInitializeContext: %ws: cannot convert flags to nametype %ld\n",
                      Context->QueriedDisplayDomainName,
                      NetStatus ));
            goto Cleanup;
        }

        Context->DcQueryType = NlDcDnsNameTypeDesc[Context->QueriedNlDnsNameType].DcQueryType;

        //
        // The Good Time Service preferred bit is mutually exclusive with almost everything.
        //

        if ( Context->QueriedFlags & DS_GOOD_TIMESERV_PREFERRED ) {
            if ( Context->QueriedFlags & (
                        DS_DIRECTORY_SERVICE_REQUIRED |
                        DS_DIRECTORY_SERVICE_PREFERRED |
                        DS_GC_SERVER_REQUIRED |
                        DS_PDC_REQUIRED |
                        DS_KDC_REQUIRED |
                        DS_WRITABLE_REQUIRED )) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcInitializeContext: %ws: flags not compatible with 'Good Time' %lx\n",
                          Context->QueriedDisplayDomainName,
                          Flags ));
                NetStatus = ERROR_INVALID_FLAGS;
                goto Cleanup;
            }
        }

        //
        // If the caller needs the PDC,
        //  ditch the DS preferred flag (there is only one PDC),
        //  ditch the writable flag (the PDC is always writable)
        //

        if ( (Context->QueriedFlags & DS_PDC_REQUIRED ) != 0 ) {
            Context->QueriedFlags &= ~(DS_DIRECTORY_SERVICE_PREFERRED|DS_WRITABLE_REQUIRED);
        }

        //
        // If the caller says that an NT 5.0 DC is both preferred and required,
        //  ditch the preferred bit.
        //

        if ( (Context->QueriedFlags & DS_NT50_REQUIRED ) != 0 &&
             (Context->QueriedFlags & DS_DIRECTORY_SERVICE_PREFERRED) != 0 ) {

            Context->QueriedFlags &= ~DS_DIRECTORY_SERVICE_PREFERRED;
        }

        //
        // Ensure we have a computername.
        //

        if ( ComputerName == NULL ) {
#ifndef WIN32_CHICAGO
            //
            // On a cluster, use the physical netbios name since this name is
            // used to receive returned mailslot packets.
            //
            NetStatus = NetpGetComputerNameEx ( &LocalComputerName, TRUE );
#else
            NetStatus = NetpGetComputerName ( &LocalComputerName);
#endif // WIN32_CHICAGO

            if ( NetStatus != NO_ERROR ) {
                goto Cleanup;
            }

            ComputerName = LocalComputerName;
            Context->FreeOurNetbiosComputerName = TRUE;
        }

        Context->OurNetbiosComputerName = ComputerName;

        //
        // Get the domain entry describing this domain.
        //

        Context->NlDcDomainEntry = NetpDcCreateDomainEntry(
                                Context->QueriedDomainGuid,
                                Context->QueriedNetbiosDomainName,
                                Context->QueriedDnsDomainName );

        if ( Context->NlDcDomainEntry == NULL ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcInitializeContext: not enough memory for DomainEntry.\n" ));
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

    }

    //
    // Do the ping initialization part
    //

    if ( InitializationType & NL_GETDC_CONTEXT_INITIALIZE_PING ) {

        if ( Context->QueriedFlags & DS_GC_SERVER_REQUIRED ) {
            ExtraVersionBits |= NETLOGON_NT_VERSION_GC;
        }
        if ( Context->QueriedFlags & DS_IP_REQUIRED ) {
            ExtraVersionBits |= NETLOGON_NT_VERSION_IP;
        }

        if ( Context->QueriedFlags & DS_PDC_REQUIRED ) {
            ExtraVersionBits |= NETLOGON_NT_VERSION_PDC;
        }

        //
        // See if we are to neutralize NT4 emulation
        //

#ifdef _NETLOGON_SERVER

        //
        // In netlogon, the boolean is kept in global parameters
        //
        if ( NlGlobalParameters.NeutralizeNt4Emulator ) {
            ExtraVersionBits |= NETLOGON_NT_VERSION_AVOID_NT4EMUL;
        }
#else
        //
        // If we are not running in netlogon, we need to read
        //  the boolean directly from the registry
        //
        {
            DWORD LocalNeutralizeNt4Emulator = 0;
            NT_PRODUCT_TYPE NtProductType;

            if ( !RtlGetNtProductType( &NtProductType ) ) {
                NtProductType = NtProductWinNt;
            }

            //
            // On DC, we always neutrilize NT4 emulation
            //
            if ( NtProductType == NtProductLanManNt ) {
                LocalNeutralizeNt4Emulator = 1;

            //
            // On wksta, read the registry
            //
            } else {
                NlReadDwordNetlogonRegValue( "NeutralizeNt4Emulator",
                                             &LocalNeutralizeNt4Emulator );
            }

            if ( LocalNeutralizeNt4Emulator ) {
                ExtraVersionBits |= NETLOGON_NT_VERSION_AVOID_NT4EMUL;
            }
        }

#endif // _NETLOGON_SERVER

        //
        // If we're querying by netbios name,
        //  initialize for doing the query.
        //

        if ( Context->QueriedNetbiosDomainName != NULL ) {

            //
            // Allocate the response buffer
            //
            //  (This buffer could be allocated on the stack ofNetpDcGetPingResponse()
            //  except the buffer is large and we want to avoid stack overflows.)
            //  (DWORD align it.)
            //

            Context->ResponseBuffer = LocalAlloc( 0,
                         ( MAX_RANDOM_MAILSLOT_RESPONSE/sizeof(DWORD) ) * sizeof(DWORD)
                                                  );

            if ( Context->ResponseBuffer == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            Context->ResponseBufferSize =
                         ( MAX_RANDOM_MAILSLOT_RESPONSE/sizeof(DWORD) ) * sizeof(DWORD);

            //
            // Open a mailslot to get ping responses on.
            //
            //
            // We need to "Randomize" the mailslot name so that this api can have
            // more than one invocation at a time.  If we don't, the fact that
            // mailslots must have unique names will prevent the second invocation
            // of this api from functioning until the first has ended and deleted
            // the mailslot. NetpLogonCreateRandomMailslot does this for us
            // and creates the mailslot in the process.
            //

            NetStatus = NetpLogonCreateRandomMailslot( ResponseMailslotName,
                                                       &Context->ResponseMailslotHandle );

            if (NetStatus != NO_ERROR ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcInitializeContext: %ws: cannot create temp mailslot %ld\n",
                          Context->QueriedDisplayDomainName,
                          NetStatus));
                goto Cleanup;
            }

            //
            // Build the ping message.
            //
            // If the account name is specified, don't generate a "primary query"
            //  message since it doesn't have an account name in it.
            //

            NetStatus = NetpDcBuildPing(
                            (Context->DcQueryType == NlDcQueryPdc ||
                                (Context->QueriedFlags & DS_WRITABLE_REQUIRED) != 0),
                            0,              // RequestCount,
                            Context->OurNetbiosComputerName,   // Netbios name of this computer
                            Context->QueriedAccountName,
                            ResponseMailslotName,
                            Context->QueriedAllowableAccountControlBits,
                            RequestedDomainSid,
                            // We really need the IP address, so don't ask for simple 5EX version
                            NETLOGON_NT_VERSION_5|NETLOGON_NT_VERSION_5EX_WITH_IP|ExtraVersionBits,
                            &Context->PingMessage,
                            &Context->PingMessageSize );

            if (NetStatus != NO_ERROR ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcInitializeContext: %ws: cannot build ping message %ld\n",
                          Context->QueriedDisplayDomainName,
                          NetStatus));
                goto Cleanup;
            }

            //
            // Build the alternate ping message if we do a DC discovery.
            //
            // For writable DCs and PDCs, the ping message built above is the "primary query" message
            //  (used to find a PDC in pre-NT 5.0 domains) and the message build below is the
            //  "logon user" message.
            //
            // If the account name is specified by the original caller,
            //  the "logon user" message allows us to prefer DCs that have the account.
            //
            // If a writable DC is requested,
            //  sending this message to NT 5 DCs allows us to return ANY NT 5 DC.
            //

            if ( ((Context->QueriedInternalFlags & DS_DOING_DC_DISCOVERY) != 0) &&
                 (((Context->QueriedFlags & DS_WRITABLE_REQUIRED) != 0) ||
                  (Context->QueriedAccountName != NULL && Context->DcQueryType == NlDcQueryPdc)) ) {

                NetStatus = NetpDcBuildPing(
                                FALSE,
                                0,              // RequestCount,
                                Context->OurNetbiosComputerName,   // Netbios name of this computer
                                Context->QueriedAccountName,
                                ResponseMailslotName,
                                Context->QueriedAllowableAccountControlBits,
                                RequestedDomainSid,
                                // We really need the IP address, so don't ask for simple 5EX version
                                NETLOGON_NT_VERSION_5|NETLOGON_NT_VERSION_5EX_WITH_IP|ExtraVersionBits,
                                &Context->AlternatePingMessage,
                                &Context->AlternatePingMessageSize );

                if (NetStatus != NO_ERROR ) {
                    NlPrint(( NL_CRITICAL,
                              "NetpDcInitializeContext: %ws: cannot build alternate ping message %ld\n",
                              Context->QueriedDisplayDomainName,
                              NetStatus));
                    goto Cleanup;
                }

            }

        }

        //
        // Build the LDAP filter.
        //

        NetStatus = NetpDcBuildLdapFilter(
                        Context->OurNetbiosComputerName,   // Netbios name of this computer
                        Context->QueriedAccountName,
                        Context->QueriedAllowableAccountControlBits,
                        RequestedDomainSid,
                        Context->QueriedDnsDomainName,
                        Context->QueriedDomainGuid,
                        // Don't ask for 5EX_WITH_IP version since the server doesn't know the right IP address over LDAP
                        NETLOGON_NT_VERSION_5|NETLOGON_NT_VERSION_5EX|ExtraVersionBits,
                        &Context->LdapFilter );

        if (NetStatus != NO_ERROR ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcInitializeContext: %ws: cannot build ldap filter %ld\n",
                      Context->QueriedDisplayDomainName,
                      NetStatus));
            goto Cleanup;
        }

        //
        // Add the socket address to the address list.
        //

        if ( DcSocketAddressCount > 0 ) {
            NetStatus = NetpDcProcessAddressList( Context,
                                                  (LPWSTR) DcNameToPing,
                                                  DcSocketAddressList,
                                                  DcSocketAddressCount,
                                                  FALSE,  // Don't know if site specific
                                                  NULL );
            if ( NetStatus != NO_ERROR ) {
                goto Cleanup;
            }
        }

    }

Cleanup:
    return NetStatus;

}

VOID
NetpDcUninitializeContext(
    IN OUT PNL_GETDC_CONTEXT Context
)

/*++

Routine Description:

    This routine cleans up the Context data struct describing the GetDc operation.

Arguments:

    Context -  the Context data struct describing the GetDc operation.

Return Value:

    None.

--*/
{
    if ( Context->FreeOurNetbiosComputerName && Context->OurNetbiosComputerName != NULL ) {
        NetApiBufferFree((LPWSTR) Context->OurNetbiosComputerName);
    }

    if ( Context->ResponseBuffer != NULL ) {
        LocalFree( Context->ResponseBuffer );
    }

    if ( Context->ResponseMailslotHandle != NULL ) {
        CloseHandle(Context->ResponseMailslotHandle);
    }

    if ( Context->PingMessage != NULL ) {
        NetpMemoryFree( Context->PingMessage );
    }

    if ( Context->AlternatePingMessage != NULL ) {
        NetpMemoryFree( Context->AlternatePingMessage );
    }

    if ( Context->LdapFilter != NULL ) {
        NetpMemoryFree( Context->LdapFilter );
    }

    if ( Context->NlDcDomainEntry != NULL ) {
        NetpDcDerefDomainEntry( Context->NlDcDomainEntry );
    }

    if ( Context->ImperfectCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( Context->ImperfectCacheEntry );
    }

    NetpDcFreeAddressList( Context );
}

NET_API_STATUS
NlPingDcNameWithContext (
    IN  PNL_GETDC_CONTEXT Context,
    IN  ULONG NumberOfPings,
    IN  BOOLEAN WaitForResponse,
    IN  ULONG Timeout,
    OUT PBOOL UsedNetbios OPTIONAL,
    OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry OPTIONAL
    )

/*++

Routine Description:

    Ping the specified DC using the appropriate ping mechanism
    and optionally wait for the ping responses. Several pings
    will be attempted up to the specified limit.

Arguments:

    Context - Desribes the DC to ping.

    NumberOfPings - Total number of pings to send.

    WaitForResponse -
        If TRUE, this API will send up to NumberOfPings pings and wait for a
        response from the DC. The API will return the success code depending
        on whether or not the DC responds successfully.

        If FALSE, pings will be sent and no responses will be collected.
        The API will return the success code depending on whether or not
        all of the requeted pings were successfully sent.

    Timeout - Total ammount of time in milliseconds to wait for ping responses.
        Ignored if WaitForResponse is FALSE.

    UsedNetbios - Returns TRUE if the netbios domain name was used to match
        the returned cache entry. Ignored if WaitForResponse is FALSE.

    NlDcCacheEntry - Returns the data structure describing response received
        from the DC. Should be freed by calling NetpMemoryFree. Ignored if
        WaitForResponse is FALSE.

Return Value:

    NO_ERROR - Success.

    ERROR_NO_LOGON_SERVERS - No DC could be found

    ERROR_NO_SUCH_USER - The DC doesn't have the user account specified in the
        ping Context.

    ERROR_DOMAIN_TRUST_INCONSISTENT - The server that responded is not a proper
        domain controller of the specified domain.

    ERROR_SERVICE_NOT_ACTIVE - The netlogon service is paused on the server.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    ULONG RetryCount;

    PNL_DC_CACHE_ENTRY NlLocalDcCacheEntry = NULL;
    BOOL LocalUsedNetbios;
    ULONG IpPingCount;
    ULONG TotalPingsSent = 0;

    //
    // If we have no mechanism to send the pings, error out.
    //

    if ( (Context->QueriedInternalFlags &
          (DS_PING_USING_LDAP | DS_PING_USING_MAILSLOT)) == 0 ) {

        return ERROR_NO_LOGON_SERVERS;
    }

    //
    // Ping repeatedely the DC
    //

    for ( RetryCount=0; RetryCount<NumberOfPings; RetryCount++ ) {

        //
        // Send the ldap ping
        //

        if ( Context->QueriedInternalFlags & DS_PING_USING_LDAP ) {
            NetStatus = NetpDcPingIp( Context, &IpPingCount );

            //
            // If we cannot send any ldap ping, do not error out.  Rather, indicate
            //  to avoid the ldap mechanism and try the mailslot one only.
            //
            if ( NetStatus != NO_ERROR || IpPingCount == 0 ) {
                NlPrint((NL_CRITICAL,
                  "NlPingDcNameWithContext: cannot send %ld ldap pings: PingsSent = %ld, Error = 0x%lx\n",
                   Context->DcAddressCount,
                   IpPingCount,
                   NetStatus ));

                Context->QueriedInternalFlags &= ~DS_PING_USING_LDAP;
            } else {
                TotalPingsSent += IpPingCount;
                NlPrint((NL_MISC,
                    "NlPingDcNameWithContext: Sent %ld/%ld ldap pings to %ws\n",
                     IpPingCount,
                     Context->DcAddressCount,
                     Context->QueriedDcName ));
            }
        }

        //
        // Send the mailslot ping
        //

        if ( Context->QueriedInternalFlags & DS_PING_USING_MAILSLOT ) {

#if NETLOGONDBG
            NlPrint((NL_MAILSLOT,
                     "NlPingDcNameWithContext: Sent '%s' message to %ws[%s] on %ws.\n",
                     NlMailslotOpcode(((PNETLOGON_LOGON_QUERY)(Context->PingMessage))->Opcode),
                     Context->QueriedDcName,
                     NlDgrNameType(ComputerName),
                     NULL ));
#endif // NETLOGONDBG

            // Skip over \\ in unc server name
            Status = NlBrowserSendDatagram(
                            Context->SendDatagramContext,
                            (Context->QueriedFlags & DS_IP_REQUIRED ) ? ALL_IP_TRANSPORTS : 0,
                            (LPWSTR) Context->QueriedDcName,
                            ComputerName,
                            NULL,       // All transports
                            NETLOGON_LM_MAILSLOT_A,
                            Context->PingMessage,
                            Context->PingMessageSize,
                            NULL );     // Don't flush Netbios cache

            //
            // If we cannot write the maislot, do not error out.  Rather, indicate
            //  to avoid the mailslot mechanism and try the ldap one only.
            //
            if ( !NT_SUCCESS(Status) ) {
                NlPrint((NL_CRITICAL,
                        "NlPingDcNameWithContext: cannot write netlogon mailslot: 0x%lx\n",
                        Status));
                Context->QueriedInternalFlags &= ~DS_PING_USING_MAILSLOT;
            } else {
                TotalPingsSent ++;
            }
        }

        //
        // If we didn't send any ping, error out.  Otherwise, try to get a
        //  response.  It is possible that we will not do any more pings
        //  if either of the ping mechanisms is to be avoided, but we want
        //  to give all of the time left to those pings which have been sent.
        //
        if ( TotalPingsSent == 0 ) {
            NetStatus = ERROR_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        //
        // Get the response from the ping.
        //

        if ( WaitForResponse ) {

            if ( NlLocalDcCacheEntry != NULL ) {
                NetpMemoryFree( NlLocalDcCacheEntry );
                NlLocalDcCacheEntry = NULL;
            }

            NetStatus = NetpDcGetPingResponse(
                            Context,
                            Timeout/NumberOfPings,
                            &NlLocalDcCacheEntry,
                            &LocalUsedNetbios );

            //
            // If no error, we've successfully found the DC.
            //
            if ( NetStatus == NO_ERROR ) {
                if ( NlLocalDcCacheEntry->CacheEntryFlags & NL_DC_CACHE_LDAP ) {
                    NlPrint((NL_MISC,
                            "NlPingDcNameWithContext: %ws responded over IP.\n",
                            Context->QueriedDcName ));
                }
                if ( NlLocalDcCacheEntry->CacheEntryFlags & NL_DC_CACHE_MAILSLOT ) {
                    NlPrint((NL_MISC,
                            "NlPingDcNameWithContext: %ws responded on a mailslot.\n",
                            Context->QueriedDcName ));
                }
                goto Cleanup;

            //
            // If we've timed out, retry
            //
            } else if ( NetStatus == ERROR_SEM_TIMEOUT ) {
                NlPrint((NL_MISC,
                        "NlPingDcNameWithContext: Ping response timeout for %ws.\n",
                        Context->QueriedDcName ));
                continue;

            //
            // If the DC we've successfully pinged and got response from
            // returns responce info that is in conflict with the requested
            // info, error out.
            //
            } else if ( NetStatus == ERROR_INVALID_DATA ) {
                NlPrint((NL_CRITICAL,
                     "NlPingDcNameWithContext: Invalid response returned from %ws.\n",
                     Context->QueriedDcName ));

                NetStatus = ERROR_DOMAIN_TRUST_INCONSISTENT;
                goto Cleanup;

            //
            // Tell the caller that the netlogon service is paused
            //  on the server.
            //
            } else if ( NetStatus == ERROR_SERVICE_NOT_ACTIVE ) {
                NlPrint((NL_CRITICAL,
                     "NlPingDcNameWithContext: Netlogon is paused on %ws.\n",
                     Context->QueriedDcName ));
                goto Cleanup;
            //
            // Check if there is no such account
            //
            } else if ( NetStatus == ERROR_NO_SUCH_USER ) {
                NlPrint((NL_CRITICAL,
                     "NlPingDcNameWithContext: No such user %ws on %ws.\n",
                     Context->QueriedAccountName,
                     Context->QueriedDcName ));
                goto Cleanup;
            } else {
                NlPrint((NL_CRITICAL,
                     "NlPingDcNameWithContext: Wrong return code from NetpDcGetPingResponse: 0x%lx\n",
                     NetStatus));
                NetStatus = ERROR_NO_LOGON_SERVERS;
                goto Cleanup;
            }
        }
    }


    if ( WaitForResponse ) {
        NlPrint(( NL_CRITICAL,
                    "NlPingDcNameWithContext: Can't ping the DC %ws.\n", Context->QueriedDcName ));
        NetStatus = ERROR_NO_LOGON_SERVERS;
    } else {

        //
        // If we are requested to only send the pings and
        //  we couldn't send all of the requested pings,
        //
        if ( TotalPingsSent < NumberOfPings ) {
            NetStatus = ERROR_NO_LOGON_SERVERS;
        } else {
            NetStatus = NO_ERROR;
        }
    }


Cleanup:

    //
    // Return the DC info to the caller.
    //

    if ( NlLocalDcCacheEntry != NULL ) {
        if ( NetStatus == NO_ERROR && WaitForResponse && NlDcCacheEntry != NULL ) {
            *NlDcCacheEntry = NlLocalDcCacheEntry;
        } else {
            NetpMemoryFree( NlLocalDcCacheEntry );
        }
    }

    if ( NetStatus == NO_ERROR && WaitForResponse && UsedNetbios != NULL ) {
        *UsedNetbios = LocalUsedNetbios;
    }

    return NetStatus;
}

DWORD
NetpGetGcUsingNetbios(
    IN PNL_GETDC_CONTEXT Context,
    IN DWORD OrigTimeout,
    IN DWORD OrigRetryCount,
    OUT PNL_DC_CACHE_ENTRY *DomainControllerCacheEntry
)

/*++

Routine Description:

    This routine tries to find a GC using a Netbios domain name.


Arguments:

    Context - Context describing the initial attempt to find a DC.

    DomainControllerCacheEntry -
        Return a pointer to a private PNL_DC_CACHE_ENTRY
        structure describing the domain controller selected. The returned
        structure must be dereferenced using NetpDcDerefCacheEntry.

Return Value:

    The status code that is to be returned by the caller.

--*/
{
    NET_API_STATUS NetStatus;

    ULONG ElapsedTime;
    ULONG TimeToWait;
    ULONG LocalFlags;
    ULONG LocalInternalFlags;

    PDOMAIN_CONTROLLER_INFOW DcDomainControllerInfo = NULL;
    PNL_DC_CACHE_ENTRY GcDomainControllerCacheEntry = NULL;


    NlPrint(( NL_MAILSLOT,
              "%ws: Try to find a GC using netbios domain name.\n",
              Context->QueriedNetbiosDomainName ));

    //
    // Reduce the timeout to be the time we haven't already spent.
    //  (But allow a minimum of 2 seconds)
    //

    ElapsedTime = NetpDcElapsedTime( Context->StartTime );

    if ( ElapsedTime < OrigTimeout ) {
        TimeToWait = max((OrigTimeout - ElapsedTime), NL_DC_MIN_ITERATION_TIMEOUT);
    } else {
        TimeToWait = NL_DC_MIN_ITERATION_TIMEOUT;
    }

#ifdef notdef
    NlPrint((NL_CRITICAL,
        "NetpGetGcUsingNetbios: timeout is %ld %ld %ld %ld\n",
        Context->StartTime,
        ElapsedTime,
        OrigTimeout,
        TimeToWait ));
#endif // notdef



    //
    // Compute the flags to use to find a DC
    //
    //  Only keep the 'force' bit from the ones passed by the caller.
    //  Any other bit could only serve to confuse finding a GC.
    //
    LocalFlags = (Context->QueriedFlags & DS_FORCE_REDISCOVERY);

    // Prefer a DS to ensure we get back a forest name if we can.
    LocalFlags |= DS_DIRECTORY_SERVICE_PREFERRED;



    //
    // Compute the internal flags used to find a DC
    //
    // Keep only the internal flags that still apply to this call.
    //
    LocalInternalFlags = (Context->QueriedInternalFlags & DS_IS_PRIMARY_DOMAIN);

    // Tell NetpDcGetName not to cache failures.
    LocalInternalFlags |= DS_DONT_CACHE_FAILURE;

    // Since we're only using the data in the ping response and we're not
    //  actually using the returned DC, don't require a close DC.
    LocalInternalFlags |= DS_CLOSE_DC_NOT_NEEDED;

    // Ensure the named domain is really the root domain
    //
    // It wouldn't be fatal to allow this.  However, we cannot support it
    // for DNS names. So we don't want folks to stumble upon this working for
    // Netbios domain names.
    //
    // However, if the caller didn't pass the domain name, don't require the
    //  root domain. The caller just wants to find a GC and doesn't know the
    //  forest name. This will be the case for Win9x clients who passed NULL
    //  and we don't know the forest name on Win9x (so we couldn't get the
    //  forest name in DsIGetDcName).
    if ( (Context->QueriedInternalFlags & DS_CALLER_PASSED_NULL_DOMAIN) == 0 ) {
        LocalInternalFlags |= DS_REQUIRE_ROOT_DOMAIN;
    }




    //
    // Simply try to find a DC in the named domain.
    //
    // Don't try to find a DC in the named site.  Their might not be one.
    // We only know that there'll be a GC in the named site.  Luckily,
    // Netbios isn't very site aware in the first place.
    //
    // Even if the DC found happens to be a close GC, don't use it.
    // That'd unfairly load the GCs that happen to be in the root domain.
    // We should spread the load to all the GCs in the site.
    //

    NetStatus = NetpDcGetName(
                    Context->SendDatagramContext,
                    Context->OurNetbiosComputerName,
                    NULL,   // No AccountName
                    0,      // No AccountControlBits
                    Context->QueriedNetbiosDomainName,
                    NULL,   // We've already shown that the DNS name doesn't work
                    NULL,   // We don't know the forest name
                    NULL,   // RequestedDomainSid,
                    Context->QueriedDomainGuid,
                    NULL,   // There might not be a DC in the named site.
                    LocalFlags,
                    LocalInternalFlags,
                    TimeToWait,
                    OrigRetryCount == 0 ?
                        1 :
                        OrigRetryCount,
                    &DcDomainControllerInfo,
                    NULL );

    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "%ws: Cannot even find a DC much less a GC.\n",
                  Context->QueriedNetbiosDomainName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Make sure we know know the name of the forest.
    //

    if ( DcDomainControllerInfo->DnsForestName == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "%ws: DC %ws doesn't know the forest name so can't find a GC.\n",
                  Context->QueriedNetbiosDomainName,
                  DcDomainControllerInfo->DomainControllerName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    NlPrint(( NL_MAILSLOT,
              "%ws: DC %ws says the forest name is %ws.\n",
              Context->QueriedNetbiosDomainName,
              DcDomainControllerInfo->DomainControllerName,
              DcDomainControllerInfo->DnsForestName ));



    //
    // Compute the flags used for finding a GC given a forest name
    //
    //
    // If the caller wasn't explicit about the format of the returned name,
    //  be consistant with the original request.
    //

    LocalFlags = Context->QueriedFlags;
    if ( (LocalFlags & (DS_RETURN_FLAT_NAME|DS_RETURN_DNS_NAME)) == 0 ) {

        //
        // If the caller specified only a Netbios domain name,
        //  or if we didn't know whether the name was a DNS or netbios name,
        //  then we should return a netbios name to the caller.
        //
        // (In the later case, we can infer that the name is a netbios name
        //  since UsedNetbios is true.)
        //
        if ( Context->QueriedDnsDomainName == NULL ||
             (Context->QueriedInternalFlags & DS_NAME_FORMAT_AMBIGUOUS) != 0 ) {
            LocalFlags |= DS_RETURN_FLAT_NAME;
        }
    }

    LocalFlags |= DS_AVOID_SELF; // Already tried self

    //
    // Tell netlogon not to cache this failed attempt.
    //  The main routine will do it.
    //
    LocalInternalFlags = Context->QueriedInternalFlags;
    LocalInternalFlags |= DS_DONT_CACHE_FAILURE;

    //
    // Try to find a GC in the returned forest name
    //

    NetStatus = NetpDcGetName(
                    Context->SendDatagramContext,
                    Context->OurNetbiosComputerName,
                    NULL,   // No AccountName
                    0,      // No AccountControlBits
                    NULL,   // Do not specify the Netbios name for a GC search
                    DcDomainControllerInfo->DnsForestName,
                    DcDomainControllerInfo->DnsForestName,
                    NULL,   // RequestedDomainSid,
                    Context->QueriedDomainGuid,
                    Context->QueriedSiteName,
                    LocalFlags,
                    LocalInternalFlags,
                    TimeToWait,
                    OrigRetryCount == 0 ?
                        1 :
                        OrigRetryCount,
                    NULL,
                    &GcDomainControllerCacheEntry );

    if ( NetStatus != NO_ERROR ) {
        NlPrint(( NL_CRITICAL,
                  "%ws: Cannot find a GC in forest %ws.\n",
                  Context->QueriedNetbiosDomainName,
                  DcDomainControllerInfo->DnsForestName ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

Cleanup:

    //
    // Return the found GC to the caller.
    //

    if ( NetStatus == NO_ERROR ) {
        *DomainControllerCacheEntry = GcDomainControllerCacheEntry;
    } else if ( GcDomainControllerCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( GcDomainControllerCacheEntry );
    }

    if ( DcDomainControllerInfo != NULL ) {
        NetApiBufferFree( DcDomainControllerInfo );
    }

    return NetStatus;
}


DWORD
NetpGetBetterDc(
    IN PNL_GETDC_CONTEXT Context,
    IN DWORD OrigTimeout,
    IN DWORD OrigRetryCount,
    IN OUT PNL_DC_CACHE_ENTRY *NlDcCacheEntry
)

/*++

Routine Description:

    This routine decides whether a better DC can be found.  This routine
    is only found if we used netbios to find the current DC.  It allows
    us to overcome some of the weaknesses of netbios.

    If the found DC isn't in the closest site, we attempt to find one
    in the closest site using DNS.


Arguments:

    Context - Context describing the initial attempt to find a DC.

    NlDcCacheEntry - Passes in a pointer to a private
        PNL_DC_CACHE_ENTRY structure describing the original found DC.
        This structure may be dereferenced by this routine.

        If DomainControllerInfo is NULL, then NlDcCacheEntry returns a
        pointer to a private PNL_DC_CACHE_ENTRY
        structure describing the domain controller selected. The returned
        structure must be dereferenced using NetpDcDerefCacheEntry. This
        may be the original structure or a newly allocated one.

Return Value:

    The status code that is to be returned by the caller.

--*/
{
    NET_API_STATUS NetStatus;

    ULONG ElapsedTime;
    ULONG TimeToWait;
    ULONG LocalFlags = Context->QueriedFlags;
    ULONG LocalInternalFlags = Context->QueriedInternalFlags;
    LPWSTR LocalSiteName;

    PNL_DC_CACHE_ENTRY LocalDomainControllerCacheEntry;

    //
    //  If the DC we've got has a DNS domain name,
    //  and that DC told us what site we're in,
    //  and that DC isn't in the closest site.
    //  try to get a DC in that closest site.
    //

    if ( (*NlDcCacheEntry)->UnicodeDnsDomainName != NULL &&
         (*NlDcCacheEntry)->UnicodeClientSiteName != NULL &&
         ((*NlDcCacheEntry)->ReturnFlags & DS_CLOSEST_FLAG ) == 0 &&
         (Context->QueriedInternalFlags & DS_CLOSE_DC_NOT_NEEDED) == 0 ) {

        NlPrint(( NL_DNS,
                  "%ws %ws: Try to find a close DC using DNS\n",
                  (*NlDcCacheEntry)->UnicodeDnsDomainName,
                  (*NlDcCacheEntry)->UnicodeClientSiteName ));

    //
    // Otherwise, the original passed in DC is just fine.
    //
    } else {
        return NO_ERROR;
    }


    //
    // Reduce the timeout to be the time we haven't already spent.
    //  (But allow a minimum of 2 seconds)
    //

    ElapsedTime = NetpDcElapsedTime( Context->StartTime );

    if ( ElapsedTime < OrigTimeout ) {
        TimeToWait = max((OrigTimeout - ElapsedTime), NL_DC_MIN_ITERATION_TIMEOUT);
    } else {
        TimeToWait = NL_DC_MIN_ITERATION_TIMEOUT;
    }

#ifdef notdef
    NlPrint((NL_CRITICAL,
        "NetpGetBetterDc: timeout is %ld %ld %ld %ld\n",
        Context->StartTime,
        ElapsedTime,
        OrigTimeout,
        TimeToWait ));
#endif // notdef

    LocalFlags |= DS_AVOID_SELF; // Already tried self

    //
    // Adjust the InternalFlags to match the new request.
    //

    LocalSiteName = (LPWSTR) Context->QueriedSiteName;
    if ( LocalInternalFlags & DS_SITENAME_DEFAULTED ) {
        LocalInternalFlags &= ~DS_SITENAME_DEFAULTED;
        LocalSiteName = NULL;
    }

    //
    // This routine is called only if Netbios was used to
    //  discover the previously found DC. So, unless the
    //  caller required the DNS info be returned, we will
    //  return the Netbios format to the caller so ensure
    //  the Netbios format match for the better DC.
    //

    if ( (Context->QueriedFlags & DS_RETURN_DNS_NAME) == 0 ) {
        LocalFlags |= DS_RETURN_FLAT_NAME;
    }

    //
    // If the caller wasn't explicit about the format of the returned name,
    //  be consistant with the original request.
    //

    //
    // Tell netlogon not to cache this failed retry attempt.
    //
    LocalInternalFlags |= DS_DONT_CACHE_FAILURE;


    //
    // Go get the DC using DNS and an explicit site name
    // Request only the appropriate structure to be returned
    //

    NetStatus = NetpDcGetName(
                    Context->SendDatagramContext,
                    Context->OurNetbiosComputerName,
                    Context->QueriedAccountName,
                    Context->QueriedAllowableAccountControlBits,
                    NULL, // No Netbios domain name (Done that. Been there.)
                    (*NlDcCacheEntry)->UnicodeDnsDomainName,
                    Context->QueriedDnsForestName != NULL ?
                        Context->QueriedDnsForestName :
                        (*NlDcCacheEntry)->UnicodeDnsForestName,
                    NULL, // RequestedDomainSid,
                    Context->QueriedDomainGuid != NULL ?
                        Context->QueriedDomainGuid :
                        (IsEqualGUID( &(*NlDcCacheEntry)->DomainGuid, &NlDcZeroGuid) ?
                            NULL :
                            &(*NlDcCacheEntry)->DomainGuid ),
                    LocalSiteName != NULL ?
                        LocalSiteName :
                        (*NlDcCacheEntry)->UnicodeClientSiteName,
                    LocalFlags,
                    LocalInternalFlags,
                    TimeToWait,
                    OrigRetryCount == 0 ?
                        1 :
                        OrigRetryCount,
                    NULL,
                    &LocalDomainControllerCacheEntry );

    if ( NetStatus == NO_ERROR ) {
        NetpDcDerefCacheEntry( *NlDcCacheEntry );
        *NlDcCacheEntry = LocalDomainControllerCacheEntry;
    }

    return NO_ERROR;
}


DWORD
NetpDcGetName(
    IN PVOID SendDatagramContext OPTIONAL,
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    IN LPCWSTR DnsForestName OPTIONAL,
    IN PSID RequestedDomainSid OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    IN ULONG InternalFlags,
    IN DWORD Timeout,
    IN DWORD RetryCount,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo OPTIONAL,
    OUT PNL_DC_CACHE_ENTRY *DomainControllerCacheEntry OPTIONAL
)

/*++

Routine Description:


    NetpDcGetName is a worker function for DsGetDcName.  It has the following
    characteristics.  It is synchronous.  It executes in the caller (it does
    not RPC to Netlogon).  It implements a cache of responses.  The cache must
    previously have been initialized via NetpDcInitializeCache.  The cache should
    be free upon process cleanup (or DLL unload) using NetpDcUninitializeCache.

    The DsGetDcName API returns the name of a DC in a specified domain.
    The domain may be trusted (directly or indirectly) by the caller or
    may be untrusted.  DC selection criteria are supplied to the API to
    indicate preference for a DC with particular characteristics.

    The DsGetDcName API is available in an ANSI and UNICODE versions.

    The DsGetDcName API does not require any particular access to the
    specified domain.  DsGetDcName does not ensure the returned domain
    controller is currently available by default.  Rather, the caller
    should attempt to use the returned domain controller.  If the domain
    controller is indeed not available, the caller should repeat the
    DsGetDcName call specifying the DS_FORCE_REDISCOVERY flag.

    The DsGetDcName API is remoted to the Netlogon service on the machine
    specified by ComputerName.

Arguments:

    SendDatagramContext - Specifies context to pass a NlBrowserSendDatagram

    ComputerName - Specifies the NETBIOS name of this computer.
        If NULL, the name will be dynamically determined.

    AccountName - Account name to pass on the ping request.
        If NULL, no account name will be sent.

    AllowableAccountControlBits - Mask of allowable account types for AccountName.
        Valid bits are those specified by USER_MACHINE_ACCOUNT_MASK.
        Invalid bits are ignored.  If more than one bit is specified, the
        account can be of any of the specified types.

    NetbiosDomainName - The Netbios name of the domain to query.
        (e.g., microsoft). Either NetbiosDomainName or DnsDomainName or both
        must be specified.

    DnsDomainName - The DNS-style name of the domain to query.
        (e.g., microsoft.com)

    DnsForestName - The DNS-style name of the tree the queried domain is in.

    RequestedDomainSid - Sid of the domain the message is destined to.
        If NULL, no domain sid will be sent in the ping request.

    DomainGuid - Specifies the Domain GUID of the domain being queried.
        This value is used to handle the case of domain renames.  If this
        value is specified and DomainName has been renamed, DsGetDcName will
        attempt to locate a DC in the domain having this specified DomainGuid.

    SiteName - Specifies the site name of the site the returned DC should be
        "close" to.  The parameter should typically be the site name of the
        site the client is in.  If not specified, the site name defaults to
        the site of ComputerName.

    Flags - Passes additional information to be used to process the request.
        Flags can be a combination values bitwise or'ed together.

    InternalFlags - Internal Flags used to pass additional information

    Timeout - Maximum time (in milliseconds) caller is willing to wait on
        this operation.

    RetryCount - Number of times the "ping" will be sent within the Timeout period

    DomainControllerInfo - Returns a pointer to a DOMAIN_CONTROLLER_INFO
        structure describing the domain controller selected.  The returned
        structure must be deallocated using NetApiBufferFree.

    DomainControllerCacheEntry - Returns a pointer to an internal structure describing
        the domain controller selected. The structure is private and is not returned
        to an external caller. Either DomainControllerInfo or DomainControllerCacheEntry
        should be set on input. The returned structure must be dereferenced using
        NetpDcDerefCacheEntry.

Return Value:

    NO_ERROR: The NlDcCacheEntry was returned;

    ERROR_NO_SUCH_DOMAIN: No DC is available for the specified domain or
        the domain does not exist.

    ERROR_NO_SUCH_USER: A DC responded that the specified user account
        doesn't exist

    ERROR_INVALID_FLAGS - The flags parameter has conflicting or superfluous
        bits set.

    ERROR_INTERNAL_ERROR: Unhandled situation detected.

    ERROR_INVALID_DOMAINNAME: Domain's name is too long. Additional labels
        cannot be concatenated.

    ERROR_NOT_ENOUGH_MEMORY: Not enough memory is available to process
        this request.

    Various Winsock errors.

--*/
{
    NET_API_STATUS NetStatus;

    NL_GETDC_CONTEXT Context;
    PNL_DC_CACHE_ENTRY NlDcCacheEntry = NULL;
    BOOL UseIp = TRUE;
    BOOL UseNetbios = TRUE;
    BOOLEAN AtleastOneTimeout = FALSE;
    PVOID PingResponseMessage = NULL;
    DWORD PingResponseMessageSize;
    PLIST_ENTRY ListEntry;
    BOOLEAN OnlyTryOnce = FALSE;
    BOOL UsedNetbios;
    ULONG ExtraVersionBits = 0;

    ULONG ElapsedTime;
    ULONG IterationWaitTime;
    ULONG TimeToWait;
    LPWSTR LocalQueriedlNetbiosDomainName = NULL;

#ifdef _NETLOGON_SERVER

//
// Prevent any outer exception handler from obscuring bugs in this code.
//
try {
#endif // _NETLOGON_SERVER

    //
    // Treat zero length domain name as NULL.
    //

    if ( DnsDomainName != NULL && *DnsDomainName == L'\0' ) {
        DnsDomainName = NULL;
    }

    if ( DnsForestName != NULL && *DnsForestName == L'\0' ) {
        DnsForestName = NULL;
    }

    if ( NetbiosDomainName != NULL && *NetbiosDomainName == L'\0' ) {
        NetbiosDomainName = NULL;
    }

    //
    // Initialization
    //

    NetStatus = NetpDcInitializeContext(
                       SendDatagramContext,
                       ComputerName,
                       AccountName,
                       AllowableAccountControlBits,
                       NetbiosDomainName,
                       DnsDomainName,
                       DnsForestName,
                       RequestedDomainSid,
                       DomainGuid,
                       SiteName,
                       NULL,     // Not a ping request
                       NULL,     // No socket addresses
                       0,        // 0 socket addresses
                       Flags,
                       InternalFlags | DS_DOING_DC_DISCOVERY, // This is a DC discovery
                       NL_GETDC_CONTEXT_INITIALIZE_FLAGS,     // Flag initialization only
                       &Context );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }



    //
    // Ask Netlogon if this machine satisfies these requirements
    //  It's better to use the local machine than going out on the net and trying to
    //  discover one.
    //

    if ( Context.QueriedFlags & DS_GC_SERVER_REQUIRED ) {
        ExtraVersionBits |= NETLOGON_NT_VERSION_GC;
    }

    if ( Context.QueriedFlags & DS_IP_REQUIRED ) {
        ExtraVersionBits |= NETLOGON_NT_VERSION_IP;
    }

    if ( Context.QueriedFlags & DS_PDC_REQUIRED ) {
        ExtraVersionBits |= NETLOGON_NT_VERSION_PDC;
    }

#ifdef _NETLOGON_SERVER

    if ( NlGlobalParameters.NeutralizeNt4Emulator ) {
        ExtraVersionBits |= NETLOGON_NT_VERSION_AVOID_NT4EMUL;
    }

    if ( (Context.QueriedFlags & DS_AVOID_SELF) == 0 ) {
        LPSTR Utf8DnsDomainName = NULL;

        if ( DnsDomainName != NULL ) {
            Utf8DnsDomainName = NetpAllocUtf8StrFromWStr( DnsDomainName );
            if ( Utf8DnsDomainName == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
        }

        NetStatus = NlGetLocalPingResponse(
                        L"<Local>",
                        FALSE,   // not an LDAP ping
                        NetbiosDomainName,
                        Utf8DnsDomainName,
                        DomainGuid,
                        RequestedDomainSid,
                        Context.DcQueryType == NlDcQueryPdc,
                        Context.OurNetbiosComputerName,   // Netbios name of this computer
                        Context.QueriedAccountName,
                        Context.QueriedAllowableAccountControlBits,
                        LMNT_MESSAGE,
                        NETLOGON_NT_VERSION_5|NETLOGON_NT_VERSION_5EX|NETLOGON_NT_VERSION_5EX_WITH_IP|NETLOGON_NT_VERSION_LOCAL|ExtraVersionBits,
                        NULL,           // No incoming socket address
                        &PingResponseMessage,
                        &PingResponseMessageSize );

        if ( Utf8DnsDomainName != NULL ) {
            NetApiBufferFree( Utf8DnsDomainName );
        }

        if ( NetStatus != ERROR_NO_SUCH_DOMAIN ) {

            if (NetStatus != NO_ERROR ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetName: %ws: cannot get local ping response %ld\n",
                          Context.QueriedDisplayDomainName,
                          NetStatus));
                goto Cleanup;
            }


            //
            // See if this response meets our needs
            //

            NetStatus = NetpDcHandlePingResponse(
                            &Context,
                            PingResponseMessage,
                            PingResponseMessageSize,
                            NL_DC_CACHE_LOCAL,      // local response
                            NULL,
                            &NlDcCacheEntry,
                            &UsedNetbios );

            switch ( NetStatus ) {
            case ERROR_SEM_TIMEOUT:     // Doesn't match the request
            case ERROR_INVALID_DATA:    // Response is garbled
            case ERROR_NO_SUCH_USER:    // User doesn't exist on this DC
                break;
            default:
                goto Cleanup;
            }
        }
    }

    //
    // If this is primary DC discovery, first cache the DC info written by
    // the join process, if any. We will pick up this cached info later.
    // We do this even if the current DC discovery is more specific than
    // the generic DC discovery used by the join process. Indeed, the join
    // DC may turn out to be more specific and may satisfy the current request.
    //
    // This is a potentially lengthy operation since the DC will be pinged.
    //

    EnterCriticalSection(&NlDcCritSect);
    if ( !NlGlobalJoinLogicDone &&
         (Context.QueriedInternalFlags & DS_IS_PRIMARY_DOMAIN) != 0 ) {

        NlGlobalJoinLogicDone = TRUE;
        if ( NlCacheJoinDomainControllerInfo() == NO_ERROR ) {

            //
            // It is bogus to force rediscovery on the first attempt for
            // a particular type. For example, forcing discovery would
            // avoid the cache thereby mising the join DC we just cached.
            //
            Context.QueriedFlags &= ~DS_FORCE_REDISCOVERY;
        }
    }
    LeaveCriticalSection(&NlDcCritSect);
#endif // _NETLOGON_SERVER


    //
    // If discovery isn't being forced,
    //  do any optimizations that will speed getting the results to the caller.
    //

    if ( (Context.QueriedFlags & DS_FORCE_REDISCOVERY) == 0 ) {
        ULONG CacheEntryElapsedTime;
        DWORD NegativeCacheElapsedTime = 0xFFFFFFFF;
        ULONG CacheEntryRefreshPeriod  = 0xFFFFFFFF;  // Infinity
        BOOL SimilarQueryFailed = FALSE;
        BOOL ForcePing;

        //
        // If there is a cache entry for this operation,
        //  Use it.
        //

        NlDcCacheEntry = NetpDcFindCacheEntry( &Context, &UsedNetbios, &ForcePing );

        if ( NlDcCacheEntry != NULL ) {
            CacheEntryElapsedTime = NetpDcElapsedTime(NlDcCacheEntry->CreationTime);
        }

        //
        // If the cached DC is not close,
        //  check if it's time to re-discover a close one.
        //

        if ( NlDcCacheEntry != NULL &&
             (NlDcCacheEntry->CacheEntryFlags & NL_DC_CACHE_NONCLOSE_EXPIRE) != 0 &&
             CacheEntryElapsedTime > NL_DC_CLOSE_SITE_TIMEOUT ) {

            NlPrint(( NL_MISC,
                      "NetpDcGetName: %ws cache not for closest site and it is too old. %ld\n",
                      Context.QueriedDisplayDomainName,
                      NetpDcElapsedTime( NlDcCacheEntry->CreationTime ) ));

            NetpDcDerefCacheEntry( NlDcCacheEntry );
            NlDcCacheEntry = NULL;
        }

        //
        // Determine the appropriate cache entry refresh interval.
        //  Notice that a cache entry will never expire if we are
        //  not running in netlogon's process.
        //

#ifdef _NETLOGON_SERVER

        //
        // Get the value as configured in seconds
        //

        if ( Context.QueriedFlags & DS_BACKGROUND_ONLY ) {
            CacheEntryRefreshPeriod = NlGlobalParameters.BackgroundSuccessfulRefreshPeriod;
        } else {
            CacheEntryRefreshPeriod = NlGlobalParameters.NonBackgroundSuccessfulRefreshPeriod;
        }

        // If the value converted into milliseconds fits into a ULONG, use it
        if ( CacheEntryRefreshPeriod <= MAXULONG/1000 ) {
            CacheEntryRefreshPeriod *= 1000;    // convert to milliseconds

        // Otherwise, use the max ULONG
        } else {
            CacheEntryRefreshPeriod = MAXULONG; // infinity
        }
#endif // _NETLOGON_SERVER

        //
        // If this cache entry is too old,
        //  ping the DC to see if it still plays the same role.
        //

        if ( NlDcCacheEntry != NULL &&
             (ForcePing ||
              CacheEntryElapsedTime > CacheEntryRefreshPeriod) ) {

            if ( ForcePing ) {
                NlPrint(( NL_MISC,
                          "NetpDcGetName: %ws cache doesn't have right account name.\n",
                          Context.QueriedDisplayDomainName ));
            } else {
                NlPrint(( NL_MISC,
                          "NetpDcGetName: %ws cache is too old. %ld\n",
                          Context.QueriedDisplayDomainName,
                          NetpDcElapsedTime( NlDcCacheEntry->CreationTime ) ));
            }

            //
            // Indicate which mechanism should be used to ping the DC
            //

            if ( NlDcCacheEntry->CacheEntryFlags & NL_DC_CACHE_LDAP ) {

                //
                // Add the cached DC address to the list of quried addresses
                //
                if ( NlDcCacheEntry->SockAddr.iSockaddrLength != 0 ) {
                    NetStatus = NetpDcProcessAddressList( &Context,
                                                          NlDcCacheEntry->UnicodeDnsHostName,
                                                          &NlDcCacheEntry->SockAddr,
                                                          1,
                                                          FALSE,  // Don't know if site specific
                                                          NULL );
                    if ( NetStatus != NO_ERROR ) {
                        goto Cleanup;
                    }

                    //
                    // Prefer DNS name for ldap pings
                    //
                    if ( NlDcCacheEntry->UnicodeDnsHostName != NULL ) {
                        Context.QueriedDcName = NlDcCacheEntry->UnicodeDnsHostName;
                        Context.QueriedInternalFlags |= DS_PING_DNS_HOST;
                    } else if ( NlDcCacheEntry->UnicodeNetbiosDcName != NULL ) {
                        Context.QueriedDcName = NlDcCacheEntry->UnicodeNetbiosDcName;
                        Context.QueriedInternalFlags |= DS_PING_NETBIOS_HOST;
                    }
                    Context.QueriedInternalFlags |= DS_PING_USING_LDAP;
                } else {
                    NlPrint(( NL_CRITICAL,
                              "NetpDcGetName: %ws cache says use ldap but has no address\n",
                              Context.QueriedDisplayDomainName ));
                }

            } else if ( NlDcCacheEntry->CacheEntryFlags & NL_DC_CACHE_MAILSLOT ) {

                //
                // We must have Netbios name for mailslot pings
                //
                if ( NlDcCacheEntry->UnicodeNetbiosDcName != NULL &&
                     NlDcCacheEntry->UnicodeNetbiosDomainName != NULL ) {
                    Context.QueriedDcName = NlDcCacheEntry->UnicodeNetbiosDcName;

                    //
                    // If we don't have the Netbios domain name in Context,
                    //  use the one from the cache entry
                    //
                    if ( Context.QueriedNetbiosDomainName == NULL ) {
                        LocalQueriedlNetbiosDomainName =
                            NetpAllocWStrFromWStr( NlDcCacheEntry->UnicodeNetbiosDomainName );
                        if ( LocalQueriedlNetbiosDomainName == NULL ) {
                            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                            goto Cleanup;
                        }
                        Context.QueriedNetbiosDomainName = LocalQueriedlNetbiosDomainName;
                    }
                    Context.QueriedInternalFlags |= DS_PING_NETBIOS_HOST;
                    Context.QueriedInternalFlags |= DS_PING_USING_MAILSLOT;
                } else {
                    NlPrint(( NL_CRITICAL,
                              "NetpDcGetName: %ws cache says use maislot but has no Netbios name\n",
                              Context.QueriedDisplayDomainName ));
                }
            }

            //
            // Ping the DC using the specified mechanism
            //

            if ( Context.QueriedInternalFlags & (DS_PING_DNS_HOST|DS_PING_NETBIOS_HOST) ) {
                ULONG PingStartTime;
                ULONG PingElapsedTime;
                PNL_DC_CACHE_ENTRY PingedNlDcCacheEntry = NULL;

                //
                // Do the ping part initialization of Context.
                //  Some of the arguments passed below are ignored by the API.
                //  Instead, the corresponding fields of Context initialized
                //  in the flag part of the context initialization are used.
                //

                NetStatus = NetpDcInitializeContext(
                                   SendDatagramContext,
                                   ComputerName,
                                   AccountName,
                                   Context.QueriedAllowableAccountControlBits,
                                   NetbiosDomainName, // Ignored for ping initialization
                                   DnsDomainName,     // Ignored for ping initialization
                                   DnsForestName,     // Ignored for ping initialization
                                   RequestedDomainSid,
                                   DomainGuid,        // Ignored for ping initialization
                                   SiteName,          // Ignored for ping initialization
                                   NULL,              // Quieried DC name has been just set
                                   NULL,              // Socket address has been just set
                                   0,                 // No socket addresses passed here
                                   Flags,             // Ignored for ping initialization
                                   InternalFlags,     // Ignored for ping initialization
                                   NL_GETDC_CONTEXT_INITIALIZE_PING, // Ping initialization
                                   &Context );

                if ( NetStatus != NO_ERROR ) {
                    NetpDcDerefCacheEntry( NlDcCacheEntry );
                    NlDcCacheEntry = NULL;
                    goto Cleanup;
                }

                //
                // Ping the cached DC name
                //
                // We send one ping and wait for maximum time
                //  that we give to a ping response. If the DC
                //  is slow to respond here, it will be given the
                //  second chance since we will leave its address
                //  at the front of the list. (Here we assume that
                //  the ping is LDAP. If it's mailslot, the 0.4 second
                //  timeout should be large enough for the datagram
                //  response time; however, the DC will not be prefered
                //  later if it's slow to respond here)
                //

                PingStartTime = GetTickCount();

                NetStatus = NlPingDcNameWithContext(
                               &Context,
                               1,                   // Send 1 ping
                               TRUE,                // Wait for response
                               NL_DC_MAX_PING_TIMEOUT, // Give maximum timeout per ping
                               &UsedNetbios,
                               &PingedNlDcCacheEntry );

                //
                // Clear all ping related bits to not confuse the DC
                //  discovery if it happens. But leave the Netbios domain
                //  name and the DC address on the list to validate the
                //  DC's response if it happens to arrive after the 0.5
                //  second timeout.
                //

                Context.QueriedDcName = NULL;
                Context.QueriedInternalFlags &= ~( DS_PING_DNS_HOST |
                                                   DS_PING_NETBIOS_HOST |
                                                   DS_PING_USING_LDAP |
                                                   DS_PING_USING_MAILSLOT );

                //
                // On success, update the cache entry. The new cache entry
                //  returned from the pinged DC may contain new information
                //  such as a new client site name. So we want to use it
                //  instead of the currently cached one.
                //

                NetpDcDerefCacheEntry( NlDcCacheEntry );
                NlDcCacheEntry = NULL;

                if ( NetStatus == NO_ERROR ) {
                    NlDcCacheEntry = PingedNlDcCacheEntry;
                }

                //
                // Update the timeout.
                //

                PingElapsedTime = NetpDcElapsedTime( PingStartTime );
                if ( Timeout > PingElapsedTime ) {
                    Timeout -= PingElapsedTime;
                }

            //
            // If we have no ping mechanism for this cache entry, ditch it
            //

            } else {
                NetpDcDerefCacheEntry( NlDcCacheEntry );
                NlDcCacheEntry = NULL;
            }
        }

        if ( NlDcCacheEntry != NULL ) {
            NlPrint(( NL_MISC,
                      "NetpDcGetName: %ws using cached information\n",
                      Context.QueriedDisplayDomainName ));
            NetStatus = NO_ERROR;
            goto Cleanup;
        }

#ifdef _NETLOGON_SERVER
        //
        // Since there is no cache entry,
        //  check if we've attempted to find a DC recently.
        //

        EnterCriticalSection(&NlDcCritSect);
        if ( Context.NlDcDomainEntry->Dc[Context.DcQueryType].NegativeCacheTime != 0 ) {
            NegativeCacheElapsedTime = NetpDcElapsedTime( Context.NlDcDomainEntry->Dc[Context.DcQueryType].NegativeCacheTime );

            //
            // If this couldn't be discovered in the last 45 seconds,
            //
            if ( NegativeCacheElapsedTime < (NlGlobalParameters.NegativeCachePeriod*1000) ) {
                NlPrint(( NL_MISC,
                          "NetpDcGetName: %ws similar query failed recently %ld\n",
                          Context.QueriedDisplayDomainName,
                          NegativeCacheElapsedTime ));
                NetStatus = ERROR_NO_SUCH_DOMAIN;
                Context.AvoidNegativeCache = TRUE;
                LeaveCriticalSection(&NlDcCritSect);
                goto Cleanup;
            }

            //
            // The negative cache timeout hasn't elapsed yet.
            //  But indicate that similar query failed in the past
            //  to make a decision as to whether we want to retry
            //  the DC discovery for background callers below.
            //
            SimilarQueryFailed = TRUE;
        }

        //
        // If the caller wants an NT5 (or newer) DC but we know
        //  this domain is NT4, adjust the negative cache elapsed
        //  time to be the time passed since the latest failure for
        //  similar query.
        //

        if ( (Context.QueriedFlags & DS_NT50_WANTED) != 0 &&
             Context.NlDcDomainEntry->InNt4Domain ) {
            DWORD InNt4DomainElapsedTime;

            InNt4DomainElapsedTime = NetpDcElapsedTime( Context.NlDcDomainEntry->InNt4DomainTime );
            if ( InNt4DomainElapsedTime < NegativeCacheElapsedTime ) {
                NegativeCacheElapsedTime = InNt4DomainElapsedTime;
            }

            //
            // Indicate that similar query failed in the past
            //
            SimilarQueryFailed = TRUE;
        }

        //
        // If the caller only wants a DC for a background task
        //  and we know a similar query failed in the past,
        //  see if it is time to try again.
        //

        if ( (Context.QueriedFlags & DS_BACKGROUND_ONLY) != 0 && SimilarQueryFailed ) {

            if ( NegativeCacheElapsedTime < (Context.NlDcDomainEntry->Dc[Context.DcQueryType].ExpBackoffPeriod*1000) ) {
                NlPrint(( NL_MISC,
                          "NetpDcGetName: %ws similar background query failed recently %ld\n",
                          Context.QueriedDisplayDomainName,
                          NegativeCacheElapsedTime ));
                NetStatus = ERROR_NO_SUCH_DOMAIN;
                Context.AvoidNegativeCache = TRUE;
                LeaveCriticalSection(&NlDcCritSect);
                goto Cleanup;
            }

            //
            // If we've already spent all the time we're willing to spend on
            //  background tasks, blow this one away.
            //

            if ( NlGlobalParameters.BackgroundRetryQuitTime != 0 &&
                 NlTimeHasElapsedEx(
                    &Context.NlDcDomainEntry->Dc[Context.DcQueryType].BackgroundRetryInitTime,
                    &NlGlobalParameters.BackgroundRetryQuitTime_100ns,
                    NULL ) ) {

                NlPrint(( NL_MISC,
                          "NetpDcGetName: %ws avoiding all future background queries\n",
                          Context.QueriedDisplayDomainName ));
                NetStatus = ERROR_NO_SUCH_DOMAIN;
                Context.AvoidNegativeCache = TRUE;
                LeaveCriticalSection(&NlDcCritSect);
                goto Cleanup;
            }

            //
            // If the negative cache entry has been marked permanent,
            //  blow this one away.
            //

            if ( Context.NlDcDomainEntry->Dc[Context.DcQueryType].PermanentNegativeCache ) {

                NlPrint(( NL_MISC,
                          "NetpDcGetName: %ws is permanently negative cached.\n",
                          Context.QueriedDisplayDomainName ));
                NetStatus = ERROR_NO_SUCH_DOMAIN;
                Context.AvoidNegativeCache = TRUE;
                LeaveCriticalSection(&NlDcCritSect);
                goto Cleanup;
            }


            //
            // We're going to try again.
            //  Adjust the exponential backoff period.
            //

            Context.NlDcDomainEntry->Dc[Context.DcQueryType].ExpBackoffPeriod *= 2;

            if ( Context.NlDcDomainEntry->Dc[Context.DcQueryType].ExpBackoffPeriod >
                 NlGlobalParameters.BackgroundRetryMaximumPeriod ) {

                Context.NlDcDomainEntry->Dc[Context.DcQueryType].ExpBackoffPeriod =
                     NlGlobalParameters.BackgroundRetryMaximumPeriod;

            }
        }

        LeaveCriticalSection(&NlDcCritSect);
#endif // _NETLOGON_SERVER

        //
        // If a good time server is preferred,
        //  and we already have a suitable cache entry,
        //  only try once to find a good time server.
        //

        if ( (Context.QueriedFlags & DS_GOOD_TIMESERV_PREFERRED) != 0 &&
             Context.ImperfectCacheEntry != NULL ) {

            //
            // Don't cache the fact that we couldn't find a DC.
            //

            Context.AvoidNegativeCache = TRUE;

            NlPrint(( NL_MISC,
                      "NetpDcGetName: %ws: Only try once to find good timeserver.\n",
                      Context.QueriedDisplayDomainName ));
            OnlyTryOnce = TRUE;
        }

        //
        // If an NT 5.0 DC is wanted,
        //  handle the case where we know we're in an NT 4.0 domain.
        //

        if ((Context.QueriedFlags & DS_NT50_WANTED) != 0 ) {

            EnterCriticalSection(&NlDcCritSect);
            if ( Context.NlDcDomainEntry->InNt4Domain ) {

                //
                // If we recently found that this was an NT 4.0 domain,
                //  fail the call immediately.
                //

                if ( NetpDcElapsedTime(Context.NlDcDomainEntry->InNt4DomainTime) <= NL_NT4_AVOIDANCE_TIME ) {

                    //
                    // If the caller only prefers an NT 5.0 machine,
                    //  let him find an NT 4.0 DC normally.
                    //

                    if ( Context.QueriedFlags & DS_DIRECTORY_SERVICE_PREFERRED ) {

                        //
                        // If we had an NT 4 DC cached,
                        //  Use it now.
                        //

                        if ( Context.ImperfectCacheEntry != NULL ) {
                            LeaveCriticalSection(&NlDcCritSect);
                            NlDcCacheEntry = Context.ImperfectCacheEntry;
                            UsedNetbios = Context.ImperfectUsedNetbios;
                            Context.ImperfectCacheEntry = NULL;
                            NlPrint(( NL_MISC,
                                      "NetpDcGetName: %ws: Avoid finding NT 5.0 DC in NT 4.0 domain (Use previously cached entry.)\n",
                                      Context.QueriedDisplayDomainName ));
                            NetStatus = NO_ERROR;
                            goto Cleanup;
                        }

                        Context.QueriedFlags &= ~DS_DIRECTORY_SERVICE_PREFERRED;
                        NlPrint(( NL_MISC,
                                  "NetpDcGetName: %ws: Avoid finding NT 5.0 DC in NT 4.0 domain (Ditch preferred)\n",
                                  Context.QueriedDisplayDomainName ));

                    //
                    // If the caller needs an NT 5.0 DC,
                    //  fail the call immediately.
                    //
                    } else {

                        //
                        // Don't cache the fact that we couldn't find a DC.
                        //  The InNt4Domain cache is more sophisticated than the
                        //  simple negative cache.
                        //

                        Context.AvoidNegativeCache = TRUE;

                        LeaveCriticalSection(&NlDcCritSect);
                        NlPrint(( NL_MISC,
                                  "NetpDcGetName: %ws: Avoid finding NT 5.0 DC in NT 4.0 domain\n",
                                  Context.QueriedDisplayDomainName ));
                        NetStatus = ERROR_NO_SUCH_DOMAIN;
                        goto Cleanup;
                    }

                //
                // If it's been a while since we found out,
                //  we'll retry the operation (but only once).
                //
                // This minimizes the cost, but still allows us to find an NT 5 DC
                //  if it was just temporarily down.
                //

                } else {

                    //
                    // Don't cache the fact that we couldn't find a DC.
                    //  The InNt4Domain cache is more sophisticated than the
                    //  simple negative cache.
                    //

                    Context.AvoidNegativeCache = TRUE;

                    NlPrint(( NL_MISC,
                              "NetpDcGetName: %ws: Only try once to find NT 5.0 DC in NT 4.0 domain.\n",
                              Context.QueriedDisplayDomainName ));
                    OnlyTryOnce = TRUE;

                }

            }
            LeaveCriticalSection(&NlDcCritSect);
        }
    }

    //
    // If we did not initialize the ping part of Context earlier
    //  to do host pings, do it here.
    //

    if ( Context.LdapFilter == NULL && Context.PingMessage == NULL ) {
        NetStatus = NetpDcInitializeContext(
                           SendDatagramContext,
                           ComputerName,
                           AccountName,
                           Context.QueriedAllowableAccountControlBits,
                           NetbiosDomainName,
                           DnsDomainName,
                           DnsForestName,
                           RequestedDomainSid,
                           DomainGuid,
                           SiteName,
                           NULL,     // Not a ping request
                           NULL,     // No socket addresses
                           0,        // 0 socket addresses
                           Flags,
                           InternalFlags,
                           NL_GETDC_CONTEXT_INITIALIZE_PING,  // Ping part initialization
                           &Context );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    //
    // Loop until we've made several attempts to find the DC
    //

    Context.StartTime = GetTickCount();

    for ( Context.TryCount = 0;
          Context.TryCount < RetryCount;
          Context.TryCount ++ ) {

        //
        // If a DNS domain name is known,
        //  use DNS to find a DC.
        //

        if ( Context.QueriedDnsDomainName == NULL ) {
            UseIp = FALSE;

        } else if ( UseIp ) {

            //
            // Try using DNS/IP to find the DC.
            //

            NetStatus = NetpDcGetNameIp(
                            &Context,
                            &NlDcCacheEntry,
                            &UsedNetbios );

            //
            // If we found it,
            //  return it.
            //

            if ( NetStatus == NO_ERROR ) {
                goto Cleanup;

            //
            // If DNS isn't configured,
            //  mark that we don't want to try DNS again.
            //  (Drop through to Netbios.)
            //

            } else if ( NetStatus == ERROR_DNS_NOT_CONFIGURED ) {
                UseIp = FALSE;

            //
            // If DNS has the name registered,
            //  but the DCs haven't yet responded,
            //  indicate we need to keep on waiting.
            //  (Drop through to Netbios.)
            //

            } else if ( NetStatus == ERROR_SEM_TIMEOUT ) {
                AtleastOneTimeout = TRUE;

            //
            // If DNS doesn't have the name registered,
            //  indicate we don't need to try DNS again.
            //  (Drop through to Netbios.)
            //

            } else if ( NetStatus == ERROR_NO_SUCH_DOMAIN ) {
                UseIp = FALSE;

            //
            // All other problems are DNS detected errors to return to
            //  the caller.
            //
            } else {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetName: %ws: cannot find DC via IP/DNS %ld\n",
                          Context.QueriedDisplayDomainName,
                          NetStatus));
                goto Cleanup;
            }
        }

        //
        // If a Netbios domain name is known,
        //  use Netbios to find a DC.
        //

        if ( Context.QueriedNetbiosDomainName == NULL ) {
            UseNetbios = FALSE;

        } else if ( UseNetbios ) {
            NetStatus = NetpDcGetNameNetbios(
                            &Context,
                            &NlDcCacheEntry,
                            &UsedNetbios );


            //
            // If we found it,
            //  return it.
            //

            if ( NetStatus == NO_ERROR ) {
                goto Cleanup;

            //
            // If Netbios sent the datagram successfully,
            //  but the DCs haven't yet responded,
            //  indicate we need to keep on waiting.
            //  (Drop through to next iteration.)
            //

            } else if ( NetStatus == ERROR_SEM_TIMEOUT ) {
                AtleastOneTimeout = TRUE;

            //
            // If Netbios couldn't send the datagram,
            //  indicate we don't need to try Netbios again.
            //  (Drop through to next iteration.)
            //

            } else if ( NetStatus == ERROR_NO_SUCH_DOMAIN ) {
                UseNetbios = FALSE;

            //
            // All other problems are DNS detected errors to return to
            //  the caller.
            //
            } else {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetName: %ws: cannot find DC via Netbios %ld\n",
                          Context.QueriedDisplayDomainName,
                          NetStatus));
                goto Cleanup;
            }
        }

        //
        // If there are no more mechanisms to try,
        //  we're done.
        //

        if ( !UseIp && !UseNetbios ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcGetName: %ws: IP and Netbios are both done.\n",
                      Context.QueriedDisplayDomainName ));
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }


        //
        // If no datagrams were sent successfully,
        //  we're done.
        //

        if ( !AtleastOneTimeout ) {
            NlPrint(( NL_CRITICAL,
                      "NetpDcGetName: %ws: no datagrams were sent\n",
                      Context.QueriedDisplayDomainName ));
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        //
        // If we should only try once,
        //  we've done that first try.
        //

        if ( OnlyTryOnce ) {

            //
            // Wait a short amount of time to ensure the response has a chance
            //  to reach us.
            //

            NetStatus = NetpDcGetPingResponse(
                            &Context,
                            NL_NT4_ONE_TRY_TIME,
                            &NlDcCacheEntry,
                            &UsedNetbios );

            if ( NetStatus != ERROR_SEM_TIMEOUT ) {
                if ( NetStatus != NO_ERROR ) {
                    NlPrint(( NL_CRITICAL,
                              "NetpDcGetName: %ws: Cannot NetpDcGetPingResponse. %ld\n",
                              Context.QueriedDisplayDomainName,
                              NetStatus ));
                }
                goto Cleanup;
            }

            //
            // So we couldn't get an NT5 DC (or a good time server).
            //
            // If the caller requires an NT 5.0 DC,
            //  we're done so error out early.
            //

            if ( (Context.QueriedFlags & (DS_DIRECTORY_SERVICE_PREFERRED|DS_GOOD_TIMESERV_PREFERRED)) == 0 ) {
                NlPrint(( NL_MISC,
                          "NetpDcGetName: %ws: Only try once done.\n",
                          Context.QueriedDisplayDomainName ));
                break;
            }

            //
            // If an NT 4 DC has already been found,
            //  (or a non-good time server has already been found),
            //  use it since the caller didn't require NT5 DC
            //  (or a good time server).
            //

            if ( Context.ImperfectCacheEntry != NULL ) {
                if ( Context.QueriedFlags & DS_DIRECTORY_SERVICE_PREFERRED ) {
                    NlPrint(( NL_MISC,
                              "NetpDcGetName: %ws: Tried once to find NT 5.0 DC (Using found NT 4.0 DC).\n",
                              Context.QueriedDisplayDomainName ));
                } else if (Context.QueriedFlags & DS_GOOD_TIMESERV_PREFERRED) {
                    NlPrint(( NL_MISC,
                              "NetpDcGetName: %ws: Tried once to find good timeserver (Using previously found DC).\n",
                              Context.QueriedDisplayDomainName ));
                }

                //
                // Drop through to handle this in the cleanup section
                //
                NetStatus = ERROR_NO_SUCH_DOMAIN;
                goto Cleanup;
            }

            //
            // Here we don't have an imperfect cache entry and the caller
            //  doesn't require an NT5 DC. Let him continue to find an
            //  NT 4.0 DC normally.
            //

            Context.QueriedFlags &= ~DS_DIRECTORY_SERVICE_PREFERRED;
            NlPrint(( NL_MISC,
                      "NetpDcGetName: %ws: Only try once reset.\n",
                      Context.QueriedDisplayDomainName ));
            OnlyTryOnce = FALSE;


        }


        //
        // Wait up to 1/RetryCount'th of the total available time for responses to come back.
        //  The caller will either resort to a less preferable candidate or
        //  will repeat the pings.  In either case, we'd rather this candidate won.
        //
        // Always wait a short amount of time here.  Consider the case that DNS
        // took 20 seconds to find that there was no DNS server.  We still want
        // to give Netbios a decent amount of time to find a DC.
        //


        ElapsedTime = NetpDcElapsedTime( Context.StartTime );

#ifdef notdef
        NlPrint((NL_CRITICAL,
            "NetpDcGetName: timeout is %ld %ld %ld %ld\n",
            Context.StartTime,
            ElapsedTime,
            Timeout,
            Context.TryCount ));
#endif // notdef

        IterationWaitTime = (Timeout*(Context.TryCount+1))/RetryCount;

        if ( IterationWaitTime > ElapsedTime &&
             (IterationWaitTime - ElapsedTime) > NL_DC_MIN_ITERATION_TIMEOUT ) {
            TimeToWait = IterationWaitTime - ElapsedTime;
        } else {
            TimeToWait = NL_DC_MIN_ITERATION_TIMEOUT;
        }

        NetStatus = NetpDcGetPingResponse(
                        &Context,
                        TimeToWait,
                        &NlDcCacheEntry,
                        &UsedNetbios );

        if ( NetStatus != ERROR_SEM_TIMEOUT ) {
            if ( NetStatus != NO_ERROR ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetName: %ws: Cannot NetpDcGetPingResponse. %ld\n",
                          Context.QueriedDisplayDomainName,
                          NetStatus ));
            }
            goto Cleanup;
        }

        //
        // If at least one NT 4.0 DC is available in the domain,
        //  and no NT 5.0 DCs (of any type) are available,
        //  and we asked for an NT 5.0 DC,
        //  early out now since our caller is impatient.
        //
        // Don't be tempted to leave out the last test.  If we're not
        // explicitly asking for an NT 5.0 DC, we might not ping any NT 5.0 DCs
        // even though they exist in the domain.
        //
        //

        if ( Context.NonDsResponse &&
             !Context.DsResponse &&
             (Context.QueriedFlags & DS_NT50_REQUIRED) != 0 ) {

            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;

        }

        //
        // If we've waited long enough for a perfect DC,
        //  drop out an use the imperfect one.
        //

        if ( Context.ImperfectCacheEntry != NULL ) {
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

    }

    //
    // Tried two times and still can't find one.
    //

    NetStatus = ERROR_NO_SUCH_DOMAIN;


Cleanup:

    ////////////////////////////////
    //                            //
    // First, hanle failure cases //
    //                            //
    ////////////////////////////////

    //
    // If the problem is simply that the DCs don't have a user account for the named user,
    //  change the status code.
    //

    if ( NetStatus == ERROR_NO_SUCH_DOMAIN && Context.NoSuchUserResponse ) {
        NetStatus = ERROR_NO_SUCH_USER;
    }

    //
    // If no DC has been found so far,
    //  handle it.
    //

    if ( NetStatus == ERROR_NO_SUCH_DOMAIN ) {

        //
        // If there is a cache entry that might not be perfect,
        //  see if it is satisfactory.
        //

        if ( Context.ImperfectCacheEntry != NULL ) {

            //
            // Handle NT 4 DC found when DS preferred.
            //
            if ( Context.QueriedFlags & DS_DIRECTORY_SERVICE_PREFERRED ) {

                //
                // If we actually attempted to discover a NT5 DC and
                //  found only NT4 DC, reset the InNt4DomainTime stamp
                //
                if ( Context.NonDsResponse && !Context.DsResponse ) {
                    EnterCriticalSection(&NlDcCritSect);
                    Context.NlDcDomainEntry->InNt4Domain = TRUE;
                    Context.NlDcDomainEntry->InNt4DomainTime = GetTickCount();
                    LeaveCriticalSection(&NlDcCritSect);
                    NlPrint(( NL_MISC,
                              "NetpDcGetName: %ws: Domain is a _new_ NT 4.0 domain.\n",
                              Context.QueriedDisplayDomainName ));
                } else {
                    NlPrint(( NL_MISC,
                              "NetpDcGetName: %ws: Domain is still NT 4.0 domain.\n",
                              Context.QueriedDisplayDomainName ));
                }

                NlDcCacheEntry = Context.ImperfectCacheEntry;
                UsedNetbios = Context.ImperfectUsedNetbios;
                Context.ImperfectCacheEntry = NULL;
                NetStatus = NO_ERROR;

            //
            // Handle regular timeserv found when good timeserv preferred.
            //

            } else if (Context.QueriedFlags & DS_GOOD_TIMESERV_PREFERRED) {
                NlPrint(( NL_MISC,
                          "NetpDcGetName: %ws: Domain has no good timeserv.\n",
                          Context.QueriedDisplayDomainName ));

                NlDcCacheEntry = Context.ImperfectCacheEntry;
                UsedNetbios = Context.ImperfectUsedNetbios;
                Context.ImperfectCacheEntry = NULL;
                NetStatus = NO_ERROR;

            }
        }
    }

    //
    // If this is a failed attempt to find a GC using a netbios name,
    //  try to find a DC then using the forest name returned from that DC.
    //
    // If the DNS name is different than the netbios name,
    //  that DNS has already been given a chance.
    //

    if ( NetStatus == ERROR_NO_SUCH_DOMAIN &&
         NlDnsGcName(Context.QueriedNlDnsNameType) &&
         Context.QueriedNetbiosDomainName != NULL &&
         ( Context.QueriedDnsDomainName == NULL ||
           _wcsicmp( Context.QueriedDnsDomainName,
                     Context.QueriedNetbiosDomainName ) == 0 ) ) {

        NetStatus = NetpGetGcUsingNetbios(
                                &Context,
                                Timeout,
                                RetryCount,
                                &NlDcCacheEntry );

        //
        // If this was successful, we certainly used DNS
        //
        if ( NetStatus == NO_ERROR ) {
            UsedNetbios = FALSE;
        }
    }

    //
    // If still no such dc could be found,
    //   update the cache appropriately.
    //

    if ( NetStatus == ERROR_NO_SUCH_DOMAIN ) {

        //
        // If at least one NT 4.0 DC is available in the domain,
        //  and no NT 5.0 DCs (of any type) are available,
        //  and we asked for an NT 5.0 DC,
        //  flag that this is an NT 4.0 domain.
        //
        // Don't be tempted to leave out the last test.  If we're not
        // explicitly asking for an NT 5.0 DC, we might not ping any NT 5.0 DCs
        // even though they exist in the domain.
        //
        //

        if ( Context.NonDsResponse &&
             !Context.DsResponse &&
             (Context.QueriedFlags & DS_NT50_REQUIRED) != 0 ) {

            EnterCriticalSection(&NlDcCritSect);
            Context.NlDcDomainEntry->InNt4Domain = TRUE;
            Context.NlDcDomainEntry->InNt4DomainTime = GetTickCount();
            LeaveCriticalSection(&NlDcCritSect);
            NlPrint(( NL_MISC,
                      "NetpDcGetName: %ws: Domain is an NT 4.0 domain.\n",
                      Context.QueriedDisplayDomainName ));

        }

        //
        // If this call isn't a retry of a successful query.
        //  update the cache to reflect this failure.
        //

        if ( (Context.QueriedInternalFlags & DS_DONT_CACHE_FAILURE) == 0 ) {

            //
            // If this was a forced attempt to find a DC,
            //  delete any existing cache entry.
            //
            // There's no use keeping this entry around.
            //
            if ( Context.QueriedFlags & DS_FORCE_REDISCOVERY ) {
                EnterCriticalSection( &NlDcCritSect );
                if ( Context.NlDcDomainEntry->Dc[Context.DcQueryType].NlDcCacheEntry != NULL ) {
                    NlPrint(( NL_DNS_MORE,
                              "Cache: %ws %ws: Ditch cache entry %ld since force couldn't find DC\n",
                              Context.NlDcDomainEntry->UnicodeNetbiosDomainName,
                              Context.NlDcDomainEntry->UnicodeDnsDomainName,
                              Context.DcQueryType ));
                    NetpDcDerefCacheEntry( Context.NlDcDomainEntry->Dc[Context.DcQueryType].NlDcCacheEntry );
                    Context.NlDcDomainEntry->Dc[Context.DcQueryType].NlDcCacheEntry = NULL;
                }
                LeaveCriticalSection( &NlDcCritSect );
            }

#ifdef _NETLOGON_SERVER
            //
            // Cache the fact that we couldn't find a DC.
            //

            if ( !Context.AvoidNegativeCache ) {
                EnterCriticalSection( &NlDcCritSect );
                Context.NlDcDomainEntry->Dc[Context.DcQueryType].NegativeCacheTime =
                    GetTickCount();
                LeaveCriticalSection( &NlDcCritSect );
            }

#endif // _NETLOGON_SERVER
        }
    }

    //
    // Initialize the first background failure time if:
    //
    // This is failed attempt and we don't have a reason
    //  not to cache it
    //
    // OR
    //
    // This is failed attempt and the caller wanted a NT5
    //  DC but this is a NT4 domain
    //

#ifdef _NETLOGON_SERVER
    if ( (NetStatus == ERROR_NO_SUCH_DOMAIN &&
          (Context.QueriedInternalFlags & DS_DONT_CACHE_FAILURE) == 0 &&
          !Context.AvoidNegativeCache)

         ||  // OR

         (NetStatus == ERROR_NO_SUCH_DOMAIN &&
          (Context.QueriedFlags & DS_NT50_WANTED) != 0 &&
          Context.NlDcDomainEntry != NULL &&
          Context.NlDcDomainEntry->InNt4Domain) ) {

        EnterCriticalSection( &NlDcCritSect );

        //
        // If this is the first failure,
        //  cache the time of the first failure.
        //
        if ( Context.NlDcDomainEntry->Dc[Context.DcQueryType].BackgroundRetryInitTime.QuadPart == 0 ) {

            NlQuerySystemTime ( &Context.NlDcDomainEntry->Dc[Context.DcQueryType].BackgroundRetryInitTime );

            Context.NlDcDomainEntry->Dc[Context.DcQueryType].ExpBackoffPeriod =
                NlGlobalParameters.BackgroundRetryInitialPeriod;

        }

        //
        // If this is a trusted domain (e.g., we're sure that the DNS name specified is a DNS name),
        //  and we got a response from a DNS server (implying net connectivity),
        //  and we didn't find a reason to avoid the permanent cache (e.g., found a SRV record),
        //  then we think we'll never be able to find a DC in this domain.
        //
        // (Notice the implication that the DNS server got the SRV entries before
        //  this machine got the trusted domain list entry.)
        if ( (Context.QueriedInternalFlags & DS_IS_TRUSTED_DOMAIN) != 0 &&
             Context.ResponseFromDnsServer &&
             !Context.AvoidPermanentNegativeCache ) {
            Context.NlDcDomainEntry->Dc[Context.DcQueryType].PermanentNegativeCache = TRUE;
            NlPrint(( NL_DNS,
                      "Cache: %ws %ws: Cache entry %ld marked permanently negative.\n",
                      Context.NlDcDomainEntry->UnicodeNetbiosDomainName,
                      Context.NlDcDomainEntry->UnicodeDnsDomainName,
                      Context.DcQueryType ));
        }

        LeaveCriticalSection( &NlDcCritSect );
    }
#endif // _NETLOGON_SERVER

    ////////////////////////////////
    //                            //
    // Now, hanle success cases   //
    //                            //
    ////////////////////////////////

    //
    // Update the cache. See if we really want to use this entry.
    //

    if ( NetStatus == NO_ERROR ) {

        //
        // If this entry hasn't been inserted, we haven't
        //  yet used it to set the site name as appropriate.
        //

        if ( (NlDcCacheEntry->CacheEntryFlags & NL_DC_CACHE_ENTRY_INSERTED) == 0 ) {

#ifdef _NETLOGON_SERVER
            //
            // If the domain being queried is the domain this machine is
            //  a member of,
            //  save the name of the site for the next call.
            //
            // Avoid setting the site name to NULL if the DC is NT4 DC since
            //  NT4 is not site aware.  If the site name is NULL but the DC
            //  is NT5 DC, set the site to NULL to indicate that this machine
            //  is not in a site.
            //

            if ( ( NlDcCacheEntry->UnicodeClientSiteName != NULL ||
                 NlDcCacheEntry->ReturnFlags & DS_DS_FLAG ) &&
                 (Context.QueriedInternalFlags & DS_IS_PRIMARY_DOMAIN) != 0  ) {

                NlSetDynamicSiteName( NlDcCacheEntry->UnicodeClientSiteName );

            }
#endif // _NETLOGON_SERVER

            //
            // Insert the cache entry into the cache.
            //

            NetpDcInsertCacheEntry( &Context, NlDcCacheEntry );
        }

        //
        // If we successfully found an NT 5.0 DC,
        //  flag that this is not an NT 4.0 domain.
        //

        EnterCriticalSection(&NlDcCritSect);
        if ( (Context.QueriedFlags & DS_NT50_REQUIRED) != 0 &&
             Context.NlDcDomainEntry->InNt4Domain ) {

            Context.NlDcDomainEntry->InNt4Domain = FALSE;
            Context.NlDcDomainEntry->InNt4DomainTime = 0;
            NlPrint(( NL_MISC,
                      "NetpDcGetName: %ws: Domain is an NT 5.0 domain.\n",
                      Context.QueriedDisplayDomainName ));
        }
        LeaveCriticalSection(&NlDcCritSect);

        //
        // If the caller requires that the DC be in the root domain,
        //  and this one isn't,
        //  fail.
        //

        if ( (Context.QueriedInternalFlags & DS_REQUIRE_ROOT_DOMAIN) != 0 &&
             NlDcCacheEntry->UnicodeDnsDomainName != NULL &&
             NlDcCacheEntry->UnicodeDnsForestName != NULL &&
             !NlEqualDnsName( NlDcCacheEntry->UnicodeDnsDomainName,
                              NlDcCacheEntry->UnicodeDnsForestName ) ) {

            NlPrint(( NL_MISC,
                      "NetpDcGetName: %ws: Domain isn't the root domain %ws %ws.\n",
                      Context.QueriedDisplayDomainName,
                      NlDcCacheEntry->UnicodeDnsDomainName,
                      NlDcCacheEntry->UnicodeDnsForestName ));
            NetStatus = ERROR_NO_SUCH_DOMAIN;
        }
    }

    //
    // If we used netbios to find a DC,
    //  see if failling back to DNS would get a better DC.
    //

    if ( NetStatus == NO_ERROR && UsedNetbios ) {

        NetStatus = NetpGetBetterDc( &Context,
                                     Timeout,
                                     RetryCount,
                                     &NlDcCacheEntry );
    }

    //
    // Prepare the returned data.
    //
    // Convert cache entry into controller info if requested
    //

    if ( NetStatus == NO_ERROR && DomainControllerInfo != NULL ) {
        WCHAR IpAddressString[NL_SOCK_ADDRESS_LENGTH+1];
        WCHAR IpAddressStringSize;
        ULONG DomainControllerInfoSize;
        ULONG DnsHostNameSize;
        ULONG NetbiosDcNameSize=0;
        ULONG DnsDomainNameSize;
        ULONG NetbiosDomainNameSize = 0;
        ULONG DcSiteNameSize = 0;
        ULONG ClientSiteNameSize = 0;
        ULONG DnsForestNameSize = 0;
        ULONG ReturnFlags = NlDcCacheEntry->ReturnFlags;
        BOOL LocalUsedNetbios = UsedNetbios;

        LPBYTE Where;

        //
        // If the user requested DNS names, then we need to send
        // back dns names
        //

        if (( Flags & DS_RETURN_DNS_NAME) == DS_RETURN_DNS_NAME) {
            LocalUsedNetbios = FALSE;
        }

        //
        //  Compute the size of the controller info entry.
        //

        DomainControllerInfoSize = sizeof(DOMAIN_CONTROLLER_INFOW);

        if ( NlDcCacheEntry->UnicodeDnsHostName != NULL &&
             (Context.QueriedFlags & DS_RETURN_FLAT_NAME) == 0 &&
            !LocalUsedNetbios ) {
            DnsHostNameSize = (wcslen(NlDcCacheEntry->UnicodeDnsHostName) + 1) * sizeof(WCHAR);

            // DomainControllerName
            DomainControllerInfoSize += DnsHostNameSize + 2 * sizeof(WCHAR);
        } else if ( NlDcCacheEntry->UnicodeNetbiosDcName != NULL ) {
            NetbiosDcNameSize = (wcslen(NlDcCacheEntry->UnicodeNetbiosDcName) + 1) * sizeof(WCHAR);

            // DomainControllerName
            DomainControllerInfoSize += NetbiosDcNameSize + 2 * sizeof(WCHAR);
        } else {
            // This can't ever happen. (But better to fail than to AV.)
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        if ( NlDcCacheEntry->SockAddr.iSockaddrLength != 0 ) {

            NetStatus = NetpSockAddrToWStr(
                        NlDcCacheEntry->SockAddr.lpSockaddr,
                        NlDcCacheEntry->SockAddr.iSockaddrLength,
                        IpAddressString );

            if ( NetStatus != NO_ERROR ) {
                NlPrint(( NL_CRITICAL,
                          "NetpDcGetName: %ws: Cannot NetpSockAddrToWStr. 0x%lx\n",
                          Context.QueriedDisplayDomainName,
                          NetStatus ));
                goto Cleanup;
            }

            IpAddressStringSize = (wcslen(IpAddressString) + 1) * sizeof(WCHAR);

            // DomainControllerAddress
            DomainControllerInfoSize += IpAddressStringSize + 2 * sizeof(WCHAR);
        } else if ( NlDcCacheEntry->UnicodeNetbiosDcName != NULL ) {
            if ( NetbiosDcNameSize == 0 ) {
                NetbiosDcNameSize = (wcslen(NlDcCacheEntry->UnicodeNetbiosDcName) + 1) * sizeof(WCHAR);
            }
            // DomainControllerAddress
            DomainControllerInfoSize += NetbiosDcNameSize + 2 * sizeof(WCHAR);
        } else {
            // This can't ever happen. (But better to fail than to AV.)
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        if ( NlDcCacheEntry->UnicodeDnsDomainName != NULL &&
            (Context.QueriedFlags & DS_RETURN_FLAT_NAME) == 0 &&
            !LocalUsedNetbios ) {
            DnsDomainNameSize = (wcslen(NlDcCacheEntry->UnicodeDnsDomainName) + 1) * sizeof(WCHAR);

            // DomainName
            DomainControllerInfoSize += DnsDomainNameSize;
        } else if ( NlDcCacheEntry->UnicodeNetbiosDomainName != NULL ) {
            NetbiosDomainNameSize = (wcslen(NlDcCacheEntry->UnicodeNetbiosDomainName) + 1) * sizeof(WCHAR);

            // DomainName
            DomainControllerInfoSize += NetbiosDomainNameSize;
        } else if ( LocalUsedNetbios &&
                    Context.QueriedNetbiosDomainName != NULL ) {
            // Lanman PDC or SAMBA Domain Master brower.
            NetbiosDomainNameSize = (wcslen(Context.QueriedNetbiosDomainName) + 1) * sizeof(WCHAR);

            // DomainName
            DomainControllerInfoSize += NetbiosDomainNameSize;
        } else {
            // This can't ever happen. (But better to fail than to AV.)
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        if ( NlDcCacheEntry->UnicodeDnsForestName != NULL ) {
            DnsForestNameSize = (wcslen(NlDcCacheEntry->UnicodeDnsForestName) + 1) * sizeof(WCHAR);

            // TreeName
            DomainControllerInfoSize += DnsForestNameSize;
        }

        if ( NlDcCacheEntry->UnicodeDcSiteName != NULL ) {
            DcSiteNameSize = (wcslen(NlDcCacheEntry->UnicodeDcSiteName) + 1) * sizeof(WCHAR);

            // DcSiteName
            DomainControllerInfoSize += DcSiteNameSize;
        }

        if ( NlDcCacheEntry->UnicodeClientSiteName != NULL ) {
            ClientSiteNameSize = (wcslen(NlDcCacheEntry->UnicodeClientSiteName) + 1) * sizeof(WCHAR);

            // ClientSiteName
            DomainControllerInfoSize += ClientSiteNameSize;
        }

        //
        //  Allocate the controller info entry.
        //

        NetStatus = NetApiBufferAllocate(
                        DomainControllerInfoSize,
                        DomainControllerInfo );

        if ( NetStatus == NO_ERROR ) {

            Where = (LPBYTE)((*DomainControllerInfo) + 1);

            //
            // Copy information into the allocated buffer.
            //

            (*DomainControllerInfo)->DomainControllerName = (LPWSTR)Where;
            *((LPWSTR)Where)++ = L'\\';
            *((LPWSTR)Where)++ = L'\\';
            if (NlDcCacheEntry->UnicodeDnsHostName != NULL &&
                (Context.QueriedFlags & DS_RETURN_FLAT_NAME) == 0 &&
                !LocalUsedNetbios ) {
                RtlCopyMemory( Where,
                               NlDcCacheEntry->UnicodeDnsHostName,
                               DnsHostNameSize );
                Where += DnsHostNameSize;
                ReturnFlags |= DS_DNS_CONTROLLER_FLAG;
            } else {
                RtlCopyMemory( Where,
                               NlDcCacheEntry->UnicodeNetbiosDcName,
                               NetbiosDcNameSize );
                Where += NetbiosDcNameSize;
            }

            (*DomainControllerInfo)->DomainControllerAddress = (LPWSTR)Where;
            *((LPWSTR)Where)++ = L'\\';
            *((LPWSTR)Where)++ = L'\\';
            if ( NlDcCacheEntry->SockAddr.iSockaddrLength != 0 ) {
                RtlCopyMemory( Where,
                               IpAddressString,
                               IpAddressStringSize );
                Where += IpAddressStringSize;
                (*DomainControllerInfo)->DomainControllerAddressType = DS_INET_ADDRESS;
            } else {
                RtlCopyMemory( Where,
                               NlDcCacheEntry->UnicodeNetbiosDcName,
                               NetbiosDcNameSize );
                Where += NetbiosDcNameSize;
                (*DomainControllerInfo)->DomainControllerAddressType = DS_NETBIOS_ADDRESS;
            }

            (*DomainControllerInfo)->DomainGuid = NlDcCacheEntry->DomainGuid;

            (*DomainControllerInfo)->DomainName = (LPWSTR)Where;
            if (NlDcCacheEntry->UnicodeDnsDomainName != NULL &&
                (Context.QueriedFlags & DS_RETURN_FLAT_NAME) == 0 &&
                !LocalUsedNetbios ) {
                RtlCopyMemory( Where,
                               NlDcCacheEntry->UnicodeDnsDomainName,
                               DnsDomainNameSize );
                Where += DnsDomainNameSize;
                ReturnFlags |= DS_DNS_DOMAIN_FLAG;
            } else if ( NlDcCacheEntry->UnicodeNetbiosDomainName != NULL ) {
                RtlCopyMemory( Where,
                               NlDcCacheEntry->UnicodeNetbiosDomainName,
                               NetbiosDomainNameSize );
                Where += NetbiosDomainNameSize;
            } else if ( LocalUsedNetbios &&
                        Context.QueriedNetbiosDomainName != NULL ) {

                RtlCopyMemory( Where,
                               Context.QueriedNetbiosDomainName,
                               NetbiosDomainNameSize );
                Where += NetbiosDomainNameSize;

            } else {
                NetStatus = ERROR_INTERNAL_ERROR;
                goto Cleanup;
            }

            if (NlDcCacheEntry->UnicodeDnsForestName != NULL ) {
                (*DomainControllerInfo)->DnsForestName = (LPWSTR)Where;
                RtlCopyMemory( Where,
                               NlDcCacheEntry->UnicodeDnsForestName,
                               DnsForestNameSize );
                Where += DnsForestNameSize;
                ReturnFlags |= DS_DNS_FOREST_FLAG;
            } else {
                (*DomainControllerInfo)->DnsForestName = NULL;
            }

            if (NlDcCacheEntry->UnicodeDcSiteName != NULL ) {
                (*DomainControllerInfo)->DcSiteName = (LPWSTR)Where;
                RtlCopyMemory( Where,
                               NlDcCacheEntry->UnicodeDcSiteName,
                               DcSiteNameSize );
                Where += DcSiteNameSize;
            } else {
                (*DomainControllerInfo)->DcSiteName = NULL;
            }

            if (NlDcCacheEntry->UnicodeClientSiteName != NULL ) {
                (*DomainControllerInfo)->ClientSiteName = (LPWSTR)Where;
                RtlCopyMemory( Where,
                               NlDcCacheEntry->UnicodeClientSiteName,
                               ClientSiteNameSize );
                Where += ClientSiteNameSize;
            } else {
                (*DomainControllerInfo)->ClientSiteName = NULL;
            }

            (*DomainControllerInfo)->Flags = ReturnFlags;
        }
    }

    //
    // Return the cache entry if requested
    //

    if ( NetStatus == NO_ERROR && DomainControllerCacheEntry != NULL ) {
        *DomainControllerCacheEntry = NlDcCacheEntry;
        NlDcCacheEntry = NULL;
    }

    //
    // Free local resources
    //

    NetpDcUninitializeContext( &Context );

    if ( PingResponseMessage != NULL ) {
        NetpMemoryFree( PingResponseMessage );
    }

    if ( NlDcCacheEntry != NULL ) {
        NetpDcDerefCacheEntry( NlDcCacheEntry );
    }

    if ( LocalQueriedlNetbiosDomainName != NULL ) {
        NetApiBufferFree( LocalQueriedlNetbiosDomainName );
    }

#ifdef _NETLOGON_SERVER
} except( NL_EXCEPTION) {
    NetStatus = NetpNtStatusToApiStatus(GetExceptionCode());
}
#endif // _NETLOGON_SERVER

    return NetStatus;
}


DWORD
DsIGetDcName(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCWSTR DomainName OPTIONAL,
    IN LPCWSTR DnsForestName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    IN ULONG InternalFlags,
    IN PVOID SendDatagramContext OPTIONAL,
    IN DWORD Timeout,
    IN LPWSTR NetbiosPrimaryDomainName OPTIONAL,
    IN LPWSTR DnsPrimaryDomainName OPTIONAL,
    IN GUID *PrimaryDomainGuid OPTIONAL,
    IN LPWSTR DnsTrustedDomainName OPTIONAL,
    IN LPWSTR NetbiosTrustedDomainName OPTIONAL,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    Same as DsGetDcNameW.

    This is the internal routine called by DsGetDcNameW (in the context of
    the original caller) or DsrGetDcName (in the context of the Netlogon
    service) to actaully implement DsGetDcNameW.

Arguments:

    Same as DsGetDcNameW except for the following additional parameters:

    ComputerName - Specifies the NETBIOS name of this computer.
        If NULL, the name will be dynamically determined.

    AccountName - Account name to pass on the ping request.
        If NULL, no account name will be sent.

    AllowableAccountControlBits - Mask of allowable account types for AccountName.
        Valid bits are those specified by UF_MACHINE_ACCOUNT_MASK.
        Invalid bits are ignored.  If more than one bit is specified, the
        account can be of any of the specified types.

    DnsForestName - The DNS-style name of the tree the queried domain is in.

    SendDatagramContext - Specifies context to pass a NlBrowserSendDatagram

    Timeout - Maximum time (in milliseconds) caller is willing to wait on
        this operation.

    InternalFlags - Internal Flags used to pass additional information

    NetbiosPrimaryDomainName - Netbios name of the domain this machine belongs
        to.

    DnsPrimaryDomainName - DNS name of the domain this machine belongs to.

    PrimaryDomainGuid - GUID of the primary domain.

    DnsTrustedName - DNS name of the queried domain as was found in the
        trust list.
        If not specified, the specified domain isn't a trusted domain.

    NetbiosTrustedDomainName - Netbios name of the queried domain as was found in the
        trust list.
        If not specified, the specified domain isn't a trusted domain.

Return Value:

    Same as DsGetDcNameW.

--*/
{
    NET_API_STATUS NetStatus;
    LPCWSTR NetbiosDomainName = NULL;
    LPCWSTR DnsDomainName = NULL;
    ULONG SamAllowableAccountControlBits;
    ULONG FormatCount = 0;
    BOOLEAN CallerSpecifiedDomain = FALSE;
#ifdef WIN32_CHICAGO
    LPSTR pDomainName = NULL;
#endif // WIN32_CHICAGO

    //
    // Ensure caller didn't specify both name type flags.
    //

    if ( ((Flags & (DS_IS_FLAT_NAME|DS_IS_DNS_NAME)) ==
                  (DS_IS_FLAT_NAME|DS_IS_DNS_NAME) ) ||
         ((Flags & (DS_RETURN_FLAT_NAME|DS_RETURN_DNS_NAME)) ==
                  (DS_RETURN_FLAT_NAME|DS_RETURN_DNS_NAME)) ) {
        NetStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }


    //
    // If the caller specified, DS_RETURN_DNS_NAME, we should really
    // set DS_IP_REQUIRED.

    if ((Flags & DS_RETURN_DNS_NAME) == DS_RETURN_DNS_NAME) {
        Flags |= DS_IP_REQUIRED;
    }


    //
    // If the caller didn't specify a domain name,
    //  use our domain name.
    //

    if ( DomainName == NULL || *DomainName == L'\0' ) {

#ifndef WIN32_CHICAGO
        //
        // If the caller wants a GC,
        //  the domain to use is the tree name.
        //
        // If we don't yet know our tree name,
        //  it is better to try with our primary name than to not try at all
        //
        //
        if ( (Flags & DS_GC_SERVER_REQUIRED) != 0 &&
             DnsForestName != NULL ) {

            NetbiosDomainName = NULL;
            DnsDomainName = DnsForestName;

        //
        // Otherwise, the domain to use is the primary domain name.
        //  Do this even if the primary domain name is a workgroup
        //  name because there might be a DC in this workgroup/domain
        //  which the caller is trying to discover.
        //
        } else {
            NetbiosDomainName = NetbiosPrimaryDomainName;
            DnsDomainName = DnsPrimaryDomainName;
            InternalFlags |= DS_IS_PRIMARY_DOMAIN | DS_IS_TRUSTED_DOMAIN;
        }
#else // WIN32_CHICAGO

#define NETWORK_PROVIDER_KEY ("System\\CurrentControlSet\\Services\\Msnp32\\NetworkProvider")
#define AUTH_AGENT_VALUE ("AuthenticatingAgent")

        do {
            HKEY hRegKey = NULL;
            DWORD dwError = 0, dwSize = 0, dwType;

            if (ERROR_SUCCESS != (dwError = RegOpenKeyEx(
                               HKEY_LOCAL_MACHINE,
                               NETWORK_PROVIDER_KEY,
                               0,
                               KEY_ALL_ACCESS,
                               &hRegKey ) ) )
            {
                break;
            }

            // get domain name size
            if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               AUTH_AGENT_VALUE,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize )))
            {
                break;
            }

            if (dwSize == 0 )
            {
                break;
            }

            pDomainName = (LPSTR) NetpMemoryAllocate((dwSize+1 ) * sizeof(WCHAR));

            if (pDomainName == NULL)
            {
                break;
            }
            // get domainname

            if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               AUTH_AGENT_VALUE,
                               NULL,
                               &dwType,
                               (PUCHAR) pDomainName,
                               &dwSize )))
            {
                break;
            }

            NetbiosDomainName = (LPCWSTR)NetpAllocWStrFromOemStr(pDomainName);

        } while (FALSE);

        if (NetbiosDomainName == NULL)
        {
            NetStatus = ERROR_INVALID_DOMAINNAME;
            goto Cleanup;
        }

        //
        // Indicate that the caller passed NULL as the domain name
        //
        InternalFlags |= DS_CALLER_PASSED_NULL_DOMAIN;
#endif // WIN32_CHICAGO



    //
    // If the caller did specify a domain name,
    //  validate it.
    //

    } else {
        CallerSpecifiedDomain = TRUE;

        //
        // If the specified domain name is a syntactically valid DNS name,
        //  use it as a DNS name.
        //
        // Don't even try to check if caller claims it is a NETBIOS name.
        //

        if ( (Flags & DS_IS_FLAT_NAME) == 0 &&
             NetpDcValidDnsDomain( DomainName )) {

            DnsDomainName = DomainName;
            FormatCount ++;

            //
            // If the primary domain name specified is not a
            //  workgroup name and
            // If the caller specified the DNS primary domain name,
            //  we don't need to guess the Netbios domain name.
            //

            if ( (InternalFlags & DS_PRIMARY_NAME_IS_WORKGROUP) == 0 &&
                 DnsPrimaryDomainName != NULL &&
                 NlEqualDnsName( DnsPrimaryDomainName, DomainName ) ) {

                //
                // If the DNS name is specified on input,
                //  don't fall back to the Netbios name for discovery.
                //  There is no benefit to trying the Netbios name.
                //  Also, when using the netbios name, we don't know when all
                //  of the DCs have responded negatively.  So, we can't early
                //  out.
                //
                if ( NetbiosPrimaryDomainName != NULL &&
                     NlEqualDnsName( DnsPrimaryDomainName, NetbiosPrimaryDomainName ) ) {
                    // Unless, of course the netbios and DNS domain names are spelled the same.
                    NetbiosDomainName = NetbiosPrimaryDomainName;
                }
                InternalFlags |= DS_IS_PRIMARY_DOMAIN | DS_IS_TRUSTED_DOMAIN;
                Flags |= DS_IS_DNS_NAME;

                //
                // But return the DNS name unless the caller has explicitly
                //  asked for the Netbios name.
                //
                if ( (Flags & DS_RETURN_FLAT_NAME) == 0 ) {
                    Flags |= DS_RETURN_DNS_NAME;
                }


            //
            // If the caller specified the DNS trusted domain name,
            //  we don't need to guess the Netbios domain name.
            //

            } else if ( DnsTrustedDomainName != NULL &&
                        NlEqualDnsName( DnsTrustedDomainName, DomainName ) ) {

                //
                // If the DNS name is specified on input,
                //  don't fall back to the Netbios name for discovery.
                //  There is no benefit to trying the Netbios name.
                //  Also, when using the netbios name, we don't know when all
                //  of the DCs have responded negatively.  So, we can't early
                //  out.
                //
                if ( NetbiosTrustedDomainName != NULL &&
                     NlEqualDnsName( DnsTrustedDomainName, NetbiosTrustedDomainName ) ) {
                    // Unless, of course the netbios and DNS domain names are spelled the same.
                    NetbiosDomainName = NetbiosTrustedDomainName;
                }
                InternalFlags |= DS_IS_TRUSTED_DOMAIN;
                Flags |= DS_IS_DNS_NAME;

                //
                // But return the DNS name unless the caller has explicitly
                //  asked for the Netbios name.
                //
                if ( (Flags & DS_RETURN_FLAT_NAME) == 0 ) {
                    Flags |= DS_RETURN_DNS_NAME;
                }

            }
        }

        //
        // If the specified domain name is a syntactically valid Netbios name,
        //  use it as a Netbios name.
        //  (Don't even try to check if caller claims it is a DNS name)
        //

        if ( (Flags & DS_IS_DNS_NAME) == 0 &&
             NetpIsDomainNameValid( (LPWSTR) DomainName )) {

            NetbiosDomainName = DomainName;
            FormatCount ++;

            //
            // If the primary domain name specified is not a
            //  workgroup name and
            // If the caller specified the Netbios primary domain name,
            //  we don't need to guess the DNS domain name.
            //

            if ( (InternalFlags & DS_PRIMARY_NAME_IS_WORKGROUP) == 0 &&
                 NetbiosPrimaryDomainName != NULL &&
                 NlNameCompare( (LPWSTR) DomainName,
                                 NetbiosPrimaryDomainName,
                                 NAMETYPE_DOMAIN ) == 0 ) {

                //
                // Use both the DNS name and the Netbios name to do the discovery
                //  (Use the DNS name since it is rename safe.)
                //
                DnsDomainName = DnsPrimaryDomainName;
                InternalFlags |= DS_IS_PRIMARY_DOMAIN | DS_IS_TRUSTED_DOMAIN;
                Flags |= DS_IS_FLAT_NAME;

                //
                // But return the netbios name unless the caller has explicitly
                //  asked for the DNS name.
                //
                if ( (Flags & DS_RETURN_DNS_NAME) == 0 ) {
                    Flags |= DS_RETURN_FLAT_NAME;
                }

            //
            // If the caller specified a DNS trust domain name that corresponds
            //  to the queried Netbios domain name, use it.
            //

            } else if ( NetbiosTrustedDomainName != NULL &&
                        NlNameCompare( (LPWSTR) DomainName,
                                       NetbiosTrustedDomainName,
                                       NAMETYPE_DOMAIN ) == 0 ) {

                //
                // Use both the DNS name and the Netbios name to do the discovery
                //  (Use the DNS name since it is rename safe.)
                //
                DnsDomainName = DnsTrustedDomainName;
                InternalFlags |= DS_IS_TRUSTED_DOMAIN;
                Flags |= DS_IS_FLAT_NAME;

                //
                // But return the netbios name unless the caller has explicitly
                //  asked for the DNS name.
                //
                if ( (Flags & DS_RETURN_DNS_NAME) == 0 ) {
                    Flags |= DS_RETURN_FLAT_NAME;
                }

            }
        }
    }

    //
    // Disallow single labeled DNS domain names if the caller
    //  specified one unless the domain is proven to exist
    //  (i.e. trusted) or we are forced to allow such names.
    //
    // Note that we don't really trust the caller here:
    //  We won't allow single labeled DNS domain name even if
    //  the caller claims it's a DNS name (via DS_IS_DNS_NAME)
    //

    if ( DnsDomainName != NULL &&
         CallerSpecifiedDomain &&
         (InternalFlags & DS_IS_TRUSTED_DOMAIN) == 0 ) {

        BOOLEAN SingleLabel = FALSE;
        LPWSTR Period = NULL;
        LPWSTR SecondPeriod = NULL;

        Period = wcsstr( DnsDomainName, L"." );

        //
        // If there is no period in the name,
        //  the name is single labeled
        //
        if ( Period == NULL ) {
            SingleLabel = TRUE;

        //
        // If there is a period, the name is
        //  single labeled if this is the only
        //  period and it's either the first
        //  or the last character in the name
        //
        } else {
            SecondPeriod = wcsstr( Period+1, L"." );

            if ( SecondPeriod == NULL ) {
                if ( Period == DnsDomainName ||
                     *(Period+1) == UNICODE_NULL ) {
                    SingleLabel = TRUE;
                }
            }
        }

        //
        // If this is single label DNS name,
        //  disallow it unless we are forced
        //  otherwise via the registry config
        //
        if ( SingleLabel ) {
            DWORD LocalAllowSingleLabelDnsDomain = 0;

            //
            // In netlogon, the boolean is kept in global parameters
            //
#ifdef _NETLOGON_SERVER

            if ( !NlGlobalParameters.AllowSingleLabelDnsDomain ) {
                NlPrint(( NL_MISC, "DsIGetDcName: Ignore single label DNS domain name %ws\n", DnsDomainName ));
                DnsDomainName = NULL;
            }

            //
            // If we are not running in netlogon, we need to read
            //  the boolean directly from the registry
            //
#else
            NlReadDwordNetlogonRegValue( "AllowSingleLabelDnsDomain",
                                         &LocalAllowSingleLabelDnsDomain );

            if ( !LocalAllowSingleLabelDnsDomain ) {
                NlPrint(( NL_MISC, "DsIGetDcName: Ignore single label DNS domain name %ws\n", DnsDomainName ));
                DnsDomainName = NULL;
            }

#endif // _NETLOGON_SERVER
        }

    }

    //
    // If the name is neither a netbios or DNS name,
    //  give up.
    //
    if ( NetbiosDomainName == NULL && DnsDomainName == NULL ) {
        NetStatus = ERROR_INVALID_DOMAINNAME;
        goto Cleanup;
    }

    //
    // If this is the primary domain,
    //  and the caller didn't specify a GUID,
    //  use the GUID of the primary domain.
    //

    if ( (InternalFlags & DS_IS_PRIMARY_DOMAIN) != 0 &&
         DomainGuid == NULL ) {
        DomainGuid = PrimaryDomainGuid;
    }

    //
    // If the format is ambiguous,
    //  pass that info on down.
    //

    if ( FormatCount > 1 ) {
        InternalFlags |= DS_NAME_FORMAT_AMBIGUOUS;
    }

    //
    // Map the AllowableAccountControlBits to the SAM representation.
    //

    SamAllowableAccountControlBits = 0;
    if ( AllowableAccountControlBits & UF_TEMP_DUPLICATE_ACCOUNT ) {
        SamAllowableAccountControlBits |= USER_TEMP_DUPLICATE_ACCOUNT;
    }
    if ( AllowableAccountControlBits & UF_NORMAL_ACCOUNT ) {
        SamAllowableAccountControlBits |= USER_NORMAL_ACCOUNT;
    }
    if (AllowableAccountControlBits & UF_INTERDOMAIN_TRUST_ACCOUNT){
        SamAllowableAccountControlBits |= USER_INTERDOMAIN_TRUST_ACCOUNT;
    }
    if (AllowableAccountControlBits & UF_WORKSTATION_TRUST_ACCOUNT){
        SamAllowableAccountControlBits |= USER_WORKSTATION_TRUST_ACCOUNT;
    }
    if ( AllowableAccountControlBits & UF_SERVER_TRUST_ACCOUNT ) {
        SamAllowableAccountControlBits |= USER_SERVER_TRUST_ACCOUNT;
    }


    //
    // Try finding a DC with this information.
    //

    NetStatus = NetpDcGetName(
                    SendDatagramContext,
                    ComputerName,
                    AccountName,
                    SamAllowableAccountControlBits,
                    NetbiosDomainName,
                    DnsDomainName,
                    DnsForestName,
                    NULL,   // No Domain Sid
                    DomainGuid,
                    SiteName,
                    Flags,
                    InternalFlags,
                    Timeout,
                    MAX_DC_RETRIES,
                    DomainControllerInfo,
                    NULL );


Cleanup:
#ifdef WIN32_CHICAGO
    if (pDomainName)
    {
        NetpMemoryFree(pDomainName);
        pDomainName = NULL;
        if ( NetbiosDomainName != NULL ) {
            NetpMemoryFree((LPWSTR)NetbiosDomainName);
        }
    }
#endif // WIN32_CHICAGO
    return NetStatus;
}
#ifndef WIN32_CHICAGO

NET_API_STATUS
NlParseSubnetString(
    IN LPCWSTR SubnetName,
    OUT PULONG SubnetAddress,
    OUT PULONG SubnetMask,
    OUT LPBYTE SubnetBitCount
    )
/*++

Routine Description:

    Convert the subnet name to address and bit count.

Arguments:

    SubnetName - Subnet string

    SubnetAddress - Returns the subnet number in Network byte order.

    SubnetMask - Returns the subnet mask in network byte order

    SubnetBitCount - Returns the number of leftmost significant bits in the
        SubnetAddress

Return Value:

    NO_ERROR: success
    ERROR_INVALID_NAME: Syntax of SubnetName is bad.
    WSANOTINITIALISED: WSA needs to be initialized before making this call

--*/
{
    LPWSTR SlashPointer;
    WCHAR *End;
    ULONG LocalBitCount;
    WCHAR LocalSubnetName[NL_SOCK_ADDRESS_LENGTH*2];
    WCHAR CanonicalSubnetName[NL_SOCK_ADDRESS_LENGTH+1];
    ULONG CanonicalSubnetNameLen;
    WCHAR CanonicalBitCount[3];
    static ULONG BitMask[] = {
                         0x00000000,
                         0x00000080,
                         0x000000C0,
                         0x000000E0,
                         0x000000F0,
                         0x000000F8,
                         0x000000FC,
                         0x000000FE,
                         0x000000FF,
                         0x000080FF,
                         0x0000C0FF,
                         0x0000E0FF,
                         0x0000F0FF,
                         0x0000F8FF,
                         0x0000FCFF,
                         0x0000FEFF,
                         0x0000FFFF,
                         0x0080FFFF,
                         0x00C0FFFF,
                         0x00E0FFFF,
                         0x00F0FFFF,
                         0x00F8FFFF,
                         0x00FCFFFF,
                         0x00FEFFFF,
                         0x00FFFFFF,
                         0x80FFFFFF,
                         0xC0FFFFFF,
                         0xE0FFFFFF,
                         0xF0FFFFFF,
                         0xF8FFFFFF,
                         0xFCFFFFFF,
                         0xFEFFFFFF,
                         0xFFFFFFFF };

    INT WsaStatus;
    SOCKADDR_IN SockAddrIn;
    INT SockAddrSize;

    //
    // Copy the string to where we can munge it.
    //

    if ( wcslen(SubnetName) + 1 > sizeof(LocalSubnetName)/sizeof(WCHAR) ) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: String too long\n", SubnetName ));
        return ERROR_INVALID_NAME;
    }
    wcscpy( LocalSubnetName, SubnetName );


    //
    // Find the subnet bit count.
    //

    SlashPointer = wcschr( LocalSubnetName, L'/' );

    if ( SlashPointer == NULL ) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: Bit Count missing %ld\n", SubnetName ));
        return ERROR_INVALID_NAME;
    }

    //
    // Zero terminate the address portion of the subnet name.
    //
    *SlashPointer = L'\0';

    //
    // Get the BitCount portion.
    //

    LocalBitCount = wcstoul( SlashPointer+1, &End, 10 );

    if ( LocalBitCount == 0 || LocalBitCount > 32 ) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: Bit Count bad %ld\n", SubnetName, LocalBitCount ));
        return ERROR_INVALID_NAME;
    }

    if ( *End != L'\0' ) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: Bit Count not at string end\n", SubnetName ));
        return ERROR_INVALID_NAME;
    }

    ultow( LocalBitCount, CanonicalBitCount, 10 );

    if ( wcscmp( SlashPointer+1, CanonicalBitCount ) != 0 ) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: not canonical %ws\n", SlashPointer+1, CanonicalBitCount ));
        return ERROR_INVALID_NAME;
    }

    *SubnetBitCount = (BYTE)LocalBitCount;


    //
    // Convert the address portion to binary.
    //

    SockAddrSize = sizeof(SockAddrIn);
    WsaStatus = WSAStringToAddressW( (LPWSTR)LocalSubnetName,
                                     AF_INET,
                                     NULL,
                                     (PSOCKADDR)&SockAddrIn,
                                     &SockAddrSize );
    if ( WsaStatus != 0 ) {
        WsaStatus = WSAGetLastError();
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: Wsa Error %ld\n", SubnetName, WsaStatus ));
        if ( WsaStatus == WSAEFAULT ||
             WsaStatus == WSAEINVAL ) {
            return ERROR_INVALID_NAME;
        }
        return WsaStatus;
    }

    if ( SockAddrIn.sin_family != AF_INET ) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: Not AF_INET\n", SubnetName ));
        return ERROR_INVALID_NAME;
    }

    *SubnetAddress = SockAddrIn.sin_addr.S_un.S_addr;
    *SubnetMask = BitMask[*SubnetBitCount];

    //
    // Require that the passed in string be in canonical form.
    //  (e.g., no leading zeros).  Since this text string is used as the
    //  name of an object in the DS, we don't want two different text strings
    //  to represent the same subnet.
    //

    CanonicalSubnetNameLen = sizeof(CanonicalSubnetName)/sizeof(WCHAR);
    WsaStatus = WSAAddressToStringW( (PSOCKADDR)&SockAddrIn,
                                     SockAddrSize,
                                     NULL,
                                     CanonicalSubnetName,
                                     &CanonicalSubnetNameLen );
    if ( WsaStatus != 0 ) {
        WsaStatus = WSAGetLastError();
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: Wsa Error %ld\n", SubnetName, WsaStatus ));
        if ( WsaStatus == WSAEFAULT ||
             WsaStatus == WSAEINVAL ) {
            return ERROR_INVALID_NAME;
        }
        return WsaStatus;
    }

    if ( wcscmp( LocalSubnetName, CanonicalSubnetName ) != 0 ) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: not canonical %ws\n", SubnetName, CanonicalSubnetName ));
        return ERROR_INVALID_NAME;
    }



    //
    // Ensure there are no bits set that aren't included in the subnet mask.
    //

    if ( (*SubnetAddress) & ~(*SubnetMask)) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: bits not in subnet mask %8.8lX %8.8lX\n", SubnetName, *SubnetAddress, *SubnetMask ));
        return ERROR_INVALID_NAME;
    }

    //
    // Ensure the subnet mask isn't 0 since
    //  RFC950 says "the value of all zeros and all ones should not be assigned
    //  to physical subnets" since all zeros implies "this network" and all ones
    //  implies "all hosts"

    if ( *SubnetAddress == 0 ||
         *SubnetAddress == *SubnetMask ) {
        NlPrint(( NL_CRITICAL,
                  "NlParseSubnetString: %ws: all zero or all one subnet address %8.8lX %8.8lX\n", SubnetName, *SubnetAddress, *SubnetMask ));
        return ERROR_INVALID_NAME;
    }

    return NO_ERROR;
}
#endif // WIN32_CHICAGO

#ifdef _NETLOGON_SERVER

VOID
NetpDcFlushNegativeCache(
    VOID
    )
/*++

Routine Description:

    Flush any failures to discover a DC.

Arguments:

    None.


Return Value:

    None.

--*/
{
    PLIST_ENTRY DomainEntry;
    PNL_DC_DOMAIN_ENTRY NlDcDomainEntry;
    ULONG QueryType;



    //
    // Loop through each cache entry
    //
    EnterCriticalSection(&NlDcCritSect);

    for ( DomainEntry = NlDcDomainList.Flink ;
          DomainEntry != &NlDcDomainList;
          DomainEntry = DomainEntry->Flink ) {

        NlDcDomainEntry = CONTAINING_RECORD( DomainEntry, NL_DC_DOMAIN_ENTRY, Next);

        //
        // Clear the failure time for each query type.
        //
        for ( QueryType = 0; QueryType < NlDcQueryTypeCount; QueryType ++ ) {
            NlFlushNegativeCacheEntry( &NlDcDomainEntry->Dc[QueryType] );
        }


    }

    LeaveCriticalSection(&NlDcCritSect);

    return;
}
#endif // _NETLOGON_SERVER


NET_API_STATUS
NetpDcInitializeCache(
    VOID
    )

/*++

Routine Description:

    Initialize the cache of discovered DCs.

Arguments:

    None.


Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - The cache could not be allocated.

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;

    try {
        InitializeCriticalSection( &NlDcCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        NlPrint(( NL_CRITICAL,
                  "NetpDcInitializeCache: Cannot initialize NlDcCritSect\n" ));
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeListHead( &NlDcDomainList );
    NlDcDomainCount = 0;

    RtlZeroMemory( &NlDcZeroGuid, sizeof(NlDcZeroGuid) );
    NlDcDnsFailureTime = 0;

    return NetStatus;
}



VOID
NetpDcUninitializeCache(
    VOID
    )
/*++

Routine Description:

    Uninitialize the cache of discovered DCs.

Arguments:

    None.


Return Value:

    None.

--*/
{

    //
    // Delete existing domain entries.
    //

    EnterCriticalSection( &NlDcCritSect );
    while (!IsListEmpty(&NlDcDomainList)) {

        PNL_DC_DOMAIN_ENTRY NlDcDomainEntry =
            CONTAINING_RECORD( NlDcDomainList.Flink, NL_DC_DOMAIN_ENTRY, Next);

        NlAssert( NlDcDomainEntry->ReferenceCount == 1 );
        NetpDcDeleteDomainEntry( NlDcDomainEntry );
    }

    LeaveCriticalSection( &NlDcCritSect );
    DeleteCriticalSection( &NlDcCritSect );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\logonsrv\idl\nlcommon.c ===
/*++

Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    nlcommon.c

Abstract:

    Routines shared by logonsrv\server and logonsrv\common

Author:

    Cliff Van Dyke (cliffv) 20-July-1996

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#ifndef _NETLOGON_SERVER
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <rpc.h>        // RPC_STATUS

#include <windef.h>
#include <winsock2.h>

#include <lmcons.h>     // General net defines
#include <dsgetdc.h>    // DsGetDcName()
#include <align.h>      // ROUND_UP_COUNT()
#include <lmerr.h>      // System Error Log definitions
#include <lmapibuf.h>   // NetapipBufferAllocate
#include <netlib.h>     // NetpMemoryAllcate(
#include <netlibnt.h>   // NetpApiStatusToNtStatus();
#include <netlogon.h>   // Definition of mailslot messages
#include <ntddbrow.h>   // Needed by nlcommon.h
#include <ntrpcp.h>

#if DBG
#define NETLOGONDBG 1
#endif // DBG
#include <nldebug.h>    // NlPrint()
#include <nlbind.h>   // Definitions shared with netlogon
#include <nlcommon.h>   // Definitions shared with netlogon
#include <stdlib.h>     // C library functions (rand, etc)


#endif // _NETLOGON_SERVER

//
// Include nlcommon.h again allocating the actual variables
// this time around.
//

// #define NLCOMMON_ALLOCATE
// #include "nlcommon.h"
// #undef NLCOMMON_ALLOCATE


#ifndef WIN32_CHICAGO


VOID
NlForestRelocationRoutine(
    IN DWORD Level,
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PTRDIFF_T Offset
    )

/*++

Routine Description:

   Routine to relocate the pointers from the fixed portion of a NetGroupEnum
   enumeration
   buffer to the string portion of an enumeration buffer.  It is called
   as a callback routine from NetpAllocateEnumBuffer when it re-allocates
   such a buffer.  NetpAllocateEnumBuffer copied the fixed portion and
   string portion into the new buffer before calling this routine.

Arguments:

    Level - Level of information in the  buffer.

    BufferDescriptor - Description of the new buffer.

    Offset - Offset to add to each pointer in the fixed portion.

Return Value:

    Returns the error code for the operation.

--*/

{
    DWORD EntryCount;
    DWORD EntryNumber;
    DWORD FixedSize;


    //
    // Local macro to add a byte offset to a pointer.
    //

#define RELOCATE_ONE( _fieldname, _offset ) \
        if ( (_fieldname) != NULL ) { \
            _fieldname = (PVOID) ((LPBYTE)(_fieldname) + (_offset)); \
        }

        //
    // Compute the number of fixed size entries
    //

    FixedSize = sizeof(DS_DOMAIN_TRUSTSW);

    EntryCount =
        ((DWORD)(BufferDescriptor->FixedDataEnd - BufferDescriptor->Buffer)) /
        FixedSize;

    //
    // Loop relocating each field in each fixed size structure
    //

    for ( EntryNumber=0; EntryNumber<EntryCount; EntryNumber++ ) {

        LPBYTE TheStruct = BufferDescriptor->Buffer + FixedSize * EntryNumber;

        RELOCATE_ONE( ((PDS_DOMAIN_TRUSTSW)TheStruct)->NetbiosDomainName, Offset );
        RELOCATE_ONE( ((PDS_DOMAIN_TRUSTSW)TheStruct)->DnsDomainName, Offset );
        RELOCATE_ONE( ((PDS_DOMAIN_TRUSTSW)TheStruct)->DomainSid, Offset );

    }

    return;

    UNREFERENCED_PARAMETER( Level );

}


NTSTATUS
NlAllocateForestTrustListEntry (
    IN PBUFFER_DESCRIPTOR BufferDescriptor,
    IN PUNICODE_STRING InNetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING InDnsDomainName OPTIONAL,
    IN ULONG Flags,
    IN ULONG ParentIndex,
    IN ULONG TrustType,
    IN ULONG TrustAttributes,
    IN PSID DomainSid OPTIONAL,
    IN GUID *DomainGuid,
    OUT PULONG RetSize,
    OUT PDS_DOMAIN_TRUSTSW *RetTrustedDomain
    )

/*++

Routine Description:

    Add a DS_DOMAIN_TRUSTSW structure to the buffer described by BufferDescriptor.

Arguments:

    BufferDescriptor - Buffer entry is to be added to.

    NetbiosDomainName, DnsDomainName, Flags, ParentIndex, TrustType,
        TrustAttributes, DomainSid, DomainGuid - Fields to fill into
        the DS_DOMAIN_TRUSTSW structure

    RetSize - Returns the size in bytes of the allocated entry

    RetTrustedDomain - Returns a pointer to the newly allocated structure

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    PDS_DOMAIN_TRUSTSW TrustedDomain = NULL;
    UNICODE_STRING NetbiosDomainName;
    UNICODE_STRING DnsDomainName;

    ULONG Size;
    ULONG VariableSize;

    //
    // Initialization
    //

    if ( InNetbiosDomainName == NULL ) {
        RtlInitUnicodeString( &NetbiosDomainName, NULL );
    } else {
        NetbiosDomainName = *InNetbiosDomainName;
    }

    if ( InDnsDomainName == NULL ) {
        RtlInitUnicodeString( &DnsDomainName, NULL );
    } else {
        DnsDomainName = *InDnsDomainName;
    }

    //
    // Determine the size of this entry
    //

    Size = sizeof(DS_DOMAIN_TRUSTSW);
    VariableSize = 0;
    if ( DnsDomainName.Length != 0 ) {
        VariableSize += DnsDomainName.Length + sizeof(WCHAR);
    }
    if ( NetbiosDomainName.Length != 0 ) {
        VariableSize += NetbiosDomainName.Length + sizeof(WCHAR);
    }
    if ( DomainSid != NULL  ) {
        VariableSize += RtlLengthSid( DomainSid );
    }
    VariableSize = ROUND_UP_COUNT( VariableSize, ALIGN_DWORD );
    *RetSize = Size + VariableSize;

    Size += VariableSize;
    Size += sizeof(DWORD);    // Size is really a function of alignment of EndOfVariableData


    NetStatus = NetpAllocateEnumBufferEx(
                    BufferDescriptor,
                    FALSE,      // Not a 'get' operation
                    0xFFFFFFFF, // PrefMaxLen,
                    Size,
                    NlForestRelocationRoutine,
                    0,
                    512 );  // Grow by at most 512 bytes more than Size

    if (NetStatus != NERR_Success) {
        Status = NetpApiStatusToNtStatus( NetStatus );
        goto Cleanup;
    }

    //
    // Copy this entry into the buffer
    //

    TrustedDomain = (PDS_DOMAIN_TRUSTSW)(BufferDescriptor->FixedDataEnd);
    *RetTrustedDomain = TrustedDomain;
    BufferDescriptor->FixedDataEnd += sizeof(DS_DOMAIN_TRUSTSW);

    //
    // Copy the fixed size data
    //

    TrustedDomain->Flags = Flags;
    TrustedDomain->ParentIndex = ParentIndex;
    TrustedDomain->TrustType = TrustType;
    TrustedDomain->TrustAttributes = TrustAttributes;
    if ( DomainGuid == NULL ) {
        RtlZeroMemory( &TrustedDomain->DomainGuid, sizeof(GUID) );
    } else {
        TrustedDomain->DomainGuid = *DomainGuid;
    }


    //
    // Copy the information into the buffer.
    //

    //
    // Copy the DWORD aligned data
    //
    if ( DomainSid != NULL ) {
        if ( !NetpCopyDataToBuffer (
                (LPBYTE)DomainSid,
                RtlLengthSid( DomainSid ),
                BufferDescriptor->FixedDataEnd,
                &BufferDescriptor->EndOfVariableData,
                (LPBYTE *)&TrustedDomain->DomainSid,
                sizeof(DWORD) ) ) {

            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
    } else {
        TrustedDomain->DomainSid = NULL;
    }


    //
    // Copy the WCHAR aligned data.
    //

    if ( NetbiosDomainName.Length != 0 ) {
        if ( !NetpCopyStringToBuffer(
                    NetbiosDomainName.Buffer,
                    NetbiosDomainName.Length/sizeof(WCHAR),
                    BufferDescriptor->FixedDataEnd,
                    (LPWSTR *)&BufferDescriptor->EndOfVariableData,
                    &TrustedDomain->NetbiosDomainName ) ) {

            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
    } else {
        TrustedDomain->NetbiosDomainName = NULL;
    }

    if ( DnsDomainName.Length != 0 ) {
        if ( !NetpCopyStringToBuffer(
                    DnsDomainName.Buffer,
                    DnsDomainName.Length/sizeof(WCHAR),
                    BufferDescriptor->FixedDataEnd,
                    (LPWSTR *)&BufferDescriptor->EndOfVariableData,
                    &TrustedDomain->DnsDomainName ) ) {

            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
    } else {
        TrustedDomain->DnsDomainName = NULL;
    }


    Status = STATUS_SUCCESS;


    //
    //
Cleanup:

    return Status;
}


NTSTATUS
NlGetNt4TrustedDomainList (
    IN LPWSTR UncDcName,
    IN PUNICODE_STRING InNetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING InDnsDomainName OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    OUT PDS_DOMAIN_TRUSTSW *ForestTrustList,
    OUT PULONG ForestTrustListSize,
    OUT PULONG ForestTrustListCount
    )

/*++

Routine Description:

    Get the list of trusted domains from the specified DC using NT 4 protocols.

Arguments:

    UncDcName - Specifies the name of a DC in the domain.

    InNetbiosDomainName - Netbios domain of the domain Dc is in.

    InDnsDomainName - Dns domain of the domain Dc is in.

    DomainSid - Sid of the domain Dc is in.

    DomainGuid - Guid of the domain Dc is in.

    ForestTrustList - Returns a list of trusted domains.
        Must be freed using NetApiBufferFree

    ForestTrustListSize - Size (in bytes) of ForestTrustList

    ForestTrustListCount - Number of entries in ForestTrustList

Return Value:

    STATUS_SUCCESS - if the trust list was successfully returned

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    LSA_HANDLE LsaHandle = NULL;
    UNICODE_STRING UncDcNameString;
    OBJECT_ATTRIBUTES ObjectAttributes;

    LSA_ENUMERATION_HANDLE EnumerationContext;
    BOOLEAN AllDone = FALSE;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo = NULL;

    PLSA_TRUST_INFORMATION TrustList = NULL;
    BUFFER_DESCRIPTOR BufferDescriptor;
    PDS_DOMAIN_TRUSTSW TrustedDomain;
    DWORD Size