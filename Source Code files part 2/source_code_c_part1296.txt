                            dwConnectionId,
                                 &NwVolumeConnInfoContainer,
                                 resumeHandle );

        *ppVolumeConnInfo = (LPBYTE) NwVolumeConnInfoContainer.Buffer;

        if ( NwVolumeConnInfoContainer.Buffer != NULL ) {

            *pEntriesRead = NwVolumeConnInfoContainer.EntriesRead;

        } else {

            *pEntriesRead = 0;
        }
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeConnEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD dwLevel,
    IN LPWSTR pVolumeName OPTIONAL,
    IN DWORD  dwConnectionId,
    OUT PNWVOLUMECONNINFO *ppVolumeConnInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{   return( FpnwVolumeConnEnum( pServerName,
                                dwLevel,
                                pVolumeName,
                                dwConnectionId,
                                (LPBYTE *) ppVolumeConnInfo,
                                pEntriesRead,
                                resumeHandle ));
}



DWORD
FpnwFileEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    IN LPWSTR pPathName OPTIONAL,
    OUT LPBYTE *ppFileInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
/*++

Routine Description:

    This enumerates files opened on the server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the volume structure contained in
        *ppFileInfo, use 1 for now.

    pPathName - If this is not NULL, this means that we want to filter
        on the path. We only want entries with this path, i.e., all users that
        currently opened the file. If this is NULL, then all files that are
        opened are returned along with the user information.

    ppFileInfo - On return, this will point to an array of NWFILEINFO structures

    pEntriesRead - On return, this will specify the number of NWFILEINFO
        returned.

    resumeHandle - On return, a resume handle is stored in the DWORD pointed
        to by resumeHandle, and is used to continue an existing server search.
        The handle should be zero on the first call and left unchanged for
        subsequent calls. If the resumeHandle is NULL, then no resume
        handle is stored.

Return Value:

    Error.

--*/
{
    DWORD err;
    FPNWFILEINFO_CONTAINER NwFileInfoContainer;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if (( ppFileInfo == NULL ) || ( pEntriesRead == NULL ))
        return ERROR_INVALID_PARAMETER;

    NwFileInfoContainer.Buffer = NULL;

    RpcTryExcept
    {
        err = NwrFileEnum( pServerName,
                           dwLevel,
                           pPathName,
                           &NwFileInfoContainer,
                           resumeHandle );

        *ppFileInfo = (LPBYTE) NwFileInfoContainer.Buffer;

        if ( NwFileInfoContainer.Buffer != NULL ) {

            *pEntriesRead = NwFileInfoContainer.EntriesRead;

        } else {

            *pEntriesRead = 0;
        }
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwFileEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    IN LPWSTR pPathName OPTIONAL,
    OUT PNWFILEINFO *ppFileInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{   return(FpnwFileEnum( pServerName,
                         dwLevel,
                         pPathName,
                         (LPBYTE *) ppFileInfo,
                         pEntriesRead,
                         resumeHandle ));
}



DWORD
FpnwFileClose(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwFileId
)
/*++

Routine Description:

    This closes the file with the given identification number.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwFileId - The identification number of the file to close.

Return Value:

    Error.

--*/
{
    DWORD err;

    RpcTryExcept
    {
        err = NwrFileClose( pServerName,
                            dwFileId );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwFileClose(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwFileId
)
{   return(FpnwFileClose( pServerName, dwFileId ));
}



DWORD
FpnwMessageBufferSend(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId,
    IN DWORD  fConsoleBroadcast,
    IN LPBYTE pbBuffer,
    IN DWORD  cbBuffer
)
/*++

Routine Description:

    This sends the message to the given connection id.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwConnectionId - The id of the connection to send message to.

    fConsoleBroadcast - If this is TRUE, that means use console broadcast. If
        FALSE, use user broadcast.

    pbBuffer - Points to the message buffer to be sent.

    cbBuffer - The size of the pbBuffer in bytes.

Return Value:

    Error.

--*/
{
    DWORD err;

    if (( pbBuffer == NULL ) || ( cbBuffer == 0 ))
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrMessageBufferSend( pServerName,
                                    dwConnectionId,
                                    fConsoleBroadcast,
                                    pbBuffer,
                                    cbBuffer );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwMessageBufferSend(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId,
    IN DWORD  fConsoleBroadcast,
    IN LPBYTE pbBuffer,
    IN DWORD  cbBuffer
)
{   return( FpnwMessageBufferSend(  pServerName,
                                    dwConnectionId,
                                    fConsoleBroadcast,
                                    pbBuffer,
                                    cbBuffer ));
}



DWORD
FpnwSetDefaultQueue(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pQueueName
)
/*++

Routine Description:

    This sets the default queue on the server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pQueueName - The name of the queue that will become the default

Return Value:

    Error.

--*/
{
    DWORD err;

    if (( pQueueName == NULL ) || ( *pQueueName == 0 ))
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrSetDefaultQueue( pServerName,
                                  pQueueName );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwSetDefaultQueue(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pQueueName
)
{   return(FpnwSetDefaultQueue( pServerName, pQueueName ));
}



DWORD
FpnwAddPServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
)
/*++

Routine Description:

    This adds a pserver.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pPServerName - The name of the PServer.

Return Value:

    Error.

--*/
{
    DWORD err;

    if (( pPServerName == NULL ) || ( *pPServerName == 0 ))
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrAddPServer( pServerName,
                             pPServerName );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwAddPServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
)
{   return( FpnwAddPServer( pServerName, pPServerName ));
}



DWORD
FpnwRemovePServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
)
/*++

Routine Description:

    This removes a pserver.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pPServerName - The name of the PServer.

Return Value:

    Error.

--*/
{
    DWORD err;

    if (( pPServerName == NULL ) || ( *pPServerName == 0 ))
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrRemovePServer( pServerName,
                                pPServerName );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwRemovePServer(
    IN LPWSTR pServerName OPTIONAL,
    IN LPWSTR pPServerName
)
{   return( FpnwRemovePServer( pServerName, pPServerName ));
}


DWORD NwpMapRpcError(
    IN DWORD RpcError
)
/*++

Routine Description:

    This routine maps the RPC error into a more meaningful windows
    error for the caller.

Arguments:

    RpcError - Supplies the exception error raised by RPC

Return Value:

    Returns the mapped error.

--*/
{

    switch (RpcError)
    {
        case RPC_S_INVALID_BINDING:
        case RPC_X_SS_IN_NULL_CONTEXT:
        case RPC_X_SS_CONTEXT_DAMAGED:
        case RPC_X_SS_HANDLES_MISMATCH:
        case ERROR_INVALID_HANDLE:
            return ERROR_INVALID_HANDLE;

        case RPC_X_NULL_REF_POINTER:
            return ERROR_INVALID_PARAMETER;

        case STATUS_ACCESS_VIOLATION:
            return ERROR_INVALID_ADDRESS;

        default:
            return RpcError;
    }
}

// ncpstub.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\inc\imports.h ===
#include <windef.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t *
#define BOOL DWORD
#endif

#include "nwstruct.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\client\notify.c ===
/*++

Copyright (c) 1987-1994  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    Sample SubAuthentication Package.

Author:

    Yi-Hsin Sung (yihsins) 27-Feb-1995

Revisions:


Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntlsa.h>

#include <windef.h>
#include <winbase.h>
#include <winuser.h>

#include <lmaccess.h>
#include <lmapibuf.h>

#include <nwsutil.h>
#include <fpnwcomm.h>
#include <usrprop.h>
#include <fpnwapi.h>
#include <nwsutil.h>

#define SW_DLL_NAME        L"swclnt.dll"
#define PASSWORD_PROC_NAME "SwPasswordChangeNotify"
#define NOTIFY_PROC_NAME   "SwDeltaChangeNotify"
#define NO_GRACE_LOGIN_LIMIT 0xFF

typedef DWORD (*PWPROC)( LPWSTR pUserName,
                         ULONG  RelativeId,
                         LPWSTR pPassword );

DWORD
GetNCPLSASecret(
    VOID
);

BOOL      fTriedToGetSW = FALSE;
BOOL      fTriedToGetNCP = FALSE;
HINSTANCE hinstSW = NULL;
PWPROC    ProcPasswordChange = NULL;
PSAM_DELTA_NOTIFICATION_ROUTINE ProcDeltaChange = NULL;
BOOL      fGotSecret = FALSE;
char      szNWSecretValue[NCP_LSA_SECRET_LENGTH] = "";



NTSTATUS
PasswordChangeNotify(
    PUNICODE_STRING UserName,
    ULONG RelativeId,
    PUNICODE_STRING Password
    )
{
    DWORD err = NO_ERROR;
    PUSER_INFO_2 pUserInfo2 = NULL;
    LPWSTR pszUser = NULL;
    LPWSTR pszPassword = NULL;

    //
    // If password is NULL, we can't get the cleartext password. Hence,
    // ignore this notification. Same for UserName.
    //
    if ( (Password == NULL) || (Password->Buffer == NULL) )
        return STATUS_SUCCESS;

    if ( (UserName == NULL) || (UserName->Buffer == NULL) )
        return STATUS_SUCCESS;

    //
    //  if neither DSMN nor FPNW are installed, blow out of here as there's
    //  nothing to do.
    //

    if ( ( fTriedToGetSW && hinstSW == NULL ) &&
         ( fTriedToGetNCP && fGotSecret == FALSE) )
    {
        return STATUS_SUCCESS;
    }

    //
    // Make sure user name and password are null terminated
    //
    pszUser = LocalAlloc( LMEM_ZEROINIT, UserName->Length + sizeof(WCHAR));

    if ( pszUser == NULL )
        return STATUS_NO_MEMORY;

    pszPassword = LocalAlloc( LMEM_ZEROINIT, Password->Length + sizeof(WCHAR));

    if ( pszPassword == NULL )
    {
        LocalFree( pszUser );
        return STATUS_NO_MEMORY;
    }

    memcpy( pszUser, UserName->Buffer, UserName->Length );
    memcpy( pszPassword, Password->Buffer, Password->Length );
    CharUpper( pszPassword );

    //
    // First, try to change the small world password if it is installed.
    //
    if ( !fTriedToGetSW )
    {
        hinstSW = LoadLibrary( SW_DLL_NAME );
        fTriedToGetSW = TRUE;
    }

    if (( hinstSW != NULL ) && ( ProcPasswordChange == NULL ))
    {
        ProcPasswordChange = (PWPROC) GetProcAddress( hinstSW,
                                                      PASSWORD_PROC_NAME );
    }

    if ( ProcPasswordChange != NULL )
    {
        err = (ProcPasswordChange)( pszUser, RelativeId, pszPassword );
    }

#if DBG
    if ( err )
    {
        KdPrint(("[FPNWCLNT] SwPasswordChangeNotify of user %ws changing returns %d.\n", pszUser, err ));
    }
#endif

    //
    //  we require that the PDC be rebooted after either DSMN or FPNW is
    //  installed anywhere in the domain for the first server... if we
    //  decide we shouldn't require a reboot, change the code such that
    //  it looks for the LSA secret everytime, not just first time through.
    //

    if ( !fTriedToGetNCP ) {

        fTriedToGetNCP = TRUE;

        //
        // Get the LSA secret used to encrypt the password
        //
        err = GetNCPLSASecret();
    }

    if ( !fGotSecret ) {

        goto CleanUp;
    }

    //
    // Next, change the netware password residue in the user parms field
    //
    err = NetUserGetInfo( NULL,
                          pszUser,
                          2,
                          (LPBYTE *) &pUserInfo2 );

    if ( !err )
    {
        WCHAR PropertyFlag;
        UNICODE_STRING PropertyValue;

        err = RtlNtStatusToDosError(
                  NetpParmsQueryUserProperty( pUserInfo2->usri2_parms,
                                     NWPASSWORD,
                                     &PropertyFlag,
                                     &PropertyValue ));


        if ( !err  && PropertyValue.Length != 0 )
        {
            //
            // This is a netware-enabled user, we need to store
            // the new password residue into the user parms
            //

            NT_PRODUCT_TYPE ProductType;
            WCHAR szEncryptedNWPassword[NWENCRYPTEDPASSWORDLENGTH];
            DWORD dwUserId;
            WORD wGraceLoginRemaining;
            WORD wGraceLoginAllowed;

            LocalFree( PropertyValue.Buffer );

            //
            // Get the grace login allowed and remaining value
            //
            err = RtlNtStatusToDosError(
                      NetpParmsQueryUserProperty( pUserInfo2->usri2_parms,
                                         GRACELOGINREMAINING,
                                         &PropertyFlag,
                                         &PropertyValue ));

            if ( !err && ( PropertyValue.Length != 0 ))
            {
                wGraceLoginRemaining = (WORD) *(PropertyValue.Buffer);
                LocalFree( PropertyValue.Buffer );

                if ( wGraceLoginRemaining != NO_GRACE_LOGIN_LIMIT )
                {
                    // If the grace login remaining is not unlimited,
                    // then we need to reset grace login remaining to
                    // the value in grace login allowed. Hence, read the
                    // grace login allowed value.

                    err = RtlNtStatusToDosError(
                              NetpParmsQueryUserProperty( pUserInfo2->usri2_parms,
                                                 GRACELOGINALLOWED,
                                                 &PropertyFlag,
                                                 &PropertyValue ));

                    if ( !err && ( PropertyValue.Length != 0 ))
                    {
                        wGraceLoginAllowed = (WORD) *(PropertyValue.Buffer);
                        LocalFree( PropertyValue.Buffer );
                    }

                }
            }


            if ( !err )
            {
                RtlGetNtProductType( &ProductType );


                dwUserId = MapRidToObjectId(
                               RelativeId,
                               pszUser,
                               ProductType == NtProductLanManNt,
                               FALSE );

                err = RtlNtStatusToDosError(
                          ReturnNetwareForm(
                              szNWSecretValue,
                              dwUserId,
                              pszPassword,
                              (UCHAR *) szEncryptedNWPassword ));
            }

            if ( !err )
            {
                LPWSTR pNewUserParms = NULL;
                BOOL fUpdate;
                UNICODE_STRING uPropertyValue;

                uPropertyValue.Buffer = szEncryptedNWPassword;
                uPropertyValue.Length = uPropertyValue.MaximumLength
                                      = sizeof( szEncryptedNWPassword );

                err = RtlNtStatusToDosError(
                          NetpParmsSetUserProperty(
                                  pUserInfo2->usri2_parms,
                                  NWPASSWORD,
                                  uPropertyValue,
                                  PropertyFlag,
                                  &pNewUserParms,
                                  &fUpdate ));

                if ( !err && fUpdate )
                {
                    USER_INFO_1013 userInfo1013;
                    LPWSTR pNewUserParms2 = NULL;
                    LPWSTR pNewUserParms3 = NULL;
                    LARGE_INTEGER currentTime;

                    //
                    //  Since we're resetting the user's password, let's
                    //  also clear the flag saying the password has
                    //  expired.  We do this by putting the current
                    //  time into the NWPasswordSet.
                    //

                    NtQuerySystemTime (&currentTime);

                    uPropertyValue.Buffer = (PWCHAR) &currentTime;
                    uPropertyValue.Length = sizeof (LARGE_INTEGER);
                    uPropertyValue.MaximumLength = sizeof (LARGE_INTEGER);

                    NetpParmsSetUserProperty( pNewUserParms,
                                     NWTIMEPASSWORDSET,
                                     uPropertyValue,
                                     (SHORT) 0,      // not a set
                                     &pNewUserParms2,
                                     &fUpdate );

                    if (pNewUserParms2 != NULL) {
                        userInfo1013.usri1013_parms = pNewUserParms2;
                    } else {
                        userInfo1013.usri1013_parms = pNewUserParms;
                    }

                    if ( wGraceLoginRemaining != NO_GRACE_LOGIN_LIMIT )
                    {
                        // If the grace login remaining is not unlimited,
                        // then we need to reset grace login remaining to
                        // the value in grace login allowed.

                        uPropertyValue.Buffer = (PWCHAR) &wGraceLoginAllowed;
                        uPropertyValue.Length = uPropertyValue.MaximumLength
                                              = sizeof(wGraceLoginAllowed);

                        NetpParmsSetUserProperty( userInfo1013.usri1013_parms,
                                         GRACELOGINREMAINING,
                                         uPropertyValue,
                                         (SHORT) 0,      // not a set
                                         &pNewUserParms3,
                                         &fUpdate );

                        if (pNewUserParms3 != NULL)
                            userInfo1013.usri1013_parms = pNewUserParms3;
                    }

                    err = NetUserSetInfo( NULL,
                                          pszUser,
                                          USER_PARMS_INFOLEVEL,
                                          (LPBYTE) &userInfo1013,
                                          NULL );

                    if (pNewUserParms2 != NULL)
                        NetpParmsUserPropertyFree( pNewUserParms2 );

                    if (pNewUserParms3 != NULL)
                        NetpParmsUserPropertyFree( pNewUserParms3 );
                }

                if ( pNewUserParms != NULL )
                    NetpParmsUserPropertyFree( pNewUserParms );
            }
        }

        NetApiBufferFree( pUserInfo2 );
    }

#if DBG
    if ( err )
    {
        KdPrint(("[FPNWCLNT] Password of user %ws changing returns %d.\n",
                pszUser, err ));
    }
#endif

CleanUp:

    LocalFree( pszUser );

    // Need to clear all memory that contains password
    memset( pszPassword, 0, Password->Length + sizeof( WCHAR ));
    LocalFree( pszPassword );

    return STATUS_SUCCESS;
}


BOOLEAN
InitializeChangeNotify (
    VOID
    )
{
    DWORD err = NO_ERROR;

    //
    // First, check to see if small world is installed.
    //
    if ( !fTriedToGetSW )
    {
        hinstSW = LoadLibrary( SW_DLL_NAME );
        fTriedToGetSW = TRUE;
    }

    if (( hinstSW != NULL )) {

        return TRUE;
    }

    if ( !fTriedToGetNCP ) {

        fTriedToGetNCP = TRUE;

        //
        // Get the LSA secret used to encrypt the password
        //
        err = GetNCPLSASecret();
    }

    return (fGotSecret != 0);
}



DWORD
GetNCPLSASecret(
    VOID
)
{
    DWORD err;
    LSA_HANDLE hlsaPolicy;
    OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    LSA_HANDLE hlsaSecret;
    UNICODE_STRING uSecretName;
    UNICODE_STRING *puSecretValue;
    LARGE_INTEGER lintCurrentSetTime, lintOldSetTime;

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes( &oa, NULL, 0L, NULL, NULL );

    //
    // The InitializeObjectAttributes macro presently store NULL for
    // the psqos field, so we must manually copy that
    // structure for now.
    //

    oa.SecurityQualityOfService = &sqos;


    err = RtlNtStatusToDosError( LsaOpenPolicy( NULL,
                                                &oa,
                                                GENERIC_EXECUTE,
                                                &hlsaPolicy ));

    if ( !err )
    {
        RtlInitUnicodeString( &uSecretName, NCP_LSA_SECRET_KEY );
        err = RtlNtStatusToDosError( LsaOpenSecret( hlsaPolicy,
                                                    &uSecretName,
                                                    SECRET_QUERY_VALUE,
                                                    &hlsaSecret ));

        if ( !err )
        {
            err = RtlNtStatusToDosError(
                      LsaQuerySecret( hlsaSecret,
                                      &puSecretValue,
                                      &lintCurrentSetTime,
                                      NULL,
                                      &lintOldSetTime ));

            if ( !err )
            {
                memcpy( szNWSecretValue,
                        puSecretValue->Buffer,
                        NCP_LSA_SECRET_LENGTH );

                fGotSecret = TRUE;

                (VOID) LsaFreeMemory( puSecretValue );
            }

            (VOID) LsaClose( hlsaSecret );

        }

        (VOID) LsaClose( hlsaPolicy );
    }

    return err;

}



NTSTATUS
DeltaNotify(
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName OPTIONAL,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )
{
    NTSTATUS err = NO_ERROR;

    //
    // Try to notify small world of SAM changes if it is installed.
    //

    if ( !fTriedToGetSW )
    {
        hinstSW = LoadLibrary( SW_DLL_NAME );
        fTriedToGetSW = TRUE;
    }

    if ( ( hinstSW != NULL ) && ( ProcDeltaChange == NULL ))
    {
        ProcDeltaChange = (PSAM_DELTA_NOTIFICATION_ROUTINE)
                               GetProcAddress( hinstSW, NOTIFY_PROC_NAME );
    }

    if ( ProcDeltaChange != NULL )
    {
        err = (ProcDeltaChange)( DomainSid,
                                 DeltaType,
                                 ObjectType,
                                 ObjectRid,
                                 ObjectName,
                                 ModifiedCount,
                                 DeltaData );
    }

#if DBG
    if ( err )
    {
        KdPrint(("[FPNWCLNT] SwDeltaChangeNotify of type %d on rid 0x%x returns %d.\n", DeltaType, ObjectRid, err ));
    }
#endif

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\client\nwsutil.c ===
/*++

Copyright (c) 1993-1993  Microsoft Corporation

Module Name:

    nwsutil.c

Abstract:

    This module implements IsNetWareInstalled()

Author:

    Congpa You  (CongpaY)   02-Dec-1993   Crested

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include "windef.h"
#include "winerror.h"
#include "winbase.h"

#include "ntlsa.h"
#include "nwsutil.h"
#include "crypt.h"

#include <fpnwcomm.h>
#include <usrprop.h>

NTSTATUS
GetRemoteNcpSecretKey (
    PUNICODE_STRING SystemName,
    CHAR *pchNWSecretKey
    )
{
    //
    //  this function returns the FPNW LSA Secret for the specified domain
    //

    NTSTATUS          ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;
    LSA_HANDLE        PolicyHandle = NULL;
    LSA_HANDLE        SecretHandle = NULL;
    UNICODE_STRING    SecretNameString;
    PUNICODE_STRING   punicodeCurrentValue;
    PUNICODE_STRING   punicodeOldValue;

    InitializeObjectAttributes( &ObjAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntstatus = LsaOpenPolicy( SystemName,
                              &ObjAttributes,
                              POLICY_CREATE_SECRET,
                              &PolicyHandle );

    if ( !NT_SUCCESS( ntstatus ))
    {
        return( ntstatus );
    }

    RtlInitUnicodeString( &SecretNameString, NCP_LSA_SECRET_KEY );

    ntstatus = LsaOpenSecret( PolicyHandle,
                              &SecretNameString,
                              SECRET_QUERY_VALUE,
                              &SecretHandle );

    if ( !NT_SUCCESS( ntstatus ))
    {
        LsaClose( PolicyHandle );
        return( ntstatus );
    }

    //
    // Do not need the policy handle anymore.
    //

    LsaClose( PolicyHandle );

    ntstatus = LsaQuerySecret( SecretHandle,
                               &punicodeCurrentValue,
                               NULL,
                               &punicodeOldValue,
                               NULL );

    //
    // Do not need the secret handle anymore.
    //

    LsaClose( SecretHandle );

    if ( NT_SUCCESS(ntstatus) && ( punicodeCurrentValue->Buffer != NULL))
    {
        memcpy( pchNWSecretKey,
                punicodeCurrentValue->Buffer,
                min(punicodeCurrentValue->Length, USER_SESSION_KEY_LENGTH));
    }

    LsaFreeMemory( punicodeCurrentValue );
    LsaFreeMemory( punicodeOldValue );

    return( ntstatus );
}

NTSTATUS
GetNcpSecretKey (
    CHAR *pchNWSecretKey
    )
{
    //
    //  simply return the LSA Secret for the local domain
    //

    return GetRemoteNcpSecretKey( NULL, pchNWSecretKey );
}

BOOL IsNetWareInstalled( VOID )
{
    CHAR pszNWSecretKey[USER_SESSION_KEY_LENGTH];

    return( !NT_SUCCESS( GetNcpSecretKey (pszNWSecretKey))
                       ? FALSE
                       : (pszNWSecretKey[0] != 0));
}

NTSTATUS InstallNetWare( LPWSTR lpNcpSecretKey )
{
    NTSTATUS          ntstatus;
    OBJECT_ATTRIBUTES ObjAttributes;
    LSA_HANDLE        PolicyHandle;
    LSA_HANDLE        SecretHandle;
    UNICODE_STRING    SecretNameString;
    UNICODE_STRING    unicodeCurrentValue;
    UNICODE_STRING    unicodeOldValue;

    InitializeObjectAttributes( &ObjAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL);

    ntstatus = LsaOpenPolicy( NULL,
                              &ObjAttributes,
                              POLICY_CREATE_SECRET,
                              &PolicyHandle );

    if ( !NT_SUCCESS( ntstatus ))
    {
        return( ntstatus );
    }

    RtlInitUnicodeString( &SecretNameString, NCP_LSA_SECRET_KEY );

    ntstatus = LsaCreateSecret( PolicyHandle,
                                &SecretNameString,
                                SECRET_SET_VALUE | DELETE,
                                &SecretHandle );

    if ( ntstatus == STATUS_OBJECT_NAME_COLLISION )
    {
        ntstatus = LsaOpenSecret( PolicyHandle,
                                  &SecretNameString,
                                  SECRET_SET_VALUE,
                                  &SecretHandle );
    }

    if ( NT_SUCCESS( ntstatus ))
    {
        RtlInitUnicodeString( &unicodeOldValue, NULL );
        RtlInitUnicodeString( &unicodeCurrentValue, lpNcpSecretKey );

        ntstatus = LsaSetSecret( SecretHandle,
                                 &unicodeCurrentValue,
                                 &unicodeOldValue );

        LsaClose( SecretHandle );
    }

    LsaClose( PolicyHandle );

    return( ntstatus );
}

ULONG
MapRidToObjectId(
    DWORD dwRid,
    LPWSTR pszUserName,
    BOOL fNTAS,
    BOOL fBuiltin )
{
    (void) fBuiltin ;   // unused for now.

    if (pszUserName && (lstrcmpi(pszUserName, SUPERVISOR_NAME_STRING)==0))
        return SUPERVISOR_USERID ;

    return ( fNTAS ? (dwRid | 0x10000000) : dwRid ) ;
}


ULONG SwapObjectId( ULONG ulObjectId )
{
    return (MAKELONG(HIWORD(ulObjectId),SWAPWORD(LOWORD(ulObjectId)))) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\inc\nwprint.h ===
/*++

Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.

Module Name:

    nw\svcdlls\ncpsvc\proc\nwprint.h

Abstract:

    Include file for the NCP print processor.

Author:

    Tommy Evans (vtommye) 02-16-1993

Revision History:

--*/

/** Data types we support **/

#define PRINTPROCESSOR_TYPE_RAW         0
#define PRINTPROCESSOR_TYPE_RAW_FF      1
#define PRINTPROCESSOR_TYPE_RAW_FF_AUTO 2
#define PRINTPROCESSOR_TYPE_JOURNAL     3
#define PRINTPROCESSOR_TYPE_TEXT        4
#define PRINTPROCESSOR_TYPE_NT_TEXT     5
#define PRINTPROCESSOR_TYPE_NUM         6   /* What is this? */

/** This is so we can compile JOURNAL.C **/

extern BOOL GdiPlayJournal(HDC, LPWSTR, DWORD, DWORD, INT);

extern HANDLE NCPXsPortHandle;

#define IDS_PSERVER_PORT 400

/** Structure used to track jobs **/

typedef struct _PRINTPROCESSORDATA {
    DWORD   signature;
    DWORD   cb;
    struct _PRINTPROCESSORDATA *pNext;
    DWORD   fsStatus;
    DWORD   uDatatype;
    DWORD   JobId;
    DWORD   Copies;                 /* Number of copies to print */
    DWORD   TabSize;                /* Tab expansion size */
    ULONG   QueueId;                /* Object id of the queue */
    HANDLE  semPaused;              /* Semaphore for job pausing */
    HANDLE  hPrinter;
    HANDLE  hLPCPort;
    HDC     hDC;
    LPWSTR  pPortName;              /* Text string for printer port */
    LPWSTR  pPrinterName;           /* Text string for printer name */
    LPWSTR  pDocument;
    LPWSTR  pOutputFile;
    LPWSTR  pDatatype;              /* Text string for datatype */
    LPWSTR  pParameters;            /* Parameters string for job */
    USHORT  NcpJobNumber;           /* NetWare job number for this job */
    BOOL    PServerPortFlag;        /* Flag if on a PServer port */
    BOOL    PServerAttachedFlag;    /* Flag if PServer attached to q */
} PRINTPROCESSORDATA, *PPRINTPROCESSORDATA;

#define PRINTPROCESSORDATA_SIGNATURE    0x5051  /* 'QP' is the signature value */

/* Define flags for fsStatus field */

#define PRINTPROCESSOR_ABORTED      0x0001
#define PRINTPROCESSOR_PAUSED       0x0002
#define PRINTPROCESSOR_CLOSED       0x0004

#define PRINTPROCESSOR_RESERVED     0xFFF8

/** Flags used for the GetKey routing **/

#define VALUE_STRING    0x01
#define VALUE_ULONG     0x02

/** Buffer sizes we'll use **/

#define READ_BUFFER_SIZE            4096
#define BASE_PRINTER_BUFFER_SIZE    2048

PPRINTPROCESSORDATA
ValidateHandle(
    HANDLE  hPrintProcessor
);

/**
    Debugging stuff.
**/

#define DBG_NONE    0x00000000
#define DBG_INFO    0x00000001
#define DBG_WARNING 0x00000002
#define DBG_ERROR   0x00000004
#define DBG_TRACE   0x00000008

#if DBG

/* Quick fix:
 *
 * Ensure DbgPrint and DbgBreakPoint are prototyped,
 * so that we're not affected by STDCALL.
 * This should be replaced by OutputDebugString
 */
ULONG
DbgPrint(
    PCH Format,
    ...
    );

VOID
DbgBreakPoint(
    VOID
    );


#define GLOBAL_DEBUG_FLAGS Debug

extern DWORD GLOBAL_DEBUG_FLAGS;

/* These flags are not used as arguments to the DBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with DBGMSG.
 * (Here mainly for explanatory purposes.)
 */
#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */
#define DBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}

#else
#define DBGMSG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\inc\srvnames.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    srvnames.h

Abstract:

    Private header file which defines the Server Service names.

Author:

    Dan Lafferty (danl) 07-Jan-1993

Revision History:

--*/

#define SERVER_INTERFACE_NAME    TEXT("FPNW")

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\nds.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nds.h

Abstract:

    This defines the necessary NDS data structures and
    symbolic constants for both kernel and user mode
    components.

Author:

    Cory West    [CoryWest]    08-Jan-1996

Revision History:

--*/

//
// NDS Actions.
//

#define NDS_REQUEST 104  // NCP Function Number.
#define NDS_PING    1    // Subfunction code for ping.
#define NDS_ACTION  2    // Subfunction code for action.

//
// NDS Verb Numbers.
//

#define NDSV_RESOLVE_NAME               1
#define NDSV_READ_ENTRY_INFO            2
#define NDSV_READ                       3
#define NDSV_LIST                       5
#define NDSV_OPEN_STREAM                27
#define NDSV_GET_SERVER_ADDRESS         53
#define NDSV_CHANGE_PASSWORD            55
#define NDSV_BEGIN_LOGIN                57
#define NDSV_FINISH_LOGIN               58
#define NDSV_BEGIN_AUTHENTICATE         59
#define NDSV_FINISH_AUTHENTICATE        60
#define NDSV_LOGOUT                     61

//
// Rounding Macros.
//

#define ROUNDUP4(x)                     ( ( (x) + 3 ) & ( ~3 ) )
#define ROUNDUP2(x)                     ( ( (x) + 1 ) & ( ~1 ) )

//
// Context Flags.
//

#define FLAGS_DEREF_ALIASES             0x1
#define FLAGS_XLATE_STRINGS             0x2
#define FLAGS_TYPELESS_NAMES            0x4
#define FLAGS_ASYNC_MODE                0x8     // Not supported.
#define FLAGS_CANONICALIZE_NAMES        0x10
#define FLAGS_ALL_PUBLIC                0x1f

//
// values for RESOLVE_NAME request flags
//

#define RSLV_DEREF_ALIASES  0x40
#define RSLV_READABLE       0x02
#define RSLV_WRITABLE       0x04
#define RSLV_WALK_TREE      0x20
#define RSLV_CREATE_ID      0x10
#define RSLV_ENTRY_ID       0x1

#define RESOLVE_NAME_ACCEPT_REMOTE      1
#define RESOLVE_NAME_REFER_REMOTE       2

//
// Confidence Levels.
//

#define LOW_CONF        0
#define MED_CONF        1
#define HIGH_CONF       2

//
// Referral Scopes.
//

#define ANY_SCOPE           0
#define COUNTRY_SCOPE       1
#define ORGANIZATION_SCOPE  2
#define LOCAL_SCOPE         3

//
// Max name sizes.
//

#define MAX_NDS_SCHEMA_NAME_CHARS 32

#define MAX_NDS_NAME_CHARS      256
#define MAX_NDS_NAME_SIZE       ( MAX_NDS_NAME_CHARS * 2 )
#define MAX_NDS_TREE_NAME_LEN   32

//
// For an NDS exchange, we use buffers of this size to hold the send
// and receive data.  These sizes come from the Win95 implementation.
//

#define NDS_BUFFER_SIZE         2048
#define DUMMY_ITER_HANDLE       ( ( unsigned long ) 0xffffffff )
#define INITIAL_ITERATION       ( ( unsigned long ) 0xffffffff )
#define ENTRY_INFO_NAME_VALUE   1

//
// Various server responses.
//

typedef struct {

    DWORD CompletionCode;
    DWORD RemoteEntry;
    DWORD EntryId;
    DWORD ServerNameLength;
    WCHAR ReferredServer[1];

    //
    // If RemoteEntry is set to RESOLVE_NAME_REFER_REMOTE,
    // Then the tree server doesn't know the information
    // about the object in question and has referred us to
    // the server named in ReferredServer.
    //

} NDS_RESPONSE_RESOLVE_NAME, *PNDS_RESPONSE_RESOLVE_NAME;

typedef struct {

    DWORD CompletionCode;
    DWORD EntryFlags;
    DWORD SubordinateCount;
    DWORD ModificationTime;

    //
    // Two UNICODE strings follow in standard NDS format:
    //
    //     DWORD BaseClassLen;
    //     WCHAR BaseClass[BaseClassLen];
    //     DWORD EntryNameLen;
    //     WCHAR EntryName[EntryNameLen];
    //

} NDS_RESPONSE_GET_OBJECT_INFO, *PNDS_RESPONSE_GET_OBJECT_INFO;

typedef struct {

    DWORD EntryId;
    DWORD Flags;
    DWORD SubordinateCount;
    DWORD ModificationTime;

    //
    // Two UNICODE strings follow in standard NDS format:
    //
    //     DWORD BaseClassLen;
    //     WCHAR BaseClass[BaseClassLen];
    //     DWORD EntryNameLen;
    //     WCHAR EntryName[EntryNameLen];
    //

} NDS_RESPONSE_SUBORDINATE_ENTRY, *PNDS_RESPONSE_SUBORDINATE_ENTRY;

typedef struct {

    DWORD  CompletionCode;
    DWORD  IterationHandle;
    DWORD  SubordinateEntries;

    //
    // Followed by an array of NDS_SUBORDINATE_ENTRY
    // structures that is SubordinateEntries long.
    //

} NDS_RESPONSE_SUBORDINATE_LIST, *PNDS_RESPONSE_SUBORDINATE_LIST;

typedef struct {

    DWORD SyntaxID;
    DWORD AttribNameLength;
    WCHAR AttribName[1];

    //
    // AttribName is of length
    // AttribNameLength, of course.
    //

    DWORD NumValues;

    //
    // Followed by an array of NumValues
    // Attrib structures.
    //

} NDS_ATTRIBUTE, *PNDS_ATTRIBUTE;

typedef struct {

    DWORD CompletionCode;
    DWORD IterationHandle;
    DWORD InfoType;
    DWORD NumAttributes;

    //
    // Followed by an array of
    // NDS_ATTRIBUTE structures.
    //

} NDS_RESPONSE_READ_ATTRIBUTE, *PNDS_RESPONSE_READ_ATTRIBUTE;

typedef struct {
    DWORD dwLength;
    WCHAR Buffer[1];
} NDS_STRING, *PNDS_STRING;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\nwcanon.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwcanon.h

Abstract:

    Header for NetWare names canonicalization library routines.

Author:

    Rita Wong      (ritaw)      19-Feb-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NW_CANON_INCLUDED_
#define _NW_CANON_INCLUDED_

DWORD
NwLibValidateLocalName(
    IN LPWSTR LocalName
    );

DWORD
NwLibCanonLocalName(
    IN LPWSTR LocalName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    );

DWORD
NwLibCanonRemoteName(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    );

DWORD
NwLibCanonUserName(
    IN LPWSTR UserName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    );

#endif // _NW_CANON_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\inc\nwsutil.h ===
/*++

Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.

Module Name:

    nwsutil.h

Abstract:

    This is the public include file for some of the functions used by
    User Manager and Server Manager.

Author:

    Congpa You 02-Dec-1993  Created.

Revision History:

--*/

#ifndef _NWSUTIL_H_
#define _NWSUTIL_H_

#include <crypt.h>
#include <fpnwname.h>


/** Function Prototypes **/

NTSTATUS GetNcpSecretKey( CHAR *pchNWSecretKey );

NTSTATUS
GetRemoteNcpSecretKey (
    PUNICODE_STRING SystemName,
    CHAR *pchNWSecretKey
    );

BOOL IsNetWareInstalled( VOID );

ULONG
MapRidToObjectId(
    DWORD dwRid,
    LPWSTR pszUserName,
    BOOL fNTAS,
    BOOL fBuiltin
    );

ULONG
SwapObjectId(
    ULONG ulObjectId
    ) ;

NTSTATUS InstallNetWare( LPWSTR lpNcpSecretKey );

VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer
    );

//Encryption function
NTSTATUS ReturnNetwareForm (const char * pszSecretValue,
                            DWORD dwUserId,
                            const WCHAR * pchNWPassword,
                            UCHAR * pchEncryptedNWPassword);

#endif // _NWSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\ntddnwfs.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ntddnwfs.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the NetWare redirector file system device.

Author:

    Colin Watson   (ColinW)  23-Dec-1992

Revision History:


--*/

#ifndef _NTDDNWFS_
#define _NTDDNWFS_

#include <windef.h>
#include <winnetwk.h>      // NETRESOURCE structure

typedef CHAR SERVERNAME[48];
typedef SERVERNAME* PSERVERNAME;

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_NWFS_DEVICE_NAME    "\\Device\\NwRdr"
#define DD_NWFS_DEVICE_NAME_U L"\\Device\\NwRdr"

//
// The file system name as returned by
// NtQueryInformationVolume(FileFsAttributeInformation)
//
#define DD_NWFS_FILESYS_NAME "NWRDR"
#define DD_NWFS_FILESYS_NAME_U L"NWRDR"

//
// Connection type bit mask
//
#define CONNTYPE_DISK      0x00000001
#define CONNTYPE_PRINT     0x00000002
#define CONNTYPE_ANY       ( CONNTYPE_DISK | CONNTYPE_PRINT )
#define CONNTYPE_IMPLICIT  0x80000000
#define CONNTYPE_SYMBOLIC  0x40000000
#define CONNTYPE_UID       0x00010000

//
// EA Names for creating a connection
//
#define EA_NAME_USERNAME        "UserName"
#define EA_NAME_PASSWORD        "Password"
#define EA_NAME_TYPE            "Type"
#define EA_NAME_CREDENTIAL_EX   "ExCredentials"

#define TRANSACTION_REQUEST     0x00000003


//
// NtDeviceIoControlFile/NtFsControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
//      Method = 00 - Buffer both input and output buffers for the request
//      Method = 01 - Buffer input, map output buffer to an MDL as an IN buff
//      Method = 10 - Buffer input, map output buffer to an MDL as an OUT buff
//      Method = 11 - Do not buffer either the input or output
//

#define IOCTL_NWRDR_BASE                  FILE_DEVICE_NETWORK_FILE_SYSTEM

#define _NWRDR_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_NWRDR_BASE, request, method, access)

#define FSCTL_NWR_START                 _NWRDR_CONTROL_CODE(200, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_NWR_STOP                  _NWRDR_CONTROL_CODE(201, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_LOGON                 _NWRDR_CONTROL_CODE(202, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_LOGOFF                _NWRDR_CONTROL_CODE(203, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONNECTION        _NWRDR_CONTROL_CODE(204, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_ENUMERATE_CONNECTIONS _NWRDR_CONTROL_CODE(205, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_DELETE_CONNECTION     _NWRDR_CONTROL_CODE(207, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_BIND_TO_TRANSPORT     _NWRDR_CONTROL_CODE(208, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_CHANGE_PASS           _NWRDR_CONTROL_CODE(209, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_SET_INFO              _NWRDR_CONTROL_CODE(211, METHOD_BUFFERED,  FILE_ANY_ACCESS)

#define FSCTL_NWR_GET_USERNAME          _NWRDR_CONTROL_CODE(215, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_CHALLENGE             _NWRDR_CONTROL_CODE(216, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_DETAILS      _NWRDR_CONTROL_CODE(217, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_MESSAGE           _NWRDR_CONTROL_CODE(218, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_STATISTICS        _NWRDR_CONTROL_CODE(219, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_STATUS       _NWRDR_CONTROL_CODE(220, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_INFO         _NWRDR_CONTROL_CODE(221, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_PREFERRED_SERVER  _NWRDR_CONTROL_CODE(222, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_PERFORMANCE  _NWRDR_CONTROL_CODE(223, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_SET_SHAREBIT          _NWRDR_CONTROL_CODE(224, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_DETAILS2     _NWRDR_CONTROL_CODE(225, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_CLOSEALL              _NWRDR_CONTROL_CODE(226, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_NWR_NDS_SETCONTEXT        NWR_ANY_NDS(1)
#define FSCTL_NWR_NDS_GETCONTEXT        NWR_ANY_NDS(2)
#define FSCTL_NWR_NDS_VERIFY_TREE       NWR_ANY_NDS(3)
#define FSCTL_NWR_NDS_RESOLVE_NAME      NWR_ANY_NDS(4)
#define FSCTL_NWR_NDS_LIST_SUBS         NWR_ANY_NDS(5)
#define FSCTL_NWR_NDS_READ_INFO         NWR_ANY_NDS(6)
#define FSCTL_NWR_NDS_READ_ATTR         NWR_ANY_NDS(7)
#define FSCTL_NWR_NDS_OPEN_STREAM       NWR_ANY_NDS(8)
#define FSCTL_NWR_NDS_GET_QUEUE_INFO    NWR_ANY_NDS(9)
#define FSCTL_NWR_NDS_GET_VOLUME_INFO   NWR_ANY_NDS(10)
#define FSCTL_NWR_NDS_RAW_FRAGEX        NWR_ANY_NDS(11)
#define FSCTL_NWR_NDS_CHANGE_PASS       NWR_ANY_NDS(12)
#define FSCTL_NWR_NDS_LIST_TREES        NWR_ANY_NDS(13)

#define IOCTL_NWR_RAW_HANDLE            _NWRDR_CONTROL_CODE(1002,METHOD_NEITHER,   FILE_ANY_ACCESS)

//
//  UserNcp control code definitions. The parameter (X) to NWR_ANY_NCP
//  is the function code to be placed in the NCP.
//

#define NWR_ANY_NCP(X)                  _NWRDR_CONTROL_CODE(0x400 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_F2_NCP(X)               _NWRDR_CONTROL_CODE(0x500 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_HANDLE_NCP(X)           _NWRDR_CONTROL_CODE(0x600 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_NDS(X)                  _NWRDR_CONTROL_CODE(0x700 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)

#define FSCTL_NWR_NCP_E3H               NWR_ANY_NCP(0x17)
#define FSCTL_NWR_NCP_E2H               NWR_ANY_NCP(0x16)
#define FSCTL_NWR_NCP_E1H               NWR_ANY_NCP(0x15)
#define FSCTL_NWR_NCP_E0H               NWR_ANY_NCP(0x14)

//
//  Macro for obtaining the parameter given to NWR_ANY_XXX when creating
//  a control code to send a UserNcp to the redirector.
//

#define ANY_NCP_OPCODE(X)      ((UCHAR)(((X) >> 2) & 0x00ff))

//
//  Macro to give the command type
//

#define IS_IT_NWR_ANY_NCP(X)            ((X & 0x1C00) == (0x400 << 2))
#define IS_IT_NWR_ANY_F2_NCP(X)         ((X & 0x1C00) == (0x500 << 2))
#define IS_IT_NWR_ANY_HANDLE_NCP(X)     ((X & 0x1C00) == (0x600 << 2))

//
// Redirector Request Packet used by the Workstation service
// to pass parameters to the Redirector through Buffer 1 of
// NtFsControlFile.
//
// Additional output of each FSCtl is found in Buffer 2.
//

#define REQUEST_PACKET_VERSION  0x00000001L // Structure version.

typedef struct _NWR_REQUEST_PACKET {

    ULONG Version;                      // Version of structure in Buffer 2

    union {


        //
        // For FSCTL_NWR_BIND_TO_TRANSPORT
        //
        struct {
            ULONG QualityOfService;     // Quality of service indicator   IN
            ULONG TransportNameLength;  // Not including terminator       IN
            WCHAR TransportName[1];     // Name of transport provider     IN
        } Bind;


        //
        // For FSCTL_NWR_LOGON
        //
        struct {
            LUID LogonId;               // User logon session identifier  IN
            ULONG UserNameLength;       // Byte count not including NULL  IN
            ULONG PasswordLength;       // Byte count not including NULL  IN
            ULONG ServerNameLength;     // Byte count not including NULL  IN
            ULONG ReplicaAddrLength;    // IPX address of the nearest dir server
                                        // replica (for NDS login only).
                                        // It's either sizeof(TDI_ADDRESS_IPX)
                                        // or 0.                          IN
            ULONG PrintOption;          // Print options for user         IN
            WCHAR UserName[1];          // User name not NULL terminated. IN

            // Password string          // Default password for connection,
                                        //    not NULL terminated, packed
                                        //    in buffer immediately after
                                        //    UserName.                   IN

            // ServerName               // Preferred server name packed in
                                        //    buffer immediately after
                                        //    Password.                   IN

            // IpxAddress               // Address copied from the SAP response
                                        // packet, packed immediately after
                                        // the servername.                IN
        } Logon;

        //
        // For FSCTL_NWR_CHANGE_PASS
        //
        struct {

            ULONG UserNameLength;
            ULONG PasswordLength;
            ULONG ServerNameLength;
            WCHAR UserName[1];

            // Password string          // New password.                  IN

            // ServerName               // Server with the new password   IN

        } ChangePass;

        //
        // For FSCTL_NWR_LOGOFF
        //
        struct {
            LUID LogonId;               // User logon session identifier  IN
        } Logoff;

        //
        // For FSCTL_NWR_DELETE_CONNECTION
        //
        struct {
            BOOLEAN UseForce;           // Force flag                     IN
        } DeleteConn;

        //
        // For FSCTL_NWR_GET_CONNECTION
        //
        struct {
            ULONG BytesNeeded;          // Size (byte count) required of
                                        //    output buffer including
                                        //    terminator                  OUT
            ULONG DeviceNameLength;     // Not including terminator       IN
            WCHAR DeviceName[4];        // Name of DOS device             IN
        } GetConn;

        //
        // FSCTL_NWR_ENUMERATE_CONNECTIONS
        //
        struct {
            ULONG EntriesRequested;    // Number of entries to get        IN
            ULONG EntriesReturned;     // Entries returned in respose buf OUT
            ULONG_PTR ResumeKey;       // Handle to next entry to get     IN OUT
            ULONG BytesNeeded;         // Size (byte count) of next entry OUT
            ULONG ConnectionType;      // Resource type requested         IN
            LUID  Uid;                 // Uid to search for               IN
        } EnumConn;

        //
        // FSCTL_NWR_SET_INFO
        //
        struct {
            ULONG PrintOption;
            ULONG MaximumBurstSize;

            ULONG PreferredServerLength; // Byte count not including NULL  IN
            ULONG ProviderNameLength;    // Byte count not including NULL  IN
            WCHAR PreferredServer[1];    // Preferred server name not NULL
                                         // terminated.
            // ProviderName string       // Provider name not NULL terminated.
                                         // Packed in buffer immediately
                                         // after PreferredServer

        } SetInfo;

        //
        // FSCTL_NWR_GET_CONN_STATUS
        //
        struct {
            ULONG ConnectionNameLength; // IN: Length of the connection name we want.
            ULONG_PTR ResumeKey;        // IN: Resume key for a continued request.
            ULONG EntriesReturned;      // OUT: Entries returned in respose buffer.
            ULONG BytesNeeded;          // OUT: Size (byte count) of next entry.
            WCHAR ConnectionName[1];    // IN: Connection name described above.
        } GetConnStatus;

        //
        // FSCTL_NWR_GET_CONN_INFO
        //
        struct {
            ULONG ConnectionNameLength; // IN: Length of the connection name we want.
            WCHAR ConnectionName[1];    // IN: Connection name described above.
        } GetConnInfo;

        //
        // FSCTL_NWR_GET_CONN_PERFORMANCE
        //
        struct {

            //
            // These are the fields for the NETCONNECTINFOSTRUCT.
            //

            DWORD dwFlags;
            DWORD dwSpeed;
            DWORD dwDelay;
            DWORD dwOptDataSize;

            //
            // This is the remote name in question.
            //

            ULONG RemoteNameLength;
            WCHAR RemoteName[1];
        } GetConnPerformance;

        struct {
            ULONG DebugFlags;           // Value for NwDebug
        } DebugValue;

    } Parameters;

} NWR_REQUEST_PACKET, *PNWR_REQUEST_PACKET;

typedef struct _NWR_NDS_REQUEST_PACKET {

    //
    // Version of structure in Buffer 2.
    //

    ULONG Version;

    union {

        //
        //  For FSCTL_NWR_NDS_RESOLVE_NAME
        //

        struct {
            ULONG ObjectNameLength;         // IN
            DWORD ResolverFlags;            // IN
            DWORD BytesWritten;             // OUT
            WCHAR ObjectName[1];            // IN
        } ResolveName;

        //
        //  For FSCTL_NWR_NDS_READ_INFO
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD BytesWritten;             // OUT
        } GetObjectInfo;

        //
        //  For FSCTL_NWR_NDS_LIST_SUBS
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD_PTR IterHandle;           // IN
            DWORD BytesWritten;             // OUT
        } ListSubordinates;

        //
        // For FSCTL_NWR_NDS_READ_ATTR
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD_PTR IterHandle;           // IN
            DWORD BytesWritten;             // OUT
            DWORD AttributeNameLength;      // IN
            WCHAR AttributeName[1];         // IN
        } ReadAttribute;

        //
        // For FSCTL_NWR_NDS_OPEN_STREAM
        //

        struct {
            DWORD FileLength;                 // OUT
            DWORD StreamAccess;               // IN
            DWORD ObjectOid;                  // IN
            UNICODE_STRING StreamName;        // IN
            WCHAR StreamNameString[1];        // IN
        } OpenStream;

        //
        // For FSCTL_NWR_NDS_SET_CONTEXT
        //

        struct {
            DWORD TreeNameLen ;               // IN
            DWORD ContextLen;                 // IN
            WCHAR TreeAndContextString[1];    // IN
        } SetContext;

        //
        // For FSCTL_NWR_NDS_GET_CONTEXT
        //

        struct {
            UNICODE_STRING Context;           // OUT
            DWORD TreeNameLen ;               // IN
            WCHAR TreeNameString[1];          // IN
        } GetContext;

        //
        // For FSCTL_NWR_NDS_VERIFY_TREE
        //

        struct {
            UNICODE_STRING TreeName;          // IN
            WCHAR NameString[1];              // IN
        } VerifyTree;

        //
        // For FSCTL_NWR_NDS_GET_QUEUE_INFO
        //

        struct {
            UNICODE_STRING QueueName;          // IN
            UNICODE_STRING HostServer;         // OUT
            DWORD QueueId;                     // OUT
        } GetQueueInfo;

        //
        // For FSCTL_NWR_NDS_GET_VOLUME_INFO
        //

        struct {
            DWORD ServerNameLen;    // OUT
            DWORD TargetVolNameLen; // OUT
            DWORD VolumeNameLen;    // IN
            WCHAR VolumeName[1];    // IN
        } GetVolumeInfo;

        //
        // For FSCTL_NWR_NDS_RAW_FRAGEX
        //

        struct {
            DWORD NdsVerb;          // IN
            DWORD RequestLength;    // IN
            DWORD ReplyLength;      // OUT
            BYTE  Request[1];       // IN
        } RawRequest;

        //
        // For FSCTL_NWR_NDS_CHANGE_PASS
        //

        struct {

            DWORD NdsTreeNameLength;
            DWORD UserNameLength;
            DWORD CurrentPasswordLength;
            DWORD NewPasswordLength;

            //
            // The above strings should be end to
            // end starting at StringBuffer.
            //

            WCHAR StringBuffer[1];
        } ChangePass;

        //
        // For FSCTL_NWR_NDS_LIST_TREES
        //

        struct {

            DWORD NtUserNameLength;   // IN
            LARGE_INTEGER UserLuid;   // OUT
            DWORD TreesReturned;      // OUT
            WCHAR NtUserName[1];      // IN
        } ListTrees;

    } Parameters;

} NWR_NDS_REQUEST_PACKET, *PNWR_NDS_REQUEST_PACKET;

//
// Structure of buffer 2 for FSCTL_NWR_GET_CONNECTION
//
typedef struct _NWR_SERVER_RESOURCE {
    WCHAR UncName[1];                   // Server resource name DOS device
                                        // is connected to; NULL terminated
} NWR_SERVER_RESOURCE, *PNWR_SERVER_RESOURCE;

//
// Structure of buffer for FSCTL_NWR_GET_MESSAGE
//

typedef struct _NWR_SERVER_MESSAGE {
    ULONG MessageOffset;   //  Offset from start of buffer to message
    LUID LogonId;          //  Logon ID
    WCHAR Server[1];       //  Source of message, NUL terminated         OUT
    //WCHAR Message[];     //  The message text, NUL terminated          OUT
} NWR_SERVER_MESSAGE, *PNWR_SERVER_MESSAGE;

#define TRANSACTION_VERSION     0x00000001L     // Structure version.
typedef struct _NWR_TRANSACTION {
    ULONG       Type;                   // Type of structure
    ULONG       Size;                   // Size of fixed portion of structure
    ULONG       Version;                // Structure version.
    ULONG       NameLength;             // Number of bytes in name (in path
                                        // format, e.g., \server\pipe\netapi\4)
    ULONG       NameOffset;             // Offset of name in buffer.
    BOOLEAN     ResponseExpected;       // Should remote system respond?
    ULONG       Timeout;                // Timeout time in milliseconds.
    ULONG       SetupWords;             // Number of trans setup words (may be
                                        // 0).  (setup words are input/output.)
    ULONG       SetupOffset;            // Offset of setup (may be 0 for none).
    ULONG       MaxSetup;               // Size of setup word array (may be 0).
    ULONG       ParmLength;             // Input param area length (may be 0).
    PVOID       ParmPtr;                // Input parameter area (may be NULL).
    ULONG       MaxRetParmLength;       // Output param. area length (may be 0).
    ULONG       DataLength;             // Input data area length (may be 0).
    PVOID       DataPtr;                // Input data area (may be NULL).
    ULONG       MaxRetDataLength;       // Output data area length (may be 0).
    PVOID       RetDataPtr;             // Output data area (may be NULL).
} NWR_TRANSACTION, *PNWR_TRANSACTION;

typedef struct _NWR_GET_CONNECTION_DETAILS {
    SERVERNAME ServerName;
    UCHAR OrderNumber;          //  Position in the Scb chain starting at 1
    UCHAR ServerAddress[12];
    UCHAR ConnectionNumberLo;
    UCHAR ConnectionNumberHi;
    UCHAR MajorVersion;
    UCHAR MinorVersion;
    BOOLEAN Preferred;
} NWR_GET_CONNECTION_DETAILS, *PNWR_GET_CONNECTION_DETAILS;

typedef struct _CONN_DETAILS2 {
   BOOL   fNds;             // TRUE if NDS, false for Bindery servers
   WCHAR  NdsTreeName[48];  // The tree name or '\0' for a 2.x or 3.x server
} CONN_DETAILS2, *PCONN_DETAILS2;


typedef struct _NWR_GET_USERNAME {
    WCHAR UserName[1];
} NWR_GET_USERNAME, *PNWR_GET_USERNAME;

typedef struct _NWR_GET_CHALLENGE_REQUEST {
    ULONG Flags;
    ULONG ObjectId;
    UCHAR Challenge[8];
    ULONG ServerNameorPasswordLength;
    WCHAR ServerNameorPassword[1];    // No NULL
} NWR_GET_CHALLENGE_REQUEST, *PNWR_GET_CHALLENGE_REQUEST;

#define CHALLENGE_FLAGS_SERVERNAME    0
#define CHALLENGE_FLAGS_PASSWORD      1

typedef struct _NWR_GET_CHALLENGE_REPLY {
    UCHAR Challenge[8];
} NWR_GET_CHALLENGE_REPLY, *PNWR_GET_CHALLENGE_REPLY;

typedef struct _NW_REDIR_STATISTICS {
    LARGE_INTEGER   StatisticsStartTime;

    LARGE_INTEGER   BytesReceived;
    LARGE_INTEGER   NcpsReceived;

    LARGE_INTEGER   BytesTransmitted;
    LARGE_INTEGER   NcpsTransmitted;

    ULONG           ReadOperations;
    ULONG           RandomReadOperations;
    ULONG           ReadNcps;
    ULONG           PacketBurstReadNcps;
    ULONG           PacketBurstReadTimeouts;

    ULONG           WriteOperations;
    ULONG           RandomWriteOperations;
    ULONG           WriteNcps;
    ULONG           PacketBurstWriteNcps;
    ULONG           PacketBurstWriteTimeouts;

    //  Connection/Session counts
    ULONG           Sessions;
    ULONG           FailedSessions;
    ULONG           Reconnects;
    ULONG           NW2xConnects;
    ULONG           NW3xConnects;
    ULONG           NW4xConnects;
    ULONG           ServerDisconnects;

    ULONG           CurrentCommands;
} NW_REDIR_STATISTICS, *PNW_REDIR_STATISTICS;

//
// CONN_STATUS structures for the new shell.
//

typedef struct _CONN_STATUS {
    DWORD   dwTotalLength;     // The total length including packed strings.
    LPWSTR  pszServerName;     // The server name.
    LPWSTR  pszUserName;       // The user name.
    LPWSTR  pszTreeName;       // The tree name or NULL for a 2.x or 3.x server.
    DWORD   nConnNum;          // The connection number used on nw srv.
    BOOL    fNds;              // TRUE if NDS, False for Bindery servers
    BOOL    fPreferred;        // TRUE if the connection is a preferred server with no explicit uses.
    DWORD   dwConnType;        // Authentication status of the connection.
} CONN_STATUS, *PCONN_STATUS;

#define NW_CONN_NOT_AUTHENTICATED            0x00000000
#define NW_CONN_BINDERY_LOGIN                0x00000001
#define NW_CONN_NDS_AUTHENTICATED_NO_LICENSE 0x00000002
#define NW_CONN_NDS_AUTHENTICATED_LICENSED   0x00000003
#define NW_CONN_DISCONNECTED                 0x00000004

typedef struct _CONN_INFORMATION {
    DWORD HostServerLength;
    LPWSTR HostServer;
    DWORD UserNameLength;
    LPWSTR UserName;
} CONN_INFORMATION, *PCONN_INFORMATION;

#endif  // ifndef _NTDDNWFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\ndsapi32.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsLib32.h

Abstract:

    This module exposes the minimal win32 API to Netware directory
    services support in the Netware redirector.

Author:

    Cory West    [CoryWest]    23-Feb-1995

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdef.h>

#include <stdio.h>
#include <ntddnwfs.h>

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
NwNdsOpenTreeHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT PHANDLE  phNwRdrHandle
);

// NwNdsOpenTreeHandle( PUNICODE_STRING, PHANDLE )
//
// Given an NDS tree name, this opens a handle the the redirector
// for accessing that tree.  The handle should closed using the
// standard NT CloseHandle() call. This function is only a
// simple wrapper around NT OpenFile().

//
// Administrativa.
//

#define HANDLE_TYPE_NCP_SERVER  1
#define HANDLE_TYPE_NDS_TREE    2

NTSTATUS
NwNdsOpenGenericHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwRdrHandle
);

// NwNdsOpenGenericHandle( PUNICODE_STRING, LPDWORD, PHANDLE )
//
// Given a name, this opens a handle the the redirector for accessing that
// named tree or server. lpdwHandleType is set to either HANDLE_TYPE_NCP_SERVER
// or HANDLE_TYPE_NDS_TREE accordingly. The handle should be closed using
// the standard NT CloseHandle() call. This function is only a simple
// wrapper around NT OpenFile().

NTSTATUS
NwOpenHandleWithSupplementalCredentials(
    IN PUNICODE_STRING puResourceName,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwHandle
);

// NwOpenHandleWithSupplementalCredentials
//
// Given a resource name (either a server name or a tree name),
// open a handle to that resource with the provided username and
// password.  As with the open generic handle routine, lpdsHandleType
// will be set to either HANDLE_TYPE_NCP_SERVER or
// HANDLE_TYPE_NDS_TREE based on the result of the open.

//
// Administrativa.
//

NTSTATUS
NwNdsSetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    IN PUNICODE_STRING puContext
);

// NwNdsSetTreeContext(HANDLE, PUNICODE_STRING, PUNICODE_STRING)
//
// Set the current context for the specified tree.
//
// Arguments:
//
//     HANDLE hNdsRdr - A handle to the redirector.
//     PUNICODE_STRING puTree - The tree name.
//     PUNICODE_STRING puContext - The context in that tree.

NTSTATUS
NwNdsGetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    OUT PUNICODE_STRING puContext
);

// NwNdsGetTreeContext(HANDLE, PUNICODE_STRING, PUNICODE_STRING)
//
// Get the current context for the specified tree.
//
// Arguments:
//
//     HANDLE hNdsRdr - A handle to the redirector.
//     PUNICODE_STRING puTree - The tree name.
//     PUNICODE_STRING puContext - The context in that tree.

NTSTATUS
NwNdsIsNdsConnection (
    IN     HANDLE hNdsRdr,
    OUT    BOOL * pfIsNds,
    IN OUT PUNICODE_STRING puTree
);

// NwNdsIsNdsConnection(HANDLE, PUNICODE_STRING)
//
// Get the current context for the specified tree.
//
// Arguments:
//
//     HANDLE hNdsRdr - A handle to the redirector.
//     BOOL *         - Get the boolean value of connection test
//     PUNICODE_STRING puTree - The tree name that handle to server
//                              represents. Caller allocates puTree
//                              with a buffer big enough to hold
//                              48 WCHARs.
//
// Returns: TRUE if hNdsRdr is a handle connected to a server that
//          is part of a NDS directory tree. puTree will contain
//          the tree name.
//          FALSE: if hNdsRdr is not a NDS tree handle.

//
// Browsing and Navigating support.
//

NTSTATUS
NwNdsResolveName (
    IN HANDLE           hNdsTree,
    IN PUNICODE_STRING  puObjectName,
    OUT DWORD           *dwObjectId,
    OUT PUNICODE_STRING puReferredServer,
    OUT PBYTE           pbRawResponse,
    IN DWORD            dwResponseBufferLen
);

// NwNdsResolveName(HANDLE, PUNICODE_STRING, PDWORD)
//
// Resolve the given name to an NDS object id.  This utilizes
// NDS verb 1.
//
// There is currently no interface for canonicalizing names.
// This call will use the default context if one has been set
// for this NDS tree.
//
// puReferredServer must point to a UNICODE_STRING with enough
// space to hold a server name (MAX_SERVER_NAME_LENGTH) *
// sizeof( WCHAR ).
//
// If dwResponseBufferLen is not 0, and pbRawResponse points
// to a writable buffer of length dwResponseBufferLen, then
// this routine will also return the entire NDS response in
// the raw response buffer.  The NDS response is described
// by NDS_RESPONSE_RESOLVE_NAME.
//
// Arguments:
//
//     HANDLE hNdsTree - The name of the NDS tree that we are interested in looking into.
//     PUNICODE_STRING puObjectName - The name that we want resolved into an object id.
//     DWORD *dwObjectId - The place where we will place the object id.
//     BYTE *pbRawResponse - The raw response buffer, if desired.
//     DWORD dwResponseBufferLen - The length of the raw response buffer.

NTSTATUS
NwNdsList (
   IN HANDLE   hNdsTree,
   IN DWORD    dwObjectId,
   OUT DWORD   *dwIterHandle,
   OUT BYTE    *pbReplyBuf,
   IN DWORD    dwReplyBufLen
);

// NwNdsList(HANDLE, DWORD, PDWORD, PBYTE, DWORD, PDWORD)
//
// List the immediate subordinates of an object.  This utilizes
// NDS verb 5.
//
// Arguments:
//
//     HANDLE hNdsTree - The handle to the tree that we are interested in.
//     DWORD dwObjectId - The object that we want to list.
//     DWORD *dwIterHandle - The iteration handle to be used in continuing
//         the request if the buffer is not large enough for the entire
//         list of subordinates.
//     BYTE *pbReplyBuf - The buffer where the raw reply will be placed.
//     DWORD dwReplyBufLen - The length of the raw reply buffer.

NTSTATUS
NwNdsReadObjectInfo(
    IN HANDLE    hNdsTree,
    IN DWORD     dwObjectId,
    OUT PBYTE    pbReplyBuf,
    IN DWORD     dwReplyBufLen
);

// NwNdsReadObjectInfo(PUNICODE_STRING, DWORD, PBYTE, DWORD)
//
// Given an object id, this gets the basic info for the object.  This
// utilizes NDS verb 2.  The reply buffer should be large enough to
// hold a DS_OBJ_INFO struct and the text of the two unicode strings.
//
// Arguments:
//
//     HANDLE hNdsTree - The tree that we want to look in.
//     DWORD dwObjectId - The object id that we want to learn about.
//     BYTE *pbReplyBuf - The space for the reply.
//     DWORD dwReplyBufLen - The length of the reply buffer.

NTSTATUS
NwNdsReadAttribute (
   IN HANDLE          hNdsTree,
   IN DWORD           dwObjectId,
   IN DWORD           *dwIterHandle,
   IN PUNICODE_STRING puAttrName,
   OUT BYTE           *pbReplyBuf,
   IN DWORD           dwReplyBufLen
);

// NwNdsReadAttribute(HANDLE, DWORD, PDWORD, PUNICODE_STRING, PBYTE, DWORD)
//
// Read the requested attribute from the listed object.
// This utilizes NDS verb 3.
//
// Arguments:
//
//     HANDLE hNdsTree - The tree that we want to read from.
//     DWORD dwObjectId - The object that we want to read from.
//     DWORD *dwIterHandle - The iteration handle.
//     PUNICODE_STRING puAttrName - The name of the attribute.
//     BYTE *pbReplyBuf - The buffer to hold the response.
//     DWORD deReplyBufLen - The length of the reply buffer.

NTSTATUS
NwNdsOpenStream (
    IN HANDLE          hNdsTree,
    IN DWORD           dwObjectId,
    IN PUNICODE_STRING puStreamName,
    IN DWORD           dwOpenFlags,
    OUT DWORD          *pdwFileLength
);

// NwNdsOpenStream(HANDLE, DWORD, PBYTE, DWORD)
//
// Open a file handle to the stream listed.
// This utilizes NDS verb 27.
//
// Arguments:
//
//     HANDLE hNdsTree - The handle to the NDS tree that we are interested in.
//     DWORD dwObjectId - The object id that we want to query.
//     PUNICODE_STRING puStreamName - The name of the stream that we want to open.
//     DWORD dwOpenFlags - 1 for read, 2 for write, 3 for read/write.
//     DWORD *pdwFileLength - The length of the file stream.

NTSTATUS
NwNdsGetQueueInformation(
    IN HANDLE            hNdsTree,
    IN PUNICODE_STRING   puQueueName,
    OUT PUNICODE_STRING  puHostServer,
    OUT PDWORD           pdwQueueId
);

// NwNdsGetQueueInformation(HANDLE, PUNICODE_STRING, PUNICODE_STRING, PDWORD)
//
// Arguments:
//
//     HANDLE hNdsTree - The handle to the NDS tree that knows about the queue.
//     PUNICODE_STRING puQueueName - The ds path to the queue that we want.
//     PUNICODE_STRING puHostServer - The host server for this queue.
//     PDWORD pdwQueueId - The queue id for this queue on this server.

NTSTATUS
NwNdsGetVolumeInformation(
    IN HANDLE            hNdsTree,
    IN PUNICODE_STRING   puVolumeName,
    OUT PUNICODE_STRING  puHostServer,
    OUT PUNICODE_STRING  puHostVolume
);

// NwNdsGetVoluemInformation(HANDLE, PUNICODE_STRING, PUNICODE_STRING, PUNICODE_STRING)
//
// Arguments:
//
//     HANDLE hNdsTree - The handle to the NDS tree that knows about the volume.
//     PUNICODE_STRING puVolumeName - The ds path to the volume that we want.
//     PUNICODE_STRING puHostServer - The host server for this nds volume.
//     PUNICODE_STRING puHostVolume - The host volume for this nds volume.

//
// User mode fragment exchange.
//

NTSTATUS
_cdecl
FragExWithWait(
    IN HANDLE  hNdsServer,
    IN DWORD   NdsVerb,
    IN BYTE    *pReplyBuffer,
    IN DWORD   pReplyBufferLen,
    IN OUT DWORD *pdwReplyLen,
    IN BYTE    *NdsRequestStr,
    ...
);

NTSTATUS
_cdecl
ParseResponse(
    PUCHAR  Response,
    ULONG ResponseLength,
    char*  FormatString,
    ...
);

int
_cdecl
FormatBuf(
    char *buf,
    int bufLen,
    const char *format,
    va_list args
);

//
// Change password support.
//

NTSTATUS
NwNdsChangePassword(
    IN HANDLE          hNwRdr,
    IN PUNICODE_STRING puTreeName,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puCurrentPassword,
    IN PUNICODE_STRING puNewPassword
);

#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\nwpkstr.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwpkstr.h

Abstract:

    Header for NetWare string packing library routines.

Author:

    Rita Wong      (ritaw)      2-Mar-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _NW_PKSTR_INCLUDED_
#define _NW_PKSTR_INCLUDED_

BOOL
NwlibCopyStringToBuffer(
    IN LPCWSTR SourceString OPTIONAL,
    IN DWORD   CharacterCount,
    IN LPCWSTR FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

#endif // _NW_PKSTR_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\nwxchg.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwxchg.h

Abstract:

    Header for generic NCP calling routine.

Author:

    Rita Wong      (ritaw)      11-Mar-1993

Environment:


Revision History:

--*/

#ifndef _NW_XCHG_INCLUDED_
#define _NW_XCHG_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

NTSTATUS
NwlibMakeNcp(
    IN HANDLE DeviceHandle,
    IN ULONG FsControlCode,
    IN ULONG RequestBufferSize,
    IN ULONG ResponseBufferSize,
    IN PCHAR FormatString,
    ...                           // Arguments to FormatString
    );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _NW_XCHG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\ncp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ncp.h

Abstract:

    This module defines NCP fields and constants.

Author:

    Manny Weiser (mannyw) 10-Aug-1993

Revision History:

--*/

#ifndef _NCP_
#define _NCP_

///////////////////////////////// IPX ///////////////////////////////////////

#define  RIP_SOCKET  0x5304
#define  SAP_SOCKET  0x5204
#define  NCP_SOCKET  0x5104

//
//  SAP request types
//

#define SAP_GENERAL_REQUEST      1
#define SAP_FIND_NEAREST         3

//
//  SAP services
//

#define SAP_SERVICE_TYPE_SERVER       4
#define SAP_SERVICE_TYPE_DIR_SERVER 278

///// IPX driver services:

#ifndef NWDOS_INCLUDED

typedef  UCHAR  byte;
typedef  USHORT word;

#endif

typedef  ULONG  NetAddress;
typedef  byte  NodeAddress [6];

typedef struct
{
    NetAddress   Net;
    NodeAddress  Node;
    word         Socket;
} IPXaddress;

NTSTATUS  IPX_Get_Local_Target          ( IPXaddress*, NodeAddress*, word* );
void  IPX_Get_Internetwork_Address  ( IPXaddress* );
word  IPX_Get_Interval_Marker       ( void );

struct _IRP_CONTEXT;
struct _NW_TDI_STRUCT;

NTSTATUS
IPX_Open_Socket(
    IN struct _IRP_CONTEXT* pIrpC,
    IN struct _NW_TDI_STRUCT* pTdiStruc
    );

VOID
IPX_Close_Socket(
    IN struct _NW_TDI_STRUCT* pTdiStruc
    );

///// IPX support routines to hide V86/VxD differences:

//byte*  IPX_Allocate_Low_Memory  ( word );
//ESR*   IPX_Wrap_Callback        ( ESR* );

///////////////////////////////// SAP ///////////////////////////////////////

typedef struct
{
    word        Command;
    word        ServerType;
    char        Name [48];
    IPXaddress  Address;
    word        Hops;
} SAPpacket;

///////////////////////////////// RIP ///////////////////////////////////////

typedef struct
{
    word        Command;
    NetAddress  Net;
    word        Hops;
    word        Ticks;
} RIPpacket;

///////////////////////////////// PEP ///////////////////////////////////////

#define  PEP_COMMAND_CONNECT        0x1111
#define  PEP_COMMAND_REQUEST        0x2222
#define  PEP_COMMAND_RESPONSE       0x3333
#define  PEP_COMMAND_DISCONNECT     0x5555
#define  PEP_COMMAND_BURST          0x7777
#define  PEP_COMMAND_ACKNOWLEDGE    0x9999

typedef struct
{
    word  command;
    byte  sequence;
    byte  connection;
    byte  x;
} PEPrequest;

typedef struct
{
    byte  error;
    byte  status;
} PEPresponse;

//
//  Bindery object types
//

#define OT_WILD         ~0
#define OT_USER         1
#define OT_GROUP        2
#define OT_PRINT_QUEUE  3
#define OT_FILESERVER   4
#define OT_DIRSERVER    0x278
#define OT_JOBQUEUE     0xA

#define ENCRYPTION_KEY_SIZE            8
#define OBJECT_ID_SIZE                 4

#define BROADCAST_MESSAGE_WAITING      0x21

//
//  NCP function codes
//

#define NCP_MESSAGE_FUNCTION            0x15
#define NCP_DIR_FUNCTION                0x16
#define NCP_ADMIN_FUNCTION              0x17
#define NCP_END_OF_JOB                  0x18
#define NCP_LOGOUT                      0x19
#define NCP_LOCK_RANGE                  0x1A
#define NCP_UNLOCK_RANGE                0x1E
#define NCP_NEGOTIATE_BUFFER_SIZE       0x21
#define NCP_GET_SHORT_NAME              0x30
#define NCP_FLUSH_FILE                  0x3D
#define NCP_SEARCH_INITIATE             0x3E
#define NCP_SEARCH_CONTINUE             0x3F
#define NCP_SEARCH_FILE                 0x40
#define NCP_CLOSE                       0x42
#define NCP_CREATE_FILE                 0x43
#define NCP_DELETE_FILE                 0x44
#define NCP_RENAME_FILE                 0x45
#define NCP_SET_FILE_ATTRIBUTES         0x46
#define NCP_GET_FILE_SIZE               0x47
#define NCP_READ_FILE                   0x48
#define NCP_WRITE_FILE                  0x49
#define NCP_SET_FILE_TIME               0x4B
#define NCP_OPEN_FILE                   0x4C
#define NCP_CREATE_NEW_FILE             0x4D
#define NCP_LFN_FUNCTION                0x57
#define NCP_NEGOTIATE_LIP_CONNECTION    0x61
#define NCP_NEGOTIATE_BURST_CONNECTION  0x65

//
//  Subfunctions of NCP_MESSAGE_FUNCTION
//

#define NCP_GET_MESSAGE                 0x01
#define NCP_GET_ENTIRE_MESSAGE          0x0B

//
//  Subfunctions of NCP_DIR_FUNCTION
//

#define NCP_GET_DIRECTORY_PATH          0x01
#define NCP_GET_VOLUME_NUMBER           0x05
#define NCP_CREATE_DIRECTORY            0x0A
#define NCP_DELETE_DIRECTORY            0x0B
#define NCP_RENAME_DIRECTORY            0x0F
#define NCP_ALLOCATE_DIR_HANDLE         0x12
#define NCP_ALLOCATE_TEMP_DIR_HANDLE    0x13
#define NCP_DEALLOCATE_DIR_HANDLE       0x14
#define NCP_GET_VOLUME_STATS            0x15
#define NCP_GET_VOLUME_INFO             0x2C
#define NCP_GET_NAME_SPACE_INFO         0x2F

//
//  Subfunctions of NCP_ADMIN_FUNCTION
//

#define NCP_GET_SERVER_INFO             0x11
#define NCP_PLAIN_TEXT_LOGIN            0x14
#define NCP_GET_LOGIN_KEY               0x17
#define NCP_ENCRYPTED_LOGIN             0x18
#define NCP_CHANGE_CONN_AUTH_STATUS     0x1D
#define NCP_QUERY_OBJECT_ID             0x35
#define NCP_SCAN_BINDERY_OBJECT         0x37
#define NCP_QUERY_PROPERTY_VALUE        0x3D
#define NCP_PLAIN_TEXT_VERIFY_PASSWORD  0x3F
#define NCP_IS_OBJECT_IN_SET            0x43
#define NCP_ENCRYPTED_VERIFY_PASSWORD   0x4A
#define NCP_CREATE_QUEUE_JOB            0x68
#define NCP_CLOSE_FILE_AND_START_JOB    0x69
#define NCP_CLOSE_FILE_AND_CANCEL_JOB   0x6A
#define NCP_SUBFUNC_79                  0x79
#define NCP_SUBFUNC_7F                  0x7F

//
// Values for NCP_CHANGE_CONN_AUTH_STATUS
//

#define NCP_CONN_NOT_LICENSED      0
#define NCP_CONN_LICENSED          1

//
//  Subfunctions of NCP_NAME_SPACE_FUNCTION
//

#define NCP_LFN_OPEN_CREATE             0x01
#define NCP_LFN_SEARCH_INITIATE         0x02
#define NCP_LFN_SEARCH_CONTINUE         0x03
#define NCP_LFN_RENAME_FILE             0x04
#define NCP_LFN_GET_INFO                0x06
#define NCP_LFN_SET_INFO                0x07
#define NCP_LFN_DELETE_FILE             0x08
#define NCP_LFN_ALLOCATE_DIR_HANDLE     0x0C

//
//  Packet types
//

#define PACKET_TYPE_SAP  0x00
#define PACKET_TYPE_NCP  0x11

//
//  Special character used to indicate that the next char in the
//  search mask is a wild card character.
//

#define LFN_META_CHARACTER              (UCHAR)0xFF

//
//  Properties we query and set
//

#define NET_ADDRESS_PROPERTY            "NET_ADDRESS"

//
//   Search attributes
//

#define SEARCH_ALL_DIRECTORIES          0x16
#define SEARCH_ALL_FILES                0x06
#define SEARCH_EXEC_ONLY_FILES          0x4E 

//  File Attributes

#define NW_ATTRIBUTE_SHARABLE       0x80
#define NW_ATTRIBUTE_ARCHIVE        0x20
#define NW_ATTRIBUTE_DIRECTORY      0x10
#define NW_ATTRIBUTE_EXECUTE_ONLY   0x08
#define NW_ATTRIBUTE_SYSTEM         0x04
#define NW_ATTRIBUTE_HIDDEN         0x02
#define NW_ATTRIBUTE_READ_ONLY      0x01
#define NW_ATTRIBUTE_EXEC_ONLY      0x4E

//  Open Flags

#define NW_OPEN_EXCLUSIVE           0x10
#define NW_DENY_WRITE               0x08
#define NW_DENY_READ                0x04
#define NW_OPEN_FOR_WRITE           0x02
#define NW_OPEN_FOR_READ            0x01

//
//  Connection status flags
//

#define NCP_STATUS_BAD_CONNECTION   0x01
#define NCP_STATUS_NO_CONNECTIONS   0x02
#define NCP_STATUS_SERVER_DOWN      0x04
#define NCP_STATUS_MSG_PENDING      0x08
#define NCP_STATUS_SHUTDOWN         0x10

//
//  Extended name space (long file name) query information flags
//

#define LFN_FLAG_INFO_NAME               0x0001
#define LFN_FLAG_INFO_BLOCK_SIZE         0x0002
#define LFN_FLAG_INFO_ATTRIBUTES         0x0004
#define LFN_FLAG_INFO_FILE_SIZE          0x0008
#define LFN_FLAG_INFO_STREAMS            0x0010
#define LFN_FLAG_INFO_EA_INFO            0x0020
#define LFN_FLAG_INFO_ARCHIVE_TIME       0x0040
#define LFN_FLAG_INFO_MODIFY_TIME        0x0080
#define LFN_FLAG_INFO_CREATION_TIME      0x0100
#define LFN_FLAG_INFO_CREATOR            0x0200
#define LFN_FLAG_INFO_DIR_INFO           0x0400
#define LFN_FLAG_INFO_RIGHTS             0x0800

//
//  Extended name space (long file name) set information flags
//

#define LFN_FLAG_SET_NAME                    0x0001  // Never used
#define LFN_FLAG_SET_INFO_ATTRIBUTES         0x0002
#define LFN_FLAG_SET_INFO_CREATE_DATE        0x0004
#define LFN_FLAG_SET_INFO_CREATE_TIME        0x0008
#define LFN_FLAG_SET_INFO_CREATOR_ID         0x0010
#define LFN_FLAG_SET_INFO_ARCHIVE_DATE       0x0020
#define LFN_FLAG_SET_INFO_ARCHIVE_TIME       0x0040
#define LFN_FLAG_SET_INFO_ARCHIVE_ID         0x0080
#define LFN_FLAG_SET_INFO_MODIFY_DATE        0x0100
#define LFN_FLAG_SET_INFO_MODIFY_TIME        0x0200
#define LFN_FLAG_SET_INFO_MODIFY_ID          0x0400
#define LFN_FLAG_SET_INFO_LASTACCESS_DATE    0x0800
#define LFN_FLAG_SET_INFO_INHERITANCE        0x1000
#define LFN_FLAG_SET_INFO_MAXIMUM_SPACE      0x2000

//
//  Extended name space (long file name) open mode flags
//

#define LFN_FLAG_OM_OPEN                 0x01
#define LFN_FLAG_OM_OVERWRITE            0x02
#define LFN_FLAG_OM_CREATE               0x08

//
//  Long name directory flags
//

#define LFN_FLAG_SHORT_DIRECTORY         0x00

//
//  Burst request
//

#define BURST_REQUEST_READ               0x01
#define BURST_REQUEST_WRITE              0x02

//
//  Burst flags
//

#define BURST_FLAG_END_OF_BURST          0x10
#define BURST_FLAG_SYSTEM_PACKET         0x80

/////////////////////////////////////////////////////////////////////////////

#define MAX_SERVER_NAME_LENGTH   48

#include <packon.h>

typedef struct _SAP_FIND_NEAREST_RESPONSE {
    USHORT SapType;         // == 4
    USHORT SapServiceType;
    UCHAR  ServerName[MAX_SERVER_NAME_LENGTH];
    ULONG  Network;
    UCHAR  NodeNumber[6];
    USHORT HopCount;       // Hi-lo order
} SAP_FIND_NEAREST_RESPONSE, *PSAP_FIND_NEAREST_RESPONSE;

typedef struct _NCP_HEADER {
    USHORT Command;
    UCHAR  SequenceNumber;
    UCHAR  ConnectionIdLow;
    UCHAR  TaskId;
    UCHAR  ConnectionIdHigh;
} NCP_HEADER, *PNCP_HEADER;

//
// Header format for NCP request with no subfunction.
//

typedef struct _NCP_REQUEST {
    NCP_HEADER NcpHeader;
    UCHAR FunctionCode;

    //
    //  Function specific stuff follows.
    //
} NCP_REQUEST, *PNCP_REQUEST;

//
// Header format for NCP request with a subfunction.
//

typedef struct _NCP_REQUEST_WITH_SUB {
    NCP_HEADER NcpHeader;
    UCHAR FunctionCode;
    USHORT SubfunctionLength;
    UCHAR SubfunctionCode;

    //
    //  Function specific stuff follows.
    //
} NCP_REQUEST_WITH_SUB, *PNCP_REQUEST_WITH_SUB;

typedef struct _NCP_RESPONSE {
    NCP_HEADER NcpHeader;

    UCHAR  Error;
    UCHAR  Status;

    //
    //  Function specific stuff follows.
    //

} NCP_RESPONSE, *PNCP_RESPONSE;

typedef struct _NCP_BURST_HEADER {
    USHORT Command;      // 0x7777
    UCHAR  Flags;
    UCHAR  StreamType;   // 0x02
    ULONG  SourceConnection;
    ULONG  DestinationConnection;
    ULONG  PacketSequenceNo;
    ULONG  SendDelayTime;
    USHORT BurstSequenceNo;
    USHORT AckSequenceNo;
    ULONG  DataSize;
    ULONG  BurstOffset;
    USHORT BurstLength;
    USHORT MissingFragmentCount;
} NCP_BURST_HEADER, *PNCP_BURST_HEADER;

typedef struct _NCP_BURST_WRITE_REQUEST {
    NCP_BURST_HEADER BurstHeader;
    ULONG Function;    //  0x02 = Write
    ULONG Handle;
    ULONG TotalWriteOffset;
    ULONG TotalWriteLength;
    ULONG Offset;
    ULONG Length;
    //UCHAR Data[x];
} NCP_BURST_WRITE_REQUEST, *PNCP_BURST_WRITE_REQUEST;

typedef struct _NCP_BURST_READ_RESPONSE {
    NCP_BURST_HEADER BurstHeader;
    ULONG Result;
    ULONG BytesRead;
    //UCHAR Data[x];
} NCP_BURST_READ_RESPONSE, *PNCP_BURST_READ_RESPONSE;

typedef struct _NCP_BURST_READ_REQUEST {
    NCP_BURST_HEADER BurstHeader;
    ULONG Function;    //  0x02 = Write
    ULONG Handle;
    ULONG TotalReadOffset;
    ULONG TotalReadLength;
    ULONG Offset;
    ULONG Length;
} NCP_BURST_READ_REQUEST, *PNCP_BURST_READ_REQUEST;

typedef struct _NCP_READ_REQUEST {
    NCP_REQUEST RequestHeader;
    UCHAR Unused;
    UCHAR Handle[6];
    ULONG FileOffset;
    USHORT Length;
} NCP_READ_REQUEST, *PNCP_READ_REQUEST;

typedef struct _NCP_READ_RESPONSE {
    NCP_RESPONSE ResponseHeader;
    USHORT Length;
    //UCHAR Data[x];
} NCP_READ_RESPONSE, *PNCP_READ_RESPONSE;

#include <packoff.h>

#endif // _NCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\br\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Versao incorreta do DOS"
NLS_MSG_002     equ     "Suporte a VDM IPX/SPX j carregado"
NLS_MSG_003     equ     "Nao  possvel carregar o suporte a VDM IPX/SPX"
NLS_MSG_004     equ     "Redirecionador Vdm NetWare j carregado"
NLS_MSG_005     equ     "Nao  possvel carregar o redirecionador Vdm NetWare"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\cht\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Incorrect DOS Version"
NLS_MSG_002     equ     "VDM IPX/SPX support is already loaded"
NLS_MSG_003     equ     "Cannot load VDM IPX/SPX support"
NLS_MSG_004	equ	"The Vdm NetWare Redirector is already loaded"
NLS_MSG_005	equ	"The Vdm NetWare Redirector cannot be loaded"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\cs\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Nesprvn verze systmu DOS"
NLS_MSG_002     equ     "Podpora VDM IPX/SPX je ji natena"
NLS_MSG_003     equ     "Nelze nast podporu VDM IPX/SPX"
NLS_MSG_004     equ     "Pesmrova NetWare VDM je ji naten"
NLS_MSG_005     equ     "Pesmrova NetWare VDM nelze nast"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\da\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
	Created

--*/

endif

NLS_MSG_001     equ     "Forkert DOS-version"
NLS_MSG_002     equ     "Der er allerede indlst nderstttelse af VDM IPX/SPX"
NLS_MSG_003     equ     "Der kan ikke indlses understttelse af VDM IPX/SPX"
NLS_MSG_004     equ     "Vdm NetWare-omdirigeringen er allerede indlst"
NLS_MSG_005     equ     "Vdm NetWare-omdirigeringen kan ikke indlses"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\chs\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     " DOS "
NLS_MSG_002     equ     "VDM IPX/SPX "
NLS_MSG_003     equ     " VDM IPX/SPX "
NLS_MSG_004	equ	"Vdm NetWare "
NLS_MSG_005	equ	"Vdm NetWare "
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\validc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    validc.h

Abstract:

    Strings of valid/invalid characters for canonicalization

Author:

    Richard Firth (rfirth) 15-May-1991

Revision History:

    03-Jan-1992 rfirth
        Added ILLEGAL_FAT_CHARS and ILLEGAL_HPFS_CHARS (from fsrtl\name.c)

    27-Sep-1991 JohnRo
        Changed TEXT macro usage to allow UNICODE.

    19-Feb-1993 RitaW
        Ported for NetWare use.

--*/

//
// Disallowed control characters (not including \0)
//

#define CTRL_CHARS_0   L"\001\002\003\004\005\006\007"
#define CTRL_CHARS_1   L"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2   L"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3   L"\030\031\032\033\034\035\036\037"

#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

//
// Character subsets
//

#define NON_COMPONENT_CHARS L"\\/:"
#define ILLEGAL_CHARS_STR   L"\"<>|"
#define SPACE_STR           L" "
#define PATH_SEPARATORS     L"\\/"

//
// Combinations of the above
//

#define ILLEGAL_CHARS       CTRL_CHARS_STR ILLEGAL_CHARS_STR
#define ILLEGAL_NAME_CHARS_STR  L"\"/\\[]:|<>+;,?" CTRL_CHARS_STR  // "=" removed for NDS

#define STANDARD_ILLEGAL_CHARS  ILLEGAL_NAME_CHARS_STR L"*"
#define SERVER_ILLEGAL_CHARS    STANDARD_ILLEGAL_CHARS SPACE_STR

//
// Characters which may not appear in a canonicalized FAT filename are:
//
//  0x00 - 0x1f " * + , / : ; < = > ? [ \ ] |      
//

#define ILLEGAL_FAT_CHARS   CTRL_CHARS_STR L"\"*+,/:;<=>?[\\]|"

//
// Characters which may not appear in a canonicalized HPFS filename are:
//
//  0x00 - 0x1f " * / : < > ? \ |
//

#define ILLEGAL_HPFS_CHARS  CTRL_CHARS_STR L"\"*/:<>?\\|"


//
// Checks if the token contains all valid characters
//
#define IS_VALID_TOKEN(_Str, _StrLen) \
    ((BOOL) (wcscspn((_Str), STANDARD_ILLEGAL_CHARS) == (_StrLen)))

//
// Checks if the server name contains all valid characters for the server name
//
#define IS_VALID_SERVER_TOKEN(_Str, _StrLen) \
    ((BOOL) (wcscspn((_Str), SERVER_ILLEGAL_CHARS) == (_StrLen)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\es\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
	Created

--*/

endif

NLS_MSG_001     equ     "Versin incorrecta de DOS"
NLS_MSG_002     equ     "Ya se ha cargado la compatibilidad con VDM IPX/SPX"
NLS_MSG_003     equ     "No se puede cargar la compatibilidad con VDM IPX/SPX"
NLS_MSG_004     equ     "Ya se ha cargado el redirector de Vdm NetWare"
NLS_MSG_005     equ     "No se puede cargar el redirector Vdm NetWare"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\el\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "   DOS"
NLS_MSG_002     equ     "   VDM IPX/SPX   "
NLS_MSG_003     equ     "        VDM IPX/SPX"
NLS_MSG_004	equ	"    Vdm NetWare   "
NLS_MSG_005	equ	"         Vdm NetWare"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\fi\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
	Created

--*/

endif

NLS_MSG_001     equ     "Vr DOS-versio"
NLS_MSG_002     equ     "VDM IPX/SPX -tuki on jo ladattu"
NLS_MSG_003     equ     "Ei voi ladata VDM IPX/SPX -tukea"
NLS_MSG_004     equ     "Vdm NetWare -uudelleenohjaus on jo ladattu"
NLS_MSG_005     equ     "Vdm NetWare -uudelleenohjausta ei voi ladata"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\fr\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Version de DOS incorrecte"
NLS_MSG_002     equ     "Le support IPX/SPX VDM est dj charg"
NLS_MSG_003     equ     "Impossible de charger le support IPX/SPX VDM"
NLS_MSG_004	equ	"Le redirecteur NetWare Vdm est dj charg"
NLS_MSG_005	equ	"Impossible de charger le redirecteur NetWare Vdm"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\hu\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Nem megfelel DOS verzi."
NLS_MSG_002     equ     "A VDM IPX/SPX tmogats mr be van tltve."
NLS_MSG_003     equ     "A VDM IPX/SPX tmogatst nem lehet betlteni."
NLS_MSG_004     equ     "A Vdm NetWare tirnyt mr be van tltve."
NLS_MSG_005     equ     "A Vdm NetWare tirnytt nem lehet betlteni."
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\jpn\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "DOS o[W"
NLS_MSG_002     equ     "VDM IPX/SPX T|[g"
NLS_MSG_003     equ     "VDM IPX/SPX T|[g"
NLS_MSG_004	equ	"Vdm NetWare Redirector "
NLS_MSG_005	equ	"Vdm NetWare Redirector "
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\it\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
	Created

--*/

endif

NLS_MSG_001     equ     "Versione DOS non valida"
NLS_MSG_002     equ     "Supporto VDM IPX/SPX gi caricato"
NLS_MSG_003     equ     "Impossibile caricare il supporto VDM IPX/SPX"
NLS_MSG_004     equ     "Il redirector Vdm NetWare  gi caricato"
NLS_MSG_005     equ     "Impossibile caricare il redirector Vdm NetWare"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\ger\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Falsche DOS-Version"
NLS_MSG_002     equ     "VDM-IPX/SPX-Untersttzung ist bereits geladen."
NLS_MSG_003     equ     "VDM-IPX/SPX-Untersttzung kann nicht geladen werden."
NLS_MSG_004	equ	"Der VDM-NetWare-Redirector ist bereits geladen."
NLS_MSG_005	equ	"Der VDM-NetWare-Redirector kann nicht geladen werden."
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\kor\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Incorrect DOS  ."
NLS_MSG_002     equ     "VDM IPX/SPX   ."
NLS_MSG_003     equ     "VDM IPX/SPX    ."
NLS_MSG_004	equ	"VDM NetWare   ."
NLS_MSG_005	equ	"VDM NetWare    ."
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\nl\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Onjuiste DOS-versie"
NLS_MSG_002     equ     "Ondersteuning voor VDM IPX/SPX is al geladen"
NLS_MSG_003     equ     "Kan geen ondersteuning voor VDM IPX/SPX laden"
NLS_MSG_004	equ	"De VDM NetWare-redirector is al geladen"
NLS_MSG_005	equ	"Kan de VDM NetWare-redirector niet laden"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\pl\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif


NLS_MSG_001     equ     "Niepoprawna wersja systemu DOS"
NLS_MSG_002     equ     "Obsuga VDM IPX/SPX jest ju zaadowana"
NLS_MSG_003     equ     "Nie mona zaadowa obsugi VDM IPX/SPX"
NLS_MSG_004     equ     "Readresator Vdm NetWare jest ju zaadowany"
NLS_MSG_005     equ     "Nie mona zaadowa readresatora Vdm NetWare"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\no\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
	Created

--*/

endif

NLS_MSG_001     equ     "Feil DOS-versjon"
NLS_MSG_002     equ     "VDM IPX/SPX-sttte er allerede lastet inn"
NLS_MSG_003     equ     "Kan ikke laste inn VDM IPX/SPX-sttte"
NLS_MSG_004     equ     "Vdm NetWare-omadressereren er allerede lastet inn"
NLS_MSG_005     equ     "Vdm NetWare-omadressereren kan ikke lastes inn"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\usa\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Incorrect DOS Version"
NLS_MSG_002     equ     "VDM IPX/SPX support is already loaded"
NLS_MSG_003     equ     "Cannot load VDM IPX/SPX support"
NLS_MSG_004	equ	"The Vdm NetWare Redirector is already loaded"
NLS_MSG_005	equ	"The Vdm NetWare Redirector cannot be loaded"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\sv\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
	Created

--*/

endif

NLS_MSG_001     equ     "Felaktig DOS-version"
NLS_MSG_002     equ     "VDM IPX/SPX-std r redan inlst"
NLS_MSG_003     equ     "Det gick inte att lsa in VDM IPX/SPX-std"
NLS_MSG_004     equ     "VDM NetWare-omdirigeraren r redan inlst"
NLS_MSG_005     equ     "Det gick inte att lsa in VDM NetWare-omdirigeraren"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\pt\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif


NLS_MSG_001     equ     "Versao incorrecta de DOS"
NLS_MSG_002     equ     "J est carregado o suporte VDM IPX/SPX"
NLS_MSG_003     equ     "Impossvel carregar o suporte VDM IPX/SPX"
NLS_MSG_004	equ	"J est carregado o Vdm NetWare Redirector"
NLS_MSG_005	equ	"Impossvel carregar o Vdm NetWare Redirector"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\ru\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "  DOS"
NLS_MSG_002     equ     " VDM IPX/SPX  "
NLS_MSG_003     equ     "   VDM IPX/SPX"
NLS_MSG_004     equ     "Vdm NetWare Redirector  "
NLS_MSG_005     equ     "  Vdm NetWare Redirector"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\inc\tr\messages.inc ===
page    ,132
if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    messages.asm

Abstract:

    Contains internationalisable strings and lengths

Author:

    Richard L Firth (rfirth) 5-Oct-1993

Environment:

    DOS real mode only

[Notes:]

    optional-notes

Revision History:

    5-Oct-1993 rfirth
        Created

--*/

endif

NLS_MSG_001     equ     "Yanl DOS Srm"
NLS_MSG_002     equ     "VDM IPX/SPX destei zaten ykl"
NLS_MSG_003     equ     "VDM IPX/SPX destei yklenemiyor"
NLS_MSG_004	equ	"Vdm NetWare Ynlendiricisi zaten ykl"
NLS_MSG_005	equ	"Vdm NetWare Ynlendiricisi yklenemiyor"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\install\setupdll\dllinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contians the DLL attach/detach event entry point for
    a Setup support DLL.

Author:

    Ted Miller (tedm) July-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

HINSTANCE ThisDLLHandle;

BOOL
DLLInit(
    IN HINSTANCE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        ThisDLLHandle = DLLHandle;
        break;

    case DLL_PROCESS_DETACH:

        //  Delete all automatically established connections
        //  See UNC handling in netcon.c.
        //
        //  This doesn't work, because the unload sequence
        //  is different for "lazy" load DLLs than for load-time DLLs.
        //  INFs must be responsible for calling DeleteAllConnections().
        //
        //  DeleteAllConnectionsWorker() ;
        //
        break ;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\install\setupdll\lodctr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lodctr.c

Abstract:

    Program to read the contents of the file specified in the command line
        and update the registry accordingly

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

    a-robw  25-Feb-93   revised calls to make it compile as a UNICODE or
                        an ANSI app.

--*/
#define     UNICODE     1
#define     _UNICODE    1
//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
//
//  Windows Include files
//
#include <windows.h>
#include <winperf.h>
#include <tchar.h>
//
#define _INITIALIZE_GLOBALS_ 1
#include "common.h"
#undef _INITIALIZE_GLOBALS_

#define TYPE_HELP   1
#define TYPE_NAME   2

#include "nwcfg.hxx"

#define  OLD_VERSION 0x010000
DWORD    dwSystemVersion;


BOOL
GetDriverName (
    IN  LPTSTR  lpIniFile,
    OUT LPTSTR  *lpDevName
)
/*++
GetDriverName

    looks up driver name in the .ini file and returns it in lpDevName

Arguments

    lpIniFile

        Filename of ini file

    lpDevName

        pointer to pointer to reciev buffer w/dev name in it

Return Value

    TRUE if found
    FALSE if not found in .ini file

--*/
{
    DWORD   dwRetSize;

    if (lpDevName) {
        dwRetSize = GetPrivateProfileString (
            TEXT("info"),       // info section
            TEXT("drivername"), // driver name value
            TEXT("drivernameNotFound"),   // default value
            *lpDevName,
            DISP_BUFF_SIZE,
            lpIniFile);
        
        if ((lstrcmpi(*lpDevName, TEXT("drivernameNotFound"))) != 0) {
            // name found
            return TRUE;
        } else {
            // name not found, default returned so return NULL string
            lstrcpy(*lpDevName,TEXT("\0"));
            return FALSE;
        }
    } else {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }
}

BOOL
BuildLanguageTables (
    IN  LPTSTR  lpIniFile,
    IN OUT PLANGUAGE_LIST_ELEMENT   pFirstElem
)
/*++

BuildLanguageTables
    
    Creates a list of structures that will hold the text for
    each supported language

Arguments
    
    lpIniFile

        Filename with data

    pFirstElem

        pointer to first list entry

ReturnValue

    TRUE if all OK
    FALSE if not

--*/
{

    LPTSTR  lpEnumeratedLangs;
    LPTSTR  lpThisLang;
    
    PLANGUAGE_LIST_ELEMENT   pThisElem;

    DWORD   dwSize;

    lpEnumeratedLangs = malloc(SMALL_BUFFER_SIZE * sizeof(TCHAR));

    if (!lpEnumeratedLangs) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    dwSize = GetPrivateProfileString (
        TEXT("languages"),
        NULL,                   // return all values in multi-sz string
        TEXT("009"),            // english as the default
        lpEnumeratedLangs,
        SMALL_BUFFER_SIZE,
        lpIniFile);

    // do first language

    lpThisLang = lpEnumeratedLangs;
    pThisElem = pFirstElem;

    while (*lpThisLang) {
        pThisElem->pNextLang = NULL;

        pThisElem->LangId = (LPTSTR) malloc ((lstrlen(lpThisLang) + 1) * sizeof(TCHAR));
        if (pThisElem->LangId == NULL) {
            free(lpEnumeratedLangs);
            SetLastError (ERROR_OUTOFMEMORY);
            return FALSE;
        }

        lstrcpy (pThisElem->LangId, lpThisLang);
        pThisElem->pFirstName = NULL;
        pThisElem->pThisName = NULL;
        pThisElem->dwNumElements=0;
        pThisElem->NameBuffer = NULL;
        pThisElem->HelpBuffer = NULL;

        // go to next string

        lpThisLang += lstrlen(lpThisLang) + 1;

        if (*lpThisLang) {  // there's another so allocate a new element
            pThisElem->pNextLang = malloc (sizeof(LANGUAGE_LIST_ELEMENT));
            if (!pThisElem) {
                free(pThisElem->LangId);
                free(lpEnumeratedLangs);
                SetLastError (ERROR_OUTOFMEMORY);
                return FALSE;   
            }
            pThisElem = pThisElem->pNextLang;   // point to new one
        }
    }

    free(lpEnumeratedLangs);
    return TRUE;
}

BOOL
LoadIncludeFile (
    IN LPTSTR lpIniFile,
    OUT PSYMBOL_TABLE_ENTRY   *pTable
)
/*++

LoadIncludeFile

    Reads the include file that contains symbolic name definitions and
    loads a table with the values defined

Arguments

    lpIniFile

        Ini file with include file name

    pTable

        address of pointer to table structure created
Return Value

    TRUE if table read or if no table defined
    FALSE if error encountere reading table

--*/
{
    INT         iNumArgs;

    DWORD       dwSize;

    BOOL        bReUse;
    BOOL        bReturn = TRUE;

    PSYMBOL_TABLE_ENTRY   pThisSymbol;

    LPTSTR      lpIncludeFileName = NULL;
    LPSTR       lpIncludeFile = NULL;
    LPSTR       lpLineBuffer  = NULL;
    LPSTR       lpAnsiSymbol  = NULL;

    FILE        *fIncludeFile;
    HFILE       hIncludeFile;
    OFSTRUCT    ofIncludeFile;

    lpIncludeFileName = malloc (MAX_PATH * sizeof (TCHAR));
    lpIncludeFile = malloc (MAX_PATH);
    lpLineBuffer = malloc (DISP_BUFF_SIZE);
    lpAnsiSymbol = malloc (DISP_BUFF_SIZE);

    if (!lpIncludeFileName || !lpIncludeFile || !lpLineBuffer || !lpAnsiSymbol) {
        if (lpIncludeFileName) {
            free(lpIncludeFileName);
        }
        if (lpIncludeFile) {
            free(lpIncludeFile);
        }
        if (lpLineBuffer) {
            free(lpLineBuffer);
        }
        if (lpAnsiSymbol) {
            free(lpAnsiSymbol);
        }

        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;    
    }

    // get name of include file (if present)

    dwSize = GetPrivateProfileString (
            TEXT("info"),
            TEXT("symbolfile"),
            TEXT("SymbolFileNotFound"),
            lpIncludeFileName,
            _msize(lpIncludeFileName),
            lpIniFile);

    if ((lstrcmpi(lpIncludeFileName, TEXT("SymbolFileNotFound"))) == 0) {
        // no symbol file defined
        *pTable = NULL;
        goto CleanUp2;
    }

    // if here, then a symbol file was defined and is now stored in 
    // lpIncludeFileName
            
    CharToOem (lpIncludeFileName, lpIncludeFile);

    hIncludeFile = OpenFile (
        lpIncludeFile,
        &ofIncludeFile,
        OF_PARSE);

    if (hIncludeFile == HFILE_ERROR) { // unable to read include filename
        // error is already in GetLastError
        *pTable = NULL;
        bReturn = FALSE;
        goto CleanUp2;
    } else {
        // open a stream 
        fIncludeFile = fopen (ofIncludeFile.szPathName, "rt");

        if (!fIncludeFile) {
            *pTable = NULL;
            bReturn = FALSE;
            goto CleanUp2;
        }
    }
        
    //
    //  read ANSI Characters from include file
    //

    bReUse = FALSE;

    while (fgets(lpLineBuffer, DISP_BUFF_SIZE, fIncludeFile) != NULL) {
        if (strlen(lpLineBuffer) > 8) {
            if (!bReUse) {
                if (*pTable) {
                    // then add to list
                    pThisSymbol->pNext = malloc (sizeof (SYMBOL_TABLE_ENTRY));
                    pThisSymbol = pThisSymbol->pNext;
                } else { // allocate first element
                    *pTable = malloc (sizeof (SYMBOL_TABLE_ENTRY));
                    pThisSymbol = *pTable;
                }

                if (!pThisSymbol) {
                    SetLastError (ERROR_OUTOFMEMORY);
                    bReturn = FALSE;
                    goto CleanUp;
                }

                // allocate room for the symbol name by using the line length
                // - the size of "#define "

//                pThisSymbol->SymbolName = malloc ((strlen(lpLineBuffer) - 8) * sizeof (TCHAR));
                pThisSymbol->SymbolName = malloc (DISP_BUFF_SIZE * sizeof (TCHAR));

                if (!pThisSymbol->SymbolName) {
                    SetLastError (ERROR_OUTOFMEMORY);
                    bReturn = FALSE;
                    goto CleanUp;
                }

            }

            // all the memory is allocated so load the fields

            pThisSymbol->pNext = NULL;

            iNumArgs = sscanf (lpLineBuffer, "#define %s %d",
                lpAnsiSymbol, &pThisSymbol->Value);

            if (iNumArgs != 2) {
                *(pThisSymbol->SymbolName) = TEXT('\0');
                pThisSymbol->Value = (DWORD)-1L;
                bReUse = TRUE;
            }  else {
                OemToChar (lpAnsiSymbol, pThisSymbol->SymbolName);
                bReUse = FALSE;
            }
        }
    }
CleanUp:
    fclose (fIncludeFile);
CleanUp2:
    if (lpIncludeFileName) free (lpIncludeFileName);
    if (lpIncludeFile) free (lpIncludeFile);
    if (lpLineBuffer) free (lpLineBuffer);
    if (lpAnsiSymbol) free (lpAnsiSymbol);

    return bReturn;
}

BOOL
ParseTextId (
    IN LPTSTR  lpTextId,
    IN PSYMBOL_TABLE_ENTRY pFirstSymbol,
    OUT PDWORD  pdwOffset,
    OUT LPTSTR  *lpLangId,
    OUT PDWORD  pdwType
)
/*++

ParseTextId

    decodes Text Id key from .INI file

    syntax for this process is:

        {<DecimalNumber>}                {"NAME"}
        {<SymbolInTable>}_<LangIdString>_{"HELP"}

         e.g. 0_009_NAME
              OBJECT_1_009_HELP

Arguments

    lpTextId

        string to decode

    pFirstSymbol

        pointer to first entry in symbol table (NULL if no table)

    pdwOffset

        address of DWORD to recive offest value

    lpLangId

        address of pointer to Language Id string
        (NOTE: this will point into the string lpTextID which will be
        modified by this routine)

    pdwType

        pointer to dword that will recieve the type of string i.e.
        HELP or NAME

Return Value

    TRUE    text Id decoded successfully
    FALSE   unable to decode string

    NOTE: the string in lpTextID will be modified by this procedure

--*/
{
    LPTSTR  lpThisChar;
    PSYMBOL_TABLE_ENTRY pThisSymbol;
    
    // check for valid return arguments

    if (!(pdwOffset) ||
        !(lpLangId) ||
        !(pdwType)) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // search string from right to left in order to identify the
    // components of the string.

    lpThisChar = lpTextId + lstrlen(lpTextId); // point to end of string

    while (*lpThisChar != TEXT('_')) {
        lpThisChar--;
        if (lpThisChar <= lpTextId) {
            // underscore not found in string
            SetLastError (ERROR_INVALID_DATA);
            return FALSE;
        }
    }

    // first underscore found

    if ((lstrcmpi(lpThisChar, TEXT("_NAME"))) == 0) {
        // name found, so set type
        *pdwType = TYPE_NAME;
    } else if ((lstrcmpi(lpThisChar, TEXT("_HELP"))) == 0) {
        // help text found, so set type
        *pdwType = TYPE_HELP;
    } else {
        // bad format
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // set the current underscore to \0 and look for language ID

    *lpThisChar-- = TEXT('\0');

    while (*lpThisChar != TEXT('_')) {
        lpThisChar--;
        if (lpThisChar <= lpTextId) {
            // underscore not found in string
            SetLastError (ERROR_INVALID_DATA);
            return FALSE;
        }
    }
    
    // set lang ID string pointer to current char ('_') + 1

    *lpLangId = lpThisChar + 1;

    // set this underscore to a NULL and try to decode the remaining text

    *lpThisChar = TEXT('\0');

    // see if the first part of the string is a decimal digit

    if ((_stscanf (lpTextId, TEXT(" %d"), pdwOffset)) != 1) {
        // it's not a digit, so try to decode it as a symbol in the 
        // loaded symbol table

        for (pThisSymbol=pFirstSymbol;
             pThisSymbol && *(pThisSymbol->SymbolName);
             pThisSymbol = pThisSymbol->pNext) {

            if ((lstrcmpi(lpTextId, pThisSymbol->SymbolName)) == 0) {
                // a matching symbol was found, so insert it's value 
                // and return (that's all that needs to be done
                *pdwOffset = pThisSymbol->Value;
                return TRUE;
            }
        }
        // if here, then no matching symbol was found, and it's not
        // a number, so return an error

        SetLastError (ERROR_BAD_TOKEN_TYPE);
        return FALSE;
    } else {
        // symbol was prefixed with a decimal number
        return TRUE;
    }
}

PLANGUAGE_LIST_ELEMENT
FindLanguage (
    IN PLANGUAGE_LIST_ELEMENT   pFirstLang,
    IN LPTSTR   pLangId
)
/*++

FindLanguage

    searchs the list of languages and returns a pointer to the language
    list entry that matches the pLangId string argument

Arguments

    pFirstLang

        pointer to first language list element

    pLangId

        pointer to text string with language ID to look up

Return Value

    Pointer to matching language list entry
    or NULL if no match

--*/
{
    PLANGUAGE_LIST_ELEMENT  pThisLang;

    for (pThisLang = pFirstLang;
         pThisLang;
         pThisLang = pThisLang->pNextLang) {
        if ((lstrcmpi(pLangId, pThisLang->LangId)) == 0) {
            // match found so return pointer
            return pThisLang;
        }
    }
    return NULL;    // no match found
}

BOOL
AddEntryToLanguage (
    PLANGUAGE_LIST_ELEMENT  pLang,
    LPTSTR                  lpValueKey,
    DWORD                   dwType,
    DWORD                   dwOffset,
    LPTSTR                  lpIniFile
)
/*++

AddEntryToLanguage

    Add a text entry to the list of text entries for the specified language

Arguments

    pLang

        pointer to language structure to update

    lpValueKey

        value key to look up in .ini file

    dwOffset

        numeric offset of name in registry

    lpIniFile

        ini file

Return Value

    TRUE if added successfully
    FALSE if error
        (see GetLastError for status)

--*/
{
    LPTSTR  lpLocalStringBuff;
    DWORD   dwSize;

    lpLocalStringBuff = malloc (SMALL_BUFFER_SIZE * sizeof(TCHAR));

    if (!lpLocalStringBuff) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    dwSize = GetPrivateProfileString (
        TEXT("text"),       // section
        lpValueKey,      // key
        TEXT("DefaultValue"), // default value
        lpLocalStringBuff,
        SMALL_BUFFER_SIZE,
        lpIniFile);

    if ((lstrcmpi(lpLocalStringBuff, TEXT("DefaultValue")))== 0) {
        SetLastError (ERROR_BADKEY);
        if (lpLocalStringBuff) free (lpLocalStringBuff);
        return FALSE;
    }

    // key found, so load structure

    if (!pLang->pThisName) {
        // this is the first
        pLang->pThisName =
            malloc (sizeof (NAME_ENTRY) +
                    (lstrlen(lpLocalStringBuff) + 1) * sizeof (TCHAR));
        if (!pLang->pThisName) {
            SetLastError (ERROR_OUTOFMEMORY);
            if (lpLocalStringBuff) free (lpLocalStringBuff);
            return FALSE;
        } else {
            pLang->pFirstName = pLang->pThisName;
        }
    } else {
        pLang->pThisName->pNext =
            malloc (sizeof (NAME_ENTRY) +
                    (lstrlen(lpLocalStringBuff) + 1) * sizeof (TCHAR));
        if (!pLang->pThisName->pNext) {
            SetLastError (ERROR_OUTOFMEMORY);
            if (lpLocalStringBuff) free (lpLocalStringBuff);
            return FALSE;
        } else {
            pLang->pThisName = pLang->pThisName->pNext;
        }
    }

    // pLang->pThisName now points to an uninitialized structre

    pLang->pThisName->pNext = NULL;
    pLang->pThisName->dwOffset = dwOffset;
    pLang->pThisName->dwType = dwType;
    pLang->pThisName->lpText = (LPTSTR)&(pLang->pThisName[1]); // string follows

    lstrcpy (pLang->pThisName->lpText, lpLocalStringBuff);

    if (lpLocalStringBuff) free (lpLocalStringBuff);

    SetLastError (ERROR_SUCCESS);

    return (TRUE);
}

BOOL
LoadLanguageLists (
    IN LPTSTR  lpIniFile,
    IN DWORD   dwFirstCounter,
    IN DWORD   dwFirstHelp,
    IN PSYMBOL_TABLE_ENTRY   pFirstSymbol,
    IN PLANGUAGE_LIST_ELEMENT  pFirstLang
)
/*++

LoadLanguageLists

    Reads in the name and explain text definitions from the ini file and
    builds a list of these items for each of the supported languages and
    then combines all the entries into a sorted MULTI_SZ string buffer.

Arguments

    lpIniFile

        file containing the definitions to add to the registry
    
    dwFirstCounter

        starting counter name index number

    dwFirstHelp

        starting help text index number

    pFirstLang

        pointer to first element in list of language elements

Return Value

    TRUE if all is well
    FALSE if not
        error is returned in GetLastError

--*/
{
    LPTSTR  lpTextIdArray;
    LPTSTR  lpLocalKey;
    LPTSTR  lpThisKey;
    DWORD   dwSize;
    LPTSTR  lpLang;
    DWORD   dwOffset;
    DWORD   dwType;
    PLANGUAGE_LIST_ELEMENT  pThisLang;

    if (!(lpTextIdArray = malloc (SMALL_BUFFER_SIZE * sizeof(TCHAR)))) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    if (!(lpLocalKey = malloc (MAX_PATH))) {
        SetLastError (ERROR_OUTOFMEMORY);
        if (lpTextIdArray) free (lpTextIdArray);
        return FALSE;
    }

    // get list of text keys to look up

    dwSize = GetPrivateProfileString (
        TEXT("text"),   // [text] section of .INI file
        NULL,           // return all keys
        TEXT("DefaultKeyValue"),    // default
        lpTextIdArray,  // return buffer
        SMALL_BUFFER_SIZE, // buffer size
        lpIniFile);     // .INI file name

    if ((lstrcmpi(lpTextIdArray, TEXT("DefaultKeyValue"))) == 0) {
        // key not found, default returned
        SetLastError (ERROR_NO_SUCH_GROUP);
        if (lpTextIdArray) free (lpTextIdArray);
        if (lpLocalKey) free (lpLocalKey);
        return FALSE;
    }

    // do each key returned

    for (lpThisKey=lpTextIdArray;
         *lpThisKey;
         lpThisKey += (lstrlen(lpThisKey) + 1)) {

        lstrcpy (lpLocalKey, lpThisKey);    // make a copy of the key
        
        // parse key to see if it's in the correct format

        if (ParseTextId(lpLocalKey, pFirstSymbol, &dwOffset, &lpLang, &dwType)) {
            // so get pointer to language entry structure
            pThisLang = FindLanguage (pFirstLang, lpLang);
            if (pThisLang) {
                if (!AddEntryToLanguage(pThisLang,
                    lpThisKey, dwType,
                    (dwOffset + ((dwType == TYPE_NAME) ? dwFirstCounter : dwFirstHelp)),
                    lpIniFile)) {
                }
            } else { // language not in list
            }
        } else { // unable to parse ID string
        }
    }

    if (lpTextIdArray) free (lpTextIdArray);
    if (lpLocalKey) free (lpLocalKey);
    return TRUE;

}

BOOL
SortLanguageTables (
    PLANGUAGE_LIST_ELEMENT pFirstLang,
    PDWORD                 pdwLastName,
    PDWORD                 pdwLastHelp
)
/*++

SortLangageTables

    walks list of languages loaded, allocates and loads a sorted multi_SZ
    buffer containing new entries to be added to current names/help text

Arguments

    pFirstLang

        pointer to first element in list of languages

ReturnValue

    TRUE    everything done as expected
    FALSE   error occurred, status in GetLastError

--*/
{
    PLANGUAGE_LIST_ELEMENT  pThisLang;

    BOOL            bSorted;

    LPTSTR          pNameBufPos, pHelpBufPos;

    PNAME_ENTRY     pThisName, pPrevName;

    DWORD           dwHelpSize, dwNameSize, dwSize;

    if (!pdwLastName || !pdwLastHelp) {
        SetLastError (ERROR_BAD_ARGUMENTS);
        return FALSE;
    }

    for (pThisLang = pFirstLang;
        pThisLang;
        pThisLang = pThisLang->pNextLang) {
        // do each language in list

        // sort elements in list by value (offset) so that lowest is first
        
        bSorted = FALSE;
        while (!bSorted ) {
            // point to start of list

            pPrevName = pThisLang->pFirstName;
            if (pPrevName) {
                pThisName = pPrevName->pNext;
            } else {
                break;  // no elements in this list
            }

            if (!pThisName) {
                break;      // only one element in the list
            }
            bSorted = TRUE; // assume that it's sorted

            // go until end of list
                    
            while (pThisName->pNext) {
                if (pThisName->dwOffset > pThisName->pNext->dwOffset) {
                    // switch 'em
                    pPrevName->pNext = pThisName->pNext;
                    pThisName->pNext = pThisName->pNext->pNext;
                    pThisName->pNext->pNext = pThisName;
                    bSorted = FALSE;
                }
                //move to next entry
                pPrevName = pThisName;
                pThisName = pThisName->pNext;
            }
            // if bSorted = TRUE , then we walked all the way down 
            // the list without changing anything so that's the end.
        }

        // with the list sorted, build the MULTI_SZ strings for the
        // help and name text strings

        // compute buffer size

        dwNameSize = dwHelpSize = 0;
        *pdwLastName = *pdwLastHelp = 0;
        
        for (pThisName = pThisLang->pFirstName;
            pThisName;
            pThisName = pThisName->pNext) {
                // compute buffer requirements for this entry
            dwSize = SIZE_OF_OFFSET_STRING;
            dwSize += lstrlen (pThisName->lpText);
            dwSize += 1;   // null
            dwSize *= sizeof (TCHAR);   // adjust for character size
                // add to appropriate size register
            if (pThisName->dwType == TYPE_NAME) {
                dwNameSize += dwSize;
                if (pThisName->dwOffset > *pdwLastName) {
                    *pdwLastName = pThisName->dwOffset;
                }
            } else if (pThisName->dwType == TYPE_HELP) {
                dwHelpSize += dwSize;
                if (pThisName->dwOffset > *pdwLastHelp) {
                    *pdwLastHelp = pThisName->dwOffset;
                }
            }
        }

        // allocate buffers for the Multi_SZ strings

        pThisLang->NameBuffer = malloc (dwNameSize);
        pThisLang->HelpBuffer = malloc (dwHelpSize);

        if (!pThisLang->NameBuffer || !pThisLang->HelpBuffer) {
            SetLastError (ERROR_OUTOFMEMORY);
            return FALSE;
        }

        // fill in buffers with sorted strings

        pNameBufPos = (LPTSTR)pThisLang->NameBuffer;
        pHelpBufPos = (LPTSTR)pThisLang->HelpBuffer;

        for (pThisName = pThisLang->pFirstName;
            pThisName;
            pThisName = pThisName->pNext) {
            if (pThisName->dwType == TYPE_NAME) {
                // load number as first 0-term. string
                dwSize = _stprintf (pNameBufPos, TEXT("%d"), pThisName->dwOffset);
                pNameBufPos += dwSize + 1;  // save NULL term.
                // load the text to match
                lstrcpy (pNameBufPos, pThisName->lpText);
                pNameBufPos += lstrlen(pNameBufPos) + 1;
            } else if (pThisName->dwType == TYPE_HELP) {
                // load number as first 0-term. string
                dwSize = _stprintf (pHelpBufPos, TEXT("%d"), pThisName->dwOffset);
                pHelpBufPos += dwSize + 1;  // save NULL term.
                // load the text to match
                lstrcpy (pHelpBufPos, pThisName->lpText);
                pHelpBufPos += lstrlen(pHelpBufPos) + 1;
            }
        }

        // add additional NULL at end of string to terminate MULTI_SZ

        *pHelpBufPos = TEXT('\0');
        *pNameBufPos = TEXT('\0');

        // compute size of MULTI_SZ strings

        pThisLang->dwNameBuffSize = (DWORD)((PBYTE)pNameBufPos -
                                            (PBYTE)pThisLang->NameBuffer) +
                                            sizeof(TCHAR);
        pThisLang->dwHelpBuffSize = (DWORD)((PBYTE)pHelpBufPos -
                                            (PBYTE)pThisLang->HelpBuffer) +
                                            sizeof(TCHAR);
    }
    return TRUE;
}

BOOL
UpdateEachLanguage (
    HKEY    hPerflibRoot,
    PLANGUAGE_LIST_ELEMENT    pFirstLang
)
/*++

UpdateEachLanguage

    Goes through list of languages and adds the sorted MULTI_SZ strings
    to the existing counter and explain text in the registry.
    Also updates the "Last Counter and Last Help" values

Arguments

    hPerflibRoot

        handle to Perflib key in the registry

    pFirstLanguage

        pointer to first language entry

Return Value

    TRUE    all went as planned
    FALSE   an error occured, use GetLastError to find out what it was.

--*/
{

    PLANGUAGE_LIST_ELEMENT  pThisLang;

    LPTSTR      pHelpBuffer = NULL;
    LPTSTR      pNameBuffer = NULL;
    LPTSTR      pNewName;
    LPTSTR      pNewHelp;

    DWORD       dwBufferSize;
    DWORD       dwValueType;
    DWORD       dwCounterSize;
    DWORD       dwHelpSize;

    HKEY        hKeyThisLang;

    LONG        lStatus;

    for (pThisLang = pFirstLang;
        pThisLang;
        pThisLang = pThisLang->pNextLang) {

        lStatus = RegOpenKeyEx(
            hPerflibRoot,
            pThisLang->LangId,
            RESERVED,
            KEY_READ | KEY_WRITE,
            &hKeyThisLang);

        if (lStatus == ERROR_SUCCESS) {
            
            // get size of counter names

            dwBufferSize = 0;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                Counters,
                RESERVED,
                &dwValueType,
                NULL,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                return FALSE;
            }

            dwCounterSize = dwBufferSize;

            // get size of help text

            dwBufferSize = 0;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                Help,
                RESERVED,
                &dwValueType,
                NULL,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                return FALSE;
            }

            dwHelpSize = dwBufferSize;

            // allocate new buffers
            
            dwCounterSize += pThisLang->dwNameBuffSize;
            pNameBuffer = malloc (dwCounterSize);

            dwHelpSize += pThisLang->dwHelpBuffSize;
            pHelpBuffer = malloc (dwHelpSize);

            if (!pNameBuffer || !pHelpBuffer) {
                if (pNameBuffer) {
                    free(pNameBuffer);
                }
                if (pHelpBuffer) {
                    free(pHelpBuffer);
                }
                SetLastError (ERROR_OUTOFMEMORY);
                return (FALSE);
            }

            // load current buffers into memory

            // read counter names into buffer. Counter names will be stored as
            // a MULTI_SZ string in the format of "###" "Name"

            dwBufferSize = dwCounterSize;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                Counters,
                RESERVED,
                &dwValueType,
                (LPVOID)pNameBuffer,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                goto ErrorExit;
            }

            // set pointer to location in buffer where new string should be
            //  appended: end of buffer - 1 (second null at end of MULTI_SZ

            pNewName = (LPTSTR)((PBYTE)pNameBuffer + dwBufferSize - sizeof(TCHAR));

            // adjust buffer length to take into account 2nd null from 1st 
            // buffer that has been overwritten

            dwCounterSize -= sizeof(TCHAR);

            // read explain text into buffer. Counter names will be stored as
            // a MULTI_SZ string in the format of "###" "Text..."

            dwBufferSize = dwHelpSize;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                Help,
                RESERVED,
                &dwValueType,
                (LPVOID)pHelpBuffer,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                goto ErrorExit;
            }

            // set pointer to location in buffer where new string should be
            //  appended: end of buffer - 1 (second null at end of MULTI_SZ

            pNewHelp = (LPTSTR)((PBYTE)pHelpBuffer + dwBufferSize - sizeof(TCHAR));

            // adjust buffer length to take into account 2nd null from 1st 
            // buffer that has been overwritten

            dwHelpSize -= sizeof(TCHAR);

            // append new strings to end of current strings

            memcpy (pNewHelp, pThisLang->HelpBuffer, pThisLang->dwHelpBuffSize);
            memcpy (pNewName, pThisLang->NameBuffer, pThisLang->dwNameBuffSize);

                lStatus = RegSetValueEx (
                    hKeyThisLang,
                    Counters,
                    RESERVED,
                    REG_MULTI_SZ,
                    (LPBYTE)pNameBuffer,
                    dwCounterSize);
            
                if (lStatus != ERROR_SUCCESS) {
                    SetLastError (lStatus);
                    goto ErrorExit;
                }

                lStatus = RegSetValueEx (
                    hKeyThisLang,
                    Help,
                    RESERVED,
                    REG_MULTI_SZ,
                    (LPBYTE)pHelpBuffer,
                    dwHelpSize);

                if (lStatus != ERROR_SUCCESS) {
                    SetLastError (lStatus);
                    goto ErrorExit;
                }
ErrorExit:
            free (pNameBuffer);
            free (pHelpBuffer);
            CloseHandle (hKeyThisLang);
            if (lStatus != ERROR_SUCCESS)
                return FALSE;
        } else {
        }
    }

    return TRUE;
}

BOOL
UpdateRegistry (
    LPTSTR  lpIniFile,
    HKEY    hKeyMachine,
    LPTSTR  lpDriverName,
    PLANGUAGE_LIST_ELEMENT  pFirstLang,
    PSYMBOL_TABLE_ENTRY   pFirstSymbol
)
/*++

UpdateRegistry
    
    - checks, and if not busy, sets the "busy" key in the registry
    - Reads in the text and help definitions from the .ini file
    - Reads in the current contents of the HELP and COUNTER names
    - Builds a sorted MULTI_SZ struct containing the new definitions 
    - Appends the new MULTI_SZ to the current as read from the registry
    - loads the new MULTI_SZ string into the registry
    - updates the keys in the driver's entry and Perflib's entry in the
        registry (e.g. first, last, etc)
    - clears the "busy" key

Arguments

    lpIniFile
        pathname to .ini file conatining definitions

    hKeyMachine
        handle to HKEY_LOCAL_MACHINE in registry on system to
        update counters for.

    lpDriverName
        Name of device driver to load counters for

    pFirstLang
        pointer to first element in language structure list

    pFirstSymbol
        pointer to first element in symbol definition list


Return Value

    TRUE if registry updated successfully
    FALSE if registry not updated
        (This routine will print an error message to stdout if an error
        is encountered).

--*/
{

    HKEY    hDriverPerf = NULL;
    HKEY    hPerflib = NULL;

    LPTSTR  lpDriverKeyPath;

    DWORD   dwType;
    DWORD   dwSize;

    DWORD   dwFirstDriverCounter;
    DWORD   dwFirstDriverHelp;
    DWORD   dwLastDriverCounter;
    DWORD   dwLastPerflibCounter;
    DWORD   dwLastPerflibHelp;

    BOOL    bStatus;
    LONG    lStatus;

    bStatus = FALSE;

    // allocate temporary buffers
    lpDriverKeyPath = malloc (MAX_PATH * sizeof(TCHAR));

    if (!lpDriverKeyPath) {
        SetLastError (ERROR_OUTOFMEMORY);
        goto UpdateRegExit;
    }

    // build driver key path string

    lstrcpy (lpDriverKeyPath, DriverPathRoot);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, lpDriverName);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, Performance);

    // open keys to registry
    // open key to driver's performance key

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        lpDriverKeyPath,
        RESERVED,
        KEY_WRITE | KEY_READ,
        &hDriverPerf);

    if (lStatus != ERROR_SUCCESS) {
        SetLastError (lStatus);
        goto UpdateRegExit;
    }

    // open key to perflib's "root" key

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        NamesKey,
        RESERVED,
        KEY_WRITE | KEY_READ,
        &hPerflib);

    if (lStatus != ERROR_SUCCESS) {
        SetLastError (lStatus);
        goto UpdateRegExit;
    }

    // get "last" values from PERFLIB

    dwType = 0;
    dwLastPerflibCounter = 0;
    dwSize = sizeof (dwLastPerflibCounter);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwLastPerflibCounter,
        &dwSize);
    
    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        SetLastError (lStatus);
        goto UpdateRegExit;
    }

    // get last help value now

    dwType = 0;
    dwLastPerflibHelp = 0;
    dwSize = sizeof (dwLastPerflibHelp);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwLastPerflibHelp,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        SetLastError (lStatus);
        goto UpdateRegExit;
    }

    // get last help value now

    dwType = 0;
    dwSize = sizeof (dwSystemVersion);
    lStatus = RegQueryValueEx (
        hPerflib,
        VersionStr,
        RESERVED,
        &dwType,
        (LPBYTE)&dwSystemVersion,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        dwSystemVersion = OLD_VERSION;
    }

    if ( dwSystemVersion != OLD_VERSION )
    {
        // ERROR. The caller does not check the version. It is the caller
        // fault
        goto UpdateRegExit;
    }

    // see if this driver's counter names have already been installed
    // by checking to see if LastCounter's value is less than Perflib's
    // Last Counter

    dwType = 0;
    dwLastDriverCounter = 0;
    dwSize = sizeof (dwLastDriverCounter);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwLastDriverCounter,
        &dwSize);

    if (lStatus == ERROR_SUCCESS) {
        // if key found, then compare with perflib value and exit this
        // procedure if the driver's last counter is <= to perflib's last
        //
        // if key not found, then continue with installation
        // on the assumption that the counters have not been installed

        if (dwLastDriverCounter <= dwLastPerflibCounter) {
            SetLastError (ERROR_SUCCESS);
            goto UpdateRegExit;
        }
    }

    // everything looks like it's ready to go so first check the 
    // busy indicator

    lStatus = RegQueryValueEx (
        hPerflib,
        Busy,
        RESERVED,
        &dwType,
        NULL,
        &dwSize);

    if (lStatus == ERROR_SUCCESS) { // perflib is in use at the moment
        return ERROR_BUSY;
    }

    // set the "busy" indicator under the PERFLIB key     

    dwSize = lstrlen(lpDriverName) * sizeof (TCHAR);
    lStatus = RegSetValueEx (
        hPerflib,
        Busy,
        RESERVED,
        REG_SZ,
        (LPBYTE)lpDriverName,
        dwSize);

    if (lStatus != ERROR_SUCCESS) {
        SetLastError (lStatus);
        goto UpdateRegExit;
    }

    // increment (by 2) the last counters so they point to the first
    // unused index after the existing names and then 
    // set the first driver counters

    dwFirstDriverCounter = dwLastPerflibCounter += 2;
    dwFirstDriverHelp = dwLastPerflibHelp += 2;

    // load .INI file definitions into language tables

    if (!LoadLanguageLists (lpIniFile, dwLastPerflibCounter, dwLastPerflibHelp,
        pFirstSymbol, pFirstLang)) {
        // error message is displayed by LoadLanguageLists so just abort
        // error is in GetLastError already
        goto UpdateRegExit;
    }

    // all the symbols and definitions have been loaded into internal
    // tables. so now they need to be sorted and merged into a multiSZ string
    // this routine also updates the "last" counters

    if (!SortLanguageTables (pFirstLang, &dwLastPerflibCounter, &dwLastPerflibHelp)) {
        goto UpdateRegExit;
    }

    if (!UpdateEachLanguage (hPerflib, pFirstLang)) {
        goto UpdateRegExit;
    }

    // update last counters for driver and perflib

    // perflib...

    lStatus = RegSetValueEx(
        hPerflib,
        LastCounter,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibCounter,
        sizeof(DWORD));

    lStatus = RegSetValueEx(
        hPerflib,
        LastHelp,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibHelp,
        sizeof(DWORD));

    // and the driver

    lStatus = RegSetValueEx(
        hDriverPerf,
        LastCounter,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibCounter,
        sizeof(DWORD));

    lStatus = RegSetValueEx(
        hDriverPerf,
        LastHelp,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibHelp,
        sizeof(DWORD));

    lStatus = RegSetValueEx(
        hDriverPerf,
        FirstCounter,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwFirstDriverCounter,
        sizeof(DWORD));

    lStatus = RegSetValueEx(
        hDriverPerf,
        FirstHelp,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwFirstDriverHelp,
        sizeof(DWORD));

    bStatus = TRUE;

    // free temporary buffers
UpdateRegExit:
    // clear busy flag

    if (hPerflib) {
        lStatus = RegDeleteValue (
            hPerflib,
            Busy);
    }
     
    // free temporary buffers

    if (lpDriverKeyPath) free (lpDriverKeyPath);
    if (hDriverPerf) CloseHandle (hDriverPerf);
    if (hPerflib) CloseHandle (hPerflib);

    return bStatus;
}

BOOL FAR PASCAL lodctr(DWORD argc,LPSTR argv[], LPSTR *ppszResult )
/*++

main



Arguments


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPTSTR  lpIniFile;
    LPTSTR  lpDriverName;

    LANGUAGE_LIST_ELEMENT   LangList;
    PSYMBOL_TABLE_ENTRY           SymbolTable = NULL;
    PSYMBOL_TABLE_ENTRY           pThisSymbol = NULL;

    BOOL fReturn = TRUE;

    lpIniFile    = malloc(MAX_PATH * sizeof(TCHAR));
    lpDriverName = malloc(MAX_PATH * sizeof(TCHAR));

    if ((lpIniFile == NULL) || (lpDriverName == NULL)) {
        if (lpIniFile) {
            free(lpIniFile);
        }
        if (lpDriverName) {
            free(lpDriverName);
        }
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    wsprintfA( achBuff, "{\"NO_ERROR\"}");

    if ( argc == 1) {
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, argv[0], -1, lpIniFile, MAX_PATH);

        if (!GetDriverName (lpIniFile, &lpDriverName)) {
            wsprintfA(achBuff,"{\"ERROR\"}");
            fReturn = FALSE;
            goto EndOfMain;
        }

        if (!BuildLanguageTables(lpIniFile, &LangList)) {
            wsprintfA (achBuff, "{\"ERROR\"}");
            fReturn = FALSE;
            goto EndOfMain;
        }

        if (!LoadIncludeFile(lpIniFile, &SymbolTable)) {
            // open errors displayed in routine
            fReturn = FALSE;
            goto EndOfMain;
        }

        if (!UpdateRegistry(lpIniFile,
            HKEY_LOCAL_MACHINE,
            lpDriverName,
            &LangList,
            SymbolTable)) {
            wsprintfA (achBuff, "{\"ERROR\"}");
            fReturn = FALSE;
        }

    } 

EndOfMain:
    if (lpIniFile) free (lpIniFile);    
    if (lpDriverName) free (lpDriverName);

    *ppszResult = achBuff;
    
    return (fReturn); // success
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\install\setupdll\nwcfg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*

        nwcfg.h

        history:
                thomaspa  1/24/94        Created
*/


#ifndef _NWCFG_H_
#define _NWCFG_H_

#define PROVIDER_NAME 101

#endif // _NWCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\install\setupdll\nwcfg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*

        nwcfg.cxx
                netware configuration source code.

        history:
                terryk  05/07/93        Created
*/


#if defined(DEBUG)
static const char szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define APIERR LONG

extern "C"
{

#include <windows.h>
#include <port1632.h>


#include <winspool.h>

// exported functions

BOOL FAR PASCAL AddNetwarePrinterProvidor( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL DeleteNetwarePrinterProvidor( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL AppendSzToFile( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL GetKernelVersion( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );

extern HINSTANCE ThisDLLHandle;
}

#define UNREFERENCED(x) ((void)(x))
#include <nwcfg.hxx>
#include <nwcfg.h>


/*******************************************************************

    NAME:       AddNetwarePrinterProvidor

    SYNOPSIS:   This is a wrapper routine for called AddPrintProvidor. It
                should be called from inf file if the user installs netware.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.

    HISTORY:
                terryk  07-May-1993     Created

********************************************************************/

#define PROVIDER_DLL_NAME   "nwprovau.dll"
#define MAX_PROVIDER_NAME_LEN 512
typedef BOOL (WINAPI *T_AddPrintProvidor)(LPSTR pName,DWORD Level,LPBYTE pMonitors);
typedef BOOL (WINAPI *T_DeletePrintProvidor)(LPSTR pName,LPSTR pEnv, LPSTR pMon);


BOOL FAR PASCAL AddNetwarePrinterProvidor( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    UNREFERENCED( nArgs );

    PROVIDOR_INFO_1 ProvidorInfo1;

    ProvidorInfo1.pEnvironment = (LPSTR) NULL;
    ProvidorInfo1.pDLLName = PROVIDER_DLL_NAME;

    APIERR err = 0;
    do {
        CHAR buf[MAX_PROVIDER_NAME_LEN];
        LPSTR lpProviderName = (LPSTR)buf;
        if ( lpProviderName == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        if ( !LoadString( ThisDLLHandle,
                          PROVIDER_NAME,
                          lpProviderName,
                          MAX_PROVIDER_NAME_LEN ) )
        {
            err = ::GetLastError();
            break;
        }

        ProvidorInfo1.pName = lpProviderName;



        HINSTANCE hDll = ::LoadLibraryA( "winspool.drv" );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pAddPrintProvidor = ::GetProcAddress( hDll, "AddPrintProvidorA" );

        if ( pAddPrintProvidor == NULL )
        {
            err = ::GetLastError();
        } else if ( !(*(T_AddPrintProvidor)pAddPrintProvidor)((LPSTR) NULL,1,(LPBYTE)&ProvidorInfo1))
        {
            err = ::GetLastError();
        }

        if ( hDll )
            ::FreeLibrary( hDll );

    } while (FALSE);
    wsprintfA( achBuff, "{\"%d\"}", err );
    *ppszResult = achBuff;

    return TRUE;
}

BOOL FAR PASCAL DeleteNetwarePrinterProvidor( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    UNREFERENCED( nArgs );
    UNREFERENCED( apszArgs );

    APIERR err = 0;

    do {
        HINSTANCE hDll = ::LoadLibraryA( "winspool.drv" );
        if ( hDll == NULL )
        {
            err = ::GetLastError();
            break;
        }

        FARPROC pDeletePrintProvidor = ::GetProcAddress( hDll, "DeletePrintProvidorA" );

        if ( pDeletePrintProvidor == NULL )
        {
            err = ::GetLastError();
        }
        else
        {
            CHAR buf[MAX_PROVIDER_NAME_LEN];
            LPSTR lpProviderName = (LPSTR)buf;
            if ( lpProviderName == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            if ( nArgs == 1 )
            {
                 lpProviderName = apszArgs[0];
            } else
            {
                if ( !LoadString( ThisDLLHandle,
                                  PROVIDER_NAME,
                                  lpProviderName,
                                  MAX_PROVIDER_NAME_LEN ) )
                {
                    err = ::GetLastError();
                }
            }
            if ( !(*(T_DeletePrintProvidor)pDeletePrintProvidor)( (LPSTR) NULL,
                                                                  (LPSTR) NULL,
                                                                  lpProviderName))
            {
                err = ::GetLastError();
            }
        }

        if ( hDll )
            ::FreeLibrary ( hDll );

    } while (FALSE);
    wsprintfA( achBuff, "{\"%d\"}", err );
    *ppszResult = achBuff;

    return TRUE;
}

/*******************************************************************

    NAME:       AppendSzToFile

    SYNOPSIS:   Append a string to a file.

    ENTRY:      Args[0] - FileName string
                Args[1] - String to be added to the file

    RETURN:     BOOL - TRUE for success.

    HISTORY:
                terryk  07-May-1993     Created

********************************************************************/

BOOL FAR PASCAL
AppendSzToFile( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    UNREFERENCED( nArgs );

    DWORD  BytesWritten;
    HANDLE hfile;
    LPSTR szFileName = apszArgs[0];
    LPSTR szAddOnSz = apszArgs[1];

    //
    // Open the file
    //

    hfile = CreateFile(
                szFileName,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ,
                (struct _SECURITY_ATTRIBUTES *) NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (hfile == INVALID_HANDLE_VALUE) {
        wsprintfA( achBuff, "{ Cannot Open File: \"%s\"}", szFileName );
        *ppszResult = achBuff;
        return FALSE;
    }

    //
    // Go to end of file
    //

    SetFilePointer (
        hfile,
        0,
        (PLONG) NULL,
        FILE_END
        );

    //
    // Append string passed in at the end of the file
    //

    WriteFile (
        hfile,
        szAddOnSz,
        lstrlen( szAddOnSz ),
        &BytesWritten,
        (struct _OVERLAPPED *) NULL
        );

    CloseHandle (hfile);
    wsprintfA( achBuff, "{\"%d\"}", 0 );
    *ppszResult = achBuff;
    return TRUE;
}

/*******************************************************************

    NAME:       GetKernelVersion

    SYNOPSIS:   Get the current kernel version number

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                The return number is the kernel build number.
                {"MajorVerion","MinorVersion","BuildNumber","PatchNumber"}

    HISTORY:
                terryk  24-Sept-1993     Created

********************************************************************/

BOOL FAR PASCAL
GetKernelVersion( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    UNREFERENCED( nArgs );

    DWORD wVer;
    LONG nSubVersion;
    LONG nVersion;

    LPCSTR  lpszRegName = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
    HKEY    hsubkey ;
    DWORD   dwZero = 0;
    DWORD   dwRegValueType;
    DWORD   dwRegValue;
    DWORD   cbRegValue;

    wVer = GetVersion();
    nSubVersion = GETMINORVERSION(wVer);
    nVersion = GETMAJORVERSION(wVer);

    cbRegValue = sizeof(dwRegValue);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            lpszRegName, dwZero, KEY_QUERY_VALUE, &hsubkey) ||
        RegQueryValueEx(hsubkey, "CSDVersion", (LPDWORD)NULL,
            &dwRegValueType, (LPBYTE)&dwRegValue, &cbRegValue) ||
        dwRegValueType != REG_DWORD
    ) {
        wsprintf(achBuff,"{\"%d\",\"%d\",\"%d\",\"%d\"}", nVersion, nSubVersion, wVer >> 16, 0);
    } else {
        wsprintf(achBuff,"{\"%d\",\"%d\",\"%d\",\"%d\"}", nVersion, nSubVersion, wVer >> 16, dwRegValue);
    }
    if (hsubkey != NULL) {
        RegCloseKey (hsubkey);
    }
    *ppszResult = achBuff;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\install\setupdll\removesz.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

RemoveSzFromFile() - remove a specified string from the file

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <nwcfg.hxx>


BOOL
RemoveSzFromFile( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    FILE * hsrcfile;
    FILE * hdesfile;
    char * pszTempname;
    char szInput[1000];

    pszTempname = tmpnam(NULL);
    wsprintf(achBuff,"{1}");
    *ppszResult = achBuff;
    if ( nArgs != 2 )
    {
        return(FALSE);
    }
    hsrcfile = fopen(apszArgs[0],"r");
    hdesfile = fopen(pszTempname,"w");
    if (( hsrcfile != NULL ) && ( hdesfile != NULL ))
    {
        while (fgets(szInput,1000,hsrcfile))
        {
            if (_stricmp(szInput,apszArgs[1])!=0)
            {
                fputs(szInput,hdesfile);
            }
        }
    }
    if ( hsrcfile != NULL )
        fclose(hsrcfile);
    if ( hdesfile != NULL )
        fclose(hdesfile);
    if (( hsrcfile != NULL ) && ( hdesfile != NULL ))
    {
        CopyFileA(pszTempname,apszArgs[0], FALSE);
        DeleteFileA(pszTempname);
    }

    wsprintf(achBuff,"{0}");
    *ppszResult = achBuff;
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\install\setupdll\unlodctr.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    unlodctr.c

Abstract:

    Program to remove the counter names belonging to the driver specified
        in the command line and update the registry accordingly

Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

--*/
#define     UNICODE     1
#define     _UNICODE    1
//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
//
//  Windows Include files
//
#include <windows.h>
#include <winperf.h>
#include <tchar.h>
//
//  local include files
//
//#define  _INITIALIZE_GLOBALS_   1   // to define & init global buffers
#include "common.h"
//#undef   _INITIALIZE_GLOBALS_
#include "nwcfg.hxx"

// version number for NT 1.0
#define OLD_VERSION  0x010000
DWORD   dwSystemVersion;    // PerfLib version number
DWORD   dwHelpItems;        // number of explain text items
DWORD   dwCounterItems;     // number of counter text items
DWORD   dwLastCounter;
DWORD   dwLastHelp;


LPTSTR
*BuildNameTable(
    IN HKEY    hKeyPerflib,     // handle to perflib key with counter names
    IN LPTSTR  lpszLangId,      // unicode value of Language subkey
    OUT PDWORD  pdwLastItem,     // size of array in elements
    OUT HKEY    *hKeyNames,
    OUT LPTSTR  CounterNameBuffer,  // New version counter name key   
    OUT LPTSTR  HelpNameBuffer     // New version help name key   
)
/*++

BuildNameTable

    Caches the counter names and explain text to accelerate name lookups
    for display.

Arguments:

    hKeyPerflib
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 009)

    pdwLastItem
            The last array element

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated TEXT strings.

    A NULL pointer is returned if an error occured. (error value is
    available using the GetLastError function).

    The structure of the buffer returned is:

        Array of pointers to zero terminated strings consisting of
            pdwLastItem elements

        MULTI_SZ string containing counter id's and names returned from
            registry for the specified language

        MULTI_SZ string containing explain text id's and explain text strings
            as returned by the registry for the specified language

    The structures listed above are contiguous so that they may be freed
    by a single "free" call when finished with them, however only the
    array elements are intended to be used.

--*/
{

    LPTSTR  *lpReturnValue;     // returned pointer to buffer

    LPTSTR  *lpCounterId;       //
    LPTSTR  lpCounterNames;     // pointer to Names buffer returned by reg.
    LPTSTR  lpHelpText ;        // pointet to exlpain buffer returned by reg.

    LPTSTR  lpThisName;         // working pointer


    BOOL    bStatus;            // return status from TRUE/FALSE fn. calls
    LONG    lWin32Status;       // return status from fn. calls

    DWORD   dwValueType;        // value type of buffer returned by reg.
    DWORD   dwArraySize;        // size of pointer array in bytes
    DWORD   dwBufferSize;       // size of total buffer in bytes
    DWORD   dwCounterSize;      // size of counter text buffer in bytes
    DWORD   dwHelpSize;         // size of help text buffer in bytes
    DWORD   dwThisCounter;      // working counter

    DWORD   dwLastId;           // largest ID value used by explain/counter text

    LPTSTR  lpValueNameString;  // pointer to buffer conatining subkey name

    //initialize pointers to NULL

    lpValueNameString = NULL;
    lpReturnValue = NULL;

    // check for null arguments and insert defaults if necessary

    if (!lpszLangId) {
        lpszLangId = DefaultLangId;
    }

    if (hKeyNames) {
        *hKeyNames = NULL;
    } else {
        SetLastError (ERROR_BAD_ARGUMENTS);
        return NULL;
    }

    // use the greater of Help items or Counter Items to size array

    if (dwHelpItems >= dwCounterItems) {
        dwLastId = dwHelpItems;
    } else {
        dwLastId = dwCounterItems;
    }

    // array size is # of elements (+ 1, since names are "1" based)
    // times the size of a pointer

    dwArraySize = (dwLastId + 1) * sizeof(LPTSTR);

    // allocate string buffer for language ID key string

    lpValueNameString = malloc (
        lstrlen(NamesKey) * sizeof (TCHAR) +
        lstrlen(Slash) * sizeof (TCHAR) +
        lstrlen(lpszLangId) * sizeof (TCHAR) +
        sizeof (TCHAR));

    if (!lpValueNameString) {
        lWin32Status = ERROR_OUTOFMEMORY;
        goto BNT_BAILOUT;
    }

    lWin32Status = RegOpenKeyEx (   // get handle to this key in the
        hKeyPerflib,               // registry
        lpszLangId,
        RESERVED,
        KEY_READ | KEY_WRITE,
        hKeyNames);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    // get size of counter names

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        Counters,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwCounterSize = dwBufferSize;

    // get size of help text

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        Help,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwHelpSize = dwBufferSize;

    // allocate buffer with room for pointer array, counter name
    // strings and help name strings

    lpReturnValue = malloc (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) {
        lWin32Status = ERROR_OUTOFMEMORY;
        goto BNT_BAILOUT;
    }

    // initialize buffer

    memset (lpReturnValue, 0, _msize(lpReturnValue));

    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPTSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPTSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counter names into buffer. Counter names will be stored as
    // a MULTI_SZ string in the format of "###" "Name"

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        Counters,
        RESERVED,
        &dwValueType,
        (LPVOID)lpCounterNames,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    // read explain text into buffer. Counter names will be stored as
    // a MULTI_SZ string in the format of "###" "Text..."

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        Help,
        RESERVED,
        &dwValueType,
        (LPVOID)lpHelpText,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    // load counter array items, by locating each text string
    // in the returned buffer and loading the
    // address of it in the corresponding pointer array element.

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal digit characters)
        // so translate to an integer for use in array element identification

        bStatus = StringToInt (lpThisName, &dwThisCounter);

        if (!bStatus) {
            // error is in GetLastError
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name which follows the id number
        // string.

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element with pointer to string

        lpCounterId[dwThisCounter] = lpThisName;

    }

    // repeat the above for the explain text strings

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        bStatus = StringToInt (lpThisName, &dwThisCounter);

        if (!bStatus) {
            // error is in GetLastError
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

    }

    // if the last item arugment was used, then load the last ID value in it

    if (pdwLastItem) *pdwLastItem = dwLastId;

    // free the temporary buffer used

    if (lpValueNameString) {
        free ((LPVOID)lpValueNameString);
    }

    // exit returning the pointer to the buffer

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        // if lWin32Status has error, then set last error value to it,
        // otherwise assume that last error already has value in it
        SetLastError (lWin32Status);
    }

    // free buffers used by this routine

    if (lpValueNameString) {
        free ((LPVOID)lpValueNameString);
    }

    if (lpReturnValue) {
        free ((LPVOID)lpReturnValue);
    }

    return NULL;
} // BuildNameTable


BOOL
GetDriverFromCommandLine (
    HKEY    hKeyMachine,
    LPTSTR  *lpDriverName,
    HKEY    *hDriverPerf,
    LPSTR argv[]
)
/*++

GetDriverFromCommandLine

    locates the first argument in the command line string (after the
    image name) and checks to see if

        a) it's there

        b) it's the name of a device driver listed in the
            Registry\Machine\System\CurrentControlSet\Services key
            in the registry and it has a "Performance" subkey

        c) that the "First Counter" value under the Performance subkey
            is defined.

    if all these criteria are true, then the routine returns TRUE and
    passes the pointer to the driver name back in the argument. If any
    one of them fail, then NULL is returned in the DriverName arg and
    the routine returns FALSE

Arguments

    lpDriverName

        the address of a LPTSTR to recive the pointer to the driver name

    hDriverPerf

        the key to the driver's performance subkey

Return Value

    TRUE if a valid driver was found in the command line

    FALSE if not (see above)

--*/
{
    LPTSTR  lpDriverKey;    // buffer to build driver key name in
    LPTSTR  lpThisChar;

    LONG    lStatus;
    DWORD   dwFirstCounter;
    DWORD   dwSize;
    DWORD   dwType;

    if (!lpDriverName || !hDriverPerf) {
        SetLastError (ERROR_BAD_ARGUMENTS);
        return FALSE;
    }

    *lpDriverName = NULL;   // initialize to NULL
    *hDriverPerf = NULL;

    lpThisChar = malloc( MAX_PATH * sizeof(TCHAR));
    if (lpThisChar == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }
    *lpThisChar = 0;

    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, argv[0], -1, lpThisChar, MAX_PATH);

    if (*lpThisChar) {
        // an argument was found so see if it's a driver
        lpDriverKey = malloc (MAX_PATH * sizeof (TCHAR));
        if (!lpDriverKey) {
            SetLastError (ERROR_OUTOFMEMORY);
            if ( lpThisChar ) free (lpThisChar);
            return FALSE;
        }

        lstrcpy (lpDriverKey, DriverPathRoot);
        lstrcat (lpDriverKey, Slash);
        lstrcat (lpDriverKey, lpThisChar);
        lstrcat (lpDriverKey, Slash);
        lstrcat (lpDriverKey, Performance);

        lStatus = RegOpenKeyEx (
            hKeyMachine,
            lpDriverKey,
            RESERVED,
            KEY_READ | KEY_WRITE,
            hDriverPerf);

        if (lStatus == ERROR_SUCCESS) {
            //
            //  this driver has a performance section so see if its
            //  counters are installed by checking the First Counter
            //  value key for a valid return. If it returns a value
            //  then chances are, it has some counters installed, if
            //  not, then display a message and quit.
            //
            free (lpDriverKey); // don't need this any more

            dwType = 0;
            dwSize = sizeof (dwFirstCounter);

            lStatus = RegQueryValueEx (
                *hDriverPerf,
                FirstCounter,
                RESERVED,
                &dwType,
                (LPBYTE)&dwFirstCounter,
                &dwSize);

            if (lStatus == ERROR_SUCCESS) {
                // counter names are installed so return success
                *lpDriverName = lpThisChar;
                SetLastError (ERROR_SUCCESS);
                if ( lpThisChar ) free (lpThisChar);
                return TRUE;
            } else {
                SetLastError (ERROR_BADKEY);
                if ( lpThisChar ) free (lpThisChar);
                return FALSE;
            }
        } else { // key not found
            SetLastError (lStatus);
            free (lpDriverKey);
            if ( lpThisChar ) free (lpThisChar);
            return FALSE;
        }
    } else {
        SetLastError (ERROR_INVALID_PARAMETER);
        if ( lpThisChar ) free (lpThisChar);
        return FALSE;
    }
}


LONG
FixNames (
    HANDLE  hKeyLang,
    LPTSTR  *lpOldNameTable,
    IN LPTSTR  lpszLangId,      // unicode value of Language subkey
    DWORD   dwLastItem,
    DWORD   dwFirstNameToRemove,
    DWORD   dwLastNameToRemove
   )
{
    LONG    lStatus;
    LPTSTR  lpNameBuffer = NULL;
    LPTSTR  lpHelpBuffer = NULL;
    DWORD   dwTextIndex, dwSize;
    LPTSTR  lpNextHelpText;
    LPTSTR  lpNextNameText;

    // allocate space for the array of new text it will point
    // into the text buffer returned in the lpOldNameTable buffer)

    lpNameBuffer = malloc (_msize(lpOldNameTable));
    lpHelpBuffer = malloc (_msize(lpOldNameTable));

    if (!lpNameBuffer || !lpHelpBuffer) {
        if (lpNameBuffer) {
            free(lpNameBuffer);
        }
        if (lpHelpBuffer) {
            free(lpHelpBuffer);
        }
        lStatus = ERROR_OUTOFMEMORY;
        return lStatus;
    }

    // remove this driver's counters from array

    for (dwTextIndex = dwFirstNameToRemove;
         dwTextIndex <= dwLastNameToRemove;
         dwTextIndex++) {

        if (dwTextIndex > dwLastItem)
           break;

        lpOldNameTable[dwTextIndex] = NULL;
    }

    lpNextHelpText = lpHelpBuffer;
    lpNextNameText = lpNameBuffer;

    // build new Multi_SZ strings from New Table

    for (dwTextIndex = 0; dwTextIndex <= dwLastItem; dwTextIndex++){
        if (lpOldNameTable[dwTextIndex]) {
            // if there's a text string at that index, then ...
            if (dwTextIndex & 0x1) {    // ODD number == Help Text
                lpNextHelpText +=
                    _stprintf (lpNextHelpText, TEXT("%d"), dwTextIndex) + 1;
                lpNextHelpText +=
                    _stprintf (lpNextHelpText, TEXT("%s"),
                    lpOldNameTable[dwTextIndex]) + 1;
                if (dwTextIndex > dwLastHelp){
                    dwLastHelp = dwTextIndex;
                }
            } else { // EVEN number == counter name text
                lpNextNameText +=
                    _stprintf (lpNextNameText, TEXT("%d"), dwTextIndex) + 1;
                lpNextNameText +=
                    _stprintf (lpNextNameText, TEXT("%s"),
                lpOldNameTable[dwTextIndex]) + 1;
                if (dwTextIndex > dwLastCounter){
                    dwLastCounter = dwTextIndex;
                }
            }
        }
    } // for dwTextIndex

    // add MULTI_SZ terminating NULL
    *lpNextNameText++ = TEXT ('\0');
    *lpNextHelpText++ = TEXT ('\0');

    // update counter name text buffer

    dwSize = (DWORD)((LPBYTE)lpNextNameText - (LPBYTE)lpNameBuffer);
        lStatus = RegSetValueEx (
            hKeyLang,
            Counters,
            RESERVED,
            REG_MULTI_SZ,
            (LPBYTE)lpNameBuffer,
            dwSize);

    if (lStatus != ERROR_SUCCESS) {
//        printf (GetFormatResource(UC_UNABLELOADLANG),
//                Counters, lpLangName, lStatus);
        goto UCN_FinishLang;
    }

    dwSize = (DWORD)((LPBYTE)lpNextHelpText - (LPBYTE)lpHelpBuffer);
    lStatus = RegSetValueEx (
        hKeyLang,
        Help,
        RESERVED,
        REG_MULTI_SZ,
        (LPBYTE)lpHelpBuffer,
        dwSize);

    if (lStatus != ERROR_SUCCESS) {
//        printf (GetFormatResource(UC_UNABLELOADLANG),
//                Help, lpLangName, lStatus);
        goto UCN_FinishLang;
    }


UCN_FinishLang:

    free (lpNameBuffer);
    free (lpHelpBuffer);
    free (lpOldNameTable);

    RegCloseKey (hKeyLang);

    return lStatus;
}

LONG
UnloadCounterNames (
    HKEY    hKeyMachine,
    HKEY    hDriverPerf,
    LPTSTR  lpDriverName
)
/*++

UnloadCounterNames

    removes the names and explain text for the driver referenced by
    hDriverPerf and updates the first and last counter values accordingly

    update process:

        - set "updating" flag under Perflib to name of driver being modified
        - FOR each language under perflib key
            -- load current counter names and explain text into array of
                pointers
            -- look at all drivers and copy their names and text into a new
                buffer adjusting for the removed counter's entries keeping
                track of the lowest entry copied.  (the names for the driver
                to be removed will not be copied, of course)
            -- update each driver's "first" and "last" index values
            -- copy all other entries from 0 to the lowest copied (i.e. the
                system counters)
            -- build a new MULIT_SZ string of help text and counter names
            -- load new strings into registry
        - update perflibl "last" counters
        - delete updating flag

     ******************************************************
     *                                                    *
     *  NOTE: FUNDAMENTAL ASSUMPTION.....                 *
     *                                                    *
     *  this routine assumes that:                        *
     *                                                    *
     *      ALL COUNTER NAMES are even numbered and       *
     *      ALL HELP TEXT STRINGS are odd numbered        *
     *                                                    *
     ******************************************************

Arguments

    hKeyMachine

        handle to HKEY_LOCAL_MACHINE node of registry on system to
        remove counters from

    hDrivefPerf
        handle to registry key of driver to be de-installed

    lpDriverName
        name of driver being de-installed

Return Value

    DOS Error code.

        ERROR_SUCCESS if all went OK
        error value if not.

--*/
{

    HKEY    hPerflib;
    HKEY    hServices;
    HKEY    hKeyLang;

    LONG    lStatus;

    DWORD   dwLangIndex;
    //
    //  dfergus 19 Apr 2001 - 295153
    //  Init dwSize
    //
    DWORD   dwSize = 0;
    DWORD   dwType;
    DWORD   dwLastItem;


    DWORD   dwRemLastDriverCounter;
    DWORD   dwRemFirstDriverCounter;
    DWORD   dwRemLastDriverHelp;
    DWORD   dwRemFirstDriverHelp;

    DWORD   dwFirstNameToRemove;
    DWORD   dwLastNameToRemove;

    LPTSTR  *lpOldNameTable;

    LPTSTR  lpLangName = NULL;
    LPTSTR  lpThisDriver = NULL;

    BOOL    bPerflibUpdated = FALSE;
    BOOL    bDriversShuffled = FALSE;

    DWORD   dwBufferSize;       // size of total buffer in bytes

    TCHAR   CounterNameBuffer [40];
    TCHAR   HelpNameBuffer [40];

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        DriverPathRoot,
        RESERVED,
        KEY_READ | KEY_WRITE,
        &hServices);

    if (lStatus != ERROR_SUCCESS) {
        return lStatus;
    }

    // open registry handle to perflib key

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        NamesKey,
        RESERVED,
        KEY_READ | KEY_WRITE,
        &hPerflib);

    if (lStatus != ERROR_SUCCESS) {
        return lStatus;
    }

    // check & set Busy flag...

    lStatus = RegQueryValueEx (
        hPerflib,
        Busy,
        RESERVED,
        &dwType,
        NULL,
        &dwSize);

    if (lStatus == ERROR_SUCCESS) { // perflib is in use at the moment
        return ERROR_BUSY;
    }


    lStatus = RegSetValueEx (
        hPerflib,
        Busy,
        RESERVED,
        REG_SZ,
        (LPBYTE)lpDriverName,
        lstrlen(lpDriverName) * sizeof(TCHAR));

    if (lStatus != ERROR_SUCCESS) {
        RegCloseKey (hPerflib);
        return lStatus;
    }

    // query registry to get number of Explain text items

    dwBufferSize = sizeof (dwHelpItems);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwHelpItems,
        &dwBufferSize);

    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        RegCloseKey (hPerflib);
        return lStatus;
    }

    // query registry to get number of counter and object name items

    dwBufferSize = sizeof (dwCounterItems);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwCounterItems,
        &dwBufferSize);

    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        RegCloseKey (hPerflib);
        return lStatus;
    }

    // query registry to get PerfLib system version

    dwBufferSize = sizeof (dwSystemVersion);
    lStatus = RegQueryValueEx (
        hPerflib,
        VersionStr,
        RESERVED,
        &dwType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        // Key not there, must be NT 1.0 version
        dwSystemVersion = OLD_VERSION;
    }

    if ( dwSystemVersion != OLD_VERSION )
    {
        // ERROR. The caller should check the version before calling me.
        // let return busy for now... 
        return(ERROR_BUSY);
    }


    // allocate temporary String buffer

    lpLangName = malloc (MAX_PATH * sizeof(TCHAR));
    lpThisDriver = malloc (MAX_PATH * sizeof(TCHAR));

    if (!lpLangName || !lpThisDriver) {
        lStatus = ERROR_OUTOFMEMORY;
        goto UCN_ExitPoint;
    }

    // Get the values that are in use by the driver to be removed

    dwSize = sizeof (dwRemLastDriverCounter);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemLastDriverCounter,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemFirstDriverCounter);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        FirstCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemFirstDriverCounter,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemLastDriverHelp);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        LastHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemLastDriverHelp,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemFirstDriverHelp);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        FirstHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemFirstDriverHelp,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        goto UCN_ExitPoint;
    }

    //  get the first and last counters to define block of names used
    //  by this device

    dwFirstNameToRemove = (dwRemFirstDriverCounter <= dwRemFirstDriverHelp ?
        dwRemFirstDriverCounter : dwRemFirstDriverHelp);

    dwLastNameToRemove = (dwRemLastDriverCounter >= dwRemLastDriverHelp ?
        dwRemLastDriverCounter : dwRemLastDriverHelp);

    dwLastCounter = dwLastHelp = 0;

    // do each language under perflib
    for (dwLangIndex = 0, dwSize = _msize(lpLangName);
         (RegEnumKey(hPerflib, dwLangIndex, lpLangName, dwSize)) == ERROR_SUCCESS;
        dwLangIndex++, dwSize = _msize(lpLangName)) {

        lpOldNameTable = BuildNameTable (hPerflib, lpLangName,
            &dwLastItem, &hKeyLang, CounterNameBuffer, HelpNameBuffer);

        if (lpOldNameTable) {
            if (!FixNames (
                hKeyLang,
                lpOldNameTable,
                lpLangName,
                dwLastItem,
                dwFirstNameToRemove,
                dwLastNameToRemove)) {
                bPerflibUpdated = TRUE;
            }
        } else { // unable to unload names for this language
            // display error message
        }
    } // end for (more languages)

    if (bPerflibUpdated) {
        // update perflib's "last" values

        dwSize = sizeof (dwLastCounter);
        lStatus = RegSetValueEx (
            hPerflib,
            LastCounter,
            RESERVED,
            REG_DWORD,
            (LPBYTE)&dwLastCounter,
            dwSize);

        dwSize = sizeof (dwLastHelp);
        lStatus = RegSetValueEx (
            hPerflib,
            LastHelp,
            RESERVED,
            REG_DWORD,
            (LPBYTE)&dwLastHelp,
            dwSize);

        // update "driver"s values (i.e. remove them)

        RegDeleteValue (hDriverPerf, FirstCounter);
        RegDeleteValue (hDriverPerf, LastCounter);
        RegDeleteValue (hDriverPerf, FirstHelp);
        RegDeleteValue (hDriverPerf, LastHelp);

    }

UCN_ExitPoint:
    RegDeleteValue (hPerflib, Busy);
    RegCloseKey (hPerflib);
    RegCloseKey (hServices);
    if (lpLangName) free (lpLangName);
    if (lpThisDriver) free (lpThisDriver);

    return lStatus;


}

BOOL FAR PASCAL unlodctr(DWORD argc,LPSTR argv[], LPSTR *ppszResult )
/*++

main

    entry point to Counter Name Unloader



Arguments

    argc
        # of command line arguments present

    argv
        array of pointers to command line strings

    (note that these are obtained from the GetCommandLine function in
    order to work with both UNICODE and ANSI strings.)

ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPTSTR  lpDriverName;   // name of driver to delete from perflib
    HKEY    hDriverPerf;    // handle to performance sub-key of driver


    DWORD   dwStatus;       // return status of fn. calls

    *ppszResult = achBuff;

    wsprintfA( achBuff, "{\"NO_ERROR\"}");

    if (!GetDriverFromCommandLine (
        HKEY_LOCAL_MACHINE, &lpDriverName, &hDriverPerf, argv)) {
        // error message was printed in routine if there was an error
        wsprintfA( achBuff,"{\"ERROR\"}");
        return (FALSE);
    }

    // removes names and explain text for driver in lpDriverName
    // displays error messages for errors encountered

    dwStatus = (DWORD)UnloadCounterNames (HKEY_LOCAL_MACHINE,
        hDriverPerf, lpDriverName);

    RegCloseKey (hDriverPerf);

    if ( dwStatus != ERROR_SUCCESS )
    {
        wsprintfA( achBuff,"{\"ERROR\"}");
    }

    return (dwStatus==ERROR_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\install\setupdll\common.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

common.h

    constants and globals that are common to LODCTR and UNLODCTR

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

--*/
#ifndef _LODCTR_COMMON_H_
#define _LODCTR_COMMON_H_
//
//  Local constants
//
#define RESERVED                0L
#define LARGE_BUFFER_SIZE       0x10000         // 64K
#define MEDIUM_BUFFER_SIZE      0x8000          // 32K
#define SMALL_BUFFER_SIZE       0x1000          //  4K
#define FILE_NAME_BUFFER_SIZE   MAX_PATH
#define DISP_BUFF_SIZE          256L
#define SIZE_OF_OFFSET_STRING   15
//
//  Data structure and type definitions
//
typedef struct _NAME_ENTRY {
    struct _NAME_ENTRY  *pNext;
    DWORD               dwOffset;
    DWORD               dwType;
    LPTSTR              lpText;
} NAME_ENTRY, *PNAME_ENTRY;

typedef struct _LANGUAGE_LIST_ELEMENT {
    struct _LANGUAGE_LIST_ELEMENT   *pNextLang;     // next lang. list
    LPTSTR  LangId;                                 // lang ID string for this elem
    PNAME_ENTRY pFirstName;                         // head of name list
    PNAME_ENTRY pThisName;                          // pointer to current entry
    DWORD   dwNumElements;                          // number of elements in array
    DWORD   dwNameBuffSize;
    DWORD   dwHelpBuffSize;
    PBYTE   NameBuffer;                             // buffer to store strings
    PBYTE   HelpBuffer;                             // buffer to store help strings
} LANGUAGE_LIST_ELEMENT, *PLANGUAGE_LIST_ELEMENT;

typedef struct _SYMBOL_TABLE_ENTRY {
    struct _SYMBOL_TABLE_ENTRY    *pNext;
    LPTSTR  SymbolName;
    DWORD   Value;
} SYMBOL_TABLE_ENTRY, *PSYMBOL_TABLE_ENTRY;
//
//  Utility Routine prototypes for routines in common.c
//
#define StringToInt(in,out) \
    (((_stscanf ((in), TEXT(" %d"), (out))) == 1) ? TRUE : FALSE)


#if _INITIALIZE_GLOBALS_
//
//
//  Text string Constant definitions
//
const LPTSTR NamesKey = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
const LPTSTR DefaultLangId = TEXT("009");
const LPTSTR Counters = TEXT("Counters");
const LPTSTR Help = TEXT("Help");
const LPTSTR VersionStr = TEXT("Version");
const LPTSTR LastHelp = TEXT("Last Help");
const LPTSTR LastCounter = TEXT("Last Counter");
const LPTSTR FirstHelp = TEXT("First Help");
const LPTSTR FirstCounter = TEXT("First Counter");
const LPTSTR Busy = TEXT("Updating");
const LPTSTR Slash = TEXT("\\");
const LPTSTR BlankString = TEXT(" ");
const LPSTR  BlankAnsiString = " ";
const LPTSTR DriverPathRoot = TEXT("SYSTEM\\CurrentControlSet\\Services");
const LPTSTR Performance = TEXT("Performance");
const LPTSTR CounterNameStr = TEXT("Counter ");
const LPTSTR HelpNameStr = TEXT("Explain ");
const LPTSTR AddCounterNameStr = TEXT("Addcounter ");
const LPTSTR AddHelpNameStr = TEXT("Addexplain ");

//
//  Global Buffers
//
TCHAR   DisplayStringBuffer[DISP_BUFF_SIZE];
CHAR    TextFormat[DISP_BUFF_SIZE];
HANDLE  hMod = NULL;    // process handle
DWORD   dwLastError = ERROR_SUCCESS;

#else   // just declare the globals

extern const LPTSTR NamesKey;
extern const LPTSTR VersionStr;
extern const LPTSTR DefaultLangId;
extern const LPTSTR Counters;
extern const LPTSTR Help;
extern const LPTSTR LastHelp;
extern const LPTSTR LastCounter;
extern const LPTSTR FirstHelp;
extern const LPTSTR FirstCounter;
extern const LPTSTR Busy;
extern const LPTSTR Slash;
extern const LPTSTR BlankString;
extern const LPSTR  BlankAnsiString;
extern const LPTSTR DriverPathRoot;
extern const LPTSTR Performance;
//
//  Global Buffers
//
extern TCHAR   DisplayStringBuffer[DISP_BUFF_SIZE];
extern CHAR    TextFormat[DISP_BUFF_SIZE];
extern HANDLE  hMod;
extern DWORD   dwLastError;

#endif // _INITIALIZE_GLOBALS_

#endif  // _LODCTR_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\install\setupdll\setvalue.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*

        setvalue.c
                Code to enable SetValue for everyone.

        history:
                terryk  09/30/93        Created
*/


#if defined(DEBUG)
static const char szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <string.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <nwlsa.h>
#include <nwapi.h>
#include <nwcfg.h>
#include <nwcfg.hxx>

extern char achBuff[];

// exported functions

BOOL FAR PASCAL SetFileSysChangeValue( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL SetEverybodyPermission( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL SetupRegistryForNWCS( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL SetupRegistryWorker( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL DeleteGatewayPassword( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );
BOOL FAR PASCAL CleanupRegistryForNWCS( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult );

//
// structure for registry munging
//

typedef struct REG_ENTRY_ {
    DWORD         Operation ;
    LONG          Level ;
    LPWSTR        s1 ;
    LPWSTR        s2 ;
} REG_ENTRY ;

//
// local routines
//
    
DWORD SetupShellExtensions(REG_ENTRY RegEntries[], DWORD dwNumEntries) ;

typedef DWORD (*LPNWCLEANUPGATEWAYSHARES)(VOID) ;

// Values & Tables that define registry data

#define MAX_REG_LEVEL       10

#define CREATE_ABS          1         // create/open a key with absolute path
#define CREATE_REL          2         // create/open a key with relative path
#define VALUE_STR           3         // write a string value
#define DELETE_ABS          4         // delete key with absolute path
#define DELETE_REL          5         // delete key with relative path
#define DELETE_VAL          6         // delete a value
#define DROP_STACK          7         // drop stack by one 

REG_ENTRY RegCreateEntries[] =
{
    {CREATE_ABS,0,L"SOFTWARE\\Classes\\NetWare_or_Compatible_Network", NULL},
    {DELETE_REL,0,L"shellex\\ContextMenuHandlers\\NetWareMenus", NULL},
    {DELETE_REL,0,L"shellex\\ContextMenuHandlers", NULL},
    {DELETE_REL,0,L"shellex\\PropertySheetHandlers\\NetWarePage", NULL},
    {DELETE_REL,0,L"shellex\\PropertySheetHandlers", NULL},
    {DELETE_REL,0,L"shellex", NULL},
    {DROP_STACK,0,NULL,NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\NetWare_or_Compatible_Network", NULL},

    {CREATE_ABS, 0,L"SOFTWARE\\Classes\\Network\\Type", NULL},
    {CREATE_REL,+1,    L"3", NULL},
    {CREATE_REL,+1,        L"shellex", NULL},
    {CREATE_REL,+1,            L"ContextMenuHandlers", NULL},
    {CREATE_REL,+1,                L"NetWareMenus", NULL},
    {VALUE_STR,0,                      L"", L"{8e9d6600-f84a-11ce-8daa-00aa004a5691}"},
    {CREATE_REL,-1,            L"PropertySheetHandlers", NULL},
    {CREATE_REL,+1,                L"NetWarePage", NULL},
    {VALUE_STR,0,                      L"", L"{8e9d6600-f84a-11ce-8daa-00aa004a5691}"},
    {CREATE_ABS, 0,L"SOFTWARE\\Classes\\CLSID", NULL},
    {CREATE_REL,+1,        L"{8e9d6600-f84a-11ce-8daa-00aa004a5691}", NULL},
    {VALUE_STR,0,              L"", L"NetWare Objects"},
    {CREATE_REL,+1,            L"InProcServer32", NULL},
    {VALUE_STR,0,                  L"", L"nwprovau.dll"},
    {VALUE_STR,0,                  L"ThreadingModel", L"Apartment"},
    {CREATE_REL,-1,        L"{e3f2bac0-099f-11cf-8daa-00aa004a5691}", NULL},
    {VALUE_STR,0,              L"", L"NetWare UNC Folder Menu"},
    {CREATE_REL,+1,            L"InProcServer32", NULL},
    {VALUE_STR,0,                  L"", L"nwprovau.dll"},
    {VALUE_STR,0,                  L"ThreadingModel", L"Apartment"},
    {CREATE_REL,-1,        L"{52c68510-09a0-11cf-8daa-00aa004a5691}", NULL},
    {VALUE_STR,0,              L"", L"NetWare Hood Verbs"},
    {CREATE_REL,+1,            L"InProcServer32", NULL},
    {VALUE_STR,0,                  L"", L"nwprovau.dll"},
    {VALUE_STR,0,                  L"ThreadingModel", L"Apartment"},
    {CREATE_REL,-1,        L"{208D2C60-3AEA-1069-A2D7-08002B30309D}", NULL},
    {CREATE_REL,+1,            L"shellex", NULL},
    {CREATE_REL,+1,                L"ContextMenuHandlers", NULL},
    {CREATE_REL,+1,                    L"NetWareMenus", NULL},
    {VALUE_STR,0,                      L"", L"{52c68510-09a0-11cf-8daa-00aa004a5691}"},
    {CREATE_ABS, 0,L"SOFTWARE\\Classes\\Folder", NULL},
    {CREATE_REL,+1,        L"shellex", NULL},
    {CREATE_REL,+1,            L"ContextMenuHandlers", NULL},
    {CREATE_REL,+1,            L"NetWareUNCMenu", NULL},
    {VALUE_STR,0,                  L"", L"{e3f2bac0-099f-11cf-8daa-00aa004a5691}"},
    {CREATE_ABS, 0,L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion", NULL},
    {CREATE_REL,+1,    L"Shell Extensions", NULL},
    {CREATE_REL,+1,        L"Approved", NULL},
    {VALUE_STR,0,              L"{8e9d6600-f84a-11ce-8daa-00aa004a5691}", L"Shell extensions for NetWare"},
    {VALUE_STR,0,              L"{e3f2bac0-099f-11cf-8daa-00aa004a5691}", L"Shell extensions for NetWare"},
    {VALUE_STR,0,              L"{52c68510-09a0-11cf-8daa-00aa004a5691}", L"Shell extensions for NetWare"}
} ;

REG_ENTRY RegDeleteEntries[] =
{
    {CREATE_ABS,0,L"SOFTWARE\\Classes\\Network\\Type\\3", NULL},
    {DELETE_REL,0,L"shellex\\ContextMenuHandlers\\NetWareMenus", NULL},
    {DELETE_REL,0,L"shellex\\ContextMenuHandlers", NULL},
    {DELETE_REL,0,L"shellex\\PropertySheetHandlers\\NetWarePage", NULL},
    {DELETE_REL,0,L"shellex\\PropertySheetHandlers", NULL},
    {DELETE_REL,0,L"shellex", NULL},
    {DROP_STACK,0,NULL,NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\Network\\Type\\3", NULL},

    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{8e9d6600-f84a-11ce-8daa-00aa004a5691}\\InProcServer32", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{8e9d6600-f84a-11ce-8daa-00aa004a5691}", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{e3f2bac0-099f-11cf-8daa-00aa004a5691}\\InProcServer32", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{e3f2bac0-099f-11cf-8daa-00aa004a5691}", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{52c68510-09a0-11cf-8daa-00aa004a5691}\\InProcServer32", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{52c68510-09a0-11cf-8daa-00aa004a5691}", NULL},
    {DELETE_ABS,0,L"SOFTWARE\\Classes\\CLSID\\{208D2C60-3AEA-1069-A2D7-08002B30309D}\\shellex\\ContextMenuHandlers\\NetWareMenus", NULL},

    {DELETE_ABS,0,L"SOFTWARE\\Classes\\Folder\\shellex\\ContextMenuHandlers\\NetWareUNCMenu", NULL},
    {CREATE_ABS,0,L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", NULL},
    {DELETE_VAL,0,L"{8e9d6600-f84a-11ce-8daa-00aa004a5691}", NULL},
    {DELETE_VAL,0,L"{e3f2bac0-099f-11cf-8daa-00aa004a5691}", NULL},
    {DELETE_VAL,0,L"{52c68510-09a0-11cf-8daa-00aa004a5691}", NULL}
} ;


/*******************************************************************

    NAME:       SetEverybodyPermission

    SYNOPSIS:   Set the registry key to everybody "Set Value" (or whatever
                the caller want.) This is called from the inf file

    ENTRY:      Registry key as the first parameter
                Permisstion type as the second parameter

    RETURN:     BOOL - TRUE for success.

    HISTORY:
                terryk  07-May-1993     Created

********************************************************************/

typedef DWORD (*T_SetPermission)(HKEY hKey, DWORD dwPermission);

BOOL FAR PASCAL SetEverybodyPermission( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    HKEY hKey = (HKEY)atol( &(apszArgs[0][1]) );    // registry key
    DWORD dwPermission = atol( apszArgs[1] );       // permission value
    DWORD err = ERROR_SUCCESS;

    do  {
        HINSTANCE hDll = LoadLibraryA( "nwapi32.dll" );
        FARPROC pSetPermission = NULL;

        if ( hDll == NULL )
        {
            err = GetLastError();
            break;
        }

        pSetPermission = GetProcAddress( hDll, "NwLibSetEverybodyPermission" );

        if ( pSetPermission == NULL )
        {
            err = GetLastError();
            break;
        }
        err = (*(T_SetPermission)pSetPermission)( hKey, dwPermission );
    } while ( FALSE );

    wsprintfA( achBuff, "{\"%d\"}", err );
    *ppszResult = achBuff;

    return( err == ERROR_SUCCESS );
}

/*******************************************************************

    NAME:       SetFileSysChangeValue

    SYNOPSIS:   calls common setup routine. this old entry point is
                is left here to handle any DLL/INF mismatch.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                       (always return TRUE)

    HISTORY:
                chuckc  29-Oct-1993     Created

********************************************************************/

BOOL FAR PASCAL SetFileSysChangeValue( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    return SetupRegistryWorker( nArgs, apszArgs, ppszResult );
}

/*******************************************************************

    NAME:       SetupRegistryForNWCS

    SYNOPSIS:   calls common worker routine to setup registry.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                       (always return TRUE)

    HISTORY:
                chuckc  29-Oct-1993     Created

********************************************************************/

BOOL FAR PASCAL SetupRegistryForNWCS( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    return SetupRegistryWorker( nArgs, apszArgs, ppszResult );
}

/*******************************************************************

    NAME:       SetupRegistryWorker

    SYNOPSIS:   set the FileSysChangeValue to please NETWARE.DRV.
                also set win.ini parameter so wfwnet.drv knows we are there.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                       (always return TRUE)

    HISTORY:
                chuckc  29-Oct-1993     Created

********************************************************************/

BOOL FAR PASCAL SetupRegistryWorker( DWORD nArgs, LPSTR apszArgs[], LPSTR * ppszResult )
{
    DWORD err = 0, err1 = 0 ;

    (void) nArgs ;         // quiet the compiler
    (void) apszArgs ;      // quiet the compiler

    if (!WriteProfileStringA("NWCS",
                             "NwcsInstalled",
                             "1"))
    {
        err = GetLastError() ;
    }

    if (!WritePrivateProfileStringA("386Enh",
                                    "FileSysChange",
                                    "off",
                                    "system.ini"))
    {
        err1 = GetLastError() ;
    }

    if (err1 == NO_ERROR)
    {
        err1 = SetupShellExtensions(
                   RegCreateEntries, 
                   sizeof(RegCreateEntries)/sizeof(RegCreateEntries[0])) ;
    }

    wsprintfA( achBuff, "{\"%d\"}", err ? err : err1 );
    *ppszResult = achBuff;

    return TRUE;
}

#define NWCLEANUPGATEWAYSHARES_NAME        "NwCleanupGatewayShares"
#define NWPROVAU_DLL_NAME                 L"NWPROVAU"

/*******************************************************************

    NAME:       DeleteGatewayPassword

    SYNOPSIS:   delete the LSA secret used for gateway password.
                also clears the NWCS installed bit. INF will be
                changed to call CleanupRegistryForNWCS, but this entry
                point is left here to handle DLL/INF mismatch.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                       (always return TRUE)

    HISTORY:
                chuckc  29-Oct-1993     Created

********************************************************************/

BOOL FAR PASCAL 
DeleteGatewayPassword( 
    DWORD nArgs, 
    LPSTR apszArgs[], 
    LPSTR * ppszResult 
    )
{
    return TRUE ;    // work is done in cleanup below which does everything.
}

/*******************************************************************

    NAME:       CleanupRegistryForNWCS

    SYNOPSIS:   delete the LSA secret used for gateway password.
                also set flag that NWCS has been removed. this flag
                is used by wfwnet.drv.

    ENTRY:      NONE from inf file.

    RETURN:     BOOL - TRUE for success.
                       (always return TRUE)

    HISTORY:
                chuckc  29-Oct-1993     Created

********************************************************************/

BOOL FAR PASCAL 
CleanupRegistryForNWCS( 
    DWORD nArgs, 
    LPSTR apszArgs[], 
    LPSTR * ppszResult 
    )
{
    HANDLE hDll ;
    DWORD err = 0, err1 = 0 ;
    LPNWCLEANUPGATEWAYSHARES lpfnNwCleanupGatewayShares = NULL ;

    (void) nArgs ;         // quiet the compiler
    (void) apszArgs ;      // quiet the compiler

    if (!WriteProfileStringA("NWCS",
                             "NwcsInstalled",
                             "0"))
    {
        err = GetLastError() ;
    }

    err1 = NwDeletePassword(GATEWAY_USER) ;

    if (!err)
        err = err1 ;

    if ((hDll = LoadLibraryW(NWPROVAU_DLL_NAME)) && 
        (lpfnNwCleanupGatewayShares = (LPNWCLEANUPGATEWAYSHARES) 
            GetProcAddress(hDll, NWCLEANUPGATEWAYSHARES_NAME)))
    {
        err1 = (*lpfnNwCleanupGatewayShares)() ;
        (void) FreeLibrary(hDll) ;
    }

    //
    // ignore errors for this. 
    //
    (void) SetupShellExtensions(
                   RegDeleteEntries, 
                   sizeof(RegDeleteEntries)/sizeof(RegDeleteEntries[0])) ;

    if (!err)
        err = err1 ;

    wsprintfA( achBuff, "{\"%d\"}", err );
    *ppszResult = achBuff;

    return TRUE;
}

/*******************************************************************

    NAME:       SetupShellExtensions

    SYNOPSIS:   setup the registry for shell extensions. function is driven 
                by a table of entries (RegEntries). for each entry there is a
                Operation code that tells us what we are doing. key entries can
                be created absolute or relative to previous positions, so we 
                maintain a stack of registry handles for the latter case. every
                key that is created is initially put on the stack. values
                are always written based on the 'current stack' position.

    ENTRY:      NONE 

    RETURN:     Win32 error code 

    HISTORY:
                chuckc  29-Nov-1995     Created

********************************************************************/
DWORD SetupShellExtensions(REG_ENTRY RegEntries[], DWORD dwNumEntries) 
{
    DWORD  err, errClose, dwDisposition, i ; 
    HKEY   hKey, RegHandleStack[MAX_REG_LEVEL] ; 
    LONG   StackIndex = -1 ;
    
    //
    // Loop thru and for each entry. Then switch & do the appropriate 
    // operation in the registry.
    //

    for (i = 0; i < dwNumEntries; i++)
    {
        err = NO_ERROR ;

        switch (RegEntries[i].Operation)
        {
            case CREATE_ABS:       

                //
                // create/open a reg key with an absolute path. since this
                // is absolute, we drop everything on the stack, and start
                // all over again.
                //
                 
                while (StackIndex >= 0)
                {
                    errClose = RegCloseKey(RegHandleStack[StackIndex--]) ;
                    ASSERT(errClose == NO_ERROR) ;
                }
 
                err = RegCreateKeyExW(HKEY_LOCAL_MACHINE,
                                      RegEntries[i].s1,      // subkey
                                      0,                     // reserved
                                      NULL,                  // class 
                                      REG_OPTION_NON_VOLATILE,
                                      KEY_ALL_ACCESS,
                                      NULL,                  // default security
                                      &hKey,               
                                      &dwDisposition) ;      // not used
                if (err != NO_ERROR)
                {
                    break ;
                }

                //
                // by default we advance the stack. no need check for overflow
                // as the stack is empty.
                //

                RegHandleStack[++StackIndex] = hKey ;
                break ;

            case CREATE_REL:
 
                //
                // create/open a reg key relative to current stack. make sure 
                // there is something on the stack (check StackIndex >= 0). 
                // then see if we are advancing (+1), staying the same (0) or
                // dropping back (-ve).
                //
                 
                if (StackIndex < 0)
                {
                    err = ERROR_INVALID_FUNCTION ;  
                    break ;
                }
 
                if (RegEntries[i].Level == +1)
                {
                    //
                    // opening next level down. continue as is and use
                    // most recently opened key as the starting point.
                    //
                }
                else if (RegEntries[i].Level == 0)
                {
                    //
                    // opening at same level as last time. so we are done
                    // with the last key. what we want to do is close it
                    // and use the parent.
                    //
                    errClose = RegCloseKey(RegHandleStack[StackIndex--]) ;

                    ASSERT(errClose == NO_ERROR) ;

                    if (StackIndex < 0)
                    {
                        err = ERROR_INVALID_FUNCTION ;
                        break ;
                    }
                }
                else if (RegEntries[i].Level < 0) 
                {
                    //
                    // dropping back & opening at a higher level. cleanup 
                    // handle for each level we pop.
                    //

                    LONG Count =  RegEntries[i].Level ;
                    
                    while (Count++ < 1)
                    {
                        errClose = RegCloseKey(RegHandleStack[StackIndex--]) ;

                        ASSERT(errClose == NO_ERROR) ;

                        if (StackIndex < -1)
                        {
                            err = ERROR_INVALID_FUNCTION ;
                            break ;
                        }
                    }
                }
                else 
                {
                    //
                    // only -ve numbers, 0 and 1 are valid
                    //

                    err = ERROR_INVALID_FUNCTION ;
                    break ;
                }

                //
                // create key relative to current point
                //
                err = RegCreateKeyExW(RegHandleStack[StackIndex], // current key
                                      RegEntries[i].s1,      // subkey
                                      0,                     // reserved
                                      NULL,                  // class 
                                      REG_OPTION_NON_VOLATILE,
                                      KEY_ALL_ACCESS,
                                      NULL,                  // default security
                                      &hKey,               
                                      &dwDisposition) ;      // not used
                if (err != NO_ERROR)
                {
                    break ;
                }

                //
                // by default we advance the stack
                //

                RegHandleStack[++StackIndex] = hKey ;   
                
                if (StackIndex >= MAX_REG_LEVEL)
                {
                    err = ERROR_INVALID_FUNCTION ;
                    break ;
                }
                
                break ;

            case VALUE_STR:
 
                //
                // create a REG_SZ value at current point. check we have 
                // handle on stack.
                //

                if (StackIndex < 0)
                {
                    err = ERROR_INVALID_FUNCTION ;
                    break ;
                }

                err = RegSetValueExW(
                           RegHandleStack[StackIndex],       // current key
                           RegEntries[i].s1,                 // value name
                           0,                                // reserved
                           REG_SZ,
                           (BYTE *)RegEntries[i].s2,         // value data
                           (wcslen(RegEntries[i].s2)+1)*sizeof(WCHAR)) ;
                break ;

            case DELETE_ABS:       

                //
                // delete a key (absolute). no change to stack.
                //

                err = RegDeleteKeyW(HKEY_LOCAL_MACHINE,
                                    RegEntries[i].s1) ;        // subkey

                if ( err == ERROR_FILE_NOT_FOUND )
                    err = NO_ERROR;

                break ;

            case DELETE_REL:       

                //
                // delete a key (relative). no change to stack.
                //

                if (StackIndex < 0)
                {
                    err = ERROR_INVALID_FUNCTION ;
                    break ;
                }

                err = RegDeleteKeyW(RegHandleStack[StackIndex],   // current key
                                    RegEntries[i].s1) ;           // subkey

                if ( err == ERROR_FILE_NOT_FOUND )
                    err = NO_ERROR;

                break ;

            case DELETE_VAL:
 
                //
                // delete value at current point. check we have handle on stack.
                //

                if (StackIndex < 0)
                {
                    err = ERROR_INVALID_FUNCTION ;
                    break ;
                }

                err = RegDeleteValueW(RegHandleStack[StackIndex], // current key
                                      RegEntries[i].s1) ;         // value name
                break ;

            case DROP_STACK:
 
                //
                // drop current stack by one (closing the handle).
                //
                 
                if (StackIndex < 0)
                {
                    err = ERROR_INVALID_FUNCTION ;  
                    break ;
                }

                errClose = RegCloseKey(RegHandleStack[StackIndex--]) ;

                ASSERT(errClose == NO_ERROR) ;
              
                break ;
 
            default:

                //
                // error out if unknown operation
                //

                err = ERROR_INVALID_FUNCTION ;
                break ;
        }

        if (err != NO_ERROR)
        {
            break ;
        }
    }

    //
    // cleanup open handles on the stack
    //

    while (StackIndex >= 0)
    {
        errClose = RegCloseKey(RegHandleStack[StackIndex--]) ;
        ASSERT(errClose == NO_ERROR) ;
    }
 
    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\install\wksta\makefile.inc ===
INFHEADER=$(TARGET_DIRECTORY).txt

!IFNDEF INFLANGUAGE
INFLANGUAGE=ENG
!ENDIF

all: oemnsvnw.inf

make_inf: oemnsvnw.inf

clean:  cleansrc oemnsvnw.inf

cleansrc:
        del oemnsvnw.inf


!IF "$(QFE_BUILD)" != "1"

oemnsvnw.inf: $(INFHEADER) nw.inf $(INFLANGUAGE).txt files10a.txt
        copy $(INFHEADER)+$(INFLANGUAGE).txt+nw.inf+files10a.txt oemnsvnw.inf
        binplace oemnsvnw.inf

!ELSE

oemnsvnw.inf: $(INFHEADER) nw.inf $(INFLANGUAGE).txt files10.txt
        copy $(INFHEADER)+$(INFLANGUAGE).txt+nw.inf+files10.txt oemnsvnw.inf
        binplace oemnsvnw.inf

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\install\wksta\nwperfm.h ===
//
//  NWPerfM.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values of the device they belong to, 
//  in order to determine the  absolute location of the counter and 
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the 
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define NWOBJ                       0
#define PACKET_BURST_READ_ID        2
#define PACKET_BURST_READ_TO_ID     4
#define PACKET_BURST_WRITE_ID       6
#define PACKET_BURST_WRITE_TO_ID    8
#define PACKET_BURST_IO_ID         10
#define CONNECT_2X_ID              12
#define CONNECT_3X_ID              14
#define CONNECT_4X_ID              16

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\chngpass.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ChngPass.c

Abstract:

    Command line test tool for changing a password on a user object in
    a NDS tree.

Author:

    Glenn Curtis       [glennc] 05-Jan-96

***/

#include <utils.c>


int
_cdecl main( int argc, char **argv )
{
    DWORD    status = NO_ERROR;

    HANDLE   hObject = NULL;

    OEM_STRING OemArg;
    UNICODE_STRING ObjectName;
    WCHAR lpObjectName[256];
    WCHAR lpOldPassword[256];
    WCHAR lpNewPassword[256];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( lpObjectName );
    ObjectName.Buffer = lpObjectName;

    //
    // Check the arguments.
    //

    if ( argc != 2 )
    {
        printf( "\nUsage: chngpass <user object DN>\n" );
        printf( "\n   where:\n" );
        printf( "   user object DN = \\\\tree\\joe.yyy.zzz\n" );
        printf( "\nFor Example: chngpass \\\\MARSDEV\\CN=USER1.OU=DEV.O=MARS\n\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    if ( status = NwNdsOpenObject( ObjectName.Buffer,
                                   NULL,
                                   NULL,
                                   &hObject,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL ) != NO_ERROR )
    {
        printf( "\nError: NwNdsOpenObject returned status %ld\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    printf( "\nPlease enter your old password : " );
    GetStringOrDefault( lpOldPassword, L"" );

    printf( "\nPlease enter your new password : " );
    GetStringOrDefault( lpNewPassword, L"" );

    if ( status = NwNdsChangeUserPassword( hObject,
                                           lpOldPassword,
                                           lpNewPassword ) != NO_ERROR )
    {
        printf( "\nError: NwNdsChangeUserPassword returned status %ld\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    if ( status = NwNdsCloseObject( hObject ) != NO_ERROR )
    {
        printf( "\nError: NwNdsCloseObject returned status %ld\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    printf( "\nUser password successfully changed\n\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\addobj.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    AddObj.c

Abstract:

    Command line test tool for adding an object to a NDS tree.

Author:

    Glenn Curtis       [glennc] 05-Jan-96

***/

#include <utils.c>
#include <string.h>


int
_cdecl main( int argc, char **argv )
{
    DWORD      status = NO_ERROR;
    LPBYTE     lpTemp = NULL, lpValue = NULL;
    DWORD      dwValue;

    HANDLE     hParentObject = NULL;
    HANDLE     hOperationData = NULL;

    OEM_STRING  OemArg;

    UNICODE_STRING ParentObjectName;
    WCHAR       lpParentObjectName[256];

    UNICODE_STRING ObjectName;
    WCHAR lpObjectName[256];

    UNICODE_STRING ClassName;
    WCHAR lpClassName[256];

    ASN1_TYPE_3 asn1Type3;

    ParentObjectName.Length = 0;
    ParentObjectName.MaximumLength = sizeof( lpParentObjectName );
    ParentObjectName.Buffer = lpParentObjectName;

    //
    // Check the arguments.
    //

    if ( argc != 4 )
    {
        printf( "\nUsage: addobj <parent object DN> <object name> <object class>\n" );
        printf( "\n   where:\n" );
        printf( "   parent object DN = \\\\tree\\xxx.yyy.zzz\n" );
        printf( "   object name = Fred\n" );
        printf( "   object class = User\n" );
        printf( "\nFor Example:\n" );
        printf( "    addobj \\\\MARSDEV\\OU=DEV.O=MARS Fred User\n\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ParentObjectName, &OemArg, FALSE );

    status = NwNdsOpenObject( ParentObjectName.Buffer,
                              NULL,
                              NULL,
                              &hParentObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status )
    {
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    //
    // Give the new object some initial attributes
    //
    status = NwNdsCreateBuffer( NDS_OBJECT_ADD, &hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n\n",
                status );

        return -1;
    }

    //
    // Get the new object's name
    //
    OemArg.Length = strlen( argv[2] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[2];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( lpObjectName );
    ObjectName.Buffer = lpObjectName;

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    asn1Type3.CaseIgnoreString = ObjectName.Buffer;

    OemArg.Length = strlen( argv[3] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[3];

    ClassName.Length = 0;
    ClassName.MaximumLength = sizeof( lpClassName );
    ClassName.Buffer = lpClassName;

    RtlOemStringToUnicodeString( &ClassName, &OemArg, FALSE );

    if ( !_wcsicmp( ClassName.Buffer, L"User" ) )
    {
        status = NwNdsPutInBuffer( NDS_SURNAME,
                                   &asn1Type3,
                                   1,
                                   0,
                                   hOperationData );

        if ( status )
        {
            printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n\n", status );

            return -1;
        }
    }

    asn1Type3.CaseIgnoreString = ClassName.Buffer;

    status = NwNdsPutInBuffer( NDS_OBJECT_CLASS,
                               &asn1Type3,
                               1,
                               0,
                               hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n\n",
                status );

        return -1;
    }

    printf( "Adding the new object to tree\n" );

    status = NwNdsAddObject( hParentObject,
                             ObjectName.Buffer,
                             hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsAddObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    status = NwNdsCloseObject( hParentObject );

    if ( status )
    {
        printf( "\nError: NwNdsCloseObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    (void) LocalFree( lpValue );

    status = NwNdsFreeBuffer( hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsFreeBuffer returned status 0x%.8X\n\n", status );

        return -1;
    }

    printf( "\nSuccess!\n\n" );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\browser.c ===
//
// NDS Browser Test App
//
// Cory West
//

#include "ndsapi32.h"
#include "nds.h"

VOID
ConsoleDumpSubordinates(
    PNDS_RESPONSE_SUBORDINATE_LIST pSubList
);

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS Status;

    //
    // For NwNdsOpenTreeHandle
    //

    HANDLE hRdr;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    WCHAR NdsStr[256];

    //
    // For NwNdsResolveName
    //

    PNDS_RESPONSE_RESOLVE_NAME psResolveName;
    DWORD dwOid;
    UNICODE_STRING ReferredServer;
    WCHAR ServerName[48];
    HANDLE hReferredServer;
    DWORD dwHandleType;

    //
    // For NwNdsReadObjectInfo
    //

    BYTE RawResponse[1024];
    PNDS_RESPONSE_GET_OBJECT_INFO psGetInfo;
    PBYTE pbRawGetInfo;
    DWORD dwStrLen;

    //
    // For NwNdsList
    //

    DWORD dwIterHandle;

    /**************************************************/

    //
    // Examine the argument count and hope for the best.
    //

    if ( argc != 3 ) {
       printf( "Usage: browser <tree name> <ds object path>\n" );
       printf( "For example, browser marsdev dev.mars\n");
       return -1;
    }

    //
    // Convert the tree name string to unicode.
    //

    oemStr.Length = strlen( argv[1] );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = argv[1];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( NdsStr );
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    //
    // Get a handle to the redirector.
    //

    Status = NwNdsOpenTreeHandle( &ObjectName,
                                  &hRdr );

    if ( !NT_SUCCESS( Status ) ) {
        printf( "*** Open Handle to Nds Tree: Status = %08lx\n", Status );
        return -1;
    }

    //
    // Resolve the name that we have to an object id.
    //

    oemStr.Length = strlen(argv[2]);
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = argv[2];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerName;
    ReferredServer.MaximumLength = sizeof( ServerName );
    ReferredServer.Length = 0;

    Status = NwNdsResolveName ( hRdr,
                                &ObjectName,
                                &dwOid,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       printf( "*** Resolve Name: Status = %08lx\n", Status );
       goto Exit;
    }

    if ( ReferredServer.Length != 0 ) {

        //
        // We have to jump servers.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            printf( "*** Couldn't open referred server: Status = %08lx\n", Status );
            goto Exit;
        }

        CloseHandle( hRdr );
        hRdr = hReferredServer;
    }

    printf( "=========================== NDS Object Info ===========================\n" );
    printf( "Object ID = 0x%08lx\n", dwOid );

    //
    // Go for the object information.
    //

    Status = NwNdsReadObjectInfo( hRdr,
                                  dwOid,
                                  RawResponse,
                                  sizeof( RawResponse ) );

    if ( !NT_SUCCESS( Status ) ) {
        printf( "*** Get Object Info: Status = %08lx\n", Status );
        goto Exit;
    }

    psGetInfo = ( PNDS_RESPONSE_GET_OBJECT_INFO ) RawResponse;

    printf( "Flags = 0x%08lx\n", psGetInfo->EntryFlags );
    printf( "Subordinate Count = 0x%08lx\n", psGetInfo->SubordinateCount );
    printf( "Last Modified Time = 0x%08lx\n", psGetInfo->ModificationTime );

    //
    // Dig out the two unicode strings for class name and object name.
    //

    pbRawGetInfo = RawResponse;

    pbRawGetInfo += sizeof ( NDS_RESPONSE_GET_OBJECT_INFO );

    dwStrLen = * ( DWORD * ) pbRawGetInfo;
    pbRawGetInfo += sizeof( DWORD );
    printf( "Class Name: %S\n", pbRawGetInfo );

    pbRawGetInfo += ROUNDUP4( dwStrLen );
    dwStrLen = * ( DWORD * ) pbRawGetInfo;
    pbRawGetInfo += sizeof( DWORD );
    printf( "Object Name: %S\n", pbRawGetInfo );

    //
    // Get the subordinate list.
    //

    if ( psGetInfo->SubordinateCount ) {

        dwIterHandle = INITIAL_ITERATION;

        do {

            Status = NwNdsList( hRdr,
                                dwOid,
                                &dwIterHandle,
                                RawResponse,
                                sizeof( RawResponse ) );

            if ( !NT_SUCCESS( Status ) ) {
                printf( "*** List Subordinates: Status = %08lx\n", Status );
                goto Exit;
            }

        ConsoleDumpSubordinates( (PNDS_RESPONSE_SUBORDINATE_LIST) RawResponse );

        } while ( dwIterHandle != INITIAL_ITERATION );

    }


Exit:

    CloseHandle( hRdr );

    if ( NT_SUCCESS( Status ) ) {
       return 0;
    } else {
       return -1;
    }

}


VOID
ConsoleDumpSubordinates(
    PNDS_RESPONSE_SUBORDINATE_LIST pSubList
) {

    NTSTATUS Status;
    PNDS_RESPONSE_SUBORDINATE_ENTRY pSubEntry;

    PBYTE pbRaw;
    DWORD dwStrLen, dwEntries;

    dwEntries = pSubList->SubordinateEntries;

    printf( "======================== Subordinate List (%d) ========================\n", dwEntries );

    pSubEntry = ( PNDS_RESPONSE_SUBORDINATE_ENTRY )
        ( ( (BYTE *)pSubList ) + sizeof( NDS_RESPONSE_SUBORDINATE_LIST ) );

    while ( dwEntries ) {

        printf( "EntryID (0x%08lx),\tFlags (0x%08lx)\n",
                pSubEntry->EntryId, pSubEntry->Flags );

        printf( "Subordinate Count (%d),\tMod Time (0x%08lx)\n",
                pSubEntry->SubordinateCount, pSubEntry->ModificationTime );

        pbRaw = (BYTE *) pSubEntry;
        pbRaw += sizeof( NDS_RESPONSE_SUBORDINATE_ENTRY );

        dwStrLen = * ( DWORD * ) pbRaw;
        pbRaw += sizeof( DWORD );
        printf( "Class Name: %S\t", pbRaw );

        pbRaw += ROUNDUP4( dwStrLen );
        dwStrLen = * ( DWORD * ) pbRaw;
        pbRaw += sizeof( DWORD );
        printf( "Object Name: %S\n", pbRaw );

        pSubEntry = ( PNDS_RESPONSE_SUBORDINATE_ENTRY ) ( pbRaw + ROUNDUP4( dwStrLen ) );
        dwEntries--;

        printf( "-----------------------------------------------------------------------\n" );

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\cx.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Cx.c

Abstract:

    This is the command line NDS utility for setting contexts.

Author:

    Cory West       [corywest]  25-Oct-95

***/

#include "ndsapi32.h"

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS Status;
    HANDLE hNdsTree;
    OEM_STRING OemArg;

    UNICODE_STRING NdsTree;
    WCHAR TreeBuffer[1024];

    UNICODE_STRING Context;
    WCHAR ContextBuffer[1024];

    //
    // Who do we want to monkey with?
    //

    if ( argc < 2 ) {
        printf( "Usage: cx [tree name] [optional context]\n" );
	return -1;
    }

    //
    // Get the tree.
    //

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    NdsTree.Length = 0;
    NdsTree.MaximumLength = sizeof( TreeBuffer );
    NdsTree.Buffer = TreeBuffer;

    RtlOemStringToUnicodeString( &NdsTree, &OemArg, FALSE );

    //
    // Open up a handle to the tree.
    //

    Status = NwNdsOpenTreeHandle( &NdsTree,
                                  &hNdsTree );

    if ( !NT_SUCCESS( Status ) ) {
       printf( "The supplied tree name is invalid or the tree is unavailable.\n" );
       return -1;
    }

    //
    // Get or set the context, depending.
    //

    Context.Length = 0;
    Context.MaximumLength = sizeof( ContextBuffer );
    Context.Buffer = ContextBuffer;

    Status = STATUS_UNSUCCESSFUL;

    if ( argc == 2 ) {

       //
       // Get the context.
       //

       Status = NwNdsGetTreeContext ( hNdsTree,
                                      &NdsTree,
				      &Context );

       if ( !NT_SUCCESS( Status ) ) {
	   printf( "You are not logged into the specified tree.\n" );
	   goto Exit;
       }

       ContextBuffer[Context.Length/sizeof(WCHAR)] = L'\0';
       printf( "%S", ContextBuffer );

    } else {

       //
       // Set the context.
       //

       OemArg.Length = strlen( argv[2] );
       OemArg.MaximumLength = OemArg.Length;
       OemArg.Buffer = argv[2];

       RtlOemStringToUnicodeString( &Context, &OemArg, FALSE );

       Status = NwNdsSetTreeContext ( hNdsTree,
                                      &NdsTree,
				      &Context );

       if ( !NT_SUCCESS( Status ) ) {
	   printf( "*** Set context: Status = %08lx\n", Status );
       }

   }


Exit:

    CloseHandle( hNdsTree );

    if ( !NT_SUCCESS( Status )) {
        return -1;
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\delobj.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    DelObj.c

Abstract:

    Command line test tool for removing an object from a NDS tree.

Author:

    Glenn Curtis       [glennc] 05-Jan-96

***/

#include <utils.c>


int
_cdecl main( int argc, char **argv )
{
    DWORD      status = NO_ERROR;

    HANDLE     hParentObject = NULL;

    OEM_STRING OemArg;
    UNICODE_STRING ParentObjectName;
    WCHAR lpParentObjectName[256];
    UNICODE_STRING ObjectName;
    WCHAR ObjectNameBuffer[48]; // Max object name length.

    ParentObjectName.Length = 0;
    ParentObjectName.MaximumLength = sizeof( lpParentObjectName );
    ParentObjectName.Buffer = lpParentObjectName;

    //
    // Check the arguments.
    //

    if ( argc != 3 )
    {
        printf( "\nUsage: delobj <parent object DN> <object name>\n" );
        printf( "\n   where:\n" );
        printf( "   parent object DN = \\\\tree\\xxx.yyy.zzz\n" );
        printf( "   object name = The name of the object to remove, no spaces\n" );
        printf( "\nFor Example:\n" );
        printf( "    delobj \\\\MARSDEV\\OU=DEV.O=MARS TESTUSER\n\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ParentObjectName, &OemArg, FALSE );

    status = NwNdsOpenObject( ParentObjectName.Buffer,
                              NULL,
                              NULL,
                              &hParentObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status )
    {
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    //
    // Prepare the new object's name
    //
    OemArg.Length = strlen( argv[2] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[2];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( ObjectNameBuffer );
    ObjectName.Buffer = ObjectNameBuffer;

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    printf( "Removing the object from tree\n" );

    status = NwNdsRemoveObject( hParentObject, ObjectName.Buffer );

    if ( status )
    {
        printf( "\nError: NwNdsRemoveObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    status = NwNdsCloseObject( hParentObject );

    if ( status )
    {
        printf( "\nError: NwNdsCloseObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    printf( "\nSuccess!\n\n" );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\ditdump.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Schema.c

Abstract:

   Command line test tool for dumping the NDS schema attribute and class
   names and/or definitions.

Author:

    Glenn Curtis       [glennc] 22-Apr-96

***/

#include <utils.c>


int
_cdecl main( int argc, char **argv )
{
    DWORD    status = NO_ERROR;

    HANDLE   hTree = NULL;
    HANDLE   hOperationData = NULL;

    OEM_STRING OemArg;
    UNICODE_STRING TreeName;
    WCHAR szTreeName[256];
    WCHAR szTempAttrName[256];
    WCHAR szTempClassName[256];

    ASN1_ID  asn1Id;

    DWORD    dwNumberOfEntries;
    DWORD    dwInfoType;
    DWORD    dwSyntaxID;

    DWORD    iter;

    TreeName.Length = 0;
    TreeName.MaximumLength = sizeof( szTreeName );
    TreeName.Buffer = szTreeName;

    //
    // Check the arguments.
    //

    if ( argc < 3 )
    {
Usage:
        printf( "\nUsage: ditdump <tree name> -n|d|x C|A [P] [C]\n" );
        printf( "\n       where: n = Names only\n" );
        printf( "       where: d = Names & definitions\n" );
        printf( "       where: x = Extended names & definitions (Includes inherited properties)\n" );
        printf( "       where: C = Classes\n" );
        printf( "       where: A = Attributes\n" );
        printf( "\n       where: P = Prompts user for list of specific\n" );
        printf( "                    classes, attributes, or syntaxes to read.\n" );
        printf( "\n       where: C = Prompts user for a specific set of credentials.\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &TreeName, &OemArg, FALSE );

    if ( ( argc > 4 && argv[4][0] == 'C' ) ||
         ( argc > 5 && argv[5][0] == 'C' ) )
    {
        WCHAR UserName[256];
        WCHAR Password[256];

        printf( "\nEnter a user name : " );
        GetStringOrDefault( UserName, L"" );

        printf( "\nEnter a password : " );
        GetStringOrDefault( Password, L"" );

        status = NwNdsOpenObject( TreeName.Buffer,
                                  UserName,
                                  Password,
                                  &hTree,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL );
    }
    else
    {
        status = NwNdsOpenObject( TreeName.Buffer,
                                  NULL,
                                  NULL,
                                  &hTree,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL );
    }

    if ( status )
    {
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    if ( argv[2][1] == 'n' && argv[3][0] == 'A' )
    {
        LPNDS_NAME_ONLY lpAttrNames = NULL;

        if ( argc > 4 && argv[4][0] == 'P' )
        {
            status = NwNdsCreateBuffer( NDS_SCHEMA_READ_ATTR_DEF,
                                        &hOperationData );

            if ( status )
            {
                printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
                printf( "Error: GetLastError returned: 0x%.8X\n\n",
                        GetLastError() );

                return -1;
            }

            do
            {
                printf( "\nEnter attribute name or <Enter> to end : " );
                GetStringOrDefault( szTempAttrName, L"" );

                if ( wcslen(szTempAttrName) > 0 )
                {
                    status = NwNdsPutInBuffer( szTempAttrName,
                                               0,
                                               NULL,
                                               0,
                                               0,
                                               hOperationData );

                    if ( status )
                    {
                        printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n", status );
                        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                                GetLastError() );

                        return -1;
                    }
                }

            } while ( wcslen(szTempAttrName) > 0 );
        }

        printf( "\nGoing to dump the schema attribute names.\n" );

        status = NwNdsReadAttrDef( hTree,
                                   NDS_INFO_NAMES,
                                   &hOperationData );

        if ( status )
        {
            printf( "\nError: NwNdsReadAttrDef returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        status = NwNdsGetAttrDefListFromBuffer( hOperationData,
                                                &dwNumberOfEntries,
                                                &dwInfoType,
                                                (LPVOID *) &lpAttrNames );

        if ( status )
        {
            printf( "\nError: NwNdsGetAttrDefListFromBuffer returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        printf( "\nThe list of attribute definitions in the schema for\n" );
        printf( "NDS tree %S is :\n\n", TreeName.Buffer );

        for ( iter = 0; iter < dwNumberOfEntries; iter++ )
        {
            (void) NwNdsGetSyntaxID( hTree,
                                     lpAttrNames[iter].szName,
                                     &dwSyntaxID );

            printf( "     %S (Syntax ID: %ld)\n",
                    lpAttrNames[iter].szName,
                    dwSyntaxID );
        }

        (void) NwNdsFreeBuffer( hOperationData );
        (void) NwNdsCloseObject( hTree );

        return 0;
    }

    if ( argv[2][1] == 'd' && argv[3][0] == 'A' )
    {
        LPNDS_ATTR_DEF lpAttrDefs = NULL;

        if ( argc > 4 && argv[4][0] == 'P' )
        {
            status = NwNdsCreateBuffer( NDS_SCHEMA_READ_ATTR_DEF,
                                        &hOperationData );

            if ( status )
            {
                printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
                printf( "Error: GetLastError returned: 0x%.8X\n\n",
                        GetLastError() );

                return -1;
            }

            do
            {
                printf( "\nEnter attribute name or <Enter> to end : " );
                GetStringOrDefault( szTempAttrName, L"" );

                if ( wcslen(szTempAttrName) > 0 )
                {
                    status = NwNdsPutInBuffer( szTempAttrName,
                                               0,
                                               NULL,
                                               0,
                                               0,
                                               hOperationData );

                    if ( status )
                    {
                        printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n", status );
                        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                                GetLastError() );

                        return -1;
                    }
                }

            } while ( wcslen(szTempAttrName) > 0 );
        }

        printf( "\nGoing to dump the schema attribute names and definitions.\n" );

        status = NwNdsReadAttrDef( hTree,
                                   NDS_INFO_NAMES_DEFS,
                                   &hOperationData );

        if ( status )
        {
            printf( "\nError: NwNdsReadAttrDef returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        status = NwNdsGetAttrDefListFromBuffer( hOperationData,
                                                &dwNumberOfEntries,
                                                &dwInfoType,
                                                (LPVOID *) &lpAttrDefs );

        if ( status )
        {
            printf( "\nError: NwNdsGetAttrDefListFromBuffer returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        printf( "\nThe list of attribute definitions in the schema for\n" );
        printf( "NDS tree %S is :\n\n", TreeName.Buffer );

        for ( iter = 0; iter < dwNumberOfEntries; iter++ )
        {
            printf( "     %S\n", lpAttrDefs[iter].szAttributeName );
            printf( "   _____________________________________________\n" );
            printf( "         Flags :           0x%.8X\n",
                    lpAttrDefs[iter].dwFlags );
            printf( "         Syntax ID :       %ld\n",
                    lpAttrDefs[iter].dwSyntaxID );
            printf( "         Lower Limit :     0x%.8X\n",
                    lpAttrDefs[iter].dwLowerLimit );
            printf( "         Upper Limit :     0x%.8X\n",
                    lpAttrDefs[iter].dwUpperLimit );
            printf( "         ASN.1 ID length : %ld\n",
                    lpAttrDefs[iter].asn1ID.length );
            printf( "         ASN.1 ID Data :   %s\n\n",
                    lpAttrDefs[iter].asn1ID.data );
        }

        (void) NwNdsFreeBuffer( hOperationData );
        (void) NwNdsCloseObject( hTree );

        return 0;
    }

    if ( argv[2][1] == 'n' && argv[3][0] == 'C' )
    {
        LPNDS_NAME_ONLY lpClassNames = NULL;

        if ( argc > 4 && argv[4][0] == 'P' )
        {
            status = NwNdsCreateBuffer( NDS_SCHEMA_READ_CLASS_DEF,
                                        &hOperationData );

            if ( status )
            {
                printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
                printf( "Error: GetLastError returned: 0x%.8X\n\n",
                        GetLastError() );

                return -1;
            }

            do
            {
                printf( "\nEnter class name or <Enter> to end : " );
                GetStringOrDefault( szTempClassName, L"" );

                if ( wcslen(szTempClassName) > 0 )
                {
                    status = NwNdsPutInBuffer( szTempClassName,
                                               0,
                                               NULL,
                                               0,
                                               0,
                                               hOperationData );

                    if ( status )
                    {
                        printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n", status );
                        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                                GetLastError() );

                        return -1;
                    }
                }

            } while ( wcslen(szTempClassName) > 0 );
        }

        printf( "\nGoing to dump the schema class names.\n" );

        status = NwNdsReadClassDef( hTree,
                                    NDS_INFO_NAMES,
                                    &hOperationData );

        if ( status )
        {
            printf( "\nError: NwNdsReadClassDef returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        status = NwNdsGetClassDefListFromBuffer( hOperationData,
                                                 &dwNumberOfEntries,
                                                 &dwInfoType,
                                                 (LPVOID *) &lpClassNames );

        if ( status )
        {
            printf( "\nError: NwNdsGetClassDefListFromBuffer returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        printf( "\nThe list of class definitions in the schema for\n" );
        printf( "NDS tree %S is :\n\n", TreeName.Buffer );

        for ( iter = 0; iter < dwNumberOfEntries; iter++ )
        {
            printf( "     %S\n", lpClassNames[iter].szName );
        }

        (void) NwNdsFreeBuffer( hOperationData );
        (void) NwNdsCloseObject( hTree );

        return 0;
    }

    if ( argv[2][1] == 'd' && argv[3][0] == 'C' )
    {
        LPNDS_CLASS_DEF lpClassDefs = NULL;

        if ( argc > 4 && argv[4][0] == 'P' )
        {
            status = NwNdsCreateBuffer( NDS_SCHEMA_READ_CLASS_DEF,
                                        &hOperationData );

            if ( status )
            {
                printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
                printf( "Error: GetLastError returned: 0x%.8X\n\n",
                        GetLastError() );

                return -1;
            }

            do
            {
                printf( "\nEnter class name or <Enter> to end : " );
                GetStringOrDefault( szTempClassName, L"" );

                if ( wcslen(szTempClassName) > 0 )
                {
                    status = NwNdsPutInBuffer( szTempClassName,
                                               0,
                                               NULL,
                                               0,
                                               0,
                                               hOperationData );

                    if ( status )
                    {
                        printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n", status );
                        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                                GetLastError() );

                        return -1;
                    }
                }

            } while ( wcslen(szTempClassName) > 0 );
        }

        printf( "\nGoing to dump the schema class names and definitions.\n" );

        status = NwNdsReadClassDef( hTree,
                                    NDS_INFO_NAMES_DEFS,
                                    &hOperationData );

        if ( status )
        {
            printf( "\nError: NwNdsReadClassDef returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        status = NwNdsGetClassDefListFromBuffer( hOperationData,
                                                 &dwNumberOfEntries,
                                                 &dwInfoType,
                                                 (LPVOID *) &lpClassDefs );

        if ( status )
        {
            printf( "\nError: NwNdsGetClassDefListFromBuffer returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        printf( "\nThe list of class definitions in the schema for\n" );
        printf( "NDS tree %S is :\n\n", TreeName.Buffer );

        for ( iter = 0; iter < dwNumberOfEntries; iter++ )
        {
            printf( "     %S\n", lpClassDefs[iter].szClassName );
            printf( "   _____________________________________________\n" );
            printf( "         Flags :           0x%.8X\n",
                    lpClassDefs[iter].dwFlags );

            printf( "         ASN.1 ID length : %ld\n",
                    lpClassDefs[iter].asn1ID.length );

            printf( "         ASN.1 ID Data :   %s\n\n",
                    lpClassDefs[iter].asn1ID.data );

            printf( "         Super Classes (%ld) : \n",
                    lpClassDefs[iter].dwNumberOfSuperClasses );
            DumpListOfStrings( lpClassDefs[iter].lpSuperClasses );

            printf( "         Containment Classes (%ld) : \n",
                    lpClassDefs[iter].dwNumberOfContainmentClasses );
            DumpListOfStrings( lpClassDefs[iter].lpContainmentClasses );

            printf( "         Naming Attributes (%ld) : \n",
                    lpClassDefs[iter].dwNumberOfNamingAttributes );
            DumpListOfStrings( lpClassDefs[iter].lpNamingAttributes );

            printf( "         Mandatory Attributes (%ld) : \n",
                    lpClassDefs[iter].dwNumberOfMandatoryAttributes );
            DumpListOfStrings( lpClassDefs[iter].lpMandatoryAttributes );

            printf( "         Optional Attributes (%ld) : \n",
                    lpClassDefs[iter].dwNumberOfOptionalAttributes );
            DumpListOfStrings( lpClassDefs[iter].lpOptionalAttributes );
            printf( "\n" );
        }

        (void) NwNdsFreeBuffer( hOperationData );
        (void) NwNdsCloseObject( hTree );

        return 0;
    }

    if ( argv[2][1] == 'x' && argv[3][0] == 'C' )
    {
        LPNDS_CLASS_DEF lpClassDefs = NULL;

        if ( argc > 4 && argv[4][0] == 'P' )
        {
            status = NwNdsCreateBuffer( NDS_SCHEMA_READ_CLASS_DEF,
                                        &hOperationData );

            if ( status )
            {
                printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
                printf( "Error: GetLastError returned: 0x%.8X\n\n",
                        GetLastError() );

                return -1;
            }

            do
            {
                printf( "\nEnter class name or <Enter> to end : " );
                GetStringOrDefault( szTempClassName, L"" );

                if ( wcslen(szTempClassName) > 0 )
                {
                    status = NwNdsPutInBuffer( szTempClassName,
                                               0,
                                               NULL,
                                               0,
                                               0,
                                               hOperationData );

                    if ( status )
                    {
                        printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n", status );
                        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                                GetLastError() );

                        return -1;
                    }
                }

            } while ( wcslen(szTempClassName) > 0 );
        }

        printf( "\nGoing to dump the extended schema class names and definitions.\n" );

        status = NwNdsReadClassDef( hTree,
                                    NDS_CLASS_INFO_EXPANDED_DEFS,
                                    &hOperationData );

        if ( status )
        {
            printf( "\nError: NwNdsReadClassDef returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        status = NwNdsGetClassDefListFromBuffer( hOperationData,
                                                 &dwNumberOfEntries,
                                                 &dwInfoType,
                                                 (LPVOID *) &lpClassDefs );

        if ( status )
        {
            printf( "\nError: NwNdsGetClassDefListFromBuffer returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        printf( "\nThe list of class definitions in the schema for\n" );
        printf( "NDS tree %S is :\n\n", TreeName.Buffer );

        for ( iter = 0; iter < dwNumberOfEntries; iter++ )
        {
            printf( "     %S\n", lpClassDefs[iter].szClassName );
            printf( "   _____________________________________________\n" );
            printf( "         Flags :           0x%.8X\n",
                    lpClassDefs[iter].dwFlags );

            printf( "         ASN.1 ID length : %ld\n",
                    lpClassDefs[iter].asn1ID.length );

            printf( "         ASN.1 ID Data :   %s\n\n",
                    lpClassDefs[iter].asn1ID.data );

            printf( "         Super Classes (%ld) : \n",
                    lpClassDefs[iter].dwNumberOfSuperClasses );
            DumpListOfStrings( lpClassDefs[iter].lpSuperClasses );

            printf( "         Containment Classes (%ld) : \n",
                    lpClassDefs[iter].dwNumberOfContainmentClasses );
            DumpListOfStrings( lpClassDefs[iter].lpContainmentClasses );

            printf( "         Naming Attributes (%ld) : \n",
                    lpClassDefs[iter].dwNumberOfNamingAttributes );
            DumpListOfStrings( lpClassDefs[iter].lpNamingAttributes );

            printf( "         Mandatory Attributes (%ld) : \n",
                    lpClassDefs[iter].dwNumberOfMandatoryAttributes );
            DumpListOfStrings( lpClassDefs[iter].lpMandatoryAttributes );

            printf( "         Optional Attributes (%ld) : \n",
                    lpClassDefs[iter].dwNumberOfOptionalAttributes );
            DumpListOfStrings( lpClassDefs[iter].lpOptionalAttributes );
            printf( "\n" );
        }

        (void) NwNdsFreeBuffer( hOperationData );
        (void) NwNdsCloseObject( hTree );

        return 0;
    }

    goto Usage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\enum.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Enum.c

Abstract:

   Command line test tool for listing all subordinate objects of an object
   in a NDS tree.

Author:

    Glenn Curtis       [glennc] 25-Jan-96

***/

#include <ndsapi32.h>
#include <nds32.h>
#include <utils.c>


typedef struct
{
    DWORD      Signature;
    HANDLE     NdsTree;
    DWORD      ObjectId;
    DWORD      ResumeId;
    DWORD      NdsRawDataBuffer;
    DWORD      NdsRawDataSize;
    DWORD      NdsRawDataId;
    DWORD      NdsRawDataCount;
    WCHAR      Name[1];

} NDS_OBJECT, * LPNDS_OBJECT;

int
_cdecl main( int argc, char **argv )
{
    DWORD    status = NO_ERROR;
    LPBYTE   lpTemp = NULL;
    DWORD    dwValue;
    DWORD    i;

    HANDLE   hObject;
    HANDLE   hOperationData = NULL;

    LPNDS_ATTR_INFO lpEntries = NULL;
    DWORD            NumberOfEntries = 0;

    OEM_STRING OemArg;
    UNICODE_STRING ObjectName;
    DWORD EntriesReturned;
    DWORD InformationType;
    DWORD ModificationTime;
    WCHAR szObjectName[256];
    WCHAR szObjectRelativeName[NDS_MAX_NAME_CHARS];
    WCHAR szObjectFullName[NDS_MAX_NAME_CHARS];
    WCHAR szObjectClassName[NDS_MAX_NAME_CHARS];

    LPNDS_FILTER_LIST lpFilters = NULL;

    //
    // All this nonsense is for converting ASCII to UNICODE
    //
    UNICODE_STRING Filters[5];
    WCHAR lpFilter1Buf[256];
    WCHAR lpFilter2Buf[256];
    WCHAR lpFilter3Buf[256];
    WCHAR lpFilter4Buf[256];
    WCHAR lpFilter5Buf[256];

    Filters[0].Length = 0;
    Filters[0].MaximumLength = sizeof( lpFilter1Buf );
    Filters[0].Buffer = lpFilter1Buf;

    Filters[1].Length = 0;
    Filters[1].MaximumLength = sizeof( lpFilter2Buf );
    Filters[1].Buffer = lpFilter2Buf;

    Filters[2].Length = 0;
    Filters[2].MaximumLength = sizeof( lpFilter3Buf );
    Filters[2].Buffer = lpFilter3Buf;

    Filters[3].Length = 0;
    Filters[3].MaximumLength = sizeof( lpFilter4Buf );
    Filters[3].Buffer = lpFilter4Buf;

    Filters[4].Length = 0;
    Filters[4].MaximumLength = sizeof( lpFilter5Buf );
    Filters[4].Buffer = lpFilter5Buf;
    //
    // End
    //

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( szObjectName );
    ObjectName.Buffer = szObjectName;

    //
    // Check the arguments.
    //

    if ( argc < 2 || argc > 7 )
    {
        printf( "\nUsage: enum <object DN> [ClassName1] [Class Name2] ... [ClassName5]\n" );
        printf( "\n   where:\n" );
        printf( "   object DN = \\\\tree\\xxx.yyy.zzz\n" );
        printf( "   ClassName = User Group Alias etc.\n" );
        printf( "\nFor Example: enum \\\\MARSDEV\\O=MARS User Group\n\n" );

        return -1;
    }

    if ( argc > 2 )
    {
        lpFilters = (LPNDS_FILTER_LIST) LocalAlloc( LMEM_ZEROINIT,
                                                    sizeof( NDS_FILTER_LIST ) -
                                                    sizeof( NDS_FILTER ) +
                                                    ( sizeof( NDS_FILTER ) *
                                                      argc - 2 ) );

        if ( lpFilters == NULL )
        {
            printf( "\nError: LocalAlloc failed\n\n" );
            return -1;
        }

        lpFilters->dwNumberOfFilters = argc - 2;

        for ( i = 0; i < lpFilters->dwNumberOfFilters; i++ )
        {
            OemArg.Length = strlen( argv[i + 2] );
            OemArg.MaximumLength = OemArg.Length;
            OemArg.Buffer = argv[i + 2];

            RtlOemStringToUnicodeString( &Filters[i], &OemArg, FALSE );

            lpFilters->Filters[i].szObjectClass = Filters[i].Buffer;
        }
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    status = NwNdsOpenObject( ObjectName.Buffer,
                              NULL,
                              NULL,
                              &hObject,
                              (LPWSTR) szObjectRelativeName,
                              (LPWSTR) szObjectFullName,
                              (LPWSTR) szObjectClassName,
                              &ModificationTime,
                              &NumberOfEntries );

    if ( status )
    {
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    printf( "NwNdsOpenObject returned the following data:\n\n" );
    printf( "   Object Relative Name :     %S\n" , szObjectRelativeName );
    printf( "   Object Full Name :         %S\n" , szObjectFullName );
    printf( "   Object Class Name :        %S\n" , szObjectClassName );
    printf( "   Object Modification Time : %ld\n\n" , ModificationTime );
    printf( "   Object Subordinate Count : %ld\n\n" , NumberOfEntries );
    printf( "   Object Handle Info : \n" );
    printf( "      Signature : 0x%.8X\n" ,
            ((LPNDS_OBJECT) hObject)->Signature );
    printf( "      Resume Id : 0x%.8X\n" ,
            ((LPNDS_OBJECT) hObject)->ResumeId );
    printf( "      Object Id : 0x%.8X\n" ,
            ((LPNDS_OBJECT) hObject)->ObjectId );
    printf( "      Name : %S\n\n" ,
            ((LPNDS_OBJECT) hObject)->Name );

    status = NwNdsListSubObjects( hObject,
                                  5,
                                  &EntriesReturned,
                                  lpFilters,
                                  &hOperationData );

    while( status == NO_ERROR )
    {
        DWORD             NumberOfObjects;
        LPNDS_OBJECT_INFO lpObjects;

        printf( "Calling NwNdsListSubObjects return %ld objects.\n",
                EntriesReturned );

        NwNdsGetObjectListFromBuffer( hOperationData,
                                      &NumberOfObjects,
                                      &InformationType,
                                      &lpObjects );

        printf( "-- Calling NwNdsGetObjectListFromBuffer return %ld objects.\n",
                NumberOfObjects );

        DumpObjectsToConsole( NumberOfObjects, InformationType, lpObjects );

        (void) NwNdsFreeBuffer( hOperationData );
        hOperationData = NULL;

        status = NwNdsListSubObjects( hObject,
                                      5,
                                      &EntriesReturned,
                                      lpFilters,
                                      &hOperationData );
    }

    if ( status != NO_ERROR &&
         status != WN_NO_MORE_ENTRIES )
    {
        printf( "\nError: NwNdsListSubObjects returned status 0x%.8X\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );
    }


CleanupAndExit:

    status = NwNdsCloseObject( hObject );

    if ( status )
    {
        printf( "\nError: NwNdsCloseObject returned status 0x%.8X\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );
    }

    if ( hOperationData )
    {
        status = NwNdsFreeBuffer( hOperationData );

        if ( status )
        {
            printf( "\nError: NwNdsFreeBuffer returned status 0x%.8X\n\n", status );
            printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\conninfo.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ConnInfo.c

Abstract:

    Command line test for getting the connection information
    for various connections.

Author:

    Cory West       [corywest] 14-Nov-95

***/

#include "ndsapi32.h"
#include "ntddnwfs.h"

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr;

    WCHAR OpenString[] = L"\\Device\\Nwrdr\\*";
    UNICODE_STRING OpenName;

    OEM_STRING OemArg;
    UNICODE_STRING ConnectionName;
    WCHAR ConnectionBuffer[512];

    ULONG BufferSize = 512;
    ULONG RequestSize, ReplyLen;
    PNWR_REQUEST_PACKET Request;
    BYTE *Reply;

    PCONN_INFORMATION pConnInfo;
    UNICODE_STRING Name;

    //
    // Check the arguments.
    //

    if ( argc != 2 ) {
        printf( "Usage: conninfo [connection name]\n" );
        printf( "For Example: conninfo x:, conninfo lpt1:, or conninfo \\\\server\\share\n" );
        return -1;
    }

    //
    // Allocate buffer space.
    //

    Request = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, BufferSize );

    if ( !Request ) {
       printf( "Insufficient memory to complete the request.\n" );
       return -1;
    }

    //
    // Convert the connect name to unicode.
    //

    ConnectionName.Length = 0;
    ConnectionName.MaximumLength = sizeof( ConnectionBuffer );
    ConnectionName.Buffer = ConnectionBuffer;

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ConnectionName, &OemArg, FALSE );

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &OpenName, OpenString );

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_INFO.
    //

    Request->Parameters.GetConnInfo.ConnectionNameLength = ConnectionName.Length;
    RtlCopyMemory( &(Request->Parameters.GetConnInfo.ConnectionName[0]),
                   ConnectionBuffer,
                   ConnectionName.Length );

    RequestSize = sizeof( Request->Parameters.GetConnInfo ) + ConnectionName.Length;
    Reply = ((PBYTE)Request) + RequestSize;
    ReplyLen = BufferSize - RequestSize;

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_INFO,
                                (PVOID) Request,
                                RequestSize,
                                (PVOID) Reply,
                                ReplyLen );

    if ( !NT_SUCCESS( ntstatus ) ) {
        goto ExitWithClose;
    }

    //
    // Print out the CONN_INFO that is in the reply buffer.
    //

    pConnInfo = (PCONN_INFORMATION) Reply;

    Name.Length = Name.MaximumLength = (USHORT) pConnInfo->HostServerLength;
    Name.Buffer = pConnInfo->HostServer;
    printf( "Host Server: %wZ\n", &Name );

    Name.Length = Name.MaximumLength = (USHORT) pConnInfo->UserNameLength;
    Name.Buffer = pConnInfo->UserName;
    printf( "User Name: %wZ\n", &Name );


ExitWithClose:

   LocalFree( Request );
   NtClose( hRdr );
   return ntstatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\getrghts.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    GetR(i)ghts.c

Abstract:

   Command line test tool for testing the NDS GetEffectiveRights API.

Author:

    Glenn Curtis       [glennc] 22-Apr-96

***/

#include <utils.c>


int
_cdecl main( int argc, char **argv )
{
    DWORD    status = NO_ERROR;

    HANDLE   hObject;

    OEM_STRING OemArg;
    UNICODE_STRING ObjectName;
    WCHAR lpObjectName[256];
    WCHAR TempName[256];
    WCHAR lpSubjectName[256];
    WCHAR lpAttributeName[256];
    DWORD dwRights;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( lpObjectName );
    ObjectName.Buffer = lpObjectName;

    //
    // Check the arguments.
    //

    if ( argc != 2 )
    {
Usage:
        printf( "\nUsage: GetRights <Object Path>\n" );
        printf( "       where: Object Path = \\\\<tree name>\\<Object distiguished name>\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    status = NwNdsOpenObject( ObjectName.Buffer,
                              NULL,
                              NULL,
                              &hObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status )
    {   
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    printf( "Subject name (Ex. joe.sales.acme) : " );
    GetStringOrDefault( lpSubjectName, L"" );

    printf( "Attribute name (Ex. A particular attribute like Surname, [All Attributes Rights],\nor [Entry Rights]) : " );
    GetStringOrDefault( lpAttributeName, L"" );

    status = NwNdsGetEffectiveRights( hObject,
                                      lpSubjectName,
                                      lpAttributeName,
                                      &dwRights );

    if ( status )
    {   
        printf( "\nError: NwNdsGetEffectiveRights returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    printf( "NwNdsGetEffectiveRights returned: 0x%.8X\n\n", dwRights );

    status = NwNdsCloseObject( hObject );

    if ( status )
    {   
        printf( "\nError: NwNdsCloseObject returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\getps.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    GetPs.c

Abstract:

    Command line test for getting the preferred server.

Author:

    Cory West       [corywest] 14-Nov-95

***/

#include "ndsapi32.h"

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr;

    WCHAR OpenString[] = L"\\Device\\Nwrdr\\*";
    UNICODE_STRING OpenName;

    BYTE Reply[64];

    //
    // Check the arguments.
    //

    if ( argc != 1 ) {
        printf( "Usage: getps\n" );
        printf( "Retrieves the current preferred server.\n" );
        return -1;
    }

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &OpenName, OpenString );

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    //
    // Call the nwrdr.
    //

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_PREFERRED_SERVER,
                                NULL,
                                0,
                                (PVOID) Reply,
                                sizeof( Reply ) );

    if ( !NT_SUCCESS( ntstatus ) ) {
        printf( "No preferred server is currently set.\n" );
        goto ExitWithClose;
    }

    //
    // On success the output buffer contains a UNICODE_STRING
    // with the string packed in afterwards.
    //

    printf( "Preferred Server: %wZ\n", (PUNICODE_STRING) Reply );

ExitWithClose:

   NtClose( hRdr );
   return ntstatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\list.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ListAttr.c

Abstract:

   Command line test tool for listing all attributes of an object in a NDS tree.

Author:

    Glenn Curtis       [glennc] 25-Jan-96

***/

#include <utils.c>


int
_cdecl main( int argc, char **argv )
{
    DWORD    status = NO_ERROR;
    LPBYTE   lpTemp = NULL;
    DWORD    dwValue;

    HANDLE   hObject;
    HANDLE   hOperationData = NULL;

    //
    // For GetFromBuffer function calls
    //
    LPNDS_ATTR_INFO lpEntries = NULL;
    DWORD           NumberOfEntries = 0;

    OEM_STRING OemArg;
    UNICODE_STRING ObjectName;
    WCHAR lpObjectName[256];
    WCHAR szClassName[256];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( lpObjectName );
    ObjectName.Buffer = lpObjectName;

    //
    // Check the arguments.
    //

    if ( argc != 2 )
    {
        printf( "\nUsage: list <object DN>\n" );
        printf( "\n   where:\n" );
        printf( "   object DN = \\\\tree\\xxx.yyy.zzz\n" );
        printf( "\nFor Example: list \\\\MARSDEV\\CN=TEST.OU=DEV.O=MARS\n\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    status = NwNdsOpenObject( ObjectName.Buffer,
                              NULL,
                              NULL,
                              &hObject,
                              NULL,
                              NULL,
                              szClassName,
                              NULL,
                              NULL );

    if ( status )
    {
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    printf("Class Name is %ws\n", szClassName);

    status = NwNdsReadObject( hObject, NDS_INFO_NAMES_DEFS, &hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsReadObject returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    status = NwNdsCloseObject( hObject );

    if ( status )
    {
        printf( "\nError: NwNdsCloseObject returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    status = NwNdsGetAttrListFromBuffer( hOperationData,
                                         &NumberOfEntries,
                                         &lpEntries );

    if ( status )
    {
        printf( "\nError: NwNdsGetAttrListFromBuffer returned status 0x%.8X\n",
                status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    PrintObjectAttributeNamesAndValues( argv[1],
                                        argv[2],
                                        NumberOfEntries,
                                        lpEntries );

    status = NwNdsFreeBuffer( hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsFreeBuffer returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\listconn.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ListConn.c

Abstract:

    Command line test for getting the CONN_STATUS structures
    for various connections.

Author:

    Cory West       [corywest] 14-Nov-95

***/

#include "ndsapi32.h"
#include "ntddnwfs.h"

ULONG DumpConnStatus(
    PCONN_STATUS pStatus
);

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr;

    WCHAR OpenString[] = L"\\Device\\Nwrdr\\*";
    UNICODE_STRING OpenName;

    OEM_STRING OemArg;
    UNICODE_STRING NdsTree;
    WCHAR TreeBuffer[64];

    ULONG BufferSize = 256;
    ULONG RequestSize, ReplyLen;
    PNWR_REQUEST_PACKET Request;
    BYTE *Reply, *LocalBlock;
    DWORD Entries, BlockLen;

    //
    // Check the arguments.
    //

    if ( argc > 2 ) {
        printf( "Usage: listconn [tree | server]\n" );
        return -1;
    }

    //
    // Allocate buffer space.
    //

    Request = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, BufferSize );

    if ( !Request ) {
       printf( "Insufficient memory to complete the request.\n" );
       return -1;
    }

    //
    // Convert the argument name to unicode.
    //

    NdsTree.Length = 0;
    NdsTree.MaximumLength = sizeof( TreeBuffer );
    NdsTree.Buffer = TreeBuffer;

    if ( argc == 2 ) {

        OemArg.Length = strlen( argv[1] );
        OemArg.MaximumLength = OemArg.Length;
        OemArg.Buffer = argv[1];

        NdsTree.Length = 0;
        NdsTree.MaximumLength = sizeof( TreeBuffer );
        NdsTree.Buffer = TreeBuffer;

        RtlOemStringToUnicodeString( &NdsTree, &OemArg, FALSE );

    }

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &OpenName, OpenString );

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_STATUS.
    //

    Request->Parameters.GetConnStatus.ConnectionNameLength = NdsTree.Length;
    RtlCopyMemory( &(Request->Parameters.GetConnStatus.ConnectionName[0]),
                   TreeBuffer,
                   NdsTree.Length );

    RequestSize = sizeof( NWR_REQUEST_PACKET ) + NdsTree.Length;
    Reply = ((PBYTE)Request) + RequestSize;
    ReplyLen = BufferSize - RequestSize;

    do {

        ntstatus = NtFsControlFile( hRdr,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_GET_CONN_STATUS,
                                    (PVOID) Request,
                                    RequestSize,
                                    (PVOID) Reply,
                                    ReplyLen );

        if ( !NT_SUCCESS( ntstatus ) ) {
            goto ExitWithClose;
        }

        //
        // Print out this batch and see if we need to continue.
        //
        // ATTN!!!  The only time that the caller needs to resize
        // the buffer is when there are no entries returned and the
        // status is STATUS_BUFFER_TOO_SMALL.  When this happens,
        // the BytesNeeded field contains the smallest usable
        // buffer size.
        //

        Entries = Request->Parameters.GetConnStatus.EntriesReturned;
        printf( "%d entries returned for this call.\n", Entries );

        LocalBlock = Reply;

        while ( Entries-- ) {

            BlockLen = DumpConnStatus( (PCONN_STATUS) LocalBlock );
            LocalBlock += BlockLen;
        }

    } while ( Request->Parameters.GetConnStatus.ResumeKey != 0 );


ExitWithClose:

   LocalFree( Request );
   NtClose( hRdr );
   return ntstatus;

}

ULONG DumpConnStatus(
    PCONN_STATUS pStatus
) {

    printf( "--------------------------------------------\n" );

    printf( "Server: %S\n", pStatus->pszServerName );
    printf( "User: %S\n", pStatus->pszUserName );
    printf( "NDS Tree: %S\n", pStatus->pszTreeName );

    printf( "Connection Number: %d\n", pStatus->nConnNum );

    if ( pStatus->fNds ) {
        printf( "Nds Connection: TRUE\n" );
    } else {
       printf( "Nds Connection: FALSE\n" );
    }

    if ( pStatus->fPreferred ) {
        printf( "Preferred Server: TRUE\n" );
    } else {
       printf( "Preferred Server: FALSE\n" );
    }

    switch ( pStatus->dwConnType ) {

    case NW_CONN_NOT_AUTHENTICATED:

        printf( "Authentication: NOT AUTHENTICATED\n" );
        break;

    case NW_CONN_BINDERY_LOGIN:

        printf( "Authentication: BINDERY LOGIN\n" );
        break;

    case NW_CONN_NDS_AUTHENTICATED_NO_LICENSE:

        printf( "Authentication: NDS AUTHENTICATED, NOT LICENSED\n" );
        break;

    case NW_CONN_NDS_AUTHENTICATED_LICENSED:

        printf( "Authentication: NDS AUTHENTICATED, LICENSED\n" );
        break;

    case NW_CONN_DISCONNECTED:

        printf( "Authentication: DISCONNECTED\n" );
        break;

    }

    printf( "--------------------------------------------\n" );

    return pStatus->dwTotalLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\getuser.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    GetUser.c

Abstract:

    This is the command line NDS utility for getting the
    user name used to log into a specified tree or server.

Author:

    Cory West       [corywest]  25-Oct-95

***/

#include "ndsapi32.h"

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr;

    WCHAR DevicePreamble[] = L"\\Device\\Nwrdr\\";
    UINT PreambleLength = 14;

    WCHAR NameStr[64];
    UNICODE_STRING OpenName;
    UINT i;

    OEM_STRING OemArg;
    UNICODE_STRING NdsTree;
    WCHAR TreeBuffer[64];

    WCHAR Reply[64];

    //
    // Check the arguments.
    //

    if ( argc != 2 ) {
        printf( "Usage: getuser [tree | server]\n" );
        return -1;
    }

    //
    // Copy over the preamble.
    //

    OpenName.MaximumLength = sizeof( NameStr );

    for ( i = 0; i < PreambleLength ; i++ )
        NameStr[i] = DevicePreamble[i];

    //
    // Convert the argument name to unicode.
    //

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    NdsTree.Length = 0;
    NdsTree.MaximumLength = sizeof( TreeBuffer );
    NdsTree.Buffer = TreeBuffer;

    RtlOemStringToUnicodeString( &NdsTree, &OemArg, FALSE );

    //
    // Copy the server or tree name.
    //

    for ( i = 0 ; i < ( NdsTree.Length / sizeof( WCHAR ) ) ; i++ ) {
        NameStr[i + PreambleLength] = NdsTree.Buffer[i];
    }

    OpenName.Length = ( i * sizeof( WCHAR ) ) +
		       ( PreambleLength * sizeof( WCHAR ) );
    OpenName.Buffer = NameStr;

    //
    // Set up the object attributes.
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
				NULL,
				NULL,
				&IoStatusBlock,
				FSCTL_NWR_GET_USERNAME,
				(PVOID) TreeBuffer,
				NdsTree.Length,
				(PVOID) Reply,
				sizeof( Reply ) );

   if ( NT_SUCCESS( ntstatus )) {

       NdsTree.Length = (USHORT)IoStatusBlock.Information;
       NdsTree.MaximumLength = NdsTree.Length;
       NdsTree.Buffer = Reply;
       printf( "%wZ", &NdsTree );
   }

   NtClose( hRdr );
   return ntstatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\moveobj.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    MoveObj.c

Abstract:

    Command line test tool for moving an object in a NDS tree.

Author:

    Glenn Curtis       [glennc] 05-Jan-96

***/

#include <utils.c>


int
_cdecl main( int argc, char **argv )
{
    DWORD      status = NO_ERROR;

    HANDLE     hObject = NULL;

    OEM_STRING OemArg;
    UNICODE_STRING ObjectName;
    WCHAR lpObjectName[256];
    UNICODE_STRING DestContainerName;
    WCHAR lpDestContainerName[256];

    //
    // Check the arguments.
    //

    if ( argc != 3 )
    {
        printf( "\nUsage: moveobj <object DN> <destination container DN>\n" );
        printf( "\n   where:\n" );
        printf( "   object DN = \\\\tree\\xxx.yyy.zzz\n" );
        printf( "   destination container DN = \\\\tree\\zzz\n" );
        printf( "\nFor Example:\n" );
        printf( "    moveobj \\\\MARSDEV\\CN=FRED.OU=DEV.O=MARS \\\\MARSDEV\\O=MARS\n\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( lpObjectName );
    ObjectName.Buffer = lpObjectName;

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    status = NwNdsOpenObject( ObjectName.Buffer,
                              NULL,
                              NULL,
                              &hObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status )
    {
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    //
    // Prepare the new object's name
    //
    OemArg.Length = strlen( argv[2] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[2];

    DestContainerName.Length = 0;
    DestContainerName.MaximumLength = sizeof( lpDestContainerName );
    DestContainerName.Buffer = lpDestContainerName;

    RtlOemStringToUnicodeString( &DestContainerName, &OemArg, FALSE );

    printf( "Moving the object in the tree\n" );

    status = NwNdsMoveObject( hObject, DestContainerName.Buffer );

    if ( status )
    {
        printf( "\nError: NwNdsMoveObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    status = NwNdsCloseObject( hObject );

    if ( status )
    {
        printf( "\nError: NwNdsCloseObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    printf( "\nSuccess!\n\n" );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\ndschpw.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsChPw.c

Abstract:

    This is the command line NDS utility for changing a
    user's NDS password.

Author:

    Cory West       [corywest]  12-Jan-96

***/

#include <ndsapi32.h>
#include <nds.h>

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr;

    WCHAR DevicePreamble[] = L"\\Device\\Nwrdr\\";
    UINT PreambleLength = 14;

    UNICODE_STRING OpenName;
    WCHAR NameStr[64];
    UINT i;

    OEM_STRING OemArg;

    UNICODE_STRING NdsTree;
    WCHAR TreeBuffer[MAX_NDS_TREE_NAME_LEN];

    UNICODE_STRING UserName;
    WCHAR UserBuffer[MAX_NDS_NAME_CHARS];

    UNICODE_STRING CurrPass;
    WCHAR CurrPassBuffer[64];

    UNICODE_STRING NewPass;
    WCHAR NewPassBuffer[64];

    //
    // Check the arguments.
    //

    if ( argc != 5 ) {
        printf( "Usage: ndschpw tree user current_pw new_pw\n" );
        return -1;
    }

    //
    // Copy over the preamble.
    //

    OpenName.MaximumLength = sizeof( NameStr );

    for ( i = 0; i < PreambleLength ; i++ )
        NameStr[i] = DevicePreamble[i];

    //
    // Convert the argument name to unicode.
    //

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    NdsTree.Length = 0;
    NdsTree.MaximumLength = sizeof( TreeBuffer );
    NdsTree.Buffer = TreeBuffer;

    RtlOemStringToUnicodeString( &NdsTree, &OemArg, FALSE );

    //
    // Copy the server or tree name.
    //

    for ( i = 0 ; i < ( NdsTree.Length / sizeof( WCHAR ) ) ; i++ ) {
        NameStr[i + PreambleLength] = NdsTree.Buffer[i];
    }

    OpenName.Length = ( i * sizeof( WCHAR ) ) +
                       ( PreambleLength * sizeof( WCHAR ) );
    OpenName.Buffer = NameStr;

    //
    // Set up the object attributes.
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    //
    // Convert the other args to unicode.
    //

    OemArg.Length = strlen( argv[2] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[2];

    UserName.Length = 0;
    UserName.MaximumLength = sizeof( UserBuffer );
    UserName.Buffer = UserBuffer;

    RtlOemStringToUnicodeString( &UserName, &OemArg, FALSE );

    OemArg.Length = strlen( argv[3] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[3];

    CurrPass.Length = 0;
    CurrPass.MaximumLength = sizeof( CurrPassBuffer );
    CurrPass.Buffer = CurrPassBuffer;

    RtlOemStringToUnicodeString( &CurrPass, &OemArg, FALSE );

    OemArg.Length = strlen( argv[4] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[4];

    NewPass.Length = 0;
    NewPass.MaximumLength = sizeof( NewPassBuffer );
    NewPass.Buffer = NewPassBuffer;

    RtlOemStringToUnicodeString( &NewPass, &OemArg, FALSE );

    //
    // Submit the request.
    //

    ntstatus = NwNdsChangePassword( hRdr,
                                    &NdsTree,
				    &UserName,
				    &CurrPass,
				    &NewPass );

   if ( NT_SUCCESS( ntstatus )) {
       printf( "Password changed.\n" );
   } else {
       printf( "Password change failed!\n" );
   }

   NtClose( hRdr );
   return ntstatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\modobj.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ModObj.c

Abstract:

    Command line test tool for modifying an object in a NDS tree.

Author:

    Glenn Curtis       [glennc] 05-Jan-96

***/

#include <utils.c>


int
_cdecl main( int argc, char **argv )
{
    DWORD      status = NO_ERROR;

    HANDLE     hObject = NULL;
    HANDLE     hOperationData = NULL;

    OEM_STRING OemArg;
    UNICODE_STRING ObjectName;
    WCHAR lpObjectName[256];
    WCHAR lpTextBuffer[256];
    ASN1_TYPE_11 asn11;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( lpObjectName );
    ObjectName.Buffer = lpObjectName;

    asn11.TelephoneNumber = (LPWSTR) lpTextBuffer;
    asn11.NumberOfBits = 0;
    asn11.Parameters = NULL;

    //
    // Check the arguments.
    //
    if ( argc != 2 )
    {
        printf( "Usage: modobj <object DN>\n" );
        printf( "For Example: modobj \\\\MARSDEV\\CN=TESTUSER.OU=DEV.O=MARS\n" );
        printf( "\nUsage: modobj <object DN>\n" );
        printf( "\n   where:\n" );
        printf( "   object DN = \\\\tree\\xxx.yyy.zzz\n" );
        printf( "\nFor Example:\n" );
        printf( "    modobj \\\\MARSDEV\\CN=TEST.OU=DEV.O=MARS\n\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    status = NwNdsOpenObject( ObjectName.Buffer,
                              NULL,
                              NULL,
                              &hObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status )
    {
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    //
    // Prepare buffer with list of attribute changes
    //
    status = NwNdsCreateBuffer( NDS_OBJECT_MODIFY, &hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n\n", status );

        return -1;
    }

    printf( "Put value NDS_FAX_NUMBER, NDS_ATTR_CLEAR into attributes buffer\n" );

    status = NwNdsPutInBuffer( NDS_FAX_NUMBER,
                               NULL,
                               0,
                               NDS_ATTR_CLEAR,
                               hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n\n", status );

        return -1;
    }

    wcscpy( asn11.TelephoneNumber, L"1 (425) 936-9687" );

    printf( "Put value NDS_FAX_NUMBER, NDS_ATTR_ADD:\"1 (425) 936-9687\" into attributes buffer\n" );

    status = NwNdsPutInBuffer( NDS_FAX_NUMBER,
                               &asn11,
                               1,
                               NDS_ATTR_ADD,
                               hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n\n", status );

        return -1;
    }

    printf( "Modifying the object in tree\n" );

    status = NwNdsModifyObject( hObject, hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsModifyObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    status = NwNdsFreeBuffer( hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsFreeBuffer returned status 0x%.8X\n\n", status );

        return -1;
    }

    status = NwNdsCloseObject( hObject );

    if ( status )
    {
        printf( "\nError: NwNdsCloseObject returned status 0x%.8X\n\n", status );

        return -1;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\netperf.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    netperf.c

Abstract:

    Command line test for getting the connection performance.

Author:

    Cory West       [corywest] 17-April-96

***/

#include "ndsapi32.h"
#include "ntddnwfs.h"

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr;

    WCHAR OpenString[] = L"\\Device\\Nwrdr\\*";
    UNICODE_STRING OpenName;

    OEM_STRING OemArg;
    UNICODE_STRING ConnectionName;

    PNWR_REQUEST_PACKET Request;
    ULONG BufferSize = 512;
    ULONG RequestSize;

    //
    // Check the arguments.
    //

    if ( argc != 2 ) {
        printf( "Usage: netperf [remote name]\n" );
        return -1;
    }

    //
    // Allocate buffer space.
    //

    Request = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT, BufferSize );

    if ( !Request ) {
       printf( "Insufficient memory to complete the request.\n" );
       return -1;
    }

    //
    // Convert the connect name to unicode.
    //

    ConnectionName.Length = 0;
    ConnectionName.MaximumLength = (USHORT) ( BufferSize - sizeof( NWR_REQUEST_PACKET ) );
    ConnectionName.Buffer = &(Request->Parameters.GetConnPerformance.RemoteName[0]);

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ConnectionName, &OemArg, FALSE );

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &OpenName, OpenString );

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_PERFORMANCE.
    //

    Request->Parameters.GetConnPerformance.RemoteNameLength = ConnectionName.Length;
    RequestSize = sizeof( NWR_REQUEST_PACKET ) + ConnectionName.Length;

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_PERFORMANCE,
                                (PVOID) Request,
                                RequestSize,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( ntstatus ) ) {
        goto ExitWithClose;
    }

    //
    // Print out the speed and packet size.
    //

    printf( "Speed: %d\n", Request->Parameters.GetConnPerformance.dwSpeed );
    printf( "Flags: %d\n", Request->Parameters.GetConnPerformance.dwFlags );
    printf( "Delay: %d\n", Request->Parameters.GetConnPerformance.dwDelay );
    printf( "Packet Size: %d\n", Request->Parameters.GetConnPerformance.dwOptDataSize );


ExitWithClose:

   LocalFree( Request );
   NtClose( hRdr );
   return ntstatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\newname.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NewName.c

Abstract:

   Command line test tool for renaming an object in a NDS tree.

Author:

    Glenn Curtis       [glennc] 25-Jan-96

***/

#include <ndsapi32.h>
#include <nds32.h>


int
_cdecl main( int argc, char **argv )
{
    DWORD    status = NO_ERROR;
    LPBYTE   lpTemp = NULL;
    DWORD    dwValue;
    DWORD    i;

    HANDLE   hParentObject;
    HANDLE   hOperationData = NULL;

    OEM_STRING OemArg;
    UNICODE_STRING ParentObjectName;
    UNICODE_STRING OldObjectName;
    UNICODE_STRING NewObjectName;
    WCHAR szParentObjectName[256];
    WCHAR szOldObjectName[256];
    WCHAR szNewObjectName[256];

    ParentObjectName.Length = 0;
    ParentObjectName.MaximumLength = sizeof( szParentObjectName );
    ParentObjectName.Buffer = szParentObjectName;

    OldObjectName.Length = 0;
    OldObjectName.MaximumLength = sizeof( szOldObjectName );
    OldObjectName.Buffer = szOldObjectName;

    NewObjectName.Length = 0;
    NewObjectName.MaximumLength = sizeof( szNewObjectName );
    NewObjectName.Buffer = szNewObjectName;

    //
    // Check the arguments.
    //

    if ( argc != 4 )
    {
        printf( "\nUsage: newname <parent object DN> <object name> <new object name>\n" );
        printf( "\n   where:\n" );
        printf( "   parent object DN = \\\\tree\\aaa.bbb\n" );
        printf( "   object name = foo\n" );
        printf( "   new object name = bar\n" );
        printf( "\nFor Example: newname \\\\MARSDEV\\OU=DEV.O=MARS glennc glenn_curtis\n\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ParentObjectName, &OemArg, FALSE );

    OemArg.Length = strlen( argv[2] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[2];

    RtlOemStringToUnicodeString( &OldObjectName, &OemArg, FALSE );

    OemArg.Length = strlen( argv[3] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[3];

    RtlOemStringToUnicodeString( &NewObjectName, &OemArg, FALSE );

    status = NwNdsOpenObject( ParentObjectName.Buffer,
                              NULL,
                              NULL,
                              &hParentObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status )
    {
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    status = NwNdsRenameObject( hParentObject,
                                OldObjectName.Buffer,
                                NewObjectName.Buffer,
                                TRUE );

    if ( status != NO_ERROR )
    {
        printf( "\nError: NwNdsRenameObject returned status 0x%.8X\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );
    }
    else
    {
        printf( "\nNwNdsRenameObject succeeded!\n\n" );
    }

    status = NwNdsCloseObject( hParentObject );

    if ( status )
    {
        printf( "\nError: NwNdsCloseObject returned status 0x%.8X\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\rdstrm.c ===
//
// NDS File Stream Cat
// Cory West
//

#include "ndsapi32.h"
#include <nds.h>

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS Status;

    //
    // For NwNdsOpenTreeHandle
    //

    HANDLE hRdr;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    WCHAR NdsStr[1024];

    //
    // For NwNdsResolveName
    //

    PNDS_RESPONSE_RESOLVE_NAME psResolveName;
    DWORD dwOid;
    HANDLE hReferredServer;
    DWORD dwHandleType;
    UNICODE_STRING ReferredServer;
    WCHAR ServerName[48];

    //
    // For ReadFile of an open stream.
    //

    DWORD dwBytesRead, dwFileLength, dwBytesShown;
    BOOL bRead;
    BYTE RawResponse[1024];

    /**************************************************/

    //
    // Examine the argument count and hope for the best.
    //

    if ( argc < 3 ) {
       printf( "Usage: rdstrm <tree name> <ds object path> <file stream>\n" );
       printf( "For example, rdstrm tree user.orgunit.org \"Login Script\"\n");
       return -1;
    }

    //
    // Convert the tree name string to unicode.
    //

    oemStr.Length = strlen( argv[1] );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = argv[1];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( NdsStr );
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    //
    // Get a handle to the redirector.
    //

    Status = NwNdsOpenTreeHandle( &ObjectName, &hRdr );

    if ( !NT_SUCCESS( Status ) ) {
        printf( "The tree is not available. Status was %08lx.\n", Status );
        return -1;
    }

    //
    // Resolve the name that we have to an object id.
    //

    oemStr.Length = strlen(argv[2]);
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = argv[2];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerName;
    ReferredServer.MaximumLength = sizeof( ServerName );
    ReferredServer.Length = 0;

    Status = NwNdsResolveName ( hRdr,
                                &ObjectName,
                                &dwOid,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       printf( "The object is not available.  Status = %08lx.\n", Status );
       goto Exit;
    }

    if ( ReferredServer.Length != 0 ) {

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            printf( "The object's referred server is not available.  Status = %08lx.\n", Status );
            goto Exit;
        }

        CloseHandle( hRdr );
        hRdr = hReferredServer;
    }

    //
    // Try to open a file stream for read access.
    //

    oemStr.Length = strlen(argv[3]);
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = argv[3];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    Status = NwNdsOpenStream( hRdr,
                              dwOid,
                              &ObjectName,
                              1,
                              &dwFileLength );

    if ( !NT_SUCCESS( Status ) ) {
        printf( "The file stream is not available.  Status = %08lx.\n", Status );
        goto Exit;
    }

    //
    // Dump the file stream.
    //

    printf( "---------- There are %d bytes in file stream %s ----------\n", dwFileLength, argv[3] );

    while ( dwFileLength ) {

        bRead = ReadFile( hRdr,
                          RawResponse,
                          sizeof( RawResponse ),
                          &dwBytesRead,
                          NULL );

        if ( !bRead ) {

            printf( "*** Couldn't read data from file stream.\n" );
            goto Exit;
        }

        dwFileLength -= dwBytesRead;
        dwBytesShown = 0;

        while ( dwBytesRead-- ) {
            printf( "%c", RawResponse[dwBytesShown++] );
        }


    }

    printf( "\n-----------------------------------------------------------------------\n" );

Exit:

    CloseHandle( hRdr );

    if ( !NT_SUCCESS( Status )) {
        return -1;
    } else {
        return 0;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\readobj.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ReadObj.c

Abstract:

    Command line test tool for reading attributes of an object in a NDS tree.

Author:

    Glenn Curtis       [glennc] 05-Jan-96

***/

#include <utils.c>


int
_cdecl main( int argc, char **argv )
{
    DWORD    status = NO_ERROR;
    LPBYTE   lpTemp = NULL;
    DWORD    dwValue;

    HANDLE   hObject = NULL;
    HANDLE   hOperationData = NULL;

    OEM_STRING OemArg;
    UNICODE_STRING ObjectName;
    WCHAR lpObjectName[256];

    //
    // For GetFromBuffer function calls
    //
    LPNDS_ATTR_INFO lpEntries = NULL;
    LPBYTE          lpValue = NULL;
    WCHAR *         lpAttributeName = NULL;
    DWORD           SyntaxId = 0;
    DWORD           NumberOfValues = 0;
    DWORD           NumberOfEntries = 0;
    DWORD           NumberOfEntriesRemaining = 0;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( lpObjectName );
    ObjectName.Buffer = lpObjectName;

    //
    // Check the arguments.
    //

    if ( argc != 2 )
    {
        printf( "\nUsage: readobj <object DN>\n" );
        printf( "\n   where:\n" );
        printf( "   object DN = \\\\tree\\xxx.yyy.zzz\n" );
        printf( "\nFor Example: readobj \\\\MARSDEV\\CN=TEST.OU=DEV.O=MARS\n\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    if ( status = NwNdsOpenObject( ObjectName.Buffer,
                                   NULL,
                                   NULL,
                                   &hObject,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL ) != NO_ERROR )
    {
        printf( "\nError: NwNdsOpenObject returned status %ld\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    //
    // Prepare buffer with list of attributes to read
    //
    if ( status = NwNdsCreateBuffer( NDS_OBJECT_READ,
                                     &hOperationData )
         != NO_ERROR )
    {
        printf( "\nError: NwNdsCreateBuffer returned status %ld\n\n",
                status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    printf( "Put value NDS_COMMON_NAME into attributes buffer\n" );

    if ( status = NwNdsPutInBuffer( NDS_COMMON_NAME,
                                    NULL,
                                    0,
                                    0,
                                    hOperationData )
         != NO_ERROR )
    {
        printf( "\nError: NwNdsPutInBuffer returned status %ld\n\n",
                status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    printf( "Put value NDS_ORGANIZATIONAL_UNIT_NAME into attributes buffer\n" );

    if ( status = NwNdsPutInBuffer( NDS_ORGANIZATIONAL_UNIT_NAME,
                                    NULL,
                                    0,
                                    0,
                                    hOperationData )
         != NO_ERROR )
    {
        printf( "\nError: NwNdsPutInBuffer returned status %ld\n\n",
                status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    printf( "Put value NDS_ORGANIZATION_NAME into attributes buffer\n" );

    if ( status = NwNdsPutInBuffer( NDS_ORGANIZATION_NAME,
                                    NULL,
                                    0,
                                    0,
                                    hOperationData )
         != NO_ERROR )
    {
        printf( "\nError: NwNdsPutInBuffer returned status %ld\n\n",
                status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    printf( "Reading object attributes from the tree\n" );

    if ( status = NwNdsReadObject( hObject, NDS_INFO_NAMES_DEFS, &hOperationData ) != NO_ERROR )
    {
        printf( "\nError: NwNdsReadObject returned status %ld\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    if ( status = NwNdsGetAttrListFromBuffer( hOperationData,
                                              &NumberOfEntries,
                                              &lpEntries )
         != NO_ERROR )
    {
        printf( "\nError: NwNdsGetAttrListFromBuffer returned status %ld\n\n",
                status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    if ( status = NwNdsFreeBuffer( hOperationData ) != NO_ERROR )
    {
        printf( "\nError: NwNdsFreeBuffer returned status %ld\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    hOperationData = NULL;

    printf( "Now reading ALL object attributes from the tree\n" );

    if ( status = NwNdsReadObject( hObject,
                                   NDS_INFO_NAMES_DEFS,
                                   &hOperationData )
         != NO_ERROR )
    {
        printf( "\nError: NwNdsReadObject returned status %ld\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    if ( status = NwNdsCloseObject( hObject ) != NO_ERROR )
    {
        printf( "\nError: NwNdsCloseObject returned status %ld\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    if ( status = NwNdsGetAttrListFromBuffer( hOperationData,
                                              &NumberOfEntries,
                                              &lpEntries )
         != NO_ERROR )
    {
        printf( "\nError: NwNdsGetAttrListFromBuffer returned status %ld\n\n",
                status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    if ( status = NwNdsFreeBuffer( hOperationData ) != NO_ERROR )
    {
        printf( "\nError: NwNdsFreeBuffer returned status %ld\n\n", status );
        printf( "\nError: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\sbrowser.c ===
//
// NDS Browser Test App for Supplemental Credentials
//
// Cory West
// July 22, 1996
//

#include "ndsapi32.h"
#include "nds.h"

VOID
ConsoleDumpSubordinates(
    PNDS_RESPONSE_SUBORDINATE_LIST pSubList
);

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS Status;

    //
    // For NwNdsOpenTreeHandle
    //

    HANDLE hRdr;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;
    WCHAR NdsStr[256];
    WCHAR UserStr[256];
    WCHAR PassStr[256];

    //
    // For NwNdsResolveName
    //

    PNDS_RESPONSE_RESOLVE_NAME psResolveName;
    DWORD dwOid;
    UNICODE_STRING ReferredServer;
    WCHAR ServerName[48];
    HANDLE hReferredServer;
    DWORD dwHandleType;

    //
    // For NwNdsReadObjectInfo
    //

    BYTE RawResponse[1024];
    PNDS_RESPONSE_GET_OBJECT_INFO psGetInfo;
    PBYTE pbRawGetInfo;
    DWORD dwStrLen;

    //
    // For NwNdsList
    //

    DWORD dwIterHandle;

    /**************************************************/

    //
    // Examine the argument count and hope for the best.
    //

    if ( argc != 5 ) {
       printf( "Usage: browser <tree name> <ds object path> <username> <password>\n" );
       printf( "For example, browser marsdev dev.mars corywest corywest.dev.mars\n");
       return -1;
    }

    //
    // Convert the tree name string to unicode.
    //

    oemStr.Length = strlen( argv[1] );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = argv[1];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( NdsStr );
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    //
    // Convert the username and password.
    //

    oemStr.Length = strlen( argv[3] );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = argv[3];

    UserName.Length = 0;
    UserName.MaximumLength = sizeof( UserStr );
    UserName.Buffer = UserStr;

    RtlOemStringToUnicodeString( &UserName, &oemStr, FALSE );

    oemStr.Length = strlen( argv[4] );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = argv[4];

    Password.Length = 0;
    Password.MaximumLength = sizeof( PassStr );
    Password.Buffer = PassStr;

    RtlOemStringToUnicodeString( &Password, &oemStr, FALSE );

    //
    // Get a handle to the redirector.
    //

    Status = NwOpenHandleWithSupplementalCredentials( &ObjectName,
                                                      &UserName,
                                                      &Password,
                                                      &dwHandleType,
                                                      &hRdr );

    if ( !NT_SUCCESS( Status ) ) {
        printf( "*** Open Handle to Nds Tree: Status = %08lx\n", Status );
        return -1;
    }

    //
    // Resolve the name that we have to an object id.
    //

    oemStr.Length = strlen(argv[2]);
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = argv[2];

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerName;
    ReferredServer.MaximumLength = sizeof( ServerName );
    ReferredServer.Length = 0;

    Status = NwNdsResolveName ( hRdr,
                                &ObjectName,
                                &dwOid,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       printf( "*** Resolve Name: Status = %08lx\n", Status );
       goto Exit;
    }

    if ( ReferredServer.Length != 0 ) {

        //
        // We have to jump servers.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            printf( "*** Couldn't open referred server: Status = %08lx\n", Status );
            goto Exit;
        }

        CloseHandle( hRdr );
        hRdr = hReferredServer;
    }

    printf( "=========================== NDS Object Info ===========================\n" );
    printf( "Object ID = 0x%08lx\n", dwOid );

    //
    // Go for the object information.
    //

    Status = NwNdsReadObjectInfo( hRdr,
                                  dwOid,
                                  RawResponse,
                                  sizeof( RawResponse ) );

    if ( !NT_SUCCESS( Status ) ) {
        printf( "*** Get Object Info: Status = %08lx\n", Status );
        goto Exit;
    }

    psGetInfo = ( PNDS_RESPONSE_GET_OBJECT_INFO ) RawResponse;

    printf( "Flags = 0x%08lx\n", psGetInfo->EntryFlags );
    printf( "Subordinate Count = 0x%08lx\n", psGetInfo->SubordinateCount );
    printf( "Last Modified Time = 0x%08lx\n", psGetInfo->ModificationTime );

    //
    // Dig out the two unicode strings for class name and object name.
    //

    pbRawGetInfo = RawResponse;

    pbRawGetInfo += sizeof ( NDS_RESPONSE_GET_OBJECT_INFO );

    dwStrLen = * ( DWORD * ) pbRawGetInfo;
    pbRawGetInfo += sizeof( DWORD );
    printf( "Class Name: %S\n", pbRawGetInfo );

    pbRawGetInfo += ROUNDUP4( dwStrLen );
    dwStrLen = * ( DWORD * ) pbRawGetInfo;
    pbRawGetInfo += sizeof( DWORD );
    printf( "Object Name: %S\n", pbRawGetInfo );

    //
    // Get the subordinate list.
    //

    if ( psGetInfo->SubordinateCount ) {

        dwIterHandle = INITIAL_ITERATION;

        do {

            Status = NwNdsList( hRdr,
                                dwOid,
                                &dwIterHandle,
                                RawResponse,
                                sizeof( RawResponse ) );

            if ( !NT_SUCCESS( Status ) ) {
                printf( "*** List Subordinates: Status = %08lx\n", Status );
                goto Exit;
            }

        ConsoleDumpSubordinates( (PNDS_RESPONSE_SUBORDINATE_LIST) RawResponse );

        } while ( dwIterHandle != INITIAL_ITERATION );

    }


Exit:

    CloseHandle( hRdr );

    if ( NT_SUCCESS( Status ) ) {
       return 0;
    } else {
       return -1;
    }

}


VOID
ConsoleDumpSubordinates(
    PNDS_RESPONSE_SUBORDINATE_LIST pSubList
) {

    NTSTATUS Status;
    PNDS_RESPONSE_SUBORDINATE_ENTRY pSubEntry;

    PBYTE pbRaw;
    DWORD dwStrLen, dwEntries;

    dwEntries = pSubList->SubordinateEntries;

    printf( "======================== Subordinate List (%d) ========================\n", dwEntries );

    pSubEntry = ( PNDS_RESPONSE_SUBORDINATE_ENTRY )
        ( ( (BYTE *)pSubList ) + sizeof( NDS_RESPONSE_SUBORDINATE_LIST ) );

    while ( dwEntries ) {

        printf( "EntryID (0x%08lx),\tFlags (0x%08lx)\n",
                pSubEntry->EntryId, pSubEntry->Flags );

        printf( "Subordinate Count (%d),\tMod Time (0x%08lx)\n",
                pSubEntry->SubordinateCount, pSubEntry->ModificationTime );

        pbRaw = (BYTE *) pSubEntry;
        pbRaw += sizeof( NDS_RESPONSE_SUBORDINATE_ENTRY );

        dwStrLen = * ( DWORD * ) pbRaw;
        pbRaw += sizeof( DWORD );
        printf( "Class Name: %S\t", pbRaw );

        pbRaw += ROUNDUP4( dwStrLen );
        dwStrLen = * ( DWORD * ) pbRaw;
        pbRaw += sizeof( DWORD );
        printf( "Object Name: %S\n", pbRaw );

        pSubEntry = ( PNDS_RESPONSE_SUBORDINATE_ENTRY ) ( pbRaw + ROUNDUP4( dwStrLen ) );
        dwEntries--;

        printf( "-----------------------------------------------------------------------\n" );

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\sample.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Sample.c

Abstract:

   Command line test tool for calling the NwlibMakeNcp function.

***/

#include <stdio.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntddnwfs.h>
#include <nwapi32.h>
#include <nwxchg.h>


//
// NCP Function Control definitions
//
#define CTL_NCP_E3H     0x0014105F
#define CTL_NCP_E2H     0x0014105B
#define CTL_NCP_E1H     0x00141057
#define CTL_NCP_E0H     0x00141053


//
// Local structure definition
//
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;

//
// Local function definitions
//
NTSTATUS SendAnNCP1( NWCONN_HANDLE   ConnectionHandle );

NTSTATUS SendAnNCP2( NWCONN_HANDLE   ConnectionHandle );

NTSTATUS SendAnNCP3( NWCONN_HANDLE   ConnectionHandle );

//
// Main program function
//
int
_cdecl main( int argc, char **argv )
{
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    NWCCODE        nwccode = SUCCESSFUL;
    NWCONN_HANDLE  ConnectionHandle;
    OEM_STRING     OemArg;
    UNICODE_STRING ServerName;
    WCHAR          ServerNameBuffer[256];

    DWORD          dwE3H = FSCTL_NWR_NCP_E3H;
    DWORD          dwE2H = FSCTL_NWR_NCP_E2H;
    DWORD          dwE1H = FSCTL_NWR_NCP_E1H;
    DWORD          dwE0H = FSCTL_NWR_NCP_E0H;

    if ( argc != 2 )
    {
        printf( "\nUsage: sample <NetWare server name>, not \\\\<server>\n" );
        system( "pause" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    ServerName.Length = 0;
    ServerName.MaximumLength = sizeof( ServerNameBuffer );
    ServerName.Buffer = ServerNameBuffer;

    RtlOemStringToUnicodeString( &ServerName, &OemArg, FALSE );

    printf( "\nConnecting to NetWare server %S\n", ServerName.Buffer );

    nwccode = NWAttachToFileServerW( ServerName.Buffer,
                                     0, // ScopeFlag - set to zero, not used
                                     &ConnectionHandle );

    if ( nwccode != SUCCESSFUL )
    {
        printf( "Error: Couldn't connect to NetWare server %S\n",
                ServerName.Buffer );
        printf( "       NWAttachToFileServerW return ntstatus 0x%.8X\n\n",
                nwccode );

        return -1;
    }

    ntstatus = SendAnNCP1( ConnectionHandle ); // Your function here!

    if ( ntstatus != STATUS_SUCCESS )
    {
        printf( "Error: SendAnNCP1 return ntstatus 0x%.8X\n\n",
                ntstatus );

        return -1;
    }

    ntstatus = SendAnNCP2( ConnectionHandle ); // Your function here!

    if ( ntstatus != STATUS_SUCCESS )
    {
        printf( "Error: SendAnNCP2 return ntstatus 0x%.8X\n\n",
                ntstatus );

        return -1;
    }

    ntstatus = SendAnNCP3( ConnectionHandle ); // Your function here!

    if ( ntstatus != STATUS_SUCCESS )
    {
        printf( "Error: SendAnNCP3 return ntstatus 0x%.8X\n\n",
                ntstatus );

        return -1;
    }

    nwccode = NWDetachFromFileServer( ConnectionHandle );

    if ( nwccode != SUCCESSFUL )
    {
        printf( "Error: Couldn't disconnect from NetWare server %S\n",
                ServerName.Buffer );
        printf( "       NWDetachFromFileServer return nwccode 0x%.8X\n\n",
                nwccode );

        return -1;
    }
}

NTSTATUS SendAnNCP1( NWCONN_HANDLE   ConnectionHandle )
/*--
Routine Description:

    This function uses an opened handle to the preferred server to
    scan bindery for all file server objects.

Arguments:

    ConnectionHandle - Supplies the handle to the server that we want to
        send NCP request to.


Return Value:

    STATUS_SUCCESS - Successfully gotten a file server name.
    - or -
    A NTSTATUS code defined in ntstatus.h
    
--*/
{
    NTSTATUS ntstatus;

    BYTE year, month, day, hour, minute, second, dayofweek;
    PNWC_SERVER_INFO pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ;

    //
    // Make and send an NCP to get file server date and time.
    //
    ntstatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    CTL_NCP_E0H,            // Server function
                    0,                      // Max request packet size
                    9,                      // Max response packet size
                    "|bbbbbbb",             // Format string
                    // === REQUEST ================================
                    // === REPLY ==================================
                    &year,
                    &month,
                    &day,
                    &hour,
                    &minute,
                    &second,
                    &dayofweek
                    );

    if ( ntstatus == STATUS_SUCCESS )
    {
        printf( "\nFile server date and time information:\n\n" );
        printf( "Hour: %d, Minute: %d, Second: %d\n", hour, minute, second );
        printf( "Day: %d, Month: %d, Year: %d\n", day, month, year );
        printf( "Day of the week: %d\n\n", dayofweek );
    }

    return ntstatus;
}


NTSTATUS SendAnNCP2( NWCONN_HANDLE   ConnectionHandle )
/*--
Routine Description:

    This function uses an opened handle to the preferred server to
    scan bindery for all file server objects.

Arguments:

    ConnectionHandle - Supplies the handle to the server that we want to
        send NCP request to.


Return Value:

    STATUS_SUCCESS - Successfully gotten a file server name.
    - or -
    A NTSTATUS code defined in ntstatus.h

--*/
{
    NTSTATUS ntstatus;
    PNWC_SERVER_INFO pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ;
    VERSION_INFO     VerInfo;

    //
    // Make and send an NCP to get file server version information.
    //
    ntstatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    CTL_NCP_E3H,            // Bindery function
                    3,                      // Max request packet size
                    130,                    // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0x11,                   // b Get File Server Information
                    // === REPLY ==================================
                    &VerInfo,               // r File Version Structure
                    sizeof(VERSION_INFO)
                    );


    if ( ntstatus == STATUS_SUCCESS )
    {
        // Convert HI-LO words to LO-HI
        // ===========================================================
        VerInfo.ConnsSupported = wSWAP( VerInfo.ConnsSupported );
        VerInfo.connsInUse     = wSWAP( VerInfo.connsInUse );
        VerInfo.maxVolumes     = wSWAP( VerInfo.maxVolumes );
        VerInfo.PeakConns      = wSWAP( VerInfo.PeakConns );

        printf( "\nFile server version information:\n\n" );
        printf( "Name: %s\n", VerInfo.szName );
        printf( "Version: %d\n", VerInfo.Version );
        printf( "Sub-Version: %d\n", VerInfo.SubVersion );
        printf( "OS Revision: %d\n", VerInfo.OSRev );
        printf( "SFT level: %d\n", VerInfo.SFTLevel );
        printf( "TTS level: %d\n", VerInfo.TTSLevel );
        printf( "Account version: %d\n", VerInfo.AcctVer );
        printf( "VAP version: %d\n", VerInfo.VAPVer );
        printf( "Queue version: %d\n", VerInfo.QueueVer );
        printf( "Printer version: %d\n", VerInfo.PrintVer );
        printf( "Virtual console version: %d\n", VerInfo.VirtualConsoleVer );
        printf( "Security restriction level: %d\n", VerInfo.SecurityResLevel );
        printf( "Inter-network B version: %d\n", VerInfo.InternetworkBVer );
        printf( "Number of connections supported: %d\n", VerInfo.ConnsSupported );
        printf( "Number of connections in use: %d\n", VerInfo.connsInUse );
        printf( "Maximum number of volumes: %d\n", VerInfo.maxVolumes );
        printf( "Peak number of connections: %d\n\n", VerInfo.PeakConns );
    }

    return ntstatus;
}


NTSTATUS SendAnNCP3( NWCONN_HANDLE   ConnectionHandle )
/*--
Routine Description:

    This function uses an opened handle to the preferred server to
    scan bindery for all file server objects.

Arguments:

    ConnectionHandle - Supplies the handle to the server that we want to
        send NCP request to.


Return Value:

    STATUS_SUCCESS - Successfully gotten a file server name.
    - or -
    A NTSTATUS code defined in ntstatus.h

--*/
{
    NTSTATUS         ntstatus;
    char             szAnsiName[1000];
    WORD             wFoundUserType = 0;
    DWORD            dwObjectID = 0xFFFFFFFFL;
    BYTE             byPropertiesFlag = 0;
    BYTE             byObjectFlag = 0;
    BYTE             byObjectSecurity = 0;

    while ( ntstatus == STATUS_SUCCESS )
    {
        //
        // Make and send an NCP to get file server version information.
        //
        ntstatus = NWScanObject( ConnectionHandle,
                                 "*",
                                 OT_USER_GROUP,
                                 &dwObjectID,
                                 szAnsiName,
                                 &wFoundUserType,
                                 &byPropertiesFlag,
                                 &byObjectFlag,
                                 &byObjectSecurity );

        if ( ntstatus == STATUS_SUCCESS )
        {
            printf( "Name: %s\n", szAnsiName );
        }
    }

    return ntstatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\search.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Search.c

Abstract:

   Command line test tool for testing the NDS Search API.

Author:

    Glenn Curtis       [glennc] 22-Apr-96

***/

#include <utils.c>


int
_cdecl main( int argc, char **argv )
{
    DWORD    status = NO_ERROR;

    HANDLE   hObject;

    OEM_STRING OemArg;
    UNICODE_STRING ObjectName;
    WCHAR szObjectName[256];
    WCHAR szTempName[256];
    WCHAR szTempAttrName[256];
    WCHAR szSubjectName[256];
    WCHAR szAttributeName[256];
    DWORD dwRights;

    ASN1_TYPE_20 Asn1_20;
    ASN1_TYPE_22 Asn1_22;
    WCHAR szText[256];

    LPQUERY_NODE lpNode1;
    LPQUERY_NODE lpNode2;
    LPQUERY_NODE lpNode3;
    LPQUERY_NODE lpNode4;

    HANDLE            hOperationData = NULL;
    DWORD             NumberOfObjects;
    DWORD             InformationType;
    DWORD             dwIterHandle = NDS_INITIAL_SEARCH;
    LPNDS_OBJECT_INFO lpObjects;


    Asn1_20.ClassName = szText;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( szObjectName );
    ObjectName.Buffer = szObjectName;

    //
    // Check the arguments.
    //

    if ( argc != 2 )
    {
Usage:
        printf( "\nUsage: Search <Path to object to start search from>\n" );
        printf( "       where: Path = \\\\<tree name>\\<Object distiguished name>\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    status = NwNdsOpenObject( ObjectName.Buffer,
                              NULL,
                              NULL,
                              &hObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status )
    {   
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    //
    // "Object Class" == "User"
    //
    wcscpy( Asn1_20.ClassName, NDS_CLASS_USER );

    status = NwNdsCreateQueryNode( NDS_QUERY_EQUAL,
                                   NDS_OBJECT_CLASS,
                                   &Asn1_20,
                                   &lpNode1 );

    if ( status )
    {   
        printf( "\nError: NwNdsCreateQueryNode returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    //
    // "Telephone Number" attribute present
    //
    status = NwNdsCreateQueryNode( NDS_QUERY_PRESENT,
                                   L"Telephone Number",
                                   0,
                                   NULL,
                                   &lpNode2 );

    if ( status )
    {   
        printf( "\nError: NwNdsCreateQueryNode returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    //
    // NOT lpNode2
    //
    status = NwNdsCreateQueryNode( NDS_QUERY_NOT,
                                   lpNode2,
                                   0,
                                   NULL,
                                   &lpNode3 );

    if ( status )
    {   
        printf( "\nError: NwNdsCreateQueryNode returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    //
    // lpNode1 AND lpNode3
    //
    status = NwNdsCreateQueryNode( NDS_QUERY_AND,
                                   lpNode1,
                                   0,
                                   lpNode3,
                                   &lpNode4 );

    if ( status )
    {   
        printf( "\nError: NwNdsCreateQueryNode returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    status = NwNdsCreateBuffer( NDS_SEARCH,
                                &hOperationData );

    if ( status )
    {
        printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n", GetLastError() );

        return -1;
    }

    do
    {
        printf( "\nEnter attribute name or <Enter> to end : " );
        GetStringOrDefault( szTempAttrName, L"" );

        if ( wcslen(szTempAttrName) > 0 )
        {
            status = NwNdsPutInBuffer( szTempAttrName,
                                       0,
                                       NULL,
                                       0,
                                       0,
                                       hOperationData );

            if ( status )
            {
                printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n",
                        status );
                printf( "Error: GetLastError returned: 0x%.8X\n\n",
                        GetLastError() );

                return -1;
            }
        }

    } while ( wcslen(szTempAttrName) > 0 );

SearchLoop :

    status = NwNdsSearch( hObject,
                          NDS_INFO_ATTR_NAMES_VALUES,
                          FALSE, // Search subtree
                          FALSE, // Deref aliases
                          lpNode4,
                          &dwIterHandle,
                          &hOperationData );

    if ( status )
    {   
        printf( "\nError: NwNdsSearch returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    NwNdsGetObjectListFromBuffer( hOperationData,
                                  &NumberOfObjects,
                                  &InformationType,
                                  &lpObjects );

    printf( "-- Calling NwNdsGetObjectListFromBuffer returned %ld objects.\n",
            NumberOfObjects );

    DumpObjectsToConsole( NumberOfObjects, InformationType, lpObjects );

    if ( dwIterHandle != NDS_NO_MORE_ITERATIONS )
    {
        goto SearchLoop;
    }

    status = NwNdsDeleteQueryTree( lpNode4 );

    if ( status )
    {   
        printf( "\nError: NwNdsDeleteQueryTree returned status 0x%.8X\n",
                status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    status = NwNdsCloseObject( hObject );

    if ( status )
    {   
        printf( "\nError: NwNdsCloseObject returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    status = NwNdsFreeBuffer( hOperationData );

    if ( status )
    {   
        printf( "\nError: NwNdsFreeBuffer returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\setshare.c ===
/***

Copyright (c) 1996  Microsoft Corporation

Module Name:

    SetShare.c

Abstract:

    This is a command line test utility for setting the
    shareable bit on a file on a Netware server.

Author:

    Cory West       [corywest]  25-April-96

***/

#include "ndsapi32.h"

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS Status;
    int ReturnCode = 0;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE hFile;

    //
    // Check the command line arguments for a file.
    //

    if ( argc < 1 ) {
        printf( "Usage: setshare [path to file]\n" );
        return -1;
    }

    //
    // Open the file.
    //

    hFile = CreateFile( argv[1],       // file name
                        GENERIC_READ,  // read access
                        0,             // exclusive
                        NULL,          // no security specifications
                        OPEN_EXISTING, // do not create
                        0,             // no attributes that we care about
                        NULL );        // no template

    if ( hFile == INVALID_HANDLE_VALUE ) {
        printf( "Couldn't open the request file.  Error = %08lx\n", Status );
        return -1;
    }

    //
    // Tell the redirector to set the shareable bit.
    //

    Status = NtFsControlFile( hFile,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              FSCTL_NWR_SET_SHAREBIT,
                              NULL,
                              0,
                              NULL,
                              0 );

    if ( !NT_SUCCESS( Status ) ) {
        printf( "A parameter was not correct.  This only works for a file\n" );
        printf( "on a Netware volume.  Status = %08lx\n", Status );
        ReturnCode = -1;
    }

    CloseHandle( hFile );

    //
    // The bit actually gets set when you close the file.
    //

    return ReturnCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\schema.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Schema.c

Abstract:

   Command line test tool for testing the NDS schema APIs.

Author:

    Glenn Curtis       [glennc] 22-Apr-96

***/

#include <utils.c>


int
_cdecl main( int argc, char **argv )
{
    DWORD    status = NO_ERROR;

    HANDLE   hObject;
    HANDLE   hOperationData = NULL;

    OEM_STRING OemArg;
    UNICODE_STRING TreeName;
    WCHAR lpTreeName[256];
    UNICODE_STRING ObjectName;
    WCHAR lpObjectName[256];
    WCHAR TempName[256];
    HANDLE hTree;

    ASN1_ID  asn1Id;

    TreeName.Length = 0;
    TreeName.MaximumLength = sizeof( lpTreeName );
    TreeName.Buffer = lpTreeName;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof( lpObjectName );
    ObjectName.Buffer = lpObjectName;

    //
    // Check the arguments.
    //

    if ( argc != 5 )
    {
Usage:
        printf( "\nUsage: schema <tree name> -a|m|r A|C <attribute or class name>\n" );
        printf( "\n       where: a = add\n" );
        printf( "       where: m = modify (classes only)\n" );
        printf( "       where: r = remove\n" );
        printf( "       where: A = Attribute\n" );
        printf( "       where: C = Class\n" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &TreeName, &OemArg, FALSE );

    OemArg.Length = strlen( argv[4] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[4];

    RtlOemStringToUnicodeString( &ObjectName, &OemArg, FALSE );

    status = NwNdsOpenObject( TreeName.Buffer,
                              NULL,
                              NULL,
                              &hTree,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status )
    {   
        printf( "\nError: NwNdsOpenObject returned status 0x%.8X\n", status );
        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                GetLastError() );

        return -1;
    }

    if ( argv[2][1] == 'a' && argv[3][0] == 'A' )
    {
        DWORD dwSyntaxId;
        DWORD dwMinValue;
        DWORD dwMaxValue;

        printf( "\nGoing to try to add an attribute to schema.\n" );

        printf( "\nEnter a syntax id (0-27) for new attribute %S\n", ObjectName.Buffer );
        scanf( "%d", &dwSyntaxId );

        printf( "\nEnter a minimum range value for new attribute %S\n", ObjectName.Buffer );
        scanf( "%d", &dwMinValue );

        printf( "\nEnter a maximum range value for new attribute %S\n", ObjectName.Buffer );
        scanf( "%d", &dwMaxValue );

        status = NwNdsDefineAttribute( hTree,
                                       ObjectName.Buffer,
                                       NDS_SINGLE_VALUED_ATTR,
                                       dwSyntaxId,
                                       dwMinValue,
                                       dwMaxValue,
                                       asn1Id );

        if ( status )
        {
            printf( "\nError: NwNdsDefineAttribute returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        printf( "\n  Success!\n" );

        return 0;
    }

    if ( argv[2][1] == 'r' && argv[3][0] == 'A' )
    {
        printf( "\nGoing to try to remove an attribute from schema.\n" );

        status = NwNdsDeleteAttrDef( hTree,
                                     ObjectName.Buffer );

        if ( status )
        {
            printf( "\nError: NwNdsDeleteAttrDef returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        printf( "\n  Success!\n" );

        return 0;
    }

    if ( argv[2][1] == 'a' && argv[3][0] == 'C' )
    {
        HANDLE hSuperClasses = NULL;
        HANDLE hContainmentClasses = NULL;
        HANDLE hNamingAttributes = NULL;
        HANDLE hMandatoryAttributes = NULL;
        HANDLE hOptionalAttributes = NULL;
        DWORD  dwFlags;

        printf( "\nGoing to try to add a class to schema.\n" );

        do
        {
            printf( "\nEnter super class name or <Enter> to end : " );
            GetStringOrDefault( TempName, L"" );

            if ( wcslen(TempName) > 0 )
            {
                if ( hSuperClasses == NULL )
                {
                    status = NwNdsCreateBuffer( NDS_SCHEMA_DEFINE_CLASS,
                                                &hSuperClasses );

                    if ( status )
                    {
                        printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
                        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                                GetLastError() );

                        return -1;
                    }
                }

                status = NwNdsPutInBuffer( TempName,
                                           0,
                                           NULL,
                                           0,
                                           0,
                                           hSuperClasses );

                if ( status )
                {
                    printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n", status );
                    printf( "Error: GetLastError returned: 0x%.8X\n\n",
                            GetLastError() );

                    return -1;
                }
            }

        } while ( wcslen(TempName) > 0 );

        do
        {
            printf( "\nEnter containment class name or <Enter> to end : " );
            GetStringOrDefault( TempName, L"" );

            if ( wcslen(TempName) > 0 )
            {
                if ( hContainmentClasses == NULL )
                {
                    status = NwNdsCreateBuffer( NDS_SCHEMA_DEFINE_CLASS,
                                                &hContainmentClasses );

                    if ( status )
                    {
                        printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
                        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                                GetLastError() );

                        return -1;
                    }
                }

                status = NwNdsPutInBuffer( TempName,
                                           0,
                                           NULL,
                                           0,
                                           0,
                                           hContainmentClasses );

                if ( status )
                {
                    printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n", status );
                    printf( "Error: GetLastError returned: 0x%.8X\n\n",
                            GetLastError() );

                    return -1;
                }
            }

        } while ( wcslen(TempName) > 0 );

        do
        {
            printf( "\nEnter naming attribute name or <Enter> to end : " );
            GetStringOrDefault( TempName, L"" );

            if ( wcslen(TempName) > 0 )
            {
                if ( hNamingAttributes == NULL )
                {
                    status = NwNdsCreateBuffer( NDS_SCHEMA_DEFINE_CLASS,
                                                &hNamingAttributes );

                    if ( status )
                    {
                        printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
                        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                                GetLastError() );

                        return -1;
                    }
                }

                status = NwNdsPutInBuffer( TempName,
                                           0,
                                           NULL,
                                           0,
                                           0,
                                           hNamingAttributes );

                if ( status )
                {
                    printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n", status );
                    printf( "Error: GetLastError returned: 0x%.8X\n\n",
                            GetLastError() );

                    return -1;
                }
            }

        } while ( wcslen(TempName) > 0 );

        do
        {
            printf( "\nEnter mandatory attribute name or <Enter> to end : " );
            GetStringOrDefault( TempName, L"" );

            if ( wcslen(TempName) > 0 )
            {
                if ( hMandatoryAttributes == NULL )
                {
                    status = NwNdsCreateBuffer( NDS_SCHEMA_DEFINE_CLASS,
                                                &hMandatoryAttributes );

                    if ( status )
                    {
                        printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
                        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                                GetLastError() );

                        return -1;
                    }
                }

                status = NwNdsPutInBuffer( TempName,
                                           0,
                                           NULL,
                                           0,
                                           0,
                                           hMandatoryAttributes );

                if ( status )
                {
                    printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n", status );
                    printf( "Error: GetLastError returned: 0x%.8X\n\n",
                            GetLastError() );

                    return -1;
                }
            }

        } while ( wcslen(TempName) > 0 );

        do
        {
            printf( "\nEnter optional attribute name or <Enter> to end : " );
            GetStringOrDefault( TempName, L"" );

            if ( wcslen(TempName) > 0 )
            {
                if ( hOptionalAttributes == NULL )
                {
                    status = NwNdsCreateBuffer( NDS_SCHEMA_DEFINE_CLASS,
                                                &hOptionalAttributes );

                    if ( status )
                    {
                        printf( "\nError: NwNdsCreateBuffer returned status 0x%.8X\n", status );
                        printf( "Error: GetLastError returned: 0x%.8X\n\n",
                                GetLastError() );

                        return -1;
                    }
                }

                status = NwNdsPutInBuffer( TempName,
                                           0,
                                           NULL,
                                           0,
                                           0,
                                           hOptionalAttributes );

                if ( status )
                {
                    printf( "\nError: NwNdsPutInBuffer returned status 0x%.8X\n", status );
                    printf( "Error: GetLastError returned: 0x%.8X\n\n",
                            GetLastError() );

                    return -1;
                }
            }

        } while ( wcslen(TempName) > 0 );

        printf( "\nEnter a value for the class flags : " );
        scanf( "%d", &dwFlags );

        status = NwNdsDefineClass( hTree,
                                   ObjectName.Buffer,
                                   dwFlags,
                                   asn1Id,
                                   hSuperClasses,
                                   hContainmentClasses,
                                   hNamingAttributes,
                                   hMandatoryAttributes,
                                   hOptionalAttributes );

        if ( status )
        {
            printf( "\nError: NwNdsDefineAttribute returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        printf( "\n  Success!\n" );

        return 0;
    }

    if ( argv[2][1] == 'r' && argv[3][0] == 'C' )
    {
        printf( "\nGoing to try to remove a class from schema.\n" );

        status = NwNdsDeleteClassDef( hTree,
                                      ObjectName.Buffer );

        if ( status )
        {
            printf( "\nError: NwNdsDeleteClassDef returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        printf( "\n  Success!\n" );

        return 0;
    }

    if ( argv[2][1] == 'm' && argv[3][0] == 'C' )
    {
        WCHAR AddAttributeName[256];

        printf( "\nGoing to try to add an attribute to a class in the schema.\n" );
        printf( "\nEnter an attribute name to add to class %S\n", ObjectName.Buffer );
        GetStringOrDefault( AddAttributeName, L"" );

        status = NwNdsAddAttributeToClass( hTree,
                                           ObjectName.Buffer,
                                           AddAttributeName );

        if ( status )
        {
            printf( "\nError: NwNdsAddAttributeToClass returned status 0x%.8X\n", status );
            printf( "Error: GetLastError returned: 0x%.8X\n\n",
                    GetLastError() );

            return -1;
        }

        printf( "\n  Success!\n" );

        return 0;
    }

    goto Usage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\testnds.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Sample.c

Abstract:

   Command line test tool for calling the NwlibMakeNcp function.

***/

#include <stdio.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ntddnwfs.h>
#include <nwapi32.h>
#include <ndsapi32.h>
#include <nwxchg.h>


//
// Local structure definition
//
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;


//
// Main program function
//
int
_cdecl main( int argc, char **argv )
{
    NTSTATUS         ntstatus = STATUS_SUCCESS;
    NWCCODE          nwccode = SUCCESSFUL;
    NWCONN_HANDLE    ConnectionHandle;
    OEM_STRING       OemArg;
    UNICODE_STRING   ServerName;
    UNICODE_STRING   TreeName;
    WCHAR            ServerNameBuffer[256];
    WCHAR            TreeNameBuffer[48];
    BOOL             fIsNds;
    PNWC_SERVER_INFO pServerInfo = NULL;

    if ( argc != 2 )
    {
        printf( "\nUsage: sample <NetWare server name>, not \\\\<server>\n" );
        system( "pause" );

        return -1;
    }

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    ServerName.Length = 0;
    ServerName.MaximumLength = sizeof( ServerNameBuffer );
    ServerName.Buffer = ServerNameBuffer;

    RtlOemStringToUnicodeString( &ServerName, &OemArg, FALSE );

    printf( "\nConnecting to NetWare server %S\n", ServerName.Buffer );

    nwccode = NWAttachToFileServerW( ServerName.Buffer,
                                     0, // ScopeFlag - set to zero, not used
                                     &ConnectionHandle );

    if ( nwccode != SUCCESSFUL )
    {
        printf( "Error: Couldn't connect to NetWare server %S\n",
                ServerName.Buffer );
        printf( "       NWAttachToFileServerW return ntstatus 0x%.8X\n\n",
                nwccode );

        return -1;
    }

    pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle;

    TreeName.Length = 0;
    TreeName.MaximumLength = sizeof( TreeNameBuffer );
    TreeName.Buffer = TreeNameBuffer;

    ntstatus = NwNdsIsNdsConnection( pServerInfo->hConn,
                                     &fIsNds,
                                     &TreeName );

    if ( ntstatus != STATUS_SUCCESS )
    {
        printf( "Error: NwNdsIsNdsConnection return ntstatus 0x%.8X\n\n",
                ntstatus );

        return -1;
    }

    if ( fIsNds )
        printf( "You are connected to tree %S\n", TreeName.Buffer );

    nwccode = NWDetachFromFileServer( ConnectionHandle );

    if ( nwccode != SUCCESSFUL )
    {
        printf( "Error: Couldn't disconnect from NetWare server %S\n",
                ServerName.Buffer );
        printf( "       NWDetachFromFileServer return nwccode 0x%.8X\n\n",
                nwccode );

        return -1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\treebn.c ===
/***

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Treebn.c

Abstract:

    Command line test for getting the connection information
    for a particular NT user name.

Author:

    Cory West       [corywest] 1-March-1996

***/

#include "ndsapi32.h"
#include "ntddnwfs.h"

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr;

    WCHAR OpenString[] = L"\\Device\\Nwrdr\\*";
    UNICODE_STRING OpenName;

    OEM_STRING OemArg;
    UNICODE_STRING NtUserName;
    WCHAR NtUserBuffer[512];

    ULONG BufferSize = 4096;
    BYTE *Reply;

    PNWR_NDS_REQUEST_PACKET Request;
    BYTE RequestBuffer[2048];
    ULONG RequestSize;

    PCONN_INFORMATION pConnInfo;
    UNICODE_STRING Name;
    DWORD dwTrees, dwSize;

    //
    // Check the arguments.
    //

    if ( argc != 2 ) {
        printf( "Usage: treebn [nt user name]\n" );
        return -1;
    }

    //
    // Allocate buffer space.
    //

    Reply = LocalAlloc( LMEM_ZEROINIT, BufferSize );

    if ( !Reply ) {
       printf( "Insufficient memory to complete the request.\n" );
       return -1;
    }

    //
    // Convert the user name to unicode.
    //

    NtUserName.Length = 0;
    NtUserName.MaximumLength = sizeof( NtUserBuffer );
    NtUserName.Buffer = NtUserBuffer;

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    RtlOemStringToUnicodeString( &NtUserName, &OemArg, FALSE );

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &OpenName, OpenString );

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    //
    // Fill out the request packet for FSCTL_NWR_NDS_LIST_TREES;
    //

    Request = ( PNWR_NDS_REQUEST_PACKET ) RequestBuffer;

    Request->Parameters.ListTrees.NtUserNameLength = NtUserName.Length;

    RtlCopyMemory( &(Request->Parameters.ListTrees.NtUserName[0]),
                   NtUserBuffer,
                   NtUserName.Length );

    RequestSize = sizeof( Request->Parameters.ListTrees ) +
                  NtUserName.Length +
                  sizeof( DWORD );

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_NDS_LIST_TREES,
                                (PVOID) Request,
                                RequestSize,
                                (PVOID) Reply,
                                BufferSize );

    if ( !NT_SUCCESS( ntstatus ) ) {
        goto ExitWithClose;
    }

    //
    // Print out the CONN_INFO array that is in the reply buffer.
    //

    dwTrees = Request->Parameters.ListTrees.TreesReturned;
    printf( "Returned %d trees.\n", dwTrees );
    printf( "Luid was %08lx\n", Request->Parameters.ListTrees.UserLuid.LowPart );

    printf( "------------------------\n" );

    pConnInfo = (PCONN_INFORMATION) Reply;

    while ( dwTrees > 0 ) {

        dwSize = sizeof( CONN_INFORMATION );

        Name.Length = Name.MaximumLength = (USHORT) pConnInfo->HostServerLength;
        Name.Buffer = pConnInfo->HostServer;
        printf( "Tree: %wZ\n", &Name );

        dwSize += Name.Length;

        Name.Length = Name.MaximumLength = (USHORT) pConnInfo->UserNameLength;
        Name.Buffer = pConnInfo->UserName;
        printf( "User Name: %wZ\n", &Name );

        dwSize += Name.Length;

        pConnInfo = (PCONN_INFORMATION) ( ((BYTE *)pConnInfo) + dwSize );
        dwTrees--;

        printf( "------------------------\n" );
    }

    ntstatus = STATUS_SUCCESS;

ExitWithClose:

   LocalFree( Request );
   NtClose( hRdr );
   return ntstatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\userfrag.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    UserFrag.c

Abstract:

    User mode fragment exchange test.

Author:

    Cory West       [corywest]  05-Jan-1996

***/

#include "ndsapi32.h"
#include <nds.h>

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS Status;
    HANDLE hNdsTree;
    OEM_STRING OemArg;

    UNICODE_STRING NdsTree;
    WCHAR TreeBuffer[48];     // Max nds tree name length.

    UNICODE_STRING Object;
    WCHAR ObjectBuffer[256];  // Max nds name length.

    DWORD dwResolverFlags;
    DWORD dwOid;
    DWORD dwReplyLength;
    BYTE NdsReply[NDS_BUFFER_SIZE];

    //
    // Who do we want to monkey with?
    //

    if ( argc != 3 ) {
        printf( "Usage: userfrag [server name] [nds object]\n" );
        return -1;
    }

    //
    // Get the server.
    //

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    NdsTree.Length = 0;
    NdsTree.MaximumLength = sizeof( TreeBuffer );
    NdsTree.Buffer = TreeBuffer;

    RtlOemStringToUnicodeString( &NdsTree, &OemArg, FALSE );

    //
    // Open up a handle to the tree.
    //

    Status = NwNdsOpenTreeHandle( &NdsTree,
                                  &hNdsTree );

    if ( !NT_SUCCESS( Status ) ) {
       printf( "The supplied tree name is invalid or the tree is unavailable.\n" );
       return -1;
    }

    //
    // Get the object information.
    //

    OemArg.Length = strlen( argv[2] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[2];

    Object.Length = 0;
    Object.MaximumLength = sizeof( ObjectBuffer );
    Object.Buffer = ObjectBuffer;

    RtlOemStringToUnicodeString( &Object, &OemArg, FALSE );

    dwResolverFlags = RSLV_DEREF_ALIASES | RSLV_WALK_TREE | RSLV_WRITABLE;

    Status = FragExWithWait( hNdsTree,
                             NDSV_RESOLVE_NAME,
                             NdsReply,
                             NDS_BUFFER_SIZE,
                             &dwReplyLength,
                             "DDDSDDDD",
                             0,                     // version
                             dwResolverFlags,       // flags
                             0,                     // scope
                             &Object,               // distinguished name
                             1,0,                   // transport type
                             1,0 );                 // treeWalker type


    if ( !NT_SUCCESS( Status ) ) {
       printf( "The resolve name failed.\n" );
       goto ExitWithClose;
    }

    Status = ParseResponse( NdsReply,
                            dwReplyLength,
                            "G_D",
                            2 * sizeof( DWORD ), // Skip the first two DWORDs
                            &dwOid );

    if ( !NT_SUCCESS( Status ) ) {
        printf( "The resolve name response was undecipherable.\n" );
        goto ExitWithClose;
    }

    Status = FragExWithWait( hNdsTree,
                             NDSV_READ_ENTRY_INFO,
                             NdsReply,
                             NDS_BUFFER_SIZE,
                             &dwReplyLength,
                             "DD",
                             0,
                             dwOid );

    if ( !NT_SUCCESS( Status ) ) {
       printf( "The get object info failed.\n" );
       goto ExitWithClose;
    }

ExitWithClose:

    CloseHandle( hNdsTree );

    if ( NT_SUCCESS( Status ) ) {
        return 0;
    }

    printf( "Unable to complete the requested operation: 0x%08lx\n", Status );
    return -1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\utils.c ===
/***
Copyright (c) 1995  Microsoft Corporation

Module Name:

    Utils.c

Abstract:

   Collection of functions used by ndsutils applications.

Author:

    Glenn Curtis       [glennc] 25-Jan-96

***/

#include <ndsapi32.h>
#include <nds32.h>
#include <ndsattr.h>
#include <ndssntx.h>


#define ROUNDUP4(x)         ( ( (x) + 3 ) & ( ~3 ) )


VOID
PrintObjectAttributeNamesAndValues(
    char *          TreeName,
    char *          ObjectName,
    DWORD           NumberOfEntries,
    LPNDS_ATTR_INFO lpEntries );

VOID
PrintValues(
    DWORD  Count,
    DWORD  SyntaxId,
    LPBYTE lpValues );

LPBYTE
PrintValue(
    DWORD SyntaxId,
    LPBYTE lpValue );

VOID
DumpListOfStrings(
    LPWSTR_LIST lpStrings );

VOID
GetStringOrDefault(
    LPWSTR string,
    LPWSTR defaultString );

void
DumpObjectsToConsole(
    DWORD NumberOfObjects,
    DWORD InformationType,
    LPNDS_OBJECT_INFO lpObjects );


VOID
PrintObjectAttributeNamesAndValues(
    char *          TreeName,
    char *          ObjectName,
    DWORD           NumberOfEntries,
    LPNDS_ATTR_INFO lpEntries )
{
    DWORD status = NO_ERROR;
    DWORD iter;
    DWORD iter2;
    DWORD PaddingLength;

    printf( "\n   Reading all attributes from object \\\\%s\\%s\n   returned the following:\n\n", TreeName, ObjectName );
    printf( "\n   Attribute Name                   |   Attribute Value                     \n" );
    printf( "____________________________________|_______________________________________\n" );

    for ( iter = 0; iter < NumberOfEntries; iter++ )
    {
        printf( "   %S", lpEntries[iter].szAttributeName );

        PaddingLength = 33 - wcslen( lpEntries[iter].szAttributeName );

        for ( iter2 = 0; iter2 < PaddingLength; iter2++ )
            printf( " " );

        printf( "|" );

        PrintValues( lpEntries[iter].dwNumberOfValues,
                     lpEntries[iter].dwSyntaxId,
                     lpEntries[iter].lpValue );

        printf( "\n" );
    }
}


VOID
PrintAttributeNamesAndValues(
    DWORD           NumberOfEntries,
    LPNDS_ATTR_INFO lpEntries )
{
    DWORD status = NO_ERROR;
    DWORD iter;
    DWORD iter2;
    DWORD PaddingLength;

    printf( "\n   Attribute Name                   |   Attribute Value                     \n" );
    printf( "____________________________________|_______________________________________\n" );

    for ( iter = 0; iter < NumberOfEntries; iter++ )
    {
        printf( "   %S", lpEntries[iter].szAttributeName );

        PaddingLength = 33 - wcslen( lpEntries[iter].szAttributeName );

        for ( iter2 = 0; iter2 < PaddingLength; iter2++ )
            printf( " " );

        printf( "|" );

        PrintValues( lpEntries[iter].dwNumberOfValues,
                     lpEntries[iter].dwSyntaxId,
                     lpEntries[iter].lpValue );

        printf( "\n" );
    }
}


VOID
    PrintValues(
        DWORD  Count,
        DWORD  SyntaxId,
        LPBYTE lpValues )
{
    DWORD iter;
    LPBYTE lpByte = lpValues;

    printf( "   Syntax Id: %d\tNumber of values: %d\n", SyntaxId, Count );
    printf( "                                    |\n" );
    printf( "                                    |   Value(s):\n" );

    for ( iter = 0; iter < Count; iter++ )
    {
        printf( "                                    |      Value %d:\n",
                iter + 1 );

        lpByte = PrintValue( SyntaxId, lpByte );
    }

    printf( "____________________________________|_______________________________________" );
}


LPBYTE
PrintValue(
    DWORD SyntaxId,
    LPBYTE lpByte )
{
    DWORD len = 0;
    DWORD iter;
    DWORD nFields;

    switch( SyntaxId )
    {
        case NDS_SYNTAX_ID_1 :
        case NDS_SYNTAX_ID_2 :
        case NDS_SYNTAX_ID_3 :
        case NDS_SYNTAX_ID_4 :
        case NDS_SYNTAX_ID_5 :
        case NDS_SYNTAX_ID_10 :
        case NDS_SYNTAX_ID_20 :
        {
            LPASN1_TYPE_1 lpASN1_1 = (LPASN1_TYPE_1) lpByte;
            printf( "                                    |         %S\n",
                    lpASN1_1->DNString );
            lpByte = (LPBYTE ) lpASN1_1 + sizeof(ASN1_TYPE_1);
        }
        break;

        case NDS_SYNTAX_ID_6 :
        {
            LPASN1_TYPE_6 lpASN1_6 = (LPASN1_TYPE_6) lpByte;
            
            printf( "                                    |         %S\n",
                    lpASN1_6->String );
            while ( lpASN1_6->Next != NULL )
            {
                lpASN1_6 = lpASN1_6->Next;

                printf( "                                    |         %S\n",
                        lpASN1_6->String );
            }
            lpByte = (LPBYTE ) lpASN1_6 + sizeof(ASN1_TYPE_6);
        }
        break;

        case NDS_SYNTAX_ID_7 :
        {
            LPASN1_TYPE_7 lpASN1_7 = (LPASN1_TYPE_7) lpByte;
            printf( "                                    |         %S\n",
                    lpASN1_7->Boolean ? L"TRUE" : L"FALSE" );
            lpByte = (LPBYTE ) lpASN1_7 + sizeof(ASN1_TYPE_7);
        }
        break;

        case NDS_SYNTAX_ID_8 :
        case NDS_SYNTAX_ID_22 :
        case NDS_SYNTAX_ID_24 :
        case NDS_SYNTAX_ID_27 :
        {
            LPASN1_TYPE_8 lpASN1_8 = (LPASN1_TYPE_8) lpByte;
            printf( "                                    |         %ld\n",
                    lpASN1_8->Integer );
            lpByte = (LPBYTE ) lpASN1_8 + sizeof(ASN1_TYPE_8);
        }
        break;

        case NDS_SYNTAX_ID_9 :
        {
            LPASN1_TYPE_9 lpASN1_9 = (LPASN1_TYPE_9) lpByte;
            printf( "            ( Octet String Length ) |         %ld\n",
                    lpASN1_9->Length );
            lpByte = (LPBYTE ) lpASN1_9 + sizeof(ASN1_TYPE_9);
        }
        break;

        case NDS_SYNTAX_ID_11 :
        {
            LPASN1_TYPE_11 lpASN1_11 = (LPASN1_TYPE_11) lpByte;
            printf( "                                    |         %S\n",
                    lpASN1_11->TelephoneNumber );
            lpByte = (LPBYTE ) lpASN1_11 + sizeof(ASN1_TYPE_11);
        }
        break;

        case NDS_SYNTAX_ID_12 :
        {
            LPASN1_TYPE_12 lpASN1_12 = (LPASN1_TYPE_12) lpByte;
            printf( "                 ( Address Type )   |         %ld\n",
                    lpASN1_12->AddressType );
            printf( "                 ( Address Length ) |         %ld\n",
                    lpASN1_12->AddressLength );
            lpByte = (LPBYTE ) lpASN1_12 + sizeof(ASN1_TYPE_12);
        }
        break;

        case NDS_SYNTAX_ID_13 :
        {
            LPASN1_TYPE_13 lpASN1_13 = (LPASN1_TYPE_13) lpByte;
            printf( "                                    |         " );
            for ( iter = 0; iter < lpASN1_13->Length; iter++ )
            {
                printf( "%x", lpASN1_13->Data[iter] );
            }
            printf( "\n" );
            while ( lpASN1_13->Next != NULL )
            {
                lpASN1_13 = lpASN1_13->Next;
                printf( "                                    |         " );
                for ( iter = 0; iter < lpASN1_13->Length; iter++ )
                {
                    printf( "%x", lpASN1_13->Data[iter] );
                }
                printf( "\n" );
            }
            lpByte = (LPBYTE ) lpASN1_13 + sizeof(ASN1_TYPE_13);
        }
        break;

        case NDS_SYNTAX_ID_14 :
        {
            LPASN1_TYPE_14 lpASN1_14 = (LPASN1_TYPE_14) lpByte;
            printf( "                        ( Type )    |         %ld\n",
                    lpASN1_14->Type );
            printf( "                        ( Address ) |         %S\n",
                    lpASN1_14->Address );
            lpByte = (LPBYTE ) lpASN1_14 + sizeof(ASN1_TYPE_14);
        }
        break;

        case NDS_SYNTAX_ID_15 :
        {
            LPASN1_TYPE_15 lpASN1_15 = (LPASN1_TYPE_15) lpByte;
            printf( "                   ( Type )         |         %ld\n",
                    lpASN1_15->Type );
            printf( "                   ( Volume Name )  |         %S\n",
                    lpASN1_15->VolumeName );
            printf( "                   ( Path )         |         %S\n",
                    lpASN1_15->Path );
            lpByte = (LPBYTE ) lpASN1_15 + sizeof(ASN1_TYPE_15);
        }
        break;

        case NDS_SYNTAX_ID_16 :
        {
            LPASN1_TYPE_16 lpASN1_16 = (LPASN1_TYPE_16) lpByte;
            printf( "                 ( Server Name )    |         %S\n",
                    lpASN1_16->ServerName );
            printf( "                 ( Replica Type )   |         %ld\n",
                    lpASN1_16->ReplicaType );
            printf( "                 ( Replica Number ) |         %ld\n",
                    lpASN1_16->ReplicaNumber );
            printf( "                 ( Count )          |         %ld\n",
                    lpASN1_16->Count );
            for ( iter = 0; iter < lpASN1_16->Count; iter++ )
            { 
                printf( "                 ( Address Type )   |         %ld\n",
                        lpASN1_16->ReplicaAddressHint[iter].AddressType );
                printf( "                 ( Address Length ) |         %ld\n",
                        lpASN1_16->ReplicaAddressHint[iter].AddressLength );
            }

            lpByte += sizeof(ASN1_TYPE_16) - sizeof(ASN1_TYPE_12) +
                      ( lpASN1_16->Count * sizeof(ASN1_TYPE_12) );
        }
        break;

        case NDS_SYNTAX_ID_17 :
        {
            LPASN1_TYPE_17 lpASN1_17 = (LPASN1_TYPE_17) lpByte;
            printf( "        ( Protected Attribute Name )|         %S\n",
                    lpASN1_17->ProtectedAttrName );
            printf( "        ( Subject Name )            |         %S\n",
                    lpASN1_17->SubjectName );
            printf( "        ( NWDS_PRIVILEGES )         |         %ld\n",
                    lpASN1_17->Privileges );
            lpByte = (LPBYTE ) lpASN1_17 + sizeof(ASN1_TYPE_17);
        }
        break;

        case NDS_SYNTAX_ID_18 :
        {
            LPASN1_TYPE_18 lpASN1_18 = (LPASN1_TYPE_18) lpByte;
            printf( "        ( Postal Address - line 1 ) |         %S\n",
                    lpASN1_18->PostalAddress[0] );
            printf( "        ( Postal Address - line 2 ) |         %S\n",
                    lpASN1_18->PostalAddress[1] );
            printf( "        ( Postal Address - line 3 ) |         %S\n",
                    lpASN1_18->PostalAddress[2] );
            printf( "        ( Postal Address - line 4 ) |         %S\n",
                    lpASN1_18->PostalAddress[3] );
            printf( "        ( Postal Address - line 5 ) |         %S\n",
                    lpASN1_18->PostalAddress[4] );
            printf( "        ( Postal Address - line 6 ) |         %S\n",
                    lpASN1_18->PostalAddress[5] );
            lpByte = (LPBYTE ) lpASN1_18 + sizeof(ASN1_TYPE_18);
        }
        break;

        case NDS_SYNTAX_ID_19 :
        {
            LPASN1_TYPE_19 lpASN1_19 = (LPASN1_TYPE_19) lpByte;
            printf( "                   ( Whole seconds )|         %ld\n",
                    lpASN1_19->WholeSeconds );
            printf( "                   ( Event ID )     |         %ld\n",
                    lpASN1_19->EventID );
            lpByte = (LPBYTE ) lpASN1_19 + sizeof(ASN1_TYPE_19);
        }
        break;

        case NDS_SYNTAX_ID_21 :
        {
            LPASN1_TYPE_21 lpASN1_21 = (LPASN1_TYPE_21) lpByte;
            printf( "                          ( Length )|         %ld\n",
                    lpASN1_21->Length );
            lpByte = (LPBYTE ) lpASN1_21 + sizeof(ASN1_TYPE_21);
        }
        break;

        case NDS_SYNTAX_ID_23 :
        {
            LPASN1_TYPE_23 lpASN1_23 = (LPASN1_TYPE_23) lpByte;
            printf( "                    ( Remote ID )   |         %ld\n",
                    lpASN1_23->RemoteID );
            printf( "                    ( Object Name ) |         %S\n",
                    lpASN1_23->ObjectName );
            lpByte = (LPBYTE ) lpASN1_23 + sizeof(ASN1_TYPE_23);
        }
        break;

        case NDS_SYNTAX_ID_25 :
        {
            LPASN1_TYPE_25 lpASN1_25 = (LPASN1_TYPE_25) lpByte;
            printf( "                    ( Object Name ) |         %S\n",
                    lpASN1_25->ObjectName );
            printf( "                    ( Level )       |         %ld\n",
                    lpASN1_25->Level );
            printf( "                    ( Interval )    |         %ld\n",
                    lpASN1_25->Interval );
            lpByte = (LPBYTE ) lpASN1_25 + sizeof(ASN1_TYPE_25);
        }
        break;

        case NDS_SYNTAX_ID_26 :
        {
            LPASN1_TYPE_26 lpASN1_26 = (LPASN1_TYPE_26) lpByte;
            printf( "                    ( Object Name ) |         %S\n",
                    lpASN1_26->ObjectName );
            printf( "                    ( Amount )      |         %ld\n",
                    lpASN1_26->Amount );
            lpByte = (LPBYTE ) lpASN1_26 + sizeof(ASN1_TYPE_26);
        }
        break;

        default :
            printf( "                                    |         <UNKNOWN SYNTAX ID>\n" );
    }

    return lpByte;
}


VOID
PrintAttributeNames(
    DWORD           NumberOfEntries,
    LPNDS_NAME_ONLY lpEntries )
{
    DWORD status = NO_ERROR;
    DWORD iter;
    DWORD iter2;
    DWORD PaddingLength;

    printf( "\n   Attribute Name\n" );
    printf( "____________________________________\n" );

    for ( iter = 0; iter < NumberOfEntries; iter++ )
    {
        printf( "   %S", lpEntries[iter].szName );
        printf( "\n" );
    }
}


VOID
DumpListOfStrings(
    LPWSTR_LIST lpStrings )
{
    LPWSTR_LIST lpTempStrings = lpStrings;

    while ( lpTempStrings != NULL )
    {
        printf( "            %S\n", lpTempStrings->szString );
        lpTempStrings = lpTempStrings->Next;
    }

    printf( "\n" );
}


VOID
GetStringOrDefault(
    LPWSTR szString,
    LPWSTR szDefaultString )
{
    int   i = 0;
    WCHAR ch;

    ch = getwchar();
    while ( ch != '\r' && ch != '\n' )
    {
        szString[i] = ch;
        i++;
        szString[i] = 0;
        ch = getwchar();
    }

    if ( i == 0 && szDefaultString != NULL )
    {
        wcscpy( szString, szDefaultString );
    }

    if ( i == 0 && szDefaultString == NULL )
    {
        wcscpy( szString, L"" );
    }
}


void
DumpObjectsToConsole(
    DWORD NumberOfObjects,
    DWORD InformationType,
    LPNDS_OBJECT_INFO lpObjects )
{
    DWORD i;
    LPNDS_OBJECT_INFO lpTempObject = lpObjects;

    for ( i = 0; i < NumberOfObjects; i++ )
    {
        printf( "\n______________________________________________\n" );
        printf( "  Object Full Name :         %S\n",
                lpTempObject->szObjectFullName );
        printf( "  Object Name :              %S\n",
                lpTempObject->szObjectName );
        printf( "  Object Class Name :        %S\n",
                lpTempObject->szObjectClass );
        printf( "  Object Entry Id :          0x%.8X\n",
                lpTempObject->dwEntryId );
        printf( "  Object Modification Time : 0x%.8X\n",
                lpTempObject->dwModificationTime );
        printf( "  Object Subordinate Count : %ld\n\n",
                lpTempObject->dwSubordinateCount );
        printf( "  Number of attributes : %ld\n\n",
                lpTempObject->dwNumberOfAttributes );

        if ( lpTempObject->dwNumberOfAttributes )
        {
          if ( InformationType == NDS_INFO_ATTR_NAMES_VALUES )
          {
            PrintAttributeNamesAndValues( lpTempObject->dwNumberOfAttributes,
                                          (LPNDS_ATTR_INFO) lpTempObject->lpAttribute );
          }

          if ( InformationType == NDS_INFO_NAMES )
          {
            PrintAttributeNames( lpTempObject->dwNumberOfAttributes,
                                 (LPNDS_NAME_ONLY) lpTempObject->lpAttribute );
          }
        }

        lpTempObject += 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\dll\debug.c ===
/*++

Copyright (c) 1991-3  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This component of netbios runs in the user process and can ( when
    built in a debug kernel) will log to either the console or through the
    kernel debugger.

Author:

    Colin Watson (ColinW) 24-Jun-91

Revision History:

--*/

#include "procs.h"

#if NWDBG

//
//  Set DebugControl to 1 to open the logfile on the first NW call and close it
//  on process exit.
//

int  DebugCtrl = 0;

BOOL UseConsole = FALSE;
BOOL UseLogFile = FALSE;
BOOL Verbose    = FALSE;

HANDLE LogFile = INVALID_HANDLE_VALUE;
#define LOGNAME                 (LPTSTR) TEXT("c:\\nwapi16.log")

LONG NwMaxDump = SERVERNAME_LENGTH * MC; //128;

#define ERR_BUF_SIZE    260
#define NAME_BUF_SIZE   260

extern UCHAR CpuInProtectMode;

LPSTR
ConvertFlagsToString(
    IN  WORD    FlagsRegister,
    OUT LPSTR   Buffer
    );

WORD
GetFlags(
    VOID
    );

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    );

VOID
DebugControl(
    int Command
    )
/*++

Routine Description:

    This routine controls what we output as debug information and where.

Arguments:

    IN  int Command

Return Value:

    none.

--*/
{

    switch (Command) {
    case 0:
        UseLogFile = TRUE;
        break;

    case 1:
        UseConsole = TRUE;
        break;

    case 2:
        if (LogFile != INVALID_HANDLE_VALUE) {
            CloseHandle(LogFile);
            LogFile = INVALID_HANDLE_VALUE;
        }
        UseLogFile = FALSE;
        UseConsole = FALSE;
        break;

    case 8:
        Verbose = TRUE; //  Same as 4 only chatty
        DebugCtrl = 4;

    case 4:
        UseLogFile = TRUE;
        break;

    }
    NwPrint(("DebugControl %x\n", Command ));
}

VOID
NwPrintf(
    char *Format,
    ...
    )
/*++

Routine Description:

    This routine is equivalent to printf with the output being directed to
    stdout.

Arguments:

    IN  char *Format - Supplies string to be output and describes following
        (optional) parameters.

Return Value:

    none.

--*/
{
    va_list arglist;
    char OutputBuffer[200];
    int length;

    if (( UseConsole == FALSE ) &&
        ( UseLogFile == FALSE )) {
        return;
    }


    va_start( arglist, Format );

    length = _vsnprintf( OutputBuffer, sizeof(OutputBuffer)-1, Format, arglist );
    if (length < 0) {
        return;
    }

    OutputBuffer[sizeof(OutputBuffer)-1] = '\0';  // in-case length= 199;

    va_end( arglist );

    if ( UseConsole ) {
        DbgPrint( "%s", OutputBuffer );
    } else {

        if ( LogFile == INVALID_HANDLE_VALUE ) {
            if ( UseLogFile ) {
                LogFile = CreateFile( LOGNAME,
                            GENERIC_WRITE,
                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                            NULL,
                            TRUNCATE_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

                if (LogFile == INVALID_HANDLE_VALUE) {
                    LogFile = CreateFile( LOGNAME,
                                GENERIC_WRITE,
                                FILE_SHARE_WRITE | FILE_SHARE_READ,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
                }

                if ( LogFile == INVALID_HANDLE_VALUE ) {
                    UseLogFile = FALSE;
                    return;
                }
            }
        }

        WriteFile( LogFile , (LPVOID )OutputBuffer, length, &length, NULL );
    }

} // NwPrintf

void
FormattedDump(
    PCHAR far_p,
    LONG  len
    )
/*++

Routine Description:

    This routine outputs a buffer in lines of text containing hex and
    printable characters.

Arguments:

    IN  far_p - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.

Return Value:

    none.

--*/
{
    ULONG     l;
    char    s[80], t[80];

    if (( UseConsole == FALSE ) &&
        ( UseLogFile == FALSE )) {
        return;
    }

    if (( len > NwMaxDump ) ||
        ( len < 0 )) {
        len = NwMaxDump;
    }

    while (len) {
        l = len < 16 ? len : 16;

        NwPrint(("%lx ", far_p));
        HexDumpLine (far_p, l, s, t);
        NwPrint(("%s%.*s%s\n", s, 1 + ((16 - l) * 3), "", t));

        len    -= l;
        far_p  += l;
    }
}

VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    )
/*++

Routine Description:

    This routine builds a line of text containing hex and printable characters.

Arguments:

    IN pch  - Supplies buffer to be displayed.
    IN len - Supplies the length of the buffer in bytes.
    IN s - Supplies the start of the buffer to be loaded with the string
            of hex characters.
    IN t - Supplies the start of the buffer to be loaded with the string
            of printable ascii characters.


Return Value:

    none.

--*/
{
    static UCHAR rghex[] = "0123456789ABCDEF";

    UCHAR    c;
    UCHAR    *hex, *asc;


    hex = s;
    asc = t;

    *(asc++) = '*';
    while (len--) {
        c = *(pch++);
        *(hex++) = rghex [c >> 4] ;
        *(hex++) = rghex [c & 0x0F];
        *(hex++) = ' ';
        *(asc++) = (c < ' '  ||  c > '~') ? (CHAR )'.' : c;
    }
    *(asc++) = '*';
    *asc = 0;
    *hex = 0;

}


VOID
DisplayExtendedError(VOID)
{
    TCHAR            errorBuf[ERR_BUF_SIZE];
    TCHAR            nameBuf[NAME_BUF_SIZE];
    DWORD           errorCode;
    DWORD           status;

    status = WNetGetLastError(
                &errorCode,
                errorBuf,
                ERR_BUF_SIZE,
                nameBuf,
                NAME_BUF_SIZE);

    if(status != WN_SUCCESS) {
        NwPrint(("nwapi32: WNetGetLastError failed %d\n",status));
        return;
    }
    NwPrint(("nwapi32: EXTENDED ERROR INFORMATION:  (from GetLastError)\n"));
    NwPrint(("nwapi32:    Code:        %d\n",errorCode));
    NwPrint(("nwapi32:    Description: "FORMAT_LPSTR"\n",errorBuf));
    NwPrint(("nwapi32:    Provider:    "FORMAT_LPSTR"\n\n",nameBuf));
    return;
}

VOID
VrDumpRealMode16BitRegisters(
    IN  BOOL    DebugStyle
    )

/*++

Routine Description:

    Displays dump of 16-bit
    real-mode 80286 registers - gp registers (8), segment registers (4), flags
    register (1) instruction pointer register (1)

Arguments:

    DebugStyle  - determines look of output:

DebugStyle == TRUE:

ax=1111  bx=2222  cx=3333  dx=4444  sp=5555  bp=6666  si=7777  di=8888
ds=aaaa  es=bbbb  ss=cccc  cs=dddd  ip=iiii   fl fl fl fl fl fl fl fl

DebugStyle == FALSE:

cs:ip=cccc:iiii  ss:sp=ssss:pppp  bp=bbbb  ax=1111  bx=2222  cx=3333  dx=4444
ds:si=dddd:ssss  es:di=eeee:dddd  flags[ODIxSZxAxPxC]=fl fl fl fl fl fl fl fl

Return Value:

    None.

--*/

{
    char    flags_string[25];

    if (( UseConsole == FALSE ) &&
        ( UseLogFile == FALSE )) {
        return;
    }

    if (CpuInProtectMode) {
        NwPrint(( "Protect Mode:\n"));
    }

    if (DebugStyle) {
        NwPrint((
            "ax=%04x  bx=%04x  cx=%04x  dx=%04x  sp=%04x  bp=%04x  si=%04x  di=%04x\n"
            "ds=%04x  es=%04x  ss=%04x  cs=%04x  ip=%04x   %s\n\n",

            pNwDosTable->SavedAx, //getAX(),
            getBX(),
            getCX(),
            getDX(),
            getSP(),
            getBP(),
            getSI(),
            getDI(),
            getDS(),
            getES(),
            getSS(),
            getCS(),
            getIP(),
            ConvertFlagsToString(GetFlags(), flags_string)
            ));
    } else {
        NwPrint((
            "cs:ip=%04x:%04x  ss:sp=%04x:%04x  bp=%04x  ax=%04x  bx=%04x  cx=%04x  dx=%04x\n"
            "ds:si=%04x:%04x  es:di=%04x:%04x  flags[ODITSZxAxPxC]=%s\n\n",
            getCS(),
            getIP(),
            getSS(),
            getSP(),
            getBP(),
            pNwDosTable->SavedAx, //getAX(),
            getBX(),
            getCX(),
            getDX(),
            getDS(),
            getSI(),
            getES(),
            getDI(),
            ConvertFlagsToString(GetFlags(), flags_string)
            ));
    }
}

LPSTR
ConvertFlagsToString(
    IN  WORD    FlagsRegister,
    OUT LPSTR   Buffer
    )

/*++

Routine Description:

    Given a 16-bit word, interpret bit positions as for x86 Flags register
    and produce descriptive string of flags state (as per debug) eg:

        NV UP DI PL NZ NA PO NC     ODItSZxAxPxC = 000000000000b
        OV DN EI NG ZR AC PE CY     ODItSZxAxPxC = 111111111111b

    Trap Flag (t) is not dumped since this has no interest for programs which
    are not debuggers or don't examine program execution (ie virtually none)

Arguments:

    FlagsRegister   - 16-bit flags
    Buffer          - place to store string. Requires 25 bytes inc \0

Return Value:

    Address of <Buffer>

--*/

{
    static char* flags_states[16][2] = {
        //0     1
        "NC", "CY", // CF (0x0001) - Carry
        "",   "",   // x  (0x0002)
        "PO", "PE", // PF (0x0004) - Parity
        "",   "",   // x  (0x0008)
        "NA", "AC", // AF (0x0010) - Aux (half) carry
        "",   "",   // x  (0x0020)
        "NZ", "ZR", // ZF (0x0040) - Zero
        "PL", "NG", // SF (0x0080) - Sign
        "",   "",   // TF (0x0100) - Trap (not dumped)
        "DI", "EI", // IF (0x0200) - Interrupt
        "UP", "DN", // DF (0x0400) - Direction
        "NV", "OV", // OF (0x0800) - Overflow
        "",   "",   // x  (0x1000) - (I/O Privilege Level) (not dumped)
        "",   "",   // x  (0x2000) - (I/O Privilege Level) (not dumped)
        "",   "",   // x  (0x4000) - (Nested Task) (not dumped)
        "",   ""    // x  (0x8000)
    };
    int i;
    WORD bit;
    BOOL on;

    *Buffer = 0;
    for (bit=0x0800, i=11; bit; bit >>= 1, --i) {
        on = (BOOL)((FlagsRegister & bit) == bit);
        if (flags_states[i][on][0]) {
            strcat(Buffer, flags_states[i][on]);
            strcat(Buffer, " ");
        }
    }
    return Buffer;
}

WORD
GetFlags(
    VOID
    )

/*++

Routine Description:

    Supplies the missing softpc function

Arguments:

    None.

Return Value:

    Conglomerates softpc flags into x86 flags word

--*/

{
    WORD    flags;

    flags = (WORD)getCF();
    flags |= (WORD)getPF() << 2;
    flags |= (WORD)getAF() << 4;
    flags |= (WORD)getZF() << 6;
    flags |= (WORD)getSF() << 7;
    flags |= (WORD)getIF() << 9;
    flags |= (WORD)getDF() << 10;
    flags |= (WORD)getOF() << 11;

    return flags;
}

VOID
VrDumpNwData(
    VOID
    )

/*++

Routine Description:

    Dumps out the state of the 16 bit datastructures.

Arguments:

    none.

Return Value:

    None.

--*/

{
    int index;
    int Drive;

    if (Verbose == FALSE) {
        return;
    }

    NwPrint(( "Preferred = %x, Primary = %x\n",
        pNwDosTable->PreferredServer,
        pNwDosTable->PrimaryServer));

    for (index = 0; index < MC; index++) {


        if ((PUCHAR)pNwDosTable->ServerNameTable[index][0] != 0 ) {

            if (pNwDosTable->ConnectionIdTable[index].ci_InUse != IN_USE) {
                NwPrint(("Warning Connection not in use %x: %x\n",
                    index,
                    pNwDosTable->ConnectionIdTable[index].ci_InUse));
            }

            NwPrint((" Server %d = %s, Connection = %d\n",
                index,
                (PUCHAR)pNwDosTable-> ServerNameTable[index],
                (((pNwDosTable->ConnectionIdTable[index]).ci_ConnectionHi * 256) +
                 ( pNwDosTable-> ConnectionIdTable[index]).ci_ConnectionLo )));
        } else {
            if (pNwDosTable->ConnectionIdTable[index].ci_InUse != FREE) {
                NwPrint(("Warning Connection in use but name is null %x: %x\n",
                            index,
                            pNwDosTable->ConnectionIdTable[index]));
            }
        }
    }

    for (Drive = 0; Drive < MD; Drive++ ) {


        if (pNwDosTable->DriveFlagTable[Drive] & 3) {
            NwPrint(("%c=%x on server %d,",'A' + Drive,
                pNwDosTable->DriveFlagTable[Drive],
                pNwDosTable->DriveIdTable[ Drive ] ));
        }

    }
    NwPrint(("\n"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\dll\locks.c ===
/*++

Copyright (c) 1993/4  Microsoft Corporation

Module Name:

    Locks.c

Abstract:

    This module implements the routines for the NetWare
    16 bit support to perform the synchonization api's

Author:

    Colin Watson    [ColinW]    07-Dec-1993

Revision History:

--*/

#include "Procs.h"
UCHAR LockMode = 0;

BOOLEAN Tickle[MC];

NTSTATUS
Sem(
    UCHAR Function,
    UCHAR Connection
    );

VOID
Locks(
    USHORT Command
    )
/*++

Routine Description:

    Implements all the locking operations

Arguments:

    Command - supplies Applications AX.

Return Value:

    Return status.

--*/
{
    UCHAR Function = Command & 0x00ff;
    USHORT Operation = Command & 0xff00;
    CONN_INDEX Connection;
    NTSTATUS status = STATUS_SUCCESS;
    PUCHAR Request;
    ULONG RequestLength;
    WORD Timeout;

    if ( Operation != 0xCF00) {

        //
        //  Connection does not need to be initialised for CF00 because
        //  we have to loop through all connections. Its harmful because
        //  a CF00 is created during ProcessExit(). If we call selectconnection
        //  and there is no server available this will make process exit
        //  really slow.
        //

        Connection = SelectConnectionInCWD();
        if (Connection == 0xff) {
            setAL(0xff);
            return;
        }

        if ( ServerHandles[Connection] == NULL ) {

            status = OpenConnection( Connection );

            if (!NT_SUCCESS(status)) {
                setAL((UCHAR)RtlNtStatusToDosError(status));
                return;
            }
        }
    }

    switch ( Operation ) {

    case 0xBC00:        //  Log physical record

        status = NwlibMakeNcp(
                    GET_NT_HANDLE(),
                    NWR_ANY_HANDLE_NCP(0x1A),
                    17, //  RequestSize
                    0,  //  ResponseSize
                    "b_wwwww",
                    Function,
                    6,              //  Leave space for NetWare handle
                    getCX(),getDX(),
                    getSI(),getDI(),
                    getBP());
        break;

    case 0xBD00:        //  Physical Unlock
        status = NwlibMakeNcp(
                    GET_NT_HANDLE(),
                    NWR_ANY_HANDLE_NCP(0x1C),
                    15, //  RequestSize
                    0,  //  ResponseSize
                    "b_wwww",
                    Function,
                    6,              //  Leave space for NetWare handle
                    getCX(),getDX(),
                    getSI(),getDI());

        break;

    case 0xBE00:        //  Clear physical record

        status = NwlibMakeNcp(
                    GET_NT_HANDLE(),
                    NWR_ANY_HANDLE_NCP(0x1E),
                    15, //  RequestSize
                    0,  //  ResponseSize
                    "b_wwww",
                    Function,
                    6,              //  Leave space for NetWare handle
                    getCX(),getDX(),
                    getSI(),getDI());

        break;

    case 0xC200:        //  Physical Lock set
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x1B),
                    3,  //  RequestSize
                    0,  //  ResponseSize
                    "bw",
                    Function,
                    getBP());
        break;

    case 0xC300:        //  Release Physical Record Set
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x1D),
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");
        break;

    case 0xC400:        //  Clear Physical Record Set
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x1F),   //  Clear Physical Record Set
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");
        break;

    case 0xC500:    //  All Semaphore operations
        status = Sem(Function, Connection);
        break;

    case 0xC600:    //  Set/Get Lock mode

        if (Function != 2) {
            LockMode = Function;
        }

        setAL(LockMode);
        return; // avoid setting AL to status at the end of this routine
        break;

    case 0xCB00:        //  Lock File Set

        if (LockMode == 0) {
            if (getDL()) {
                Timeout = 0xffff;
            } else {
                Timeout = 0;
            }
        } else {
            Timeout = getBP();
        }

        for (Connection = 0; Connection < MC; Connection++) {
            if (Tickle[Connection]) {
                status = NwlibMakeNcp(
                            ServerHandles[Connection],
                            NWR_ANY_F2_NCP(0x04),
                            2,  //  RequestSize
                            0,  //  ResponseSize
                            "w",
                            Timeout);
                if (!NT_SUCCESS(status)) {
                    break;
                }
            }
        }
        break;

    case 0xCD00:        //  Release File Set
    case 0xCF00:        //  Clear File Set
        for (Connection = 0; Connection < MC; Connection++) {
            if (Tickle[Connection]) {
                status = NwlibMakeNcp(
                            ServerHandles[Connection],
                            (Operation == 0xCD00) ? NWR_ANY_F2_NCP(0x06): NWR_ANY_F2_NCP(0x08),
                            0,  //  RequestSize
                            0,  //  ResponseSize
                            "");
                if (!NT_SUCCESS(status)) {
                    break;
                }

                if (Operation == 0xCF00) {
                    Tickle[Connection] = FALSE;
                }
            }
        }

        break;

    case 0xD000:        //  Log Logical Record

        Request = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                sizeof(UCHAR),
                                IS_PROTECT_MODE());

        RequestLength = Request[0] + 1;

        Request = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                RequestLength,
                                IS_PROTECT_MODE());

        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x09),
                    RequestLength + 5,  //  RequestSize
                    0,  //  ResponseSize
                    "bwbr",
                    (LockMode) ? Function : 0,
                    (LockMode) ? getBP() : 0,
                    RequestLength,
                    Request, RequestLength );
        break;

    case 0xD100:        //  Lock Logical Record Set

        if (LockMode == 0) {
            if (getDL()) {
                Timeout = 0xffff;
            } else {
                Timeout = 0;
            }
        } else {
            Timeout = getBP();
        }

        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x0A),
                    3,  //  RequestSize
                    0,  //  ResponseSize
                    "bw",
                    (LockMode) ? Function : 0,
                    Timeout);
        break;

    case 0xD200:        //  Release File
    case 0xD400:        //  Clear Logical Record
        Request = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                sizeof(UCHAR),
                                IS_PROTECT_MODE());

        RequestLength = Request[0]+1;

        Request = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                RequestLength,
                                IS_PROTECT_MODE());

        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    (Operation == 0xD200) ? NWR_ANY_F2_NCP(0x0C) :
                        NWR_ANY_F2_NCP(0x0B),
                    RequestLength+1,
                    0,  //  ResponseSize
                    "br",
                    RequestLength,
                    Request, RequestLength );
        break;

    case 0xD300:
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x13),
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");
        break;


    case 0xD500:    //  Clear Logical Record Set
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x0E),
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");
        break;

    case 0xEB00:    //  Log File
    case 0xEC00:    //  Release File
    case 0xED00:    //  Clear File
        {
            UCHAR DirHandle;
            HANDLE Win32DirectoryHandle = 0;
            PUCHAR ptr;

            Request = GetVDMPointer (
                                    (ULONG)((getDS() << 16)|getDX()),
                                    256 * sizeof(UCHAR),
                                    IS_PROTECT_MODE());

            RequestLength = strlen(Request);

            //  Find DirHandle
            ptr = Request;
            while ( (*ptr != 0) &&
                    (!IS_ASCII_PATH_SEPARATOR(*ptr)) &&
                    (*ptr != ':' )) {
                ptr++;
            }

            if (IS_ASCII_PATH_SEPARATOR(*ptr)) {
                int ServerNameLength = (int) (ptr - Request);
                PUCHAR scanptr = ptr;

                //
                //  Make sure there is a ":" further up the name otherwise
                //  we could confuse foo\bar.txt with a server called foo
                //

                while ( (*scanptr != 0) &&
                        (*scanptr != ':' )) {
                    scanptr++;
                }

                if (*scanptr) {
                    //
                    //  Name is of the form server\sys:foo\bar.txt
                    //  set connection appropriately.
                    //

                    for (Connection = 0; Connection < MC ; Connection++ ) {

                        //
                        //  Look for server foo avoiding foobar.
                        //

                        if ((pNwDosTable->ConnectionIdTable[Connection].ci_InUse ==
                                    IN_USE) &&
                            (!memcmp( pNwDosTable->ServerNameTable[Connection],
                                      Request,
                                      ServerNameLength)) &&
                            (pNwDosTable->ServerNameTable[Connection][ServerNameLength] ==
                                '\0')) {
                            break;  // Connection is the correct server
                        }
                    }

                    //
                    // Move Request to after the seperator and ptr to the ":"
                    //

                    RequestLength -= (ULONG) (ptr + sizeof(UCHAR) - Request);
                    Request = ptr + sizeof(UCHAR);
                    ptr = scanptr;
                }
            }

            if (*ptr) {

                //
                //  Name of form "sys:foo\bar.txt" this gives the server
                //  all the information required.
                //

                DirHandle = 0;

                if (Request[1] == ':') {

                    UCHAR Drive = tolower(Request[0])-'a';

                    //
                    //  Its a normal (redirected) drive k:foo\bar.txt.
                    //  Use the drive tables to give the connection and handle.
                    //

                    Connection = pNwDosTable->DriveIdTable[ Drive ] - 1;
                    DirHandle = pNwDosTable->DriveHandleTable[Drive];

                    if (DirHandle == 0) {
                        DirHandle = (UCHAR)GetDirectoryHandle2(Drive);
                    }
                    Request += 2;           // skip "k:"
                    RequestLength -= 2;
                }

            } else {

                WCHAR Curdir[256];

                //
                //  Name of form "foo\bar.txt"
                //

                GetCurrentDirectory(sizeof(Curdir) / sizeof(WCHAR), Curdir);

                Win32DirectoryHandle =
                    CreateFileW( Curdir,
                                0,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_BACKUP_SEMANTICS,
                                0);

                if (Win32DirectoryHandle != INVALID_HANDLE_VALUE) {
                    DWORD BytesReturned;

                    if ( DeviceIoControl(
                            Win32DirectoryHandle,
                            IOCTL_NWR_RAW_HANDLE,
                            NULL,
                            0,
                            (PUCHAR)&DirHandle,
                            sizeof(DirHandle),
                            &BytesReturned,
                            NULL ) == FALSE ) {

                        CloseHandle( Win32DirectoryHandle );
                        setAL(0xff);
                        return;

                    }

                } else {

                    setAL(0xff);
                    return;
                }
            }

            if (Operation == 0xEB00) {
                status = NwlibMakeNcp(
                            ServerHandles[Connection],
                            NWR_ANY_F2_NCP(0x03),
                            RequestLength + 5,
                            0,  //  ResponseSize
                            "bbwbr",
                            DirHandle,
                            (LockMode) ? Function : 0,
                            (LockMode) ? getBP() : 0,
                            RequestLength,
                            Request, RequestLength );

                Tickle[Connection] = TRUE;

            } else {
                status = NwlibMakeNcp(
                            ServerHandles[Connection],
                            (Operation == 0xEC00 ) ?
                                NWR_ANY_F2_NCP(0x07) :
                                NWR_ANY_F2_NCP(0x05),
                            RequestLength + 2,
                            0,  //  ResponseSize
                            "bbr",
                            DirHandle,
                            RequestLength,
                            Request, RequestLength );
            }

            if (Win32DirectoryHandle) {
                CloseHandle( Win32DirectoryHandle );
            }
        }
        break;

    }

    if (!NT_SUCCESS(status)) {
        setAL((UCHAR)RtlNtStatusToDosError(status));
        return;
    } else {
        setAL(0);
    }
}

VOID
InitLocks(
    VOID
    )
/*++

Routine Description:

    Reset the Tickle internal variables

Arguments:

    None.

Return Value:

    None.

--*/
{

    ZeroMemory( Tickle, sizeof(Tickle));
}

VOID
ResetLocks(
    VOID
    )
/*++

Routine Description:

    Reset the Locks for the current VDM. Called during process exit.

Arguments:

    None.

Return Value:

    None.

--*/
{

    Locks(0xCF00);  //  Clear all File sets.

}

NTSTATUS
Sem(
    UCHAR Function,
    UCHAR Connection
    )
/*++

Routine Description:

    Build all NCPs for Semaphore support

Arguments:

    Function - Supplies the subfunction from AL

    Connection - Supplies the server for the request

Return Value:

    None.

--*/
{
    PUCHAR Request;
    NTSTATUS status;

    switch (Function) {

        UCHAR Value;
        UCHAR OpenCount;
        WORD  HandleHigh, HandleLow;

    case 0: //OpenSemaphore

        Request = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                256 * sizeof(UCHAR),
                                IS_PROTECT_MODE());

        NwPrint(("Nw16: OpenSemaphore\n"));

        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x20),
                    Request[0] + 3,  //  RequestSize
                    5,  //  ResponseSize
                    "bbr|wwb",
                    0,
                    getCL(),    // Semaphore Value
                    Request, Request[0] + 1,

                    &HandleHigh, &HandleLow,
                    &OpenCount);


        if (NT_SUCCESS(status)) {
            setBL(OpenCount);
            setCX(HandleHigh);
            setDX(HandleLow);
        }

        break;

    case 1: // ExamineSemaphore

        NwPrint(("Nw16: ExamineSemaphore\n"));
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x20),
                    5,  //  RequestSize
                    2,  //  ResponseSize
                    "bww|bb",
                    1,
                    getCX(),getDX(),

                    &Value,
                    &OpenCount);

        if (NT_SUCCESS(status)) {
            setCX(Value);
            setDL(OpenCount);
        }
        break;

    case 2: // WaitOnSemaphore
        NwPrint(("Nw16: WaitOnSemaphore\n"));
        status = NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x20),
                    7,  //  RequestSize
                    0,  //  ResponseSize
                    "bwww",
                    2,
                    getCX(),getDX(),
                    getBP());
        break;

    case 3: // SignalSemaphore
        NwPrint(("Nw16: SignalSemaphore\n"));
    case 4: // CloseSemaphore

        if (Function == 4) {
            NwPrint(("Nw16: CloseSemaphore\n"));
        }

        status = NwlibMakeNcp(      //  Close and Signal
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(0x20),
                    5,  //  RequestSize
                    0,  //  ResponseSize
                    "bww",
                    Function,
                    getCX(),getDX());
        break;

    default:
        NwPrint(("Nw16: Unknown Semaphore operation %d\n", Function));
        status = STATUS_INVALID_PARAMETER;
        break;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\ndsutils\volinfo.c ===
/***

Copyright (c) 1995  Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    A command line NDS utility for resolving volume objects.

Author:

    Cory West       [corywest]  25-Oct-95

***/

#include "ndsapi32.h"

int
_cdecl main(
    int argc,
    char **argv
) {

    NTSTATUS Status;
    HANDLE hNdsTree;
    OEM_STRING OemArg;

    UNICODE_STRING NdsTree;
    WCHAR TreeBuffer[48];     // Max nds tree name length.

    UNICODE_STRING Volume;
    WCHAR VolumeBuffer[256];  // Max nds name length.

    UNICODE_STRING HostServer, HostVolume;
    WCHAR HostServerBuffer[48];
    WCHAR HostVolumeBuffer[256];

    //
    // Who do we want to monkey with?
    //

    if ( argc != 3 ) {
        printf( "Usage: volinfo [tree name] [volume object]\n" );
        return -1;
    }

    //
    // Get the tree.
    //

    OemArg.Length = strlen( argv[1] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[1];

    NdsTree.Length = 0;
    NdsTree.MaximumLength = sizeof( TreeBuffer );
    NdsTree.Buffer = TreeBuffer;

    RtlOemStringToUnicodeString( &NdsTree, &OemArg, FALSE );

    //
    // Open up a handle to the tree.
    //

    Status = NwNdsOpenTreeHandle( &NdsTree,
                                  &hNdsTree );

    if ( !NT_SUCCESS( Status ) ) {
       printf( "The supplied tree name is invalid or the tree is unavailable.\n" );
       return -1;
    }

    //
    // Get the volume information.
    //

    OemArg.Length = strlen( argv[2] );
    OemArg.MaximumLength = OemArg.Length;
    OemArg.Buffer = argv[2];

    Volume.Length = 0;
    Volume.MaximumLength = sizeof( VolumeBuffer );
    Volume.Buffer = VolumeBuffer;

    RtlOemStringToUnicodeString( &Volume, &OemArg, FALSE );

    //
    // Set up the reply strings.
    //

    HostServer.Length = 0;
    HostServer.MaximumLength = sizeof( HostServerBuffer );
    HostServer.Buffer = HostServerBuffer;

    HostVolume.Length = 0;
    HostVolume.MaximumLength = sizeof( HostVolumeBuffer );
    HostVolume.Buffer = HostVolumeBuffer;

    Status = NwNdsGetVolumeInformation( hNdsTree,
                                        &Volume,
					&HostServer,
					&HostVolume );


    CloseHandle( hNdsTree );

    if ( NT_SUCCESS( Status )) {
        printf( "Host Server: %wZ\n", &HostServer );
        printf( "Host Volume: %wZ\n", &HostVolume );
	return 0;
    }

    printf( "Unable to complete the requested operation: 0x%08lx\n", Status );
    return -1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\dll\procs.h ===
/*++

Copyright (c) 1993/4  Microsoft Corporation

Module Name:

    procs.c

Abstract:

    Common header file for routines which support 16 bit
    applications.

Author:

    Colin Watson    (colinw)    21-Nov-1993

Environment:


Revision History:


--*/

#ifndef DBG
#define DBG 0
#endif

#if !DBG
#undef NWDBG
#endif

#define UNICODE

#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <string.h>     // strcmp
#include <stdio.h>
#include <stdarg.h>
#include <debugfmt.h>   // FORMAT_LPSTR

#include <nwapi.h>
#include <nwxchg.h>
#include <ntddnwfs.h>
#include <npapi.h>
#include <nwrnames.h>

#include <vddsvc.h>
#include <nwdos.h>
#include <ncp.h>

#define IDS_CLIENT_ID_STRING          1
#define IDS_CLIENT_ID_STRING_NEC98    2

//  Locks.c

VOID
Locks(
    USHORT Command
    );

VOID
InitLocks(
    VOID
    );

VOID
ResetLocks(
    VOID
    );


//  Ncp.c

extern PNWDOSTABLE pNwDosTable;
extern HANDLE ServerHandles[MC];

CONN_INDEX
SelectConnection(
    VOID
    );

CONN_INDEX
SelectConnectionInCWD(
    VOID
    );

NTSTATUS
OpenConnection(
    CONN_INDEX Connection
    );

ULONG
GetDirectoryHandle2(
    DWORD Drive
    );


#define GET_NT_HANDLE() (HANDLE)(pNwDosTable->NtHandleHi << 16 | pNwDosTable->NtHandleLow)
#define GET_NT_SRCHANDLE() (HANDLE)(pNwDosTable->NtHandleSrcHi << 16 | pNwDosTable->NtHandleSrcLow)


//
// MSW_PE: Machine Status Word Protect-mode enable bit
//

#ifndef MSW_PE
#define MSW_PE  0x0001
#endif

#undef getMSW
extern  WORD getMSW(VOID);

#define IS_PROTECT_MODE()   (UCHAR)((getMSW() & MSW_PE)? TRUE : FALSE)

#if NWDBG

#define NwPrint(String) NwPrintf String;

VOID
DebugControl(
    int Command
    );

VOID
NwPrintf(
    char *Format,
    ...
    );

VOID
VrDumpRealMode16BitRegisters(
    IN  BOOL    DebugStyle
    );

VOID
VrDumpNwData(
    VOID
    );

VOID
DisplayExtendedError(
    VOID
    );

VOID
FormattedDump(
    PCHAR far_p,
    LONG  len
    );

#else

#define NwPrint(_x_)
#define VrDumpRealMode16BitRegisters(_x_)
#define VrDumpNwData( )
#define DisplayExtendedError( )
#define FormattedDump(_x_,_y_)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\dll\ncp.c ===
/*++

Copyright (c) 1993/4  Microsoft Corporation

Module Name:

    ncp.c

Abstract:

    Contains routine which accepts the bop from a 16 bit
    application and processes the request appropriately.
    Normally it performes an NCP exchange on behalf of the
    application.

Author:

    Colin Watson    (colinw)    07-Jul-1993

Environment:


Revision History:


--*/

#include "procs.h"

#define BASE_DOS_ERROR  ((NTSTATUS )0xC0010000L)

#include <packon.h>
typedef struct _TTSOUTPACKET {
    UCHAR SubFunction;
    USHORT cx;
    USHORT dx;
} TTSOUTPACKET, *PTTSOUTPACKET ;

typedef struct _TTSINPACKET{
    USHORT cx;
    USHORT dx;
} TTSINPACKET, *PTTSINPACKET;

#include <packoff.h>

VOID
InitDosTable(
    PNWDOSTABLE pdt
    );

VOID
LoadPreferredServerName(
    VOID
    );

VOID
ProcessResourceArray(
    LPNETRESOURCE   NetResource,
    DWORD           NumElements
    );

VOID
ProcessResource(
    LPNETRESOURCE   NetResource
    );

VOID
SendNCP(
    ULONG Command
    );

VOID
SendF2NCP(
    ULONG Command
    );

UCHAR
AttachmentControl(
    ULONG Command
    );

VOID
SendNCP2(
    ULONG Command,
    PUCHAR Request,
    ULONG RequestLength,
    PUCHAR Reply,
    ULONG ReplyLength
    );

VOID
CloseConnection(
    CONN_INDEX Connection
    );

NTSTATUS
InitConnection(
    CONN_INDEX Connection
    );

VOID
GetDirectoryHandle(
    VOID
    );

VOID
LoadDriveHandleTable(
    VOID
    );

VOID
AllocateDirectoryHandle(
    VOID
    );

VOID
ResetDrive(
    UCHAR Drive
    );

VOID
AllocateDirectoryHandle2(
    VOID
    );

PWCHAR
BuildUNC(
    IN PUCHAR aName,
    IN ULONG aLength
    );

VOID
GetServerDateAndTime(
    VOID
    );

VOID
GetShellVersion(
    IN USHORT Command
    );

VOID
TTS(
    VOID
    );

VOID
OpenCreateFile(
    VOID
    );

BOOL
IsItNetWare(
    PUCHAR Name
    );

VOID
SetCompatibility(
    VOID
    );

VOID
OpenQueueFile(
    VOID
    );

VOID
AttachHandle(
    VOID
    );

VOID
ProcessExit(
    VOID
    );

VOID
SystemLogout(
    VOID
    );

VOID
ServerFileCopy(
    VOID
    );

VOID
SetStatus(
    NTSTATUS Status
    );

//
//  The following pointer contains the 32 bit virtual address of where
//  the nw16.exe tsr holds the workstation structures.
//

PNWDOSTABLE pNwDosTable;

//
//  Global variables used to hold the state for this process
//

UCHAR OriginalPrimary = 0;
HANDLE ServerHandles[MC];

HANDLE Win32DirectoryHandleTable[MD];
PWCHAR Drives[MD]; // Strings such as R: or a unc name

UCHAR  SearchDriveTable[16];


BOOLEAN Initialized = FALSE;
BOOLEAN TablesValid = FALSE;                // Reload each time a process starts
BOOLEAN DriveHandleTableValid = FALSE;      // Reload first time process does NW API

WORD DosTableSegment;
WORD DosTableOffset;

extern UCHAR LockMode;

#if NWDBG
BOOL GotDebugState = FALSE;
extern int DebugCtrl;
#endif


VOID
Nw16Register(
    VOID
    )
/*++

Routine Description:

    This function is called by wow when nw16.sys is loaded.

Arguments:


Return Value:

    None.

--*/
{
    DWORD           status;
    HANDLE          enumHandle;
    LPNETRESOURCE   netResource;
    DWORD           numElements;
    DWORD           bufferSize;
    DWORD           dwScope = RESOURCE_CONNECTED;

    NwPrint(("Nw16Register\n"));

    if ( !Initialized) {
        UCHAR CurDir[256];
        DosTableSegment = getAX();
        DosTableOffset = getDX();

        //
        // this call always made from Real Mode (hence FALSE for last param)
        //

        pNwDosTable = (PNWDOSTABLE) GetVDMPointer (
                                        (ULONG)((DosTableSegment << 16)|DosTableOffset),
                                        sizeof(NWDOSTABLE),
                                        FALSE
                                        );

        InitDosTable( pNwDosTable );

        if ((GetCurrentDirectoryA(sizeof(CurDir)-1, CurDir) >= 2) &&
            (CurDir[1] == ':')) {
            pNwDosTable->CurrentDrive = tolower(CurDir[0]) - 'a';
        }

        InitLocks();
    }


#if NWDBG
    {
        WCHAR Value[80];

        if (GetEnvironmentVariableW(L"NWDEBUG",
                                     Value,
                                     sizeof(Value)/sizeof(Value[0]) - 1)) {

            DebugCtrl = Value[0] - '0';

            //  0 Use logfile
            //  1 Use debugger
            //  2/undefined No debug output
            //  4 Use logfile, close on process exit
            //  8 Use logfile, verbose, close on process exit

            DebugControl( DebugCtrl );

            GotDebugState = TRUE;  // Don't look again until process exits vdm
        }
    }
#endif

    LoadPreferredServerName();

    //
    // Attempt to allow for MD drives
    //

    bufferSize = (MD*sizeof(NETRESOURCE))+1024;

    netResource = (LPNETRESOURCE) LocalAlloc(LPTR, bufferSize);

    if (netResource == NULL) {

        NwPrint(("Nw16Register: LocalAlloc Failed %d\n",GetLastError));
        setCF(1);
        return;
    }

    //-----------------------------------//
    // Get a handle for a top level enum //
    //-----------------------------------//
    status = NPOpenEnum(
                dwScope,
                RESOURCETYPE_DISK,
                0,
                NULL,
                &enumHandle);

    if ( status != WN_SUCCESS) {
        NwPrint(("Nw16Register:WNetOpenEnum failed %d\n",status));

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto LoadLocal;
    }

    // ---- Multi-user code change : Add "while" ----
    while ( status == WN_SUCCESS ) {

        //-----------------------------//
        // Enumerate the disk devices. //
        //-----------------------------//

        numElements = 0xffffffff;

        status = NwEnumConnections(
                                  enumHandle,
                                  &numElements,
                                  netResource,
                                  &bufferSize,
                                  TRUE);  // Include implicit connections


        if ( status == WN_SUCCESS) {
            //----------------------------------------//
            // Insert the results in the Nw Dos Table //
            //----------------------------------------//
            ProcessResourceArray( netResource, numElements);

        }
    } // end while

    if ( status == WN_NO_MORE_ENTRIES ) {
        status = WN_SUCCESS;
    } else

        if ( status != WN_SUCCESS) {
        NwPrint(("Nw16Register:NwEnumResource failed %d\n",status));

        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        WNetCloseEnum(enumHandle);
        goto LoadLocal;
    }

    //------------------------------------------//
    // Close the EnumHandle & print the results //
    //------------------------------------------//

    status = NPCloseEnum(enumHandle);
    if (status != WN_SUCCESS) {
        NwPrint(("Nw16Register:WNetCloseEnum failed %d\n",status));
        //
        // If there is an extended error, display it.
        //
        if (status == WN_EXTENDED_ERROR) {
            DisplayExtendedError();
        }
        goto LoadLocal;

    }

LoadLocal:

    //
    //  Add the local devices so that NetWare apps don't try to map them
    //  to remote servers.
    //

    {
        USHORT Drive;
        WCHAR DriveString[4];
        UINT Type;

        DriveString[1] = L':';
        DriveString[2] = L'\\';
        DriveString[3] = L'\0';

        //
        // Hardwire A: and B: because hitting the floppy drive with
        // GetDriveType takes too long.
        //

        pNwDosTable->DriveFlagTable[0] = LOCAL_DRIVE;
        pNwDosTable->DriveFlagTable[1] = LOCAL_DRIVE;


        for (Drive = 2; Drive <= 'Z' - 'A'; Drive++ ) {

            if (pNwDosTable->DriveFlagTable[Drive] == 0) {
                DriveString[0] = L'A' + Drive;
                Type = GetDriveTypeW( DriveString );

                //
                //  0 means drive type cannot be determined, all others are
                //  provided by other filesystems.
                //

                if (Type != 1) {
                    pNwDosTable->DriveFlagTable[Drive] = LOCAL_DRIVE;
                }
            }
        }

#ifdef NWDBG
        for (Drive = 0; Drive < MD; Drive++ ) {

            DriveString[0] = L'A' + Drive;

            NwPrint(("%c(%d)=%x,",'A' + Drive,
                GetDriveTypeW( DriveString ),
                pNwDosTable->DriveFlagTable[Drive] ));

            if (!((Drive + 1) % 8)) {
                NwPrint(("\n",0));
            }
        }

        NwPrint(("\n"));
#endif

    }

    if ( !Initialized ) {
        Initialized = TRUE;
        pNwDosTable->PrimaryServer = OriginalPrimary;
    }

    TablesValid = TRUE;

    LocalFree(netResource);
    setCF(0);

    NwPrint(("Nw16Register: End\n"));
}

VOID
LoadPreferredServerName(
    VOID
    )
{

    //
    //  If we already have a connection to somewhere then we already have a
    //  preferred servername of some sort.
    //

    if (pNwDosTable->ConnectionIdTable[0].ci_InUse == IN_USE) {
        return;
    }

    //
    //  Load the server name table with the preferred/nearest server.
    //

    CopyMemory( pNwDosTable->ServerNameTable[0], "*", sizeof("*"));

    if (NT_SUCCESS(OpenConnection( 0 ))) {

        if( NT_SUCCESS(InitConnection(0)) ) {

            //
            //  Close the handle so that the rdr can be stopped if
            //  user is not running a netware aware application.
            //

            CloseConnection(0);

            pNwDosTable->PrimaryServer = 1;

            return;

        }

    }

    pNwDosTable->PrimaryServer = 0;

}

VOID
ProcessResourceArray(
    LPNETRESOURCE  NetResource,
    DWORD           NumElements
    )
{
    DWORD   i;
    for (i=0; i<NumElements ;i++ ) {
        ProcessResource(&(NetResource[i]));
    }
    return;
}

VOID
ProcessResource(
    LPNETRESOURCE   NetResource
    )
{
    SERVERNAME ServerName;
    int ServerNameLength;
    int i;
    int Connection;
    BOOLEAN Found = FALSE;

    //
    // Extract Server Name from RemoteName, skipping first 2 chars that
    // contain backslashes and taking care to handle entries that only
    // contain a servername.
    //


    ServerNameLength = wcslen( NetResource->lpRemoteName );

    ASSERT(NetResource->lpRemoteName[0] == '\\');
    ASSERT(NetResource->lpRemoteName[1] == '\\');

    for (i = 2; i <= ServerNameLength; i++) {

        if ((NetResource->lpRemoteName[i] == '\\') ||
            (i == ServerNameLength )){

            ServerNameLength = i - 2;

            WideCharToMultiByte(
                CP_OEMCP,
                0,
                &NetResource->lpRemoteName[2],
                ServerNameLength,
                ServerName,
                sizeof( ServerName ),
                NULL,
                NULL );

            CharUpperBuffA( ServerName, ServerNameLength );

            ZeroMemory( &ServerName[ServerNameLength],
                        SERVERNAME_LENGTH - ServerNameLength );

            break;
        }

    }

    //
    //  Now try to find ServerName in the connection table. If there are
    //  more than MC servers in the table already then skip this one.
    //

    for (Connection = 0; Connection < MC ; Connection++ ) {
        if ((pNwDosTable->ConnectionIdTable[Connection].ci_InUse == IN_USE) &&
            (!memcmp( pNwDosTable->ServerNameTable[Connection], ServerName, SERVERNAME_LENGTH))) {
            Found = TRUE;
            break;
        }
    }


    NwPrint(("Nw16ProcessResource Server: %s\n",ServerName));

    if ( Found == FALSE ) {
        for (Connection = 0; Connection < MC ; Connection++ ) {
            if (pNwDosTable->ConnectionIdTable[Connection].ci_InUse == FREE) {

                CopyMemory( pNwDosTable->ServerNameTable[Connection],
                    ServerName,
                    SERVERNAME_LENGTH);

                if ((NT_SUCCESS(OpenConnection( (CONN_INDEX)Connection ))) &&
                    ( NT_SUCCESS(InitConnection( (CONN_INDEX)Connection ) ))) {

                        Found = TRUE;

                } else {
                    //  Couldn't talk to the server so ignore it.
                    ZeroMemory( pNwDosTable->ServerNameTable[Connection], SERVERNAME_LENGTH );

                }

                break;  // Escape from for (Connection =...
            }
        }
    }

    //
    //  Build the drive id and drive flag tables.   Entries 0 - 25
    //  are reserved for drives redirected to letters.  We use drives
    //  26 - 31 for UNC drives.
    //

    if ( Found == TRUE ) {
        DRIVE Drive;
        DRIVE NextUncDrive = 26;

        if ( NetResource->dwType != RESOURCETYPE_DISK ) {
            return;
        }

        if ( NetResource->lpLocalName != NULL) {
            Drive = NetResource->lpLocalName[0] - L'A';
        } else {
            if ( NextUncDrive < MD ) {
                Drive = NextUncDrive++;
            } else {

                //
                //  No room in the table for this UNC drive.
                //

                return;
            }
        }

        //
        //  We have a drive and a connection. Complete the table
        //  mappings.
        //

        pNwDosTable->DriveIdTable[ Drive ] = Connection + 1;
        pNwDosTable->DriveFlagTable[ Drive ] = PERMANENT_NETWORK_DRIVE;

    }

}


VOID
InitDosTable(
    PNWDOSTABLE pdt
    )

/*++

Routine Description:

    This routine Initializes the NetWare Dos Table to its empty values.

Arguments:

    pdt - Supplies the table to be initialized.

Return Value:

    None

--*/
{
    ZeroMemory( ServerHandles, sizeof(ServerHandles) );
    ZeroMemory( Drives, sizeof(Drives) );
    ZeroMemory( (PVOID) pdt, sizeof(NWDOSTABLE) );
    ZeroMemory( Win32DirectoryHandleTable, sizeof(Win32DirectoryHandleTable) );
    FillMemory( SearchDriveTable, sizeof(SearchDriveTable), 0xff );
}

UCHAR CpuInProtectMode;


VOID
Nw16Handler(
    VOID
    )
/*++

Routine Description:

    This function is called by wow when nw16.sys traps an Int and
    bop's into 32 bit mode.

Arguments:


Return Value:

    None,

--*/
{
    USHORT Command;
    WORD offset;

    //
    // get the CPU mode once: the memory references it's required for won't
    // change during this call. Cuts down number of calls to getMSW()
    //

    CpuInProtectMode = IS_PROTECT_MODE();

    setCF(0);
    if ( TablesValid == FALSE ) {

        //
        //  Load the tables unless the process is exiting.
        //

        if ((pNwDosTable->SavedAx & 0xff00) != 0x4c00) {
            Nw16Register();
        }

#if NWDBG
        if (GotDebugState == FALSE) {

            WCHAR Value[80];

            if (GetEnvironmentVariableW(L"NWDEBUG",
                                         Value,
                                         sizeof(Value)/sizeof(Value[0]) - 1)) {

                DebugCtrl = Value[0] - '0';

                //  0 Use logfile
                //  1 Use debugger
                //  2/undefined No debug output
                //  4 Use logfile, close on process exit
                //  8 Use logfile, verbose, close on process exit

                DebugControl( DebugCtrl );

            }

            GotDebugState = TRUE;  // Don't look again until process exits vdm
        }
#endif
    }

    //
    //  Normal AX register is used to get into 32 bit code so get applications
    //  AX from the shared datastructure.
    //

    Command = pNwDosTable->SavedAx;

    //
    //  set AX register so that AH gets preserved
    //

    setAX( Command );

    NwPrint(("Nw16Handler process command %x\n", Command ));
    VrDumpRealMode16BitRegisters( FALSE );
    VrDumpNwData();

    switch (Command & 0xff00) {

    case 0x3C00:
    case 0x3D00:
            OpenCreateFile();
            break;

    case 0x4C00:
            ProcessExit();              //  Close all handles
            goto default_dos_handler;   //  Let Dos handle rest of processing
            break;

    case 0x9f00:
            OpenQueueFile();
            break;

    case 0xB300:                        //  Packet Signing
            setAL(0);                   //  not supported
            break;

    case 0xB400:
            AttachHandle();
            break;

    case 0xB500:
        switch (Command & 0x00ff) {
        case 03:
            setAX((WORD)pNwDosTable->TaskModeByte);
            break;

        case 04:
            setES((WORD)(CpuInProtectMode ? pNwDosTable->PmSelector : DosTableSegment));
            setBX((WORD)(DosTableOffset + &((PNWDOSTABLE)0)->TaskModeByte));
            break;

        case 06:
            setAX(2);
            break;

        default:
            goto default_dos_handler;
        }
        break;

    case 0xB800:    // Capture - Not supported
        setAL(0xff);
        setCF(1);
        break;

    case 0xBB00:    // Set EOJ status
        {
            static UCHAR EOJstatus = 1;
            setAL(EOJstatus);
            EOJstatus = pNwDosTable->SavedAx & 0x00ff;
        }
        break;

    case 0xBC00:
    case 0xBD00:
    case 0xBE00:

    case 0xC200:
    case 0xC300:
    case 0xC400:
    case 0xC500:
    case 0xC600:
        Locks(Command);
        break;

    case 0xC700:
        TTS();
        break;

    case 0xCB00:
    case 0xCD00:
    case 0xCF00:

    case 0xD000:
    case 0xD100:
    case 0xD200:
    case 0xD300:
    case 0xD400:
    case 0xD500:
        Locks(Command);
        break;

    case 0xD700:
        SystemLogout();
        break;

    case 0xDB00:
        {
            UCHAR Drive;
            UCHAR Count = 0;
            for (Drive = 0; Drive < MD; Drive++) {
                if (pNwDosTable->DriveFlagTable[Drive] == LOCAL_DRIVE ) {
                    Count++;
                }
            }
            setAL(Count);
        }
        break;

    case 0xDC00:    //  Get station number
        {
            CONN_INDEX Connection = SelectConnection();
            if (Connection == 0xff) {
                setAL(0xff);
                setCF(1);
            } else {

                PCONNECTIONID pConnection =
                    &pNwDosTable->ConnectionIdTable[Connection];

                setAL(pConnection->ci_ConnectionLo);
                setAH(pConnection->ci_ConnectionHi);
                setCH( (UCHAR)((pConnection->ci_ConnectionHi == 0) ?
                                pConnection->ci_ConnectionLo / 10 + '0':
                                'X'));
                setCL((UCHAR)(pConnection->ci_ConnectionLo % 10 + '0'));
            }
        }
        break;

    case 0xDD00:    //  Set NetWare Error mode
        {
            static UCHAR ErrorMode = 0;
            setAL( ErrorMode );
            ErrorMode = getDL();
        }
        break;

    case 0xDE00:
        {
            static UCHAR BroadCastMode = 0;
            UCHAR OpCode = getDL();
            if ( OpCode < 4) {
                BroadCastMode = OpCode;
            }
            setAL(BroadCastMode);
        }
        break;

    case 0xDF00:    // Capture - Not supported
        setAL(0xff);
        setCF(1);
        break;

    case 0xE000:
    case 0xE100:
    case 0xE300:
        SendNCP(Command);
        break;

    case 0xE200:

        AllocateDirectoryHandle();
        break;

    case 0xE700:
        GetServerDateAndTime();
        break;

    case 0xE900:

        switch (Command & 0x00ff) {
        PUCHAR ptr;
        case 0:
            GetDirectoryHandle();
            break;

        case 1:
            ptr = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                sizeof(SearchDriveTable),
                                CpuInProtectMode
                                );

            RtlMoveMemory( ptr, SearchDriveTable, sizeof(SearchDriveTable) );
            break;

        case 2:
            ptr = GetVDMPointer (
                                (ULONG)((getDS() << 16)|getDX()),
                                sizeof(SearchDriveTable),
                                CpuInProtectMode
                                );

            RtlMoveMemory( SearchDriveTable, ptr, sizeof(SearchDriveTable) );
            break;

        case 5:
            AllocateDirectoryHandle2();
            break;

        case 7:
            setAL(0xff);    // Drive depth not yet implemented
            break;

#ifdef NWDBG
        //  Debug control
        case 0xf0:  //  Use logfile
        case 0xf1:  //  Use debugger
        case 0xf2:  //  No debug output
            DebugControl(Command & 0x000f);
            break;
#endif
        default:
            NwPrint(("Nw16Handler unprocessed interrupt %x\n", pNwDosTable->SavedAx ));
        }
        break;

    case 0xEA00:
        GetShellVersion(Command);
        break;

    case 0xEB00:
    case 0xEC00:
    case 0xED00:
        Locks(Command);
        break;


    case 0xEF00:
        NwPrint(("Nw32: %x\n", pNwDosTable->SavedAx ));

        switch (Command & 0xff) {
        case 00:
            if (DriveHandleTableValid == FALSE) {
                LoadDriveHandleTable();
            }

            offset = (WORD)&((PNWDOSTABLE)0)->DriveHandleTable;
            break;

        case 01:
            offset = (WORD)&((PNWDOSTABLE)0)->DriveFlagTable;
            break;

        case 02:
            offset = (WORD)&((PNWDOSTABLE)0)->DriveIdTable;
            break;

        case 03:
            offset = (WORD)&((PNWDOSTABLE)0)->ConnectionIdTable;
            break;

        case 04:
            offset = (WORD)&((PNWDOSTABLE)0)->ServerNameTable;
            break;

        default:
            goto default_dos_handler;
        }
        setSI((WORD)(DosTableOffset + offset));
        setES((WORD)(CpuInProtectMode ? pNwDosTable->PmSelector : DosTableSegment));
        setAL(0);
        break;

    case 0xF100:
        setAL(AttachmentControl(Command));
        break;

    case 0xF200:
        SendF2NCP(Command);
        break;

    case 0xF300:
        ServerFileCopy();
        break;

    default:

default_dos_handler:

        NwPrint(("Nw16Handler unprocessed interrupt %x\n", pNwDosTable->SavedAx ));

        //
        // if we don't handle this call, we modify the return ip to point to
        // code that will restore the stack and jump far into dos
        //

        setIP((WORD)(getIP() + 3));

    }

#if NWDBG
    pNwDosTable->SavedAx = getAX();
#endif
    VrDumpRealMode16BitRegisters( FALSE );
}


CONN_INDEX
SelectConnection(
    VOID
    )
/*++

Routine Description:

    Pick target connection for current transaction

Arguments:

    None

Return Value:

    Index into ConnectionIdTable or 0xff,

--*/
{

    UCHAR IndexConnection;

    if ( pNwDosTable->PreferredServer != 0 ) {
        return(pNwDosTable->PreferredServer - 1);
    }

    // select default server if current drive is mapped by us?

    if ( pNwDosTable->PrimaryServer != 0 ) {
        return(pNwDosTable->PrimaryServer - 1);
    }


    // Need to pick another


    for (IndexConnection = 0; IndexConnection < MC ; IndexConnection++ ) {

        if (pNwDosTable->ConnectionIdTable[IndexConnection].ci_InUse == IN_USE) {

            pNwDosTable->PrimaryServer = IndexConnection + 1;

            return(pNwDosTable->PrimaryServer - 1);

        }
    }

    // No servers in the table so find the nearest/preferred.

    LoadPreferredServerName();

    return(pNwDosTable->PrimaryServer - 1);

}


CONN_INDEX
SelectConnectionInCWD(
    VOID
    )
/*++

Routine Description:

    Pick target connection for current transaction. Give preference to 
    the current working directory.

Arguments:

    None

Return Value:

    Index into ConnectionIdTable or 0xff,

--*/
{

    UCHAR IndexConnection;
    CHAR CurDir[256];
    USHORT Drive; 

    // Try to return the connection  for CWD first.
    if ((GetCurrentDirectoryA(sizeof(CurDir)-1, CurDir) >= 2) &&
         (CurDir[1] = ':')) {
        Drive = tolower(CurDir[0]) - 'a';
    }
    IndexConnection = pNwDosTable->DriveIdTable[ Drive ] - 1 ; 

    if (pNwDosTable->ConnectionIdTable[IndexConnection].ci_InUse == IN_USE) {
        return IndexConnection ; 
    }

    if ( pNwDosTable->PreferredServer != 0 ) {
        return(pNwDosTable->PreferredServer - 1);
    }


    if ( pNwDosTable->PrimaryServer != 0 ) {
        return(pNwDosTable->PrimaryServer - 1);
    }


    // Need to pick another


    for (IndexConnection = 0; IndexConnection < MC ; IndexConnection++ ) {

        if (pNwDosTable->ConnectionIdTable[IndexConnection].ci_InUse == IN_USE) {

            pNwDosTable->PrimaryServer = IndexConnection + 1;

            return(pNwDosTable->PrimaryServer - 1);

        }
    }

    // No servers in the table so find the nearest/preferred.

    LoadPreferredServerName();

    return(pNwDosTable->PrimaryServer - 1);

}


VOID
SendNCP(
    ULONG Command
    )
/*++

Routine Description:

    Implement generic Send NCP function.

    ASSUMES called from Nw16Handler

Arguments:

    Command  - Supply the opcode 0xexxx
    DS:SI    - Supply Request buffer & length
    ES:DI    - Supply Reply buffer & length

    On return AL = Status of operation.

Return Value:

    None.

--*/
{
    PUCHAR Request, Reply;
    ULONG RequestLength, ReplyLength;
    UCHAR OpCode;

    OpCode = (UCHAR)((Command >> 8) - 0xcc);

    Request = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI()),
                            sizeof(WORD),
                            CpuInProtectMode
                            );

    Reply = GetVDMPointer (
                            (ULONG)((getES() << 16)|getDI()),
                            sizeof(WORD),
                            CpuInProtectMode
                            );

    RequestLength = *(WORD UNALIGNED*)Request;
    ReplyLength = *(WORD UNALIGNED*)Reply;

    Request = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI() + sizeof(WORD)),
                            (USHORT)RequestLength,
                            CpuInProtectMode
                            );
    Reply = GetVDMPointer (
                            (ULONG)((getES() << 16)|getDI()) + sizeof(WORD),
                            (USHORT)ReplyLength,
                            CpuInProtectMode
                            );

    NwPrint(("SubRequest     %x, RequestLength  %x\n", Request[0], RequestLength ));

    SendNCP2( NWR_ANY_NCP(OpCode ),
        Request,
        RequestLength,
        Reply,
        ReplyLength);
}


VOID
SendF2NCP(
    ULONG Command
    )
/*++

Routine Description:

    Implement generic Send NCP function. No length to be inseted by
    the redirector in the request buffer.

    ASSUMES called from Nw16Handler

Arguments:

    Command  - Supply the opcode 0xf2xx
    DS:SI CX - Supply Request buffer & length
    ES:DI DX - Supply Reply buffer & length

    On return AL = Status of operation.

Return Value:

    None.

--*/
{
    PUCHAR Request, Reply;
    ULONG RequestLength, ReplyLength;
    UCHAR OpCode;


    OpCode = (UCHAR)(Command & 0x00ff);

    RequestLength = getCX();
    ReplyLength = getDX();

    Request = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI()),
                            (USHORT)RequestLength,
                            CpuInProtectMode
                            );
    Reply = GetVDMPointer (
                            (ULONG)((getES() << 16)|getDI()),
                            (USHORT)ReplyLength,
                            CpuInProtectMode
                            );

    NwPrint(("F2SubRequest   %x, RequestLength  %x\n", Request[2], RequestLength ));

#if 0
    if ((RequestLength != 0) &&
        (OpCode == 0x17)) {

        if ((Request[2] == 0x17) ||
            (Request[2] == 0x18)) {
            //
            //  The request was for an encryption key. Tell the
            //  application that encryption is not supported.
            //

            setAL(0xfb);
            return;

        } else if ((Request[2] == 0x14 ) ||
                   (Request[2] == 0x3f )) {

            //
            //  Plaintext login or Verify Bindery Object Password.
            //  Convert to its WNET equivalent version.
            //

            UCHAR Name[256];
            UCHAR Password[256];
            UCHAR ServerName[sizeof(SERVERNAME)+3];
            PUCHAR tmp;
            CONN_INDEX Connection;
            NETRESOURCEA Nr;

            Connection = SelectConnection();
            if ( Connection == 0xff ) {
                setAL(0xff);
                setCF(1);
                return;
            }

            ZeroMemory( &Nr, sizeof(NETRESOURCE));
            ServerName[0] = '\\';
            ServerName[1] = '\\';
            RtlCopyMemory( ServerName+2, pNwDosTable->ServerNameTable[Connection], sizeof(SERVERNAME) );
            ServerName[sizeof(ServerName)-1] = '\0';
            Nr.lpRemoteName = ServerName;
            Nr.dwType = RESOURCETYPE_DISK;

            //  point to password length.
            tmp = &Request[6] + Request[5];

            Name[Request[5]] = '\0';
            RtlMoveMemory( Name, &Request[6], Request[5]);

            Password[tmp[0]] = '\0';
            RtlMoveMemory( Password, tmp+1, tmp[0]);

            NwPrint(("Connect to %s as %s password %s\n", ServerName, Name, Password ));

            if (NO_ERROR == WNetAddConnection2A( &Nr, Password, Name, 0)) {
                setAL(0);
            } else {
                setAL(255);
            }
            return;
        }
    }

#endif

    SendNCP2( NWR_ANY_F2_NCP(OpCode ),
        Request,
        RequestLength,
        Reply,
        ReplyLength);
}


VOID
SendNCP2(
    ULONG Command,
    PUCHAR Request,
    ULONG RequestLength,
    PUCHAR Reply,
    ULONG ReplyLength
    )
/*++

Routine Description:

    Pick target connection for current transaction

    This routine effectively opens a handle for each NCP sent. This means that
    we don't keep handles open to servers unnecessarily which would cause
    problems if a user tries to delete the connection or stop the workstation.

    If this causes to much of a load then the fallback is to spin off a thread
    that waits on an event with a timeout and periodically sweeps the
    server handle table removing stale handles. Setting the event would cause
    the thread to exit. Critical sections would need to be added to protect
    handles. Dll Init/exit routine to kill the thread and close the handles
    would also be needed.

Arguments:

    Command  - Supply the opcode
    Request, RequestLength - Supply Request buffer & length
    Reply, ReplyLength - Supply Reply buffer & length

    On return AL = Status of operation.

Return Value:

    None.

--*/
{
    CONN_INDEX Connection = SelectConnection();
    NTSTATUS status;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;

    NwPrint(("Send NCP %x to %d:%s\n", Command, Connection, pNwDosTable->ServerNameTable[Connection] ));
    NwPrint(("RequestLength  %x\n", RequestLength ));
    NwPrint(("Reply          %x, ReplyLength  %x\n", Reply, ReplyLength ));

    if (Connection == 0xff) {
        setAL(0xff);
        setCF(1);
        return;
    };

    if ( ServerHandles[Connection] == NULL ) {

        status = OpenConnection( Connection );

        if (!NT_SUCCESS(status)) {
            SetStatus(status);
            return;
        } else {
            InitConnection( Connection );
        }
    }

    Handle = ServerHandles[Connection];

    //
    //  If its a CreateJobandFile NCP then we need to use the handle
    //  created through Dos so that the writes go into the spoolfile created
    //  by this NCP.
    //

    if (Command == NWR_ANY_F2_NCP(0x17)) {

        if ((Request[2] == 0x68) ||
            (Request[2] == 0x79)) {

            Handle = GET_NT_HANDLE();
        }
    } else if (Command == NWR_ANY_NCP(0x17)) {
        if ((Request[0] == 0x68) ||
            (Request[0] == 0x79)) {

            Handle = GET_NT_HANDLE();
        }
    }

    FormattedDump( Request, RequestLength );

    //
    // Make the NCP request on the appropriate handle
    //

    status = NtFsControlFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 Command,
                 (PVOID) (Request),
                 RequestLength,
                 (PVOID) Reply,
                 ReplyLength);

    if (NT_SUCCESS(status)) {
        status = IoStatusBlock.Status;
        FormattedDump( Reply, ReplyLength );
    }

    if (!NT_SUCCESS(status)) {
        SetStatus(status);
        setCF(1);
        NwPrint(("NtStatus          %x, DosError     %x\n", status, getAL() ));
    } else {
        setAL(0);
    }
}


NTSTATUS
OpenConnection(
    CONN_INDEX Connection
    )
/*++

Routine Description:

    Open the handle to the redirector to access the specified server.

Arguments:

    Connection - Supplies the index to use for the handle

Return Value:

    Status of the operation

--*/
{
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    LPWSTR FullName;

    UCHAR AnsiName[SERVERNAME_LENGTH+sizeof(UCHAR)];

    UNICODE_STRING UServerName;
    OEM_STRING AServerName;

    if ( Connection >= MC) {
        return( BASE_DOS_ERROR + 249 ); // No free connection slots
    }

    if (ServerHandles[Connection] != NULL ) {

        CloseConnection(Connection);

    }

    FullName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                            sizeof( DD_NWFS_DEVICE_NAME_U ) +
                            (SERVERNAME_LENGTH + 1) * sizeof(WCHAR)
                            );

    if ( FullName == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(AnsiName,
                pNwDosTable->ServerNameTable[Connection],
                SERVERNAME_LENGTH);
    AnsiName[SERVERNAME_LENGTH] = '\0';

    RtlInitAnsiString( &AServerName, AnsiName );
    Status = RtlOemStringToUnicodeString( &UServerName,
                &AServerName,
                TRUE);

    if (!NT_SUCCESS(Status)) {
        LocalFree( FullName );
        return(Status);
    }

    wcscpy( FullName, DD_NWFS_DEVICE_NAME_U );
    wcscat( FullName, L"\\");
    wcscat( FullName, UServerName.Buffer );

    RtlFreeUnicodeString(&UServerName);

    RtlInitUnicodeString( &UServerName, FullName );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open a handle to the server.
    //

    //
    //  Try to login to the nearest server. This is necessary for
    //  the real preferred server if there are no redirections to
    //  it. The rdr can logout and disconnect. SYSCON doesn't like
    //  running from such a server.
    //
    Status = NtOpenFile(
                   &ServerHandles[Connection],
                   SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if ( NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS(Status)) {
        //
        //  Failed to login. Use the non-login method. This allows the
        //  app to do a bindery login or query the bindery.
        //

        Status = NtOpenFile(
                       &ServerHandles[Connection],
                       SYNCHRONIZE,
                       &ObjectAttributes,
                       &IoStatusBlock,
                       FILE_SHARE_VALID_FLAGS,
                       FILE_SYNCHRONOUS_IO_NONALERT
                       );

        if ( NT_SUCCESS(Status)) {
            Status = IoStatusBlock.Status;
        }
    }

    NwPrint(("Nw16:OpenConnection %d: %wZ status = %08lx\n", Connection, &UServerName, Status));

    LocalFree( FullName );

    if (!NT_SUCCESS(Status)) {
        SetStatus(Status);
        return Status;
    }

    return Status;
}


VOID
CloseConnection(
    CONN_INDEX Connection
    )
/*++

Routine Description:

    Close the connection handle

Arguments:

    Connection - Supplies the index to use for the handle

Return Value:

    None.

--*/
{
    if (ServerHandles[Connection]) {

        NwPrint(("CloseConnection: %d\n",Connection));

        NtClose(ServerHandles[Connection]);

        ServerHandles[Connection] = NULL;
    }
}


NTSTATUS
InitConnection(
    CONN_INDEX Connection
    )
/*++

Routine Description:

    Get the connection status from the redirector.

Arguments:

    Connection - Supplies the index to use for the handle

Return Value:

    Status of the operation

--*/
{
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    NWR_GET_CONNECTION_DETAILS Details;

    Status = NtFsControlFile(
                 ServerHandles[Connection],
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_NWR_GET_CONN_DETAILS,
                 NULL,
                 0,
                 (PVOID) &Details,
                 sizeof(Details));

    if (Status == STATUS_SUCCESS) {
        Status = IoStatusBlock.Status;
    }

    NwPrint(("Nw16:InitConnection: %d status = %08lx\n",Connection, Status));

    if (!NT_SUCCESS(Status)) {

        SetStatus(Status);

        CloseConnection(Connection);

    } else {
        PCONNECTIONID pConnection =
            &pNwDosTable->ConnectionIdTable[Connection];

        pConnection->ci_OrderNo= Details.OrderNumber;

        CopyMemory(pNwDosTable->ServerNameTable[Connection],
                    Details.ServerName,
                    sizeof(SERVERNAME));

        CopyMemory(pConnection->ci_ServerAddress,
                    Details.ServerAddress,
                    sizeof(pConnection->ci_ServerAddress));

        pConnection->ci_ConnectionNo= Details.ConnectionNumberLo;
        pConnection->ci_ConnectionLo= Details.ConnectionNumberLo;
        pConnection->ci_ConnectionHi= Details.ConnectionNumberHi;
        pConnection->ci_MajorVersion= Details.MajorVersion;
        pConnection->ci_MinorVersion= Details.MinorVersion;
        pConnection->ci_InUse = IN_USE;
        pConnection->ci_1 = 0;
        pConnection->ci_ConnectionStatus = 2;

        //
        //  If this is the preferred conection then record it as special.
        //  If this is the first drive then also record it. Usually it gets
        //  overwritten by the preferred.
        //

        if (( Details.Preferred ) ||
            ( OriginalPrimary == 0 )) {

            NwPrint(("Nw16InitConnection: Primary Connection is %d\n", Connection+1));

            pNwDosTable->PrimaryServer = OriginalPrimary = (UCHAR)Connection + 1;
        }

        setAL(0);
    }

    return Status;
}

VOID
GetDirectoryHandle(
    VOID
    )
/*++

Routine Description:

    Obtain a NetWare handle for the current directory.

    If a NetWare handle is assigned then the Win32 handle created for
    the directory handle is kept open. When the process exits, the Win32
    handle will close. When all the Win32 handles from this process are
    closed an endjob NCP will be sent freeing the directory handle on the
    server.

Arguments:

    DX supplies the drive.

    AL returns the handle.
    AH returns the status flags.


Return Value:

    None.

--*/
{
    USHORT Drive = getDX();

    NwPrint(("Nw32:GetDirectoryHandle %c: ", 'A' + Drive));

    GetDirectoryHandle2( Drive );

    setAL(pNwDosTable->DriveHandleTable[Drive]);
    setAH(pNwDosTable->DriveFlagTable[Drive]);

    NwPrint(("Handle = %x, Flags =%x\n", pNwDosTable->DriveHandleTable[Drive],
                                        pNwDosTable->DriveFlagTable[Drive] ));
}

ULONG
GetDirectoryHandle2(
    DWORD Drive
    )
/*++

Routine Description:

    Obtain a NetWare handle for the current directory.

    If a NetWare handle is assigned then the Win32 handle created for
    the directory handle is kept open. When the process exits, the Win32
    handle will close. When all the Win32 handles from this process are
    closed an endjob NCP will be sent freeing the directory handle on the
    server.

    Note: Updates DriveHandleTable.

Arguments:

    Drive supplies the drive index (0 = a:).

Return Value:

    returns the handle.

--*/
{
    DWORD BytesReturned;

    if (Drive >= MD) {
        setAL( 0x98 );  // Volume does not exist
        return 0xffffffff;
    }

    NwPrint(("Nw32:GetDirectoryHandle2 %c:\n", 'A' + Drive));

    //
    //  If we don't have a handle and its either a temporary or
    //  permanent drive then create it.
    //

    if (( Win32DirectoryHandleTable[Drive] == 0 ) &&
        ( (pNwDosTable->DriveFlagTable[Drive] & 3) != 0 )){
        WCHAR DriveString[4];
        PWCHAR Name;

        //
        //  We don't have a handle for this drive.
        //  Open an NT handle to the current directory and
        //  ask the redirector for a NetWare directory handle.
        //

        if (Drive <= ('Z' - 'A')) {

            DriveString[0] = L'A' + (WCHAR)Drive;
            DriveString[1] = L':';
            DriveString[2] = L'.';
            DriveString[3] = L'\0';

            Name = DriveString;

        } else {

            Name = Drives[Drive];

            if( Name == NULL ) {
                NwPrint(("\nNw32:GetDirectoryHandle2 Drive not mapped\n",0));
                return 0xffffffff;
            }
        }

        Win32DirectoryHandleTable[Drive] =
            CreateFileW( Name,
                        0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_BACKUP_SEMANTICS,
                        0);

        if (Win32DirectoryHandleTable[Drive] != INVALID_HANDLE_VALUE) {

            if ( DeviceIoControl(
                    Win32DirectoryHandleTable[Drive],
                    IOCTL_NWR_RAW_HANDLE,
                    NULL,
                    0,
                    (PUCHAR)&pNwDosTable->DriveHandleTable[Drive],
                    sizeof(pNwDosTable->DriveHandleTable[Drive]),
                    &BytesReturned,
                    NULL ) == FALSE ) {

                NwPrint(("\nNw32:GetDirectoryHandle2 DeviceIoControl %x\n", GetLastError()));
                CloseHandle( Win32DirectoryHandleTable[Drive] );
                Win32DirectoryHandleTable[Drive] = 0;
                return 0xffffffff;

            } else {
                ASSERT( BytesReturned == sizeof(pNwDosTable->DriveHandleTable[Drive]));

                NwPrint(("\nNw32:GetDirectoryHandle2 Success %x\n", pNwDosTable->DriveHandleTable[Drive]));
            }

        } else {
            NwPrint(("\nNw32:GetDirectoryHandle2 CreateFile %x\n", GetLastError()));

            Win32DirectoryHandleTable[Drive] = 0;

            return 0xffffffff;
        }

    }

    return (ULONG)pNwDosTable->DriveHandleTable[Drive];
}

VOID
LoadDriveHandleTable(
    VOID
    )
/*++

Routine Description:

    Open handles to all the NetWare drives

Arguments:

    none.

Return Value:

    none.

--*/
{

    USHORT Drive;
    for (Drive = 0; Drive < MD; Drive++ ) {
        GetDirectoryHandle2(Drive);
    }

    DriveHandleTableValid = TRUE;

}

VOID
AllocateDirectoryHandle(
    VOID
    )
/*++

Routine Description:

    Allocate permanent or temporary handle for drive.

    For a permanent handle, we map this to a "net use".

    ASSUMES called from Nw16Handler


Arguments:

    DS:SI supplies the request.
    ES:DI supplies the response.

    AL returns the completion code.


Return Value:

    None.

--*/
{

    PUCHAR Request=GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI()),
                            2,
                            CpuInProtectMode
                            );

    PUCHAR Reply = GetVDMPointer (
                            (ULONG)((getES() << 16)|getDI()),
                            4,
                            CpuInProtectMode
                            );

    USHORT RequestLength = *(USHORT UNALIGNED *)( Request );

    Request=GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI()),
                            RequestLength+2,
                            CpuInProtectMode
                            );

    FormattedDump( Request, RequestLength+2 );


    if (( Request[2] == 0x12) ||
        ( Request[2] == 0x13)) {
        // do temp drives need different handling?

        UCHAR Drive = Request[4] - 'A';

        if (Drive >= MD) {
            setAL( 0x98 );  // Volume does not exist
            return;
        }

        if (pNwDosTable->DriveHandleTable[Drive] != 0) {

            NwPrint(("Nw32: Move directory handle %d\n", Drive));

            //
            //  We already have a directory handle assigned for this
            //  process. Ask the server to point the handle at the requested
            //  position.
            //

            SendNCP2(FSCTL_NWR_NCP_E2H, Request+2, RequestLength, Reply+2, 2);

            if (getAL() == 0) {
                //  Record the new handle.

                pNwDosTable->DriveIdTable[ Drive ] = SelectConnection()+1;

                if (Request[2] == 0x12) {
                    pNwDosTable->DriveFlagTable[ Drive ] =
                        PERMANENT_NETWORK_DRIVE;
                } else {
                    pNwDosTable->DriveFlagTable[ Drive ] =
                        TEMPORARY_NETWORK_DRIVE;
                }

                pNwDosTable->DriveHandleTable[Drive] = Reply[2];
                NwPrint(("Nw32: Move directory handle -> %x\n", Reply[2]));
            }

        } else {
            NETRESOURCE Nr;
            WCHAR DriveString[3];
            ULONG Handle;

            if (Request[2] == 0x12) {
                NwPrint(("Nw32: Allocate permanent directory handle %d\n", Drive));
            } else {
                NwPrint(("Nw32: Allocate temporary directory handle %d\n", Drive));
            }

            if (Drives[Drive] != NULL) {

                //  Tidy up the old name for this drive.

                LocalFree( Drives[Drive] );
                Drives[Drive] = NULL;
            }

            DriveString[0] = L'A' + Drive; // A through Z
            DriveString[1] = L':';
            DriveString[2] = L'\0';

            //
            // This is effectively a net use!
            //

            ZeroMemory( &Nr, sizeof(NETRESOURCE));

            Nr.lpRemoteName = BuildUNC(&Request[6], Request[5]);
            Nr.dwType = RESOURCETYPE_DISK;

            //  Save where this drive points.
            Drives[Drive] = Nr.lpRemoteName;

            if (DriveString[0] <= L'Z') {
                Nr.lpLocalName = DriveString;

                if (NO_ERROR != WNetAddConnection2W( &Nr, NULL, NULL, 0)) {

                    NwPrint(("Nw32: Allocate ->%d\n", GetLastError()));
                    setAL(0x98);    // Volume does not exist
                    return;
                }
            }


            if (Request[2] == 0x12) {
                pNwDosTable->DriveFlagTable[ Drive ] =
                    PERMANENT_NETWORK_DRIVE;
            } else {
                pNwDosTable->DriveFlagTable[ Drive ] =
                    TEMPORARY_NETWORK_DRIVE;
            }

            Handle = GetDirectoryHandle2( Drive );

            if (Handle == 0xffffffff) {

                if (DriveString[0] <= L'Z') {

                    WNetCancelConnection2W( DriveString, 0, TRUE);

                }

                ResetDrive( Drive );

                setAL(0x9c);    // Invalid path

            } else {

                //
                //  We have a drive and a connection. Complete the table
                //  mappings.
                //

                pNwDosTable->DriveIdTable[ Drive ] = SelectConnection()+1;

                Reply[2] = (UCHAR)(Handle & 0xff);
                Reply[3] = (UCHAR)(0xff); //should be effective rights
                setAL(0);    // Successful
            }
        }

    } else if ( Request[2] == 0x14 ) {

        UCHAR DirHandle = Request[3];
        UCHAR Drive;
        CONN_INDEX Connection = SelectConnection();

        NwPrint(("Nw32: Deallocate directory handle %d on Connection %d\n", DirHandle, Connection));

        for (Drive = 0; Drive < MD; Drive++) {


            NwPrint(("Nw32: Drive %c: is DirHandle %d, Connection %d\n",
                    'A' + Drive,
                    pNwDosTable->DriveHandleTable[Drive],
                    pNwDosTable->DriveIdTable[ Drive ]-1 ));

            if ((pNwDosTable->DriveHandleTable[Drive] == DirHandle) &&
                (pNwDosTable->DriveIdTable[ Drive ] == Connection+1)) {

                //
                // This is effectively a net use del!
                //

                NwPrint(("Nw32: Deallocate directory handle %c\n", 'A' + Drive));

                ResetDrive(Drive);

                setAL(0);

                return;
            }
        }

        setAL(0x9b); //  Bad directory handle
        return;

    } else {

        SendNCP(pNwDosTable->SavedAx);
    }

    FormattedDump( Reply, Reply[0] );
}

VOID
ResetDrive(
    UCHAR Drive
    )
/*++

Routine Description:

    Do a net use del

Arguments:

    Drive - Supplies the target drive.

Return Value:

    None.

--*/
{

    NwPrint(("Nw32: Reset Drive %c:\n", 'A' + Drive ));

    if ((pNwDosTable->DriveFlagTable[ Drive ] &
         ( PERMANENT_NETWORK_DRIVE | TEMPORARY_NETWORK_DRIVE )) == 0) {

        return;

    }

    if (Win32DirectoryHandleTable[Drive] != 0) {

        CloseHandle( Win32DirectoryHandleTable[Drive] );
        Win32DirectoryHandleTable[Drive] = 0;

    }

    if (Drive <= (L'Z' - L'A')) {

        DWORD WStatus;
        WCHAR DriveString[3];

        DriveString[0] = L'A' + Drive;
        DriveString[1] = L':';
        DriveString[2] = L'\0';

        WStatus = WNetCancelConnection2W( DriveString, 0, TRUE);

        if( WStatus != NO_ERROR ) {
            NwPrint(("Nw32: WNetCancelConnection2W failed  %d\n", WStatus ));
        }

    }

    //  Turn off flags that show this drive as redirected

    pNwDosTable->DriveFlagTable[ Drive ] &=
        ~( PERMANENT_NETWORK_DRIVE | TEMPORARY_NETWORK_DRIVE );

    pNwDosTable->DriveHandleTable[Drive] = 0;
}

VOID
AllocateDirectoryHandle2(
    VOID
    )
/*++

Routine Description:

    Allocate root drive

    ASSUMES called from Nw16Handler

Arguments:

    BL    supplies drive to map.
    DS:DX supplies the pathname

    AL returns the completion code.


Return Value:

    None.

--*/
{
    UCHAR Drive = getBL()-1;

    PUCHAR Name=GetVDMPointer (
                            (ULONG)((getDS() << 16)|getDX()),
                            256,    // longest valid path
                            CpuInProtectMode
                            );

    NETRESOURCE Nr;
    WCHAR DriveString[3];
    ULONG Handle;

    NwPrint(("Nw32: e905 map drive %c to %s\n", Drive + 'A', Name ));

    if (Drive >= MD) {
        setAL( 0x98 );  // Volume does not exist
        setCF(1);
        return;
    }

    if (pNwDosTable->DriveHandleTable[Drive] != 0) {

        NwPrint(("Nw32: Drive already redirected\n"));
        ResetDrive(Drive);

    }


    NwPrint(("Nw32: Allocate permanent directory handle\n"));

    if (Drives[Drive] != NULL) {

        //  Tidy up the old name for this drive.

        LocalFree( Drives[Drive] );
        Drives[Drive] = NULL;
    }

    //
    // This is effectively a net use!
    //

    ZeroMemory( &Nr, sizeof(NETRESOURCE));

    Nr.lpRemoteName = BuildUNC( Name, strlen(Name));
    //  Save where this drive points.
    Drives[Drive] = Nr.lpRemoteName;

    if (Drive <= (L'Z' - L'A')) {
        DriveString[0] = L'A' + Drive; // A through Z
        DriveString[1] = L':';
        DriveString[2] = L'\0';
        Nr.lpLocalName = DriveString;
        Nr.dwType = RESOURCETYPE_DISK;

        if (NO_ERROR != WNetAddConnection2W( &Nr, NULL, NULL, 0)) {

            NwPrint(("Nw32: Allocate0 ->%d\n", GetLastError()));

            if (GetLastError() == ERROR_ALREADY_ASSIGNED) {

                WNetCancelConnection2W( DriveString, 0, TRUE);

                if (NO_ERROR != WNetAddConnection2W( &Nr, NULL, NULL, 0)) {

                    NwPrint(("Nw32: Allocate1 ->%d\n", GetLastError()));
                    ResetDrive( Drive );
                    setAL(0x03);    // Volume does not exist
                    setCF(1);
                    return;
                }

            } else {

                    NwPrint(("Nw32: Allocate2 ->%d\n", GetLastError()));
                    ResetDrive( Drive );
                    setAL(0x03);    // Volume does not exist
                    setCF(1);
                    return;
            }
        }
    }

    //
    //  Set flags so that GetDirectory2 will open handle
    //
    pNwDosTable->DriveIdTable[ Drive ] = SelectConnection()+1;
    pNwDosTable->DriveFlagTable[ Drive ] = PERMANENT_NETWORK_DRIVE;

    Handle = GetDirectoryHandle2( Drive );

    if (Handle == 0xffffffff) {

        ResetDrive( Drive );
        setAL(0x03);    // Invalid path
        setCF(1);

    } else {

        setAL(0);    // Successful

    }

    NwPrint(("Nw32: Returning %x\n",getAL()));
}

PWCHAR
BuildUNC(
    IN PUCHAR aName,
    IN ULONG aLength
    )
/*++

Routine Description:

    This routine takes the ansi name, prepends the appropriate server name
    (if appropriate) and converts to Unicode.

Arguments:

    IN aName - Supplies the ansi name.
    IN aLength - Supplies the ansi name length in bytes.

Return Value:

    Unicode string

--*/
{
    UNICODE_STRING Name;
    UCHAR ServerName[sizeof(SERVERNAME)+1];

    CONN_INDEX Connection;
    ANSI_STRING TempAnsi;
    UNICODE_STRING TempUnicode;
    USHORT x;

    //  conversion rules for aName to Name are:

    //  foo:                "\\server\foo\"
    //  foo:bar\baz         "\\server\foo\bar\baz"
    //  foo:\bar\baz        "\\server\foo\bar\baz"


#ifdef NWDBG
    TempAnsi.Buffer = aName;
    TempAnsi.Length = (USHORT)aLength;
    TempAnsi.MaximumLength = (USHORT)aLength;
    NwPrint(("Nw32: BuildUNC %Z\n", &TempAnsi));
#endif

    Connection = SelectConnection();
    if ( Connection == 0xff ) {
        return NULL;
    }

    Name.MaximumLength = (USHORT)(aLength + sizeof(SERVERNAME) + 5) * sizeof(WCHAR);
    Name.Buffer = (PWSTR)LocalAlloc( LMEM_FIXED, (ULONG)Name.MaximumLength);

    if (Name.Buffer == NULL) {
        return NULL;
    }

    Name.Length = 4;
    Name.Buffer[0] = L'\\';
    Name.Buffer[1] = L'\\';

    //
    //  Be careful because ServerName might be 48 bytes long and therefore
    //  not null terminated.
    //

    RtlCopyMemory( ServerName, pNwDosTable->ServerNameTable[Connection], sizeof(SERVERNAME) );
    ServerName[sizeof(ServerName)-1] = '\0';

    RtlInitAnsiString( &TempAnsi, ServerName );
    RtlAnsiStringToUnicodeString( &TempUnicode, &TempAnsi, TRUE);
    RtlAppendUnicodeStringToString( &Name, &TempUnicode );
    RtlFreeUnicodeString( &TempUnicode );

    //  Now pack servername to volume seperator if necessary.

    if ((aLength != 0) &&
        (aName[0] != '\\')) {
        RtlAppendUnicodeToString( &Name, L"\\");
    }

    // aName might not be null terminated so be careful creating TempAnsi
    TempAnsi.Buffer = aName;
    TempAnsi.Length = (USHORT)aLength;
    TempAnsi.MaximumLength = (USHORT)aLength;

    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString( &TempUnicode, &TempAnsi, TRUE))) {
        LocalFree( Name.Buffer );
        return NULL;
    }

    RtlAppendUnicodeStringToString( &Name, &TempUnicode );

    //  If the name already has a volume seperator then don't add another.
    for (x=0; x < (Name.Length/sizeof(WCHAR)) ; x++ ) {

        if (Name.Buffer[x] == L':') {

            //  Strip the colon if it is immediately followed by a backslash

            if (((Name.Length/sizeof(WCHAR))-1 > x) &&
                (Name.Buffer[x+1] == L'\\')) {

                RtlMoveMemory( &Name.Buffer[x],
                               &Name.Buffer[x+1],
                               Name.Length - ((x + 1) * sizeof(WCHAR)));
                Name.Length -= sizeof(WCHAR);

            } else {

                //  Replace the colon with a backslash
                Name.Buffer[x] = L'\\';

            }
            goto skip;
        }
    }


skip:

    RtlFreeUnicodeString( &TempUnicode );

    //  Strip trailing backslash if present.

    if ((Name.Length >= sizeof(WCHAR) ) &&
        (Name.Buffer[(Name.Length/sizeof(WCHAR)) - 1 ] == L'\\')) {

        Name.Length -= sizeof(WCHAR);
    }

    //  Return pointer to a null terminated wide char string.

    Name.Buffer[Name.Length/sizeof(WCHAR)] = L'\0';
    NwPrint(("Nw32: BuildUNC %ws\n", Name.Buffer));

    return Name.Buffer;
}


VOID
GetServerDateAndTime(
    VOID
    )
/*++

Routine Description:

    Implement Funtion E7h

    ASSUMES called from Nw16Handler

Arguments:

    none.

Return Value:

    none.

--*/
{

    PUCHAR Reply = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getDX()),
                            7,
                            CpuInProtectMode
                            );

    SendNCP2( NWR_ANY_NCP(0x14), NULL, 0, Reply, 7 );

}

VOID
GetShellVersion(
    IN USHORT Command
    )
/*++

Routine Description:

    Get the environment variables. Needs to be configurable for
    Japanese machines.

Arguments:

    Command supplies the callers AX.

Return Value:

    none.

--*/
{

    setAX(0);       // MSDOS, PC
    setBX(0x031a);  // Shell version
    setCX(0);

    if ( (Command & 0x00ff) != 0) {

        LONG tmp;
        HKEY Key = NULL;
        HINSTANCE hInst;
        int retval;

        PUCHAR Reply = GetVDMPointer (
                                (ULONG)((getES() << 16)|getDI()),
                                40,
                                CpuInProtectMode
                                );

        if ( Reply == NULL ) {
            return;
        }

        hInst = GetModuleHandleA( "nwapi16.dll" );
        
        if (hInst == NULL) {
            return;
        }

        retval = LoadStringA( hInst, IsNEC_98 ? IDS_CLIENT_ID_STRING_NEC98 : IDS_CLIENT_ID_STRING, Reply, 40 );

        //
        // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
        // \NWCWorkstation\Parameters
        //
        tmp = RegOpenKeyExW(
                       HKEY_LOCAL_MACHINE,
                       NW_WORKSTATION_REGKEY,
                       REG_OPTION_NON_VOLATILE,   // options
                       KEY_READ,                  // desired access
                       &Key
                       );

        if (tmp != ERROR_SUCCESS) {
            return;
        }

        tmp = 40;   //  Max size for the string.

        RegQueryValueExA(
            Key,
            "ShellVersion",
            NULL,
            NULL,
            Reply,
            &tmp);

        ASSERT( tmp <= 40 );

        RegCloseKey( Key );

    }
}

#include <packon.h>

typedef struct _TTSOUTPACKETTYPE {
    UCHAR SubFunction;
    USHORT cx;
    USHORT dx;
} TTSOUTPACKETTYPE;

typedef struct _TTSINPACKETTYPE {
    USHORT cx;
    USHORT dx;
} TTSINPACKETTYPE;

#include <packoff.h>

VOID
TTS(
    VOID
    )
/*++

Routine Description:

    Transaction Tracking System

Arguments:

    none.

Return Value:

    none.

--*/
{
    UCHAR bOutput;
    UCHAR bInput[2];

    TTSINPACKET TTsInPacket;
    TTSOUTPACKET TTsOutPacket;


    switch ( pNwDosTable->SavedAx & 0x00ff )
    {
        case 2:
            // NCP Tts Available
            bOutput = 0;
            SendNCP2( NWR_ANY_F2_NCP(0x22), &bOutput, sizeof(UCHAR), NULL, 0);

            if (getAL() == 0xFF) {
                setAL(01);
            }
            break;

        case 0:
            // NCP Tts Begin/Abort
            bOutput = 1;
            SendNCP2( NWR_ANY_F2_NCP(0x22), &bOutput, sizeof(UCHAR), NULL, 0);
            break;

        case 3:
            // NCP Tts Begin/Abort
            bOutput = 3;
            SendNCP2( NWR_ANY_F2_NCP(0x22), &bOutput, sizeof(UCHAR), NULL, 0);
            break;

        case 1:
            // NCP Tts End
            bOutput = 2;
            SendNCP2( NWR_ANY_F2_NCP(0x22),
                &bOutput, sizeof(UCHAR),
                (PUCHAR)&TTsInPacket, sizeof(TTsInPacket));

            setCX(TTsInPacket.cx);
            setDX(TTsInPacket.dx);
            break;

        case 4:
            // NCP Tts Status
            TTsOutPacket.SubFunction = 4;
            TTsOutPacket.cx = getCX();
            TTsOutPacket.dx = getDX();

            SendNCP2( NWR_ANY_F2_NCP(0x22),
                (PUCHAR)&TTsOutPacket, sizeof(TTsOutPacket),
                NULL, 0);

            break;

        case 5:
        case 7:
            // NCP Tts Get App/Station Thresholds
            bOutput = (pNwDosTable->SavedAx & 0x00ff);

            SendNCP2( NWR_ANY_F2_NCP(0x22),
                &bOutput, sizeof(UCHAR),
                bInput, sizeof(bInput));

            setCX( (USHORT)((bInput[0] << 8 ) || bInput[1]) );
            break;

        case 6:
        case 8:
            // NCP Tts Set App/Station Thresholds
            TTsOutPacket.SubFunction = (pNwDosTable->SavedAx & 0x00ff);
            TTsOutPacket.cx = getCX();
            SendNCP2( NWR_ANY_F2_NCP(0x22),
                (PUCHAR)&TTsOutPacket, sizeof(UCHAR) + sizeof(USHORT),
                NULL, 0);
            break;

        default:
            pNwDosTable->SavedAx = 0xc7FF;
            break;
    }
    return;
}

VOID
OpenCreateFile(
    VOID
    )
/*++

Routine Description:

    Look at the file being opened to determine if it is
    a compatibility mode open to a file on a NetWare drive.

Arguments:

    none.

Return Value:

    none.

--*/
{
    WORD Command = pNwDosTable->SavedAx;

    PUCHAR Name;


    if ((Command & OF_SHARE_MASK ) != OF_SHARE_COMPAT) {
        return;
    }

    Name = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getDX()),
                            256,
                            CpuInProtectMode
                            );


    NwPrint(("Nw16Handler Compatibility Open of %s\n", Name ));

    //
    //  We already know its a Create or Open with sharing options
    //  set to compatibility mode or the tsr wouldn't have bopped to us.
    //


    if (IsItNetWare(Name)) {

        SetCompatibility();

    }
}

BOOL
IsItNetWare(
    PUCHAR Name
    )
/*++

Routine Description:

    Look at the filename being opened to determine if it is on a NetWare drive.

Arguments:

    none.

Return Value:

    none.

--*/
{
    UCHAR Drive;

    Drive = tolower(Name[0])-'a';

    NwPrint(("Nw16Handler IsItNetWare %s\n", Name ));

    if (Name[1] == ':') {

        if (pNwDosTable->DriveFlagTable[Drive] == LOCAL_DRIVE) {

            //  Definitely not a netware drive.
            return FALSE;
        }

    } else if ((IS_ASCII_PATH_SEPARATOR(Name[0])) &&
               (IS_ASCII_PATH_SEPARATOR(Name[0]))) {

            // Assume only UNC names that the tsr built are NetWare

        if ((getDS() == DosTableSegment ) &&
            (getDX() == (WORD)(DosTableOffset + FIELD_OFFSET(NWDOSTABLE, DeNovellBuffer[0] )))) {

            return TRUE;
        }

        return FALSE;

    } else {

        Drive = pNwDosTable->CurrentDrive;

    }

    //
    //  If this is a drive we don't know about, refresh our tables.
    //

    if (pNwDosTable->DriveFlagTable[Drive] == 0 ) {

        Nw16Register();

    }

    if (pNwDosTable->DriveFlagTable[Drive] &
                (TEMPORARY_NETWORK_DRIVE | PERMANENT_NETWORK_DRIVE )) {

            return TRUE;

    }

    return FALSE;

}

VOID
SetCompatibility(
    VOID
    )
/*++

Routine Description:

    Take the Create/Open file request in AX and modify appropriately

Arguments:

    none.

Return Value:

    none.

--*/
{
    WORD Command = getAX();

    if (( Command & OF_READ_WRITE_MASK) == OF_READ ) {

        setAX((WORD)(Command | OF_SHARE_DENY_WRITE));

    } else {

        setAX((WORD)(Command | OF_SHARE_EXCLUSIVE));

    }

}

VOID
OpenQueueFile(
    VOID
    )
/*++

Routine Description:

    Build the UNC filename \\server\queue using the contents of the shared
    datastructures and the CreateJobandFile NCP.

Arguments:

    none.

Return Value:

    none.

--*/
{

    CONN_INDEX Connection = SelectConnection();
    PUCHAR Request;
    PUCHAR Buffer = pNwDosTable->DeNovellBuffer;
    int index;

    if ( Connection == 0xff ) {
        //
        //  No need to return an errorcode. The NCP exchange
        //  will fail and give an appropriate call to the application.
        //

        return;
    }

    if ( ServerHandles[Connection] == NULL ) {

        NTSTATUS status;

        status = OpenConnection( Connection );

        if (!NT_SUCCESS(status)) {
            SetStatus(status);
            return;
        }
    }

    //
    //  CreateJobandQueue open in progress. The purpose of this
    //  open being processed is to translate the information in
    //  the CreateJob NCP into a pathname to be opened by the 16
    //  bit code.
    //


    //
    //  Users DS:SI points at a CreateJob NCB. Inside the request is
    //  the objectid of the queue. Ask the server for the queue name.
    //

    Request = GetVDMPointer (
                            (ULONG)((getDS() << 16)|getSI()),
                            8,
                            CpuInProtectMode);

    NwlibMakeNcp(
                ServerHandles[Connection],
                FSCTL_NWR_NCP_E3H,
                7,                      //  RequestSize
                61,                     //  ResponseSize
                "br|_r",
                0x36,                   //  Get Bindery Object Name
                Request+3, 4,
                6,                      //  Skip ObjectId and Type
                pNwDosTable->DeNovellBuffer2, 48 );


    pNwDosTable->DeNovellBuffer2[54] = '\0';

    Buffer[0] = '\\';
    Buffer[1] = '\\';
    Buffer += 2;            //  Point to after backslashes

    //  Copy the servername
    for (index = 0; index < sizeof(SERVERNAME); index++) {
        Buffer[index] = pNwDosTable->ServerNameTable[Connection][index];
        if (Buffer[index] == '\0') {
            break;
        }
    }

    Buffer[index] = '\\';

    RtlCopyMemory( &Buffer[index+1], &pNwDosTable->DeNovellBuffer2[0], 48 );

    NwPrint(("Nw32: CreateQueue Job and File %s\n", pNwDosTable->DeNovellBuffer));

    //
    //  Set up 16 bit registers to do the DOS OpenFile for \\server\queue
    //

    setDS((WORD)(CpuInProtectMode ? pNwDosTable->PmSelector : DosTableSegment));
    setDX( (WORD)(DosTableOffset + FIELD_OFFSET(NWDOSTABLE, DeNovellBuffer[0] )) );
    setAX(0x3d02);    //  Set to OpenFile

}

VOID
AttachHandle(
    VOID
    )
/*++

Routine Description:

    This routine implements Int 21 B4. Which is supposed to create a
    Dos Handle that corresponds to a specified 6 byte NetWare handle.

    This is used as a replacement for doing a DosOpen on "NETQ" and usin the
    handle returned from there.

Arguments:

    none.

Return Value:

    none.

--*/
{

    if ( pNwDosTable->CreatedJob ) {

        NwPrint(("Nw32: AttachHandle %x\n", pNwDosTable->JobHandle));
        setAX( pNwDosTable->JobHandle );
        pNwDosTable->CreatedJob = 0;        //  Only return it once.

    } else {

        NwPrint(("Nw32: AttachHandle failed, no job\n"));
        setAX(ERROR_FILE_NOT_FOUND);
        setCF(1);

    }
}

VOID
ProcessExit(
    VOID
    )
/*++

Routine Description:

    Cleanup all cached handles. Unmap all temporary drives.

    Cleanup the server name table so that if another dos app
    is started we reload all the useful information such as
    the servers connection number.

    Note: Dos always completes processing after we complete.

Arguments:

    none.

Return Value:

    none.

--*/
{
    UCHAR Connection;
    UCHAR Drive;
    USHORT Command = pNwDosTable->SavedAx;

    ResetLocks();

    for (Drive = 0; Drive < MD; Drive++) {

        NwPrint(("Nw32: Deallocate directory handle %c\n", 'A' + Drive));

        if (Win32DirectoryHandleTable[Drive] != 0) {

            CloseHandle( Win32DirectoryHandleTable[Drive] );
            Win32DirectoryHandleTable[Drive] = 0;
            pNwDosTable->DriveHandleTable[Drive] = 0;

        }
    }

    for (Connection = 0; Connection < MC ; Connection++ ) {
        if (pNwDosTable->ConnectionIdTable[Connection].ci_InUse == IN_USE) {

            CloseConnection(Connection);

            pNwDosTable->ConnectionIdTable[Connection].ci_InUse = FREE;

            ZeroMemory( pNwDosTable->ServerNameTable[Connection], SERVERNAME_LENGTH );
        }
    }

    pNwDosTable->PreferredServer = 0;

    LockMode = 0;
    TablesValid = FALSE;
    DriveHandleTableValid = FALSE;

#if NWDBG
    if (DebugCtrl & ~3 ) {
        DebugControl( 2 );  //  Close logfile
    }
    GotDebugState = FALSE;
#endif

    //
    //  set AX register so that AH gets preserved
    //

    setAX( Command );
}

VOID
SystemLogout(
    VOID
    )
/*++

Routine Description:

    This api is called by the NetWare login.

    Remove all NetWare redirected drives and logout connections
    that don't have open handles on them. Don't detach the connections.

Arguments:

    none.

Return Value:

    none.

--*/
{

    UCHAR Connection;
    UCHAR Drive;
    USHORT Command = pNwDosTable->SavedAx;

    ResetLocks();

    for (Drive = 0; Drive < MD; Drive++) {
        ResetDrive(Drive);
    }

    for (Connection = 0; Connection < MC ; Connection++ ) {
        if (pNwDosTable->ConnectionIdTable[Connection].ci_InUse == IN_USE) {

            if ( ServerHandles[Connection] == NULL ) {
                OpenConnection( Connection );
            }

            if (ServerHandles[Connection] != NULL ) {

                NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(NCP_LOGOUT),
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");

                CloseConnection(Connection);
            }

            //pNwDosTable->ConnectionIdTable[Connection].ci_InUse = FREE;

            //ZeroMemory( pNwDosTable->ServerNameTable[Connection], SERVERNAME_LENGTH );
        }
    }

    pNwDosTable->PreferredServer = 0;
    pNwDosTable->PrimaryServer = 0;

    // No servers in the table so find the nearest/preferred.

    LoadPreferredServerName();

    //
    //  set AX register so that AH gets preserved
    //  and AL says success.
    //

    setAX( (USHORT)(Command & 0xff00) );
}

UCHAR
AttachmentControl(
    ULONG Command
    )
/*++

Routine Description:

    Implement Funtion F1h

Arguments:

    none.

Return Value:

    Return status.

--*/
{
    UCHAR Connection = getDL();

    if ((Connection < 1) ||
        (Connection > MC)) {
        return 0xf7;
    }

    Connection -= 1;

    switch (Command & 0x00ff) {

    case 0:     //  Attach

        NwPrint(("Nw16AttachmentControl: Attach connection %d\n", Connection));

        pNwDosTable->ConnectionIdTable[Connection].ci_InUse = IN_USE;

        if ( ServerHandles[Connection] == NULL ) {

            NTSTATUS status = OpenConnection( Connection );

            if (!NT_SUCCESS(status)) {
                pNwDosTable->ConnectionIdTable[Connection].ci_InUse = FREE;
                ZeroMemory( pNwDosTable->ServerNameTable[Connection], SERVERNAME_LENGTH );
                return (UCHAR)RtlNtStatusToDosError(status);
            } else {
                InitConnection(Connection);
            }
        }

        return 0;
        break;

    case 1:     //  Detach

        NwPrint(("Nw16AttachmentControl: Detach connection %d\n", Connection));

        if (pNwDosTable->ConnectionIdTable[Connection].ci_InUse != IN_USE) {
            return 0xff;
        } else {

            pNwDosTable->ConnectionIdTable[Connection].ci_InUse = FREE;

            if (ServerHandles[Connection] != NULL ) {
                CloseConnection(Connection);
            }

            ZeroMemory( pNwDosTable->ServerNameTable[Connection], SERVERNAME_LENGTH );

            if (pNwDosTable->PrimaryServer == (UCHAR)Connection + 1 ) {

                // Need to pick another
                UCHAR IndexConnection;

                pNwDosTable->PrimaryServer = 0;

                for (IndexConnection = 0; IndexConnection < MC ; IndexConnection++ ) {

                    if (pNwDosTable->ConnectionIdTable[IndexConnection].ci_InUse == IN_USE) {

                        pNwDosTable->PrimaryServer = IndexConnection + 1;

                    }
                }

            }

            if (pNwDosTable->PreferredServer == (UCHAR)Connection + 1 ) {
                pNwDosTable->PreferredServer = 0;
            }

            return 0;
        }

    case 2:     //  Logout

        NwPrint(("Nw16AttachmentControl: Logout connection %d\n", Connection));

        if (pNwDosTable->ConnectionIdTable[Connection].ci_InUse != IN_USE) {
            return 0xff;
        } else {

            UCHAR Drive;

            if ( ServerHandles[Connection] == NULL ) {
                OpenConnection( Connection );
            }

            for (Drive = 0; Drive < MD; Drive++ ) {
                if (pNwDosTable->DriveIdTable[ Drive ] == (Connection + 1)) {
                    ResetDrive(Drive);
                }
            }

            if (ServerHandles[Connection] != NULL ) {
                NwlibMakeNcp(
                    ServerHandles[Connection],
                    NWR_ANY_F2_NCP(NCP_LOGOUT),
                    0,  //  RequestSize
                    0,  //  ResponseSize
                    "");
                CloseConnection(Connection);
            }

            return 0;
        }

    }
    return 0xff;
}

VOID
ServerFileCopy(
    VOID
    )
/*++

Routine Description:

    Build the NCP that tells the server to move a file on the server.

Arguments:

    none.

Return Value:

    none.

--*/
{

    DWORD BytesReturned;
    UCHAR SrcHandle[6];
    UCHAR DestHandle[6];
    NTSTATUS status;
    PUCHAR Buffer;

    Buffer = GetVDMPointer (
                        (ULONG)((getES() << 16)|getDI()),
                        16,
                        CpuInProtectMode
                        );

    if ( DeviceIoControl(
            GET_NT_SRCHANDLE(),
            IOCTL_NWR_RAW_HANDLE,
            NULL,
            0,
            (PUCHAR)&SrcHandle,
            sizeof(SrcHandle),
            &BytesReturned,
            NULL ) == FALSE ) {

        setAL(0xff);
        return;

    }

    if ( DeviceIoControl(
            GET_NT_HANDLE(),
            IOCTL_NWR_RAW_HANDLE,
            NULL,
            0,
            (PUCHAR)&DestHandle,
            sizeof(DestHandle),
            &BytesReturned,
            NULL ) == FALSE ) {

        setAL(0xff);
        return;

    }

    status = NwlibMakeNcp(
                GET_NT_SRCHANDLE(),
                NWR_ANY_F2_NCP(0x4A),
                25,  //  RequestSize
                4,   //  ResponseSize
                "brrddd|d",
                0,
                SrcHandle,  6,
                DestHandle, 6,
                *(DWORD UNALIGNED*)&Buffer[4],
                *(DWORD UNALIGNED*)&Buffer[8],
                *(DWORD UNALIGNED*)&Buffer[12],
                &BytesReturned
                );

    setDX((WORD)(BytesReturned >> 16));
    setCX((WORD)BytesReturned);

    if (!NT_SUCCESS(status)) {
        SetStatus(status);
        return;
    } else {
        setAL(0);
    }
}

VOID
SetStatus(
    NTSTATUS Status
    )
/*++

Routine Description:

    Convert an NTSTATUS into the appropriate register settings and updates
    to the dos tables.

Arguments:

    none.

Return Value:

    none.

--*/
{
    UCHAR DosStatus = (UCHAR)RtlNtStatusToDosError(Status);

    if ((!DosStatus) &&
        (Status != 0)) {

        //
        //  We have a connection bit set
        //

        if ( Status & (NCP_STATUS_BAD_CONNECTION << 8)) {
            DosStatus = 0xfc;
        } else {
            DosStatus = 0xff;
        }
    }

    if (DosStatus) {
        setCF(1);
    }

    setAL(DosStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\drv\netware.h ===
/*****************************************************************/
/**               Microsoft Windows 4.0                         **/
/**           Copyright (C) Microsoft Corp., 1991-1993          **/
/*****************************************************************/


/*
 * History:
 *  08/08/93    vlads   Created
 *	10/16/93	gregj	Removed #pragma pack() because of #include nesting
 *
 */

#ifndef _INC_NETWARE
#define _INC_NETWARE

#include <windows.h>

// #include <npdefs.h>

// #include <base.h>

// #include <npassert.h>
// #include <buffer.h>

// #include <..\..\dev\ddk\inc16\error.h>
// #include <bseerr.h>
#include "nwerror.h"
// #include "..\nwnp\nwsysdos.h"

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

// #include <netcons.h>
// #include <netlib.h>

WINAPI NETWAREREQUEST (LPVOID);
WINAPI PNETWAREREQUEST(LPVOID);
WINAPI DOSREQUESTER(LPVOID);

//UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
//UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
//UINT WINAPI WNetCancelConnection(LPSTR, BOOL);


#ifdef __cplusplus
}
#endif  /* __cplusplus */


#ifdef DEBUG
#define TRACE(s) OutputDebugString(s)
#else
#define TRACE(s)
#endif

extern HINSTANCE hInstance;

#endif  /* !_INC_NETWARE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\drv\nwasmutl.asm ===
PAGE,132
;*****************************************************************;
;**               Microsoft Windows for Workgroups              **;
;**           Copyright (C) Microsoft Corp., 1991-1993          **;
;*****************************************************************;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                          ;;
;; COMPONENT:   Windows NetWare DLL.                                        ;;
;;                                                                          ;;
;; FILE:        NWASMUTL.ASM                                                ;;
;;                                                                          ;;
;; PURPOSE:     General routines used that cannot be done in C.             ;;
;;                                                                          ;;
;; REVISION HISTORY:                                                        ;;
;;  vlads       09/20/93 First cut                                          ;;
;;                                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        INCLUDE CMACROS.INC

?PLM = 1
?WIN=0

ifndef SEGNAME
    SEGNAME equ <_TEXT>         ; default seg name
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg                 ; this defines what seg this goes in
assumes cs,CodeSeg

;;
;; Swapping bytes in a  word
;;

cProc   WordSwap, <PUBLIC,FAR>
        parmW inWord

cBegin
        mov     ax, word ptr (inWord)
        xchg    al, ah
cEnd


;;
;; Swapping words in a long word
;;
cProc   LongSwap, <FAR,PUBLIC>, <dx>
        parmD inLong

cBegin
        mov     dx, word ptr (inLong + 2)
        xchg    dl, dh
        mov     ax, word ptr (inLong)
        xchg    al, ah
cEnd

;public NETWAREREQUEST
;
;NETWAREREQUEST proc far
;    int 21h
;       retf
;NETWAREREQUEST endp
        
sEnd _thisseg

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\drv\nwerror.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* NWERROR.H -- Novell defined error return codes from Netware API
 *
 * History:
 *  03/16/93    vlads   Created
 *
 */

#ifndef _nwerror_h_
#define _nwerror_h_


#define NWSC_SUCCESS            0x00
#define NWSC_SERVEROUTOFMEMORY  0x96
#define NWSC_NOSUCHVOLUME       0x98   // Volume does not exist
#define NWSC_BADDIRECTORYHANDLE 0x9b
#define NWSC_NOSUCHPATH         0x9c
#define NWSC_NOJOBRIGHTS        0xd6
#define NWSC_EXPIREDPASSWORD    0xdf
#define NWSC_NOSUCHSEGMENT      0xec   // Segment does not exist
#define NWSC_INVALIDNAME        0xef
#define NWSC_NOWILDCARD         0xf0   // Wildcard not allowed
#define NWSC_NOPERMBIND         0xf1   // Invalid bindery security

#define NWSC_ALREADYATTACHED    0xf8   // Already attached to file server
#define NWSC_NOPERMREADPROP     0xf9   // No property read privelege
#define NWSC_NOFREESLOTS        0xf9   // No free connection slots at server
#define NWSC_NOMORESLOTS        0xfa   // No more server slots
#define NWSC_NOSUCHPROPERTY     0xfb   // Property does not exist
#define NWSC_UNKNOWN_REQUEST    0xfb    // Invalid NCP number
#define NWSC_NOSUCHOBJECT       0xfc   // End of Scan Bindery Object service
                                       // No such object
#define NWSC_UNKNOWNSERVER      0xfc   // Unknown file server
#define NWSC_SERVERBINDERYLOCKED    0xfe   // Server bindery locked
#define NWSC_BINDERYFAILURE     0xff   // Bindery failure
#define NWSC_ILLEGALSERVERADDRESS 0xff   // No response from server (illegal server address)
#define NWSC_NOSUCHCONNECTION   0xff   // Connection ID does not exist


typedef WORD   NW_STATUS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\drv\dllentry.asm ===
PAGE,132
;***************************************************************************
;*
;*   DLLENTRY.ASM
;*
;*	VER.DLL Entry code
;*
;*	This module generates a code segment called INIT_TEXT.
;*	It initializes the local heap if one exists and then calls
;*	the C routine LibMain() which should have the form:
;*	BOOL FAR PASCAL LibMain(HANDLE hInstance,
;*				WORD   wDataSeg,
;*				WORD   cbHeap,
;*				LPSTR  lpszCmdLine);
;*        
;*	The result of the call to LibMain is returned to Windows.
;*	The C routine should return TRUE if it completes initialization
;*	successfully, FALSE if some error occurs.
;*
;**************************************************************************

	INCLUDE CMACROS.INC

externFP <LIBMAIN>               ;The C routine to be called

ifndef SEGNAME
    SEGNAME equ <_TEXT>         ; default seg name
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE


sBegin	CodeSeg          ; this defines what seg this goes in
assumes cs,CodeSeg

?PLM=0                           ;'C'naming
externA  <_acrtused>             ;Ensures that Win DLL startup code is linked

?PLM=1                           ;'PASCAL' naming
externFP <LOCALINIT>             ;Windows heap init routine

cProc   LibEntry, <PUBLIC,FAR>   ;Entry point into DLL

cBegin
        push    di               ;Handle of the module instance
        push    ds               ;Library data segment
        push    cx               ;Heap size
        push    es               ;Command line segment
        push    si               ;Command line offset

        ;** If we have some heap then initialize it
        jcxz    callc            ;Jump if no heap specified

        ;** Call the Windows function LocalInit() to set up the heap
        ;**	LocalInit((LPSTR)start, WORD cbHeap);
        
        xor     ax,ax
        cCall   LOCALINIT <ds, ax, cx>
        or      ax,ax            ;Did it do it ok ?
        jz      error            ;Quit if it failed

        ;** Invoke the C routine to do any special initialization

callc:
        call    LIBMAIN          ;Invoke the 'C' routine (result in AX)
        jmp short exit           ;LibMain is responsible for stack clean up

error:
	pop	si		 ;Clean up stack on a LocalInit error
        pop     es               
        pop     cx               
        pop     ds
        pop     di
exit:

cEnd

sEnd _thisseg

	END LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\drv\ints.asm ===
page ,132

if 0

/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ints.asm

Abstract:

    Contains handler for Windows protect-mode NetwareRequest function, exported
    by NETWARE.DRV. Code in this file access real mode memory via an LDT descriptor
    created especially for this purpose. This selector gives us access to all
    code and data contained in the Nw16 TSR

Author:

    Richard L Firth 22-Jan-1994

Environment:

    Windows protect mode only

Revision History:

    22-Jan-1994 rfirth
        Created

--*/

endif

include nwdos.inc                       ; NWDOSTABLE_ASM structure
include isvbop.inc                      ; DispatchCall

.286
.model medium,pascal

_DATA segment word public 'DATA'

OldInt21Handler dd      ?
RMSegment       dw      ?
RMBase          dw      ?               ; MUST be in this order - loaded
RMSelector      dw      ?               ; via lds dx,word ptr RMBase

.errnz (RMSelector - (RMBase + 2))

_DATA ends

;
; code segment ordering
;

INIT_TEXT segment byte public 'CODE'
INIT_TEXT ends

_TEXT segment byte public 'CODE'
_TEXT ends

;
; macros
;

LOAD_DS macro
        push    _DATA
        pop     ds
        assume  ds:_DATA
        endm

SET_DS macro
        push    ds
        LOAD_DS
        endm

RESTORE_DS macro
        pop     ds
        assume  ds:nothing
        endm

LOAD_RM_DS_BX macro
        LOAD_DS
        lds     bx,dword ptr RMBase
        assume  ds:nothing
        endm

RESTORE_DS_BX macro
        RESTORE_DS
        pop     bx
        endm

INIT_TEXT segment byte public 'CODE'

        assume  cs:INIT_TEXT

        public GetLowRedirInfo
GetLowRedirInfo proc far
        mov     ax,9f00h
        int     21h                     ; get the RM data segment in BX
        jc      @f
        SET_DS
        mov     RMSegment,bx
        mov     RMBase,dx
        mov     ax,2
        int     31h
        jc      @f                      ; can't create selector
        mov     RMSelector,ax

;
; now that we have the selector, we write the selector value into the low
; memory area. The 32-bit DLL will use this value when setting output DS or ES
; register values if the call originated in Protect Mode
;

        lds     bx,dword ptr RMBase
        mov     [bx]._PmSelector,ax

;
; we now hook int 21
;

        LOAD_DS
        push    es
        mov     ax,3521h
        int     21h
        mov     word ptr OldInt21Handler,bx
        mov     word ptr OldInt21Handler[2],es
        mov     cx,_TEXT
        mov     dx,offset _TEXT:NewInt21Handler
        mov     ax,205h
        mov     bl,21h
        int     31h
        pop     es
        RESTORE_DS
        xor     ax,ax                   ; success: return TRUE
        inc     ax
        ret
@@:     xor     ax,ax                   ; failure: return FALSE
        ret
GetLowRedirInfo endp

INIT_TEXT ends

_TEXT segment byte public 'CODE'

        assume  cs:_TEXT

        public NewInt21Handler
NewInt21Handler proc far
        sti
        cmp     ah,0e3h
        jb      @f
        call    far ptr NetwareRequest
        retf    2
@@:     sub     sp,4
        push    bp
        mov     bp,sp
        push    es
        push    bx
        SET_DS
        les     bx,OldInt21Handler
        mov     [bp+2],bx
        mov     [bp+4],es
        RESTORE_DS
        pop     bx
        pop     es
        pop     bp
        retf
NewInt21Handler endp

        public NetwareRequest
NetwareRequest proc far
        push    bx
        push    ds
        LOAD_RM_DS_BX
        cmp     ah,0f0h
        jne     for_dll

;
; these are the 0xF000, 0xF001, 0xF002, 0xF004, 0xF005 calls that we can handle
; here without having to BOP. All we need do is access the table in the shared
; real-mode/protect-mode (low) memory
;

.errnz (_PrimaryServer - (_PreferredServer + 1))

;
; point bx at PreferredServer in the low memory area. If the request is a
; PrimaryServer request (0xF004, 0xF005) then point bx at PrimaryServer
;

        lea     bx,[bx]._PreferredServer; bx = offset of PreferredServer
        cmp     al,3
        cmc
        adc     bx,0                    ; bx = &PrimaryServer if F004 or F005
        or      al,al                   ; f000 = set preferred server
        jz      set_server
        cmp     al,4                    ; f004 = set primary server
        jnz     try_01

;
; 0xF000 or 0xF004: set Preferred or Primary Server to value contained in DL.
; If DL > 8, set respective server index to 0
;

set_server:
        xor     al,al
        cmp     dl,8
        ja      @f
        mov     al,dl
@@:     mov     [bx],al
        jmp     short exit_f0

;
; 0xF001 or 0xF005: get Preferred or Primary Server
;

try_01: cmp     al,1                    ; f001 = get preferred server
        jz      get_server
        cmp     al,5
        jnz     try_02

get_server:
        mov     al,[bx]
        jmp     short exit_f0

try_02: cmp     al,2                    ; f002 = get default server
        jnz     for_dll                 ; try to handle on 32-bit side
        mov     al,[bx]                 ; al = PreferredServer
        or      al,al
        jnz     exit_f0
        mov     al,[bx+1]               ; al = PrimaryServer

exit_f0:RESTORE_DS_BX
        ret

;
; if we're here then the call must go through to the 32-bit DLL. Save any relevant
; info in the low memory area, load the handle and BOP (DispatchCall)
;

for_dll:mov     [bx]._SavedAx,ax        ; save AX value for DLL
        push    word ptr [bx]._hVdd     ; put VDD handle on top of stack

        cmp     ah,0BCh                 ; bc, bd, be need handle mapping
        jb      @f
        cmp     ah,0BEh
        ja      @f
        pop     ax                      ; ax = hVdd
        RESTORE_DS_BX                   ; ds, bx = user ds, bx
        call    MapNtHandle
        jmp     dispatchola

@@:     push    bp
        cmp     ah, 0E3h                ; Is it new or old Create Job request?
        je      lookupcode
        cmp     ax, 0F217h
        jne     check_f3

lookupcode:
        mov     bp,sp
        mov     ds,[bp+4]
        cmp     byte ptr [si+2],68h
        je      createjob
        cmp     byte ptr [si+2],79h
        je      createjob
        jmp     short outtahere

createjob:
        LOAD_RM_DS_BX
        mov     [bx]._SavedAx,9f02h
        push    ax                      ; Open \\Server\queue for NCP
        mov     ax,[bp+2]               ; ax = hVdd
        mov     ds,[bp+4]               ; ds = users ds
        push    ds
        push    dx                      ; users dx
        DispatchCall                    ; Set DeNovellBuffer to \\Server\queue
                                        ; and registers ready for DOS OpenFile
        int     21h                     ; Open \\server\queue
        LOAD_RM_DS_BX
        jc      openfailed
        mov     [bx]._JobHandle, al
        mov     [bx]._CreatedJob, 1     ; Flag JobHandle is valid
        push    bx
        mov     bx, ax                  ; JobHandle
        call    MapNtHandle             ; take bx and find the Nt handle
        pop     bx

openfailed:
        pop     dx
        pop     ds                      ; Proceed and send the NCP
        pop     ax

        push    ds
        push    bx
        LOAD_RM_DS_BX
        mov     [bx]._SavedAx, ax
        pop     bx
        pop     ds                      ; users DS
        jmp     short outtahere

check_f3:
        cmp     ah, 0F3h
        jne     outtahere
                                        ; FileServerCopy, change both
                                        ; handles in the structure es:di
        push    bx

        mov     bx,word ptr es:[di]     ; Map Source Handle
        call    MapNtHandle

        pop     bx
        mov     ax,[bx]._NtHandleHi
        mov     [bx]._NtHandleSrcHi,ax
        mov     ax,[bx]._NtHandleLow
        mov     [bx]._NtHandleSrcLow,ax

        mov     bx,word ptr es:[di+2]   ; Map Destination Handle
        call    MapNtHandle

outtahere:
        pop     bp
        pop     ax                      ; ax = hVdd
        RESTORE_DS_BX                   ; ds, bx = user ds, bx
dispatchola:
        DispatchCall                    ; BOP: DLL performs action
        ret                             ; return to the application

;
; if the request was not recognized by the DLL, it modifies IP so that control
; will resume at the next int 21. We just fill the intervening space with NOPs
; (space that makes up a retf <n> instruction in the RM TSR)
;

        nop
        nop
        int     21h
        ret
NetwareRequest endp

; ***   MapNtHandle
; *
; *     Given a handle in BX, map it to a 32-bit Nt handle in NtHandle[Hi|Low]
; *
; *     ENTRY   bx = handle to map
; *
; *     EXIT    Success - NtHandle set to 32-bit Nt handle from SFT
; *
; *     USES    ax, bx, flags
; *
; *     ASSUMES nothing
; *
; ***

MapNtHandle proc near
        push    ax
        mov     ax,9f01h                ; call MapNtHandle on (BX) in RM
        int     21h                     ; update NtHandleHi, NtHandleLow
        pop     ax
@@:     ret
MapNtHandle endp

_TEXT ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\drv\nwinit.c ===
/*****************************************************************/
/**               Microsoft Windows 4.0                         **/
/**           Copyright (C) Microsoft Corp., 1992-1993          **/
/*****************************************************************/

/* INIT.C -- General code for MS/Netware network driver emulator.
 *
 * History:
 *  09/22/93    vlads   Created
 *
 */

#include "netware.h"

#define Reference(x) ((void)(x))

extern BOOL far pascal GetLowRedirInfo(void);

int FAR PASCAL LibMain(
    HANDLE hInst,
    WORD wDataSeg,
    WORD wcbHeapSize,
    LPSTR lpstrCmdLine)
{

    //
    // get shared data segment address. Fail initialization if an error is
    // returned
    //

    if (!GetLowRedirInfo()) {
        return 0;
    }

    //
    // return success
    //

    return 1;
}

/*  WEP
 *  Windows Exit Procedure
 */

int FAR PASCAL _loadds WEP(int nParameter)
{
   Reference(nParameter);
   return 1;
}


WINAPI PNETWAREREQUEST(LPVOID x)
{
    return(1);
}

//
// removed because nwcalls makes use of this function; removing it causes
// NWCALLS to use real INT 21
//

//WINAPI DOSREQUESTER(LPVOID x)
//{
//    return(1);
//}

UINT WINAPI WNetAddConnection(LPSTR p1, LPSTR p2, LPSTR p3)
{
    return(1);
}

UINT WINAPI WNetGetConnection(LPSTR p1, LPSTR p2, UINT FAR *p3)
{
    return(1);
}

UINT WINAPI WNetCancelConnection(LPSTR p1, BOOL p2)
{
    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\inc\nwdos.h ===
/*--

  Copyright (c) 1993  Microsoft Corporation

  Module Name:

    NWDOS.h

  Abstract:

    This is the include file that defines all constants and types for
    16 bit applications accessing the redirector.

  Author:

    Colin Watson   (ColinW)  08-Jul-1993

  Revision History:

--*/

#define NWDOS_INCLUDED

#define  MC     8   // maximum number of connections

#define  NC     8   // number of novell connections
#define  MP     3   // maximum number of printers
#define  MD    32   // maximum number of drives
#define  PZ    64   // print buffer size

#define SERVERNAME_LENGTH   48
#define USERNAME_LENGTH     16
#define PASSWORD_LENGTH     16
#define IPXADDRESS_LENGTH   12
#define NODEADDRESS_LENGTH  6

typedef  UCHAR  byte;
typedef  USHORT word;

typedef  byte   CONN_INDEX; // index into ConnectionIdTable, range 0..MC-1
typedef  byte   DRIVE;      // index into DriveXxxTable, range 0..MD-1

/* OpenFile() Flags */

#define OF_READ_WRITE_MASK  0x0003
/*
#define OF_READ 	        0x0000
#define OF_WRITE	        0x0001
#define OF_READWRITE	    0x0002
*/
#define OF_SHARE_MASK       0x0070
/*
#define OF_SHARE_COMPAT	    0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE	        0x0100
#define OF_DELETE	        0x0200
#define OF_VERIFY	        0x0400   */ /* Used with OF_REOPEN */
/*
#define OF_SEARCH	        0x0400	 */ /* Used without OF_REOPEN */
/*
#define OF_CANCEL	        0x0800
#define OF_CREATE	        0x1000
#define OF_PROMPT	        0x2000
#define OF_EXIST	        0x4000
#define OF_REOPEN	        0x8000
*/

//
// Force misalignment of the following structures
//

/* XLATOFF */
#include <packon.h>
/* XLATON */

typedef  struct CID { /* */
    byte        ci_InUse;
    byte        ci_OrderNo;
    byte        ci_ServerAddress[IPXADDRESS_LENGTH];
    word        ci_TimeOut;
    byte        ci_LocalNode[NODEADDRESS_LENGTH];
    byte        ci_SequenceNo;
    byte        ci_ConnectionNo;
    byte        ci_ConnectionStatus;
    word        ci_MaxTimeOut;
    byte        ci_ConnectionLo;
    byte        ci_ConnectionHi;
    byte        ci_MajorVersion;
    byte        ci_1;
    byte        ci_MinorVersion;
} CONNECTIONID;
typedef CONNECTIONID UNALIGNED *PCONNECTIONID;

#if 0  /* Already declared in nw\inc\ntddnwfs.h */
typedef  char   SERVERNAME[SERVERNAME_LENGTH];
#endif

typedef  char   USERNAME[USERNAME_LENGTH];
typedef  char   PASSWORD[PASSWORD_LENGTH];
typedef  char   IPXADDRESS[IPXADDRESS_LENGTH];
typedef  char   NODEADDRESS[NODEADDRESS_LENGTH];

//
//  The following type collects all the structures used between the TSR
//  and the 32 bit dll into one packed structure.
//
// *** ANY CHANGES TO THIS STRUCTURE MUST ALSO BE MADE TO THE ASM NWDOSTABLE_ASM
// *** STRUCTURE (below)
//

/* XLATOFF */
typedef struct {
    CONNECTIONID    ConnectionIdTable[MC];
    SERVERNAME      ServerNameTable[MC];
    CONN_INDEX      DriveIdTable[MD];       // Corresponding ConnectionId
    UCHAR           DriveFlagTable[MD];
    UCHAR           DriveHandleTable[MD];
    UCHAR           PreferredServer;
    UCHAR           PrimaryServer;
    UCHAR           TaskModeByte;
    UCHAR           CurrentDrive;
    USHORT          SavedAx;
    USHORT          NtHandleHi;
    USHORT          NtHandleLow;
    USHORT          NtHandleSrcHi;
    USHORT          NtHandleSrcLow;
    USHORT          hVdd;
    USHORT          PmSelector;
    UCHAR           CreatedJob;
    UCHAR           JobHandle;
    UCHAR           DeNovellBuffer[256];
    UCHAR           DeNovellBuffer2[256];
} NWDOSTABLE;
typedef NWDOSTABLE *PNWDOSTABLE;
/* XLATON */

//
// Turn structure packing back off
//

/* XLATOFF */
#include <packoff.h>
/* XLATON */

//
//  CONNECTIONID Constants
//

#define FREE                        0
#define IN_USE                      0xff

//
//  Values for DriveFlags
//

#define NOT_MAPPED                  0
#define PERMANENT_NETWORK_DRIVE     1
#define TEMPORARY_NETWORK_DRIVE     2
#define LOCAL_DRIVE                 0x80


///// Client state tables:

extern  CONNECTIONID*   ConnectionIdTable;          //  MC entries
extern  SERVERNAME*     ServerNameTable;            //  MC entries

extern  byte*           DriveFlagTable;             //  MD entries
extern  byte*           DriveIdTable;               //  MD entries

//
// this next egregious grossness is extant because MASM cannot handle anything
// other than a basic type inside a structure declaration
//
// *** ANY CHANGES TO THIS STRUCTURE MUST ALSO BE MADE TO THE C NWDOSTABLE
// *** STRUCTURE (above)
//
// NB. The leading underscores are there because we already have globals with
// the same names
//

/* ASM

NWDOSTABLE_ASM struc

_ConnectionIdTable  db ((size CID) * MC) dup (?)
_ServerNameTable    db (MC * SERVERNAME_LENGTH) dup (?)
_DriveIdTable       db MD dup (?)
_DriveFlagTable     db MD dup (?)
_DriveHandleTable   db MD dup (?)
_PreferredServer    db ?
_PrimaryServer      db ?
_TaskModeByte       db ?
_CurrentDrive       db ?
_SavedAx            dw ?
_NtHandleHi         dw ?
_NtHandleLow        dw ?
_NtHandleSrcHi      dw ?
_NtHandleSrcLow     dw ?
_hVdd               dw ?
_PmSelector         dw ?
_CreatedJob         db ?
_JobHandle          db ?
_DeNovellBuffer     db 256 dup (?)
_DeNovellBuffer2    db 256 dup (?)

NWDOSTABLE_ASM ends

*/

/* XLATOFF */
//
// IS_ASCII_PATH_SEPARATOR - returns TRUE if ch is / or \. ch is a single
// byte (ASCII) character
//
#define IS_ASCII_PATH_SEPARATOR(ch)     (((ch) == '/') || ((ch) == '\\'))
/* XLATON */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\asmmacro.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    asmmacro.inc
;
;Abstract:
;
;    Contains macros to extend masm functionality:
;
;       jmpc
;       jmpnc
;       jmpne
;       jmps
;       _mkjmp
;
;
;Author:
;
;    Richard L Firth (rfirth) 24-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;Revision History:
;
;    24-Sep-1991 rfirth
;        Created
;
;--



DEFINED_BIT=020h
;ISDEFINED equ %(.type <thing> and DEFINED_BIT)
LABEL_DEFINED equ <(.type &label and DEFINED_BIT)>

DEBUG_MACROS    = 0
;DEBUG_MACROS    = 1


;***    jmpa
;*
;*      jump to label if above. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpa    macro   label
        _mkjmp  ja,jna,&label
endm

;***    jmpc
;*
;*      jump to label if below. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpb    macro   label
        _mkjmp  jb,jnb,&label
endm

;***    jmpc
;*
;*      jump to label if carry flag set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpc    macro   label
        _mkjmp  jc,jnc,&label
endm



;***    jmpnc
;*
;*      jump to label if carry flag NOT set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpnc   macro   label
        _mkjmp  jnc,jc,&label
endm



;***    jmpne
;*
;*      jump to label if zero flag NOT set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpne   macro   label
        _mkjmp  jne,je,&label
endm



;***    jmpe
;*
;*      jump to label if zero flag set. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmpe    macro   label
        _mkjmp  je,jne,&label
endm



;***    jmps
;*
;*      jump to label. Label can be short (+129, -126 from
;*      the first byte of the current jump instruction, if it is a short - ie
;*      byte - jump) or near
;*
;*      ENTRY   label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

jmps    macro   label
        local   l,dist
dist=&label-$
if1
if (.type label and DEFINED_BIT)
if ((dist gt 129) or (dist lt -126))
if DEBUG_MACROS
        %out pass1: &label defined and near
endif
        jmp     &label
else
if DEBUG_MACROS
        %out pass1: &label defined and short
endif
        jmp     short &label
endif
else
if DEBUG_MACROS
        %out pass1: &label not defined
endif
        org     $+3
endif
else
if ((dist gt 129) or (dist lt -126))
if DEBUG_MACROS
        %out pass2: &label defined and near
endif
        jmp     &label
else
if DEBUG_MACROS
        %out pass2: &label defined and short
endif
        jmp     short &label
        org     $+1
endif
endif
l:
endm



;***    _mkjmp
;*
;*      Make a jmp<?> macro. Generate instruction sequence for jump with or
;*      without conditional test. Jump may be short (+127/-128 bytes) or near
;*      (+32767/-32768 bytes)
;*
;*      ENTRY   is      - short jump instruction
;*              in      - near jump instruction
;*              label   - to jump to
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

_put macro s,v
if2
if DEBUG_MACROS
%out s = v
endif
endif
endm

_mkjmp  macro   is, in, label
        local   l

;;
;; if pass 1 and label is already known, generate correct instruction
;;

if1
if (.type &label and DEFINED_BIT)

;;
;; if label is too far away for short jump instruction, make jump <condition>
;; into jump <NOT condition> round jump to label followed by a near jump to
;; label
;;

if (((&label - $) gt 129) or ((&label - $) lt -126))
        &in     l       ;; short jump, NOT condition
        jmp     &label  ;; jump to where we want to go
else
        &is     &label  ;; short jump
endif

;;
;; if pass 1 and we don't know about the label yet, adjust the program
;; counter by the max. number of bytes taken up by this macro (5 - 2 for
;; short jump, 3 for near jump)
;;

else
        nop
        nop
        nop
        nop
        nop
endif

;;
;; pass 2 - do same stuff as for pass 1
;;

else
if (((&label - $) gt 129) or ((&label - $) lt -126))
 if ((&label-$) gt 129)
        _put    <label distance>, %(&label-$)
 else
        _put    <label distance>, %($-&label)
 endif
        &in     l
        jmp     &label
else

;;
;; label is within +127/-128 bytes of current instruction - generate short
;; jump instruction and put the program counter forward past the space
;; reserved during pass 1
;;

        _put    <label distance>, %(&label-$)
        &is     &label
        nop
        nop
        nop
endif
endif
l:
endm



oldjmps macro   label
if2
if (((&label - $) gt 127) or (($ - &label) lt -128))
        jmp     short l
        jmp     &label
else
        jmp     short &label
        org     $+3
endif
else
;;
;; if this is pass 1 just take up max amount of space so phases don't get
;; screwed
;;
        org     $+5
endif
l:
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\debugmac.inc ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    debugmac.inc
;
;Abstract:
;
;    Contains debugging macros:
;
;       DbgBreakPoint
;       DbgUnsupported
;       DbgDEBUG
;       DbgPrint
;       DbgPrintTty
;       DbgPrintString
;       DbgPrintHexDword
;       DbgPrintHexWord
;       DbgPrintHexByte
;       DbgPrintNearPointer
;       DbgPrintFarPointer
;
;Author:
;
;    Richard L Firth (rfirth) 13-Sep-1991
;
;Environment:
;
;    DOS application mode only
;
;[Notes:]
;
;    optional-notes
;
;Revision History:
;
;    13-Sep-1991 rfirth
;        Created
;
;--


;***    DbgBreakPoint
;*
;*      Same as NT routine of same name. No-op in non-DEBUG version
;*
;*      ENTRY
;*
;*      EXIT
;*
;*      RETURNS
;*
;*      ASSUMES
;*
;***

DbgBreakPoint macro
if DEBUG
        int     3
endif
endm

;***    DbgUnsupported
;*
;*      Causes the 32-bit support code to display a message about an unsupported
;*      service code, and dumps the 16-bit registers. Used to discover when an
;*      unsupported int 2f/11 call or int 21/5f call is being made
;*
;*      ENTRY
;*
;*      EXIT
;*
;*      RETURNS
;*
;*      ASSUMES
;*
;***

DbgUnsupported macro
if DEBUG
        SVC     -1
endif
endm

;***    DbgDEBUG
;*
;*      Prints the string "DEBUG: " to console using Bios Int 10h/ah=0eh
;*
;*      ENTRY   nothing
;*
;*      EXIT    nothing
;*
;*      USES    ax
;*
;*      ASSUMES 286+
;*
;***

DbgDEBUG macro
        mov     ax,(14 shl 8) + 'D'
        int     10h
        mov     al,'E'
        int     10h
        mov     al,'B'
        int     10h
        mov     al,'U'
        int     10h
        mov     al,'G'
        int     10h
        mov     al,':'
        int     10h
        mov     al,' '
        int     10h
endm



;***    DbgCrLf
;*
;*      Prints CR,LF to console using Bios Int 10h/ah=0eh
;*
;*      ENTRY   nothing
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgCrLf macro
        push    ax
        mov     ax,(14 shl 8) + 13
        int     10h
        mov     al,10
        int     10h
        pop     ax
endm



;***    DbgPrint
;*
;*      Prints an ASCIZ string to console using Bios Int 10h
;*
;*      ENTRY   string  - address of ASCIZ string to print
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrint macro string
if DEBUG                        ;; no macro if not debug version
        pushf                   ;; save regs used by DbgPrintTty
        push    ax
        push    bx
        push    si
        push    ds
        mov     ax,seg string
        mov     ds,ax
        mov     si,offset string;; ds:si = address of string
        DbgPrintTty             ;; display it on console
        pop     ds
        pop     si
        pop     bx
        pop     ax
        popf
endif
endm



;***    DbgPrintTty
;*
;*      Prints an ASCIZ string in ds:si to console using Bios Int 10h
;*
;*      ENTRY   page    - if present defines which Bios video page to use
;*                        Defaults to 0
;*              ds:si   - address of ASCIZ string to print
;*
;*      EXIT    nothing
;*
;*      USES    al, bh, si, flags
;*
;*      ASSUMES 286+
;*
;***

DbgPrintTty macro page
        local   l1,l2

if DEBUG                        ;; no macro if not debug version
        mov     ah,14           ;; Bios Int write character as TTY function
ifb <page>
        sub     bh,bh
else
        mov     bh,page
endif
        cld                     ;; autoincrement lodsb
l1:     lodsb                   ;; al := next character; si := next character addr
        or      al,al           ;; eof string?
        jz      l2              ;; yes
        int     10h             ;; display it to console
        jmp     short l1        ;; go round again
l2:
endif
endm



;***    DbgPrintString
;*
;*      Prints a string to console using Bios Int 10h. Note that this macro
;*      does not do printf style substitutions. The string "DEBUG: " will be
;*      displayed if the banner parm is not blank
;*
;*      ENTRY   string  - character string. Needn't be zero-terminated
;*              banner  - the "DEBUG: " banner will be printed if not blank
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintString macro string, banner
        local   s1
        local   l1

if DEBUG                        ;; no macro if not debug version
        jmp     short l1
s1      db      &string,0
l1:     pushf                   ;; don't destroy direction flag
        pusha                   ;; save gp regs
ifb <banner>
        DbgDEBUG                ;; Display "DEBUG: "
endif
        push    ds              ;; save user's data seg
        push    cs
        pop     ds              ;; ds == cs
        mov     si,offset cs:s1 ;; si := string offset
        DbgPrintTty             ;; display ds:si to console
        pop     ds              ;; restore user's data seg
        popa                    ;; restore gp regs
        popf                    ;; restore direction flag+
endif
endm



;***    DbgPrintHexDword
;*
;*      Prints a dword to console in hex notation using Bios Int 10h
;*
;*      ENTRY   dword   - dword to print
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexDword macro dword
if DEBUG                        ;; no macro if not debug version
        DbgPrint    <"DbgPrintHexDword not implemented yet",13,10>
endif
endm



;***    DbgPrintHexWord
;*
;*      Prints a word to console in hex notation using Bios Int 10h
;*
;*      ENTRY   word    - to print. Can be memory or register
;*
;*      EXIT    nothing
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexWord macro word
        local   l1, l2
if DEBUG                        ;; no macro if not debug version
        pushf                   ;; don't use any registers
        push    ax
        push    cx
        push    dx
ifdifi <word>,<ax>
        mov     ax,word
endif
        mov     cx,4
l1:     rol     ax,4
        mov     dx,ax
        and     al,0fh
        cmp     al,9
        jle     l2
        add     al,'a'-('9'+1)
l2:     add     al,'0'
        mov     ah,14
        int     10h
        mov     ax,dx
        loop    l1
        pop     dx
        pop     cx
        pop     ax
        popf
endif
endm



;***    DbgPrintHexByte
;*
;*      Prints a string to console using Bios Int 10h. Note that this macro
;*      does not do printf style substitutions
;*
;*      ENTRY   string  - character string. Needn't be zero-terminated
;*
;*      EXIT
;*
;*      USES    nothing
;*
;*      ASSUMES 286+
;*
;***

DbgPrintHexByte macro byte
if DEBUG                        ;; no macro if not debug version
        DbgPrint    <"DbgPrintHexByte not implemented yet",13,10>
endif
endm



DbgPrintNearPointer macro nearptr
endm



DbgPrintFarPointer macro farptr
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\nw16.asm ===
page    ,132

if 0
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nw16.asm

Abstract:

    This module contains the stub redir TSR code for NT VDM net support

Author:

    Richard L Firth (rfirth) 05-Sep-1991
    Colin Watson (colinw)    30-Jun-1993

Environment:

    Dos mode only

Revision History:

    05-Sep-1991 rfirth
        Created

    30-Jun-1993 colinw
        ported to NetWare

--*/
endif



;
; DOS include files
;

.xlist
.xcref
include ..\..\..\..\public\sdk\inc\isvbop.inc   ;  NTVDM BOP mechanism
include dossym.inc      ; includes MS-DOS version etc
include pdb.inc         ; PSP defines
include syscall.inc     ; AssignOper
include segorder.inc    ; load order of 'redir' segments
include debugmac.inc    ; debug display macros
include asmmacro.inc    ; jumps which may be short or near
include messages.inc
include nwdos.inc       ; NetWare structures and nwapi32 interface
.cref
.list

;
; Define externals in resident code and data
;

ResidentCodeStart

        extrn   Old21Handler:dword
        extrn   NwInt21:near
        extrn   hVDD:dword
        extrn   quick_jump_to_dos:byte
        extrn   for_dos_proper:byte
        extrn   chain_previous_int21:byte
        extrn   ConnectionIdTable:byte
        extrn   not_exclusive:byte

ResidentCodeEnd


InitStack       segment stack para 'stack'

        dw      256 dup (?)

InitStack       ends

InitDataStart


bad_ver_msg     db      NLS_MSG_001,c_CR,c_LF
BAD_VER_MSG_LEN equ     $-bad_ver_msg
                db      '$'             ; for INT 21/09 display string

already_loaded_msg      db      NLS_MSG_004,c_CR,c_LF
ALREADY_LOADED_MSG_LEN  equ     $-already_loaded_msg

cannot_load_msg db      NLS_MSG_005,c_CR, c_LF
CANNOT_LOAD_MSG_LEN     equ     $-cannot_load_msg

InitDataEnd


InitCodeStart

        assume  cs:InitCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        public DllName
DllName         db      "NWAPI16.DLL",0

        public InitFunc
InitFunc        db      "Nw16Register",0

        public  DispFunc
DispFunc        db      "Nw16Handler",0

        public  start
start   proc    near

;
; when we start up we could be on any old PC - even an original, so don't
; assume anything other than a model-T processor
;

        .8086

;
; Set the data segment while we're at it - all paths set it sooner
; or later. NOTE: es will point to the PSP until we change it!
;

        mov     dx,InitData
        mov     ds,dx
        assume  ds:InitData

;
; first off, get the DOS version. If we're not running on NT (VDM) then this
; TSR's not going to do much, so exit. Exit using various methods, depending
; on the DOS version (don't you hate compatibility?)
;

        mov     ah,30h
        int     21h
        jc      ancient_version         ; version not even supported

;
; version is 2.0 or higher. Check it out. al = major#, ah = minor#
;

        cmp     al,major_version
        jne     invalid_version

;
; what do you know? We're actually running on NT (unless some evil programmer
; has pinched int 21h/30h and broken it!). Enable minimum instruction set
; for NTVDM (286 on RISC).
;

        .286c

;
; perform an installation check by calling one of our entry points
; (GetFileServerNameTable). If this returns a table pointer in ES:DI then we
; know this TSR is already active, in which case we bail out now
;

        push    es
        push    di
        xor     di,di
        mov     es,di
        mov     ax,0ef03h
        int     21h
        mov     ax,es
        or      ax,di
        pop     di
        pop     es
        jnz     already_here

;
; OK, the NetWare redir is not already loaded - we're in business.
; Find entrypoints to nwapi16.dll Get and set the various interrupt
; vectors, Calculate the amount of space we want to keep,
; free up any unused space (like the environment segment), display a message
; in the DEBUG version, then terminate and stay resident. Remember: at this
; point we expect ES to point at the PSP
;

        call    PullInDll
        jc      already_here            ; failed to load

        call    InstallInterruptHandlers

        assume  es:nothing

        push    es
        pop     ds
        call    is_c_on_command_line
        jz      @f

        mov     dx,ResidentCode
        mov     ds,dx

        assume  ds:ResidentCode
        mov     not_exclusive, 1

        assume  ds:nothing
@@:

;
; free the environment segment
;

        mov     es,es:[PDB_environ]
        mov     ah,49h
        int     21h                     ; free environment segment

;if DEBUG
;ifdef VERBOSE
;        DbgPrintString <"NetWare Redir successfully loaded",13,10>
;endif
;endif

;
; finally terminate and stay resident
;

        mov     dx,ResidentEnd
        sub     dx,ResidentStart        ; number of paragraphs in resident code
        add     dx,10h                  ; additional for PSP (PDB)


;if DEBUG
;ifdef VERBOSE
;        DbgPrintString "Staying resident with "
;        DbgPrintHexWord dx
;        DbgPrintString " paragraphs. Load seg is ",NOBANNER
;        mov     ah,62h
;        int     21h
;        DbgPrintHexWord bx
;        DbgPrintString " current seg is ",NOBANNER
;        DbgPrintHexWord cs
;        DbgCrLf
;endif
;endif

        mov     ax,3100h
        int     21h                     ; terminate and stay resident

;
; here if the MS-DOS version check (Ah=30h) call is not supported
;

ancient_version:
        mov     dx,InitData
        mov     ds,dx

        assume  ds:InitData

        mov     dx,offset bad_ver_msg
        mov     ah,9                    ; cp/m-style write to output
        int     21h

;
; safe exit: what we really want to do here is INT 20H, but when you do this,
; CS must be the segment of the PSP of this program. Knowing that CD 20 is
; embedded at the start of the PSP, the most foolproof way of doing this is
; to jump (using far return) to the start of the PSP
;

        push    es
        xor     ax,ax
        push    ax
        retf                            ; terminate

;
; we are running on a version of DOS >= 2.00, but its not NT, so we still can't
; help. Display the familiar message and exit, but using a less programmer-
; hostile mechanism
;

invalid_version:
        mov     dx,offset bad_ver_msg
        mov     cx,BAD_VER_MSG_LEN
        jmps    print_error_message_and_exit

;
; if we cannot initialize 32-bit support (because we can't find/load the DLL)
; then put back the hooked interrupt vectors as they were when this TSR started,
; display a message and fail to load the redir TSR
;

initialization_error:
        call    RestoreInterruptHandlers
        mov     dx,offset cannot_load_msg
        mov     cx,CANNOT_LOAD_MSG_LEN
        jmps    print_error_message_and_exit

;
; The DOS version's OK, but this TSR is already loaded
;

already_here:
        mov     dx,offset already_loaded_msg
        mov     cx,ALREADY_LOADED_MSG_LEN

print_error_message_and_exit:
        mov     bx,1                    ; bx = stdout handle
        mov     ah,40h                  ; write to handle
        int     21h                     ; write (cx) bytes @ (ds:dx) to stdout
        mov     ax,4c01h                ; terminate program
        int     21h                     ; au revoir, cruel environment

start   endp

;*******************************************************************************
;*
;*  InstallInterruptHandlers
;*
;*      Sets the interrupt handlers for all the ints we use - 21
;*
;*  ENTRY       es = PSP segment
;*              ds =
;*
;*  EXIT        Old21Handler contains the original interrupt 21 vector
;*
;*  RETURNS     nothing
;*
;*  ASSUMES
;*
;*******************************************************************************

InstallInterruptHandlers proc
        push    es                      ; PSP segment - destroyed by INT 21/35h
        push    ds

;
; note: if we use ResidentCode here, explicitly, instead of seg OldMultHandler,
; then we can leave out an extraneous load of ds for the ISR address
;

        mov     dx,ResidentCode
        mov     ds,dx

        assume  ds:ResidentCode

;
; Add ourselves to the int 21 chain
;

        mov     ax,3521h
        int     21h
        mov     word ptr Old21Handler,bx
        mov     word ptr Old21Handler+2,es
        mov     word ptr quick_jump_to_dos+1,bx
        mov     word ptr quick_jump_to_dos+3,es
        mov     word ptr for_dos_proper+1,bx
        mov     word ptr for_dos_proper+3,es
        mov     word ptr chain_previous_int21+1,bx
        mov     word ptr chain_previous_int21+3,es
        mov     dx,offset ResidentCode:NwInt21
        mov     ax,2521h
        int     21h

        pop     ds                      ; restore segment registers
        pop     es
        ret
InstallInterruptHandlers endp

;*******************************************************************************
;*
;*  RestoreInterruptHandlers
;*
;*      Resets the interrupt handlers for all the ints we use - 21
;*
;*  ENTRY       Old21Handler
;*              contain the interrupt vectors from before nw16.sys was loaded
;*
;*  EXIT        Original interrupt vectors are restored
;*
;*  RETURNS     nothing
;*
;*  ASSUMES
;*
;*******************************************************************************

RestoreInterruptHandlers proc
        push    ds

        assume  ds:nothing

        push    es
        mov     dx,ResidentCode
        mov     es,dx

        assume  es:ResidentCode

        lds     dx,Old21Handler
        mov     ax,2521h
        int     21h

        pop     es
        pop     ds
        ret
RestoreInterruptHandlers endp

;*******************************************************************************
;*
;*  PullInDll
;*
;*      Does a RegisterModule to load NWAPI32.DLL into our NTVDM.EXE
;*
;*  ENTRY       nothing
;*
;*  EXIT        nothing
;*
;*  RETURNS     cf if fails.
;*
;*  ASSUMES     Earth moves round Sun
;*
;******************************************************************************/

PullInDll proc near

        pusha                           ; dispatch code
        push    dx                      ; save callers dx,ds,es,ax
        push    ds
        push    es
        push    ax

        mov     dx,InitCode
        mov     ds,dx

        assume  ds:InitCode

        push    ds
        pop     es

        assume  es:InitCode

        mov     si,offset DllName       ; ds:si = nwapi32.dll
        mov     di,offset InitFunc      ; es:di = init routine
        mov     bx,offset DispFunc      ; ds:bx = dispatch routine
        mov     ax,ResidentCode
        mov     dx,offset ConnectionIdTable
                                        ; ax:dx = shared datastructure

        RegisterModule

        jc      @f

        mov     dx,ResidentCode
        mov     ds,dx
        assume  ds:ResidentCode
        mov     word ptr hVDD,ax

@@:     pop     ax                      ; callers ax
        pop     es                      ; callers es
        pop     ds                      ; callers ds
        pop     dx                      ; callers dx

        assume  ds:nothing
        assume  es:nothing

        popa                            ; dispatch code
        ret
PullInDll endp

;*******************************************************************************
;*
;*  is_c_on_command_line
;*
;*     -C or /C means we should open compatiblity mode createfiles as shared
;*      instead of exclusive
;*
;*  ENTRY       ds points to PDB
;*
;*  EXIT        nothing
;*
;*  RETURNS     zero if not found.
;*
;*  ASSUMES     ds points at PSP
;*
;******************************************************************************/

is_c_on_command_line proc near
        mov     si,80h
        lodsb
        cbw
        mov     cx,ax
next:   jcxz    quit
        dec     cx
        lodsb
check_next:
        cmp     al,'-'
        je      check_c
        cmp     al,'/'
        je      check_c
        cmp     al,' '
        je      next
        cmp     al,9
        je      next
find_ws:jcxz    quit
        dec     cx
        lodsb
        cmp     al,' '
        je      next
        cmp     al,9
        je      next
        jmp     short find_ws
check_c:jcxz    quit
        dec     cx
        lodsb
        or      al,20h
        cmp     al,'c'
        jne     find_ws
        or      cx,ax
quit:   or      cx,cx
        ret
is_c_on_command_line endp

InitCodeEnd
end     start
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\resident.asm ===
page    ,132
if 0

/*++

Copyright (c) 1993-4 Microsoft Corporation

Module Name:

    resident.asm

Abstract:

    This module contains the resident code part of the stub redir TSR for NT
    VDM NetWare support.

Author:

    Colin Watson (colinw)   08-Jul-1993

Environment:

    Dos mode only

Revision History:

    08-Jul-1993 colinw
        Created

--*/

endif



.xlist                  ; don't list these include files
.xcref                  ; turn off cross-reference listing
include ..\..\..\..\public\sdk\inc\isvbop.inc      ; NTVDM BOP mechanism
include dosmac.inc      ; Break macro etc (for following include files only)
include dossym.inc      ; User_<Reg> defines
include segorder.inc    ; segments
include mult.inc        ; MultNET
include sf.inc          ; SFT definitions/structure
include pdb.inc         ; program header/process data block structure

include debugmac.inc    ; DbgPrint macro
include asmmacro.inc    ; language extensions

include nwdos.inc       ; NetWare structures and nwapi32 interface

.cref                   ; switch cross-reference back on
.list                   ; switch listing back on
subttl                  ; kill subtitling started in include file


.286                    ; all code in this module 286 compatible

far_segment segment
far_label label far
far_segment ends

ResidentCodeStart

        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        public  Old21Handler
Old21Handler    dd      ?

;
; IMPORTANT: the following up to the comment <END NWDOSTABLE> must
; be kept in the same order as for the NWDOSTABLE structure in NWDOS.H/.INC.
; Align on 32 bits to make it convenient for nwapi32.dll
;
        align 4

        public  ConnectionIdTable
ConnectionIdTable       CID      MC dup (<>)

        public  ServerNameTable
ServerNameTable         db       MC * SERVERNAME_LENGTH dup (0)

        public  DriveIdTable
DriveIdTable            db       MD dup (0)

        public  DriveFlagTable
DriveFlagTable          db       MD dup (0)

        public  DriveHandleTable
DriveHandleTable        db      MD dup (0)

        public  PreferredServer
PreferredServer         db      0

        public  PrimaryServer
PrimaryServer           db      0

        public  TaskModeByte
TaskModeByte            db      0

CurrentDrive            db      0

        public  SavedAx;
SavedAx                 dw      0

        public  NtHandleHi;
NtHandleHi              dw      0
        public  NtHandleLow;
NtHandleLow             dw      0

        public  NtHandleSrcHi;          //      Used in FileServerCopy
NtHandleSrcHi           dw      0
        public  NtHandleSrcLow;
NtHandleSrcLow          dw      0

        public hVDD
hVDD                    dw      -1

        public PmSelector
PmSelector              dw      0

        public  CreatedJob
CreatedJob              db      0
        public  JobHandle
JobHandle               db      0

NOV_BUFFER_LENGTH       equ     256

        public  DenovellBuffer
DenovellBuffer          db      NOV_BUFFER_LENGTH  dup (?)

        public  DenovellBuffer2
DenovellBuffer2         db      NOV_BUFFER_LENGTH  dup (?)


.errnz (size DeNovellBuffer2 - size DenovellBuffer)

Comspec                 db      "COMSPEC="
COMSPEC_LENGTH          equ ($ - Comspec)

;
; this is the <END NWDOSTABLE> structure.
;

;
; data passed from nw16.asm
;
        public not_exclusive
not_exclusive           db      0

        page

        public  NwInt21
NwInt21 proc    far
        assume  cs:ResidentCode
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing

        sti                             ; make sure ints are still enabled

;
; check whether we filter this vector; if not, pass it through to previous INT 21
; handler (DOS or some other TSR)
;
; If this is a name based operation, and the caller is passing through a novell
; format name - SYS:FOO or SERVER\SYS:FOO - then munge the name to be a UNC name
;

        cmp     ah,0eh
        jne     @f
        jmp     select_default_drive
@@:     cmp     ah,39h                  ; create directory
        je      check_name
        ja      @f

;
; ah less than 39h (mkdir) is definitely for DOS
;

        public  quick_jump_to_dos
quick_jump_to_dos:
        jmp     far_label

;
; run any of the following name-based calls through the name check:
;
;       3ah     remove directory
;       3bh     change directory
;       3ch     create file
;       3dh     open file
;       41h     delete file
;       43h     get/set attributes
;       4bh     exec program
;       4eh     find first file
;       56h     rename
;

@@:     cmp     ah,3dh
        jbe     check_name
        cmp     ah,41h                  ; delete file
        je      check_name
        cmp     ah,43h                  ; get/set attributes
        je      check_name
        cmp     ah,4bh                  ; exec program
        je      check_name
        cmp     ah,4eh                  ; find first file
        je      check_name
        cmp     ah,56h                  ; rename
        je      rename
        jmp     dispatch_check


;
; Rename function. This has 2 path names: source in ds:dx and
; destination in es:di. Check the destination first then fall through
; and check the source.
;
rename:
        push    ds
        push    dx
        push    es
        push    di                      ; user registers saved for after Int21

        push    ds                      ; save ds:dx 'cause we will corrupt them
        push    dx

        mov     dx,es
        mov     ds,dx
        mov     dx,di                   ; ds:dx = destination buffer
        call    IsDosPath
        je      @f                      ; DOS path, no modification
        cld
        push    di
        call    DenovellizeName
        pop     di
        cmp     dx,offset DenovellBuffer
        je      swap_buffers

@@:
        pop     dx                      ; ds:dx points at source again
        pop     ds

        pop     di
        pop     es
        pop     dx
        pop     ds
        jmp     check_name

;
; Destination name was normalized and stored in DeNovellBuffer. put the data
; in Denovellbuffer2 in-case we need to put the Source name in Denovellbuffer
;

swap_buffers:
        push    cx
        push    si
        push    ds                      ; will become es during Dos call

        mov     si,dx
        mov     di,cs
        mov     es,di
        mov     di,offset DenovellBuffer2
        mov     cx,NOV_BUFFER_LENGTH / 2
.errnz (NOV_BUFFER_LENGTH and 1)

        rep     movsw

        mov     di,offset DenovellBuffer2
        pop     es                      ; es:di is now Denovellbuffer2
        pop     si
        pop     cx

        pop     dx                      ; make ds:dx source again
        pop     ds

                                        ; stack has users di,es,dx,ds pushed
                                        ; parameters are same as callers except for es:di
        jmp     check_src

check_name:                             ; ds:dx points at name to examine
        push    ds
        push    dx
        push    es
        push    di
                                        ; fall through

check_src:                              ; only jumped to in rename

        cld
        call    IsDosPath
        je      for_dos_properR         ; x: or UNC filename. No more processing

        cmp     ah,3dh
        jne     notNETQ                 ; special NETQ open only applies for create
        cmp     CreatedJob,0
        jz      notNETQ                 ; don't look at name if no job handle available

        push    ax
        push    si
        mov     si,dx
        cld
        lodsw
        cmp     ax,"EN"
        jne     @f
        lodsw
        cmp     ax,"QT"
        jne     @f
        lodsb
        or      al,al
        jnz     @f

        pop     si                      ; Opening NETQ. Return Dos handle from CreateJob and File
        pop     ax
        mov     CreatedJob,0            ; Only return handle once
        mov     al, JobHandle
        xor     ah, ah
        pop     di
        pop     es
        pop     dx
        pop     ds
        clc
        retf    2

@@:     pop     si
        pop     ax
        jmp     for_dos_properR

notNETQ:push    di
        call    DenovellizeName         ; munge the name if required
        pop     di                      ; restore caller DI

;
; Look for compatibility mode opens that need to change to exlusive mode
; opens so that they get properly cached. Criteria for opening exclusive
; is that the application did not specify any sharing modes and the drive
; being opened is on a netware drive.
;

        cmp     ah, 3ch
        je      @f
        cmp     ah, 3dh
        jne     not_compat
@@:     test    al,OF_SHARE_MASK
        jne     not_compat

        cmp     not_exclusive, 1        ; open shared mode anyway
        je      not_compat

        mov     SavedAx,ax
        mov     ax,hVdd
        DispatchCall                    ; 32 bit code decides if compat mode

not_compat:
        pushf
        call    Old21Handler            ; fake int 21 to get to DOS

        pop     di
        pop     es
        pop     dx
        pop     ds
        retf    2                       ; return to app (with flags from DOS)

for_dos_properR:                        ; restore regs and call dos
        pop     di
        pop     es
        pop     dx
        pop     ds
        cmp     ah, 3ch
        je      @f
        cmp     ah, 3dh
        jne     for_dos_proper
@@:     test    al,OF_SHARE_MASK
        jne     for_dos_proper
        cmp     not_exclusive, 1        ; open shared mode anyway
        je      for_dos_proper
        mov     SavedAx,ax
        mov     ax,hVdd
@@:     DispatchCall                    ; 32 bit code decides if compat mode
        public  for_dos_proper
for_dos_proper:
        jmp     far_label

dispatch_check:
        cmp     ah,04ch
        jne     check_9f
        jmp     process_exit

;
; 'special' entry point to return the data segment info to the protect-mode code
; so it can generate an LDT descriptor which refers to this memory.
;

check_9f:
        cmp     ah,9fh
        jne     check_nw_ep             ; is it a Netware call?
        or      al,al
        jnz     check_handle_mapper
        mov     bx,seg ConnectionIdTable; 9f00: return segment info
        mov     dx,offset ConnectionIdTable
        clc                             ; if we loaded then it can't fail
        retf    2

;
; if the call is 9f01 then we call MapNtHandle for the value in BX. This will
; update NtHandleHi and NtHandleLow, which we assume will be accessed from the
; code segment register
;

check_handle_mapper:
        cmp     al,1
        jne     check_nw_ep             ; still not one of ours?
        call    MapNtHandle             ; 9f01: call MapNtHandle
        retf    2

check_nw_ep:
        cmp     ah,0b4h
        jb      for_dos_proper
        cmp     ah,0f3h
        ja      for_dos_proper
        jne     @f
        jmp     file_server_copy
@@:     cmp     ah,0BAh
        jne     check_f0

        push    bx                      ; get environment. used by map.exe
        push    ax
        mov     ah,051h                 ; load current apps PDB into ax
        int     021h

@@:     mov     es, bx
        cmp     bx, es:PDB_Parent_PID
        je      @f
        mov     bx, es:PDB_Parent_PID
        jmp     @b
@@:
        mov     dx, es:PDB_environ      ; set DX to environment segment
        mov     es, dx                  ; set es:di to value of COMSPEC

        push    si
        push    ds
        mov     ds, dx
        xor     si, si

;       future code to save space
;       es <- env seg
;       di <- env off
;       ds <- cs
;       si <- offset Comspec
;       cx <- .size Comspec / 2
;       cld
;       repz cmpsw
;       jnz     no match

;       al <- 0
;       cx <- remaining size of env seg
;       rep scasb

        cld
next_var:
        lodsb
        cmp     al, "C"
        jne     @f
        lodsb
        cmp     al, "O"
        jne     @f
        lodsb
        cmp     al, "M"
        jne     @f
        lodsb
        cmp     al, "S"
        lodsb
        jne     @f
        cmp     al, "P"
        jne     @f
        lodsb
        cmp     al, "E"
        jne     @f
        lodsb
        cmp     al, "C"
        jne     @f
        lodsb
        cmp     al, "="
        je      got_comspec

@@:                                     ; Search for null terminating environment
        or      al,al
        je      next_var
        lodsb
        jmp     @b

got_comspec:
        pop     ds
        mov     di,si
        pop     si

        pop     ax
        pop     bx
        iret

check_f0:
        cmp     ah,0f0h
        jne     for_me

;
; if we're here then we're doing simple stuff that we don't need to bop fer
; currently stuff here is ah=f0, al = 00, 01, 04, 05
;
; caveat emptor dept #312: However, it came to pass that we needed to bop when
; the f00x calls were made without any preceding calls that would cause nwapi32
; to be loaded
;

dispatch_f0:

.errnz ((offset PrimaryServer - offset PreferredServer) - 1)

        or      al,al                   ; f000 = set preferred server
        jnz     try_01
        cmp     dl,8
        ja      zap_preferred
        mov     PreferredServer,dl
        iret

zap_preferred:
        mov     PreferredServer,al      ; al contains 0 remember
        iret

try_01: cmp     al,1                    ; f001 = get preferred server
        jnz     try_02
        mov     al,PreferredServer
        iret

try_02: cmp     al,2                    ; f002 = get default server
        jnz     try_04
        mov     al,PreferredServer
        or      al,al
        jnz     @f
        mov     al,PrimaryServer
@@:     iret

try_04: cmp     al,4                    ; f004 = set primary server
        jne     try_05
        cmp     dl,8
        ja      zap_primary
        mov     PrimaryServer,dl
        iret

zap_primary:
        mov     PrimaryServer,0
        iret

try_05: cmp     al,5                    ; f005 = get primary server
        jne     for_me
        mov     al,PrimaryServer
        iret

file_server_copy:
        call    FileServerCopy          ; f3 - Used by ncopy.exe
        ;jmp    for_me

;
; if the process exits and the dll is loaded then call the 32 bit code to
; close any cached handles.
;

process_exit:
       ;jmp     for_me

;
; if we're here then the dispatch code is for a NetWare client API. First we
; check if we have already loaded the 32-bit code. If not, then load it. If we
; get an error, we will fall through to DOS
;

for_me:
        cmp     ah,0BCh                 ; bc,bd,be need handle mapping
        jb      no_mapping
        cmp     ah,0BEh
        ja      no_mapping

;do_mapping_call:
        call    MapNtHandle             ; take bx and find the Nt handle

no_mapping:
        mov     SavedAx,ax

        cmp     ah,0e3h                 ; Look for CreateJob NCP
        jne     @f                      ; try f2 alternative

        mov     al,[si+2]                 ; si is NCP subfunction
        jmp     lookupcode

@@:     cmp     ax,0f217h
        jne     do_dispatch             ; Not CreateJob
        mov     al,[si+2]               ; si is NCP subfunction

lookupcode:
        cmp     al,68h
        je      createjob
        cmp     al,79h
        jne     do_dispatch


createjob:                              ; It is a CreateJob and File

                                        ; Always return the errorcode from the NCP exchange
                                        ; regardless of any earlier failures in the NT plumbing.
        mov     ax, SavedAx
        push    ax                      ; Open \\Server\queue for NCP
        push    ds
        push    dx
        mov     ax, 9f02h
        mov     SavedAx,ax

        mov     ax,hVdd
        DispatchCall                    ; Set DeNovellBuffer to \\Server\queue
                                        ; and registers ready for DOS OpenFile

        pushf
        call    Old21Handler            ; Open \\server\queue
        jc      @f
        mov     JobHandle, al
        mov     CreatedJob, 1           ; Flag JobHandle is valid
        push    bx
        xor     ah, ah
        mov     bx, ax                  ; JobHandle
        call    MapNtHandle             ; take bx and find the Nt handle
        pop     bx

@@:
        pop     dx
        pop     ds                      ; Proceed and send the NCP
        pop     ax
        mov     SavedAx, ax

do_dispatch:
        mov     ax,hVdd
        DispatchCall
        retf 2                          ; return to the application

        public  chain_previous_int21
chain_previous_int21:
        jmp     far_label


;
; Save new drive so we can conveniently handle compatibility mode opens.
; also need to return 32 as the number of available drives.
;

select_default_drive:
        pushf
        call    Old21Handler            ; fake int 21 to get to DOS

        mov     ah,19h                  ; get current drive
        pushf
        call    Old21Handler            ; fake int 21 to get to DOS
        mov     CurrentDrive,al         ; current drive

        mov     al,32                   ; # of drives supported by NetWare
        retf    2                       ; return to app (with flags from DOS)


NwInt21 endp

;*******************************************************************************
;*
;*  FileServerCopy
;*
;*      Implement preperation for calling
;*      \\...)
;*
;*  ENTRY       applications registers
;*
;*  EXIT        nothing
;*
;*  RETURNS     nothing
;*
;*  ASSUMES     no registers (except flags) can be destroyed
;*
;******************************************************************************/

FileServerCopy proc near

        push    ax
        push    bx

        mov     bx,word ptr es:[di]     ; Map Source Handle
        call    MapNtHandle

        mov     bx,NtHandleHi
        mov     NtHandleSrcHi,bx
        mov     bx,NtHandleLow
        mov     NtHandleSrcLow,bx

        mov     bx,word ptr es:[di+2]   ; Map Destination Handle
        call    MapNtHandle

@@:     pop     bx
        pop     ax

        ret
FileServerCopy endp

;*******************************************************************************
;*
;*  IsDosPath
;*
;*      Checks to see if a path name looks like a Microsoft path (<drive>:... or
;*      \\...)
;*
;*  ENTRY       ds:dx = path name
;*
;*  EXIT        nothing
;*
;*  RETURNS     ZF = 1: path is for MS-DOS
;*
;*  ASSUMES     no registers (except flags) can be destroyed
;*
;******************************************************************************/

IsDosPath proc near
        push    ax
        xchg    si,dx                   ; si = offset of filename; dx = ????
        mov     al,[si+1]               ; al = second character of filename
        cmp     al,':'
        je      @f                      ; looks like a DOS filename
        cmp     al,'\'                  ; (X\... or \\...)
        jne     tryFirstbyte
        cmp     al,'/'                  ; (X/... or //...)
        jne     @f                      ; second char is not "\" or "/"

tryFirstbyte:
        mov     al,[si]                 ; al = first character of filename
        cmp     al,'\'                  ; (\\... or \/...)
        je      @f
        cmp     al,'/'                  ; (\/... or //...)

@@:     xchg    si,dx                   ; dx = offset of filename; si = ????
        pop     ax
        ret
IsDosPath endp

;*******************************************************************************
;*
;*  DenovellizeName
;*
;*      Converts a name from Novell format (SERVER\SHARE:filename or
;*      SHARE:filename) to DOS UNC name. Server name is found by:
;*
;*              if PreferredServer != 0 then Index = PreferredServer
;*              else if PrimaryServer != 0 then Index = PrimaryServer
;*              else Index = 0
;*              servername = ServerNameTable[Index * sizeof(SERVER_NAME)]
;*
;*  ENTRY       ds:dx = name
;*
;*  EXIT        ds:dx = offset of DenovellBuffer
;*
;*  RETURNS     if success, DI points to last byte+1 in DenovellBuffer, else
;*              DI is garbage
;*
;*  ASSUMES     1. filename does not wrap in buffer segment
;*              2. DI register can be trashed
;*              3. DF = 0
;*
;******************************************************************************/

DenovellizeName proc near
        assume  ds:nothing
        assume  es:nothing

        push    ax
        push    bx
        push    cx
        push    bp
        push    si
        push    es
        mov     bp,ds

;
; get the length of the input filename
;

        mov     cx,ds
        mov     es,cx
        mov     di,dx                   ; es:di = filename
        xor     cx,cx
        dec     cx                      ; cx = ffff
        xor     al,al
        repnz   scasb
        not     cx
        dec     cx                      ; cx = strlen(filename)
        cmp     cx,length DenovellBuffer
        jb      @f
        jmp     dnn_ret                 ; filename too long: give it to DOS

;
; find the offset of ':' in the filename
;

@@:     mov     bx,cx                   ; remember length
        mov     di,dx                   ; es:di = filename
        mov     al,':'
        repnz   scasb                   ; di = strchr(filename, ':')+1
        jz      @f
go_home:jmp     dnn_ret                 ; no ':' - not novell format name?
@@:     cmp     byte ptr [di],0
        je      go_home                 ; device name? (eg "LPT1:") - to DOS
        mov     si,di                   ; si = offset of ':' in name, +1

;
; find the offset of the first '/' or '\'
;

        mov     cx,bx                   ; cx = length of filename
        mov     di,dx                   ; di = offset of filename
        mov     al,'\'
        repnz   scasb
        sub     bx,cx
        mov     cx,bx
        mov     bx,di
        mov     di,dx
        mov     al,'/'
        repnz   scasb
        jnz     @f
        mov     bx,di

;
; if ':' before '\' or '/' then name is SYS:FOO... else SERVER\SYS:FOO...
;

@@:     mov     di,cs
        mov     es,di
        mov     di,offset DenovellBuffer
        mov     ax,('\' shl 8) + '\'
        stosw
        cmp     bx,si
        jb      copy_share_name
        xor     bx,bx
        mov     cl,PreferredServer
        or      cl,cl
        jnz     got_index
        mov     cl,PrimaryServer
        jcxz    get_server_name

got_index:
        dec     cl
        jz      get_server_name
        mov     bx,cx

.errnz SERVERNAME_LENGTH - 48

        shl     cx,5
        shl     bx,4

get_server_name:
        add     bx,cx
        mov     cx,ds
        mov     si,es
        mov     ds,si
        lea     si,ServerNameTable[bx]
        cmp     byte ptr [si],0
        je      dnn_ret
        mov     ah,SERVERNAME_LENGTH

copy_server_name:
        lodsb
        or      al,al
        jz      done_server_name
        stosb
        dec     ah
        jnz     copy_server_name

done_server_name:
        mov     al,'\'
        stosb
        mov     ds,cx

copy_share_name:
        mov     si,dx

next_char:
        lodsb
        cmp     al,':'
        je      @f
        stosb
        jmp     short next_char
@@:     mov     al,'\'
        stosb

copy_rest:
        lodsb
        stosb
        or      al,al
        jnz     copy_rest
        cmp     byte ptr [si-2],':'
        jne     @f
        mov     byte ptr [si-2],0
@@:     mov     dx,offset DenovellBuffer
        mov     bp,es

dnn_ret:mov     ds,bp
        pop     es
        pop     si
        pop     bp
        pop     cx
        pop     bx
        pop     ax
        ret
DenovellizeName endp



;***    DosCallBack
;*
;*      Call back into DOS via the int 2f/ah=12 back door. If CALL_DOS defined,
;*      use a call, else s/w interrupt. Using a call means no other TSRs etc.
;*      which load AFTER the redir can hook it, but we DON'T HAVE TO MAKE A
;*      PRIVILEGE TRANSITION ON x86 which speeds things up. This should be safe,
;*      because no other s/w should really be hooking INT 2F/AH=12
;*
;*      ENTRY   FunctionNumber  - dispatch code goes in al
;*              DosAddr         - if present, variable containing address of
;*                                DOS int 2f entry point
;*              OldMultHandler  - this variable contains the address of DOSs
;*                                int 2f back door. Specific to redir code
;*
;*      EXIT    nothing
;*
;*      USES    ax, OldMultHandler
;*
;*      ASSUMES nothing
;*
;***

DosCallBack macro FunctionNumber, DosAddr
        mov     ax,(MultDOS shl 8) + FunctionNumber
ifdef CALL_DOS
        pushf
ifb <DosAddr>
if (((.type OldMultHandler) and 32) eq 0)    ;; OldMultHandler not defined
        extrn   OldMultHandler:dword
endif
        call    OldMultHandler
else
        call    DosAddr
endif
else
        int     2fh
endif
endm

;
; defines for DosCallBack FunctionNumbers
;

SF_FROM_SFN     =       22
PJFN_FROM_HANDLE=       32

; ***   MapNtHandle
; *
; *     Given a handle in BX, map it to a 32-bit Nt handle store result
; *             in NtHandle[Hi|Low]
; *
; *
; *     ENTRY   bx = handle to map
; *
; *     EXIT    Success - NtHandle set to 32-bit Nt handle from SFT
; *
; *     RETURNS Success - CF = 0
; *             Failure - CF = 1, ax = ERROR_INVALID_HANDLE
; *
; *     USES    ax, bx, flags
; *
; *     ASSUMES nothing
; *
; ***

MapNtHandle proc near
        pusha                           ; save regs used by Dos call back
        push    ds
        push    es

;
; call back to Dos to get the pointer to the JFN in our caller's JFT. Remember
; the handle (BX) is an index into the JFT. The byte at this offset in the JFT
; contains the index of the SFT structure we want in the system file table
;

        DosCallBack PJFN_FROM_HANDLE    ; pJfnFromHamdle
        jc      @f                      ; bad handle

;
; we retrieved a pointer to the required byte in the JFT. The byte at this
; pointer is the SFT index which describes our 'file' (file to (un)lock in
; this case). We use this as an argument to the next call back function -
; get Sft from System File Number.
;

        mov     bl,es:[di]
        xor     bh,bh
        DosCallBack SF_FROM_SFN         ; SfFromSfn
        jc      @f                      ; oops - bad handle

;
; Ok. We have a pointer to the SFT which describes this named pipe. Get the
; 32-bit Nt handle and store it in the shared datastructure.
;

        mov     bx,word ptr es:[di].sf_NtHandle[2]
        mov     NtHandleHi,bx
        mov     bx,word ptr es:[di].sf_NtHandle
        mov     NtHandleLow,bx

;
; restore all registers used by Dos call back.
; Carry flag is set appropriately
;

@@:     pop     es
        pop     ds
        popa
        jnc     @f

;
; finally, if there was an error then return a bad handle indication in ax
;

        mov     ax,ERROR_INVALID_HANDLE
@@:     ret
MapNtHandle endp

ResidentCodeEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=nw16

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\segorder.inc ===
;/*++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    segorder.inc
;
;Abstract:
;
;    This module contains the segment order and segment macros
;
;Author:
;
;    Richard Firth (rfirth) 05-Sep-1991
;
;Environment:
;
;    Dos mode only
;
;Notes:
;
;    When initially loaded, the NT VDM redir has the following order:
;
;       +----------------------+
;       |                      |
;       |    Resident Code     |
;       |                      |
;       +----------------------+
;       |                      |
;       |    Resident Data     |
;       |                      |
;       +----------------------+ ----------------+
;       |                      |                 |
;       | Initialisation Code  | <- entry point  v
;       |                      |
;       +----------------------+
;       |                      |                 all the stuff between these
;       | Initialisation Data  |                 arrows is discarded if we stay
;       |                      |                 resident. Note that the redir
;       +----------------------+                 does not uninstall
;       |                      |
;       | Initialisation Stack |                 ^
;       |                      |                 |
;       +----------------------+ ----------------+
;
;Revision History:
;
;    05-Sep-1991 rfirth
;        Created
;
;--*/



ResidentStart   segment public para 'code'
ResidentStart   ends

ResidentCode    segment public word 'code'
ResidentCode    ends

ResidentData    segment public word 'data'
ResidentData    ends

ResidentEnd     segment public para 'data'
ResidentEnd     ends

ResidentGroup   group   ResidentStart, ResidentCode, ResidentData, ResidentEnd

InitCode        segment public para 'init'
InitCode        ends

InitData        segment public word 'init'
InitData        ends

InitStack       segment stack para 'stack'
InitStack       ends

;
; macros to avoid having to type in/possibly alter segment header guff
;

ResidentCodeStart macro
ResidentCode    segment public word 'code'
endm

ResidentCodeEnd macro
ResidentCode    ends
endm

ResidentDataStart macro
ResidentData    segment public word 'data'
endm

ResidentDataEnd macro
ResidentData    ends
endm

InitCodeStart   macro
InitCode        segment public para 'init'
endm

InitCodeEnd     macro
InitCode        ends
endm

InitDataStart   macro
InitData        segment public word 'init'
endm

InitDataEnd     macro
InitData        ends
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\makefile.inc ===
!IF 0

Copyright (c) 1991 & 1993  Microsoft Corporation

Module Name:

    makefile

Abstract:

    makefile for Vdm NetWare Redir program

Author:

    Richard L Firth (rfirth) 13-Sep-1991

Revision History:

    13-Sep-1991 rfirth
        Created

!ENDIF

!include $(NTMAKEENV)\makefile.plt

#
# Because we've invoked nmake from within a makefile, macros defined
# in a previous makefile (ie, sources, sources.inc, makefile.def)
# are not defined at this point unless they're defined on the command
# line.  This makefile assumes the LANGUAGE and ALT_PROJECT_TARGET macros
# defined in $(LANGUAGE)\sources.inc are passed to this invokation of nmake
# on the command line.
#

!if "$(PROCESSOR_ARCHITECTURE)" == "x86"
TARGET_DIRECTORY=i386
!elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
TARGET_DIRECTORY=alpha
!endif

PATH=$(PATH_TOOLS16);$(PATH)

#
# set the LANGUAGE info
#

!IFNDEF LANGUAGE
LANGUAGE=USA
!ENDIF

DEST=$(LANGUAGE)\$(_OBJ_DIR)\$(TARGET_DIRECTORY)

.SUFFIXES:
.SUFFIXES:  .asm .h

#
# nmake doesn't work properly if we try to stick the objects in obj, so put
# them in current dir for now. WHEN CHANGE OBJPATH TO BE OBJ, CHANGE clean TOO
#

ASM         = $(PATH_TOOLS16)\masm
LINK        = $(PATH_TOOLS16)\link16

#
# convert NTDEBUG into DEBUG flag. NTDEBUG can be not present or retail, either
# of which mean no debugging; or ntsd, cvp or sym, which means debugging support
# required
#

!IF "$(NTDEBUG)" == "ntsdnodbg"
DEBUGGING=0
!ELSE
DEBUGGING=1
!ENDIF

#
# assembler and linker debugging options
#

!IF $(DEBUGGING)
ASMDEBUG    =/DDEBUG=1 /Zi
LINKDEBUG   =/CO
!ELSE
ASMDEBUG    =/DDEBUG=0
LINKDEBUG   =
!ENDIF
ASMINC      =/I. /I..\..\inc /I..\inc\$(_OBJ_DIR)\$(TARGET_DIRECTORY) /I..\..\inc\$(LANGUAGE) /I$(SDK_INC16_PATH)
ASMFLAGS    =/Mx
LINKFLAGS   =/MAP /CP:1


#
# Inference rules - asm to obj, h to inc
#

.asm{$(DEST)\}.obj:
    @rem Setting the MASM env var keeps the masm command line below 128 chars
    set MASM=$(ASMINC) $(ASMDEBUG) $(USERDEFS)
    $(ASM) $<,$@;

.asm.lst:
    set MASM = $(ASMINC) $(ASMDEBUG) $(USERDEFS)
    $(ASM) /L $<;


#
# what it is we're building
#

TARGET      = $(DEST)\nw16.exe
MAPFILE     = $(TARGET:.exe=.map)
DEFFILE     = ;

OBJS        = $(DEST)\nw16.obj       \
              $(DEST)\resident.obj

LIBS        =

#
# how to build it
#

all:    makedir $(TARGET)


$(TARGET):  $(OBJS)
    $(LINK) @<<
$(OBJS)
$(TARGET) $(LINKFLAGS) $(LINKDEBUG)
$(MAPFILE)
$(LIBS)
$(DEFFILE)
<<


#
# where to put it
#
    if not exist $(DEST) md $(DEST)
    binplace -o $(ALT_PROJECT_TARGET) $(TARGET)
    binplace -o $(ALT_PROJECT_TARGET) $(MAPFILE)

#
# clean build - delete all objs
#

clean:  clean2

clean2:
    if exist $(DEST)\*.* del $(DEST)\*.*
    $(MAKE)

makedir:
    @-if not exist $(DEST) md $(DEST)


#
# file dependencies
#

$(DEST)\nw16.obj:          \
        nw16.asm                \
        debugmac.inc            \
        asmmacro.inc            \
        segorder.inc            \
        ..\inc\$(_OBJ_DIR)\$(TARGET_DIRECTORY)\nwdos.inc

$(DEST)\resident.obj:      \
        resident.asm            \
        segorder.inc            \
        debugmac.inc            \
        asmmacro.inc            \
        ..\inc\$(_OBJ_DIR)\$(TARGET_DIRECTORY)\nwdos.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nw16\tsr\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-98, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#***************************************************************************/

#
# By calling nmake from within nmake, we can avoid changing relative
# paths in the existing ..\makefile.inc.
#

nw16:
    cd..
    nmake /fmakefile.inc \
         ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
         LANGUAGE=$(LANGUAGE)
    cd $(LANGUAGE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\packstr.c ===
/*++

Copyright (c) 1992, 1993  Microsoft Corporation

Module Name:

    packstr.c

Abstract:

    Contains functions for packing strings into buffers that also contain
    structures.

Author:

    From LAN Manager netlib.
    Rita Wong     (ritaw)     2-Mar-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include <procs.h>


BOOL
NwlibCopyStringToBuffer(
    IN LPCWSTR SourceString OPTIONAL,
    IN DWORD   CharacterCount,
    IN LPCWSTR FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    )

/*++

Routine Description:

    This routine puts a single variable-length string into an output buffer.
    The string is not written if it would overwrite the last fixed structure
    in the buffer.

Arguments:

    SourceString - Supplies a pointer to the source string to copy into the
        output buffer.  If SourceString is null then a pointer to a zero terminator
        is inserted into output buffer.

    CharacterCount - Supplies the length of SourceString, not including zero
        terminator.  (This in units of characters - not bytes).

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the string written in the output buffer.

    VariableDataPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer to the variable data
        should be written.

Return Value:

    Returns TRUE if string fits into output buffer, FALSE otherwise.

--*/
{
    DWORD CharsNeeded = (CharacterCount + 1);


    //
    // Determine if source string will fit, allowing for a zero terminator.
    // If not, just set the pointer to NULL.
    //

    if ((*EndOfVariableData - CharsNeeded) >= FixedDataEnd) {

        //
        // It fits.  Move EndOfVariableData pointer up to the location where
        // we will write the string.
        //

        *EndOfVariableData -= CharsNeeded;

        //
        // Copy the string to the buffer if it is not null.
        //

        if (CharacterCount > 0 && SourceString != NULL) {

            (VOID) wcsncpy(*EndOfVariableData, SourceString, CharacterCount);
        }

        //
        // Set the zero terminator.
        //

        *(*EndOfVariableData + CharacterCount) = L'\0';

        //
        // Set up the pointer in the fixed data portion to point to where the
        // string is written.
        //

        *VariableDataPointer = *EndOfVariableData;

        return TRUE;

    }
    else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\nwcapi32.c ===
/*++

Copyright (C) 1993 Microsoft Corporation

Module Name:

      NWAPI32.C

Abstract:

      This module contains NetWare compatible APIs.  The NWC* functions
      are implemented as wrappers around NWP* or NW* functions.

Author:

      Chuck Y. Chan   (ChuckC)  06-Mar-1995

Revision History:

      ChuckC          Moved over from DSM to consolidate.
                                  
--*/

#include "procs.h"
 
//
// define define categories of errors
//
typedef enum _NCP_CLASS {
    NcpClassConnect,
    NcpClassBindery,
    NcpClassDir
} NCP_CLASS ;

extern NWCCODE 
MapNtStatus( 
    const NTSTATUS ntstatus,
    const NCP_CLASS ncpclass
);

extern DWORD 
SetWin32ErrorFromNtStatus(
    NTSTATUS NtStatus
) ;


//
// Function bodies
//


NWCCODE 
NWCAddTrusteeToDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWACCESS_RIGHTS         rightsMask
    )
{
    return (NWAddTrusteeToDirectory(
                            hConn,
                            dirHandle,
                            pszPath,
                            dwTrusteeID,
                            rightsMask)) ;
}

NWCCODE 
NWCAllocPermanentDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszDirPath,
    NWDIR_HANDLE            *pbNewDirHandle,
    NWACCESS_RIGHTS         *pbRightsMask
    )
{
    return (NWAllocPermanentDirectoryHandle(
                            hConn,
                            dirHandle,
                            pszDirPath,
                            pbNewDirHandle,
                            pbRightsMask)) ;
}

NWCCODE 
NWCAllocTemporaryDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszDirPath,
    NWDIR_HANDLE            *pbNewDirHandle,
    NWACCESS_RIGHTS         *pbRightsMask
    )
{
    return (NWAllocTemporaryDirectoryHandle(
                            hConn,
                            dirHandle,
                            pszDirPath,
                            pbNewDirHandle,
                            pbRightsMask)) ;
}

NWCCODE 
NWCAttachToFileServer(
    const char              *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    )
{
    return (NWAttachToFileServer(
                            pszServerName,
                            ScopeFlag,
                            phNewConn)) ;
}

NWCCODE 
NWCAttachToFileServerW(
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    )
{
    return (NWAttachToFileServerW(
                            pszServerName,
                            ScopeFlag,
                            phNewConn)) ;
}

NWCCODE 
NWCCheckConsolePrivileges(
    NWCONN_HANDLE           hConn
    )
{
    return(NWCheckConsolePrivileges(hConn)); 
}

NWCCODE 
NWCDeallocateDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle
    )
{
    return(NWDeallocateDirectoryHandle(
                            hConn,
                            dirHandle)) ;
}

NWCCODE 
NWCDetachFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    return(NWDetachFromFileServer(hConn)) ;
}

NWCCODE 
NWCGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO            *lpVerInfo
    )
{
    return(NWGetFileServerVersionInfo(
                            hConn,
                            lpVerInfo)) ;
}

NWCCODE 
NWCGetInternetAddress(
    NWCONN_HANDLE           hConn,
    NWCONN_NUM              nConnNum,
    NWNET_ADDR              *pIntAddr
    )
{
    return (NWGetInternetAddress(
                            hConn,
                            nConnNum,
                            pIntAddr)) ;
}

NWCCODE 
NWCGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char                    *pszObjName,
    NWOBJ_TYPE              *pwObjType )
{
    return(NWGetObjectName(
                            hConn,
                            dwObjectID,
                            pszObjName,
                            pwObjType )) ;
}


NWCCODE 
NWCGetVolumeInfoWithNumber(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               nVolNum,
    char                    *pszVolName,
    NWNUMBER                *pwTotalBlocks,
    NWNUMBER                *pwSectors,
    NWNUMBER                *pwAvailBlocks,
    NWNUMBER                *pwTotalDir,
    NWNUMBER                *pwAvailDir,
    NWVOL_FLAGS             *pfVolRemovable
    )
{
    return(NWGetVolumeInfoWithNumber(
                            hConn,
                            nVolNum,
                            pszVolName,
                            pwTotalBlocks,
                            pwSectors,
                            pwAvailBlocks,
                            pwTotalDir,
                            pwAvailDir,
                            pfVolRemovable)) ;
}

NWCCODE 
NWCGetVolumeInfoWithHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            nDirHand,
    char                    *pszVolName,
    NWNUMBER                *pwTotalBlocks,
    NWNUMBER                *pwSectors,
    NWNUMBER                *pwAvailBlocks,
    NWNUMBER                *pwTotalDir,
    NWNUMBER                *pwAvailDir,
    NWVOL_FLAGS             *pfVolRemovable
    )
{
    return(NWGetVolumeInfoWithHandle(
                            hConn,
                            nDirHand,
                            pszVolName,
                            pwTotalBlocks,
                            pwSectors,
                            pwAvailBlocks,
                            pwTotalDir,
                            pwAvailDir,
                            pfVolRemovable)) ;
}

NWCCODE 
NWCGetVolumeName(
    NWCONN_HANDLE       hConn,
    NWVOL_NUM           bVolNum,
    char                *pszVolName
    )
{
    return(NWGetVolumeName(
                        hConn,
                        bVolNum,
                        pszVolName)) ;
}

NWCCODE 
NWCIsObjectInSet(
    NWCONN_HANDLE           hConn,
    const char              *lpszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *lpszPropertyName,
    const char           	*lpszMemberName,
    NWOBJ_TYPE              wMemberType
	)
{
    return(NWIsObjectInSet(
	                        hConn,
	                        lpszObjectName,
	                        wObjType,
	                        lpszPropertyName,
                            lpszMemberName,
                            wMemberType)) ;
}


NWCCODE 
NWCLoginToFileServer(
    NWCONN_HANDLE           hConn,
    const char              *pszUserName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPassword
    )
{
    return(NWLoginToFileServer(
                            hConn,
                            pszUserName,
                            wObjType,
                            pszPassword)) ;
}

NWCCODE 
NWCLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    return(NWLogoutFromFileServer( hConn )) ;
}

NWCCODE 
NWCReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjName,
    NWOBJ_TYPE              wObjType,
    char                    *pszPropName,
    unsigned char           ucSegment,
    char                    *pValue,
    NWFLAGS                 *pucMoreFlag,
    NWFLAGS                 *pucPropFlag
    )
{
    return(NWReadPropertyValue(
                            hConn,
                            pszObjName,
                            wObjType,
                            pszPropName,
                            ucSegment,
                            pValue,
                            pucMoreFlag,
                            pucPropFlag)) ;
}

NWCCODE 
NWCScanObject(
    NWCONN_HANDLE           hConn,
    const char              *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID                *pdwObjectID,
    char                    *pszObjectName,
    NWOBJ_TYPE              *pwObjType,
    NWFLAGS                 *pucHasProperties,
    NWFLAGS                 *pucObjectFlags,
    NWFLAGS                 *pucObjSecurity
    )
{
    return(NWScanObject(
                            hConn,
                            pszSearchName,
                            wObjSearchType,
                            pdwObjectID,
                            pszObjectName,
                            pwObjType,
                            pucHasProperties,
                            pucObjectFlags,
                            pucObjSecurity)) ;
}

NWCCODE 
NWCScanProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char                    *pszSearchName,
    NWOBJ_ID                *pdwSequence,
    char                    *pszPropName,
    NWFLAGS                 *pucPropFlags,
    NWFLAGS                 *pucPropSecurity,
    NWFLAGS                 *pucHasValue,
    NWFLAGS                 *pucMore
    )
{
    return( NWScanProperty(
                            hConn,
                            pszObjectName,
                            wObjType,
                            pszSearchName,
                            pdwSequence,
                            pszPropName,
                            pucPropFlags,
                            pucPropSecurity,
                            pucHasValue,
                            pucMore)) ;
}

NWCCODE 
NWCGetFileServerDateAndTime(
    NWCONN_HANDLE           hConn,
    BYTE                    *year,
    BYTE                    *month,
    BYTE                    *day,
    BYTE                    *hour,
    BYTE                    *minute,
    BYTE                    *second,
    BYTE                    *dayofweek
    )
{
    return( NWGetFileServerDateAndTime( 
                            hConn,
                            year,
                            month,
                            day,
                            hour,
                            minute,
                            second,
                            dayofweek ));
}


NWCCODE 
NWCAddTrustee(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWRIGHTS_MASK           rightsMask
    )
{
    NTSTATUS NtStatus;

    NtStatus = NWPAddTrustee(
                   hConn,
                   dirHandle,
                   pszPath,
                   dwTrusteeID,
                   rightsMask 
                   );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;

    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE 
NWCDeleteObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType
    )
{
    NTSTATUS NtStatus;

    NtStatus = NWPDeleteObject( hConn,
                                pszObjectName,
                                wObjType );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;

    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCCreateObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    )
{
    NTSTATUS           NtStatus ;

    NtStatus = NWPCreateObject( hConn,
                                pszObjectName,
                                wObjType,
                                ucObjectFlags,
                                ucObjSecurity );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;

    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCCreateProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    )
{
    NTSTATUS           NtStatus ;

    NtStatus = NWPCreateProperty( hConn,
                                  pszObjectName,
                                  wObjType,
                                  pszPropertyName,
                                  ucObjectFlags,
                                  ucObjSecurity );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCDeleteProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName
    )
{
    NTSTATUS           NtStatus ;

    NtStatus = NWPDeleteProperty( hConn,
                                  pszObjectName,
                                  wObjType,
                                  pszPropertyName );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCWritePropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWSEGMENT_NUM           segmentNumber,
    NWSEGMENT_DATA          *segmentData,
    NWFLAGS                 moreSegments
    )
{
    NTSTATUS           NtStatus ;

    NtStatus = NWPWritePropertyValue( hConn,
                                      pszObjectName,
                                      wObjType,
                                      pszPropertyName,
                                      segmentNumber,
                                      segmentData,
                                      moreSegments );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCGetObjectID(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWOBJ_ID                *objectID
    )
{
    NTSTATUS           NtStatus ;
  
    NtStatus = NWPGetObjectID( hConn,
                               pszObjectName,
                               wObjType,
                               objectID );


    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCRenameBinderyObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    const char              *pszNewObjectName,
    NWOBJ_TYPE              wObjType 
    )
{
    NTSTATUS NtStatus;

    NtStatus = NWPRenameBinderyObject( 
                   hConn,
                   pszObjectName,
                   pszNewObjectName,
                   wObjType
                   );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCAddObjectToSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    )
{
    NTSTATUS           NtStatus ;
  
    NtStatus = NWPAddObjectToSet( hConn,
                                  pszObjectName,
                                  wObjType,
                                  pszPropertyName,
                                  pszMemberName,
                                  memberType );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCDeleteObjectFromSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    )
{
    NTSTATUS           NtStatus ;
  
    NtStatus = NWPDeleteObjectFromSet( hConn,
                                       pszObjectName,
                                       wObjType,
                                       pszPropertyName,
                                       pszMemberName,
                                       memberType );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE 
NWCCreateDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWACCESS_RIGHTS         accessMask 
    )
{
    NTSTATUS    NtStatus;

    NtStatus = NWPCreateDirectory(
                    hConn,
                    dirHandle,
                    pszPath,
                    accessMask 
                    );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}


NWCCODE
NWCScanForTrustees(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    BYTE                    *numberOfEntries,
    TRUSTEE_INFO            *ti
    )
{
    NTSTATUS    NtStatus;

    NtStatus =  NWPScanForTrustees(
                            hConn,
                            dirHandle,
                            pszsearchDirPath,
                            pucsequenceNumber,
                            numberOfEntries,
                            ti
                            ) ;

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
} 


NWCCODE
NWCScanDirectoryForTrustees2(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    char                    *pszdirName,
    NWDATE_TIME             *dirDateTime,
    NWOBJ_ID                *ownerID,
    TRUSTEE_INFO            *ti
    )
{
    NTSTATUS    NtStatus;

    NtStatus =  NWPScanDirectoryForTrustees2(
                            hConn,
                            dirHandle,
                            pszsearchDirPath,
                            pucsequenceNumber,
                            pszdirName,
                            dirDateTime,
                            ownerID,
                            ti
                            );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
} 


NWCCODE
NWCGetBinderyAccessLevel(
    NWCONN_HANDLE           hConn,
    NWFLAGS                 *accessLevel,
    NWOBJ_ID                *objectID
    )
{
    NTSTATUS    NtStatus;

    NtStatus =  NWPGetBinderyAccessLevel(
                            hConn,
                            accessLevel,
                            objectID
                            );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE
NWCGetFileServerDescription(
    NWCONN_HANDLE           hConn,
    char                    *pszCompany,
    char                    *pszVersion,
    char                    *pszRevision
    )
{
    NTSTATUS   NtStatus ;

    NtStatus = NWPGetFileServerDescription(
                            hConn,
                            pszCompany,
                            pszVersion,
                            pszRevision
                            );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE
NWCGetVolumeNumber(
    NWCONN_HANDLE           hConn,
    char                    *pszVolume,
    NWVOL_NUM               *VolumeNumber
    )
{
    NTSTATUS   NtStatus ;

    NtStatus = NWPGetVolumeNumber(
                            hConn,
                            pszVolume,
                            VolumeNumber
                            );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE
NWCGetVolumeUsage(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               VolumeNumber,
    DWORD                   *TotalBlocks,
    DWORD                   *FreeBlocks,
    DWORD                   *PurgeableBlocks,
    DWORD                   *NotYetPurgeableBlocks,
    DWORD                   *TotalDirectoryEntries,
    DWORD                   *AvailableDirectoryEntries,
    BYTE                    *SectorsPerBlock
    )
{
    NTSTATUS   NtStatus ;

    NtStatus = NWPGetVolumeUsage( 
                            hConn,
                            VolumeNumber,
                            TotalBlocks,
                            FreeBlocks,
                            PurgeableBlocks,
                            NotYetPurgeableBlocks,
                            TotalDirectoryEntries,
                            AvailableDirectoryEntries,
                            SectorsPerBlock
                            );

    (void) SetWin32ErrorFromNtStatus(NtStatus) ;
    
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE
NWCCreateQueue(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char    NWFAR     *pszQueueName,
    NWOBJ_TYPE              wQueueType,
    const char    NWFAR     *pszPathName,
    NWOBJ_ID      NWFAR     *pdwQueueId
    )
{
    return (NWCreateQueue(
                     hConn,
                     dirHandle,
                     pszQueueName,
                     wQueueType,
                     pszPathName,
                     pdwQueueId
                     ));
}

NWCCODE
NWCChangePropertySecurity(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    const char      NWFAR   *pszPropertyName,
    NWFLAGS                 ucObjSecurity
    )
{
    return (NWChangePropertySecurity(
                            hConn,
                            pszObjName,
                            wObjType,
                            pszPropertyName,
                            ucObjSecurity
                            ));
}

NWCCODE
NWCDestroyQueue(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwQueueId
    )
{
    return (NWDestroyQueue(
                       hConn,
                       dwQueueId
                       ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\nwapi32.c ===
/*++

Copyright (C) 1993 Microsoft Corporation

Module Name:

      NWAPI32.C

Abstract:

      This module contains the NetWare(R) SDK support to routines
      into the NetWare redirector

Author:

      Chris Sandys    (a-chrisa)  09-Sep-1993

Revision History:

      Chuck Y. Chan (chuckc)   02/06/94  Moved to NWCS. Make it more NT like.
      Chuck Y. Chan (chuckc)   02/27/94  Clear out old code.
                                         Make logout work.
                                         Check for error in many places.
                                         Dont hard code strings.
                                         Remove non compatible parameters.
                                         Lotsa other cleanup.
      Tommy R. Evans (tommye)  04/21/00  Added two routines:
                                            NwNdsObjectHandleToConnHandle()
                                            NwNdsConnHandleFree()
                                            
--*/

#include "procs.h"
#include "nwapi32.h"
#include <nds32.h>
#include <stdio.h>
 
//
// Define structure for internal use. Our handle passed back from attach to
// file server will be pointer to this. We keep server string around for
// discnnecting from the server on logout. The structure is freed on detach.
// Callers should not use this structure but treat pointer as opaque handle.
//
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;

//
// define define categories of errors
//
typedef enum _NCP_CLASS {
    NcpClassConnect,
    NcpClassBindery,
    NcpClassDir
} NCP_CLASS ;

//
// define error mapping structure
//
typedef struct _NTSTATUS_TO_NCP {
    NTSTATUS NtStatus ;
    NWCCODE  NcpCode  ;
} NTSTATUS_TO_NCP, *LPNTSTATUS_TO_NCP ;
    
//
// Error mappings for directory errors
//
NTSTATUS_TO_NCP MapNcpDirErrors[] = 
{
    {STATUS_NO_SUCH_DEVICE,                VOLUME_DOES_NOT_EXIST},
    {STATUS_INVALID_HANDLE,                BAD_DIRECTORY_HANDLE},
    {STATUS_OBJECT_PATH_NOT_FOUND,         INVALID_PATH},
    {STATUS_UNSUCCESSFUL,                  INVALID_PATH},
    {STATUS_NO_MORE_ENTRIES,               NO_SUCH_OBJECT},
    {STATUS_ACCESS_DENIED,                 NO_OBJECT_READ_PRIVILEGE},
    {STATUS_INSUFF_SERVER_RESOURCES,       SERVER_OUT_OF_MEMORY},
    { 0,                                   0 }
} ;

//
// Error mappings for connect errors
//
NTSTATUS_TO_NCP MapNcpConnectErrors[] = 
{
    {STATUS_UNSUCCESSFUL,                  INVALID_CONNECTION},
    {STATUS_ACCESS_DENIED,                 NO_OBJECT_READ_PRIVILEGE},
    {STATUS_NO_MORE_ENTRIES,               UNKNOWN_FILE_SERVER},
    {STATUS_INSUFF_SERVER_RESOURCES,       SERVER_OUT_OF_MEMORY},
    { 0,                                   0 }
} ;

//
// Error mappings for bindery errors
//
NTSTATUS_TO_NCP MapNcpBinderyErrors[] = 
{
    {STATUS_ACCESS_DENIED,                 NO_OBJECT_READ_PRIVILEGE},
    {STATUS_NO_MORE_ENTRIES,               UNKNOWN_FILE_SERVER},
    {STATUS_NO_MORE_ENTRIES,               NO_SUCH_OBJECT},
    {STATUS_INVALID_PARAMETER,             NO_SUCH_PROPERTY},
    {STATUS_UNSUCCESSFUL,                  INVALID_CONNECTION},
    {STATUS_INSUFF_SERVER_RESOURCES,       SERVER_OUT_OF_MEMORY},
    {STATUS_NO_SUCH_DEVICE,                VOLUME_DOES_NOT_EXIST},
    {STATUS_INVALID_HANDLE,                BAD_DIRECTORY_HANDLE},
    {STATUS_OBJECT_PATH_NOT_FOUND,         INVALID_PATH},
    // {0xC0010001,                           INVALID_CONNECTION},
    // {0xC0010096,                           SERVER_OUT_OF_MEMORY},
    // {0xC0010098,                           VOLUME_DOES_NOT_EXIST},
    // {0xC001009B,                           BAD_DIRECTORY_HANDLE},
    // {0xC001009C,                           INVALID_PATH},
    // {0xC00100FB,                           NO_SUCH_PROPERTY},
    // {0xC00100FC,                           NO_SUCH_OBJECT},
    { 0,                                   0 }
} ;


//
// Forwards
//
DWORD 
CancelAllConnections(
      LPWSTR    pszServer
);


NWCCODE 
MapNtStatus( 
    const NTSTATUS ntstatus,
    const NCP_CLASS ncpclass
);

DWORD 
SetWin32ErrorFromNtStatus(
    NTSTATUS NtStatus
) ;

DWORD
szToWide( 
    LPWSTR lpszW, 
    LPCSTR lpszC, 
    INT nSize 
);

//
// Static functions used internally
//

LPSTR
NwDupStringA(
    const LPSTR       lpszA,
    WORD              length
)
{
    LPSTR lpRet;

    //
    // Allocate memory
    //
    lpRet = LocalAlloc( LMEM_FIXED|LMEM_ZEROINIT , length );

    if(lpRet == NULL) return(NULL);

    //
    // Dupulicate string
    //
    memcpy( (LPVOID)lpRet, (LPVOID)lpszA, length );

    return(lpRet);
}


VOID
MapSpecialJapaneseChars(
    LPSTR       lpszA,
    WORD        length
)
{
    LCID lcid;
//
// Netware Japanese version The following character is replaced with another one
// if the string is for File Name only when sendding from Client to Server.
//
// any char, even DBCS trailByte. 
//
//  SJIS+0xBF     -> 0x10
//  SJIS+0xAE     -> 0x11
//  SJIS+0xAA     -> 0x12
//
// DBCS TrailByte only.
//
//  SJIS+0x5C     -> 0x13
//

// Get system locale and language ID in Kernel mode in order to  
// distinguish the currently running system.

    NtQueryDefaultLocale( TRUE, &lcid );

    if (! (PRIMARYLANGID(lcid) == LANG_JAPANESE ||
           PRIMARYLANGID(lcid) == LANG_KOREAN ||
           PRIMARYLANGID(lcid) == LANG_CHINESE) ) {

            return;
    }

    if(lpszA == NULL)
        return;

    if( PRIMARYLANGID(lcid) == LANG_JAPANESE ) {

            while( length ) {

                if( IsDBCSLeadByte(*lpszA) && (length >= 2) ) {

                        //  Adding length>=2 ensure the Lead Byte is followed by
                        //  a trail byte , Fix bug #102729
                        //
                        // This is a DBCS character, check trailbyte is 0x5C or not.
                        //

                        lpszA++;
                        length--;
                        if( *lpszA == 0x5C ) {
                            *lpszA = (UCHAR)0x13;
                        }

                }

                switch( (UCHAR) *lpszA ) {
                    case 0xBF :
                        *lpszA = (UCHAR)0x10;
                        break;
                    case 0xAE :
                        *lpszA = (UCHAR)0x11;
                        break;
                    case 0xAA :
                        *lpszA = (UCHAR)0x12;
                        break;
                }

                //
                // next char
                //
                lpszA++;
                length--;
            }
    }
    else if (PRIMARYLANGID(lcid) == LANG_CHINESE ||
             PRIMARYLANGID(lcid) == LANG_KOREAN) {

            while( length ) {
                if( IsDBCSLeadByte(*lpszA) && *(lpszA+1) == 0x5C ) {
                        *(lpszA+1) = (UCHAR)0x13;
                }

                switch( (UCHAR) *lpszA ) {

                    case 0xBF :
                        *lpszA = (UCHAR)0x10;
                        break;

                    case 0xAE :
                        *lpszA = (UCHAR)0x11;
                        break;

                    case 0xAA :
                        *lpszA = (UCHAR)0x12;
                        break;
                }

                //
                // next char
                //
                lpszA++;
                length--;
            }
    }
}

VOID
UnmapSpecialJapaneseChars(
    LPSTR       lpszA,
    WORD        length
)
{
    LCID lcid;

    //
    // Get system locale and language ID in Kernel mode in order to  
    // distinguish the currently running system.
    //

    NtQueryDefaultLocale( TRUE, &lcid );

    if (! (PRIMARYLANGID(lcid) == LANG_JAPANESE ||
           PRIMARYLANGID(lcid) == LANG_KOREAN ||
           PRIMARYLANGID(lcid) == LANG_CHINESE) ) {

            return;
    }

    if (lpszA == NULL)
        return;

    if( PRIMARYLANGID(lcid) == LANG_JAPANESE ) {
            while( length ) {
                if( IsDBCSLeadByte(*lpszA) && (length >= 2) ) {
                        //  Adding length>=2 ensure the Lead Byte is followed by  
                        //  a trail byte , Fix bug #102729
                        //
                        // This is a DBCS character, check trailbyte is 0x5C or not.
                        //
                        lpszA++;
                        length--;
                        if( *lpszA == 0x13 ) {
                            *lpszA = (UCHAR)0x5C;
                        }
                }

                switch( (UCHAR) *lpszA ) {
                    case 0x10 :
                        *lpszA = (UCHAR)0xBF;
                        break;
                    case 0x11 :
                        *lpszA = (UCHAR)0xAE;
                        break;
                    case 0x12 :
                        *lpszA = (UCHAR)0xAA;
                        break;
                }
                //
                // next char
                //
                lpszA++;
                length--;
            }
    }
    else if (PRIMARYLANGID(lcid) == LANG_CHINESE ||
             PRIMARYLANGID(lcid) == LANG_KOREAN) {

            while( length ) {
                switch( (UCHAR) *lpszA ) {
                    case 0x10 :
                        *lpszA = (UCHAR)0xBF;
                        break;
                    case 0x11 :
                        *lpszA = (UCHAR)0xAE;
                        break;
                    case 0x12 :
                        *lpszA = (UCHAR)0xAA;
                        break;
                }
                // have to check after restoring leadbyte values
                if( IsDBCSLeadByte(*lpszA) && *(lpszA+1) == 0x13 ) {
                        *(lpszA+1) = (UCHAR)0x5C;
                }
                //
                // next char
                //
                lpszA++;
                length--;
            }
    }
}

DWORD
szToWide( 
    LPWSTR lpszW, 
    LPCSTR lpszC, 
    INT nSize 
    )
{
    if (!MultiByteToWideChar(CP_ACP,
                             MB_PRECOMPOSED,
                             lpszC,
                             -1,
                             lpszW,
                             nSize))
    {
        return (GetLastError()) ;
    }
    
    return NO_ERROR ;
}


NWCCODE 
MapNtStatus( 
    const NTSTATUS ntstatus,
    const NCP_CLASS ncpclass
    )
{
    LPNTSTATUS_TO_NCP pErrorMap ;

    if (ntstatus == STATUS_SUCCESS)
        return SUCCESSFUL ;

    switch ( ncpclass ) {
        case NcpClassBindery: 
            pErrorMap = MapNcpBinderyErrors ; 
            break ;
        case NcpClassDir: 
            pErrorMap = MapNcpDirErrors ; 
            break ;
        case NcpClassConnect: 
            pErrorMap = MapNcpConnectErrors ; 
            break ;
        default:                      
            return 0xFFFF ;        
    }

    while (pErrorMap->NtStatus)
    {
        if (pErrorMap->NtStatus == ntstatus)
            return (pErrorMap->NcpCode) ;

        pErrorMap++ ;
    }

    return 0xFFFF ;
}

DWORD 
SetWin32ErrorFromNtStatus(
    NTSTATUS NtStatus
) 
{
    DWORD Status ;

    if (NtStatus & 0xC0010000) {            // netware specific
 
        Status = ERROR_EXTENDED_ERROR ;

    } else if (NtStatus == NWRDR_PASSWORD_HAS_EXPIRED) {

        Status = 0 ;  // note this is not an error (the operation suceeded!)

    } else {

        Status = RtlNtStatusToDosError(NtStatus) ;

    }

    SetLastError(Status) ;

    return Status ;
}

//
//  FormatString - Supplies an ANSI string which describes how to
//     convert from the input arguments into NCP request fields, and
//     from the NCP response fields into the output arguments.
//
//       Field types, request/response:
//
//          'b'      byte              ( byte   /  byte* )
//          'w'      hi-lo word        ( word   /  word* )
//          'd'      hi-lo dword       ( dword  /  dword* )
//          '-'      zero/skip byte    ( void )
//          '='      zero/skip word    ( void )
//          ._.      zero/skip string  ( word )
//          'p'      pstring           ( char* )
//          'P'      DBCS pstring      ( char* )
//          'c'      cstring           ( char* )
//          'C'      cstring followed skip word ( char*, word ) 
//          'r'      raw bytes         ( byte*, word )
//          'R'      DBCS raw bytes    ( byte*, word )
//          'u'      p unicode string  ( UNICODE_STRING * )
//          'U'      p uppercase string( UNICODE_STRING * )
//          'W'      word n followed by an array of word[n] ( word, word* )
//
//
//
//
// Standard NCP Function Block
//
//
//    NWCCODE NWAPI DLLEXPORT
//    NW***(
//        NWCONN_HANDLE           hConn,
//        )
//    {
//        NWCCODE NcpCode;
//        NTSTATUS NtStatus;
//    
//        NtStatus = NwlibMakeNcp(
//                        hConn,                  // Connection Handle
//                        FSCTL_NWR_NCP_E3H,      // Bindery function
//                        ,                       // Max request packet size
//                        ,                       // Max response packet size
//                        "b|",                   // Format string
//                        // === REQUEST ================================
//                        0x,                     // b Function
//                        // === REPLY ==================================
//                        );
//    
//        return MapNtStatus( NtStatus, NcpClassXXX );
//    }
//    
//    

NWCCODE NWAPI DLLEXPORT
NWAddTrusteeToDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char      NWFAR   *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWACCESS_RIGHTS         rightsMask
    )
{
    unsigned short     reply;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Directory function
                    265,                    // Max request packet size
                    2,                      // Max response packet size
                    "bbrbP|",               // Format string
                    // === REQUEST ================================
                    0x0d,                   // b Add trustee to directory
                    dirHandle,              // b 0xffffffff to start or last returned ID when enumerating  HI-LO
                    &dwTrusteeID,DW_SIZE,   // r Object ID to assigned to directory
                    rightsMask,             // b User rights for directory
                    pszPath,                // P Directory (if dirHandle = 0 then vol:directory)
                    // === REPLY ==================================
                    &reply                  // Not used
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );

}
NWCCODE NWAPI DLLEXPORT
NWAllocPermanentDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char            NWFAR   *pszDirPath,
    NWDIR_HANDLE    NWFAR   *pbNewDirHandle,
    NWACCESS_RIGHTS NWFAR   *pbRightsMask
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // E2 Function function
                    261,                    // Max request packet size
                    4,                      // Max response packet size
                    "bbbP|bb",              // Format string
                    // === REQUEST ================================
                    0x12,                   // b Function Alloc Perm Dir
                    dirHandle,              // b 0 for new
                    0,                      // b Drive Letter
                    pszDirPath,             // P Volume Name (SYS: or SYS:\PUBLIC)
                    // === REPLY ==================================
                    pbNewDirHandle,         // b Dir Handle
                    pbRightsMask            // b Rights
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE NWAPI DLLEXPORT
NWAllocTemporaryDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char            NWFAR   *pszDirPath,
    NWDIR_HANDLE    NWFAR   *pbNewDirHandle,
    NWACCESS_RIGHTS NWFAR   *pbRightsMask
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // E2 Function function
                    261,                    // Max request packet size
                    4,                      // Max response packet size
                    "bbbP|bb",              // Format string
                    // === REQUEST ================================
                    0x13,                   // b Function Alloc Temp Dir
                    dirHandle,              // b 0 for new
                    0,                      // b Drive Letter
                    pszDirPath,             // P Volume Name (SYS: or SYS:\PUBLIC)
                    // === REPLY ==================================
                    pbNewDirHandle,         // b Dir Handle
                    pbRightsMask            // b Rights
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE NWAPI DLLEXPORT
NWCheckConsolePrivileges(
    NWCONN_HANDLE           hConn
    )
{
    WORD               wDummy;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    2,                      // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0xC8,                   // b Get Console Privilges
                    // === REPLY ==================================
                    &wDummy,W_SIZE          // r Dummy Response
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );     
}

NWCCODE NWAPI DLLEXPORT
NWDeallocateDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle
    )
{
    WORD               wDummy;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // E2 Function function
                    4,                      // Max request packet size
                    2,                      // Max response packet size
                    "bb|w",                 // Format string
                    // === REQUEST ================================
                    0x14,                   // b Function Dealloc Dir Hand
                    dirHandle,              // b 0 for new
                    // === REPLY ==================================
                    &wDummy
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE NWAPI DLLEXPORT
NWGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO    NWFAR   *lpVerInfo
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    130,                    // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0x11,                   // b Get File Server Information
                    // === REPLY ==================================
                    lpVerInfo,              // r File Version Structure
                    sizeof(VERSION_INFO)
                    );

    // Convert HI-LO words to LO-HI
    // ===========================================================
    lpVerInfo->ConnsSupported = wSWAP( lpVerInfo->ConnsSupported );
    lpVerInfo->connsInUse     = wSWAP( lpVerInfo->connsInUse );
    lpVerInfo->maxVolumes     = wSWAP( lpVerInfo->maxVolumes );
    lpVerInfo->PeakConns      = wSWAP( lpVerInfo->PeakConns );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWGetInternetAddress(
    NWCONN_HANDLE           hConn,
    NWCONN_NUM              nConnNum,
    NWNET_ADDR      NWFAR   *pIntAddr
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    4,                      // Max request packet size
                    14,                     // Max response packet size
                    "bb|r",                 // Format string
                    // === REQUEST ================================
                    0x13,                   // b Get Internet Address
                    nConnNum,               // b Connection Number
                    // === REPLY ==================================
                    pIntAddr,12             // r File Version Structure
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}


NWCCODE NWAPI DLLEXPORT
NWGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char            NWFAR   *pszObjName,
    NWOBJ_TYPE      NWFAR   *pwObjType )
{
    NWOBJ_ID           dwRetID;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 


    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    7,                      // Max request packet size
                    56,                     // Max response packet size
                    "br|rrR",               // Format string
                    // === REQUEST ================================
                    0x36,                   // b Get Bindery Object Name
                    &dwObjectID,DW_SIZE,    // r Object ID    HI-LO
                    // === REPLY ==================================
                    &dwRetID,DW_SIZE,       // r Object ID HI-LO
                    pwObjType,W_SIZE,       // r Object Type
                    pszObjName,48           // R Object Name
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}

// This function not supported  (E3 E9)
NWCCODE NWAPI DLLEXPORT
NWGetVolumeInfoWithNumber(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               nVolNum,
    char        NWFAR       *pszVolName,
    NWNUMBER    NWFAR       *pwTotalBlocks,
    NWNUMBER    NWFAR       *pwSectors,
    NWNUMBER    NWFAR       *pwAvailBlocks,
    NWNUMBER    NWFAR       *pwTotalDir,
    NWNUMBER    NWFAR       *pwAvailDir,
    NWVOL_FLAGS NWFAR       *pfVolRemovable
    )
{
    WORD        wTime;                 // w Elapsed Time
    BYTE        bVoln;                 // b Vol Num
    BYTE        bDriven;               // b Drive Num
    WORD        wStartBlock;           // w Starting Block
    WORD        wMaxUsedDir;           // w Actual Max Used Directory Entries
    BYTE        bVolHashed;            // b Volume is hashed
    BYTE        bVolCached;            // b Volume is Cached
    BYTE        bVolMounted;           // b Volume is mounted

    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    4,                      // Max request packet size
                    42,                     // Max response packet size
                    "bb|wbbwwwwwwwbbbbr",   // Format string
                    // === REQUEST ================================
                    0xe9,                   // b Get Volume Information
                    nVolNum,                // b Volume Number (0 to Max Vol)
                    // === REPLY ==================================
                    &wTime,                 // w Elapsed Time
                    &bVoln,                 // b Vol Num
                    &bDriven,               // b Drive Num
                    pwSectors,              // w Sectors per block
                    &wStartBlock,           // w Starting Block
                    pwTotalBlocks,          // w Total Blocks
                    pwAvailBlocks,          // w Available Blocks (free)
                    pwTotalDir,             // w Total Dir Slots
                    pwAvailDir,             // w Available Directory Slots
                    &wMaxUsedDir,           // w Actual Max Used Directory Entries
                    &bVolHashed,            // b Volume is hashed
                    &bVolCached,            // b Volume is Cached
                    pfVolRemovable,         // b Volume is removable
                    &bVolMounted,           // b Volume is mounted
                    pszVolName,16           // r Volume Name
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWGetVolumeInfoWithHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            nDirHand,
    char        NWFAR       *pszVolName,
    NWNUMBER    NWFAR       *pwTotalBlocks,
    NWNUMBER    NWFAR       *pwSectors,
    NWNUMBER    NWFAR       *pwAvailBlocks,
    NWNUMBER    NWFAR       *pwTotalDir,
    NWNUMBER    NWFAR       *pwAvailDir,
    NWVOL_FLAGS NWFAR       *pfVolRemovable
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    4,                      // Max request packet size
                    30,                     // Max response packet size
                    "bb|wwwwwrb",           // Format string
                    // === REQUEST ================================
                    0x15,                   // b Get Volume Information
                    nDirHand,               // b Dir Handle
                    // === REPLY ==================================
                    pwSectors,              // w Sectors per block
                    pwTotalBlocks,          // w Total Blocks
                    pwAvailBlocks,          // w Available Blocks (free)
                    pwTotalDir,             // w Total Dir Slots
                    pwAvailDir,             // w Available Directory Slots
                    pszVolName,16,          // r Volume Name
                    pfVolRemovable          // b Volume is removable
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE NWAPI DLLEXPORT
NWGetVolumeName(
    NWCONN_HANDLE       hConn,
    NWVOL_NUM           bVolNum,
    char        NWFAR   *pszVolName
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Directory Services
                    4,                      // Max request packet size
                    19,                     // Max response packet size
                    "bb|p",                 // Format string
                    // === REQUEST ================================
                    0x06,                   // Get Volume Name
                    bVolNum,                // Volume Number
                    // === REPLY ==================================
                    pszVolName             // Return Volume name
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassDir );
}

NWCCODE NWAPI DLLEXPORT
NWIsObjectInSet(
        NWCONN_HANDLE           hConn,
        const char      NWFAR   *lpszObjectName,
        NWOBJ_TYPE              wObjType,
        const char      NWFAR   *lpszPropertyName,
        const char              NWFAR   *lpszMemberName,
        NWOBJ_TYPE                              wMemberType
        )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 
        WORD               Dummy;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,   // Connection Handle
                    FSCTL_NWR_NCP_E3H,    // Bindery function
                    122,                  // Max request packet size
                    2,                    // Max response packet size
                    "brPPrP|",            // Format string
                    // === REQUEST ================================
                    0x43,                 // b Read Property Value
                    &wObjType,W_SIZE,     // r OT_???  HI-LO
                    lpszObjectName,       // P Object Name
                    lpszPropertyName,     // P Prop Name
                    &wMemberType,W_SIZE,  // r Member Type
                    lpszMemberName,       // P Member Name
                    // === REPLY ==================================
                    &Dummy,W_SIZE
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );

} // NWIsObjectInSet

NWCCODE NWAPI DLLEXPORT
NWLoginToFileServer(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszUserName,
    NWOBJ_TYPE              wObType,
    const char      NWFAR   *pszPassword
    )
{
    NETRESOURCEW       NetResource;
    DWORD              dwRes, dwSize;
    NWCCODE            nwRes;
    LPWSTR             pszUserNameW = NULL, 
                       pszPasswordW = NULL;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    //
    // validate parameters
    //
    if (!hConn || !pszUserName || !pszPassword)
        return INVALID_CONNECTION ;

    //
    // allocate memory for unicode strings and convert ANSI input
    // to Unicode.
    //
    dwSize = strlen(pszUserName)+1 ;
    if (!(pszUserNameW = (LPWSTR)LocalAlloc(
                                       LPTR, 
                                       dwSize * sizeof(WCHAR))))
    {
        nwRes = REQUESTER_ERROR ;
        goto ExitPoint ; 
    }
    if (szToWide( pszUserNameW, pszUserName, dwSize ) != NO_ERROR)
    {
        nwRes = REQUESTER_ERROR ;
        goto ExitPoint ; 
    }

    dwSize = strlen(pszPassword)+1 ;
    if (!(pszPasswordW = (LPWSTR)LocalAlloc(
                                       LPTR, 
                                       dwSize * sizeof(WCHAR))))
    {
        nwRes = REQUESTER_ERROR ;
        goto ExitPoint ; 
    }
    
    if (szToWide( pszPasswordW, pszPassword, dwSize ) != NO_ERROR)
    {
        nwRes = REQUESTER_ERROR ;
        goto ExitPoint ; 
    }

    NetResource.dwScope      = 0 ;
    NetResource.dwUsage      = 0 ;
    NetResource.dwType       = RESOURCETYPE_ANY;
    NetResource.lpLocalName  = NULL;
    NetResource.lpRemoteName = (LPWSTR) pServerInfo->ServerString.Buffer;
    NetResource.lpComment    = NULL;
    NetResource.lpProvider   = NULL ;

    //
    // make the connection 
    //
    dwRes=NPAddConnection ( &NetResource, 
                            pszPasswordW, 
                            pszUserNameW );

    if( NO_ERROR != dwRes ) {
        dwRes = GetLastError();
        switch( dwRes ) {
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                nwRes = SUCCESSFUL;
                break;
            case ERROR_ALREADY_ASSIGNED:
                nwRes = ALREADY_ATTACHED;
                break;
            case ERROR_ACCESS_DENIED:
            case ERROR_BAD_DEV_TYPE:
            case ERROR_BAD_DEVICE:
            case ERROR_BAD_NET_NAME:
            case ERROR_BAD_PROFILE:
            case ERROR_CANNOT_OPEN_PROFILE:
            case ERROR_DEVICE_ALREADY_REMEMBERED:
            case ERROR_EXTENDED_ERROR:
            case ERROR_INVALID_PASSWORD:
            case ERROR_NO_NET_OR_BAD_PATH:
            case ERROR_NO_NETWORK:
                nwRes = INVALID_CONNECTION;
                break;
            default:
                nwRes = INVALID_CONNECTION;
                break;
        }
    } else {
        nwRes = SUCCESSFUL;
    }

ExitPoint: 

    if (pszUserNameW)
        (void) LocalFree((HLOCAL) pszUserNameW) ;
    if (pszPasswordW)
        (void) LocalFree((HLOCAL) pszPasswordW) ;

    return( nwRes );
}

NWCCODE NWAPI DLLEXPORT
NWLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    DWORD              dwRes;
    NWCCODE            nwRes;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    //
    // cancel all explicit connections to that server
    //
    (void) CancelAllConnections ( pServerInfo->ServerString.Buffer );

    //
    // now cancel the any connection to \\servername.
    //
    dwRes=NPCancelConnection( pServerInfo->ServerString.Buffer, TRUE );

    if( NO_ERROR != dwRes ) {
        dwRes = GetLastError();
        switch( dwRes ) 
        {
            case ERROR_NOT_CONNECTED:
            case ERROR_INVALID_HANDLE:
                nwRes = SUCCESSFUL;
                break;

            case ERROR_BAD_PROFILE:
            case ERROR_CANNOT_OPEN_PROFILE:
            case ERROR_DEVICE_IN_USE:
            case ERROR_EXTENDED_ERROR:
                nwRes = INVALID_CONNECTION;
                break;
            default:
                nwRes = INVALID_CONNECTION;
                break;
        }
    } else {
        nwRes = SUCCESSFUL;
    }

    return( nwRes );
}

NWCCODE NWAPI DLLEXPORT
NWReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    char            NWFAR   *pszPropName,
    unsigned char           ucSegment,
    char            NWFAR   *pValue,
    NWFLAGS         NWFAR   *pucMoreFlag,
    NWFLAGS         NWFAR   *pucPropFlag
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    70,                     // Max request packet size
                    132,                    // Max response packet size
                    "brPbP|rbb",            // Format string
                    // === REQUEST ================================
                    0x3D,                   // b Read Property Value
                    &wObjType,W_SIZE,       // r Object Type    HI-LO
                    pszObjName,             // P Object Name
                    ucSegment,              // b Segment Number
                    pszPropName,            // P Property Name
                    // === REPLY ==================================
                    pValue,128,             // r Property value
                    pucMoreFlag,            // b More Flag
                    pucPropFlag             // b Prop Flag
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWScanObject(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID        NWFAR   *pdwObjectID,
    char            NWFAR   *pszObjectName,
    NWOBJ_TYPE      NWFAR   *pwObjType,
    NWFLAGS         NWFAR   *pucHasProperties,
    NWFLAGS         NWFAR   *pucObjectFlags,
    NWFLAGS         NWFAR   *pucObjSecurity
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    57,                     // Max request packet size
                    59,                     // Max response packet size
                    "brrP|rrRbbb",          // Format string
                    // === REQUEST ================================
                    0x37,                   // b Scan bindery object
                    pdwObjectID,DW_SIZE,    // r 0xffffffff to start or last returned ID when enumerating  HI-LO
                    &wObjSearchType,W_SIZE, // r Use OT_??? Defines HI-LO
                    pszSearchName,          // P Search Name. (use "*") for all
                    // === REPLY ==================================
                    pdwObjectID,DW_SIZE,    // r Returned ID    HI-LO
                    pwObjType,W_SIZE,       // r rObject Type    HI-LO
                    pszObjectName,48,       // R Found Name
                    pucObjectFlags,         // b Object Flag
                    pucObjSecurity,         // b Object Security
                    pucHasProperties        // b Has Properties
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWScanProperty(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char            NWFAR   *pszSearchName,
    NWOBJ_ID        NWFAR   *pdwSequence,
    char            NWFAR   *pszPropName,
    NWFLAGS         NWFAR   *pucPropFlags,
    NWFLAGS         NWFAR   *pucPropSecurity,
    NWFLAGS         NWFAR   *pucHasValue,
    NWFLAGS         NWFAR   *pucMore
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    73,                     // Max request packet size
                    26,                     // Max response packet size
                    "brPrP|Rbbrbb",         // Format string
                    // === REQUEST ================================
                    0x3C,                   // b Scan Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // P Object Name
                    pdwSequence,DW_SIZE,    // r Sequence HI-LO
                    pszSearchName,          // P Property Name to Search for
                    // === REPLY ==================================
                    pszPropName,16,         // R Returned Property Name
                    pucPropFlags,           // b Property Flags
                    pucPropSecurity,        // b Property Security
                    pdwSequence,DW_SIZE,    // r Sequence HI-LO
                    pucHasValue,            // b Property Has value
                    pucMore                 // b More Properties
                    );

    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassBindery );
}




NWCCODE NWAPI DLLEXPORT
NWGetFileServerDateAndTime(
    NWCONN_HANDLE           hConn,
    BYTE            NWFAR   *year,
    BYTE            NWFAR   *month,
    BYTE            NWFAR   *day,
    BYTE            NWFAR   *hour,
    BYTE            NWFAR   *minute,
    BYTE            NWFAR   *second,
    BYTE            NWFAR   *dayofweek
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E0H,      // Server function
                    0,                      // Max request packet size
                    9,                      // Max response packet size
                    "|bbbbbbb",             // Format string
                    // === REQUEST ================================
                    // === REPLY ==================================
                    year,
                    month,
                    day,
                    hour,
                    minute,
                    second,
                    dayofweek
                    );


    (void) SetWin32ErrorFromNtStatus( NtStatus );
    return MapNtStatus( NtStatus, NcpClassConnect );
    
} // NWGetFileServerDateAndTime


//
// worker routines
//

#define NW_RDR_SERVER_PREFIX L"\\Device\\Nwrdr\\"


DWORD 
CancelAllConnections(
      LPWSTR    pszServer
)
/*++

Routine Description:

    This routine cancels all connections to a server

Arguments:

    pszServer - the server we are disconnecting from

Return Value:

    NO_ERROR or win32 error for failure.

--*/
{
    DWORD status = ERROR_NO_NETWORK;
    HANDLE EnumHandle = (HANDLE) NULL;

    LPNETRESOURCE NetR = NULL;

    DWORD BytesNeeded = 4096;
    DWORD EntriesRead;
    DWORD i;

    //
    // Retrieve the list of connections
    //
    status = NPOpenEnum(
                   RESOURCE_CONNECTED,
                   0,
                   0,
                   NULL,
                   &EnumHandle
                   );

    if (status != NO_ERROR) {
        EnumHandle = (HANDLE) NULL;
        goto CleanExit;
    }

    //
    // Allocate buffer to get connection list.
    //
    if ((NetR = (LPNETRESOURCE) LocalAlloc(
                                    LPTR,
                                    (UINT) BytesNeeded
                                    )) == NULL) {

        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    do {

        EntriesRead = 0xFFFFFFFF;          // Read as many as possible

        status = NPEnumResource(
                     EnumHandle,
                     &EntriesRead,
                     (LPVOID) NetR,
                     &BytesNeeded
                     );

        if (status == WN_SUCCESS) 
        {
            LPNETRESOURCE TmpPtr = NetR;

            for (i = 0; i < EntriesRead; i++, TmpPtr++) 
            {
                LPWSTR pszTmp ;

                //
                // If it contains the server we are logging off from, we want
                // to cancel it. First, lets extract the server name part.
                //

                pszTmp = TmpPtr->lpRemoteName ; 

                if (!pszTmp || !*pszTmp)
                    continue ;

                if ((*pszTmp == L'\\') && (*(pszTmp+1) == L'\\'))
                    pszTmp += 2 ; 

                if (pszTmp = wcschr(pszTmp, L'\\'))
                    *pszTmp = 0 ;

                if (_wcsicmp(TmpPtr->lpRemoteName, pszServer) == 0)
                {
                    //
                    // Aha, it matches. Restore the '\' and nuke it with force.
                    // Ignore errors here.
                    //
                    if (pszTmp)
                        *pszTmp = L'\\' ;

                    if (TmpPtr->lpLocalName && *(TmpPtr->lpLocalName))
                    {
                        //
                        // if local name present, its a redirection. 
                        //
                        (void) NPCancelConnection( TmpPtr->lpLocalName,TRUE );
                    }
                    else
                    {
                        //
                        // else cancel the deviceless use
                        //
                        (void) NPCancelConnection( TmpPtr->lpRemoteName,TRUE );
                    }
                }
            }

        }
        else if (status != WN_NO_MORE_ENTRIES) {

            status = GetLastError();

            if (status == WN_MORE_DATA) {

                //
                // Original buffer was too small.  Free it and allocate
                // the recommended size and then some to get as many
                // entries as possible.
                //

                (void) LocalFree((HLOCAL) NetR);

                if ((NetR = (LPNETRESOURCE) LocalAlloc(
                                         LPTR,
                                         (UINT) BytesNeeded
                                         )) == NULL) {

                    status = ERROR_NOT_ENOUGH_MEMORY;
                    goto CleanExit;
                }
            }
            else
            {
                //
                // cant handle other errors. bag out.
                //
                goto CleanExit;
            }
        }

    } while (status != WN_NO_MORE_ENTRIES);

    if (status == WN_NO_MORE_ENTRIES) 
    {
        status = NO_ERROR;
    }

CleanExit:

    if (EnumHandle != (HANDLE) NULL) 
    {
        (void) NPCloseEnum(EnumHandle);
    }

    if (NetR != NULL) 
    {
        (void) LocalFree((HLOCAL) NetR);
    }

    return status;
}

NWCCODE NWAPI DLLEXPORT
NWCreateQueue(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char    NWFAR     *pszQueueName,
    NWOBJ_TYPE              wQueueType,
    const char    NWFAR     *pszPathName,
    NWOBJ_ID      NWFAR     *pdwQueueId
    )
{
   NTSTATUS           NtStatus;
   PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

   NtStatus = NwlibMakeNcp(
                  pServerInfo->hConn,     // Connection Handle
                  FSCTL_NWR_NCP_E3H,      // Bindery function
                  174,                    // Max request packet size
                  6,                      // Max response packet size
                  "brPbP|r",              // Format string
                  // === REQUEST ================================
                  0x64,                   // b Create Queue
                  &wQueueType,W_SIZE,     // r Queue Type    HI-LO
                  pszQueueName,           // P Queue Name
                  dirHandle,              // b Directory Handle
                  pszPathName,            // P Path name
                  // === REPLY ==================================
                  pdwQueueId,DW_SIZE      // r Queue ID HI-LO
                  );

   (void) SetWin32ErrorFromNtStatus(NtStatus);
   return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWChangePropertySecurity(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    const char      NWFAR   *pszPropertyName,
    NWFLAGS                 ucObjSecurity
    )
{
    NTSTATUS   NtStatus;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp (
                   pServerInfo->hConn,   // Connection Handle
                   FSCTL_NWR_NCP_E3H,    // Bindery function
                   70,                   // Max request packet size
                   2,                    // Max response packet size
                   "brPbP|",             // Format string
                   // === REQUEST ================================
                   0x3B,                 // b Change Property Security
                   &wObjType,W_SIZE,     // r OT_???  HI-LO
                   pszObjName,           // P Prop Name
                   ucObjSecurity,        // b New Property security
                   pszPropertyName       // P Property Name
                   // === REPLY ==================================
                   );

   (void) SetWin32ErrorFromNtStatus( NtStatus );
   return MapNtStatus( NtStatus, NcpClassBindery );
}

NWCCODE NWAPI DLLEXPORT
NWDestroyQueue(
    NWCONN_HANDLE hConn,
    NWOBJ_ID      dwQueueId
    )
{
    NTSTATUS   NtStatus;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                   pServerInfo->hConn,   // Connection Handle
                   FSCTL_NWR_NCP_E3H,    // Bindery function
                   7,                    // Max request packet size
                   2,                    // Max response packet size
                   "bd|",                // Format string
                   // === REQUEST ================================
                   0x65,                 // b Destroy Queue
                   dwQueueId             // d Queue ID
                   // === REPLY ==================================
                   );

   (void) SetWin32ErrorFromNtStatus( NtStatus );
   return MapNtStatus( NtStatus, NcpClassBindery );

}

//
// tommye MS 88021 / MCS 
//
//  Added the following two routines to allow the library user 
//  to obtain a NWCONN_HANDLE given a ObjectHandle, then free that 
//  handle.
//

NWCONN_HANDLE NWAPI DLLEXPORT
NwNdsObjectHandleToConnHandle(
    IN HANDLE ObjectHandle)
{
    PNWC_SERVER_INFO    pServerInfo;
    LPNDS_OBJECT_PRIV   pObject = (LPNDS_OBJECT_PRIV)ObjectHandle;

    /** Allocate the NWCONN_HANDLE to return **/

    pServerInfo = (PNWC_SERVER_INFO)LocalAlloc(LPTR, sizeof(NWC_SERVER_INFO));
    if (pServerInfo == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    /** Fill it in **/

    pServerInfo->hConn = pObject->NdsTree;

    /** 
        Fill in the server name, even though NWLoginToFileServer and 
        NWLogoutFromFileServer are the only calls that use it now.
    **/

    RtlInitUnicodeString(
                    &pServerInfo->ServerString, 
                    pObject->szContainerName);

    /** 
        Return the pointer to the block, which is our form of NWCONN_HANDLE.
        The caller is responsible for calling NwNdsConnHandlFree when done.
    **/

    return (NWCONN_HANDLE)pServerInfo;
}

VOID NWAPI DLLEXPORT
NwNdsConnHandleFree(
    IN NWCONN_HANDLE hConn)
{
    if (hConn) {
        PNWC_SERVER_INFO pServerInfo = (PNWC_SERVER_INFO)hConn;

        /** Free the connection handle **/

        LocalFree(pServerInfo);
    }

    /** All done **/

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\ndsapi32.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsLib32.c

Abstract:

    This module implements the exposed user-mode link to
    Netware NDS support in the Netware redirector.  For
    more comments, see ndslib32.h.

Author:

    Cory West    [CoryWest]    23-Feb-1995

--*/

#include <procs.h>
//#include <nwapilyr.h>

NTSTATUS
NwNdsOpenGenericHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwRdrHandle
) {

    NTSTATUS ntstatus, OpenStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;

    WCHAR DevicePreamble[] = L"\\Device\\Nwrdr\\";
    UINT PreambleLength = 14;

    WCHAR NameStr[128];
    UNICODE_STRING uOpenName;
    UINT i;

    PNWR_NDS_REQUEST_PACKET Rrp;
    BYTE RrpData[1024];

    //
    // Prepare the open name.
    //

    uOpenName.MaximumLength = sizeof( NameStr );

    for ( i = 0; i < PreambleLength ; i++ )
        NameStr[i] = DevicePreamble[i];

    try {

        for ( i = 0 ; i < ( puNdsTree->Length / sizeof( WCHAR ) ) ; i++ ) {
            NameStr[i + PreambleLength] = puNdsTree->Buffer[i];
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;

    }

    uOpenName.Length = (USHORT)(( i * sizeof( WCHAR ) ) +
                       ( PreambleLength * sizeof( WCHAR ) ));
    uOpenName.Buffer = NameStr;

    //
    // Set up the object attributes.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uOpenName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    //
    // Make the compiler happy about variable initialization.
    //

    RtlZeroMemory( &IoStatusBlock, sizeof( IO_STATUS_BLOCK ) );

    ntstatus = NtOpenFile(
                   phNwRdrHandle,
                   DesiredAccess,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    OpenStatus = IoStatusBlock.Status;

    //
    // Verify that this is a tree handle, not a server handle.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET)RrpData;

    Rrp->Version = 0;

    RtlCopyMemory( &(Rrp->Parameters).VerifyTree,
                   puNdsTree,
                   sizeof( UNICODE_STRING ) );

    RtlCopyMemory( (BYTE *)(&(Rrp->Parameters).VerifyTree) + sizeof( UNICODE_STRING ),
                   puNdsTree->Buffer,
                   puNdsTree->Length );

    try {

        ntstatus = NtFsControlFile( *phNwRdrHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_VERIFY_TREE,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ) + puNdsTree->Length,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        ntstatus = GetExceptionCode();
        goto CloseAndExit2;
    }

    if ( !NT_SUCCESS( ntstatus ))
    {
        *lpdwHandleType = HANDLE_TYPE_NCP_SERVER;
    }
    else
    {
        *lpdwHandleType = HANDLE_TYPE_NDS_TREE;
    }

    return OpenStatus;

CloseAndExit2:

    NtClose( *phNwRdrHandle );
    *phNwRdrHandle = NULL;

    return ntstatus;
}


NTSTATUS
NwNdsSetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    IN PUNICODE_STRING puContext
)
/*+++

    This sets the current context in the requested tree.

---*/
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD RrpSize;
    BYTE *CurrentString;

    //
    // Set up the request.
    //

    RrpSize = sizeof( NWR_NDS_REQUEST_PACKET ) +
              puTree->Length +
              puContext->Length;

    Rrp = LocalAlloc( LMEM_ZEROINIT, RrpSize );

    if ( !Rrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        (Rrp->Parameters).SetContext.TreeNameLen = puTree->Length;
        (Rrp->Parameters).SetContext.ContextLen = puContext->Length;

        CurrentString = (BYTE *)(Rrp->Parameters).SetContext.TreeAndContextString;

        RtlCopyMemory( CurrentString, puTree->Buffer, puTree->Length );
        CurrentString += puTree->Length;
        RtlCopyMemory( CurrentString, puContext->Buffer, puContext->Length );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    try {

        ntstatus = NtFsControlFile( hNdsRdr,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_SETCONTEXT,
                                    (PVOID) Rrp,
                                    RrpSize,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = GetExceptionCode();
        goto ExitWithCleanup;
    }

ExitWithCleanup:

    LocalFree( Rrp );
    return ntstatus;
}

NTSTATUS
NwNdsGetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    OUT PUNICODE_STRING puContext
)
/*+++

    This gets the current context of the requested tree.

---*/
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD RrpSize;

    //
    // Set up the request.
    //

    RrpSize = sizeof( NWR_NDS_REQUEST_PACKET ) + puTree->Length;

    Rrp = LocalAlloc( LMEM_ZEROINIT, RrpSize );

    if ( !Rrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        (Rrp->Parameters).GetContext.TreeNameLen = puTree->Length;

        RtlCopyMemory( (BYTE *)(Rrp->Parameters).GetContext.TreeNameString,
                       puTree->Buffer,
                       puTree->Length );

        (Rrp->Parameters).GetContext.Context.MaximumLength = puContext->MaximumLength;
        (Rrp->Parameters).GetContext.Context.Length = 0;
        (Rrp->Parameters).GetContext.Context.Buffer = puContext->Buffer;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    try {

        ntstatus = NtFsControlFile( hNdsRdr,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_GETCONTEXT,
                                    (PVOID) Rrp,
                                    RrpSize,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = GetExceptionCode();
        goto ExitWithCleanup;
    }

    //
    // Copy out the length; the buffer has already been written.
    //

    puContext->Length = (Rrp->Parameters).GetContext.Context.Length;

ExitWithCleanup:

    LocalFree( Rrp );
    return ntstatus;
}

NTSTATUS
NwNdsIsNdsConnection (
    IN  HANDLE hNdsRdr,
    OUT BOOL *          pfIsNds,
    OUT PUNICODE_STRING puTree
)
/*+++

    This tests the current connection handle to see if it is one that is
    connected to a server in an NDS tree. If so, the name of the tree is
    put into puTree.

---*/
{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PCONN_DETAILS2 Rrp;
    DWORD RrpSize;

    *pfIsNds = FALSE;

    //
    // Set up the request.
    //

    RrpSize = sizeof( CONN_DETAILS2 );

    Rrp = LocalAlloc( LMEM_ZEROINIT, RrpSize );

    if ( !Rrp )
        return STATUS_INSUFFICIENT_RESOURCES;

    try
    {
        ntstatus = NtFsControlFile( hNdsRdr,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_GET_CONN_DETAILS2,
                                    NULL,
                                    0,
                                    (PVOID) Rrp,
                                    RrpSize );

    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        ntstatus = GetExceptionCode();
        goto ExitWithCleanup;
    }

    if ( ntstatus == STATUS_SUCCESS )
    {
        if ( Rrp->fNds )
        {
            puTree->Length = (USHORT) wcslen( Rrp->NdsTreeName );

            if ( puTree->MaximumLength >= puTree->Length )
                wcscpy( puTree->Buffer, Rrp->NdsTreeName );
            else
                puTree->Length = 0;

            *pfIsNds = TRUE;
        }
    }

ExitWithCleanup:

    LocalFree( Rrp );
    return ntstatus;
}

NTSTATUS
NwNdsList (
   IN HANDLE   hNdsTree,
   IN DWORD    dwObjectId,
   OUT DWORD   *dwIterHandle,
   OUT BYTE    *pbReplyBuf,
   IN DWORD    dwReplyBufLen
) {

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;

    PNDS_RESPONSE_SUBORDINATE_LIST Rsp;
    DWORD dwRspBufferLen;

    BYTE RrpData[256];
    BYTE RspData[1024];

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;

    Rrp->Parameters.ListSubordinates.ObjectId = dwObjectId;
    Rrp->Parameters.ListSubordinates.IterHandle = *dwIterHandle;

   if ( dwReplyBufLen != 0 &&
        pbReplyBuf != NULL ) {

       Rsp = ( PNDS_RESPONSE_SUBORDINATE_LIST ) pbReplyBuf;
       dwRspBufferLen = dwReplyBufLen;

   } else {

       Rsp = ( PNDS_RESPONSE_SUBORDINATE_LIST ) RspData;
       dwRspBufferLen = 1024;

   }

   try {

       Status = NtFsControlFile( hNdsTree,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 FSCTL_NWR_NDS_LIST_SUBS,
                                 (PVOID) Rrp,
                                 sizeof( NWR_NDS_REQUEST_PACKET ),
                                 (PVOID) Rsp,
                                 dwRspBufferLen );

   } except ( EXCEPTION_EXECUTE_HANDLER ) {

       return GetExceptionCode();
   }

   if ( Status == STATUS_SUCCESS )
   {
      *dwIterHandle = Rsp->IterationHandle;
   }

   return Status;

}

NTSTATUS
NwNdsReadObjectInfo(
    IN HANDLE  hNdsTree,
    IN DWORD   dwObjectId,
    OUT BYTE   *pbRawReply,
    IN DWORD   dwReplyBufLen
)
{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;

    PNDS_RESPONSE_GET_OBJECT_INFO Rsp;
    DWORD dwRspBufferLen;

    BYTE RrpData[256];
    BYTE RspData[1024];

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;

    Rrp->Parameters.GetObjectInfo.ObjectId = dwObjectId;

    if ( dwReplyBufLen != 0 &&
         pbRawReply != NULL ) {

        Rsp = ( PNDS_RESPONSE_GET_OBJECT_INFO ) pbRawReply;
        dwRspBufferLen = dwReplyBufLen;

    } else {

        Rsp = ( PNDS_RESPONSE_GET_OBJECT_INFO ) RspData;
        dwRspBufferLen = 1024;

    }

    try {

        Status = NtFsControlFile( hNdsTree,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_NWR_NDS_READ_INFO,
                                  (PVOID) Rrp,
                                  sizeof( NWR_NDS_REQUEST_PACKET ),
                                  (PVOID) Rsp,
                                  dwRspBufferLen );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return GetExceptionCode();
    }

    return Status;

}



NTSTATUS
NwNdsReadAttribute (
   IN HANDLE          hNdsTree,
   IN DWORD           dwObjectId,
   IN DWORD           *dwIterHandle,
   IN PUNICODE_STRING puAttrName,
   OUT BYTE           *pbReplyBuf,
   IN DWORD           dwReplyBufLen
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    PNDS_RESPONSE_READ_ATTRIBUTE Rsp = ( PNDS_RESPONSE_READ_ATTRIBUTE )
                                       pbReplyBuf;

    DWORD dwAttributeNameLen;

    BYTE RrpData[1024];

    //
    // Check the incoming buffer.
    //
    if ( !dwReplyBufLen || !Rsp )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set up the request.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;
    RtlZeroMemory( Rrp, 1024 );

    (Rrp->Parameters).ReadAttribute.ObjectId = dwObjectId;
    (Rrp->Parameters).ReadAttribute.IterHandle = *dwIterHandle;

    //
    // Nds strings are NULL terminated; watch the size.
    //

    dwAttributeNameLen = puAttrName->Length + sizeof( WCHAR );

    (Rrp->Parameters).ReadAttribute.AttributeNameLength = dwAttributeNameLen;

    try {

        //
        // But don't try to copy more than the user gave us.
        //

        memcpy( (Rrp->Parameters).ReadAttribute.AttributeName,
                puAttrName->Buffer,
                puAttrName->Length );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;
    }

   //
   // Send the request to the Redirector FSD.
   //

   try {

       ntstatus = NtFsControlFile( hNdsTree,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   FSCTL_NWR_NDS_READ_ATTR,
                                   (PVOID) Rrp,
                                   sizeof( NWR_NDS_REQUEST_PACKET ) + dwAttributeNameLen,
                                   (PVOID) Rsp,
                                   dwReplyBufLen );

   } except ( EXCEPTION_EXECUTE_HANDLER ) {

       return GetExceptionCode();
   }

   if ( ntstatus == STATUS_SUCCESS )
   {
      *dwIterHandle = Rsp->IterationHandle;
   }

   //
   // There's no buffer post processing on this one.
   //

   return ntstatus;

}

NTSTATUS
NwNdsOpenStream (
    IN HANDLE          hNdsTree,
    IN DWORD           dwObjectId,
    IN PUNICODE_STRING puStreamName,
    IN DWORD           dwOpenFlags,
    OUT DWORD          *pdwFileLength
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    BYTE RrpData[1024];

    //
    // Set up the request.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;
    RtlZeroMemory( Rrp, 1024 );

    (Rrp->Parameters).OpenStream.StreamAccess = dwOpenFlags;
    (Rrp->Parameters).OpenStream.ObjectOid = dwObjectId;

    (Rrp->Parameters).OpenStream.StreamName.Length = puStreamName->Length;
    (Rrp->Parameters).OpenStream.StreamName.MaximumLength =
        sizeof( RrpData ) - sizeof( (Rrp->Parameters).OpenStream );
    (Rrp->Parameters).OpenStream.StreamName.Buffer =
        (Rrp->Parameters).OpenStream.StreamNameString;

    //
    // Make sure we're not trashing memory.
    //

    if ( (Rrp->Parameters).OpenStream.StreamName.Length >
         (Rrp->Parameters).OpenStream.StreamName.MaximumLength ) {

        return STATUS_INVALID_PARAMETER;
    }

    try {

        //
        // But don't try to copy more than the user gave us.
        //

        memcpy( (Rrp->Parameters).OpenStream.StreamNameString,
                puStreamName->Buffer,
                puStreamName->Length );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Send the request to the Redirector FSD.
    //

    try {

        ntstatus = NtFsControlFile( hNdsTree,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_OPEN_STREAM,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ) + puStreamName->Length,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return GetExceptionCode();
    }

    if ( pdwFileLength ) {
        *pdwFileLength = (Rrp->Parameters).OpenStream.FileLength;
    }

    return ntstatus;
}

NTSTATUS
NwNdsGetQueueInformation(
    IN HANDLE            hNdsTree,
    IN PUNICODE_STRING   puQueueName,
    OUT PUNICODE_STRING  puHostServer,
    OUT PDWORD           pdwQueueId
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    BYTE RrpData[1024];

    //
    // Set up the request.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;
    RtlZeroMemory( Rrp, sizeof( RrpData ) );

    if ( puQueueName ) {
        (Rrp->Parameters).GetQueueInfo.QueueName.Length = puQueueName->Length;
        (Rrp->Parameters).GetQueueInfo.QueueName.MaximumLength = puQueueName->MaximumLength;
        (Rrp->Parameters).GetQueueInfo.QueueName.Buffer = puQueueName->Buffer;
    }

    if ( puHostServer ) {
        (Rrp->Parameters).GetQueueInfo.HostServer.Length = 0;
        (Rrp->Parameters).GetQueueInfo.HostServer.MaximumLength = puHostServer->MaximumLength;
        (Rrp->Parameters).GetQueueInfo.HostServer.Buffer = puHostServer->Buffer;
    }

    //
    // Send the request to the Redirector FSD.
    //

    try {

        ntstatus = NtFsControlFile( hNdsTree,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_GET_QUEUE_INFO,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ),
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return GetExceptionCode();
    }

    if ( NT_SUCCESS( ntstatus ) ) {

        if ( pdwQueueId ) {
            *pdwQueueId = (Rrp->Parameters).GetQueueInfo.QueueId;
        }

        puHostServer->Length = (Rrp->Parameters).GetQueueInfo.HostServer.Length;

    }

    return ntstatus;
}

NTSTATUS
NwNdsGetVolumeInformation(
    IN HANDLE            hNdsTree,
    IN PUNICODE_STRING   puVolumeName,
    OUT PUNICODE_STRING  puHostServer,
    OUT PUNICODE_STRING  puHostVolume
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD RequestSize;
    BYTE RrpData[1024];
    BYTE ReplyData[1024];
    PBYTE NameStr;

    //
    // Set up the request.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;
    RtlZeroMemory( Rrp, sizeof( RrpData ) );

    if ( !puVolumeName ||
         puVolumeName->Length > MAX_NDS_NAME_SIZE ||
         !puHostServer ||
         !puHostVolume ) {

        return STATUS_INVALID_PARAMETER;
    }

    try {

        (Rrp->Parameters).GetVolumeInfo.VolumeNameLen = puVolumeName->Length;
        RtlCopyMemory( &((Rrp->Parameters).GetVolumeInfo.VolumeName[0]),
                       puVolumeName->Buffer,
                       puVolumeName->Length );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Send the request to the Redirector FSD.
    //

    RequestSize = sizeof( NWR_NDS_REQUEST_PACKET ) +
                  (Rrp->Parameters).GetVolumeInfo.VolumeNameLen;

    try {

        ntstatus = NtFsControlFile( hNdsTree,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_GET_VOLUME_INFO,
                                    (PVOID) Rrp,
                                    RequestSize,
                                    ReplyData,
                                    sizeof( ReplyData ) );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return GetExceptionCode();
    }

    if ( NT_SUCCESS( ntstatus ) ) {

        try {

            if ( ( puHostServer->MaximumLength < (Rrp->Parameters).GetVolumeInfo.ServerNameLen ) ||
                 ( puHostVolume->MaximumLength < (Rrp->Parameters).GetVolumeInfo.TargetVolNameLen ) ) {

                return STATUS_BUFFER_TOO_SMALL;
            }

            puHostServer->Length = (USHORT)(Rrp->Parameters).GetVolumeInfo.ServerNameLen;
            puHostVolume->Length = (USHORT)(Rrp->Parameters).GetVolumeInfo.TargetVolNameLen;

            NameStr = &ReplyData[0];

            RtlCopyMemory( puHostServer->Buffer, NameStr, puHostServer->Length );
            NameStr += puHostServer->Length;
            RtlCopyMemory( puHostVolume->Buffer, NameStr, puHostVolume->Length );

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            return STATUS_INVALID_PARAMETER;
        }

    }

    return ntstatus;

}

//
// User mode fragment exchange.
//

int
_cdecl
FormatBuf(
    char *buf,
    int bufLen,
    const char *format,
    va_list args
);

int
_cdecl
CalculateBuf(
    const char *format,
    va_list args
);


int
_cdecl
FormatBuf(
    char *buf,
    int bufLen,
    const char *format,
    va_list args
)
/*

Routine Description:

    Formats a buffer according to supplied the format string.

    FormatString - Supplies an ANSI string which describes how to
       convert from the input arguments into NCP request fields, and
       from the NCP response fields into the output arguments.

         Field types, request/response:

            'b'      byte              ( byte   /  byte* )
            'w'      hi-lo word        ( word   /  word* )
            'd'      hi-lo dword       ( dword  /  dword* )
            'W'      lo-hi word        ( word  /   word*)
            'D'      lo-hi dword       ( dword  /  dword*)
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'c'      cstring           ( char* )
            'C'      cstring followed skip word ( char*, word )
            'V'      sized NDS value   ( byte *, dword / byte **, dword *)
            'S'      p unicode string copy as NDS_STRING (UNICODE_STRING *)
            's'      cstring copy as NDS_STRING (char* / char *, word)
            'r'      raw bytes         ( byte*, word )
            'u'      p unicode string  ( UNICODE_STRING * )
            'U'      p uppercase string( UNICODE_STRING * )

Routine Arguments:

    char *buf - destination buffer.
    int buflen - length of the destination buffer.
    char *format - format string.
    args - args to the format string.

Implementation Notes:

   This comes verbatim from kernel mode.

*/
{
    ULONG ix;

    NTSTATUS status;
    const char *z = format;

    //
    // Convert the input arguments into request packet.
    //

    ix = 0;

    while ( *z )
    {
        switch ( *z )
        {
        case '=':
            buf[ix++] = 0;
        case '-':
            buf[ix++] = 0;
            break;

        case '_':
        {
            WORD l = va_arg ( args, WORD );
            if (ix + (ULONG)l > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            while ( l-- )
                buf[ix++] = 0;
            break;
        }

        case 'b':
            buf[ix++] = va_arg ( args, BYTE );
            break;

        case 'w':
        {
            WORD w = va_arg ( args, WORD );
            buf[ix++] = (BYTE) (w >> 8);
            buf[ix++] = (BYTE) (w >> 0);
            break;
        }

        case 'd':
        {
            DWORD d = va_arg ( args, DWORD );
            buf[ix++] = (BYTE) (d >> 24);
            buf[ix++] = (BYTE) (d >> 16);
            buf[ix++] = (BYTE) (d >>  8);
            buf[ix++] = (BYTE) (d >>  0);
            break;
        }

        case 'W':
        {
            WORD w = va_arg(args, WORD);
            (* (WORD *)&buf[ix]) = w;
            ix += 2;
            break;
        }

        case 'D':
        {
            DWORD d = va_arg (args, DWORD);
            (* (DWORD *)&buf[ix]) = d;
            ix += 4;
            break;
        }

        case 'c':
        {
            char* c = va_arg ( args, char* );
            WORD  l = (WORD)strlen( c );
            if (ix + (ULONG)l > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            RtlCopyMemory( &buf[ix], c, l+1 );
            ix += l + 1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( args, char* );
            WORD l = va_arg ( args, WORD );
            WORD len = strlen( c ) + 1;
            if (ix + (ULONG)l > (ULONG)bufLen)
            {
                goto ErrorExit;
            }

            RtlCopyMemory( &buf[ix], c, len > l? l : len);
            ix += l;
            buf[ix-1] = 0;
            break;
        }

        case 'p':
        {
            char* c = va_arg ( args, char* );
            BYTE  l = (BYTE)strlen( c );
            if (ix + (ULONG)l +1 > (ULONG)bufLen)
            {
                goto ErrorExit;
            }
            buf[ix++] = l;
            RtlCopyMemory( &buf[ix], c, l );
            ix += l;
            break;
        }

        case 'u':
        {
            PUNICODE_STRING pUString = va_arg ( args, PUNICODE_STRING );
            OEM_STRING OemString;
            ULONG Length;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            if ( ix + Length > (ULONG)bufLen ) {
                goto ErrorExit;
            }

            buf[ix++] = (UCHAR)Length;
            OemString.Buffer = &buf[ix];
            OemString.MaximumLength = (USHORT)Length + 1;

            status = RtlUnicodeStringToOemString( &OemString, pUString, FALSE );
            ASSERT( NT_SUCCESS( status ));
            ix += (USHORT)Length;
            break;
        }

        case 'S':
        {
            PUNICODE_STRING pUString = va_arg (args, PUNICODE_STRING);
            ULONG Length, rLength;

            Length = pUString->Length;
            if (ix + Length + sizeof(Length) + sizeof( WCHAR ) > (ULONG)bufLen) {
                goto ErrorExit;
            }

            //
            // The VLM client uses the rounded up length and it seems to
            // make a difference!  Also, don't forget that NDS strings have
            // to be NULL terminated.
            //

            rLength = ROUNDUP4(Length + sizeof( WCHAR ));
            *((DWORD *)&buf[ix]) = rLength;
            ix += 4;
            RtlCopyMemory(&buf[ix], pUString->Buffer, Length);
            ix += Length;
            rLength -= Length;
            RtlFillMemory( &buf[ix], rLength, '\0' );
            ix += rLength;
            break;

        }

        case 's':
        {
           PUNICODE_STRING pUString = va_arg (args, PUNICODE_STRING);
           ULONG Length, rLength;

           Length = pUString->Length;
           if (ix + Length + sizeof(Length) + sizeof( WCHAR ) > (ULONG)bufLen) {
               // DebugTrace( 0, Dbg, "FormatBuf: case 's' request buffer too small.\n", 0 );
               goto ErrorExit;
           }

           //
           // Don't use the padded size here, only the NDS null terminator.
           //

           rLength = Length + sizeof( WCHAR );
           *((DWORD *)&buf[ix]) = rLength;
           ix += 4;
           RtlCopyMemory(&buf[ix], pUString->Buffer, Length);
           ix += Length;
           rLength -= Length;
           RtlFillMemory( &buf[ix], rLength, '\0' );
           ix += rLength;
           break;


        }

        case 'V':
        {
            // too similar to 'S' - should be combined
            BYTE* b = va_arg ( args, BYTE* );
            DWORD  l = va_arg ( args, DWORD );
            if ( ix + l + sizeof(DWORD) > (ULONG)
               bufLen )
            {
                goto ErrorExit;
            }
            *((DWORD *)&buf[ix]) = l;
            ix += sizeof(DWORD);
            RtlCopyMemory( &buf[ix], b, l );
                        l = ROUNDUP4(l);
            ix += l;
            break;
        }

        case 'r':
        {
            BYTE* b = va_arg ( args, BYTE* );
            WORD  l = va_arg ( args, WORD );
            if ( b == NULL || l == 0 )
            {
                break;
            }
            if ( ix + l > (ULONG)bufLen )
            {
                goto ErrorExit;
            }
            RtlCopyMemory( &buf[ix], b, l );
            ix += l;
            break;
        }

        default:

        ;

        }

        if ( ix > (ULONG)bufLen )
        {
            goto ErrorExit;
        }


        z++;
    }

    return(ix);

ErrorExit:
    return 0;
}


int
_cdecl
CalculateBuf(
    const char *format,
    va_list args
)
/*

Routine Description:

    This routine calculates the buffer size needed to hold a request.
    FormatString - Supplies an ANSI string which describes how to
       convert from the input arguments into NCP request fields, and
       from the NCP response fields into the output arguments.

         Field types, request/response:

            'b'      byte              ( byte   /  byte* )
            'w'      hi-lo word        ( word   /  word* )
            'd'      hi-lo dword       ( dword  /  dword* )
            'W'      lo-hi word        ( word  /   word*)
            'D'      lo-hi dword       ( dword  /  dword*)
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'c'      cstring           ( char* )
            'C'      cstring followed skip word ( char*, word )
            'V'      sized NDS value   ( byte *, dword / byte **, dword *)
            'S'      p unicode string copy as NDS_STRING (UNICODE_STRING *)
            's'      cstring copy as NDS_STRING (char* / char *, word)
            'r'      raw bytes         ( byte*, word )
            'u'      p unicode string  ( UNICODE_STRING * )
            'U'      p uppercase string( UNICODE_STRING * )

Routine Arguments:

    char *format - format string.
    args - args to the format string.

Implementation Notes:

   This comes verbatim from kernel mode.

*/
{
    ULONG ix;

    const char *z = format;

    //
    // Convert the input arguments into request packet.
    //

    ix = 0;

    while ( *z )
    {
        switch ( *z )
        {
        case '=':
            ix++;
        case '-':
            ix++;
            break;

        case '_':
        {
            WORD l = va_arg ( args, WORD );
            ix += l;
            break;
        }

        case 'b':
        {
            char b = va_arg ( args, BYTE );
            ix++;
            break;
        }

        case 'w':
        {
            WORD w = va_arg ( args, WORD );
            ix += 2;
            break;
        }

        case 'd':
        {
            DWORD d = va_arg ( args, DWORD );
            ix += 4;
            break;
        }

        case 'W':
        {
            WORD w = va_arg(args, WORD);
            ix += 2;
            break;
        }

        case 'D':
        {
            DWORD d = va_arg (args, DWORD);
            ix += 4;
            break;
        }

        case 'c':
        {
            char* c = va_arg ( args, char* );
            WORD  l = (WORD)strlen( c );
            ix += l + 1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( args, char* );
            WORD l = va_arg ( args, WORD );
            WORD len = strlen( c ) + 1;
            ix += l;
            break;
        }

        case 'p':
        {
            char* c = va_arg ( args, char* );
            BYTE  l = (BYTE)strlen( c );
            ix++;
            ix += l;
            break;
        }

        case 'u':
        {
            PUNICODE_STRING pUString = va_arg ( args, PUNICODE_STRING );
            OEM_STRING OemString;
            ULONG Length;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            ix++;
            ix += (USHORT)Length;
            break;
        }

        case 'S':
        {
            PUNICODE_STRING pUString = va_arg (args, PUNICODE_STRING);
            ULONG Length, rLength;

            Length = pUString->Length;

            //
            // The VLM client uses the rounded up length and it seems to
            // make a difference!  Also, don't forget that NDS strings have
            // to be NULL terminated.
            //

            rLength = ROUNDUP4(Length + sizeof( WCHAR ));
            ix += 4;
            ix += Length;
            rLength -= Length;
            ix += rLength;
            break;

        }

        case 's':
        {
           PUNICODE_STRING pUString = va_arg (args, PUNICODE_STRING);
           ULONG Length, rLength;

           Length = pUString->Length;

           //
           // Don't use the padded size here, only the NDS null terminator.
           //

           rLength = Length + sizeof( WCHAR );
           ix += 4;
           ix += Length;
           rLength -= Length;
           ix += rLength;
           break;


        }

        case 'V':
        {
            // too similar to 'S' - should be combined
            BYTE* b = va_arg ( args, BYTE* );
            DWORD  l = va_arg ( args, DWORD );
            ix += sizeof(DWORD);
            l = ROUNDUP4(l);
            ix += l;
            break;
        }

        case 'r':
        {
            BYTE* b = va_arg ( args, BYTE* );
            WORD  l = va_arg ( args, WORD );
            if ( b == NULL || l == 0 )
            {
                break;
            }
            ix += l;
            break;
        }

        default:

        ;

        }

        z++;
    }

    return(ix);
}


NTSTATUS
_cdecl
ParseResponse(
    PUCHAR  Response,
    ULONG ResponseLength,
    char*  FormatString,
    ...                       //  format specific parameters
    )
/*++

Routine Description:

    This routine parse an NCP response.

    Packet types:

            'G'      Generic packet            ( )

         Field types, request/response:

            'b'      byte              ( byte* )
            'w'      hi-lo word        ( word* )
            'x'      ordered word      ( word* )
            'd'      hi-lo dword       ( dword* )
            'e'      ordered dword     ( dword* )
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'c'      cstring           ( char* )
            'r'      raw bytes         ( byte*, word )

            Added 3/29/95 by CoryWest:

            'W'      lo-hi word        ( word  /   word*)
            'D'      lo-hi dword       ( dword  /  dword*)
            'S'      unicode string copy as NDS_STRING (UNICODE_STRING *)
            'T'      terminal unicode string copy as NDS_STRING (UNICODE_STRING *)

            't'      terminal unicode string with the nds null copied
                     as NDS_STRING (UNICODE_STRING *) (for GetUseName)

Return Value:

    STATUS - Success or failure, depending on the response.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PCHAR FormatByte;
    va_list Arguments;
    ULONG Length = 0;

    va_start( Arguments, FormatString );

    //
    // User mode parse response handles only generic packets.
    //

    if ( *FormatString != 'G' ) {
        return STATUS_INVALID_PARAMETER;
    }

    FormatByte = FormatString + 1;
    while ( *FormatByte ) {

        switch ( *FormatByte ) {

        case '-':
            Length += 1;
            break;

        case '=':
            Length += 2;
            break;

        case '_':
        {
            WORD l = va_arg ( Arguments, WORD );
            Length += l;
            break;
        }

        case 'b':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            *b = Response[Length++];
            break;
        }

        case 'w':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            b[1] = Response[Length++];
            b[0] = Response[Length++];
            break;
        }

        case 'x':
        {
            WORD* w = va_arg ( Arguments, WORD* );
            *w = *(WORD UNALIGNED *)&Response[Length];
            Length += 2;
            break;
        }

        case 'd':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            b[3] = Response[Length++];
            b[2] = Response[Length++];
            b[1] = Response[Length++];
            b[0] = Response[Length++];
            break;
        }

        case 'e':
        {
            DWORD UNALIGNED * d = va_arg ( Arguments, DWORD* );
            *d = *(DWORD UNALIGNED *)&Response[Length];
            Length += 4;
            break;
        }

        case 'c':
        {
            char* c = va_arg ( Arguments, char* );
            WORD  l = (WORD)strlen( &Response[Length] );
            memcpy ( c, &Response[Length], l+1 );
            Length += l+1;
            break;
        }

        case 'p':
        {
            char* c = va_arg ( Arguments, char* );
            BYTE  l = Response[Length++];
            memcpy ( c, &Response[Length], l );
            c[l+1] = 0;
            break;
        }

        case 'r':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            WORD  l = va_arg ( Arguments, WORD );
            RtlCopyMemory( b, &Response[Length], l );
            Length += l;
            break;
        }

        case 'W':
        {

            WORD *w = va_arg ( Arguments, WORD* );
            *w = (* (WORD *)&Response[Length]);
            Length += 2;
            break;

        }

        case 'D':
        {

            DWORD *d = va_arg ( Arguments, DWORD* );
            *d = (* (DWORD *)&Response[Length]);
            Length += 4;
            break;

        }

        case 'S':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

               strl = (USHORT)(* (DWORD *)&Response[Length]);

                //
                // Don't count the null terminator that is part of
                // Novell's counted unicode string.
                //

                pU->Length = strl - sizeof( WCHAR );
                Length += 4;
                RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );
                Length += ROUNDUP4(strl);

            } else {

                //
                // Skip over the string since we don't want it.
                //

                Length += ROUNDUP4((* (DWORD *)&Response[Length] ));
                Length += 4;
            }


            break;

        }

        case 's':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

                strl = (USHORT)(* (DWORD *)&Response[Length]);
                pU->Length = strl;
                Length += 4;
                RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );
                Length += ROUNDUP4(strl);

            } else {

                //
                // Skip over the string since we don't want it.
                //

                Length += ROUNDUP4((* (DWORD *)&Response[Length] ));
                Length += 4;
            }


            break;

        }

        case 'T':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

                strl = (USHORT)(* (DWORD *)&Response[Length] );
                strl -= sizeof( WCHAR );  // Don't count the NULL from NDS.

                if ( strl <= pU->MaximumLength ) {

                   pU->Length = strl;
                   Length += 4;
                   RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );

                   //
                   // No need to advance the pointers since this is
                   // specifically a termination case!
                   //

                } else {

                    pU->Length = 0;
                }

            }

            break;

        }

        case 't':
        {

            PUNICODE_STRING pU = va_arg( Arguments, PUNICODE_STRING );
            USHORT strl;

            if (pU) {

                strl = (USHORT)(* (DWORD *)&Response[Length] );

                if ( strl <= pU->MaximumLength ) {

                   pU->Length = strl;
                   Length += 4;
                   RtlCopyMemory( pU->Buffer, &Response[Length], pU->Length );

                   //
                   // No need to advance the pointers since this is
                   // specifically a termination case!
                   //

                } else {

                   pU->Length = 0;

                }

            }

            break;

        }

    }

    if ( Length > ResponseLength ) {
        return( STATUS_INVALID_PARAMETER );
    }

    FormatByte++;

    }

    va_end( Arguments );
    return( Status );

}

NTSTATUS
NwNdsChangePassword(
    IN HANDLE          hNwRdr,
    IN PUNICODE_STRING puTreeName,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puCurrentPassword,
    IN PUNICODE_STRING puNewPassword
) {

    NTSTATUS Status;
    PNWR_NDS_REQUEST_PACKET pNdsRequest;
    DWORD dwRequestLength;
    PBYTE CurrentString;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Allocate the request.
    //

    dwRequestLength =  sizeof( NWR_NDS_REQUEST_PACKET ) +
                       puTreeName->Length +
                       puUserName->Length +
                       puCurrentPassword->Length +
                       puNewPassword->Length;

    pNdsRequest = LocalAlloc( LMEM_ZEROINIT, dwRequestLength );

    if ( !pNdsRequest) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the parameters into the request buffer.
    //

    try {

        (pNdsRequest->Parameters).ChangePass.NdsTreeNameLength =
            puTreeName->Length;
        (pNdsRequest->Parameters).ChangePass.UserNameLength =
            puUserName->Length;
        (pNdsRequest->Parameters).ChangePass.CurrentPasswordLength =
            puCurrentPassword->Length;
        (pNdsRequest->Parameters).ChangePass.NewPasswordLength =
            puNewPassword->Length;

        CurrentString = ( PBYTE ) &((pNdsRequest->Parameters).ChangePass.StringBuffer[0]);
        RtlCopyMemory( CurrentString, puTreeName->Buffer, puTreeName->Length );

        CurrentString += puTreeName->Length;
        RtlCopyMemory( CurrentString, puUserName->Buffer, puUserName->Length );

        CurrentString += puUserName->Length;
        RtlCopyMemory( CurrentString, puCurrentPassword->Buffer, puCurrentPassword->Length );

        CurrentString += puCurrentPassword->Length;
        RtlCopyMemory( CurrentString, puNewPassword->Buffer, puNewPassword->Length );

        Status = NtFsControlFile( hNwRdr,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_NWR_NDS_CHANGE_PASS,
                                  (PVOID) pNdsRequest,
                                  dwRequestLength,
                                  NULL,
                                  0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = STATUS_INVALID_PARAMETER;
    }

    LocalFree( pNdsRequest );
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwapi32\nwapi32.c ===
//
// dummy file to make build happy
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\canon.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    canon.c

Abstract:

    Contains canonicalization routines for NetWare names.

Author:

    Rita Wong     (ritaw)    19-Feb-1993

Environment:


Revision History:


--*/


#include <procs.h>


DWORD
NwLibValidateLocalName(
    IN LPWSTR LocalName
    )
/*++

Routine Description:

    This routine checks to see if the supplied name is a valid
    DOS device name.

Arguments:

    LocalName - Supplies a local device name.  It can be any of
        the following:

            X:
            LPTn or LPTn:
            COMn or COMn:
            PRN or PRN:
            AUX or AUX:


Return Value:

    NO_ERROR - LocalName is valid.

    WN_BAD_NETNAME - LocalName is invalid.

--*/
{
    DWORD LocalNameLength;


    //
    // Cannot be a NULL or empty string
    //
    if (LocalName == NULL || *LocalName == 0) {
        return WN_BAD_NETNAME;
    }

    LocalNameLength = wcslen(LocalName);

    if (LocalNameLength == 1) {
        return WN_BAD_NETNAME;
    }

    if (LocalName[LocalNameLength - 1] == L':') {
        if (! IS_VALID_TOKEN(LocalName, LocalNameLength - 1)) {
            return WN_BAD_NETNAME;
        }
    }
    else {
        if (! IS_VALID_TOKEN(LocalName, LocalNameLength)) {
            return WN_BAD_NETNAME;
        }
    }

    if (LocalNameLength == 2) {
        //
        // Must be in the form of X:
        //
        if (! iswalpha(*LocalName)) {
            return WN_BAD_NETNAME;
        }

        if (LocalName[1] != L':') {
            return WN_BAD_NETNAME;
        }

        return NO_ERROR;
    }

    if (RtlIsDosDeviceName_U(LocalName) == 0) {
        return WN_BAD_NETNAME;
    }

    //
    // Valid DOS device name but invalid redirection name
    //
    if (_wcsnicmp(LocalName, L"NUL", 3) == 0) {
        return WN_BAD_NETNAME;

    }
    return NO_ERROR;
}


DWORD
NwLibCanonLocalName(
    IN LPWSTR LocalName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    )
/*++

Routine Description:

    This routine canonicalizes the local name by uppercasing the string
    and converting the following:

          x:  -> X:
          LPTn: -> LPTn
          COMn: -> COMn
          PRN or PRN:  -> LPT1
          AUX or AUX:  -> COM1

Arguments:

    LocalName - Supplies a local device name.

    OutputBuffer - Receives a pointer to the canonicalized LocalName.

    OutputBufferLength - Receives the length of the canonicalized name
        in number of characters, if specified.

Return Value:

    NO_ERROR - Successfully canonicalized the local name.

    WN_BAD_NETNAME - LocalName is invalid.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

--*/
{
    DWORD status;
    DWORD LocalNameLength;


    status = NwLibValidateLocalName(LocalName);

    if (status != NO_ERROR) {
        return status;
    }

    LocalNameLength = wcslen(LocalName);

    //
    // Allocate output buffer.  Should be the size of the LocalName
    // plus 1 for the special case of PRN -> LPT1 or AUX -> COM1.
    //
    *OutputBuffer = (PVOID) LocalAlloc(
                                LMEM_ZEROINIT,
                                (LocalNameLength + 2) * sizeof(WCHAR)
                                );

    if (*OutputBuffer == NULL) {
        KdPrint(("NWLIB: NwLibCanonLocalName LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*OutputBuffer, LocalName);

    if (LocalNameLength > 2) {

        if (_wcsnicmp(*OutputBuffer, L"PRN", 3) == 0) {

            //
            // Convert PRN or PRN: to LPT1
            //
            wcscpy(*OutputBuffer, L"LPT1");
            LocalNameLength = 4;

        }
        else if (_wcsnicmp(*OutputBuffer, L"AUX", 3) == 0) {

            //
            // Convert AUX or AUX: to COM1
            //
            wcscpy(*OutputBuffer, L"COM1");
            LocalNameLength = 4;
        }

        //
        // Remove trailing colon, if there is one, and decrement the length
        // of DOS device name.
        //
        if ((*OutputBuffer)[LocalNameLength - 1] == L':') {
            (*OutputBuffer)[--LocalNameLength] = 0;
        }
    }

    //
    // LocalName is always in uppercase.
    //
    _wcsupr(*OutputBuffer);

    if (ARGUMENT_PRESENT(OutputBufferLength)) {
        *OutputBufferLength = LocalNameLength;
    }

    return NO_ERROR;
}


DWORD
NwLibCanonRemoteName(
    IN LPWSTR LocalName OPTIONAL,
    IN LPWSTR RemoteName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    )
/*++

Routine Description:

    This routine validates and canonicalizes the supplied
    NetWare UNC name.  It can be of any length in the form of:

        \\Server\Volume\Directory\Subdirectory

Arguments:

    LocalName - Supplies the local device name.  If it is NULL, then
        \\Server is an acceptable format for the UNC name.

    RemoteName - Supplies the UNC name.

    OutputBuffer - Receives a pointer to the canonicalized RemoteName.

    OutputBufferLength - Receives the length of the canonicalized name
        in number of characters, if specified.

Return Value:

    NO_ERROR - RemoteName is valid.

    WN_BAD_NETNAME - RemoteName is invalid.

--*/
{
    DWORD RemoteNameLength;
    DWORD i;
    DWORD TokenLength;
    LPWSTR TokenPtr;
    BOOL  fFirstToken = TRUE;


    //
    // Cannot be a NULL or empty string
    //
    if (RemoteName == NULL || *RemoteName == 0) {
        return WN_BAD_NETNAME;
    }

    RemoteNameLength = wcslen(RemoteName);

    //
    // Must be at least \\x\y if local device name is specified.
    // Otherwise it must be at least \\x.
    //
    if ((RemoteNameLength < 5 && ARGUMENT_PRESENT(LocalName)) ||
        (RemoteNameLength < 3)) {
        return WN_BAD_NETNAME;
    }

    //
    // First two characters must be "\\"
    //
    if (*RemoteName != L'\\' || RemoteName[1] != L'\\') {
        return WN_BAD_NETNAME;
    }

    if (! ARGUMENT_PRESENT(LocalName) &&
        (IS_VALID_TOKEN(&RemoteName[2], RemoteNameLength - 2))) {

        //
        // Return success for \\Server case.
        //

        *OutputBuffer = (PVOID) LocalAlloc(
                                    LMEM_ZEROINIT,
                                    (RemoteNameLength + 1) * sizeof(WCHAR)
                                    );

        if (*OutputBuffer == NULL) {
            KdPrint(("NWLIB: NwLibCanonRemoteName LocalAlloc failed %lu\n",
                     GetLastError()));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(*OutputBuffer, RemoteName);

        return NO_ERROR;
    }

    //
    // Must have at least one more backslash after the third character
    //
    if (wcschr(&RemoteName[3], L'\\') == NULL) {
        return WN_BAD_NETNAME;
    }

    //
    // Last character cannot a backward slash
    //
    if (RemoteName[RemoteNameLength - 1] == L'\\') {
        return WN_BAD_NETNAME;
    }

    //
    // Allocate output buffer.  Should be the size of the RemoteName
    // and space for an extra character to simplify parsing code below.
    //
    *OutputBuffer = (PVOID) LocalAlloc(
                                LMEM_ZEROINIT,
                                (RemoteNameLength + 2) * sizeof(WCHAR)
                                );


    if (*OutputBuffer == NULL) {
        KdPrint(("NWLIB: NwLibCanonRemoteName LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*OutputBuffer, RemoteName);

    //
    // Convert all backslashes to NULL terminator, skipping first 2 chars.
    //
    for (i = 2; i < RemoteNameLength; i++) {
        if ((*OutputBuffer)[i] == L'\\') {

            (*OutputBuffer)[i] = 0;

            //
            // Two consecutive forward or backslashes is bad.
            //
            if ((i + 1 < RemoteNameLength) &&
                ((*OutputBuffer)[i + 1] == L'\\')) {

                (void) LocalFree((HLOCAL) *OutputBuffer);
                *OutputBuffer = NULL;
                return WN_BAD_NETNAME;
            }
        }
    }

    //
    // Validate each token of the RemoteName, separated by NULL terminator.
    //
    TokenPtr = *OutputBuffer + 2;  // Skip first 2 chars

    while (*TokenPtr != 0) {

        TokenLength = wcslen(TokenPtr);

        if (  ( fFirstToken && !IS_VALID_SERVER_TOKEN(TokenPtr, TokenLength))
           || ( !fFirstToken && !IS_VALID_TOKEN(TokenPtr, TokenLength))
           )
        {
            (void) LocalFree((HLOCAL) *OutputBuffer);
            *OutputBuffer = NULL;
            return WN_BAD_NETNAME;
        }

        fFirstToken = FALSE;
        TokenPtr += TokenLength + 1;
    }

    //
    // Convert NULL separators to backslashes
    //
    for (i = 0; i < RemoteNameLength; i++) {
        if ((*OutputBuffer)[i] == 0) {
            (*OutputBuffer)[i] = L'\\';
        }
    }

    if (ARGUMENT_PRESENT(OutputBufferLength)) {
        *OutputBufferLength = RemoteNameLength;
    }

    return NO_ERROR;
}


DWORD
NwLibCanonUserName(
    IN LPWSTR UserName,
    OUT LPWSTR *OutputBuffer,
    OUT LPDWORD OutputBufferLength OPTIONAL
    )
/*++

Routine Description:

    This routine canonicalizes the user name by checking to see
    if the name contains any illegal characters.


Arguments:

    UserName - Supplies a username.

    OutputBuffer - Receives a pointer to the canonicalized UserName.

    OutputBufferLength - Receives the length of the canonicalized name
        in number of characters, if specified.

Return Value:

    NO_ERROR - Successfully canonicalized the username.

    WN_BAD_NETNAME - UserName is invalid.

    ERROR_NOT_ENOUGH_MEMORY - Could not allocate output buffer.

--*/
{
    DWORD UserNameLength;


    //
    // Cannot be a NULL or empty string
    //
    if (UserName == NULL) {
        return WN_BAD_NETNAME;
    }

    UserNameLength = wcslen(UserName);

    if (! IS_VALID_TOKEN(UserName, UserNameLength)) {
        return WN_BAD_NETNAME;
    }

    //
    // Allocate output buffer.  Should be the size of the UserName
    // plus 1 for the special case of PRN -> LPT1 or AUX -> COM1.
    //
    *OutputBuffer = (PVOID) LocalAlloc(
                                LMEM_ZEROINIT,
                                (UserNameLength + 1) * sizeof(WCHAR)
                                );

    if (*OutputBuffer == NULL) {
        KdPrint(("NWLIB: NwLibCanonUserName LocalAlloc failed %lu\n",
                 GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*OutputBuffer, UserName);

    if (ARGUMENT_PRESENT(OutputBufferLength)) {
        *OutputBufferLength = UserNameLength;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\nwpapi32.c ===
/*++

Copyright (C) 1993 Microsoft Corporation

Module Name:

      NWAPI32.C

Abstract:

      This module contains several useful functions. Mostly wrappers.

Author:

      Chuck Y. Chan   (ChuckC)  06-Mar-1995

Revision History:
                                  
--*/


#include "procs.h"
 
//
// Define structure for internal use. Our handle passed back from attach to
// file server will be pointer to this. We keep server string around for
// discnnecting from the server on logout. The structure is freed on detach.
// Callers should not use this structure but treat pointer as opaque handle.
//
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;


//
// forward declare
//
#ifndef WIN95
extern NTSTATUS
NwAttachToServer(
    IN  LPWSTR  ServerName,
    OUT LPHANDLE phandleServer
    ) ;

extern NTSTATUS
NwDetachFromServer(
    IN HANDLE handleServer
    ) ;

#endif
extern DWORD 
CancelAllConnections(
    LPWSTR    pszServer
    ) ;

extern DWORD
szToWide( 
    LPWSTR lpszW, 
    LPCSTR lpszC, 
    INT nSize 
);



NTSTATUS
NWPAttachToFileServerW(
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    )
{
    NTSTATUS         NtStatus;
    LPWSTR           lpwszServerName;   // Pointer to buffer for WIDE servername
    int              nSize;
    PNWC_SERVER_INFO pServerInfo = NULL;

    UNREFERENCED_PARAMETER(ScopeFlag) ;

    //
    // check parameters and init return result to be null.
    //
    if (!pszServerName || !phNewConn)
        return STATUS_INVALID_PARAMETER;

    *phNewConn = NULL ; 

    //
    // Allocate a buffer to store the file server name 
    //
    nSize = wcslen(pszServerName)+3 ;
    if(!(lpwszServerName = (LPWSTR) LocalAlloc( 
                                        LPTR, 
                                        nSize * sizeof(WCHAR) ))) 
    {
        NtStatus = STATUS_NO_MEMORY;
        goto ExitPoint ;
    }
    wcscpy( lpwszServerName, L"\\\\" );
    wcscat( lpwszServerName, pszServerName );

    //
    // Allocate a buffer for the server info (handle + name pointer). Also
    // init the unicode string.
    //
    if( !(pServerInfo = (PNWC_SERVER_INFO) LocalAlloc( 
                                              LPTR, 
                                              sizeof(NWC_SERVER_INFO))) ) 
    {
        NtStatus = STATUS_NO_MEMORY;
        goto ExitPoint ;
    }
    RtlInitUnicodeString(&pServerInfo->ServerString, lpwszServerName) ;

    //
    // Call createfile to get a handle for the redirector calls
    //
    NtStatus = NwAttachToServer( lpwszServerName, &pServerInfo->hConn );

ExitPoint: 

    //
    // Free the memory allocated above before exiting
    //
    if ( !NT_SUCCESS( NtStatus))
    {
        if (lpwszServerName)
            (void) LocalFree( (HLOCAL) lpwszServerName );
        if (pServerInfo)
            (void) LocalFree( (HLOCAL) pServerInfo );
    }
    else
        *phNewConn  = (HANDLE) pServerInfo ;

    return( NtStatus );
}


NTSTATUS
NWPDetachFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    (void) NwDetachFromServer( pServerInfo->hConn );

    (void) LocalFree (pServerInfo->ServerString.Buffer) ;

    //
    // catch any body that still trirs to use this puppy...
    //
    pServerInfo->ServerString.Buffer = NULL ;   
    pServerInfo->hConn = NULL ;

    (void) LocalFree (pServerInfo) ;

    return STATUS_SUCCESS;
}


NTSTATUS
NWPGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO            *lpVerInfo
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    130,                    // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0x11,                   // b Get File Server Information
                    // === REPLY ==================================
                    lpVerInfo,              // r File Version Structure
                    sizeof(VERSION_INFO)
                    );

    // Convert HI-LO words to LO-HI
    // ===========================================================
    lpVerInfo->ConnsSupported = wSWAP( lpVerInfo->ConnsSupported );
    lpVerInfo->connsInUse     = wSWAP( lpVerInfo->connsInUse );
    lpVerInfo->maxVolumes     = wSWAP( lpVerInfo->maxVolumes );
    lpVerInfo->PeakConns      = wSWAP( lpVerInfo->PeakConns );
    return NtStatus;
}

NTSTATUS
NWPGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char                    *pszObjName,
    NWOBJ_TYPE              *pwObjType )
{
    NWOBJ_ID           dwRetID;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    7,                      // Max request packet size
                    56,                     // Max response packet size
                    "br|rrr",               // Format string
                    // === REQUEST ================================
                    0x36,                   // b Get Bindery Object Name
                    &dwObjectID,DW_SIZE,    // r Object ID    HI-LO
                    // === REPLY ==================================
                    &dwRetID,DW_SIZE,       // r Object ID HI-LO
                    pwObjType,W_SIZE,       // r Object Type
                    pszObjName,48           // r Object Name
                    );

    return NtStatus;
}

DWORD
NWPLoginToFileServerW(
    NWCONN_HANDLE  hConn,
    LPWSTR         pszUserNameW,
    NWOBJ_TYPE     wObjType,
    LPWSTR         pszPasswordW
    )
{
    NETRESOURCEW       NetResource;
    DWORD              dwRes;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    //
    // validate parameters
    //
    if (!hConn || !pszUserNameW || !pszPasswordW)
        return ERROR_INVALID_PARAMETER;

    NetResource.dwScope      = 0 ;
    NetResource.dwUsage      = 0 ;
    NetResource.dwType       = RESOURCETYPE_ANY;
    NetResource.lpLocalName  = NULL;
    NetResource.lpRemoteName = (LPWSTR) pServerInfo->ServerString.Buffer;
    NetResource.lpComment    = NULL;
    NetResource.lpProvider   = NULL ;

    //
    // make the connection 
    //
    dwRes=NPAddConnection ( &NetResource, 
                            pszPasswordW, 
                            pszUserNameW );

    if( NO_ERROR != dwRes ) 
        dwRes = GetLastError();

    return( dwRes );
}


DWORD
NWPLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    DWORD              dwRes;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    //
    // now cancel the any connection to \\servername.
    //
    dwRes = NPCancelConnection( pServerInfo->ServerString.Buffer, TRUE );

    if ( NO_ERROR != dwRes ) 
        dwRes = GetLastError();

    return dwRes;
}


NTSTATUS
NWPReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjName,
    NWOBJ_TYPE              wObjType,
    char                    *pszPropName,
    unsigned char           ucSegment,
    char                    *pValue,
    NWFLAGS                 *pucMoreFlag,
    NWFLAGS                 *pucPropFlag
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    70,                     // Max request packet size
                    132,                    // Max response packet size
                    "brpbp|rbb",            // Format string
                    // === REQUEST ================================
                    0x3D,                   // b Read Property Value
                    &wObjType,W_SIZE,       // r Object Type    HI-LO
                    pszObjName,             // p Object Name
                    ucSegment,              // b Segment Number
                    pszPropName,            // p Property Name
                    // === REPLY ==================================
                    pValue,128,             // r Property value
                    pucMoreFlag,            // b More Flag
                    pucPropFlag             // b Prop Flag
                    );

    return NtStatus;
}

NTSTATUS
NWPScanObject(
    NWCONN_HANDLE           hConn,
    const char              *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID                *pdwObjectID,
    char                    *pszObjectName,
    NWOBJ_TYPE              *pwObjType,
    NWFLAGS                 *pucHasProperties,
    NWFLAGS                 *pucObjectFlags,
    NWFLAGS                 *pucObjSecurity
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    57,                     // Max request packet size
                    59,                     // Max response packet size
                    "brrp|rrrbbb",          // Format string
                    // === REQUEST ================================
                    0x37,                   // b Scan bindery object
                    pdwObjectID,DW_SIZE,    // r 0xffffffff to start or last returned ID when enumerating  HI-LO
                    &wObjSearchType,W_SIZE, // r Use OT_??? Defines HI-LO
                    pszSearchName,          // p Search Name. (use "*") for all
                    // === REPLY ==================================
                    pdwObjectID,DW_SIZE,    // r Returned ID    HI-LO
                    pwObjType,W_SIZE,       // r rObject Type    HI-LO
                    pszObjectName,48,       // r Found Name
                    pucObjectFlags,         // b Object Flag
                    pucObjSecurity,         // b Object Security
                    pucHasProperties        // b Has Properties
                    );

    return NtStatus;
}

NTSTATUS
NWPScanProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char                    *pszSearchName,
    NWOBJ_ID                *pdwSequence,
    char                    *pszPropName,
    NWFLAGS                 *pucPropFlags,
    NWFLAGS                 *pucPropSecurity,
    NWFLAGS                 *pucHasValue,
    NWFLAGS                 *pucMore
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    73,                     // Max request packet size
                    26,                     // Max response packet size
                    "brprp|rbbrbb",         // Format string
                    // === REQUEST ================================
                    0x3C,                   // b Scan Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    pdwSequence,DW_SIZE,    // r Sequence HI-LO
                    pszSearchName,          // p Property Name to Search for
                    // === REPLY ==================================
                    pszPropName,16,         // r Returned Property Name
                    pucPropFlags,           // b Property Flags
                    pucPropSecurity,        // b Property Security
                    pdwSequence,DW_SIZE,    // r Sequence HI-LO
                    pucHasValue,            // b Property Has value
                    pucMore                 // b More Properties
                    );

    return NtStatus;
}

NTSTATUS
NWPDeleteObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    54,                     // Max request packet size
                    2,                      // Max response packet size
                    "brp|",                 // Format string
                    // === REQUEST ================================
                    0x33,                   // b Scan Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName           // p Object Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS
NWPCreateObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    56,                     // Max request packet size
                    2,                      // Max response packet size
                    "bbbrp|",               // Format string
                    // === REQUEST ================================
                    0x32,                   // b Scan Prop function
                    ucObjectFlags,          // b Object flags
                    ucObjSecurity,          // b Object security
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName           // p Object Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS
NWPCreateProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    73,                     // Max request packet size
                    2,                      // Max response packet size
                    "brpbbp|",              // Format string
                    // === REQUEST ================================
                    0x39,                   // b Create Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    ucObjectFlags,          // b Object flags
                    ucObjSecurity,          // b Object security
                    pszPropertyName         // p Property Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}


NTSTATUS
NWPDeleteProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    73,                     // Max request packet size
                    2,                      // Max response packet size
                    "brpp|",                // Format string
                    // === REQUEST ================================
                    0x3A,                   // b Delete Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    pszPropertyName         // p Property Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}


NTSTATUS
NWPWritePropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWSEGMENT_NUM           segmentNumber,
    NWSEGMENT_DATA          *segmentData,
    NWFLAGS                 moreSegments
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    201,                    // Max request packet size
                    2,                      // Max response packet size
                    "brpbbpr|",             // Format string
                    // === REQUEST ================================
                    0x3E,                   // b Write Prop function
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    segmentNumber,          // b Segment Number
                    moreSegments,           // b Segment remaining
                    pszPropertyName,        // p Property Name
                    segmentData, 128        // r Property Value Data
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS
NWPChangeObjectPasswordEncrypted(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    BYTE                    *validationKey,
    BYTE                    *newKeyedPassword
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    strlen( pszObjectName) + 32, // Max request packet size
                    2,                      // Max response packet size
                    "brrpr|",               // Format string
                    // === REQUEST ================================
                    0x4B,                   // b Write Prop function
                    validationKey, 8,       // r Key
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    newKeyedPassword, 17    // r New Keyed Password
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS
NWPGetObjectID(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWOBJ_ID                *objectID
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    54,                     // Max request packet size
                    56,                     // Max response packet size
                    "brp|d",                // Format string
                    // === REQUEST ================================
                    0x35,                   // b Get Obj ID
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    // === REPLY ==================================
                    objectID                // d Object ID
                    );

    *objectID = dwSWAP( *objectID );

    return NtStatus;
}


NTSTATUS
NWPRenameBinderyObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    const char              *pszNewObjectName,
    NWOBJ_TYPE              wObjType 
    )
{
    NTSTATUS     NtStatus;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    105,                    // Max request packet size
                    2,                      // Max response packet size
                    "brpp",                 // Format string
                    // === REQUEST ================================
                    0x34,                   // b Rename bindery object
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    pszNewObjectName        // p New Object Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS 
NWPAddObjectToSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    122,                    // Max request packet size
                    2,                      // Max response packet size
                    "brpprp|",              // Format string
                    // === REQUEST ================================
                    0x41,                   // b Add obj to set
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    pszPropertyName,        // p Property Name
                    &memberType, W_SIZE,    // r Member type
                    pszMemberName           // p Member Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}


NTSTATUS 
NWPDeleteObjectFromSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    122,                    // Max request packet size
                    2,                      // Max response packet size
                    "brpprp|",              // Format string
                    // === REQUEST ================================
                    0x42,                   // b Del object from set
                    &wObjType,W_SIZE,       // r Type of Object
                    pszObjectName,          // p Object Name
                    pszPropertyName,        // p Property Name
                    &memberType, W_SIZE,    // r Member type
                    pszMemberName           // p Member Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS 
NWPGetChallengeKey(
    NWCONN_HANDLE           hConn,
    UCHAR                   *challengeKey
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    10,                     // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0x17,                   // b Get Challenge
                    // === REPLY ==================================
                    challengeKey, 8
                    );

    return NtStatus;
}

NTSTATUS 
NWPCreateDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWACCESS_RIGHTS         accessMask 
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    261,                    // Max request packet size
                    2,                      // Max response packet size
                    "bbbp|",                // Format string
                    // === REQUEST ================================
                    0xA,                    // b Create Directory
                    dirHandle,              // b Directory Handle
                    accessMask,             // b Access Mask
                    pszPath                 // p Property Name
                    // === REPLY ==================================
                    );

    return NtStatus;
}

NTSTATUS
NWPAddTrustee(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWRIGHTS_MASK           rightsMask
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Directory function
                    266,                    // Max request packet size
                    2,                      // Max response packet size
                    "bbrrp|",               // Format string
                    // === REQUEST ================================
                    0x27,                   // b Add trustee to directory
                    dirHandle,              // b Directory handle
                    &dwTrusteeID,DW_SIZE,   // r Object ID to assigned to directory
                    &rightsMask,W_SIZE,     // r User rights for directory
                    pszPath                 // p Directory (if dirHandle = 0 then vol:directory)
                    );

    return NtStatus;

}


NTSTATUS
NWPScanForTrustees(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    BYTE                    *numberOfEntries,
    TRUSTEE_INFO            *ti
    )
{
    ULONG i;
    DWORD oid[20];
    WORD or[20];
    NTSTATUS NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    261,                    // Max request packet size
                    121,                    // Max response packet size
                    "bbbp|brr",             // Format string
                    // === REQUEST ================================
                    0x26,                   // b Scan For Trustees
                    dirHandle,              // b Directory Handle
                    *pucsequenceNumber,     // b Sequence Number
                    pszsearchDirPath,       // p Search Dir Path
                    // === REPLY ==================================
                    numberOfEntries,
                    &oid[0],DW_SIZE*20,      // r trustee object ID
                    &or[0], W_SIZE*20        // b Trustee rights mask 
                    );


    for(i = 0; i < 20; i++) {
      ti[i].objectID = oid[i];
      ti[i].objectRights = or[i];
    }

    (*pucsequenceNumber)++;
    
    return NtStatus ;

} // NWScanForTrustees


NTSTATUS
NWPScanDirectoryForTrustees2(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    char                    *pszdirName,
    NWDATE_TIME             *dirDateTime,
    NWOBJ_ID                *ownerID,
    TRUSTEE_INFO            *ti
    )
{
    ULONG i;
    DWORD oid[5];
    BYTE or[5];
    NTSTATUS NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    memset(oid, 0, sizeof(oid));
    memset(or, 0, sizeof(or));

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    261,                    // Max request packet size
                    49,                     // Max response packet size
                    "bbbp|rrrrr",  // Format string
                    // === REQUEST ================================
                    0x0C,                   // b Scan Directory function
                    dirHandle,              // b Directory Handle
                    *pucsequenceNumber,     // b Sequence Number
                    pszsearchDirPath,       // p Search Dir Path
                    // === REPLY ==================================
                    pszdirName,16,          // r Returned Directory Name
                    dirDateTime,DW_SIZE,    // r Date and Time
                    ownerID,DW_SIZE,        // r Owner ID
                    &oid[0],DW_SIZE*5,      // r trustee object ID
                    &or[0], 5               // b Trustee rights mask 
                    );


    for(i = 0; i < 5; i++) {
      ti[i].objectID = oid[i];
      ti[i].objectRights = (WORD) or[i];
    }

    (*pucsequenceNumber)++;
    
    return NtStatus ;

} // NWScanDirectoryForTrustees2


NTSTATUS
NWPGetBinderyAccessLevel(
    NWCONN_HANDLE           hConn,
    NWFLAGS                 *accessLevel,
    NWOBJ_ID                *objectID
    )
{
    NTSTATUS NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    7,                      // Max response packet size
                    "b|br",                 // Format string
                    // === REQUEST ================================
                    0x46,                   // b Get Bindery Access Level
                    // === REPLY ==================================
                    accessLevel,
                    objectID,DW_SIZE
                    );


    
    return NtStatus ;

} // NWGetBinderyAccessLevel

NTSTATUS
NWPGetFileServerDescription(
    NWCONN_HANDLE         hConn,
    char                  *pszCompany,
    char                  *pszVersion,
    char                  *pszRevision
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    514,                    // Max response packet size
                    "b|ccc",                // Format string
                    // === REQUEST ================================
                    0xC9,                   // b Get File Server Information
                    // === REPLY ==================================
                    pszCompany,             // c Company
                    pszVersion,             // c Version
                    pszRevision             // c Description
                    );

    return NtStatus;
}

NTSTATUS
NWPGetVolumeNumber(
    NWCONN_HANDLE         hConn,
    char                  *pszVolume,
    NWVOL_NUM             *VolumeNumber
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    20,                     // Max request packet size
                    3,                      // Max response packet size
                    "bp|b",                  // Format string
                    // === REQUEST ================================
                    0x05,                   // b Get Volume Number
                    pszVolume,              // p volume name
                    // === REPLY ==================================
                    VolumeNumber            // b Description
                    );

    return NtStatus;
}

NTSTATUS
NWPGetVolumeUsage(
    NWCONN_HANDLE         hConn,
    NWVOL_NUM             VolumeNumber,
    DWORD                 *TotalBlocks,
    DWORD                 *FreeBlocks,
    DWORD                 *PurgeableBlocks,
    DWORD                 *NotYetPurgeableBlocks,
    DWORD                 *TotalDirectoryEntries,
    DWORD                 *AvailableDirectoryEntries,
    BYTE                  *SectorsPerBlock
    )
{
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E2H,      // Bindery function
                    4,                      // Max request packet size
                    46,                     // Max response packet size
                    "bb|dddddd==b",                 // Format string
                    // === REQUEST ================================
                    0x2C,                   // b Get Volume Number
                    VolumeNumber,           // p volume number
                    // === REPLY ==================================
                    TotalBlocks,
                    FreeBlocks,
                    PurgeableBlocks,
                    NotYetPurgeableBlocks,
                    TotalDirectoryEntries,
                    AvailableDirectoryEntries,
                    SectorsPerBlock
                    );

    *TotalBlocks = dwSWAP( *TotalBlocks );
    *FreeBlocks  = dwSWAP( *FreeBlocks );
    *PurgeableBlocks = dwSWAP( *PurgeableBlocks );
    *NotYetPurgeableBlocks = dwSWAP( *NotYetPurgeableBlocks );
    *TotalDirectoryEntries = dwSWAP( *TotalDirectoryEntries );
    *AvailableDirectoryEntries = dwSWAP( *AvailableDirectoryEntries );

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\nds32.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nds32.c

Abstract:

    This module implements functions to Read, Add, Modify, and Remove
    NDS Objects and Attributes using the Microsoft Netware redirector.

Author:

    Glenn Curtis    [GlennC]    04-Jan-1996 - New NDS function implementations
    Glenn Curtis    [GlennC]    24-Apr-1996 - Added schema APIs
    Glenn Curtis    [GlennC]    20-Jun-1996 - Added search API
    Felix Wong      [t-felixw]  24-Sep-1995 - Added Win95 Support
    Glenn Curtis    [GlennC]    20-Nov-1996 - Improved search API
    Glenn Curtis    [GlennC]    02-Jan-1997 - Added rename object API
    Tommy Evans     [tommye]    21-Apr-2000 - Moved the NDS_OBJECT typedef out and
                                                renamed to NDS_OBJECT_PRIV.

--*/

#include <procs.h>
#include <nds32.h>
#include <align.h>
#include <nwapi32.h>
#include <nwpkstr.h>

#ifdef WIN95
#include <msnwapi.h>
#include <utils95.h>
#include <ndsapi95.h>
#endif

/* Definitions */

#define NDS_SIGNATURE                            0x6E656C67 /* glen */
#define ONE_KB                                   1024
#define TWO_KB                                   (ONE_KB*2)
#define FOUR_KB                                  (ONE_KB*4)
#define EIGHT_KB                                 (ONE_KB*8)
#define SIXTEEN_KB                               (ONE_KB*16)
#define THIRY_TWO_KB                             (ONE_KB*32)
#define SIXTY_FOUR_KB                            (ONE_KB*64)
#define ONE_TWENTY_EIGHT_KB                      (ONE_KB*128)
#define NDS_MAX_BUFFER                           (ONE_KB*63)

#define NDS_SEARCH_ENTRY                         0
#define NDS_SEARCH_SUBORDINATES                  1
#define NDS_SEARCH_SUBTREE                       2

#define NDS_DEREF_ALIASES                        0x00000000
#define NDS_DONT_DEREF_ALIASES                   0x00010000

/* NetWare NDS NCP function identifiers */

#define NETWARE_NDS_FUNCTION_RESOLVE_NAME         0x00000001
#define NETWARE_NDS_FUNCTION_READ_OBJECT          0x00000003
#define NETWARE_NDS_FUNCTION_LIST                 0x00000005
#define NETWARE_NDS_FUNCTION_SEARCH               0x00000006
#define NETWARE_NDS_FUNCTION_ADD_OBJECT           0x00000007
#define NETWARE_NDS_FUNCTION_REMOVE_OBJECT        0x00000008
#define NETWARE_NDS_FUNCTION_MODIFY_OBJECT        0x00000009
#define NETWARE_NDS_FUNCTION_MODIFY_RDN           0x0000000A
#define NETWARE_NDS_FUNCTION_DEFINE_ATTR          0x0000000B
#define NETWARE_NDS_FUNCTION_READ_ATTR_DEF        0x0000000C
#define NETWARE_NDS_FUNCTION_REMOVE_ATTR_DEF      0x0000000D
#define NETWARE_NDS_FUNCTION_DEFINE_CLASS         0x0000000E
#define NETWARE_NDS_FUNCTION_READ_CLASS_DEF       0x0000000F
#define NETWARE_NDS_FUNCTION_MODIFY_CLASS         0x00000010
#define NETWARE_NDS_FUNCTION_REMOVE_CLASS_DEF     0x00000011
#define NETWARE_NDS_FUNCTION_LIST_CONT_CLASSES    0x00000012
#define NETWARE_NDS_FUNCTION_GET_EFFECTIVE_RIGHTS 0x00000013
#define NETWARE_NDS_FUNCTION_BEGIN_MOVE_OBJECT    0x0000002A
#define NETWARE_NDS_FUNCTION_FINISH_MOVE_OBJECT   0x0000002B
#define NETWARE_NDS_FUNCTION_GET_SERVER_ADDRESS   0x00000035


/* Data structure definitions */

typedef struct
{
    DWORD  dwBufferId;
    DWORD  dwOperation;

    //
    // About the request buffer
    //
    DWORD  dwRequestBufferSize;
    DWORD  dwRequestAvailableBytes;
    DWORD  dwNumberOfRequestEntries;
    DWORD  dwLengthOfRequestData;

    //
    // The request buffer
    //
    LPBYTE lpRequestBuffer;

    //
    // About the reply buffer
    //
    DWORD  dwReplyBufferSize;
    DWORD  dwReplyAvailableBytes;
    DWORD  dwNumberOfReplyEntries;
    DWORD  dwLengthOfReplyData;

    //
    // More about the reply buffer
    //
    DWORD  dwReplyInformationType;

    //
    // The reply buffer
    //
    LPBYTE lpReplyBuffer;

    //
    // About the index buffer
    //
    DWORD  dwIndexBufferSize;
    DWORD  dwIndexAvailableBytes;
    DWORD  dwNumberOfIndexEntries;
    DWORD  dwLengthOfIndexData;

    //
    // More about the index buffer
    //
    DWORD  dwCurrentIndexEntry;

    //
    // The index buffer
    //
    LPBYTE lpIndexBuffer;

    //
    // About the syntax buffer
    //
    DWORD  dwSyntaxBufferSize;
    DWORD  dwSyntaxAvailableBytes;
    DWORD  dwNumberOfSyntaxEntries;
    DWORD  dwLengthOfSyntaxData;

    //
    // The syntax buffer
    //
    LPBYTE lpSyntaxBuffer;

    //
    // A place to keep the search from object path ...
    //
    WCHAR szPath[NDS_MAX_NAME_CHARS + 1];

} NDS_BUFFER, * LPNDS_BUFFER;


/* Local Function Definitions */

VOID
PrepareAddEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    DWORD          dwSyntaxID,
    LPBYTE         lpAttributeValues,
    DWORD          dwValueCount,
    LPDWORD        lpdwLengthInBytes );

VOID
PrepareModifyEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    DWORD          dwSyntaxID,
    DWORD          dwAttrModificationOperation,
    LPBYTE         lpAttributeValues,
    DWORD          dwValueCount,
    LPDWORD        lpdwLengthInBytes );

VOID
PrepareReadEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    LPDWORD        lpdwLengthInBytes );

DWORD
CalculateValueDataSize(
    DWORD           dwSyntaxId,
    LPBYTE          lpAttributeValues,
    DWORD           dwValueCount );

VOID
AppendValueToEntry(
    LPBYTE  lpBuffer,
    DWORD   dwSyntaxId,
    LPBYTE  lpAttributeValues,
    DWORD   dwValueCount,
    LPDWORD lpdwLengthInBytes );

DWORD
MapNetwareErrorCode(
    DWORD dwNetwareError );

DWORD
IndexReadAttrDefReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer );

DWORD
IndexReadClassDefReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer );

DWORD
IndexReadObjectReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer );

DWORD
IndexReadNameReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer );

DWORD
IndexSearchObjectReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer );

DWORD
SizeOfASN1Structure(
    LPBYTE * lppRawBuffer,
    DWORD    dwSyntaxId );

DWORD
ParseASN1ValueBlob(
    LPBYTE RawDataBuffer,
    DWORD  dwSyntaxId,
    DWORD  dwNumberOfValues,
    LPBYTE SyntaxStructure );

DWORD
ParseStringListBlob(
    LPBYTE RawDataBuffer,
    DWORD  dwNumberOfStrings,
    LPBYTE SyntaxStructure );

DWORD
ReadAttrDef_AllAttrs(
    IN  HANDLE hTree,
    IN  DWORD  dwInformationType,
    OUT HANDLE lphOperationData );

DWORD
ReadAttrDef_SomeAttrs(
    IN     HANDLE hTree,
    IN     DWORD  dwInformationType,
    IN OUT HANDLE lphOperationData );

DWORD
ReadClassDef_AllClasses(
    IN  HANDLE hTree,
    IN  DWORD  dwInformationType,
    OUT HANDLE lphOperationData );

DWORD
ReadClassDef_SomeClasses(
    IN     HANDLE hTree,
    IN     DWORD  dwInformationType,
    IN OUT HANDLE lphOperationData );

DWORD
ReadObject_AllAttrs(
    IN  HANDLE   hObject,
    IN  DWORD    dwInformationType,
    OUT HANDLE * lphOperationData );

DWORD
ReadObject_SomeAttrs(
    IN     HANDLE   hObject,
    IN     DWORD    dwInformationType,
    IN OUT HANDLE * lphOperationData );

DWORD
Search_AllAttrs(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType,
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    OUT    HANDLE *     lphOperationData );

DWORD
Search_SomeAttrs(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType,
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    IN OUT HANDLE *     lphOperationData );

DWORD
GetFirstNdsSubTreeEntry(
    OUT LPNDS_OBJECT_PRIV lpNdsObject,
    IN  DWORD BufferSize );

DWORD
GetNextNdsSubTreeEntry(
    OUT LPNDS_OBJECT_PRIV lpNdsObject );

VOID
GetSubTreeData(
    IN  DWORD    NdsRawDataPtr,
    OUT LPDWORD  lpdwEntryId,
    OUT LPDWORD  lpdwSubordinateCount,
    OUT LPDWORD  lpdwModificationTime,
    OUT LPDWORD  lpdwClassNameLen,
    OUT LPWSTR * szClassName,
    OUT LPDWORD  lpdwObjectNameLen,
    OUT LPWSTR * szObjectName );

LPBYTE
GetSearchResultData( IN  LPBYTE   lpResultBufferPtr,
                     OUT LPDWORD  lpdwFlags,
                     OUT LPDWORD  lpdwSubordinateCount,
                     OUT LPDWORD  lpdwModificationTime,
                     OUT LPDWORD  lpdwClassNameLen,
                     OUT LPWSTR * szClassName,
                     OUT LPDWORD  lpdwObjectNameLen,
                     OUT LPWSTR * szObjectName,
                     OUT LPDWORD  lpdwEntryInfo1,
                     OUT LPDWORD  lpdwEntryInfo2 );

DWORD
WriteObjectToBuffer(
    IN OUT LPBYTE *        FixedPortion,
    IN OUT LPWSTR *        EndOfVariableData,
    IN     LPWSTR          ObjectFullName,
    IN     LPWSTR          ObjectName,
    IN     LPWSTR          ClassName,
    IN     DWORD           EntryId,
    IN     DWORD           ModificationTime,
    IN     DWORD           SubordinateCount,
    IN     DWORD           NumberOfAttributes,
    IN     LPNDS_ATTR_INFO lpAttributeInfos );

DWORD
VerifyBufferSize(
    IN  LPBYTE  lpRawBuffer,
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwSyntaxID,
    IN  DWORD   dwNumberOfValues,
    OUT LPDWORD lpdwLength );

DWORD
VerifyBufferSizeForStringList(
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwNumberOfValues,
    OUT LPDWORD lpdwLength );

DWORD
WriteQueryTreeToBuffer(
    IN  LPQUERY_TREE lpQueryTree,
    IN  LPNDS_BUFFER lpNdsBuffer );

DWORD
WriteQueryNodeToBuffer(
    IN  LPQUERY_NODE lpQueryNode,
    IN  LPNDS_BUFFER lpNdsBuffer );

DWORD
NwNdsGetServerDN(
    IN  HANDLE  hTree,
    OUT LPWSTR  szServerDN );

DWORD
AllocateOrIncreaseSyntaxBuffer(
    IN  LPNDS_BUFFER lpNdsBuffer );

DWORD
AllocateOrIncreaseRequestBuffer(
    IN  LPNDS_BUFFER lpNdsBuffer );


//
// Flags used for the function ParseNdsUncPath()
//
#define  PARSE_NDS_GET_TREE_NAME    0
#define  PARSE_NDS_GET_PATH_NAME    1
#define  PARSE_NDS_GET_OBJECT_NAME  2


WORD
ParseNdsUncPath( IN OUT LPWSTR * Result,
                 IN     LPWSTR   ObjectPathName,
                 IN     DWORD    flag );


/* Function Implementations */

DWORD
NwNdsAddObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName,
    IN  HANDLE hOperationData )
/*
   NwNdsAddObject()

   This function is used to add a leaf object to an NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object in
                        the directory tree to add a new leaf to. Handle is
                        obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name that the new leaf
                        object will be known by.

       HANDLE           hOperationData - A buffer containing a list of
                        attributes and values to create the new object. This
                        buffer is manipulated by the following functions:
                            NwNdsCreateBuffer (NDS_OBJECT_ADD),
                            NwNdsPutInBuffer, and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    NTSTATUS       ntstatus;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_BUFFER   lpNdsBuffer = (LPNDS_BUFFER) hOperationData;
    LPNDS_OBJECT_PRIV   lpNdsParentObject = (LPNDS_OBJECT_PRIV) hParentObject;
    UNICODE_STRING ObjectName;

    if ( lpNdsBuffer == NULL ||
         lpNdsParentObject == NULL ||
         szObjectName == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsBuffer->dwOperation != NDS_OBJECT_ADD ||
         lpNdsParentObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &ObjectName, szObjectName );

    ntstatus =
        FragExWithWait(
                     lpNdsParentObject->NdsTree,
                     NETWARE_NDS_FUNCTION_ADD_OBJECT,
                     NdsReply,
                     NDS_BUFFER_SIZE,
                     &dwReplyLength,
                     "DDDSDr",
                     0,                   // Version
                     0,                   // Flags
                     lpNdsParentObject->ObjectId,
                     &ObjectName,
                     lpNdsBuffer->dwNumberOfRequestEntries,
                     lpNdsBuffer->lpRequestBuffer, // Object attributes to be added
                     (WORD)lpNdsBuffer->dwLengthOfRequestData // Length of data
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsAddObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsAddObject: The add name response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsAddAttributeToClass(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName,
    IN  LPWSTR   szAttributeName )
/*
   NwNdsAddAttributeToClass()

   This function is used to modify the schema definition of a class by adding
   an optional attribute to a particular class. Modification of existing NDS
   class defintions is limited to only adding additional optional attributes.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name of the class definition to be
                        modified.

       LPWSTR           szAttributeName - The name of the attribute to be added
                        as an optional attribute to the class defintion in the
                        schema.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING ClassName;
    UNICODE_STRING AttributeName;

    if ( szAttributeName == NULL ||
         szClassName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &ClassName, szClassName );
    RtlInitUnicodeString( &AttributeName, szAttributeName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_MODIFY_CLASS,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DSDS",
                        0,          // Version
                        &ClassName,
                        1,          // Number of attributes
                        &AttributeName
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsAddAttributeToClass: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsAddAttributeToClass: The modify class definition response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsChangeUserPassword(
    IN  HANDLE hUserObject,
    IN  LPWSTR szOldPassword,
    IN  LPWSTR szNewPassword )
/*
   NwNdsChangeUserPassword()

   This function is used to change the password for a given user object
   in a NDS directory tree.

   Arguments:

       HANDLE           hUserObject - A handle to a specific user object in
                        the directory tree to change the password on. Handle
                        is obtained by calling NwNdsOpenObject.

       LPWSTR           szOldPassword - The current password set on the user
                        object hUserObject.

                          - OR -

                        If NwNdsChangeUserPassword is called from a client with
                        administrative priveleges to the specified user object
                        identified by hUserObject, then the szOldPassword
                        value can be blank (L""). This way resetting the user
                        password to szNewPassword.

       LPWSTR           szNewPassword - The new password to be set on the user
                        object hUserObject.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_UNSUCCESSFUL;
    UNICODE_STRING TreeNameStr;
    UNICODE_STRING UserNameStr;
    UNICODE_STRING OldPasswordStr;
    UNICODE_STRING NewPasswordStr;
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hUserObject;
    DWORD          tempStrLen = 0;
    LPWSTR         tempStr = NULL;

    tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                  lpNdsObject->szContainerName,
                                  PARSE_NDS_GET_TREE_NAME );

    TreeNameStr.Buffer = tempStr;
    TreeNameStr.Length = (WORD) tempStrLen;
    TreeNameStr.MaximumLength = (WORD) tempStrLen;

    tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                  lpNdsObject->szContainerName,
                                  PARSE_NDS_GET_PATH_NAME );

#ifndef WIN95
    UserNameStr.Buffer = tempStr;
    UserNameStr.Length = (WORD) tempStrLen;
    UserNameStr.MaximumLength = (WORD) tempStrLen;

    RtlInitUnicodeString( &OldPasswordStr, szOldPassword );
    RtlInitUnicodeString( &NewPasswordStr, szNewPassword );

    ntstatus = NwNdsChangePassword( lpNdsObject->NdsTree,
                                    &TreeNameStr,
                                    &UserNameStr,
                                    &OldPasswordStr,
                                    &NewPasswordStr );
#else
    {
        LPSTR pszUser = NULL;
        LPSTR pszOldPasswd = NULL;
        LPSTR pszNewPasswd = NULL;
        NW_STATUS nwstatus;
        if (!(pszUser = AllocateAnsiString(tempStr))) {
            ntstatus = STATUS_NO_MEMORY;
            goto Exit;
        }
        if (!(pszOldPasswd = AllocateAnsiString(szOldPassword))) {
            ntstatus = STATUS_NO_MEMORY;
            goto Exit;
        }
        if (!(pszNewPasswd= AllocateAnsiString(szNewPassword))) {
            ntstatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        nwstatus = NDSChangePassword( pszUser,
                                      pszOldPasswd,
                                      pszNewPasswd );
        ntstatus = MapNwToNtStatus(nwstatus);
    Exit:
        if (pszUser)
            FreeAnsiString(pszUser);
        if (pszOldPasswd)
            FreeAnsiString(pszOldPasswd);
        if (pszNewPasswd)
            FreeAnsiString(pszNewPasswd);
    }
#endif

    if ( ntstatus != STATUS_SUCCESS )
    {
        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
    }

    return status;
}


DWORD
NwNdsCloseObject(
    IN  HANDLE hObject )
/*
   NwNdsCloseObject()

   This function is used to close the handle used to manipulate an object
   in an NDS directory tree. The handle must be one Opened by NwNdsOpenObject.

   Arguments:

       HANDLE           lphObject - The handle of the object to be closed.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;

    if ( lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( lpNdsObject )
    {
        if ( lpNdsObject->NdsTree )
            CloseHandle( lpNdsObject->NdsTree );

        if ( lpNdsObject->NdsRawDataBuffer )
        {
            (void) LocalFree( (HLOCAL) lpNdsObject->NdsRawDataBuffer );
            lpNdsObject->NdsRawDataBuffer = 0;
            lpNdsObject->NdsRawDataSize = 0;
            lpNdsObject->NdsRawDataId = INITIAL_ITERATION;
            lpNdsObject->NdsRawDataCount = 0;
        }

        (void) LocalFree( (HLOCAL) lpNdsObject );
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    return NO_ERROR;
}


DWORD
NwNdsCreateBuffer(
    IN  DWORD    dwOperation,
    OUT HANDLE * lphOperationData )
/*
   NwNdsCreateBuffer()

   This function is used to create a buffer used to describe object
   transactions to a specific object in an NDS directory tree. This routine
   allocates memory and is automatically resized as needed during calls
   to NwNdsPutInBuffer. This buffer must be freed with NwNdsFreeBuffer.

   Arguments:

       DWORD            dwOperation - Indicates how buffer is to be utilized.
                        Use defined values NDS_OBJECT_ADD, NDS_OBJECT_MODIFY,
                        NDS_OBJECT_READ, NDS_SCHEMA_DEFINE_CLASS,
                        NDS_SCHEMA_READ_ATTR_DEF, NDS_SCHEMA_READ_CLASS_DEF,
                        NDS_OBJECT_LIST_SUBORDINATES, NDS_SEARCH.

       HANDLE *         lphOperationData - Address of a HANDLE handle to
                        receive created buffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_BUFFER lpNdsBuffer = NULL;
    DWORD        dwSizeOfBuffer = TWO_KB; // Initial size, grow as needed.

    switch( dwOperation )
    {
        case NDS_OBJECT_ADD:
        case NDS_OBJECT_MODIFY:
        case NDS_OBJECT_READ:
        case NDS_SCHEMA_DEFINE_CLASS:
        case NDS_SCHEMA_READ_ATTR_DEF:
        case NDS_SCHEMA_READ_CLASS_DEF:
        case NDS_OBJECT_LIST_SUBORDINATES:
        case NDS_SEARCH:
             break;

        default:
#if DBG
             KdPrint(( "NDS32: NwNdsCreateBuffer parameter dwOperation unknown 0x%.8X\n", dwOperation ));
             ASSERT( FALSE );
#endif

             SetLastError( ERROR_INVALID_PARAMETER );
             return (DWORD) UNSUCCESSFUL;
    }

    //
    // Allocate memory for the buffer.
    //
    lpNdsBuffer =
              (LPNDS_BUFFER) LocalAlloc( LPTR, sizeof(NDS_BUFFER) );

    if ( lpNdsBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsCreateBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Initialize the contents of the header structure.
    //
    lpNdsBuffer->dwBufferId = NDS_SIGNATURE;
    lpNdsBuffer->dwOperation = dwOperation;

    if ( dwOperation == NDS_OBJECT_LIST_SUBORDINATES )
    {
        lpNdsBuffer->dwIndexBufferSize = dwSizeOfBuffer;
        lpNdsBuffer->dwIndexAvailableBytes = dwSizeOfBuffer;
    }
    else
    {
        lpNdsBuffer->dwRequestBufferSize = dwSizeOfBuffer;
        lpNdsBuffer->dwRequestAvailableBytes = dwSizeOfBuffer;
    }

    //
    // NOTE: The following are set to zero by LPTR
    //
    // lpNdsBuffer->dwNumberOfRequestEntries = 0;
    // lpNdsBuffer->dwLengthOfRequestData = 0;

    // lpNdsBuffer->dwReplyBufferSize = 0;
    // lpNdsBuffer->dwReplyAvailableBytes = 0;
    // lpNdsBuffer->dwNumberOfReplyEntries = 0;
    // lpNdsBuffer->dwLengthOfReplyData = 0;

    // lpNdsBuffer->dwReplyInformationType = 0;

    // lpNdsBuffer->lpReplyBuffer = NULL;

    // lpNdsBuffer->dwNumberOfIndexEntries = 0;
    // lpNdsBuffer->dwLengthOfIndexData = 0;
    // lpNdsBuffer->dwCurrentIndexEntry = 0;

    // lpNdsBuffer->dwSyntaxBufferSize = 0;
    // lpNdsBuffer->dwSyntaxAvailableBytes = 0;
    // lpNdsBuffer->dwNumberOfSyntaxEntries = 0;
    // lpNdsBuffer->dwLengthOfSyntaxData = 0;

    // lpNdsBuffer->lpSyntaxBuffer = NULL;

    //
    // Now allocate the data buffer.
    //
    if ( dwOperation == NDS_OBJECT_LIST_SUBORDINATES )
    {
        lpNdsBuffer->lpIndexBuffer =
                            (LPBYTE) LocalAlloc( LPTR, dwSizeOfBuffer );

        if ( lpNdsBuffer->lpIndexBuffer == NULL )
        {
#if DBG
            KdPrint(( "NDS32: NwNdsCreateBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            (void) LocalFree((HLOCAL) lpNdsBuffer);
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }
    }
    else
    {
        lpNdsBuffer->lpRequestBuffer =
                            (LPBYTE) LocalAlloc( LPTR, dwSizeOfBuffer );

        if ( lpNdsBuffer->lpRequestBuffer == NULL )
        {
#if DBG
            KdPrint(( "NDS32: NwNdsCreateBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            (void) LocalFree((HLOCAL) lpNdsBuffer);
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    *lphOperationData = (HANDLE) lpNdsBuffer;

    return NO_ERROR;
}


DWORD
NwNdsCreateQueryNode(
    IN  DWORD          dwOperation,
    IN  LPVOID         lpLValue,
    IN  DWORD          dwSyntaxId,
    IN  LPVOID         lpRValue,
    OUT LPQUERY_NODE * lppQueryNode
)
/*
   NwNdsCreateQueryNode()

   This function is used to generate a tree node that is part of a query
   to be used with the function NwNdsSearch.

   Arguments:

       DWORD            dwOperation - Indicates the type of node to create
                        for a search query. Use one of the defined values
                        below:

                          NDS_QUERY_OR
                          NDS_QUERY_AND :
                            These operations must have both lpLValue and
                            lpRValue pointing to a QUERY_NODE structure.
                            In this case the dwSyntaxId value is ignored.

                          NDS_QUERY_NOT :
                            This operation must have lpLValue pointing to a
                            QUERY_NODE structure and lpRValue set to NULL.
                            In this case the dwSyntaxId value is ignored.

                          NDS_QUERY_EQUAL
                          NDS_QUERY_GE
                          NDS_QUERY_LE
                          NDS_QUERY_APPROX :
                            These operations must have lpLValue pointing to
                            a LPWSTR containing the name of an NDS attribute,
                            and lpRValue pointing to an ASN1 structure defined
                            in NdsSntx.h. dwSyntaxId must be set to the syntax
                            identifier of the ASN1 structure pointed to by
                            lpRValue.

                          NDS_QUERY_PRESENT :
                            This operation must have lpLValue pointing to a
                            LPWSTR containing the name of an NDS attribute,
                            and lpRValue set to NULL. In this case the
                            dwSyntaxId value is ignored.

       LPVOID           lpLValue - A pointer to either a QUERY_NODE structure
                        or a LPWSTR depending on the value for dwOperation.

       DWORD            dwSyntaxId - The syntax identifier of the ASN1
                        structure pointed to by lpRValue for the dwOperations
                        NDS_QUERY_EQUAL, NDS_QUERY_GE, NDS_QUERY_LE, or
                        NDS_QUERY_APPROX. For other dwOperation values, this
                        is ignored.

       LPVOID           lpRValue - A pointer to either a QUERY_NODE structure,
                        an ASN1 structure, or NULL, depending on the value for
                        dwOperation.

       LPQUERY_NODE *   lppQueryNode - Address of a LPQUERY_NODE to receive
                        a pointer to created node.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPWSTR szAttributeName;
    DWORD  dwAttributeNameLen;
    LPWSTR szRValueString;
    DWORD  dwRValueStringLen;

    switch( dwOperation )
    {
        case NDS_QUERY_OR :
        case NDS_QUERY_AND :

            if ( lpLValue == NULL || lpRValue == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode was not passed a pointer to an L or R value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            *lppQueryNode = (LPQUERY_NODE) LocalAlloc( LPTR,
                                                       sizeof(QUERY_NODE) );

            if ( *lppQueryNode == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return (DWORD) UNSUCCESSFUL;
            }

            (*lppQueryNode)->dwOperation = dwOperation;
            (*lppQueryNode)->dwSyntaxId = NDS_NO_MORE_ITERATIONS;
            (*lppQueryNode)->lpLVal = lpLValue;
            (*lppQueryNode)->lpRVal = lpRValue;

            break;

        case NDS_QUERY_NOT :

            if ( lpLValue == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            *lppQueryNode = (LPQUERY_NODE) LocalAlloc( LPTR,
                                                       sizeof(QUERY_NODE) );

            if ( *lppQueryNode == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return (DWORD) UNSUCCESSFUL;
            }

            (*lppQueryNode)->dwOperation = dwOperation;
            (*lppQueryNode)->dwSyntaxId = NDS_NO_MORE_ITERATIONS;
            (*lppQueryNode)->lpLVal = lpLValue;
            (*lppQueryNode)->lpRVal = NULL;

            break;

        case NDS_QUERY_EQUAL :
        case NDS_QUERY_GE :
        case NDS_QUERY_LE :
        case NDS_QUERY_APPROX :

            switch( dwSyntaxId )
            {
                case NDS_SYNTAX_ID_1 :
                case NDS_SYNTAX_ID_2 :
                case NDS_SYNTAX_ID_3 :
                case NDS_SYNTAX_ID_4 :
                case NDS_SYNTAX_ID_5 :
                case NDS_SYNTAX_ID_10 :
                case NDS_SYNTAX_ID_20 :
                    //
                    // This syntax is in the form of a LPWSTR.
                    //
                    szAttributeName = (LPWSTR) lpLValue;
                    dwAttributeNameLen = ROUND_UP_COUNT(
                                            ( wcslen( szAttributeName ) + 1 ) *
                                            sizeof(WCHAR),
                                            ALIGN_DWORD );
                    szRValueString = ((LPASN1_TYPE_1) lpRValue)->DNString;
                    dwRValueStringLen = ROUND_UP_COUNT(
                                           ( wcslen( szRValueString ) + 1 ) *
                                           sizeof(WCHAR),
                                           ALIGN_DWORD );

                    *lppQueryNode = (LPQUERY_NODE)
                     LocalAlloc( LPTR,
                                 sizeof(QUERY_NODE) +
                                 dwAttributeNameLen +
                                 dwRValueStringLen );

                    if ( *lppQueryNode == NULL )
                    {
#if DBG
                        KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        return (DWORD) UNSUCCESSFUL;
                    }

                    (*lppQueryNode)->dwOperation = dwOperation;
                    (*lppQueryNode)->dwSyntaxId = dwSyntaxId;
                    (*lppQueryNode)->lpLVal = *lppQueryNode;
                    (LPBYTE) (*lppQueryNode)->lpLVal += sizeof(QUERY_NODE);
                    wcscpy( (LPWSTR) (*lppQueryNode)->lpLVal, szAttributeName );
                    (*lppQueryNode)->lpRVal = (*lppQueryNode)->lpLVal;
                    (LPBYTE) (*lppQueryNode)->lpRVal += dwAttributeNameLen;
                    wcscpy( (LPWSTR) (*lppQueryNode)->lpRVal, szRValueString );

                    break;

                case NDS_SYNTAX_ID_7 :
                case NDS_SYNTAX_ID_8 :
                case NDS_SYNTAX_ID_22 :
                case NDS_SYNTAX_ID_24 :
                case NDS_SYNTAX_ID_27 :
                    //
                    // This syntax is in the form of a DWORD.
                    //

                    szAttributeName = (LPWSTR) lpLValue;
                    dwAttributeNameLen = ROUND_UP_COUNT(
                                            ( wcslen( szAttributeName ) + 1 ) *
                                            sizeof(WCHAR),
                                            ALIGN_DWORD );

                    *lppQueryNode = (LPQUERY_NODE)
                                              LocalAlloc( LPTR,
                                                          sizeof(QUERY_NODE) +
                                                          dwAttributeNameLen +
                                                          sizeof(ASN1_TYPE_8) );

                    if ( *lppQueryNode == NULL )
                    {
#if DBG
                        KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        return (DWORD) UNSUCCESSFUL;
                    }

                    (*lppQueryNode)->dwOperation = dwOperation;
                    (*lppQueryNode)->dwSyntaxId = dwSyntaxId;
                    (*lppQueryNode)->lpLVal = *lppQueryNode;
                    (LPBYTE) (*lppQueryNode)->lpLVal += sizeof(QUERY_NODE);
                    wcscpy( (LPWSTR) (*lppQueryNode)->lpLVal,
                            szAttributeName );
                    (*lppQueryNode)->lpRVal = (LPQUERY_NODE)((LPBYTE)((*lppQueryNode)->lpLVal) +
                                              dwAttributeNameLen);
                    ((LPASN1_TYPE_8)(*lppQueryNode)->lpRVal)->Integer =
                                      ((LPASN1_TYPE_8)lpRValue)->Integer;

                    break;

                case NDS_SYNTAX_ID_9 :
                    //
                    // This syntax is in the form of an Octet String.
                    //
                    szAttributeName = (LPWSTR) lpLValue;
                    dwAttributeNameLen = ROUND_UP_COUNT(
                                            ( wcslen( szAttributeName ) + 1 ) *
                                            sizeof(WCHAR),
                                            ALIGN_DWORD );

                    *lppQueryNode = (LPQUERY_NODE)
                     LocalAlloc( LPTR,
                                 sizeof(QUERY_NODE) +
                                 dwAttributeNameLen +
                                 sizeof( DWORD ) +
                                 ((LPASN1_TYPE_9) lpRValue)->Length + 1 );

                    if ( *lppQueryNode == NULL )
                    {
#if DBG
                        KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                        return (DWORD) UNSUCCESSFUL;
                    }

                    (*lppQueryNode)->dwOperation = dwOperation;
                    (*lppQueryNode)->dwSyntaxId = dwSyntaxId;
                    (*lppQueryNode)->lpLVal = *lppQueryNode;
                    (LPBYTE) (*lppQueryNode)->lpLVal += sizeof(QUERY_NODE);
                    wcscpy( (LPWSTR) (*lppQueryNode)->lpLVal, szAttributeName );
                    (*lppQueryNode)->lpRVal = (*lppQueryNode)->lpLVal;
                    (LPBYTE) (*lppQueryNode)->lpRVal += dwAttributeNameLen;
                    *((LPDWORD) (*lppQueryNode)->lpRVal) =
                                            ((LPASN1_TYPE_9) lpRValue)->Length;
                    (LPBYTE) (*lppQueryNode)->lpRVal += sizeof( DWORD );
                    memcpy( (*lppQueryNode)->lpRVal,
                            ((LPASN1_TYPE_9) lpRValue)->OctetString,
                            ((LPASN1_TYPE_9) lpRValue)->Length );
                    (LPBYTE) (*lppQueryNode)->lpRVal -= sizeof( DWORD );

                    break;

                default :
                    SetLastError( ERROR_NOT_SUPPORTED );
                    return (DWORD) UNSUCCESSFUL;
            }

            break;

        case NDS_QUERY_PRESENT :

            if ( lpLValue == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            szAttributeName = (LPWSTR) lpLValue;
            dwAttributeNameLen = ( wcslen( szAttributeName ) + 1 ) *
                                 sizeof(WCHAR);

            *lppQueryNode = (LPQUERY_NODE) LocalAlloc( LPTR,
                                                       sizeof(QUERY_NODE) +
                                                       dwAttributeNameLen );

            if ( *lppQueryNode == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return (DWORD) UNSUCCESSFUL;
            }

            (*lppQueryNode)->dwOperation = dwOperation;
            (*lppQueryNode)->dwSyntaxId = NDS_NO_MORE_ITERATIONS;
            (*lppQueryNode)->lpLVal = (*lppQueryNode);
            (LPBYTE) (*lppQueryNode)->lpLVal += sizeof(QUERY_NODE);
            wcscpy( (LPWSTR) (*lppQueryNode)->lpLVal, szAttributeName );
            (*lppQueryNode)->lpRVal = NULL;

            break;

        default :
#if DBG
            KdPrint(( "NDS32: NwNdsCreateQueryNode was passed an unidentified operation - 0x%.8X.\n", dwOperation ));
#endif

             SetLastError( ERROR_INVALID_PARAMETER );
             return (DWORD) UNSUCCESSFUL;
    }

    return NO_ERROR;
}


DWORD
NwNdsDefineAttribute(
    IN  HANDLE   hTree,
    IN  LPWSTR   szAttributeName,
    IN  DWORD    dwFlags,
    IN  DWORD    dwSyntaxID,
    IN  DWORD    dwLowerLimit,
    IN  DWORD    dwUpperLimit,
    IN  ASN1_ID  asn1ID )
/*
   NwNdsDefineAttribute()

   This function is used to create an attribute definition in the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szAttributeName - The name that the new attribute will
                        be referred to by.

       DWORD            dwFlags - Flags values to be set for new attribute
                        definition. Definitions for flag values are found at
                        the top of the file Nds32.h.

       DWORD            dwSyntaxID - The ID of the syntax structure to be use
                        for the new attribute. Syntax IDs and their associated
                        structures are defined in the file NdsSntx.h. According
                        to the NetWare NDS schema spec, there is and always will
                        be, only 28 (0..27) different syntaxes.

       DWORD            dwLowerLimit - The lower limit of a sized attribute
                        (dwFlags value set to NDS_SIZED_ATTR). Can be set to
                        zero if attribute is not sized.

       DWORD            dwUpperLimit - The upper limit of a sized attribute
                        (dwFlags value set to NDS_SIZED_ATTR). Can be set to
                        zero if attribute is not sized.

       ASN1_ID          asn1ID - The ASN.1 ID for the attribute. If no
                        attribute identifier has been registered, a
                        zero-length octet string is specified.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING AttributeName;

    if ( szAttributeName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &AttributeName, szAttributeName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_DEFINE_ATTR,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DDSDDDD",
                        0,          // Version
                        dwFlags,
                        &AttributeName,
                        dwSyntaxID,
                        dwLowerLimit,
                        dwUpperLimit,
                        0           // ASN1 Id
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDefineAttribute: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDefineAttribute: The define attribute response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsDefineClass(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName,
    IN  DWORD    dwFlags,
    IN  ASN1_ID  asn1ID,
    IN  HANDLE   hSuperClasses,
    IN  HANDLE   hContainmentClasses,
    IN  HANDLE   hNamingAttributes,
    IN  HANDLE   hMandatoryAttributes,
    IN  HANDLE   hOptionalAttributes )
/*
   NwNdsDefineClass()

   This function is used to create a class definition in the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name that the new class will
                        be referred to by.

       DWORD            dwFlags - Flags values to be set for new class
                        definition. Definitions for flag values are found at
                        the top of the file Nds32.h.

       ASN1_ID          asn1ID - The ASN.1 ID for the class. If no
                        class identifier has been registered, a
                        zero-length octet string is specified.

       HANDLE(S)        hSuperClasses,
                        hContainmentClasses,
                        hNamingAttributes,
                        hMandatoryAttributes,
                        hOptionalAttributes -

                        Handle to buffers that contain class definition
                        information to create new class in schema.
                        These handles are manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_DEFINE_CLASS),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                - OR -

                        Handles can be NULL to indicate that no list
                        is associated with the specific class defintion
                        item.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING ClassName;
    LPNDS_BUFFER   lpSuperClasses = (LPNDS_BUFFER) hSuperClasses;
    LPNDS_BUFFER   lpContainmentClasses = (LPNDS_BUFFER) hContainmentClasses;
    LPNDS_BUFFER   lpNamingAttributes = (LPNDS_BUFFER) hNamingAttributes;
    LPNDS_BUFFER   lpMandatoryAttributes = (LPNDS_BUFFER) hMandatoryAttributes;
    LPNDS_BUFFER   lpOptionalAttributes = (LPNDS_BUFFER) hOptionalAttributes;

    DWORD          NumberOfSuperClasses = 0;
    DWORD          NumberOfContainmentClasses = 0;
    DWORD          NumberOfNamingAttributes = 0;
    DWORD          NumberOfMandatoryAttributes = 0;
    DWORD          NumberOfOptionalAttributes = 0;

    WORD           SuperClassesBufferLength = 0;
    WORD           ContainmentClassesBufferLength = 0;
    WORD           NamingAttributesBufferLength = 0;
    WORD           MandatoryAttributesBufferLength = 0;
    WORD           OptionalAttributesBufferLength = 0;

    LPBYTE         SuperClassesBuffer = NULL;
    LPBYTE         ContainmentClassesBuffer = NULL;
    LPBYTE         NamingAttributesBuffer = NULL;
    LPBYTE         MandatoryAttributesBuffer = NULL;
    LPBYTE         OptionalAttributesBuffer = NULL;

    if ( szClassName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( lpSuperClasses )
    {
        if ( lpSuperClasses->dwBufferId != NDS_SIGNATURE ||
             lpSuperClasses->dwOperation != NDS_SCHEMA_DEFINE_CLASS )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
        }

        NumberOfSuperClasses = lpSuperClasses->dwNumberOfRequestEntries,
        SuperClassesBuffer = lpSuperClasses->lpRequestBuffer,
        SuperClassesBufferLength = (WORD)lpSuperClasses->dwLengthOfRequestData;
    }

    if ( lpContainmentClasses )
    {
        if ( lpContainmentClasses->dwBufferId != NDS_SIGNATURE ||
             lpContainmentClasses->dwOperation != NDS_SCHEMA_DEFINE_CLASS )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
        }

        NumberOfContainmentClasses =
                lpContainmentClasses->dwNumberOfRequestEntries,
        ContainmentClassesBuffer =
                lpContainmentClasses->lpRequestBuffer,
        ContainmentClassesBufferLength =
                (WORD)lpContainmentClasses->dwLengthOfRequestData;
    }

    if ( lpNamingAttributes )
    {
        if ( lpNamingAttributes->dwBufferId != NDS_SIGNATURE ||
             lpNamingAttributes->dwOperation != NDS_SCHEMA_DEFINE_CLASS )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
        }

        NumberOfNamingAttributes =
                lpNamingAttributes->dwNumberOfRequestEntries,
        NamingAttributesBuffer =
                lpNamingAttributes->lpRequestBuffer,
        NamingAttributesBufferLength =
                (WORD)lpNamingAttributes->dwLengthOfRequestData;
    }

    if ( lpMandatoryAttributes )
    {
        if ( lpMandatoryAttributes->dwBufferId != NDS_SIGNATURE ||
             lpMandatoryAttributes->dwOperation != NDS_SCHEMA_DEFINE_CLASS )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
        }

        NumberOfMandatoryAttributes =
                lpMandatoryAttributes->dwNumberOfRequestEntries,
        MandatoryAttributesBuffer =
                lpMandatoryAttributes->lpRequestBuffer,
        MandatoryAttributesBufferLength =
                (WORD)lpMandatoryAttributes->dwLengthOfRequestData;
    }

    if ( lpOptionalAttributes )
    {
        if ( lpOptionalAttributes->dwBufferId != NDS_SIGNATURE ||
             lpOptionalAttributes->dwOperation != NDS_SCHEMA_DEFINE_CLASS )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
        }

        NumberOfOptionalAttributes =
                lpOptionalAttributes->dwNumberOfRequestEntries,
        OptionalAttributesBuffer =
                lpOptionalAttributes->lpRequestBuffer,
        OptionalAttributesBufferLength =
                (WORD)lpOptionalAttributes->dwLengthOfRequestData;
    }

    RtlInitUnicodeString( &ClassName, szClassName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_DEFINE_CLASS,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DDSDDrDrDrDrDr",
                        0,          // Version
                        dwFlags,
                        &ClassName,
                        0,          // ASN1 Id
                        NumberOfSuperClasses,
                        SuperClassesBuffer,
                        SuperClassesBufferLength,
                        NumberOfContainmentClasses,
                        ContainmentClassesBuffer,
                        ContainmentClassesBufferLength,
                        NumberOfNamingAttributes,
                        NamingAttributesBuffer,
                        NamingAttributesBufferLength,
                        NumberOfMandatoryAttributes,
                        MandatoryAttributesBuffer,
                        MandatoryAttributesBufferLength,
                        NumberOfOptionalAttributes,
                        OptionalAttributesBuffer,
                        OptionalAttributesBufferLength
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDefineClass: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDefineClass: The define class response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsDeleteAttrDef(
    IN  HANDLE   hTree,
    IN  LPWSTR   szAttributeName )
/*
   NwNdsDeleteAttrDef()

   This function is used to remove an attribute definition from the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szAttributeName - The name of the attribute
                        defintion to remove.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING AttributeName;

    if ( szAttributeName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &AttributeName, szAttributeName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_REMOVE_ATTR_DEF,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DS",
                        0,          // Version
                        &AttributeName
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDeleteAttrDef: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDeleteAttrDef: The delete attribute response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsDeleteClassDef(
    IN  HANDLE   hTree,
    IN  LPWSTR   szClassName )
/*
   NwNdsDeleteClassDef()

   This function is used to remove a class definition from the schema of
   NDS tree hTree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szClassName - The name of the class defintion to remove.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING ClassName;

    if ( szClassName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &ClassName, szClassName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_REMOVE_CLASS_DEF,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DS",
                        0,          // Version
                        &ClassName
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDeleteClassDef: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsDeleteClassDef: The delete class response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


VOID
NwNdsDeleteQueryNode(
    IN  LPQUERY_NODE lpQueryNode
)
/*
   NwNdsDeleteQueryNode()

   This function is used to free a tree node that was part of a query
   used with the function NwNdsSearch.

   Arguments:

       LPQUERY_NODE     lpQueryNode - A pointer to a particular node of
                        a query tree that defines a search. The tree is
                        created manually by the user through the function
                        NwNdsCreateQueryNode.

    Returns:

       Nothing
*/
{
    (void) LocalFree( (HLOCAL) lpQueryNode );

    lpQueryNode = NULL;
}


DWORD
NwNdsDeleteQueryTree(
    IN  LPQUERY_TREE lpQueryTree
)
/*
   NwNdsDeleteQueryTree()

   This function is used to free a tree that describes a query that was
   used with the function NwNdsSearch.

   Arguments:

       LPQUERY_TREE     lpQueryTree - A pointer to the root of a query
                        tree that defines a search.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD status;

    switch( lpQueryTree->dwOperation )
    {
        case NDS_QUERY_OR :
        case NDS_QUERY_AND :

            if ( lpQueryTree->lpLVal == NULL || lpQueryTree->lpRVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsDeleteQueryTree was not passed a pointer to an L or R value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            status = NwNdsDeleteQueryTree( lpQueryTree->lpLVal );

            if ( status != NO_ERROR )
            {
                return status;
            }

            lpQueryTree->lpLVal = NULL;

            status = NwNdsDeleteQueryTree( lpQueryTree->lpRVal );

            if ( status != NO_ERROR )
            {
                return status;
            }

            lpQueryTree->lpRVal = NULL;

            NwNdsDeleteQueryNode( lpQueryTree );

            break;

        case NDS_QUERY_NOT :

            if ( lpQueryTree->lpLVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: NwNdsCreateQueryNode was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            status = NwNdsDeleteQueryTree( lpQueryTree->lpLVal );

            if ( status != NO_ERROR )
            {
                return status;
            }

            lpQueryTree->lpLVal = NULL;

            NwNdsDeleteQueryNode( lpQueryTree );

            break;

        case NDS_QUERY_EQUAL :
        case NDS_QUERY_GE :
        case NDS_QUERY_LE :
        case NDS_QUERY_APPROX :
        case NDS_QUERY_PRESENT :

            NwNdsDeleteQueryNode( lpQueryTree );

            break;

        default :
#if DBG
            KdPrint(( "NDS32: NwNdsDeleteQueryTree was passed an unidentified operation - 0x%.8X.\n", lpQueryTree->dwOperation ));
#endif

             SetLastError( ERROR_INVALID_PARAMETER );
             return (DWORD) UNSUCCESSFUL;
    }

    return NO_ERROR;
}


DWORD
NwNdsFreeBuffer(
    IN  HANDLE hOperationData
                     )
/*
   NwNdsFreeBuffer()

   This function is used to free the buffer used to describe object
   operations to a specific object in an NDS directory tree. The buffer must
   be one created by NwNdsCreateBuffer, or returned by calling NwNdsReadObject,
   NwNdsReadAttrDef, or NwNdsReadClassDef.

   Arguments:

       HANDLE           hOperationData - Handle to buffer that is to be freed.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD        status = NO_ERROR;
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) hOperationData;

    if ( lpNdsBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsFreeBuffer was passed a NULL buffer pointer.\n" ));
#endif

        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( lpNdsBuffer->dwBufferId != NDS_SIGNATURE )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsFreeBuffer was passed an unidentified buffer.\n" ));
        ASSERT( FALSE );
#endif

        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // If this buffer contains a pointer to an index buffer. Need to free
    // the index buffer.
    //
    if ( lpNdsBuffer->lpIndexBuffer )
    {
        if ( lpNdsBuffer->dwOperation == NDS_SEARCH &&
             lpNdsBuffer->dwNumberOfIndexEntries )
        {
            LPNDS_OBJECT_INFO lpObjectInfo = (LPNDS_OBJECT_INFO)
                                                    lpNdsBuffer->lpIndexBuffer;
            DWORD iter;

            for ( iter = 0; iter < lpNdsBuffer->dwNumberOfIndexEntries; iter++ )
            {
                (void) LocalFree( (HLOCAL) lpObjectInfo[iter].lpAttribute );
                lpObjectInfo[iter].lpAttribute = NULL;
                lpObjectInfo[iter].dwNumberOfAttributes = 0;
            }
        }

        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpIndexBuffer );
        lpNdsBuffer->lpIndexBuffer = NULL;
    }

    //
    // If this buffer contains a pointer to a reply buffer. Need to free
    // the reply buffer.
    //
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
    }

    //
    // If this buffer contains a pointer to a request buffer. Need to free
    // the request buffer.
    //
    if ( lpNdsBuffer->lpRequestBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpRequestBuffer );
        lpNdsBuffer->lpRequestBuffer = NULL;
    }

    //
    // If this buffer contains a pointer to a syntax buffer. Need to free
    // the syntax buffer.
    //
    if ( lpNdsBuffer->lpSyntaxBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpSyntaxBuffer );
        lpNdsBuffer->lpSyntaxBuffer = NULL;
    }

    //
    // Now free the handle buffer.
    //
    (void) LocalFree((HLOCAL) lpNdsBuffer);

    return NO_ERROR;
}


DWORD
NwNdsGetAttrDefListFromBuffer(
    IN  HANDLE   hOperationData,
    OUT LPDWORD  lpdwNumberOfEntries,
    OUT LPDWORD  lpdwInformationType,
    OUT LPVOID * lppEntries )
/*
   NwNdsGetAttrDefListFromBuffer()

   This function is used to retrieve an array of attribute definition entries
   for a schema that was read with a prior call to NwNdsReadAttrDef.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadAttrDef.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwInformationType - The address of a DWORD to
                        receive a value that indicates the type of information
                        returned by the call to NwNdsReadAttrDef.

       LPVOID *         lppEntries - The address of a pointer to the beginning
                        of an array of attribute schema structures. Each
                        structure contains the details of each attribute
                        definition read from a given schema by calling
                        NwNdsReadAttrDef. The lppEntries value should be
                        cast to either a LPNDS_ATTR_DEF or LPNDS_NAME_ONLY
                        structure depending on the value returned in
                        lpdwInformationType.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_BUFFER    lpNdsBuffer = (LPNDS_BUFFER) hOperationData;

    //
    // Check to see if the data handle is one for reading attribute definitions.
    //
    if ( lpNdsBuffer == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsBuffer->dwOperation != NDS_SCHEMA_READ_ATTR_DEF )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if NwNdsReadAttrDef has been called yet.
    //
    if ( lpNdsBuffer->lpReplyBuffer == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if the call to NwNdsReadAttrDef returned any attributes.
    //
    if ( lpNdsBuffer->dwNumberOfReplyEntries == 0 )
    {
        SetLastError( ERROR_NO_DATA );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // If TRUE, we need to walk raw response to set indexes to data within.
    //
    if ( lpNdsBuffer->lpIndexBuffer == NULL )
    {
        DWORD status;

        if ( lpNdsBuffer->dwReplyInformationType == NDS_INFO_NAMES )
        {
            status = IndexReadNameReplyBuffer( lpNdsBuffer );
        }
        else
        {
            status = IndexReadAttrDefReplyBuffer( lpNdsBuffer );
        }

        if ( status )
        {
            SetLastError( status );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    lpNdsBuffer->dwCurrentIndexEntry = 0;
    *lpdwNumberOfEntries = lpNdsBuffer->dwNumberOfIndexEntries;
    *lpdwInformationType = lpNdsBuffer->dwReplyInformationType;
    *lppEntries = (LPVOID) lpNdsBuffer->lpIndexBuffer;

    return NO_ERROR;
}


DWORD
NwNdsGetAttrListFromBuffer(
    IN  HANDLE            hOperationData,
    OUT LPDWORD           lpdwNumberOfEntries,
    OUT LPNDS_ATTR_INFO * lppEntries )
/*
   NwNdsGetAttrListFromBuffer()

   This function is used to retrieve an array of attribute entries for an
   object that was read with a prior call to NwNdsReadObject.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadObject.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPNDS_ATTR_INFO *
                        lppEntries - The address of a pointer to the beginning
                        of an array of NDS_ATTR_INFO structures. Each
                        structure contains the details of each attribute read
                        from a given object by calling NwNdsReadObject.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_BUFFER    lpNdsBuffer = (LPNDS_BUFFER) hOperationData;

    //
    // Check to see if the data handle is one for reading attributes.
    //
    if ( lpNdsBuffer == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsBuffer->dwOperation != NDS_OBJECT_READ )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if NwNdsReadObject has been called yet.
    //
    if ( lpNdsBuffer->lpReplyBuffer == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if the call to NwNdsReadObject returned any attributes.
    //
    if ( lpNdsBuffer->dwNumberOfReplyEntries == 0 )
    {
        SetLastError( ERROR_NO_DATA );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // If TRUE, we need to walk raw response to set indexes to data within.
    //
    if ( lpNdsBuffer->lpIndexBuffer == NULL )
    {
        DWORD status;

        if ( lpNdsBuffer->dwReplyInformationType == NDS_INFO_NAMES )
        {
            status = IndexReadNameReplyBuffer( lpNdsBuffer );
        }
        else
        {
            status = IndexReadObjectReplyBuffer( lpNdsBuffer );
        }

        if ( status )
        {
            SetLastError( status );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    ASSERT( lpNdsBuffer->lpIndexBuffer != NULL );

    lpNdsBuffer->dwCurrentIndexEntry = 0;
    *lpdwNumberOfEntries = lpNdsBuffer->dwNumberOfIndexEntries;
    *lppEntries = (LPNDS_ATTR_INFO) lpNdsBuffer->lpIndexBuffer;

    return NO_ERROR;
}


DWORD
NwNdsGetClassDefListFromBuffer(
    IN  HANDLE   hOperationData,
    OUT LPDWORD  lpdwNumberOfEntries,
    OUT LPDWORD  lpdwInformationType,
    OUT LPVOID * lppEntries )
/*
   NwNdsGetClassDefListFromBuffer()

   This function is used to retrieve an array of class definition entries
   for a schema that was read with a prior call to NwNdsReadClassDef.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsReadClassDef.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwInformationType - The address of a DWORD to
                        receive a value that indicates the type of information
                        returned by the call to NwNdsReadClassDef.

       LPVOID *         lppEntries - The address of a pointer to the beginning
                        of an array of schema class structures. Each
                        structure contains the details of each class
                        definition read from a given schema by calling
                        NwNdsReadClassDef. The lppEntries value should be
                        cast to either a LPNDS_CLASS_DEF or LPNDS_DEF_NAME_ONLY
                        structure depending on the value returned in
                        lpdwInformationType.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_BUFFER    lpNdsBuffer = (LPNDS_BUFFER) hOperationData;

    //
    // Check to see if the data handle is one for reading class definitions.
    //
    if ( lpNdsBuffer == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsBuffer->dwOperation != NDS_SCHEMA_READ_CLASS_DEF )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if NwNdsReadClassDef has been called yet.
    //
    if ( lpNdsBuffer->lpReplyBuffer == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if the call to NwNdsReadClassDef returned any classes.
    //
    if ( lpNdsBuffer->dwNumberOfReplyEntries == 0 )
    {
        SetLastError( ERROR_NO_DATA );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // If TRUE, we need to walk raw response to set indexes to data within.
    //
    if ( lpNdsBuffer->lpIndexBuffer == NULL )
    {
        DWORD status;

        if ( lpNdsBuffer->dwReplyInformationType == NDS_INFO_NAMES )
        {
            status = IndexReadNameReplyBuffer( lpNdsBuffer );
        }
        else
        {
            status = IndexReadClassDefReplyBuffer( lpNdsBuffer );
        }

        if ( status )
        {
            SetLastError( status );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    ASSERT( lpNdsBuffer->lpIndexBuffer != NULL );

    lpNdsBuffer->dwCurrentIndexEntry = 0;
    *lpdwNumberOfEntries = lpNdsBuffer->dwNumberOfIndexEntries;
    *lpdwInformationType = lpNdsBuffer->dwReplyInformationType;
    *lppEntries = (LPVOID) lpNdsBuffer->lpIndexBuffer;

    return NO_ERROR;
}


DWORD
NwNdsGetEffectiveRights(
    IN  HANDLE  hObject,
    IN  LPWSTR  szSubjectName,
    IN  LPWSTR  szAttributeName,
    OUT LPDWORD lpdwRights )
/*
   NwNdsGetEffectiveRights()

   This function is used to determine the effective rights of a particular
   subject on a particular object in the NDS tree. The user needs to have
   appropriate priveleges to make the determination.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to determine effective rights on. Handle is
                        obtained by calling NwNdsOpenObject.

       LPWSTR           szSubjectName - The distinguished name of user whose
                        rights we're interested in determining.

       LPWSTR           szAttributeName - Regular attribute name (i.e.
                        L"Surname" , L"CN" ) for reading a particular
                        attribute right, or L"[All Attribute Rights]" and
                        L"[Entry Rights]" can be used to determine the default
                        attribute rights and object rights respectively.

       LPDWORD          lpdwRights - A pointer to a DWORD to receive the
                        results. If the call is successful, lpdwRights will
                        contain a mask representing the subject's rights:

                           Attribute rights -  NDS_RIGHT_COMPARE_ATTR,
                              NDS_RIGHT_READ_ATTR, NDS_RIGHT_WRITE_ATTR,
                              NDS_RIGHT_ADD_SELF_ATTR, and
                              NDS_RIGHT_SUPERVISE_ATTR.

                           Object rights - NDS_RIGHT_BROWSE_OBJECT,
                              NDS_RIGHT_CREATE_OBJECT, NDS_RIGHT_DELETE_OBJECT,
                              NDS_RIGHT_RENAME_OBJECT, and
                              NDS_RIGHT_SUPERVISE_OBJECT.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;
    UNICODE_STRING SubjectName;
    UNICODE_STRING AttributeName;

    if ( szAttributeName == NULL ||
         szSubjectName == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &SubjectName, szSubjectName );
    RtlInitUnicodeString( &AttributeName, szAttributeName );

    ntstatus =
        FragExWithWait(
                        lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_GET_EFFECTIVE_RIGHTS,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DDSS",
                        0,          // Version
                        lpNdsObject->ObjectId,
                        &SubjectName,
                        &AttributeName
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetEffectiveRights: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetEffectiveRights: The status code response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        return nwstatus;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "G_D",
                              1 * sizeof(DWORD),
                              lpdwRights );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetEffectiveRights: The effective rights response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsGetObjectListFromBuffer(
    IN  HANDLE              hOperationData,
    OUT LPDWORD             lpdwNumberOfEntries,
    OUT LPDWORD             lpdwAttrInformationType OPTIONAL,
    OUT LPNDS_OBJECT_INFO * lppEntries )
/*
   NwNdsGetObjectListFromBuffer()

   This function is used to retrieve an array of object entries for
   objects that were read with a prior call to either
   NwNdsListSubObjects or NwNdsSearch.

   Arguments:

       HANDLE           hOperationData - Buffer containing the read
                        response from calling NwNdsListSubObjects, or a
                        buffer containing the search results from a call
                        to NwNdsSearch.

       LPDWORD          lpdwNumberOfEntries - The address of a DWORD to
                        receive the number of array elements pointed to by
                        lppEntries.

       LPDWORD          lpdwAttrInformationType - The address of a DWORD to
                        receive a value that indicates the type of attribute
                        information returned by the call to NwNdsSearch.
                        This attribute information type determines which
                        buffer structure (LPNDS_ATTR_INFO or LPNDS_NAME_ONLY)
                        should be used for the lpAttribute field found in
                        each NDS_OBJECT_INFO structure below.

                        - or -

                        NULL to indicate that the callee is not interested,
                        especially when the object list is that from a call
                        to NwNdsListSubObjects.

       LPNDS_OBJECT_INFO *
                        lppEntries - The address of a pointer to the beginning
                        of an array of NDS_OBJECT_INFO structures. Each
                        structure contains the details of each object returned
                        from a call to NwNdsListSubObjects or NwNdsSearch.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) hOperationData;

    *lpdwNumberOfEntries = 0;
    *lppEntries = NULL;

    //
    // Check to see if the data handle is one for listing subordinates or
    // for searching.
    //
    if ( lpNdsBuffer == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         ( lpNdsBuffer->dwOperation != NDS_OBJECT_LIST_SUBORDINATES &&
           lpNdsBuffer->dwOperation != NDS_SEARCH ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if the call to NwNdsListSubObjects returned any objects.
    //
    if ( lpNdsBuffer->dwOperation == NDS_OBJECT_LIST_SUBORDINATES &&
         lpNdsBuffer->dwNumberOfIndexEntries == 0 )
    {
        SetLastError( ERROR_NO_DATA );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if the call to NwNdsSearch returned any objects.
    //
    if ( lpNdsBuffer->dwOperation == NDS_SEARCH &&
         lpNdsBuffer->dwNumberOfReplyEntries == 0 )
    {
        SetLastError( ERROR_NO_DATA );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // If TRUE, we need to walk raw response to set indexes to data within.
    //
    if ( lpNdsBuffer->dwOperation == NDS_SEARCH &&
         lpNdsBuffer->lpIndexBuffer == NULL )
    {
        DWORD status;

        status = IndexSearchObjectReplyBuffer( lpNdsBuffer );

        if ( status )
        {
            SetLastError( status );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    ASSERT( lpNdsBuffer->lpIndexBuffer != NULL );

    lpNdsBuffer->dwCurrentIndexEntry = 0;
    *lpdwNumberOfEntries = lpNdsBuffer->dwNumberOfIndexEntries;
    *lppEntries = (LPNDS_OBJECT_INFO) lpNdsBuffer->lpIndexBuffer;

    if ( lpdwAttrInformationType )
    {
        *lpdwAttrInformationType = lpNdsBuffer->dwReplyInformationType;
    }

    return NO_ERROR;
}


DWORD
NwNdsGetSyntaxID(
    IN  HANDLE  hTree,
    IN  LPWSTR  szlpAttributeName,
    OUT LPDWORD lpdwSyntaxID )
/*
   NwNdsGetObjListFromBuffer()

   This function is used to retrieve the Syntax ID of a given attribute name.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szlpAttributeName - The attribute name whose Syntax ID
                        is requested.

       LPDWORD          lpdwSyntaxID - The address of a DWORD to receive the
                        SyntaxID.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    UNICODE_STRING AttributeName;
    DWORD          dwNumEntries;
    DWORD          dwStringLen;
    LPBYTE         lpByte;
    DWORD          LengthInBytes;
    LPBYTE         lpTempEntry = NULL;

    if ( lpNdsObject == NULL ||
         szlpAttributeName == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &AttributeName, szlpAttributeName );

    // allocate enough extra space for the padding PrepareReadEntry will do
    lpTempEntry = LocalAlloc( LPTR, AttributeName.Length + (2*sizeof(DWORD)) );

    if ( ! lpTempEntry )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }
    PrepareReadEntry( lpTempEntry,
                      AttributeName,
                      &LengthInBytes );


    ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                               NETWARE_NDS_FUNCTION_READ_ATTR_DEF,
                               NdsReply,
                               NDS_BUFFER_SIZE,
                               &dwReplyLength,
                               "DDDDDr",
                               0,             // Version
                               NDS_NO_MORE_ITERATIONS, // Initial iteration
                               NDS_INFO_NAMES_DEFS,
                               (DWORD) FALSE, // All attributes indicator
                               1,             // Number of attributes
                               lpTempEntry,
                               LengthInBytes);

    (void) LocalFree((HLOCAL) lpTempEntry );
    
    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetSyntaxID: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetSyntaxID: The get syntax id response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( nwstatus )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetSyntaxID: NetWare error 0x%.8X reading %ws.\n", nwstatus, szlpAttributeName ));
#endif
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        return nwstatus;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "G_D",
                              3 * sizeof(DWORD),
                              &dwNumEntries );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetSyntaxID: The attribute read response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ASSERT( dwNumEntries == 1 );

    //
    // Set lpByte to the point in the reply buffer that has the attribute
    // name length.
    //
    lpByte = NdsReply + ( 4 * sizeof(DWORD) );

    //
    // Get the attribute name length and move lpByte to beginning of
    // attribute name
    //
    dwStringLen = * (LPDWORD) lpByte;
    lpByte += sizeof(DWORD);

    //
    // Move lpByte past the attribute name so that it points to the
    // attribute flags value
    //
    lpByte += ROUND_UP_COUNT( dwStringLen,
                              ALIGN_DWORD);

    //
    // Move lpByte past the attribute flags value so that it now points to
    // the attribute syntax id value
    //
    lpByte += sizeof(DWORD);
    *lpdwSyntaxID = * (LPDWORD) lpByte;
    return NO_ERROR;
}


DWORD
NwNdsListSubObjects(
    IN  HANDLE   hParentObject,
    IN  DWORD    dwEntriesRequested,
    OUT LPDWORD  lpdwEntriesReturned,
    IN  LPNDS_FILTER_LIST lpFilters OPTIONAL,
    OUT HANDLE * lphOperationData )
/*
   NwNdsListSubObjects()

   This function is used to enumerate the subordinate objects for a particular
   parent object. A filter can be passed in to restrict enumeration to a
   a specific class type or list of class types.

   Arguments:

       HANDLE           hParentObject - A handle to the object in the directory
                        tree whose subordinate objects (if any) will be
                        enumerated.

       DWORD            dwEntriesRequested - The number of subordinate objects
                        to list. A subsequent call to NwNdsListSubObjects will
                        continue enumeration following the last item returned.

       LPDWORD          lpdwEntriesReturned - A pointer to a DWORD that will
                        contain the actual number of subobjects enumerated in
                        the call.

       LPNDS_FILTER_LIST lpFilters - The caller can specify the object class
                         names for the kinds of objects that they would like
                         to enumerate. For example if just User and Group
                         object classes should be enumerated, then a filter
                         for class names NDS_CLASS_USER and NDS_CLASS_GROUP
                         should be pass in.

                                - or -

                         NULL to indicate that all objects should be returned
                         (no filter).

       HANDLE *         lphOperationData - Address of a HANDLE handle to
                        receive created buffer that contains the list of
                        subordinate objects read from the object
                        hParentObject. This handle is manipulated by the
                        following functions:
                           NwNdsGetObjListFromBuffer and NwNdsFreeBuffer.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD        status = NO_ERROR;
    LPNDS_BUFFER lpNdsBuffer = NULL;
    LPNDS_OBJECT_PRIV lpNdsParentObject = (LPNDS_OBJECT_PRIV) hParentObject;
    LPBYTE FixedPortion = NULL;
    LPWSTR EndOfVariableData = NULL;
    BOOL  FitInBuffer = TRUE;

    //
    // Test the parameters.
    //
    if ( lpNdsParentObject == NULL ||
         lpNdsParentObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( lpNdsParentObject->ResumeId == NDS_NO_MORE_ITERATIONS )
    {
        if ( lpNdsParentObject->NdsRawDataBuffer )
        {
            (void) LocalFree( (HLOCAL) lpNdsParentObject->NdsRawDataBuffer );
            lpNdsParentObject->NdsRawDataBuffer = 0;
            lpNdsParentObject->NdsRawDataSize = 0;
            lpNdsParentObject->NdsRawDataId = INITIAL_ITERATION;
            lpNdsParentObject->NdsRawDataCount = 0;
        }

        //
        // Reached the end of enumeration.
        //
        return WN_NO_MORE_ENTRIES;
    }

    //
    // Allocate a results buffer
    //
    status = NwNdsCreateBuffer( NDS_OBJECT_LIST_SUBORDINATES,
                                (HANDLE *) &lpNdsBuffer );

    if ( status )
    {
        return status;
    }

    FixedPortion = lpNdsBuffer->lpIndexBuffer;
    EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                          ROUND_DOWN_COUNT(
                                  lpNdsBuffer->dwIndexAvailableBytes,
                                  ALIGN_DWORD ) );

    *lpdwEntriesReturned = 0;
    *lphOperationData = NULL;

    while ( FitInBuffer &&
            dwEntriesRequested > *lpdwEntriesReturned &&
            status == NO_ERROR )
    {
        if ( lpNdsParentObject->ResumeId == 0 )
        {
            //
            // Get the first subtree entry.
            //
            status = GetFirstNdsSubTreeEntry( lpNdsParentObject,
                                              lpNdsBuffer->dwRequestAvailableBytes );
        }

        //
        // Either ResumeId contains the first entry we just got from
        // GetFirstNdsSubTreeEntry or it contains the next directory
        // entry to return.
        //
        if (status == NO_ERROR && lpNdsParentObject->ResumeId != 0)
        {
            WORD   tempStrLen;
            LPWSTR newPathStr = NULL;
            LPWSTR tempStr = NULL;
            LPWSTR ClassName;
            LPWSTR ObjectName;
            DWORD  ClassNameLen;
            DWORD  ObjectNameLen;
            DWORD  EntryId;
            DWORD  SubordinateCount;
            DWORD  ModificationTime;
            BOOL   fWriteThisObject = FALSE;

            //
            // Get current subtree data from lpNdsParentObject
            //
            GetSubTreeData( lpNdsParentObject->ResumeId,
                            &EntryId,
                            &SubordinateCount,
                            &ModificationTime,
                            &ClassNameLen,
                            &ClassName,
                            &ObjectNameLen,
                            &ObjectName );

            if ( lpFilters )
            {
                DWORD iter;

                for ( iter = 0; iter < lpFilters->dwNumberOfFilters; iter++ )
                {
                    if (!wcscmp(lpFilters->Filters[iter].szObjectClass, ClassName))
                        fWriteThisObject = TRUE;
                }
            }
            else
            {
                fWriteThisObject = TRUE;
            }

            if ( fWriteThisObject )
            {
                //
                // Need to build a string with the new NDS UNC path
                // for subtree object
                //
                newPathStr = (PVOID) LocalAlloc( LPTR,
                                   ( wcslen(ObjectName) +
                                   wcslen(lpNdsParentObject->szContainerName) +
                                   3 ) * sizeof(WCHAR) );

                if ( newPathStr == NULL )
                {
                    (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
#if DBG
                    KdPrint(("NDS32: NwNdsListSubObjects LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                            lpNdsParentObject->szContainerName,
                                            PARSE_NDS_GET_TREE_NAME );

                tempStrLen /= sizeof(WCHAR);

                if ( tempStrLen > 0 )
                {
                    wcscpy( newPathStr, L"\\\\" );
                    wcsncat( newPathStr, tempStr, tempStrLen );
                    wcscat( newPathStr, L"\\" );
                    wcscat( newPathStr, ObjectName );
                    _wcsupr( newPathStr );
                }

                tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                            lpNdsParentObject->szContainerName,
                                            PARSE_NDS_GET_PATH_NAME );

                tempStrLen /= sizeof(WCHAR);

                if ( tempStrLen > 0 )
                {
                    wcscat( newPathStr, L"." );
                    wcsncat( newPathStr, tempStr, tempStrLen );
                }

                //
                // Pack subtree name into output buffer.
                //
                status = WriteObjectToBuffer( &FixedPortion,
                                              &EndOfVariableData,
                                              newPathStr,
                                              ObjectName,
                                              ClassName,
                                              EntryId,
                                              ModificationTime,
                                              SubordinateCount,
                                              0,      // No attribute
                                              NULL ); // infos here

                if ( status == NO_ERROR )
                {
                    //
                    // Note that we've returned the current entry.
                    //
                    (*lpdwEntriesReturned)++;
                    (lpNdsBuffer->dwNumberOfIndexEntries)++;
                }

                if ( newPathStr )
                    (void) LocalFree( (HLOCAL) newPathStr );
            }

            if (status == WN_MORE_DATA)
            {
                //
                // Could not write current entry into output buffer.
                //

                if (*lpdwEntriesReturned)
                {
                    //
                    // Still return success because we got at least one.
                    //
                    status = NO_ERROR;
                }

                FitInBuffer = FALSE;
            }
            else if (status == NO_ERROR)
            {
                //
                // Get next directory entry.
                //
                status = GetNextNdsSubTreeEntry( lpNdsParentObject );
            }
        } // end of if data to process

        if (status == WN_NO_MORE_ENTRIES)
        {
            lpNdsParentObject->ResumeId = NDS_NO_MORE_ITERATIONS;
        }
    } //end of while loop

    //
    // User asked for more than there are entries.  We just say that
    // all is well.
    //
    // This is incompliance with the wierd provider API definition where
    // if user gets NO_ERROR, and EntriesRequested > *EntriesRead, and
    // at least one entry fit into output buffer, there's no telling if
    // the buffer was too small for more entries or there are no more
    // entries.  The user has to call this API again and get WN_NO_MORE_ENTRIES
    // before knowing that the last call had actually reached the end of list.
    //
    if ( *lpdwEntriesReturned && status == WN_NO_MORE_ENTRIES )
    {
        status = NO_ERROR;
    }

    if ( *lpdwEntriesReturned )
    {
        *lphOperationData = lpNdsBuffer;
    }

    if ( *lpdwEntriesReturned == 0 )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
        lpNdsBuffer = NULL;
    }

    if ( lpNdsParentObject->NdsRawDataBuffer &&
         lpNdsParentObject->ResumeId == NDS_NO_MORE_ITERATIONS )
    {
        (void) LocalFree( (HLOCAL) lpNdsParentObject->NdsRawDataBuffer );
        lpNdsParentObject->NdsRawDataBuffer = 0;
        lpNdsParentObject->NdsRawDataSize = 0;
        lpNdsParentObject->NdsRawDataId = INITIAL_ITERATION;
        lpNdsParentObject->NdsRawDataCount = 0;
    }

    return status;
}


DWORD
NwNdsModifyObject(
    IN  HANDLE hObject,
    IN  HANDLE hOperationData )
/*
   NwNdsModifyObject()

   This function is used to modify a leaf object in an NDS directory tree.
   Modifying a leaf object means: changing, adding, removing, and clearing of
   specified attributes for a given object.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       HANDLE           hOperationData - A handle to data containing a
                        list of attribute changes to be applied to the object.
                        This buffer is manipulated by the following functions:
                           NwNdsCreateBuffer (NDS_OBJECT_MODIFY),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

   Returns:

       NO_ERROR
       ERROR_INVALID_PARAMETER
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD        nwstatus;
    NTSTATUS     ntstatus = STATUS_SUCCESS;
    DWORD        dwReplyLength;
    BYTE         NdsReply[NDS_BUFFER_SIZE];
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) hOperationData;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;

    if ( lpNdsBuffer == NULL ||
         lpNdsObject == NULL ||
         lpNdsBuffer->dwOperation != NDS_OBJECT_MODIFY ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus =
        FragExWithWait(
                     lpNdsObject->NdsTree,
                     NETWARE_NDS_FUNCTION_MODIFY_OBJECT,
                     NdsReply,
                     NDS_BUFFER_SIZE,
                     &dwReplyLength,
                     "DDDDr",
                     0,                   // Version
                     0,                   // Flags
                     lpNdsObject->ObjectId, // The id of the object
                     lpNdsBuffer->dwNumberOfRequestEntries,
                     lpNdsBuffer->lpRequestBuffer, // Object attribute changes
                     (WORD)lpNdsBuffer->dwLengthOfRequestData // Length of data
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsModifyObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsModifyObject: The modify object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;
}


DWORD
NwNdsMoveObject(
    IN  HANDLE hObject,
    IN  LPWSTR szDestObjectParentDN )
/*
   NwNdsMoveObject()

   This function is used to move a leaf object in an NDS directory tree
   from one container to another.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be moved. Handle is obtained by calling
                        NwNdsOpenObject.

       LPWSTR           szDestObjectParentDN - The DN of the object's new
                        parent.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;
    LPNDS_OBJECT_PRIV   lpNdsDestParentObject = NULL;
    WCHAR          szServerDN[NDS_MAX_NAME_CHARS];
    UNICODE_STRING ObjectName;
    UNICODE_STRING ServerDN;
    DWORD          dwDestParentObjectId;

    if ( szDestObjectParentDN == NULL ||
         lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlZeroMemory( &szServerDN, sizeof( szServerDN ) );

    status = NwNdsGetServerDN( lpNdsObject, szServerDN );

    if ( status )
    {
        return status;
    }

    status = NwNdsOpenObject( szDestObjectParentDN,
                              NULL,
                              NULL,
                              (HANDLE *) &lpNdsDestParentObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status )
    {
        return status;
    }

    dwDestParentObjectId = lpNdsDestParentObject->ObjectId;

    (void) NwNdsCloseObject( (HANDLE) lpNdsDestParentObject );

    RtlInitUnicodeString( &ObjectName, lpNdsObject->szRelativeName );
    RtlInitUnicodeString( &ServerDN, szServerDN );

    ntstatus =
        FragExWithWait( lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_BEGIN_MOVE_OBJECT,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DDDSS",
                        0,          // Version
                        0x00000000, // Some value
                        dwDestParentObjectId,
                        &ObjectName,
                        &ServerDN
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsMoveObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsMoveObject: The status code response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        return nwstatus;
    }

    ntstatus =
        FragExWithWait( lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_FINISH_MOVE_OBJECT,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        "DDDDSS",
                        0,          // Version
                        0x00000001, // Some value
                        lpNdsObject->ObjectId,
                        dwDestParentObjectId,
                        &ObjectName,
                        &ServerDN
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsMoveObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsMoveObject: The status code response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        return nwstatus;
    }

    return nwstatus;
}


DWORD
NwNdsOpenObject(
    IN  LPWSTR   szObjectDN,
    IN  LPWSTR   UserName OPTIONAL,
    IN  LPWSTR   Password OPTIONAL,
    OUT HANDLE * lphObject,
    OUT LPWSTR   szObjectName OPTIONAL,
    OUT LPWSTR   szObjectFullName OPTIONAL,
    OUT LPWSTR   szObjectClassName OPTIONAL,
    OUT LPDWORD  lpdwModificationTime OPTIONAL,
    OUT LPDWORD  lpdwSubordinateCount OPTIONAL )
/*
   NwNdsOpenObject()

   Arguments:

       LPWSTR           szObjectDN - The distinguished name of the object
                        that we want resolved into an object handle.

       LPWSTR           UserName - The name of the user account to create
                        connection to object with.
                            - OR -
                        NULL to use the base credentials of the callee's LUID.

       LPWSTR           Password - The password of the user account to create
                        connection to object with. If password is blank, callee
                        should pass "".
                            - OR -
                        NULL to use the base credentials of the callee's LUID.

       HANDLE *         lphObject - The address of a NDS_OBJECT_HANDLE
                        to receive the handle of the object specified by
                        szObjectDN.

       Optional arguments: ( Callee can pass NULL in for these parameters to
                             indicate ignore )

       LPWSTR           szObjectName - A LPWSTR buffer to receive
                        the object's NDS name, or NULL if not
                        interested. The buffer for this string must be
                        provided by the user. Buffer should be at least
                        NDS_MAX_NAME_SIZE

       LPWSTR           szObjectFullName - A LPWSTR buffer to receive
                        the object's full NDS name (DN), or NULL if not
                        interested. The buffer for this string must be
                        provided by the user. Buffer should be at least
                        NDS_MAX_NAME_SIZE

       LPWSTR           szObjectClassName - A LPWSTR buffer to receive
                        the class name of the object opened, or NULL if not
                        interested. The buffer for this string must be
                        provided by the user. Buffer should be at least
                        NDS_MAX_NAME_SIZE.

       LPDWORD          lpdwModificationTime -  The address of a DWORD to
                        receive the last date/time the object was modified.

       LPDWORD          lpdwSubordinateCount -  The address of a DWORD to
                        receive the number of subordinate objects that may
                        be found under szObjectDN, if it is a container object.
                        Or, NULL in not interested.

                        If szObjectDN is not a container, then the value is set
                        to zero. Although a value of zero does not imply
                        that object is not a container, it could just be empty.

   Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    WCHAR          szServerName[NW_MAX_SERVER_LEN];
    UNICODE_STRING ServerName;
    UNICODE_STRING ObjectName;
    LPNDS_OBJECT_PRIV   lpNdsObject = NULL;
#ifdef WIN95
    LPWSTR         pszObjectName = NULL;
    LPWSTR         szWin95ClassName = NULL;
#endif
    if ( szObjectDN == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsObject = (LPNDS_OBJECT_PRIV) LocalAlloc( LPTR,
                                             sizeof(NDS_OBJECT_PRIV) );

    if (lpNdsObject == NULL) {
#if DBG
        KdPrint(("NDS32: NwNdsOpenObject LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    ServerName.Length = 0;
    ServerName.MaximumLength = sizeof(szServerName);
    ServerName.Buffer = szServerName;

    ObjectName.Buffer = NULL;

    ObjectName.MaximumLength = (wcslen( szObjectDN ) + 1) * sizeof(WCHAR);

    ObjectName.Length = ParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                         szObjectDN,
                                         PARSE_NDS_GET_TREE_NAME );

    if ( ObjectName.Length == 0 || ObjectName.Buffer == NULL )
    {
        SetLastError( ERROR_PATH_NOT_FOUND );
        goto ErrorExit;
    }

    //
    // Open a NDS tree connection handle to \\treename
    //
    if ( UserName && Password )
    {
        UNICODE_STRING usUserName;
        UNICODE_STRING usPassword;
        DWORD          dwHandleType;

        RtlInitUnicodeString( &usUserName, UserName );
        RtlInitUnicodeString( &usPassword, Password );

        ntstatus = NwOpenHandleWithSupplementalCredentials(
                                               &ObjectName,
                                               &usUserName,
                                               &usPassword,
                                               &dwHandleType,
                                               &lpNdsObject->NdsTree );

        if ( ntstatus == STATUS_SUCCESS &&
             dwHandleType != HANDLE_TYPE_NDS_TREE )
        {
            SetLastError( ERROR_PATH_NOT_FOUND );
            goto ErrorExit;
        }
    }
    else if ( !UserName && !Password )
    {
        ntstatus = NwNdsOpenTreeHandle( &ObjectName, &lpNdsObject->NdsTree );
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto ErrorExit;
    }

    if ( ntstatus != STATUS_SUCCESS )
    {
        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        goto ErrorExit;
    }

    ObjectName.Length /= sizeof(WCHAR);

    wcscpy( lpNdsObject->szContainerName, L"\\\\" );
    wcsncat( lpNdsObject->szContainerName, ObjectName.Buffer, ObjectName.Length );
    wcscat( lpNdsObject->szContainerName, L"\\" );
    _wcsupr( lpNdsObject->szContainerName );

    //
    // Get the path to the container to open.
    //
    ObjectName.Length = ParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                         szObjectDN,
                                         PARSE_NDS_GET_PATH_NAME );

    if ( ObjectName.Length == 0 )
    {
        UNICODE_STRING Root;

        RtlInitUnicodeString(&Root, L"[Root]");

        //
        // Resolve the path to get a NDS object id of [Root].
        //
#ifndef WIN95
        ntstatus = NwNdsResolveName( lpNdsObject->NdsTree,
                                     &Root,
                                     &lpNdsObject->ObjectId,
                                     &ServerName,
                                     NULL,
                                     0 );
#else
        ntstatus = NwNdsResolveNameWin95( lpNdsObject->NdsTree,
                                     &Root,
                                     &lpNdsObject->ObjectId,
                                     &lpNdsObject->NdsTree,
                                     NULL,
                                     0 );
#endif
        if ( ntstatus != STATUS_SUCCESS )
        {
            DWORD status;
            status = RtlNtStatusToDosError( ntstatus );

            if ( status == ERROR_NOT_CONNECTED )
                SetLastError( ERROR_PATH_NOT_FOUND );
            else
                SetLastError( status );
            goto ErrorExit;
        }
    }
    else
    {
        //
        // Resolve the path to get a NDS object id.
        //
#ifndef WIN95
        ntstatus = NwNdsResolveName( lpNdsObject->NdsTree,
                                     &ObjectName,
                                     &lpNdsObject->ObjectId,
                                     &ServerName,
                                     NULL,
                                     0 );
#else

        ntstatus = NwNdsResolveNameWin95( lpNdsObject->NdsTree,
                                     &ObjectName,
                                     &lpNdsObject->ObjectId,
                                     &lpNdsObject->NdsTree,
                                     NULL,
                                     0 );
#endif

        if ( ntstatus != STATUS_SUCCESS )
        {
            DWORD status;
            status = RtlNtStatusToDosError( ntstatus );

            if ( status == ERROR_NOT_CONNECTED )
                SetLastError( ERROR_PATH_NOT_FOUND );
            else
                SetLastError( status );
            goto ErrorExit;
        }
    }

#ifndef WIN95
    if ( ServerName.Length )
    {
        DWORD    dwHandleType;

        //
        // NwNdsResolveName succeeded, but we were referred to
        // another server, though lpNdsObject->ObjectId is still valid.
        //
        if ( lpNdsObject->NdsTree )
            CloseHandle( lpNdsObject->NdsTree );

        lpNdsObject->NdsTree = 0;

        //
        // Open a NDS generic connection handle to \\ServerName
        //
        ntstatus = NwNdsOpenGenericHandle( &ServerName,
                                           &dwHandleType,
                                           &lpNdsObject->NdsTree );

        if ( ntstatus != STATUS_SUCCESS )
        {
            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            goto ErrorExit;
        }
    }
    {
        PBYTE RawResponse = NULL;
        PNDS_RESPONSE_GET_OBJECT_INFO psGetInfo;
        PBYTE pbRawGetInfo;
        LPWSTR szClassName;
        DWORD dwStrLen;

        RawResponse = LocalAlloc( LPTR, TWO_KB );

        if ( ! RawResponse )
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto ErrorExit;
        }

        ntstatus = NwNdsReadObjectInfo( lpNdsObject->NdsTree,
                                        lpNdsObject->ObjectId,
                                        RawResponse,
                                        TWO_KB );

        if ( ntstatus != STATUS_SUCCESS )
        {
            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            goto ErrorExit;
        }

        psGetInfo = ( PNDS_RESPONSE_GET_OBJECT_INFO ) RawResponse;

        if ( lpdwModificationTime != NULL )
        {
            *lpdwModificationTime = psGetInfo->ModificationTime;
        }

        if ( lpdwSubordinateCount != NULL )
        {
            *lpdwSubordinateCount = psGetInfo->SubordinateCount;
        }

        //
        // Dig out the two unicode strings for class name and object name.
        //

        pbRawGetInfo = RawResponse;

        pbRawGetInfo += sizeof (NDS_RESPONSE_GET_OBJECT_INFO);

        dwStrLen = * (LPDWORD) pbRawGetInfo;
        pbRawGetInfo += sizeof(DWORD);
        szClassName = (LPWSTR) pbRawGetInfo;

        if ( szObjectClassName != NULL )
        {
            wcscpy( szObjectClassName, szClassName );
        }

        pbRawGetInfo += ROUNDUP4( dwStrLen );
        dwStrLen = * ( DWORD * ) pbRawGetInfo;
        pbRawGetInfo += sizeof(DWORD);

        //
        // Clean up the object's relative name ...
        //
        if ( wcscmp( szClassName, NDS_CLASS_TOP ) )
        {
            LPWSTR szTempStr = (LPWSTR) pbRawGetInfo;

            while ( *szTempStr != L'=' )
            {
                szTempStr++;
            }

            szTempStr++;

            wcscpy( lpNdsObject->szRelativeName, szTempStr );

            szTempStr = lpNdsObject->szRelativeName;

            while ( *szTempStr && *szTempStr != L'.' )
            {
                szTempStr++;
            }

            *szTempStr = L'\0';
        }
        else
        {
            wcscpy( lpNdsObject->szRelativeName, (LPWSTR) pbRawGetInfo );
        }

        if ( szObjectName != NULL )
        {
            wcscpy( szObjectName, lpNdsObject->szRelativeName );
        }

        if ( szObjectFullName != NULL )
        {
            if ( wcscmp( szClassName, NDS_CLASS_TOP ) )
            {
                wcscpy( szObjectFullName, lpNdsObject->szContainerName );
                wcscat( szObjectFullName, (LPWSTR) pbRawGetInfo );
            }
            else
            {
                wcscpy( szObjectFullName,
                        lpNdsObject->szContainerName );

                szObjectFullName[wcslen( szObjectFullName ) - 1] = L'\0';
            }
        }

        //
        // If the object is at a level below the root of the tree, append
        // it's full DN to handle Name.
        //
        if ( wcscmp( szClassName, NDS_CLASS_TOP ) )
        {
            wcscat(lpNdsObject->szContainerName, (LPWSTR) pbRawGetInfo);
        }

        if ( RawResponse )
            LocalFree( RawResponse );
    }

    lpNdsObject->Signature = NDS_SIGNATURE;

    //
    // Initialize ListSubObject/Search structure values.
    //
    // lpNdsObject->ResumeId = 0;         // Start of enumeration
    //
    // lpNdsObject->NdsRawDataBuffer = 0;
    // lpNdsObject->NdsRawDataSize = 0;
    // lpNdsObject->NdsRawDataId = 0;     // These are initialized by
    // lpNdsObject->NdsRawDataCount = 0;  // LPTR

    //
    // Return the newly created object handle.
    //
    *lphObject = (HANDLE) lpNdsObject;

    return NO_ERROR;

#else
    {
        DS_OBJ_INFO dsobj;
        DWORD dwStrLen;
        NW_STATUS nwstatus;

        memset(&dsobj, 0, sizeof(DS_OBJ_INFO));

        nwstatus = NDSGetObjectInfoWithId(lpNdsObject->NdsTree,
                                  lpNdsObject->ObjectId,
                                  &dsobj );

        ntstatus = MapNwToNtStatus(nwstatus);
        if ( ntstatus != STATUS_SUCCESS )
        {
            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            goto ErrorExit;
        }

        if ( lpdwSubordinateCount != NULL )
        {
            *lpdwSubordinateCount = dsobj.subordinateCount;
        }

        if (!(szWin95ClassName = AllocateUnicodeString(dsobj.className))) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto ErrorExit;
        }

        if ( szObjectClassName != NULL )
        {
            wcscpy( szObjectClassName, szWin95ClassName);
        }

        if (!(pszObjectName = AllocateUnicodeString(dsobj.objectName))) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto ErrorExit;
        }

        //
        // Clean up the object's relative name ...
        //
        if ( wcscmp( szWin95ClassName, NDS_CLASS_TOP ) )
        {
            LPWSTR szTempStr = pszObjectName;

            while ( *szTempStr != L'=' )
            {
                szTempStr++;
            }

            szTempStr++;

            wcscpy( lpNdsObject->szRelativeName, szTempStr );

            szTempStr = lpNdsObject->szRelativeName;

            while ( *szTempStr && *szTempStr != L'.' )
            {
                szTempStr++;
            }

            *szTempStr = L'\0';
        }
        else
        {
            wcscpy( lpNdsObject->szRelativeName, pszObjectName );
        }

        if ( szObjectName != NULL )
        {
            wcscpy( szObjectName, lpNdsObject->szRelativeName );
        }

        if ( szObjectFullName != NULL )
        {
            if ( wcscmp( szWin95ClassName, NDS_CLASS_TOP ) )
            {
                wcscpy( szObjectFullName, lpNdsObject->szContainerName );
                wcscat( szObjectFullName, pszObjectName );
            }
            else
            {
                wcscpy( szObjectFullName,
                        lpNdsObject->szContainerName );

                szObjectFullName[wcslen( szObjectFullName ) - 1] = L'\0';
            }
        }

        //
        // If the object is at a level below the root of the tree, append
        // it full DN to handle Name.
        //
        if ( wcscmp( szWin95ClassName, NDS_CLASS_TOP ) )
        {
            wcscat(lpNdsObject->szContainerName, pszObjectName);
        }
        if(szWin95ClassName){
            FreeUnicodeString(szWin95ClassName);
        }
        if(pszObjectName){
            FreeUnicodeString(pszObjectName);
        }
    }

    lpNdsObject->Signature = NDS_SIGNATURE;
    *lphObject = (HANDLE) lpNdsObject;

    return NO_ERROR;
#endif


ErrorExit:

    if ( lpNdsObject )
    {
#ifndef WIN95
        // There is no ref count in Win95, the connection will time out itself
        if ( lpNdsObject->NdsTree )
            CloseHandle( lpNdsObject->NdsTree );
#endif
        (void) LocalFree( (HLOCAL) lpNdsObject );
    }

#ifdef WIN95
    if(szWin95ClassName)
    {
        FreeUnicodeString(szWin95ClassName);
    }

    if(pszObjectName)
    {
        FreeUnicodeString(pszObjectName);
    }
#endif

    *lphObject = NULL;
    return (DWORD) UNSUCCESSFUL;
}


DWORD
NwNdsPutInBuffer(
    IN     LPWSTR szAttributeName,
    IN     DWORD  dwSyntaxID,
    IN     LPVOID lpAttributeValues,
    IN     DWORD  dwValueCount,
    IN     DWORD  dwAttrModificationOperation,
    IN OUT HANDLE hOperationData )
/*
   NwNdsPutInBuffer()

   This function is used to add an entry to the buffer used to describe
   an object attribute or change to an object attribute. The buffer must
   be created using NwNdsCreateBuffer. If the buffer was created using the
   operations, NDS_OBJECT_ADD, NDS_SCHEMA_DEFINE_CLASS,
   NDS_SCHEMA_READ_ATTR_DEF, or NDS_SCHEMA_READ_CLASS_DEF, then
   dwAttrModificationOperation is ignored. If the buffer was created using
   either the operation NDS_OBJECT_READ or NDS_SEARCH, then
   dwAttrModificationOperation, puAttributeType, and lpAttributeValue are
   all ingnored.

   Arguments:

       LPWSTR           szAttributeName - A NULL terminated WCHAR string
                        that contains name of the attribute value to be
                        added to the buffer. It can be a user supplied
                        string, or one of the  many defined string macros
                        in ndsnames.h.

       DWORD            dwSyntaxID - The ID of the syntax structure used to
                        represent the attribute value. Syntax IDs and their
                        associated structures are defined in the file
                        NdsSntx.h. According to the NetWare NDS schema spec,
                        there is and always will be, only 28 (0..27)
                        different syntaxes.

       LPVOID           lpAttributeValues - A pointer to the beginning of a
                        buffer containing the value(s) for a particular
                        object attribute with data syntax dwSyntaxID.

       DWORD            dwValueCount - The number of value entries found in
                        buffer pointed to by lpAttributeValues.

       DWORD            dwAttrModificationOperation - If the buffer was created
                        using the operation NDS_MODIFY_OBJECT, then this is
                        used to desribe which type of modification operation
                        to apply for a given attribute. These attribute
                        modification operations are defined near the beginning
                        of this file.

       HANDLE           hOperationData - A handle to data created by
                        calling NwNdsCreateBuffer. The buffer stores the
                        attributes used to define transactions for
                        NwNdsAddObject, NwNdsModifyObject, NwNdsReadObject,
                        NwNdsReadAttrDef, NwNdsReadClassDef, or NwNdsSearch.

    Returns:

       NO_ERROR
       ERROR_NOT_ENOUGH_MEMORY
       ERROR_INVALID_PARAMETER
*/
{
    LPNDS_BUFFER   lpNdsBuffer = (LPNDS_BUFFER) hOperationData;
    DWORD          LengthInBytes;
    LPBYTE         lpTempEntry = NULL;
    UNICODE_STRING AttributeName;
    DWORD          bufferSize = TWO_KB;

    if ( lpNdsBuffer == NULL ||
         szAttributeName == NULL ||
         lpNdsBuffer->dwBufferId != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &AttributeName, szAttributeName );

    //
    // Check to see if the buffer was already used by a read operation.
    //
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        SetLastError( ERROR_ACCESS_DENIED );
        return NDS_ERR_NO_ACCESS;
    }

    if ( lpNdsBuffer->dwOperation == NDS_OBJECT_MODIFY )
    {
        switch( dwAttrModificationOperation )
        {
            case NDS_ATTR_ADD:
            case NDS_ATTR_REMOVE:
            case NDS_ATTR_ADD_VALUE:
            case NDS_ATTR_REMOVE_VALUE:
            case NDS_ATTR_ADDITIONAL_VALUE:
            case NDS_ATTR_OVERWRITE_VALUE:
            case NDS_ATTR_CLEAR:
            case NDS_ATTR_CLEAR_VALUE:
                break;

            default:
#if DBG
                KdPrint(( "NDS32: NwNdsPutInBuffer was passed an unidentified modification operation.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
        }
    }

    if ( lpNdsBuffer->dwOperation == NDS_OBJECT_ADD ||
         lpNdsBuffer->dwOperation == NDS_OBJECT_MODIFY )
    {
        bufferSize += CalculateValueDataSize ( dwSyntaxID,
                                               lpAttributeValues,
                                               dwValueCount );
    }

    lpTempEntry = LocalAlloc( LPTR, bufferSize );

    if ( ! lpTempEntry )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    switch ( lpNdsBuffer->dwOperation )
    {
        case NDS_OBJECT_ADD:
            PrepareAddEntry( lpTempEntry,
                             AttributeName,
                             dwSyntaxID,
                             lpAttributeValues,
                             dwValueCount,
                             &LengthInBytes );
            break;

        case NDS_OBJECT_MODIFY:
            PrepareModifyEntry( lpTempEntry,
                                AttributeName,
                                dwSyntaxID,
                                dwAttrModificationOperation,
                                lpAttributeValues,
                                dwValueCount,
                                &LengthInBytes );
            break;

        case NDS_OBJECT_READ:
        case NDS_SCHEMA_DEFINE_CLASS:
        case NDS_SCHEMA_READ_ATTR_DEF:
        case NDS_SCHEMA_READ_CLASS_DEF:
        case NDS_SEARCH:
            //
            // Check to see if this buffer has already been used. If so,
            // return with error.
            //
            if ( lpNdsBuffer->lpReplyBuffer )
            {
                if ( lpTempEntry )
                    LocalFree( lpTempEntry );

                SetLastError( ERROR_INVALID_PARAMETER );
                return (DWORD) UNSUCCESSFUL;
            }

            PrepareReadEntry( lpTempEntry,
                              AttributeName,
                              &LengthInBytes );
            break;

        default:
#if DBG
            KdPrint(( "NDS32: NwNdsPutInBuffer has unknown buffer operation!\n" ));
#endif

            if ( lpTempEntry )
                LocalFree( lpTempEntry );

            SetLastError( ERROR_INVALID_PARAMETER );
            return (DWORD) UNSUCCESSFUL;
    }

    if ( lpNdsBuffer->dwRequestAvailableBytes >= LengthInBytes )
    {
        //
        // Copy temporary buffer entry into buffer and update buffer header.
        //

        RtlCopyMemory( (LPBYTE)&lpNdsBuffer->lpRequestBuffer[lpNdsBuffer->dwLengthOfRequestData],
                       lpTempEntry,
                       LengthInBytes );

        lpNdsBuffer->dwRequestAvailableBytes -= LengthInBytes;
        lpNdsBuffer->dwNumberOfRequestEntries += 1;
        lpNdsBuffer->dwLengthOfRequestData += LengthInBytes;
    }
    else
    {
        LPBYTE lpNewBuffer = NULL;

        //
        // Need to reallocate buffer to a bigger size.
        //
        lpNewBuffer = (LPBYTE) LocalAlloc(
                                  LPTR,
                                  lpNdsBuffer->dwRequestBufferSize +
                                  LengthInBytes +
                                  TWO_KB );

        if ( lpNewBuffer == NULL )
        {
#if DBG
            KdPrint(( "NDS32: NwNdsPutInBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            if ( lpTempEntry )
                LocalFree( lpTempEntry );

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }

        RtlCopyMemory( lpNewBuffer,
                       lpNdsBuffer->lpRequestBuffer,
                       lpNdsBuffer->dwLengthOfRequestData );

        LocalFree( (HLOCAL) lpNdsBuffer->lpRequestBuffer );
        lpNdsBuffer->lpRequestBuffer = lpNewBuffer;
        lpNdsBuffer->dwRequestBufferSize += LengthInBytes + TWO_KB;
        lpNdsBuffer->dwRequestAvailableBytes += LengthInBytes + TWO_KB;

        //
        // Copy temporary buffer entry into the resized buffer and
        // update buffer header.
        //

        RtlCopyMemory( (LPBYTE)&lpNdsBuffer->lpRequestBuffer[lpNdsBuffer->dwLengthOfRequestData],
                       lpTempEntry,
                       LengthInBytes );

        lpNdsBuffer->dwRequestAvailableBytes -= LengthInBytes;
        lpNdsBuffer->dwNumberOfRequestEntries += 1;
        lpNdsBuffer->dwLengthOfRequestData += LengthInBytes;
    }

    if ( lpTempEntry )
        LocalFree( lpTempEntry );

    return NO_ERROR;
}


DWORD
NwNdsReadAttrDef(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES
                                       // or NDS_INFO_NAMES_DEFS
    IN OUT HANDLE * lphOperationData OPTIONAL )
/*
   NwNdsReadAttrDef()

   This function is used to read attribute definitions in the schema of an
   NDS directory tree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the defined attribute name(s) in the schema or
                        read both the attribute name(s) and definition(s)
                        from the schema.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attribute names to be read from
                        the schema. This handle is manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_READ_ATTR_DEF),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all attributes should be read from the schema.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Attribute values can be retrieved from the
                        buffer with the functions:
                            NwNdsGetAttrDefListFromBuffer.

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions:
                            NwNdsGetAttrDefListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    if ( hTree == NULL ||
         ((LPNDS_OBJECT_PRIV) hTree)->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( *lphOperationData == NULL ) // If TRUE, we need to read all attr defs
        return ReadAttrDef_AllAttrs( hTree,
                                     dwInformationType,
                                     lphOperationData );
    else // Else, we read the attr definitions specified in lphOperationData
        return ReadAttrDef_SomeAttrs( hTree,
                                      dwInformationType,
                                      lphOperationData );
}


DWORD
NwNdsReadClassDef(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES,
                                       // NDS_INFO_NAMES_DEFS,
                                       // NDS_CLASS_INFO_EXPANDED_DEFS,
                                       // or NDS_CLASS_INFO
    IN OUT HANDLE * lphOperationData OPTIONAL )
/*
   NwNdsReadClassDef()

   This function is used to read class definitions in the schema of an
   NDS directory tree.

   Arguments:

       HANDLE           hTree - A handle to the directory tree to be
                        manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the defined class name(s) in the schema or
                        read both the class name(s) and definition(s)
                        from the schema.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of class names to be read from
                        the schema. This handle is manipulated by the following
                        functions:
                           NwNdsCreateBuffer (NDS_SCHEMA_READ_CLASS_DEF),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all classes should be read from the schema.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Class read results can be retrieved from the
                        buffer with the functions:
                            NwNdsGetClassDefListFromBuffer.

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions:
                            NwNdsGetClassDefListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    if ( hTree == NULL ||
         ((LPNDS_OBJECT_PRIV) hTree)->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( *lphOperationData == NULL ) // If TRUE, we need to read all class defs
        return ReadClassDef_AllClasses( hTree,
                                        dwInformationType,
                                        lphOperationData );
    else // Else, we read the class definitions specified in lphOperationData
        return ReadClassDef_SomeClasses( hTree,
                                         dwInformationType,
                                         lphOperationData );
}


DWORD
NwNdsReadObject(
    IN     HANDLE   hObject,
    IN     DWORD    dwInformationType, // NDS_INFO_NAMES
                                       // or NDS_INFO_ATTR_NAMES_VALUES
    IN OUT HANDLE * lphOperationData OPTIONAL )
/*
   NwNdsReadObject()

   This function is used to read attributes about an object of an NDS
   directory tree.

   Arguments:

       HANDLE           hObject - A handle to the object in the directory
                        tree to be manipulated. Handle is obtained by calling
                        NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the attribute name(s) on the object or
                        read both the attribute name(s) and value(s)
                        from the object.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attributes to be read from the
                        object hObject. This handle is manipulated by the
                        following functions:
                           NwNdsCreateBuffer (NDS_OBJECT_READ),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all object attributes should be read from object
                        hObject.

                        If these calls are successful, this pointer will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Attribute values can be retrieved from the
                        buffer with the functions:
                           NwNdsGetAttrListFromBuffer

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions:
                           NwNdsGetAttrListFromBuffer and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    if ( hObject == NULL ||
         ((LPNDS_OBJECT_PRIV) hObject)->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( *lphOperationData == NULL ) // If TRUE, we need to read all attributes
        return ReadObject_AllAttrs( hObject,
                                    dwInformationType,
                                    lphOperationData );
    else // Else, we read the attributes specified in lphOperationData
        return ReadObject_SomeAttrs( hObject,
                                     dwInformationType,
                                     lphOperationData );
}


DWORD
NwNdsRemoveObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName )
/*
   NwNdsRemoveObject()

   This function is used to remove a leaf object from an NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object container
                        in the directory tree to remove leaf object from.
                        Handle is obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name of the leaf object
                        to be removed.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD    nwstatus;
    DWORD    status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    DWORD    dwReplyLength;
    BYTE     NdsReply[TWO_KB]; // A 2K buffer is plenty for a response
    LPNDS_OBJECT_PRIV lpNdsParentObject = (LPNDS_OBJECT_PRIV) hParentObject;
    LPNDS_OBJECT_PRIV lpNdsObject = NULL;
    LPWSTR   szFullObjectDN = NULL;
    LPWSTR   szTempStr = NULL;
    DWORD    length;
    UNICODE_STRING ObjectName;

    if (  szObjectName == NULL ||
          lpNdsParentObject == NULL ||
          lpNdsParentObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &ObjectName, szObjectName );

    //
    // Create a buffer to hold the full object distinguished name.
    // \\tree\<--Object Name-->.<existing container path, if any>
    //
    szFullObjectDN = (LPWSTR) LocalAlloc(
                               LPTR,
                               ( wcslen( lpNdsParentObject->szContainerName ) *
                                 sizeof(WCHAR) ) +     // Container name
                                 ObjectName.Length +     // Object name
                                 ( 2 * sizeof(WCHAR) ) ); // Extras

    //
    // Check that the memory allocation was successful.
    //
    if ( szFullObjectDN == NULL )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRemoveObject LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    length = ParseNdsUncPath( &szTempStr,
                              lpNdsParentObject->szContainerName,
                              PARSE_NDS_GET_TREE_NAME );

    length /= sizeof(WCHAR);

    wcscpy( szFullObjectDN, L"\\\\" );              // <\\>
    wcsncat( szFullObjectDN, szTempStr, length );   // <\\tree>
    wcscat( szFullObjectDN, L"\\" );                // <\\tree\>
    wcsncat( szFullObjectDN, ObjectName.Buffer,
             ObjectName.Length );                   // <\\tree\obj>

    length = ParseNdsUncPath( &szTempStr,
                              lpNdsParentObject->szContainerName,
                              PARSE_NDS_GET_PATH_NAME );

    if ( length > 0 )
    {
        length /= sizeof(WCHAR);
        wcscat( szFullObjectDN, L"." );              // <\\tree\obj.>
        wcsncat( szFullObjectDN, szTempStr, length );// <\\tree\obj.org_unt.org>
    }

    status = NwNdsOpenObject( szFullObjectDN,
                              NULL,
                              NULL,
                              (HANDLE *) &lpNdsObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status != NO_ERROR )
    {
        // NwNdsOpenObject will have already set the last error . . .
        goto ErrorExit;
    }

    (void) LocalFree( szFullObjectDN );
    szFullObjectDN = NULL;

    ntstatus =
        FragExWithWait(
                        lpNdsParentObject->NdsTree,
                        NETWARE_NDS_FUNCTION_REMOVE_OBJECT,
                        NdsReply,           // Response buffer.
                        sizeof(NdsReply), // Size of response buffer.
                        &dwReplyLength,     // Length of response returned.
                        "DD",           // Going to send 2 DWORDs, they are ...
                        0,                         // Version
                        lpNdsObject->ObjectId // The id of the object
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRemoveObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        goto ErrorExit;
    }

    (void) NwNdsCloseObject( (HANDLE) lpNdsObject );
    lpNdsObject = NULL;

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRemoveObject: The remove object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        goto ErrorExit;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;


ErrorExit :

    if ( szFullObjectDN )
    {
        (void) LocalFree( szFullObjectDN );
    }

    if ( lpNdsObject )
    {
        (void) NwNdsCloseObject( (HANDLE) lpNdsObject );
    }

    return (DWORD) UNSUCCESSFUL;
}


DWORD
NwNdsRenameObject(
    IN  HANDLE hParentObject,
    IN  LPWSTR szObjectName,
    IN  LPWSTR szNewObjectName,
    IN  BOOL   fDeleteOldName )
/*
   NwNdsRenameObject()

   This function is used to rename an object in a NDS directory tree.

   Arguments:

       HANDLE           hParentObject - A handle to the parent object container
                        in the directory tree to rename leaf object in.
                        Handle is obtained by calling NwNdsOpenObject.

       LPWSTR           szObjectName - The directory name of the object to be
                        renamed.

       LPWSTR           szNewObjectName - The new directory name of the object.

       BOOL             fDeleteOldName - If true, the old name is discarded;
                        Otherwise, the old name is retained as an additional
                        attribute.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD    nwstatus;
    DWORD    status = NO_ERROR;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    DWORD    dwReplyLength;
    BYTE     NdsReply[TWO_KB]; // A 2K buffer is plenty for a response
    LPNDS_OBJECT_PRIV lpNdsParentObject = (LPNDS_OBJECT_PRIV) hParentObject;
    LPNDS_OBJECT_PRIV lpNdsObject = NULL;
    LPWSTR   szFullObjectDN = NULL;
    LPWSTR   szTempStr = NULL;
    DWORD    length;
    UNICODE_STRING ObjectName;
    UNICODE_STRING NewObjectName;

    if (  szObjectName == NULL ||
          szNewObjectName == NULL ||
          lpNdsParentObject == NULL ||
          lpNdsParentObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    RtlInitUnicodeString( &ObjectName, szObjectName );
    RtlInitUnicodeString( &NewObjectName, szNewObjectName );

    //
    // Create a buffer to hold the full object distinguished name.
    // \\tree\<--Object Name-->.<existing container path, if any>
    //
    szFullObjectDN = (LPWSTR) LocalAlloc(
                               LPTR,
                               ( wcslen( lpNdsParentObject->szContainerName ) *
                                 sizeof(WCHAR) ) +     // Container name
                                 ObjectName.Length +     // Object name
                                 ( 2 * sizeof(WCHAR) ) ); // Extras

    //
    // Check that the memory allocation was successful.
    //
    if ( szFullObjectDN == NULL )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRenameObject LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    length = ParseNdsUncPath( &szTempStr,
                              lpNdsParentObject->szContainerName,
                              PARSE_NDS_GET_TREE_NAME );

    length /= sizeof(WCHAR);

    wcscpy( szFullObjectDN, L"\\\\" );              // <\\>
    wcsncat( szFullObjectDN, szTempStr, length );   // <\\tree>
    wcscat( szFullObjectDN, L"\\" );                // <\\tree\>
    wcsncat( szFullObjectDN, ObjectName.Buffer,
             ObjectName.Length );                   // <\\tree\obj>

    length = ParseNdsUncPath( &szTempStr,
                              lpNdsParentObject->szContainerName,
                              PARSE_NDS_GET_PATH_NAME );

    if ( length > 0 )
    {
        length /= sizeof(WCHAR);
        wcscat( szFullObjectDN, L"." );              // <\\tree\obj.>
        wcsncat( szFullObjectDN, szTempStr, length );// <\\tree\obj.org_unt.org>
    }

    status = NwNdsOpenObject( szFullObjectDN,
                              NULL,
                              NULL,
                              (HANDLE *) &lpNdsObject,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL );

    if ( status != NO_ERROR )
    {
        // NwNdsOpenObject will have already set the last error . . .
        goto ErrorExit;
    }

    (void) LocalFree( szFullObjectDN );
    szFullObjectDN = NULL;

    ntstatus =
        FragExWithWait(
                        lpNdsParentObject->NdsTree,
                        NETWARE_NDS_FUNCTION_MODIFY_RDN,
                        NdsReply,           // Response buffer.
                        sizeof(NdsReply),   // Size of response buffer.
                        &dwReplyLength,     // Length of response returned.
                        "DDDS",
                        0x00000000,         // Version
                        lpNdsObject->ObjectId,
                        fDeleteOldName ? 0x00021701 : 0x00021700,
                        &NewObjectName
                      );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRenameObject: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        goto ErrorExit;
    }

    (void) NwNdsCloseObject( (HANDLE) lpNdsObject );
    lpNdsObject = NULL;

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsRenameObject: The rename object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        goto ErrorExit;
    }

    SetLastError( MapNetwareErrorCode( nwstatus ) );
    return nwstatus;


ErrorExit :

    if ( szFullObjectDN )
    {
        (void) LocalFree( szFullObjectDN );
    }

    if ( lpNdsObject )
    {
        (void) NwNdsCloseObject( (HANDLE) lpNdsObject );
    }

    return (DWORD) UNSUCCESSFUL;
}


DWORD
NwNdsSearch(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType, // NDS_INFO_NAMES
                                           // or NDS_INFO_ATTR_NAMES_VALUES
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    IN OUT HANDLE *     lphOperationData )
/*
   NwNdsSearch()

   This function is used to query an NDS directory tree to find objects of
   a certain object type that match a specified search filter.

   Arguments:

       HANDLE           hStartFromObject - A HANDLE to an object in the
                        directory tree to start search from. Handle is
                        obtained by calling NwNdsOpenObject.

       DWORD            dwInformationType - Indicates whether user chooses to
                        read only the attribute name(s) on the search result
                        objects or read both the attribute name(s) and value(s)
                        from the search result objects.

       DWORD            dwScope -
                        NDS_SCOPE_ONE_LEVEL - Search subordinates from given
                                              object, one level only
                        NDS_SCOPE_SUB_TREE - Search from given object on down
                        NDS_SCOPE_BASE_LEVEL - Applies search to an object

       BOOL             fDerefAliases - If TRUE the search will dereference
                        aliased objects to the real objects and continue
                        to search in the aliased objects subtree. If FALSE
                        the search will not dereference aliases.

       LPQUERY_TREE     lpQueryTree - A pointer to the root of a
                        search tree which defines a query. This tree
                        is manipulated by the following functions:
                           NwNdsCreateQueryNode, NwNdsDeleteQueryNode,
                           and NwNdsDeleteQueryTree.

       LPDWORD          lpdwIterHandle - A pointer to a DWORD that has the
                        iteration handle value. On input, the handle value
                        is set to NDS_INITIAL_SEARCH or to a value previously
                        returned from a prior call to NwNdsSearch. On ouput,
                        the handle value is set to NDS_NO_MORE_ITERATIONS if
                        search is complete, or to some other value otherwise.

       HANDLE *         lphOperationData - The address of a HANDLE to data
                        containing a list of attributes to be read from the
                        objects that meet the search query. This handle is
                        manipulated by the following functions:
                           NwNdsCreateBuffer (NDS_SEARCH),
                           NwNdsPutInBuffer, and NwNdsFreeBuffer.

                                            - OR -

                        The address of a HANDLE set to NULL, which indicates
                        that all object attributes should be read from the
                        search objects found.

                        If these calls are successful, this handle will also
                        contain the read results from the call. In the later
                        case, a buffer will be created to contain the read
                        results. Object information with attribute information
                        can be retrieved from the buffer with the function:
                           NwNdsGetObjectListFromBuffer.

                        After the call to this function, this buffer is ONLY
                        manipulated by the functions:
                          NwNdsGetObjectListFromBuffer,
                          and NwNdsFreeBuffer.

    Returns:

       NO_ERROR
       UNSUCCESSFUL - Call GetLastError for Win32 error code.
*/
{
    DWORD dwNdsScope = NDS_SEARCH_SUBTREE;

    switch ( dwScope )
    {
        case NDS_SCOPE_ONE_LEVEL :
            dwNdsScope = NDS_SEARCH_SUBORDINATES;
            break;

        case NDS_SCOPE_SUB_TREE :
            dwNdsScope = NDS_SEARCH_SUBTREE;
            break;

        case NDS_SCOPE_BASE_LEVEL :
            dwNdsScope = NDS_SEARCH_ENTRY;
            break;
    }

    if ( hStartFromObject == NULL ||
         lpQueryTree == NULL ||
         lpdwIterHandle == NULL ||
         ((LPNDS_OBJECT_PRIV) hStartFromObject)->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( *lphOperationData == NULL )
    {
        //
        // The callee is asking for all attributes to be returned from search.
        //
        return Search_AllAttrs( hStartFromObject,
                                dwInformationType,
                                dwNdsScope,
                                fDerefAliases,
                                lpQueryTree,
                                lpdwIterHandle,
                                lphOperationData );
    }
    else if ( ((LPNDS_BUFFER) *lphOperationData)->lpRequestBuffer == NULL )
    {
        //
        // The callee has a handle from a prior call to NwNdsSearch, and is
        // still asking for all attributes to be returned from search.
        //
        return Search_AllAttrs( hStartFromObject,
                                dwInformationType,
                                dwNdsScope,
                                fDerefAliases,
                                lpQueryTree,
                                lpdwIterHandle,
                                lphOperationData );
    }
    else
    {
        //
        // The callee has a handle that they created with calls to
        // NwNdsCreateBuffer and NwNdsPutInBuffer to specify attributes
        // to be returned from search or NwNdsSearch was called once before
        // and we are resuming the search.
        //
        return Search_SomeAttrs( hStartFromObject,
                                 dwInformationType,
                                 dwNdsScope,
                                 fDerefAliases,
                                 lpQueryTree,
                                 lpdwIterHandle,
                                 lphOperationData );
    }
}


/* Local Function Implementations */

VOID
PrepareAddEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    DWORD          dwSyntaxID,
    LPBYTE         lpAttributeValues,
    DWORD          dwValueCount,
    LPDWORD        lpdwLengthInBytes )
{
    LPBYTE lpTemp = lpTempEntry;
    DWORD  dwStringLen = AttributeName.Length + sizeof(WCHAR);
    DWORD  dwPadLen = ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD ) -
                      dwStringLen;

    *lpdwLengthInBytes = 0;

    //
    // tommye - MS bug 71653 - added try/except wrapper
    //

    try {

        //
        // Write attribute name length to temp entry buffer.
        //
        * (LPDWORD) lpTemp = dwStringLen;
        *lpdwLengthInBytes += sizeof(DWORD);
        lpTemp += sizeof(DWORD);

        //
        // Write attribute name to temp entry buffer.
        //
        RtlCopyMemory( lpTemp, AttributeName.Buffer, AttributeName.Length );
        *lpdwLengthInBytes += AttributeName.Length;
        lpTemp += AttributeName.Length;

        //
        // Add the null character.
        //
        * (LPWSTR) lpTemp = L'\0';
        *lpdwLengthInBytes += sizeof(WCHAR);
        lpTemp += sizeof(WCHAR);

        //
        // Write padding (if needed) to temp entry buffer.
        //
        if ( dwPadLen )
        {
            RtlZeroMemory( lpTemp, dwPadLen );
            lpTemp += dwPadLen;
            *lpdwLengthInBytes += dwPadLen;
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        return;
    }

    //
    // Now add the value(s) to temp entry.
    //
    AppendValueToEntry( lpTemp,
                        dwSyntaxID,
                        lpAttributeValues,
                        dwValueCount,
                        lpdwLengthInBytes );
}


VOID
PrepareModifyEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    DWORD          dwSyntaxID,
    DWORD          dwAttrModificationOperation,
    LPBYTE         lpAttributeValues,
    DWORD          dwValueCount,
    LPDWORD        lpdwLengthInBytes )
{
    LPBYTE lpTemp = lpTempEntry;
    DWORD  dwStringLen = AttributeName.Length + sizeof(WCHAR);
    DWORD  dwPadLen = ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD ) -
                      dwStringLen;

    *lpdwLengthInBytes = 0;

    //
    // tommye - MS bug 71654 - added try/except wrapper
    //

    try {

        //
        // Write attribute modification operation to temp entry buffer.
        //
        * (LPDWORD) lpTemp = dwAttrModificationOperation;
        lpTemp += sizeof(DWORD);
        *lpdwLengthInBytes += sizeof(DWORD);

        //
        // Write attribute name length to temp entry buffer.
        //
        * (LPDWORD) lpTemp = dwStringLen;
        *lpdwLengthInBytes += sizeof(DWORD);
        lpTemp += sizeof(DWORD);

        //
        // Write attribute name to temp entry buffer.
        //
        RtlCopyMemory( lpTemp, AttributeName.Buffer, AttributeName.Length );
        *lpdwLengthInBytes += AttributeName.Length;
        lpTemp += AttributeName.Length;

        //
        // Add the null character.
        //
        * (LPWSTR) lpTemp = L'\0';
        *lpdwLengthInBytes += sizeof(WCHAR);
        lpTemp += sizeof(WCHAR);

        //
        // Write padding (if needed) to temp entry buffer.
        //
        if ( dwPadLen )
        {
            RtlZeroMemory( lpTemp, dwPadLen );
            lpTemp += dwPadLen;
            *lpdwLengthInBytes += dwPadLen;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        return;
    }

    //
    // Now add the value(s) to temp entry (if needed).
    //
    switch( dwAttrModificationOperation )
    {
        case NDS_ATTR_ADD_VALUE:
        case NDS_ATTR_ADDITIONAL_VALUE:
        case NDS_ATTR_OVERWRITE_VALUE:
        case NDS_ATTR_REMOVE_VALUE:
        case NDS_ATTR_CLEAR_VALUE:
        case NDS_ATTR_ADD:
            AppendValueToEntry( lpTemp,
                                dwSyntaxID,
                                lpAttributeValues,
                                dwValueCount,
                                lpdwLengthInBytes );
            break;

        case NDS_ATTR_REMOVE:
        case NDS_ATTR_CLEAR:
            // Don't need to do anything for these modification operations.
            break;

        default :
#if DBG
            KdPrint(( "NDS32: PrepareModifyEntry warning, unknown modification operation 0x%.8X\n", dwAttrModificationOperation ));
            ASSERT( FALSE );
#endif
            ; // Nothing, skip it.
    }
}


VOID
PrepareReadEntry(
    LPBYTE         lpTempEntry,
    UNICODE_STRING AttributeName,
    LPDWORD        lpdwLengthInBytes )
{
    LPBYTE lpTemp = lpTempEntry;
    DWORD  dwStringLen = AttributeName.Length + sizeof(WCHAR);
    DWORD  dwPadLen = ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD ) -
                      dwStringLen;

    *lpdwLengthInBytes = 0;

    //
    // tommye - MS bug 71655 - added try/except wrapper
    //

    try {
        //
        // Write attribute name length to temp entry buffer.
        //
        * (LPDWORD) lpTemp = dwStringLen;
        *lpdwLengthInBytes += sizeof(DWORD);
        lpTemp += sizeof(DWORD);

        //
        // Write attribute name to temp entry buffer.
        //
        RtlCopyMemory( lpTemp, AttributeName.Buffer, AttributeName.Length );
        *lpdwLengthInBytes += AttributeName.Length;
        lpTemp += AttributeName.Length;

        //
        // Add the null character.
        //
        * (LPWSTR) lpTemp = L'\0';
        *lpdwLengthInBytes += sizeof(WCHAR);
        lpTemp += sizeof(WCHAR);

        //
        // Write padding (if needed) to temp entry buffer.
        //
        if ( dwPadLen )
        {
            RtlZeroMemory( lpTemp, dwPadLen );
            lpTemp += dwPadLen;
            *lpdwLengthInBytes += dwPadLen;
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        return;
    }
}


DWORD
CalculateValueDataSize(
    DWORD           dwSyntaxId,
    LPBYTE          lpAttributeValues,
    DWORD           dwValueCount )
{
    LPBYTE lpAttrStart, lpAttrTemp = lpAttributeValues;
    LPBYTE lpField1, lpField2;
    DWORD  numFields;
    DWORD  length = 0;
    DWORD  stringLen, stringLen2;
    DWORD  iter, i;
    DWORD  dwLengthInBytes = 0;

    dwLengthInBytes += sizeof(DWORD);

    for ( iter = 0; iter < dwValueCount; iter++ )
    {
        switch ( dwSyntaxId )
        {
            case NDS_SYNTAX_ID_0 :
                break;

            case NDS_SYNTAX_ID_1 :
            case NDS_SYNTAX_ID_2 :
            case NDS_SYNTAX_ID_3 :
            case NDS_SYNTAX_ID_4 :
            case NDS_SYNTAX_ID_5 :
            case NDS_SYNTAX_ID_10 :
            case NDS_SYNTAX_ID_20 :

                stringLen = wcslen(((LPASN1_TYPE_1) lpAttrTemp)->DNString);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_1);
                break;

            case NDS_SYNTAX_ID_6 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrStart = lpAttrTemp;
                while(  ((LPASN1_TYPE_6) lpAttrTemp)->Next )
                {
                    stringLen = wcslen(((LPASN1_TYPE_6) lpAttrTemp)->String);
                    dwLengthInBytes += sizeof(DWORD);
                    dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                         ALIGN_DWORD);
                    lpAttrTemp = (LPBYTE)(((LPASN1_TYPE_6) lpAttrTemp)->Next);
                }
                stringLen = wcslen(((LPASN1_TYPE_6) lpAttrTemp)->String);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD);
                lpAttrTemp = lpAttrStart + sizeof(ASN1_TYPE_6);
                break;

            case NDS_SYNTAX_ID_7 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_7);
                break;

            case NDS_SYNTAX_ID_8 :
            case NDS_SYNTAX_ID_22 :
            case NDS_SYNTAX_ID_24 :
            case NDS_SYNTAX_ID_27 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_8);
                break;

            case NDS_SYNTAX_ID_9 :

                stringLen = ((LPASN1_TYPE_9) lpAttrTemp)->Length;
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen)*sizeof(BYTE),
                                                     ALIGN_DWORD );
                lpAttrTemp += sizeof(ASN1_TYPE_9);
                break;

            case NDS_SYNTAX_ID_11 :

                stringLen = wcslen(((LPASN1_TYPE_11) lpAttrTemp)->TelephoneNumber);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD );
                dwLengthInBytes += 2*sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_11);
                break;

            case NDS_SYNTAX_ID_12 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ((LPASN1_TYPE_12)
                    lpAttrTemp)->AddressLength * sizeof(WCHAR);
                lpAttrTemp += sizeof(ASN1_TYPE_12);
                break;

            case NDS_SYNTAX_ID_13 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrStart = lpAttrTemp;
                while ( ((LPASN1_TYPE_13) lpAttrTemp)->Next )
                {
                    stringLen = ((LPASN1_TYPE_13) lpAttrTemp)->Length;
                    dwLengthInBytes += sizeof(DWORD);
                    dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(BYTE),
                                                         ALIGN_DWORD);
                    lpAttrTemp = (LPBYTE)(((LPASN1_TYPE_13) lpAttrTemp)->Next);
                }
                stringLen = ((LPASN1_TYPE_13) lpAttrTemp)->Length;
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(BYTE),
                                                     ALIGN_DWORD);
                lpAttrTemp = lpAttrStart + sizeof(ASN1_TYPE_13);
                break;

            case NDS_SYNTAX_ID_14 :

                stringLen = wcslen(((LPASN1_TYPE_14) lpAttrTemp)->Address);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_14);
                break;

            case NDS_SYNTAX_ID_15 :

                stringLen = wcslen(((LPASN1_TYPE_15) lpAttrTemp)->VolumeName);
                stringLen2 = wcslen(((LPASN1_TYPE_15) lpAttrTemp)->Path);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_15);
                break;

            case NDS_SYNTAX_ID_16 :

                stringLen = wcslen(((LPASN1_TYPE_16) lpAttrTemp)->ServerName);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_16);

                break;

            case NDS_SYNTAX_ID_17 :

                stringLen = wcslen(((LPASN1_TYPE_17) lpAttrTemp)->ProtectedAttrName);
                stringLen2 = wcslen(((LPASN1_TYPE_17) lpAttrTemp)->SubjectName);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_17);
                break;

            case NDS_SYNTAX_ID_18 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                for ( i = 0; i < 6; i++ )
                {
                    stringLen = wcslen(((LPASN1_TYPE_18) lpAttrTemp)->PostalAddress[i]);
                    dwLengthInBytes += sizeof(DWORD);
                    dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                         ALIGN_DWORD);
                }
                lpAttrTemp += sizeof(ASN1_TYPE_18);
                break;

            case NDS_SYNTAX_ID_19 :

                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_19);
                break;

            case NDS_SYNTAX_ID_21 :

                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_21);
                break;

            case NDS_SYNTAX_ID_23 :
                break;

            case NDS_SYNTAX_ID_25 :

                stringLen = wcslen(((LPASN1_TYPE_25) lpAttrTemp)->ObjectName);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);
                dwLengthInBytes += sizeof(DWORD);
                dwLengthInBytes += sizeof(DWORD);
                lpAttrTemp += sizeof(ASN1_TYPE_25);
                break;

            case NDS_SYNTAX_ID_26 :
                break;

            default :
#if DBG
                KdPrint(( "NDS32: CalculateValueDataSize() unknown SyntaxId 0x%.8X.\n", dwSyntaxId ));
                ASSERT( FALSE );
#endif
                break;  // empty statement not allowed
        }
    }

    return dwLengthInBytes;
}


VOID
AppendValueToEntry(
    LPBYTE          lpBuffer,
    DWORD           dwSyntaxId,
    LPBYTE          lpAttributeValues,
    DWORD           dwValueCount,
    LPDWORD         lpdwLengthInBytes )
{
    LPBYTE lpTemp = lpBuffer;
    LPBYTE lpAttrStart, lpAttrTemp = lpAttributeValues;
    LPBYTE lpField1, lpField2;
    DWORD  numFields;
    DWORD  length = 0;
    DWORD  stringLen, stringLen2;
    DWORD  iter, i;

    *(LPDWORD)lpTemp = dwValueCount;
    lpTemp += sizeof(DWORD);
    *lpdwLengthInBytes += sizeof(DWORD);

    for ( iter = 0; iter < dwValueCount; iter++ )
    {
        switch ( dwSyntaxId )
        {
            case NDS_SYNTAX_ID_0 :
                break;

            case NDS_SYNTAX_ID_1 :
            case NDS_SYNTAX_ID_2 :
            case NDS_SYNTAX_ID_3 :
            case NDS_SYNTAX_ID_4 :
            case NDS_SYNTAX_ID_5 :
            case NDS_SYNTAX_ID_10 :
            case NDS_SYNTAX_ID_20 :

                stringLen = wcslen(((LPASN1_TYPE_1) lpAttrTemp)->DNString);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_1) lpAttrTemp)->DNString,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_1);
                break;

            case NDS_SYNTAX_ID_6 :

                lpField1 = lpTemp; // Save field to store the number of
                                   // bytes following
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 = 0;

                lpField2 = lpTemp; // Save field to store the number of
                                       // elements
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 += sizeof(DWORD);

                numFields = 0;

                lpAttrStart = lpAttrTemp;

                while(  ((LPASN1_TYPE_6) lpAttrTemp)->Next )
                {
                    stringLen = wcslen(((LPASN1_TYPE_6) lpAttrTemp)->String);

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    *lpdwLengthInBytes += sizeof(DWORD);
                    *(LPDWORD)lpField1 += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   ((LPASN1_TYPE_6) lpAttrTemp)->String,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                             ALIGN_DWORD);
                    *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                         ALIGN_DWORD);
                    *(LPDWORD)lpField1 += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                           ALIGN_DWORD);

                    lpAttrTemp = (LPBYTE)(((LPASN1_TYPE_6) lpAttrTemp)->Next);

                    numFields++;
                }

                stringLen = wcslen(((LPASN1_TYPE_6) lpAttrTemp)->String);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_6) lpAttrTemp)->String,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD);
                *(LPDWORD)lpField1 += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD);

                lpAttrTemp = lpAttrStart + sizeof(ASN1_TYPE_6);

                numFields++;

                *(LPDWORD)lpField2 = numFields;

                break;

            case NDS_SYNTAX_ID_7 :

                *(LPDWORD)lpTemp = 1; // Needs to have value 1, representing one byte even though it is
                                      // padded out to four bytes.
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = 0; // This clears all bits of the DWORD
                *(LPBYTE)lpTemp = (BYTE) (((LPASN1_TYPE_7)
                                                lpAttrTemp)->Boolean);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_7);

                break;

            case NDS_SYNTAX_ID_8 :
            case NDS_SYNTAX_ID_22 :
            case NDS_SYNTAX_ID_24 :
            case NDS_SYNTAX_ID_27 :

                *(LPDWORD)lpTemp = 4; // Needs to have value 4, representing four bytes - already DWORD aligned.
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_8) lpAttrTemp)->Integer;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_8);

                break;

            case NDS_SYNTAX_ID_9 :

                stringLen = ((LPASN1_TYPE_9) lpAttrTemp)->Length;

                *(LPDWORD)lpTemp = (stringLen)  * sizeof(BYTE);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_9) lpAttrTemp)->OctetString,
                               stringLen*sizeof(BYTE) );
                lpTemp += ROUND_UP_COUNT((stringLen)*sizeof(BYTE),
                                         ALIGN_DWORD );
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen)*sizeof(BYTE),
                                                     ALIGN_DWORD );

                lpAttrTemp += sizeof(ASN1_TYPE_9);

                break;

            case NDS_SYNTAX_ID_11 :

                stringLen = wcslen(((LPASN1_TYPE_11) lpAttrTemp)->TelephoneNumber);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                    ALIGN_DWORD) +
                                     ( 2*sizeof(DWORD) );
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_11) lpAttrTemp)->TelephoneNumber,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD );

                lpTemp += 2*sizeof(DWORD);
                *lpdwLengthInBytes += 2*sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_11);

                break;

            case NDS_SYNTAX_ID_12 :

                *(LPDWORD)lpTemp =
                     (2*sizeof(DWORD)) +
                     (((LPASN1_TYPE_12) lpAttrTemp)->AddressLength*sizeof(WCHAR));
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_12) lpAttrTemp)->AddressType;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                //
                // Write address length value to buffer
                //
                *(LPDWORD)lpTemp = ((LPASN1_TYPE_12) lpAttrTemp)->AddressLength;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                //
                // Write the address to the buffer
                //
                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_12) lpAttrTemp)->Address,
                               ((LPASN1_TYPE_12) lpAttrTemp)->AddressLength
                               * sizeof(WCHAR) );
                lpTemp += ((LPASN1_TYPE_12) lpAttrTemp)->AddressLength *
                          sizeof(WCHAR);
                *lpdwLengthInBytes += ((LPASN1_TYPE_12)
                    lpAttrTemp)->AddressLength * sizeof(WCHAR);

                lpAttrTemp += sizeof(ASN1_TYPE_12);

                break;

            case NDS_SYNTAX_ID_13 :

                lpField1 = lpTemp; // Save field to store the number of
                                   // bytes following
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 = 0;

                lpField2 = lpTemp; // Save field to store the number of
                                       // elements
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 += sizeof(DWORD);

                numFields = 0;

                lpAttrStart = lpAttrTemp;

                while ( ((LPASN1_TYPE_13) lpAttrTemp)->Next )
                {
                    stringLen = ((LPASN1_TYPE_13) lpAttrTemp)->Length;

                    *(LPDWORD)lpTemp = stringLen;
                    lpTemp += sizeof(DWORD);
                    *lpdwLengthInBytes += sizeof(DWORD);
                    *(LPDWORD)lpField1 += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   ((LPASN1_TYPE_13) lpAttrTemp)->Data,
                                   stringLen*sizeof(BYTE) );
                    lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(BYTE),
                                             ALIGN_DWORD);
                    *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(BYTE),
                                                         ALIGN_DWORD);
                    *(LPDWORD)lpField1 += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(BYTE),
                                                         ALIGN_DWORD);

                    lpAttrTemp = (LPBYTE)(((LPASN1_TYPE_13) lpAttrTemp)->Next);

                    numFields++;
                }

                stringLen = ((LPASN1_TYPE_13) lpAttrTemp)->Length;

                *(LPDWORD)lpTemp = stringLen;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_13) lpAttrTemp)->Data,
                               stringLen*sizeof(BYTE) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(BYTE),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(BYTE),
                                                     ALIGN_DWORD);
                *(LPDWORD)lpField1 += ROUND_UP_COUNT((stringLen+1)*
                                                     sizeof(BYTE),
                                                     ALIGN_DWORD);

                lpAttrTemp = lpAttrStart + sizeof(ASN1_TYPE_13);

                numFields++;

                *(LPDWORD)lpField2 = numFields;

                break;

            case NDS_SYNTAX_ID_14 :

                stringLen = wcslen(((LPASN1_TYPE_14) lpAttrTemp)->Address);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD) +
                                   sizeof(DWORD);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_14) lpAttrTemp)->Type;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen + 1)*sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_14) lpAttrTemp)->Address,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_14);

                break;

            case NDS_SYNTAX_ID_15 :

                stringLen = wcslen(((LPASN1_TYPE_15) lpAttrTemp)->VolumeName);
                stringLen2 = wcslen(((LPASN1_TYPE_15) lpAttrTemp)->Path);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD) +
                                   ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD) +
                                   sizeof(DWORD);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_15) lpAttrTemp)->Type;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen+1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_15) lpAttrTemp)->VolumeName,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                *(LPDWORD)lpTemp = (stringLen2+1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_15) lpAttrTemp)->Path,
                               stringLen2*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_15);

                break;

            case NDS_SYNTAX_ID_16 :

                stringLen = wcslen(((LPASN1_TYPE_16) lpAttrTemp)->ServerName);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD) +
                                                  (4*sizeof(DWORD));
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_16) lpAttrTemp)->ServerName,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_16) lpAttrTemp)->ReplicaType;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_16) lpAttrTemp)->ReplicaNumber;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_16) lpAttrTemp)->Count;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_16);

                break;

            case NDS_SYNTAX_ID_17 :

                stringLen = wcslen(((LPASN1_TYPE_17) lpAttrTemp)->ProtectedAttrName);
                stringLen2 = wcslen(((LPASN1_TYPE_17) lpAttrTemp)->SubjectName);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                    ALIGN_DWORD) +
                                     ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                    ALIGN_DWORD) +
                                     sizeof(DWORD);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_17)lpAttrTemp)->ProtectedAttrName,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                *(LPDWORD)lpTemp = (stringLen2 + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_17) lpAttrTemp)->SubjectName,
                               stringLen2*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen2+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_17) lpAttrTemp)->Privileges;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_17);

                break;

            case NDS_SYNTAX_ID_18 :

                lpField1 = lpTemp; // Save field to store the number of
                                   // bytes following
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 = 0;

                *(LPDWORD)lpTemp = 6; // The number of postal address fields
                                      // is always six.
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);
                *(LPDWORD)lpField1 += sizeof(DWORD);

                for ( i = 0; i < 6; i++ )
                {
                    stringLen = wcslen(((LPASN1_TYPE_18) lpAttrTemp)->PostalAddress[i]);

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    *lpdwLengthInBytes += sizeof(DWORD);
                    *(LPDWORD)lpField1 += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   ((LPASN1_TYPE_18) lpAttrTemp)->PostalAddress[i],
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                             ALIGN_DWORD);
                    *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                         ALIGN_DWORD);
                    *(LPDWORD)lpField1 += ROUND_UP_COUNT((stringLen+1)*
                                                         sizeof(WCHAR),
                                                         ALIGN_DWORD);
                }

                lpAttrTemp += sizeof(ASN1_TYPE_18);

                break;

            case NDS_SYNTAX_ID_19 :

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_19) lpAttrTemp)->WholeSeconds;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_19) lpAttrTemp)->EventID;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_19);

                break;

            case NDS_SYNTAX_ID_21 :

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_21) lpAttrTemp)->Length;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_21);

                break;

            case NDS_SYNTAX_ID_23 :
                break;

            case NDS_SYNTAX_ID_25 :

                stringLen = wcslen(((LPASN1_TYPE_25) lpAttrTemp)->ObjectName);

                *(LPDWORD)lpTemp = ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                  ALIGN_DWORD) +
                                   2*sizeof(DWORD);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                RtlCopyMemory( lpTemp,
                               ((LPASN1_TYPE_25) lpAttrTemp)->ObjectName,
                               stringLen*sizeof(WCHAR) );
                lpTemp += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                         ALIGN_DWORD);
                *lpdwLengthInBytes += ROUND_UP_COUNT((stringLen+1)*sizeof(WCHAR),
                                                     ALIGN_DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_25) lpAttrTemp)->Level;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                *(LPDWORD)lpTemp = ((LPASN1_TYPE_25) lpAttrTemp)->Interval;
                lpTemp += sizeof(DWORD);
                *lpdwLengthInBytes += sizeof(DWORD);

                lpAttrTemp += sizeof(ASN1_TYPE_25);

                break;

            case NDS_SYNTAX_ID_26 :
                break;

            default :
#if DBG
                KdPrint(( "NDS32: AppendValueToEntry() unknown SyntaxId 0x%.8X.\n", dwSyntaxId ));
                ASSERT( FALSE );
#endif
                break;  // empty statement not allowed
        }
    }
}


DWORD
MapNetwareErrorCode(
    DWORD dwNetwareError )
{
    DWORD status = NO_ERROR;

    switch( dwNetwareError )
    {
        case NDS_ERR_SUCCESS :
            status = NO_ERROR;
            break;

        case NDS_ERR_NO_SUCH_ENTRY :
        case NDS_ERR_NO_SUCH_VALUE :
        case NDS_ERR_NO_SUCH_ATTRIBUTE :
        case NDS_ERR_NO_SUCH_CLASS :
        case NDS_ERR_NO_SUCH_PARTITION :
            status = ERROR_EXTENDED_ERROR;
            break;

        case NDS_ERR_ENTRY_ALREADY_EXISTS :
            status = ERROR_ALREADY_EXISTS;
            break;

        case NDS_ERR_NOT_EFFECTIVE_CLASS :
        case NDS_ERR_ILLEGAL_ATTRIBUTE :
        case NDS_ERR_MISSING_MANDATORY :
        case NDS_ERR_ILLEGAL_DS_NAME :
        case NDS_ERR_ILLEGAL_CONTAINMENT :
        case NDS_ERR_CANT_HAVE_MULTIPLE_VALUES :
        case NDS_ERR_SYNTAX_VIOLATION :
        case NDS_ERR_DUPLICATE_VALUE :
        case NDS_ERR_ATTRIBUTE_ALREADY_EXISTS :
        case NDS_ERR_MAXIMUM_ENTRIES_EXIST :
        case NDS_ERR_DATABASE_FORMAT :
        case NDS_ERR_INCONSISTANT_DATABASE :
        case NDS_ERR_INVALID_COMPARISON :
        case NDS_ERR_COMPARISON_FAILED :
        case NDS_ERR_TRANSACTIONS_DISABLED :
        case NDS_ERR_INVALID_TRANSPORT :
        case NDS_ERR_SYNTAX_INVALID_IN_NAME :
        case NDS_ERR_REPLICA_ALREADY_EXISTS :
        case NDS_ERR_TRANSPORT_FAILURE :
        case NDS_ERR_ALL_REFERRALS_FAILED :
        case NDS_ERR_CANT_REMOVE_NAMING_VALUE :
        case NDS_ERR_OBJECT_CLASS_VIOLATION :
        case NDS_ERR_ENTRY_IS_NOT_LEAF :
        case NDS_ERR_DIFFERENT_TREE :
        case NDS_ERR_ILLEGAL_REPLICA_TYPE :
        case NDS_ERR_SYSTEM_FAILURE :
        case NDS_ERR_INVALID_ENTRY_FOR_ROOT :
        case NDS_ERR_NO_REFERRALS :
        case NDS_ERR_REMOTE_FAILURE :
        case NDS_ERR_INVALID_REQUEST :
        case NDS_ERR_INVALID_ITERATION :
        case NDS_ERR_SCHEMA_IS_NONREMOVABLE :
        case NDS_ERR_SCHEMA_IS_IN_USE :
        case NDS_ERR_CLASS_ALREADY_EXISTS :
        case NDS_ERR_BAD_NAMING_ATTRIBUTES :
        case NDS_ERR_NOT_ROOT_PARTITION :
        case NDS_ERR_INSUFFICIENT_STACK :
        case NDS_ERR_INSUFFICIENT_BUFFER :
        case NDS_ERR_AMBIGUOUS_CONTAINMENT :
        case NDS_ERR_AMBIGUOUS_NAMING :
        case NDS_ERR_DUPLICATE_MANDATORY :
        case NDS_ERR_DUPLICATE_OPTIONAL :
        case NDS_ERR_MULTIPLE_REPLICAS :
        case NDS_ERR_CRUCIAL_REPLICA :
        case NDS_ERR_SCHEMA_SYNC_IN_PROGRESS :
        case NDS_ERR_SKULK_IN_PROGRESS :
        case NDS_ERR_TIME_NOT_SYNCRONIZED :
        case NDS_ERR_RECORD_IN_USE :
        case NDS_ERR_DS_VOLUME_NOT_MOUNTED :
        case NDS_ERR_DS_VOLUME_IO_FAILURE :
        case NDS_ERR_DS_LOCKED :
        case NDS_ERR_OLD_EPOCH :
        case NDS_ERR_NEW_EPOCH :
        case NDS_ERR_PARTITION_ROOT :
        case NDS_ERR_ENTRY_NOT_CONTAINER :
        case NDS_ERR_FAILED_AUTHENTICATION :
        case NDS_ERR_NO_SUCH_PARENT :
            status = ERROR_EXTENDED_ERROR;
            break;

        case NDS_ERR_NO_ACCESS :
            status = ERROR_ACCESS_DENIED;
            break;

        case NDS_ERR_REPLICA_NOT_ON :
        case NDS_ERR_DUPLICATE_ACL :
        case NDS_ERR_PARTITION_ALREADY_EXISTS :
        case NDS_ERR_NOT_SUBREF :
        case NDS_ERR_ALIAS_OF_AN_ALIAS :
        case NDS_ERR_AUDITING_FAILED :
        case NDS_ERR_INVALID_API_VERSION :
        case NDS_ERR_SECURE_NCP_VIOLATION :
        case NDS_ERR_FATAL :
            status = ERROR_EXTENDED_ERROR;
            break;

        default :
#if DBG
            KdPrint(( "NDS32: MapNetwareErrorCode failed, Netware error = 0x%.8X\n", dwNetwareError ));
            ASSERT( FALSE );
#endif

            status = ERROR_EXTENDED_ERROR;
    }

    return status;
}


DWORD
IndexReadAttrDefReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer )
{
    LPNDS_ATTR_DEF lpReplyIndex = NULL;
    DWORD          iter;
    LPBYTE         lpByte = NULL;
    DWORD          dwStringLen;

    //
    // Make sure this is set to zero, for NwNdsGetNextXXXXFromBuffer()
    //
    lpNdsBuffer->dwCurrentIndexEntry = 0;

    //
    // Set values used to track the memory used in the index buffer.
    //
    lpNdsBuffer->dwIndexBufferSize = lpNdsBuffer->dwNumberOfReplyEntries *
                                     sizeof(NDS_ATTR_DEF);
    lpNdsBuffer->dwIndexAvailableBytes = lpNdsBuffer->dwIndexBufferSize;
    lpNdsBuffer->dwNumberOfIndexEntries = 0;
    lpNdsBuffer->dwLengthOfIndexData = 0;

    //
    // Create a buffer to hold the ReplyBufferIndex
    //
    lpReplyIndex = (LPNDS_ATTR_DEF)
        LocalAlloc( LPTR, lpNdsBuffer->dwIndexBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpReplyIndex == NULL )
    {
#if DBG
        KdPrint(( "NDS32: IndexReadAttrDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->lpIndexBuffer = (LPBYTE) lpReplyIndex;

    //
    // Move lpByte so that it points to the first attribute definition
    //
    lpByte = lpNdsBuffer->lpReplyBuffer;

    // lpByte += sizeof(DWORD);  // Move past Completion Code
    // lpByte += sizeof(DWORD);  // Move past Iteration Handle
    // lpByte += sizeof(DWORD);  // Move past Information Type
    // lpByte += sizeof(DWORD);  // Move past Amount Of Attributes
    lpByte += 4 * sizeof(DWORD); // Equivalent to above

    //
    // In a for loop, walk the reply buffer index and fill it up with
    // data by referencing the Reply buffer or Syntax buffer.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfReplyEntries; iter++ )
    {
        dwStringLen = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Attribute Name Length

        lpReplyIndex[iter].szAttributeName = (LPWSTR) lpByte;
        lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );

        lpReplyIndex[iter].dwFlags = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Flags

        lpReplyIndex[iter].dwSyntaxID = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Syntax ID

        lpReplyIndex[iter].dwLowerLimit = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Lower Limit

        lpReplyIndex[iter].dwUpperLimit = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Upper Limit

        lpReplyIndex[iter].asn1ID.length = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past ASN.1 ID length

        RtlCopyMemory( lpReplyIndex[iter].asn1ID.data,
                       lpByte,
                       sizeof(BYTE) * NDS_MAX_ASN1_NAME_LEN );
        lpByte += sizeof(BYTE) * NDS_MAX_ASN1_NAME_LEN;

        lpNdsBuffer->dwNumberOfIndexEntries++;
        lpNdsBuffer->dwLengthOfIndexData += sizeof( NDS_ATTR_DEF );
        lpNdsBuffer->dwIndexAvailableBytes -= sizeof( NDS_ATTR_DEF );
    }

#if DBG
    if ( lpNdsBuffer->dwLengthOfIndexData != lpNdsBuffer->dwIndexBufferSize )
    {
        KdPrint(( "ASSERT in NDS32: IndexReadAttrDefReplyBuffer\n" ));
        KdPrint(( "       lpNdsBuffer->dwLengthOfIndexData !=\n" ));
        KdPrint(( "       lpNdsBuffer->dwIndexBufferSize\n" ));
        ASSERT( FALSE );
    }
#endif

    return NO_ERROR;
}


DWORD
IndexReadClassDefReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer )
{
    LPNDS_CLASS_DEF lpReplyIndex = NULL;
    DWORD           iter;
    LPBYTE          lpByte = NULL;
    DWORD           LengthOfValueStructs;
    DWORD           dwStringLen;

    //
    // Make sure this is set to zero, for NwNdsGetNextXXXXFromBuffer()
    //
    lpNdsBuffer->dwCurrentIndexEntry = 0;

    //
    // Set values used to track the memory used in the index buffer.
    //
    lpNdsBuffer->dwIndexBufferSize = lpNdsBuffer->dwNumberOfReplyEntries *
                                     sizeof(NDS_CLASS_DEF);
    lpNdsBuffer->dwIndexAvailableBytes = lpNdsBuffer->dwIndexBufferSize;
    lpNdsBuffer->dwNumberOfIndexEntries = 0;
    lpNdsBuffer->dwLengthOfIndexData = 0;

    //
    // Create a buffer to hold the ReplyBufferIndex
    //
    lpReplyIndex = (LPNDS_CLASS_DEF)
        LocalAlloc( LPTR,
                    lpNdsBuffer->dwIndexBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpReplyIndex == NULL )
    {
#if DBG
        KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->lpIndexBuffer = (LPBYTE) lpReplyIndex;

    //
    // Move lpByte so that it points to the SyntaxId of the first attribute
    //
    lpByte = lpNdsBuffer->lpReplyBuffer;

    // lpByte += sizeof(DWORD); // Move past Completion Code
    // lpByte += sizeof(DWORD); // Move past Iteration Handle
    // lpByte += sizeof(DWORD); // Move past Information Type
    // lpByte += sizeof(DWORD); // Move past Amount Of Attributes
    lpByte += 4 * sizeof(DWORD); // Equivalent to above

    //
    // In a for loop, walk the index buffer and fill it up with
    // data by referencing the reply buffer. Note references to
    // the syntax buffer are stored as offsets while un-marshalling.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfReplyEntries; iter++ )
    {
        dwStringLen = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Class Name Length

        lpReplyIndex[iter].szClassName = (LPWSTR) lpByte;
        lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );

        lpReplyIndex[iter].dwFlags = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Flags

        lpReplyIndex[iter].asn1ID.length = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past ASN.1 ID length

        RtlCopyMemory( lpReplyIndex[iter].asn1ID.data,
                       lpByte,
                       sizeof(BYTE) * NDS_MAX_ASN1_NAME_LEN );
        lpByte += sizeof(BYTE) * NDS_MAX_ASN1_NAME_LEN;

        lpReplyIndex[iter].dwNumberOfSuperClasses = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD);

        if ( lpReplyIndex[iter].dwNumberOfSuperClasses > 0 )
        {
           if ( VerifyBufferSizeForStringList(
                             lpNdsBuffer->dwSyntaxAvailableBytes,
                             lpReplyIndex[iter].dwNumberOfSuperClasses,
                             &LengthOfValueStructs ) != NO_ERROR )
           {
               if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer ) != NO_ERROR )
               {
#if DBG
                   KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   return (DWORD) UNSUCCESSFUL;
               }
           }

           lpByte += ParseStringListBlob(
                          lpByte,
                          lpReplyIndex[iter].dwNumberOfSuperClasses,
                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

           lpReplyIndex[iter].lpSuperClasses =
                (LPWSTR_LIST) lpNdsBuffer->dwLengthOfSyntaxData;
           lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
           lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
        }
        else
        {
            lpReplyIndex[iter].lpSuperClasses = NULL;
        }

        lpReplyIndex[iter].dwNumberOfContainmentClasses = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD);

        if ( lpReplyIndex[iter].dwNumberOfContainmentClasses > 0 )
        {
           if ( VerifyBufferSizeForStringList(
                             lpNdsBuffer->dwSyntaxAvailableBytes,
                             lpReplyIndex[iter].dwNumberOfContainmentClasses,
                             &LengthOfValueStructs ) != NO_ERROR )
           {
               if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer ) !=
                    NO_ERROR )
               {
#if DBG
                   KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   return (DWORD) UNSUCCESSFUL;
               }
           }

           lpByte += ParseStringListBlob(
                          lpByte,
                          lpReplyIndex[iter].dwNumberOfContainmentClasses,
                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

           lpReplyIndex[iter].lpContainmentClasses =
                (LPWSTR_LIST) lpNdsBuffer->dwLengthOfSyntaxData;
           lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
           lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
        }
        else
        {
            lpReplyIndex[iter].lpContainmentClasses = NULL;
        }

        lpReplyIndex[iter].dwNumberOfNamingAttributes = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD);

        if ( lpReplyIndex[iter].dwNumberOfNamingAttributes > 0 )
        {
           if ( VerifyBufferSizeForStringList(
                             lpNdsBuffer->dwSyntaxAvailableBytes,
                             lpReplyIndex[iter].dwNumberOfNamingAttributes,
                             &LengthOfValueStructs ) != NO_ERROR )
           {
               if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer ) != NO_ERROR )
               {
#if DBG
                   KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   return (DWORD) UNSUCCESSFUL;
               }
           }

           lpByte += ParseStringListBlob(
                          lpByte,
                          lpReplyIndex[iter].dwNumberOfNamingAttributes,
                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

           lpReplyIndex[iter].lpNamingAttributes =
                (LPWSTR_LIST) lpNdsBuffer->dwLengthOfSyntaxData;
           lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
           lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
        }
        else
        {
            lpReplyIndex[iter].lpNamingAttributes = NULL;
        }

        lpReplyIndex[iter].dwNumberOfMandatoryAttributes = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD);

        if ( lpReplyIndex[iter].dwNumberOfMandatoryAttributes > 0 )
        {
           if ( VerifyBufferSizeForStringList(
                             lpNdsBuffer->dwSyntaxAvailableBytes,
                             lpReplyIndex[iter].dwNumberOfMandatoryAttributes,
                             &LengthOfValueStructs ) != NO_ERROR )
           {
               if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer ) != NO_ERROR )
               {
#if DBG
                   KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   return (DWORD) UNSUCCESSFUL;
               }
           }

           lpByte += ParseStringListBlob(
                          lpByte,
                          lpReplyIndex[iter].dwNumberOfMandatoryAttributes,
                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

           lpReplyIndex[iter].lpMandatoryAttributes =
                (LPWSTR_LIST) lpNdsBuffer->dwLengthOfSyntaxData;
           lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
           lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
        }
        else
        {
            lpReplyIndex[iter].lpMandatoryAttributes = NULL;
        }

        lpReplyIndex[iter].dwNumberOfOptionalAttributes = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD);

        if ( lpReplyIndex[iter].dwNumberOfOptionalAttributes > 0 )
        {
           if ( VerifyBufferSizeForStringList(
                             lpNdsBuffer->dwSyntaxAvailableBytes,
                             lpReplyIndex[iter].dwNumberOfOptionalAttributes,
                             &LengthOfValueStructs ) != NO_ERROR )
           {
               if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer ) != NO_ERROR )
               {
#if DBG
                   KdPrint(( "NDS32: IndexReadClassDefReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   return (DWORD) UNSUCCESSFUL;
               }
           }

           lpByte += ParseStringListBlob(
                          lpByte,
                          lpReplyIndex[iter].dwNumberOfOptionalAttributes,
                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

           lpReplyIndex[iter].lpOptionalAttributes =
                (LPWSTR_LIST) lpNdsBuffer->dwLengthOfSyntaxData;
           lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
           lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
        }
        else
        {
            lpReplyIndex[iter].lpOptionalAttributes = NULL;
        }

        lpNdsBuffer->dwNumberOfIndexEntries++;
        lpNdsBuffer->dwLengthOfIndexData += sizeof( NDS_CLASS_DEF );
        lpNdsBuffer->dwIndexAvailableBytes -= sizeof( NDS_CLASS_DEF );
    }

    //
    // Now convert all syntax buffer references to pointers.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfIndexEntries; iter++ )
    {
        if ( lpReplyIndex[iter].dwNumberOfSuperClasses > 0 )
        {
           (LPBYTE) lpReplyIndex[iter].lpSuperClasses +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
        }

        if ( lpReplyIndex[iter].dwNumberOfContainmentClasses > 0 )
        {
           (LPBYTE) lpReplyIndex[iter].lpContainmentClasses +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
        }

        if ( lpReplyIndex[iter].dwNumberOfNamingAttributes > 0 )
        {
           (LPBYTE) lpReplyIndex[iter].lpNamingAttributes +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
        }

        if ( lpReplyIndex[iter].dwNumberOfMandatoryAttributes > 0 )
        {
           (LPBYTE) lpReplyIndex[iter].lpMandatoryAttributes +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
        }

        if ( lpReplyIndex[iter].dwNumberOfOptionalAttributes > 0 )
        {
           (LPBYTE) lpReplyIndex[iter].lpOptionalAttributes +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
        }
    }

#if DBG
    if ( lpNdsBuffer->dwLengthOfIndexData != lpNdsBuffer->dwIndexBufferSize )
    {
        KdPrint(( "ASSERT in NDS32: IndexReadClassDefReplyBuffer\n" ));
        KdPrint(( "       lpNdsBuffer->dwLengthOfIndexData !=\n" ));
        KdPrint(( "       lpNdsBuffer->dwIndexBufferSize\n" ));
        ASSERT( FALSE );
    }
#endif

    return NO_ERROR;
}


DWORD
IndexReadObjectReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer )
{
    LPNDS_ATTR_INFO lpReplyIndex = NULL;
    DWORD           iter;
    LPBYTE          lpByte = NULL;
    DWORD           LengthOfValueStructs;
    DWORD           dwStringLen;

    //
    // Make sure this is set to zero, for NwNdsGetNextXXXXFromBuffer()
    //
    lpNdsBuffer->dwCurrentIndexEntry = 0;

    //
    // Set values used to track the memory used in the index buffer.
    //
    lpNdsBuffer->dwIndexBufferSize = lpNdsBuffer->dwNumberOfReplyEntries *
                                     sizeof(NDS_ATTR_INFO);
    lpNdsBuffer->dwIndexAvailableBytes = lpNdsBuffer->dwIndexBufferSize;
    lpNdsBuffer->dwNumberOfIndexEntries = 0;
    lpNdsBuffer->dwLengthOfIndexData = 0;

    //
    // Create a buffer to hold the ReplyBufferIndex
    //
    lpReplyIndex = (LPNDS_ATTR_INFO)
        LocalAlloc( LPTR, lpNdsBuffer->dwIndexBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpReplyIndex == NULL )
    {
#if DBG
        KdPrint(( "NDS32: IndexReadObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->lpIndexBuffer = (LPBYTE) lpReplyIndex;

    //
    // Move lpByte so that it points to the SyntaxId of the first attribute
    //
    lpByte = lpNdsBuffer->lpReplyBuffer;

    // lpByte += sizeof(DWORD); // Move past Completion Code
    // lpByte += sizeof(DWORD); // Move past Iteration Handle
    // lpByte += sizeof(DWORD); // Move past Information Type
    // lpByte += sizeof(DWORD); // Move past Amount Of Attributes
    lpByte += 4 * sizeof(DWORD); // Equivalent to above

    //
    // In a for loop, walk the index buffer and fill it up with
    // data by referencing the reply buffer. Note references to
    // the syntax buffer are stored as offsets while un-marshalling.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfReplyEntries; iter++ )
    {
        lpReplyIndex[iter].dwSyntaxId = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Syntax Id

        dwStringLen = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Attribute Name Length

        lpReplyIndex[iter].szAttributeName = (LPWSTR) lpByte;
        lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );

        lpReplyIndex[iter].dwNumberOfValues = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Count Of Values

        //
        // See if the syntax buffer is large enough to hold the number of
        // SyntaxID structures that will be used to store the value(s)
        // for the current attribute. If the buffer isn't large enough
        // it is reallocated to a bigger size (if possible).
        //
        if ( VerifyBufferSize( lpByte,
                               lpNdsBuffer->dwSyntaxAvailableBytes,
                               lpReplyIndex[iter].dwSyntaxId,
                               lpReplyIndex[iter].dwNumberOfValues,
                               &LengthOfValueStructs ) != NO_ERROR )
        {
            if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer ) != NO_ERROR )
            {
#if DBG
                KdPrint(( "NDS32: IndexReadObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                return (DWORD) UNSUCCESSFUL;
            }
        }

        //
        // Parse the raw data buffer by mapping the network structures to
        // the NDS Syntax structures we define in NdsSntx.h. Then move the
        // pointer used to walk the raw data buffer past the ASN.1 Values.
        //
        lpByte += ParseASN1ValueBlob( lpByte,
                                      lpReplyIndex[iter].dwSyntaxId,
                                      lpReplyIndex[iter].dwNumberOfValues,
                                      (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

        lpReplyIndex[iter].lpValue =
                (LPBYTE) lpNdsBuffer->dwLengthOfSyntaxData;
        lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
        lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;

        lpNdsBuffer->dwNumberOfIndexEntries++;
        lpNdsBuffer->dwLengthOfIndexData += sizeof( NDS_ATTR_INFO );
        lpNdsBuffer->dwIndexAvailableBytes -= sizeof( NDS_ATTR_INFO );
    }

    //
    // Now convert all syntax buffer references to pointers.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfIndexEntries; iter++ )
    {
        (LPBYTE) lpReplyIndex[iter].lpValue +=
                                          (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
    }

#if DBG
    if ( lpNdsBuffer->dwLengthOfIndexData != lpNdsBuffer->dwIndexBufferSize )
    {
        KdPrint(( "ASSERT in NDS32: IndexReadObjectReplyBuffer\n" ));
        KdPrint(( "       lpNdsBuffer->dwLengthOfIndexData !=\n" ));
        KdPrint(( "       lpNdsBuffer->dwIndexBufferSize\n" ));
        ASSERT( FALSE );
    }
#endif

    return NO_ERROR;
}


DWORD
IndexReadNameReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer )
{
    LPNDS_NAME_ONLY lpReplyIndex = NULL;
    DWORD           iter;
    LPBYTE          lpByte = NULL;
    DWORD           dwStringLen;

    //
    // Make sure this is set to zero, for NwNdsGetNextXXXXFromBuffer()
    //
    lpNdsBuffer->dwCurrentIndexEntry = 0;

    //
    // Set values used to track the memory used in the index buffer.
    //
    lpNdsBuffer->dwIndexBufferSize = lpNdsBuffer->dwNumberOfReplyEntries *
                                     sizeof(NDS_NAME_ONLY);
    lpNdsBuffer->dwIndexAvailableBytes = lpNdsBuffer->dwIndexBufferSize;
    lpNdsBuffer->dwNumberOfIndexEntries = 0;
    lpNdsBuffer->dwLengthOfIndexData = 0;

    //
    // Create a buffer to hold the ReplyBufferIndex
    //
    lpReplyIndex = (LPNDS_NAME_ONLY)
        LocalAlloc( LPTR, lpNdsBuffer->dwIndexBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpReplyIndex == NULL )
    {
#if DBG
        KdPrint(( "NDS32: IndexReadNameReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->lpIndexBuffer = (LPBYTE) lpReplyIndex;

    //
    // Move lpByte so that it points to the first name
    //
    lpByte = lpNdsBuffer->lpReplyBuffer;

    // lpByte += sizeof(DWORD);  // Move past Completion Code
    // lpByte += sizeof(DWORD);  // Move past Iteration Handle
    // lpByte += sizeof(DWORD);  // Move past Information Type
    // lpByte += sizeof(DWORD);  // Move past Amount Of Attributes
    lpByte += 4 * sizeof(DWORD); // Equivalent to above

    //
    // In a for loop, walk the reply buffer index and fill it up with
    // data by referencing the Reply buffer or Syntax buffer.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfReplyEntries; iter++ )
    {
        dwStringLen = *((LPDWORD) lpByte);
        lpByte += sizeof(DWORD); // Move past Attribute Name Length

        lpReplyIndex[iter].szName = (LPWSTR) lpByte;
        lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );

        lpNdsBuffer->dwNumberOfIndexEntries++;
        lpNdsBuffer->dwLengthOfIndexData += sizeof( NDS_NAME_ONLY );
        lpNdsBuffer->dwIndexAvailableBytes -= sizeof( NDS_NAME_ONLY );
    }

#if DBG
    if ( lpNdsBuffer->dwLengthOfIndexData != lpNdsBuffer->dwIndexBufferSize )
    {
        KdPrint(( "ASSERT in NDS32: IndexReadNameReplyBuffer\n" ));
        KdPrint(( "       lpNdsBuffer->dwLengthOfIndexData !=\n" ));
        KdPrint(( "       lpNdsBuffer->dwIndexBufferSize\n" ));
        ASSERT( FALSE );
    }
#endif

    return NO_ERROR;
}


DWORD
IndexSearchObjectReplyBuffer(
    LPNDS_BUFFER lpNdsBuffer )
{
    LPNDS_OBJECT_INFO lpReplyIndex = NULL;
    DWORD             iter;
    DWORD             iter2;
    LPBYTE            lpByte = NULL;
    DWORD             LengthOfValueStructs;
    DWORD             dwStringLen;
    LPBYTE            FixedPortion;
    LPWSTR            EndOfVariableData;

    //
    // Make sure this is set to zero, for NwNdsGetNextXXXXFromBuffer()
    //
    lpNdsBuffer->dwCurrentIndexEntry = 0;

    //
    // Set values used to track the memory used in the index buffer.
    //
    lpNdsBuffer->dwIndexBufferSize = lpNdsBuffer->dwNumberOfReplyEntries *
                                     ( sizeof(NDS_OBJECT_INFO) +
                                       ( MAX_NDS_NAME_CHARS * 4 *
                                         sizeof( WCHAR ) ) );
    lpNdsBuffer->dwIndexAvailableBytes = lpNdsBuffer->dwIndexBufferSize;
    lpNdsBuffer->dwNumberOfIndexEntries = 0;
    lpNdsBuffer->dwLengthOfIndexData = 0;

    //
    // Create a buffer to hold the ReplyBufferIndex
    //
    lpReplyIndex = (LPNDS_OBJECT_INFO)
        LocalAlloc( LPTR, lpNdsBuffer->dwIndexBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpReplyIndex == NULL )
    {
#if DBG
        KdPrint(( "NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->lpIndexBuffer = (LPBYTE) lpReplyIndex;

    FixedPortion = lpNdsBuffer->lpIndexBuffer;
    EndOfVariableData = (LPWSTR) ((DWORD_PTR) FixedPortion +
                          ROUND_DOWN_COUNT(
                                  lpNdsBuffer->dwIndexAvailableBytes,
                                  ALIGN_DWORD ) );

    //
    // Move lpByte so that it points to the first object
    //
    lpByte = lpNdsBuffer->lpReplyBuffer;

    // lpByte += sizeof(DWORD);  // Move past Completion Code
    // lpByte += sizeof(DWORD);  // Move past Iteration Handle
    // lpByte += sizeof(DWORD);  // Move past Information Type
    // lpByte += sizeof(DWORD);  // Move past Amount Of Attributes
    // lpByte += sizeof(DWORD);  // Move past Length Of Search
    // lpByte += sizeof(DWORD);  // Move past Amount Of Entries
    lpByte += 6 * sizeof(DWORD); // Equivalent to above

    //
    // In a for loop, walk the reply buffer index and fill it up with
    // data by referencing the Reply buffer or Syntax buffer.
    //
    for ( iter = 0; iter < lpNdsBuffer->dwNumberOfReplyEntries; iter++ )
    {
        WORD            tempStrLen;
        LPWSTR          newPathStr = NULL;
        LPWSTR          tempStr = NULL;
        LPWSTR          ClassName;
        LPWSTR          DistinguishedObjectName;
        LPWSTR          ObjectName;
        DWORD           ClassNameLen;
        DWORD           DistinguishedObjectNameLen;
        DWORD           Flags;
        DWORD           SubordinateCount;
        DWORD           ModificationTime;
        DWORD           NumberOfAttributes = 0;
        LPNDS_ATTR_INFO lpAttributeInfos = NULL;
        DWORD           EntryInfo1;

        //
        // Get current subtree data from lpNdsParentObject
        //
        lpByte = GetSearchResultData( lpByte,
                                      &Flags,
                                      &SubordinateCount,
                                      &ModificationTime,
                                      &ClassNameLen,
                                      &ClassName,
                                      &DistinguishedObjectNameLen,
                                      &DistinguishedObjectName,
                                      &EntryInfo1,
                                      &NumberOfAttributes );

        //
        // Need to build a string with the new NDS UNC path
        // for search object
        //
        newPathStr = (PVOID) LocalAlloc( LPTR,
                                         ( wcslen( DistinguishedObjectName ) +
                                           wcslen( lpNdsBuffer->szPath ) +
                                           3 ) * sizeof( WCHAR ) );

        if ( newPathStr == NULL )
        {
#if DBG
            KdPrint(("NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }

        //
        // Need to build a string for the relative object name.
        //
        ObjectName = (PVOID) LocalAlloc( LPTR,
                                         ( wcslen( DistinguishedObjectName ) +
                                           1 ) * sizeof( WCHAR ) );

        if ( ObjectName == NULL )
        {
#if DBG
            KdPrint(("NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }

        tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                      lpNdsBuffer->szPath,
                                      PARSE_NDS_GET_TREE_NAME );

        tempStrLen /= sizeof(WCHAR);

        if ( tempStrLen > 0 )
        {
            wcscpy( newPathStr, L"\\\\" );
            wcsncat( newPathStr, tempStr, tempStrLen );
            wcscat( newPathStr, L"\\" );
            wcscat( newPathStr, DistinguishedObjectName );
            _wcsupr( newPathStr );
        }
        else
        {
            wcscpy( newPathStr, L"" );
        }

        tempStrLen = ParseNdsUncPath( (LPWSTR *) &tempStr,
                                      newPathStr,
                                      PARSE_NDS_GET_OBJECT_NAME );

        tempStrLen /= sizeof(WCHAR);

        if ( tempStrLen > 0 )
        {
            wcsncpy( ObjectName, tempStr, tempStrLen );
        }
        else
        {
            wcscpy( ObjectName, L"" );
        }

        if ( lpNdsBuffer->dwReplyInformationType == NDS_INFO_ATTR_NAMES_VALUES )
        {
          lpAttributeInfos = (LPNDS_ATTR_INFO) LocalAlloc(
                                                    LPTR,
                                                    NumberOfAttributes *
                                                    sizeof( NDS_ATTR_INFO )
                                                         );

          if ( lpAttributeInfos == NULL )
          {
#if DBG
              KdPrint(("NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

              SetLastError( ERROR_NOT_ENOUGH_MEMORY );
              return (DWORD) UNSUCCESSFUL;
          }

          for ( iter2 = 0; iter2 < NumberOfAttributes; iter2++ )
          {
            lpAttributeInfos[iter2].dwSyntaxId = *((LPDWORD) lpByte);
            lpByte += sizeof(DWORD); // Move past Syntax Id

            dwStringLen = *((LPDWORD) lpByte);
            lpByte += sizeof(DWORD); // Move past Attribute Name Length

            lpAttributeInfos[iter2].szAttributeName = (LPWSTR) lpByte;
            lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );

            lpAttributeInfos[iter2].dwNumberOfValues = *((LPDWORD) lpByte);
            lpByte += sizeof(DWORD); // Move past Count Of Values

            //
            // See if the syntax buffer is large enough to hold the number of
            // SyntaxID structures that will be used to store the value(s)
            // for the current attribute. If the buffer isn't large enough
            // it is reallocated to a bigger size (if possible).
            //
            if ( VerifyBufferSize( lpByte,
                                   lpNdsBuffer->dwSyntaxAvailableBytes,
                                   lpAttributeInfos[iter2].dwSyntaxId,
                                   lpAttributeInfos[iter2].dwNumberOfValues,
                                   &LengthOfValueStructs ) != NO_ERROR )
            {
                if ( AllocateOrIncreaseSyntaxBuffer( lpNdsBuffer ) != NO_ERROR )
                {
#if DBG
                    KdPrint(( "NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                    return (DWORD) UNSUCCESSFUL;
                }
            }

            //
            // Parse the raw data buffer by mapping the network structures to
            // the NDS Syntax structures we define in NdsSntx.h. Then move the
            // pointer used to walk the raw data buffer past the ASN.1 Values.
            //
            lpByte += ParseASN1ValueBlob( lpByte,
                                          lpAttributeInfos[iter2].dwSyntaxId,
                                          lpAttributeInfos[iter2].dwNumberOfValues,
                                          (LPVOID) &lpNdsBuffer->lpSyntaxBuffer[lpNdsBuffer->dwLengthOfSyntaxData] );

            lpAttributeInfos[iter2].lpValue =
                      (LPBYTE) lpNdsBuffer->dwLengthOfSyntaxData;
            lpNdsBuffer->dwSyntaxAvailableBytes -= LengthOfValueStructs;
            lpNdsBuffer->dwLengthOfSyntaxData += LengthOfValueStructs;
          }
        }
        else
        {
          lpAttributeInfos = (LPNDS_ATTR_INFO) LocalAlloc(
                                                    LPTR,
                                                    NumberOfAttributes *
                                                    sizeof( NDS_NAME_ONLY )
                                                         );

          if ( lpAttributeInfos == NULL )
          {
#if DBG
              KdPrint(("NDS32: IndexSearchObjectReplyBuffer LocalAlloc Failed 0x%.8X\n", GetLastError()));
#endif

              SetLastError( ERROR_NOT_ENOUGH_MEMORY );
              return (DWORD) UNSUCCESSFUL;
          }

          for ( iter2 = 0; iter2 < NumberOfAttributes; iter2++ )
          {
            dwStringLen = *((LPDWORD) lpByte);
            lpByte += sizeof(DWORD); // Move past Attribute Name Length

            ((LPNDS_NAME_ONLY) lpAttributeInfos)[iter2].szName =
                                                             (LPWSTR) lpByte;
            lpByte += ROUND_UP_COUNT( dwStringLen, ALIGN_DWORD );
          }
        }

        (void) WriteObjectToBuffer( &FixedPortion,
                                    &EndOfVariableData,
                                    newPathStr,
                                    ObjectName,
                                    ClassName,
                                    0, // Don't have this data to write out!
                                    ModificationTime,
                                    SubordinateCount,
                                    NumberOfAttributes,
                                    lpAttributeInfos );

        if ( newPathStr )
        {
            (void) LocalFree( (HLOCAL) newPathStr );
            newPathStr = NULL;
        }

        if ( ObjectName )
        {
            (void) LocalFree( (HLOCAL) ObjectName );
            ObjectName = NULL;
        }

        lpNdsBuffer->dwNumberOfIndexEntries++;
        lpNdsBuffer->dwLengthOfIndexData += sizeof( NDS_CLASS_DEF );
        lpNdsBuffer->dwIndexAvailableBytes -= sizeof( NDS_CLASS_DEF );
    }


    //
    // If the syntax buffer was used for the index, we need to convert
    // offset values to pointers
    //
    if ( lpNdsBuffer->dwReplyInformationType == NDS_INFO_ATTR_NAMES_VALUES )
    {
        for ( iter = 0; iter < lpNdsBuffer->dwNumberOfIndexEntries; iter++ )
        {
            LPNDS_ATTR_INFO lpNdsAttr = (LPNDS_ATTR_INFO)
                                             lpReplyIndex[iter].lpAttribute;

            for ( iter2 = 0;
                  iter2 < lpReplyIndex[iter].dwNumberOfAttributes;
                  iter2++ )
            {
                lpNdsAttr[iter2].lpValue += (DWORD_PTR) lpNdsBuffer->lpSyntaxBuffer;
            }
        }
    }

#if DBG
    if ( lpNdsBuffer->dwLengthOfIndexData > lpNdsBuffer->dwIndexBufferSize )
    {
        KdPrint(( "ASSERT in NDS32: IndexSearchObjectReplyBuffer\n" ));
        KdPrint(( "       lpNdsBuffer->dwLengthOfIndexData >\n" ));
        KdPrint(( "       lpNdsBuffer->dwIndexBufferSize\n" ));
        ASSERT( FALSE );
    }
#endif

    return NO_ERROR;
}


DWORD
SizeOfASN1Structure(
    LPBYTE * lppRawBuffer,
    DWORD    dwSyntaxId )
{
    DWORD  dwSize = 0;
    DWORD  numFields = 0;
    DWORD  StringLen = 0;
    DWORD  dwBlobLength = 0;
    LPBYTE lpBlobBeginning = NULL;
    LPBYTE lpRawBuffer = *lppRawBuffer;

    switch ( dwSyntaxId )
    {
        case NDS_SYNTAX_ID_1 :
            dwSize = sizeof(ASN1_TYPE_1);
            break;
        case NDS_SYNTAX_ID_2 :
            dwSize = sizeof(ASN1_TYPE_2);
            break;
        case NDS_SYNTAX_ID_3 :
            dwSize = sizeof(ASN1_TYPE_3);
            break;
        case NDS_SYNTAX_ID_4 :
            dwSize = sizeof(ASN1_TYPE_4);
            break;
        case NDS_SYNTAX_ID_5 :
            dwSize = sizeof(ASN1_TYPE_5);
            break;
        case NDS_SYNTAX_ID_6 :
            numFields = *(LPDWORD)(lpRawBuffer + sizeof(DWORD));
            dwSize = sizeof(ASN1_TYPE_6)*numFields;
            break;
        case NDS_SYNTAX_ID_7 :
            dwSize = sizeof(ASN1_TYPE_7);
            break;
        case NDS_SYNTAX_ID_8 :
            dwSize = sizeof(ASN1_TYPE_8);
            break;
        case NDS_SYNTAX_ID_9 :
            dwSize = sizeof(ASN1_TYPE_9);
            break;
        case NDS_SYNTAX_ID_10 :
            dwSize = sizeof(ASN1_TYPE_10);
            break;
        case NDS_SYNTAX_ID_11 :
            dwSize = sizeof(ASN1_TYPE_11);
            break;
        case NDS_SYNTAX_ID_12 :
            dwSize = sizeof(ASN1_TYPE_12);
            break;
        case NDS_SYNTAX_ID_13 :
            dwSize = sizeof(ASN1_TYPE_13);
            break;
        case NDS_SYNTAX_ID_14 :
            dwSize = sizeof(ASN1_TYPE_14);
            break;
        case NDS_SYNTAX_ID_15 :
            dwSize = sizeof(ASN1_TYPE_15);
            break;
        case NDS_SYNTAX_ID_16 :
            lpBlobBeginning = lpRawBuffer;
            dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
            dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
            lpRawBuffer += sizeof(DWORD);

            StringLen = *(LPDWORD)lpRawBuffer;
            lpRawBuffer += sizeof(DWORD);

            //
            // Skip past ServerName
            //
            lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

            //
            // Skip past ReplicaType
            //
            lpRawBuffer += sizeof(DWORD);

            //
            // Skip past ReplicaNumber
            //
            lpRawBuffer += sizeof(DWORD);

            //
            // Store address count and move past it
            //
            numFields = *(LPDWORD)lpRawBuffer;
            lpRawBuffer += sizeof(DWORD);

            dwSize = sizeof(ASN1_TYPE_16) - sizeof(ASN1_TYPE_12) +
                     ( numFields * sizeof(ASN1_TYPE_12) );

            *lppRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);
            break;
        case NDS_SYNTAX_ID_17 :
            dwSize = sizeof(ASN1_TYPE_17);
            break;
        case NDS_SYNTAX_ID_18 :
            dwSize = sizeof(ASN1_TYPE_18);
            break;
        case NDS_SYNTAX_ID_19 :
            dwSize = sizeof(ASN1_TYPE_19);
            break;
        case NDS_SYNTAX_ID_20 :
            dwSize = sizeof(ASN1_TYPE_20);
            break;
        case NDS_SYNTAX_ID_21 :
            dwSize = sizeof(ASN1_TYPE_21);
            break;
        case NDS_SYNTAX_ID_22 :
            dwSize = sizeof(ASN1_TYPE_22);
            break;
        case NDS_SYNTAX_ID_23 :
            dwSize = sizeof(ASN1_TYPE_23);
            break;
        case NDS_SYNTAX_ID_24 :
            dwSize = sizeof(ASN1_TYPE_24);
            break;
        case NDS_SYNTAX_ID_25 :
            dwSize = sizeof(ASN1_TYPE_25);
            break;
        case NDS_SYNTAX_ID_26 :
            dwSize = sizeof(ASN1_TYPE_26);
            break;
        case NDS_SYNTAX_ID_27 :
            dwSize = sizeof(ASN1_TYPE_27);
            break;

        default :
            KdPrint(( "NDS32: SizeOfASN1Structure() unknown SyntaxId 0x%.8X.\n", dwSyntaxId ));
            ASSERT( FALSE );
    }

    return dwSize;
}

DWORD
ParseASN1ValueBlob(
    LPBYTE RawDataBuffer,
    DWORD  dwSyntaxId,
    DWORD  dwNumberOfValues,
    LPBYTE SyntaxStructure )
{
    DWORD   iter;
    DWORD   i;
    DWORD   length = 0;
    LPBYTE  lpRawBuffer = RawDataBuffer;
    LPBYTE  lpSyntaxBuffer = SyntaxStructure;
    DWORD   StringLen;
    DWORD   numFields;
    DWORD   dwBlobLength;
    LPBYTE  lpBlobBeginning;

    for ( iter = 0; iter < dwNumberOfValues; iter++ )
    {
        switch ( dwSyntaxId )
        {
            case NDS_SYNTAX_ID_0 :

                break;

            case NDS_SYNTAX_ID_1 :
            case NDS_SYNTAX_ID_2 :
            case NDS_SYNTAX_ID_3 :
            case NDS_SYNTAX_ID_4 :
            case NDS_SYNTAX_ID_5 :
            case NDS_SYNTAX_ID_10 :
            case NDS_SYNTAX_ID_20 :

                StringLen = *(LPDWORD)lpRawBuffer;
                length += sizeof(DWORD);
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_1) lpSyntaxBuffer)->DNString =
                               StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_1);

                length += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                break;

            case NDS_SYNTAX_ID_6 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                numFields = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                for ( iter = 0; iter < numFields; iter++ )
                {
                    StringLen = *(LPDWORD)lpRawBuffer;
                    lpRawBuffer += sizeof(DWORD);
                    ((LPASN1_TYPE_6) lpSyntaxBuffer)->String =
                                   StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                    lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                    if ( (iter+1) < numFields )
                    {
                        ((LPASN1_TYPE_6) lpSyntaxBuffer)->Next =
                                                   (LPASN1_TYPE_6)
                                                   (lpSyntaxBuffer +
                                                    sizeof(ASN1_TYPE_6) );
                    }
                    else
                    {
                        ((LPASN1_TYPE_6) lpSyntaxBuffer)->Next = NULL;
                    }

                    lpSyntaxBuffer += sizeof(ASN1_TYPE_6);
                }

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_7 :

                StringLen = *(LPDWORD)lpRawBuffer;
                length += sizeof(DWORD);
                lpRawBuffer += sizeof(DWORD);

                ASSERT( StringLen == 1 ); // Booleans are sent as a single
                                          // element DWORD array on the net.
                                          // Although booleans are only the
                                          // first single byte value.

                ((LPASN1_TYPE_7) lpSyntaxBuffer)->Boolean = *(LPDWORD)lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_7);

                length += StringLen*sizeof(DWORD);
                lpRawBuffer += StringLen*sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_8 :
            case NDS_SYNTAX_ID_22 :
            case NDS_SYNTAX_ID_24 :
            case NDS_SYNTAX_ID_27 :

                StringLen = *(LPDWORD)lpRawBuffer;
                length += sizeof(DWORD);
                lpRawBuffer += sizeof(DWORD);

                ASSERT( StringLen == 4 ); // These DWORD values are all sent
                                          // as a 4 element BYTE array on
                                          // the net.

                ((LPASN1_TYPE_8) lpSyntaxBuffer)->Integer =
                                                    *(LPDWORD)lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_8);

                length += StringLen*sizeof(BYTE);
                lpRawBuffer += StringLen*sizeof(BYTE);

                break;

            case NDS_SYNTAX_ID_9 :

                StringLen = *(LPDWORD)lpRawBuffer;
                length += sizeof(DWORD);
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_9) lpSyntaxBuffer)->Length = StringLen;
                ((LPASN1_TYPE_9) lpSyntaxBuffer)->OctetString =
                               StringLen == 0 ? NULL : lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_9);

                length += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                break;

            case NDS_SYNTAX_ID_11 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_11) lpSyntaxBuffer)->TelephoneNumber =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                ((LPASN1_TYPE_11) lpSyntaxBuffer)->NumberOfBits =
                                                    *(LPDWORD)lpRawBuffer;

                if ( ((LPASN1_TYPE_11) lpSyntaxBuffer)->NumberOfBits )
                {
                    lpRawBuffer += sizeof(DWORD);
                    ((LPASN1_TYPE_11) lpSyntaxBuffer)->Parameters = lpRawBuffer;
                }
                else
                {
                    ((LPASN1_TYPE_11) lpSyntaxBuffer)->Parameters = NULL;
                }

                lpSyntaxBuffer += sizeof(ASN1_TYPE_11);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_12 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_12) lpSyntaxBuffer)->AddressType =
                                                    *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                ((LPASN1_TYPE_12) lpSyntaxBuffer)->AddressLength = StringLen;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_12) lpSyntaxBuffer)->Address =
                                StringLen == 0 ? NULL : lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_12);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_13 :
#if DBG
                KdPrint(( "NDS32: ParseASN1ValueBlob() - Don't know how to parse SyntaxId 0x%.8X. Get a sniff and give it to GlennC.\n", dwSyntaxId ));
                ASSERT( FALSE );
#endif
                break;

            case NDS_SYNTAX_ID_14 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_14) lpSyntaxBuffer)->Type =
                                                    *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_14) lpSyntaxBuffer)->Address =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_14);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_15 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_15) lpSyntaxBuffer)->Type =
                                                    *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_15) lpSyntaxBuffer)->VolumeName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_15) lpSyntaxBuffer)->Path =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_15);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_16 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_16) lpSyntaxBuffer)->ServerName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                ((LPASN1_TYPE_16) lpSyntaxBuffer)->ReplicaType =
                                                       *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_16) lpSyntaxBuffer)->ReplicaNumber =
                                                       *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_16) lpSyntaxBuffer)->Count =
                                                       *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                for ( i=0; i < ((LPASN1_TYPE_16) lpSyntaxBuffer)->Count; i++ )
                {
                    ((LPASN1_TYPE_16) lpSyntaxBuffer)->ReplicaAddressHint[i].AddressType = *(LPDWORD)lpRawBuffer;
                    lpRawBuffer += sizeof(DWORD);

                    StringLen = *(LPDWORD)lpRawBuffer;
                    ((LPASN1_TYPE_16) lpSyntaxBuffer)->ReplicaAddressHint[i].AddressLength = StringLen;
                    lpRawBuffer += sizeof(DWORD);

                    ((LPASN1_TYPE_16) lpSyntaxBuffer)->ReplicaAddressHint[i].Address = StringLen == 0 ? NULL : lpRawBuffer;
                    lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );
                }

                lpSyntaxBuffer += sizeof(ASN1_TYPE_16) -
                                  sizeof(ASN1_TYPE_12) +
                                  ( ((LPASN1_TYPE_16) lpSyntaxBuffer)->Count*
                                    sizeof(ASN1_TYPE_12) );

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_17 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);
                ((LPASN1_TYPE_17) lpSyntaxBuffer)->ProtectedAttrName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);
                ((LPASN1_TYPE_17) lpSyntaxBuffer)->SubjectName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                ((LPASN1_TYPE_17) lpSyntaxBuffer)->Privileges =
                                                       *(LPDWORD)lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_17);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_18 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                numFields = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                for ( i = 0; i < numFields; i++ )
                {
                    StringLen = *(LPDWORD)lpRawBuffer;
                    lpRawBuffer += sizeof(DWORD);
                    ((LPASN1_TYPE_18) lpSyntaxBuffer)->PostalAddress[i] =
                                   StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                    lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );
                }

                lpSyntaxBuffer += sizeof(ASN1_TYPE_18);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_19 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_19) lpSyntaxBuffer)->WholeSeconds =
                                *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_19) lpSyntaxBuffer)->EventID =
                                *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                lpSyntaxBuffer += sizeof(ASN1_TYPE_19);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_21 :

                ((LPASN1_TYPE_21) lpSyntaxBuffer)->Length =
                               *(LPDWORD)lpRawBuffer;
                lpSyntaxBuffer += sizeof(ASN1_TYPE_21);

                length += sizeof(DWORD);
                lpRawBuffer += sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_23 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_23) lpSyntaxBuffer)->RemoteID =
                                *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);
                ((LPASN1_TYPE_23) lpSyntaxBuffer)->ObjectName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                lpSyntaxBuffer += sizeof(ASN1_TYPE_23);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_25 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_25) lpSyntaxBuffer)->Level =
                                                    *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                ((LPASN1_TYPE_25) lpSyntaxBuffer)->Interval =
                                                    *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);
                ((LPASN1_TYPE_25) lpSyntaxBuffer)->ObjectName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                lpSyntaxBuffer += sizeof(ASN1_TYPE_25);
                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            case NDS_SYNTAX_ID_26 :

                lpBlobBeginning = lpRawBuffer;
                dwBlobLength = *(LPDWORD)lpRawBuffer*sizeof(BYTE);
                dwBlobLength = ROUND_UP_COUNT( dwBlobLength, ALIGN_DWORD );
                lpRawBuffer += sizeof(DWORD);

                StringLen = *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);
                ((LPASN1_TYPE_26) lpSyntaxBuffer)->ObjectName =
                                StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
                lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

                ((LPASN1_TYPE_26) lpSyntaxBuffer)->Amount =
                                *(LPDWORD)lpRawBuffer;
                lpRawBuffer += sizeof(DWORD);

                lpSyntaxBuffer += sizeof(ASN1_TYPE_26);

                length += dwBlobLength + sizeof(DWORD);
                lpRawBuffer = lpBlobBeginning + dwBlobLength + sizeof(DWORD);

                break;

            default :
#if DBG
                KdPrint(( "NDS32: ParseASN1ValueBlob() unknown SyntaxId 0x%.8X.\n", dwSyntaxId ));
                ASSERT( FALSE );
#endif

                return 0;
        }
    }

    return length;
}


DWORD
ParseStringListBlob(
    LPBYTE RawDataBuffer,
    DWORD  dwNumberOfStrings,
    LPBYTE SyntaxStructure )
{
    DWORD   iter;
    DWORD   length = 0;
    LPBYTE  lpRawBuffer = RawDataBuffer;
    LPBYTE  lpSyntaxBuffer = SyntaxStructure;
    DWORD   StringLen;

    for ( iter = 0; iter < dwNumberOfStrings; iter++ )
    {
        StringLen = *(LPDWORD)lpRawBuffer;
        lpRawBuffer += sizeof(DWORD);
        length += sizeof(DWORD);
        ((LPASN1_TYPE_6) lpSyntaxBuffer)->String =
                                 StringLen == 0 ? NULL : (LPWSTR) lpRawBuffer;
        lpRawBuffer += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );
        length += ROUND_UP_COUNT( StringLen, ALIGN_DWORD );

        if ( (iter+1) < dwNumberOfStrings )
        {
            ((LPASN1_TYPE_6) lpSyntaxBuffer)->Next = (LPASN1_TYPE_6)
                                                      (lpSyntaxBuffer +
                                                      sizeof(ASN1_TYPE_6) );
        }
        else
        {
            ((LPASN1_TYPE_6) lpSyntaxBuffer)->Next = NULL;
        }

        lpSyntaxBuffer += sizeof(ASN1_TYPE_6);
    }

    return length;
}


WORD
ParseNdsUncPath(
    IN OUT LPWSTR * lpszResult,
    IN     LPWSTR   szObjectPathName,
    IN     DWORD    flag )
{
    unsigned short length = 2;
    unsigned short totalLength = (USHORT) wcslen( szObjectPathName );

    if ( totalLength < 2 )
        return 0;

    //
    // Get length to indicate the character in the string that indicates the
    // "\" in between the tree name and the rest of the UNC path.
    //
    // Example:  \\<tree name>\<path to object>[\|.]<object>
    //                        ^
    //                        |
    //
    while ( length < totalLength && szObjectPathName[length] != L'\\' )
    {
        length++;
    }

    if ( flag == PARSE_NDS_GET_TREE_NAME )
    {
        *lpszResult = (LPWSTR) ( szObjectPathName + 2 );

        return ( length - 2 ) * sizeof(WCHAR); // Take off 2 for the two \\'s
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME && length == totalLength )
    {
        *lpszResult = szObjectPathName;

        return 0;
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME )
    {
        *lpszResult = szObjectPathName + length + 1;

        return ( totalLength - length - 1 ) * sizeof(WCHAR);
    }

    if ( flag == PARSE_NDS_GET_OBJECT_NAME )
    {
        unsigned short ObjectNameLength = 0;

        *lpszResult = szObjectPathName + length + 1;

        length++;

        while ( length < totalLength && szObjectPathName[length] != L'.' )
        {
            length++;
            ObjectNameLength++;
        }

        return ObjectNameLength * sizeof(WCHAR);
    }

    *lpszResult = szObjectPathName + totalLength - 1;
    length = 1;

    while ( *lpszResult[0] != L'\\' )
    {
        *lpszResult--;
        length++;
    }

    *lpszResult++;
    length--;

    return length * sizeof(WCHAR);
}


DWORD
ReadAttrDef_AllAttrs(
    IN  HANDLE   hTree,
    IN  DWORD    dwInformationType,
    OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = NULL;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;
    DWORD        dwInfoType = dwInformationType;

    *lphOperationData = NULL;

    status = NwNdsCreateBuffer( NDS_SCHEMA_READ_ATTR_DEF,
                                (HANDLE *) &lpNdsBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    lpNdsBuffer->lpReplyBuffer = NULL;
    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // Reasonable guess is that the response buffer needs to be 8K bytes.
    //
    dwCurrBuffSize = EIGHT_KB;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_AllAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
SendRequest:
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_ATTR_DEF,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDD",
                                   0,             // Version
                                   dwIterHandle, // Initial iteration
                                   dwInformationType,
                                   (DWORD) TRUE,  // All attributes indicator
                                   0 );           // Number of attribute names


        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
            if (nwstatus == NDS_ERR_INSUFFICIENT_BUFFER)
            {
#if DBG
                KdPrint(( "NDS32: ReadAttrDef_AllAttrs - NDS_ERR_INSUFFICIENT_BUFFER - doubling size from %ld\n", dwCurrBuffSize ));
#endif
                //
                // The buffer was too small, make it twice as big.
                //
                if ( dwCurrBuffSize <=  THIRY_TWO_KB)
                {   // NDS_MAX_BUFFER = 0xFC00
                    dwCurrBuffSize *= 2;
                    if (dwCurrBuffSize > NDS_MAX_BUFFER)
                        dwCurrBuffSize = NDS_MAX_BUFFER;
                    lpTempBuff = (PVOID) LocalAlloc(LPTR, dwCurrBuffSize);
                    if (lpTempBuff)
                    {
                        (void) LocalFree((HLOCAL) lpCurrBuff);
                        lpCurrBuff = lpTempBuff;
                        lpTempBuff = NULL;
                        // Error cancels iteration, so reset any previously read responses and start over
                        dwIterHandle = NDS_NO_MORE_ITERATIONS;
                        if (lpNdsBuffer->lpReplyBuffer)
                        {
                            (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
                            lpNdsBuffer->lpReplyBuffer = NULL;
                            lpNdsBuffer->dwReplyBufferSize = 0;
                            dwNumEntries = 0;
                        }
                        goto SendRequest;
                    }
#if DBG
                    else {
                        KdPrint(( "NDS32: ReadAttrDef_AllAttrs - Buffer ReAlloc failed to increase to %ld\n", dwCurrBuffSize ));
                    }
#endif
                }
            }

#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_AllAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (dwCurrBuffSize - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    *lphOperationData = lpNdsBuffer;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
        lpNdsBuffer = NULL;
    }

    return status;
}


DWORD
ReadAttrDef_SomeAttrs(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType,
    IN OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) *lphOperationData;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwInfoType = dwInformationType;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;

    if ( lpNdsBuffer->dwOperation != NDS_SCHEMA_READ_ATTR_DEF )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if this buffer has already been used for a read reply.
    //
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }
    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // Reasonable guess is that the response buffer needs to be 8K bytes.
    //
    dwCurrBuffSize = EIGHT_KB;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
SendRequest:
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_ATTR_DEF,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDDr",
                                   0,             // Version
                                   dwIterHandle, // Initial iteration
                                   dwInformationType,
                                   (DWORD) FALSE, // All attributes indicator
                                   lpNdsBuffer->dwNumberOfRequestEntries,
                                   lpNdsBuffer->lpRequestBuffer,
                                   (WORD)lpNdsBuffer->dwLengthOfRequestData );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
            if (nwstatus == NDS_ERR_INSUFFICIENT_BUFFER)
            {
#if DBG
                KdPrint(( "NDS32: ReadAttrDef_SomeAttrs - NDS_ERR_INSUFFICIENT_BUFFER - doubling size from %ld\n", dwCurrBuffSize ));
#endif
                //
                // The buffer was too small, make it twice as big.
                //
                if ( dwCurrBuffSize <=  THIRY_TWO_KB)
                {   // NDS_MAX_BUFFER = 0xFC00
                    dwCurrBuffSize *= 2;
                    if (dwCurrBuffSize > NDS_MAX_BUFFER)
                        dwCurrBuffSize = NDS_MAX_BUFFER;
                    lpTempBuff = (PVOID) LocalAlloc(LPTR, dwCurrBuffSize);
                    if (lpTempBuff)
                    {
                        (void) LocalFree((HLOCAL) lpCurrBuff);
                        lpCurrBuff = lpTempBuff;
                        lpTempBuff = NULL;
                        // Error cancels iteration, so reset any previously read responses and start over
                        dwIterHandle = NDS_NO_MORE_ITERATIONS;
                        if (lpNdsBuffer->lpReplyBuffer)
                        {
                            (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
                            lpNdsBuffer->lpReplyBuffer = NULL;
                            lpNdsBuffer->dwReplyBufferSize = 0;
                            dwNumEntries = 0;
                        }
                        goto SendRequest;
                    }
#if DBG
                    else {
                        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs - Buffer ReAlloc failed to increase to %ld\n", dwCurrBuffSize ));
                    }
#endif
                }
            }
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif
            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadAttrDef_SomeAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (dwCurrBuffSize - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
        lpNdsBuffer->dwReplyBufferSize = 0;
    }

    return status;
}


DWORD
ReadClassDef_AllClasses(
    IN  HANDLE   hTree,
    IN  DWORD    dwInformationType,
    OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = NULL;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;
    DWORD        dwInfoType = dwInformationType;

    *lphOperationData = NULL;

    status = NwNdsCreateBuffer( NDS_SCHEMA_READ_CLASS_DEF,
                                (HANDLE *) &lpNdsBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    lpNdsBuffer->lpReplyBuffer = NULL;
    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // Reasonable guess is that the response buffer needs to be 16K bytes.
    //
    dwCurrBuffSize = SIXTEEN_KB;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadClassDef_AllClasses LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
SendRequest:
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_CLASS_DEF,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDD",
                                   0,             // Version
                                   dwIterHandle, // Initial iteration
                                   dwInformationType,
                                   (DWORD) TRUE,  // All attributes indicator
                                   0 );           // Number of attribute names


        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses: The read response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
            if (nwstatus == NDS_ERR_INSUFFICIENT_BUFFER)
            {
#if DBG
                KdPrint(( "NDS32: ReadClassDef_AllClasses - NDS_ERR_INSUFFICIENT_BUFFER - doubling size from %ld\n", dwCurrBuffSize ));
#endif
                //
                // The buffer was too small, make it twice as big.
                //
                if ( dwCurrBuffSize <=  THIRY_TWO_KB)
                {   // NDS_MAX_BUFFER = 0xFC00
                    dwCurrBuffSize *= 2;
                    if (dwCurrBuffSize > NDS_MAX_BUFFER)
                        dwCurrBuffSize = NDS_MAX_BUFFER;
                    lpTempBuff = (PVOID) LocalAlloc(LPTR, dwCurrBuffSize);
                    if (lpTempBuff)
                    {
                        (void) LocalFree((HLOCAL) lpCurrBuff);
                        lpCurrBuff = lpTempBuff;
                        lpTempBuff = NULL;
                        // Error cancels iteration, so reset any previously read responses and start over
                        dwIterHandle = NDS_NO_MORE_ITERATIONS;
                        if (lpNdsBuffer->lpReplyBuffer)
                        {
                            (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
                            lpNdsBuffer->lpReplyBuffer = NULL;
                            lpNdsBuffer->dwReplyBufferSize = 0;
                            dwNumEntries = 0;
                        }
                        goto SendRequest;
                    }
#if DBG
                    else {
                        KdPrint(( "NDS32: ReadClassDef_AllClasses - Buffer ReAlloc failed to increase to %ld\n", dwCurrBuffSize ));
                    }
#endif
                }
            }

#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_AllClasses LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (dwCurrBuffSize - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    *lphOperationData = lpNdsBuffer;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
        lpNdsBuffer = NULL;
    }

    return status;
}


DWORD
ReadClassDef_SomeClasses(
    IN     HANDLE   hTree,
    IN     DWORD    dwInformationType,
    IN OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) *lphOperationData;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwInfoType = dwInformationType;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;

    if ( lpNdsBuffer->dwOperation != NDS_SCHEMA_READ_CLASS_DEF )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if this buffer has already been used for a read reply.
    //
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }
    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // Reasonable guess is that the response buffer needs to be 16K bytes.
    //
    dwCurrBuffSize = SIXTEEN_KB;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadClassDef_SomeClasses LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
SendRequest:
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_CLASS_DEF,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDDr",
                                   0,             // Version
                                   dwIterHandle, // Initial iteration
                                   dwInformationType,
                                   (DWORD) FALSE, // All attributes indicator
                                   lpNdsBuffer->dwNumberOfRequestEntries,
                                   lpNdsBuffer->lpRequestBuffer,
                                   (WORD)lpNdsBuffer->dwLengthOfRequestData );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
            if (nwstatus == NDS_ERR_INSUFFICIENT_BUFFER)
            {
#if DBG
                KdPrint(( "NDS32: ReadClassDef_SomeClasses - NDS_ERR_INSUFFICIENT_BUFFER - doubling size from %ld\n", dwCurrBuffSize ));
#endif
                //
                // The buffer was too small, make it twice as big.
                //
                if ( dwCurrBuffSize <=  THIRY_TWO_KB)
                {   // NDS_MAX_BUFFER = 0xFC00
                    dwCurrBuffSize *= 2;
                    if (dwCurrBuffSize > NDS_MAX_BUFFER)
                        dwCurrBuffSize = NDS_MAX_BUFFER;
                    lpTempBuff = (PVOID) LocalAlloc(LPTR, dwCurrBuffSize);
                    if (lpTempBuff)
                    {
                        (void) LocalFree((HLOCAL) lpCurrBuff);
                        lpCurrBuff = lpTempBuff;
                        lpTempBuff = NULL;
                        // Error cancels iteration, so reset any previously read responses and start over
                        dwIterHandle = NDS_NO_MORE_ITERATIONS;
                        if (lpNdsBuffer->lpReplyBuffer)
                        {
                            (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
                            lpNdsBuffer->lpReplyBuffer = NULL;
                            lpNdsBuffer->dwReplyBufferSize = 0;
                            dwNumEntries = 0;
                        }
                        goto SendRequest;
                    }
#if DBG
                    else {
                        KdPrint(( "NDS32: ReadClassDef_SomeClasses - Buffer ReAlloc failed to increase to %ld\n", dwCurrBuffSize ));
                    }
#endif
                }
            }

#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (dwCurrBuffSize - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
        lpNdsBuffer->dwReplyBufferSize = 0;
    }

    return status;
}


DWORD
ReadObject_AllAttrs(
    IN  HANDLE   hObject,
    IN  DWORD    dwInformationType,
    OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = NULL;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;
    DWORD        dwInfoType = dwInformationType;

    if ( lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    status = NwNdsCreateBuffer( NDS_OBJECT_READ,
                                (HANDLE *) &lpNdsBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    lpNdsBuffer->lpReplyBuffer = NULL;
    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // We're asking for all attribute values, so let's start with max buffer to avoid iterations.
    //
    dwCurrBuffSize = NDS_MAX_BUFFER;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadObject_AllAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_OBJECT,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDDD",
                                   0,            // Version
                                   dwIterHandle, // Initial iteration
                                   lpNdsObject->ObjectId, // Id of the object
                                   dwInformationType,
                                   (DWORD) TRUE, // All attributes indicator
                                   0 );          // Number of attribute names

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_AllAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (dwCurrBuffSize - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    *lphOperationData = lpNdsBuffer;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
        lpNdsBuffer = NULL;
    }

    return status;
}


DWORD
ReadObject_SomeAttrs(
    IN     HANDLE   hObject,
    IN     DWORD    dwInformationType,
    IN OUT HANDLE * lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) *lphOperationData;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hObject;
    DWORD        dwIterHandle = NDS_NO_MORE_ITERATIONS;
    DWORD        dwInfoType = dwInformationType;
    DWORD        dwNumEntries = 0;
    DWORD        dwCurrNumEntries = 0;
    DWORD        dwCurrBuffSize = 0;
    DWORD        dwCopyOffset = 0;
    PVOID        lpCurrBuff = NULL;
    PVOID        lpTempBuff = NULL;

    if ( lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( lpNdsBuffer->dwOperation != NDS_OBJECT_READ )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Check to see if this buffer has already been used for a read reply.
    //
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->dwReplyBufferSize = 0;

    //
    // We may be asking for all values, so let's start with max buffer to avoid iterations.
    //
    dwCurrBuffSize = NDS_MAX_BUFFER;

    lpCurrBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpCurrBuff == NULL )
    {
#if DBG
        KdPrint(( "NDS32: ReadObject_SomeAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    do
    {
        ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                                   NETWARE_NDS_FUNCTION_READ_OBJECT,
                                   lpCurrBuff,
                                   dwCurrBuffSize,
                                   &dwReplyLength,
                                   "DDDDDDr",
                                   0,               // Version
                                   dwIterHandle, // Initial iteration
                                   lpNdsObject->ObjectId, // Id of the object
                                   dwInformationType,
                                   (DWORD) FALSE,   // All attributes indicator
                                   lpNdsBuffer->dwNumberOfRequestEntries,
                                   lpNdsBuffer->lpRequestBuffer, // Object info
                                   (WORD)lpNdsBuffer->dwLengthOfRequestData );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_SomeAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "GD",
                                  &nwstatus );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( nwstatus )
        {
#if DBG
            KdPrint(( "NDS32: ReadClassDef_SomeClasses - NetWare error 0x%.8X.\n", nwstatus ));
#endif
            SetLastError( MapNetwareErrorCode( nwstatus ) );
            status = nwstatus;
            goto ErrorExit;
        }

        ntstatus = ParseResponse( (BYTE *) lpCurrBuff,
                                  dwReplyLength,
                                  "G_DDD",
                                  sizeof(DWORD),
                                  &dwIterHandle,
                                  &dwInfoType,
                                  &dwCurrNumEntries );

        if ( !NT_SUCCESS( ntstatus ) )
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

            SetLastError( RtlNtStatusToDosError( ntstatus ) );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }

        if ( lpNdsBuffer->lpReplyBuffer == NULL) // first time through
        {
            dwCopyOffset = 0; // we want the entire buffer the first time
            lpTempBuff = (PVOID) LocalAlloc( LPTR, dwCurrBuffSize ); // Allocate new reply buffer
        }
        else
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_SomeAttrs - subsequent iteration, ReplyBuffer now %ld\n", lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset ));
#endif
            dwCopyOffset = 4 * sizeof(DWORD); // skip the response code, iteration handle, etc. on subsequent iterations
            lpTempBuff = (PVOID) LocalAlloc (LPTR, lpNdsBuffer->dwReplyBufferSize + dwCurrBuffSize - dwCopyOffset);
            // grow reply buffer to hold additional data
            if (lpTempBuff)
            {
                RtlCopyMemory( lpTempBuff, lpNdsBuffer->lpReplyBuffer, lpNdsBuffer->dwReplyBufferSize);
                (void) LocalFree((HLOCAL) lpNdsBuffer->lpReplyBuffer);
            }
        }
        if (lpTempBuff == NULL)
        {
#if DBG
            KdPrint(( "NDS32: ReadObject_SomeAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            status = (DWORD) UNSUCCESSFUL;
            goto ErrorExit;
        }
        RtlCopyMemory( (LPBYTE) ((LPBYTE) (lpTempBuff) + lpNdsBuffer->dwReplyBufferSize),
                       (LPBYTE) ((LPBYTE) (lpCurrBuff) + dwCopyOffset),
                       (dwCurrBuffSize - dwCopyOffset) );
        lpNdsBuffer->lpReplyBuffer = lpTempBuff;
        lpNdsBuffer->dwReplyBufferSize += (dwCurrBuffSize - dwCopyOffset);
        dwNumEntries += dwCurrNumEntries;
        RtlZeroMemory(lpCurrBuff, dwCurrBuffSize);
    } while ( dwIterHandle != NDS_NO_MORE_ITERATIONS );

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    (void) LocalFree( (HLOCAL) lpCurrBuff );

    return NO_ERROR;

ErrorExit :

    if ( lpCurrBuff )
    {
        (void) LocalFree( (HLOCAL) lpCurrBuff );
        lpCurrBuff = NULL;
    }
    if ( lpNdsBuffer->lpReplyBuffer )
    {
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
        lpNdsBuffer->dwReplyBufferSize = 0;
    }

    return status;
}


DWORD
Search_AllAttrs(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType,
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    IN OUT HANDLE *     lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = NULL;
    LPNDS_BUFFER lpNdsQueryTreeBuffer = NULL;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hStartFromObject;
    DWORD        dwIterHandle;
    DWORD        dwNumEntries;
    DWORD        dwAmountOfNodesSearched;
    DWORD        dwLengthOfSearch;
    DWORD        iter;

    //
    // Search NCP parameters
    //
    DWORD        dwFlags = fDerefAliases ?
                           NDS_DEREF_ALIASES :
                           NDS_DONT_DEREF_ALIASES;
    DWORD        dwNumNodes = 0;
    DWORD        dwNumAttributes = 0;
    DWORD        dwInfoType = dwInformationType;

    LPBYTE       FixedPortion;
    LPWSTR       EndOfVariableData;
    BOOL         FitInBuffer = TRUE;

    if ( *lphOperationData == NULL )
    {
        //
        // This is the first time that NwNdsSearch has been called,
        // need to create a hOperationData buffer . . .
        //
        status = NwNdsCreateBuffer( NDS_SEARCH,
                                    (HANDLE *) &lpNdsBuffer );

        if ( status )
        {
            goto ErrorExit;
        }

        //
        // Not specifying any particular attributes in the search request.
        //
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpRequestBuffer );
        lpNdsBuffer->lpRequestBuffer = NULL;
        lpNdsBuffer->dwRequestBufferSize = 0;
        lpNdsBuffer->dwRequestAvailableBytes = 0;
        lpNdsBuffer->dwNumberOfRequestEntries = 0;
        lpNdsBuffer->dwLengthOfRequestData = 0;

        //
        // Reasonable guess is that the response buffer needs to be 16K bytes.
        //
        lpNdsBuffer->dwReplyBufferSize = SIXTEEN_KB;
    }
    else if ( ((LPNDS_BUFFER) *lphOperationData)->dwBufferId == NDS_SIGNATURE &&
              ((LPNDS_BUFFER) *lphOperationData)->dwOperation == NDS_SEARCH &&
              ((LPNDS_BUFFER) *lphOperationData)->lpReplyBuffer )
    {
        //
        // This seems to be a sub-sequent call to NwNdsSearch with a resume
        // handle, need to clean up the hOperationData buffer from the last
        // time this was called.
        //
        lpNdsBuffer = (LPNDS_BUFFER) *lphOperationData;

        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
        lpNdsBuffer->dwReplyAvailableBytes = 0;
        lpNdsBuffer->dwNumberOfReplyEntries = 0;
        lpNdsBuffer->dwLengthOfReplyData = 0;

        if ( lpNdsBuffer->lpIndexBuffer )
        {
            (void) LocalFree( (HLOCAL) lpNdsBuffer->lpIndexBuffer );
            lpNdsBuffer->lpIndexBuffer = NULL;
            lpNdsBuffer->dwIndexAvailableBytes = 0;
            lpNdsBuffer->dwNumberOfIndexEntries = 0;
            lpNdsBuffer->dwLengthOfIndexData = 0;
        }

        //
        // Since the last call to NwNdsSearch needed a bigger buffer for all
        // of the response data, let's continue this time with a bigger reply
        // buffer. We grow the buffer up to a point, 128K bytes.
        //
        if ( lpNdsBuffer->dwReplyBufferSize < SIXTY_FOUR_KB )
        {
            lpNdsBuffer->dwReplyBufferSize *= 2;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    status = NwNdsCreateBuffer( NDS_SEARCH,
                                (HANDLE *) &lpNdsQueryTreeBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    //
    // Prepare request buffer stream with search query.
    //
    status = WriteQueryTreeToBuffer( lpQueryTree, lpNdsQueryTreeBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    lpNdsBuffer->lpReplyBuffer =
        (PVOID) LocalAlloc( LPTR, lpNdsBuffer->dwReplyBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpNdsBuffer->lpReplyBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: Search_AllAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

/*
    //
    // This is the format of a version 3 search request ...
    //
    ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                               NETWARE_NDS_FUNCTION_SEARCH,
                               lpNdsBuffer->lpReplyBuffer,
                               lpNdsBuffer->dwReplyBufferSize,
                               &dwReplyLength,
                               "DDDDDDDDDDr",
                               0x00000003, // Version
                               dwFlags,
                               *lpdwIterHandle,
                               lpNdsObject->ObjectId, // Id of object to
                                                      // start search from.
                               dwScope,
                               dwNumNodes,
                               dwInfoType,
                               0x0000281D, // Flags??
                               0x741E0000, // ??
                               (DWORD) TRUE, // All attributes?
                               lpNdsQueryTreeBuffer->lpRequestBuffer,
                               (WORD)lpNdsQueryTreeBuffer->dwLengthOfRequestData );
*/

    ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                               NETWARE_NDS_FUNCTION_SEARCH,
                               lpNdsBuffer->lpReplyBuffer,
                               lpNdsBuffer->dwReplyBufferSize,
                               &dwReplyLength,
                               "DDDDDDDDDr",
                               0x00000002, // Version
                               dwFlags,
                               *lpdwIterHandle,
                               lpNdsObject->ObjectId, // Id of object to
                                                      // start search from.
                               dwScope,
                               dwNumNodes,
                               dwInfoType,
                               (DWORD) TRUE, // All attributes?
                               dwNumAttributes,
                               lpNdsQueryTreeBuffer->lpRequestBuffer,
                               (WORD)lpNdsQueryTreeBuffer->dwLengthOfRequestData );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    ntstatus = ParseResponse( lpNdsBuffer->lpReplyBuffer,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        status = nwstatus;
        goto ErrorExit;
    }

    ntstatus = ParseResponse( (BYTE *) lpNdsBuffer->lpReplyBuffer,
                              dwReplyLength,
                              "G_DDDDD",
                              sizeof(DWORD),
                              &dwIterHandle,
                              &dwAmountOfNodesSearched,
                              &dwInfoType,
                              &dwLengthOfSearch,
                              &dwNumEntries );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    //
    // Finished the search call, free up lpNDsQueryTreeBuffer
    //
    (void) NwNdsFreeBuffer( (HANDLE) lpNdsQueryTreeBuffer );
    lpNdsQueryTreeBuffer = NULL;

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    *lpdwIterHandle = dwIterHandle;
    *lphOperationData = (HANDLE) lpNdsBuffer;

    //
    // Keep the search from object path . . .
    //
    wcscpy( lpNdsBuffer->szPath, lpNdsObject->szContainerName );

    return NO_ERROR;

ErrorExit :

    if ( lpNdsBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsBuffer );
        lpNdsBuffer = NULL;
    }

    if ( lpNdsQueryTreeBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsQueryTreeBuffer );
        lpNdsQueryTreeBuffer = NULL;
    }

    return status;
}


DWORD
Search_SomeAttrs(
    IN     HANDLE       hStartFromObject,
    IN     DWORD        dwInformationType,
    IN     DWORD        dwScope,
    IN     BOOL         fDerefAliases,
    IN     LPQUERY_TREE lpQueryTree,
    IN OUT LPDWORD      lpdwIterHandle,
    IN OUT HANDLE *     lphOperationData )
{
    DWORD        status;
    DWORD        nwstatus;
    NTSTATUS     ntstatus;
    LPNDS_BUFFER lpNdsBuffer = (LPNDS_BUFFER) *lphOperationData;
    LPNDS_BUFFER lpNdsQueryTreeBuffer = NULL;
    DWORD        dwReplyLength;
    LPNDS_OBJECT_PRIV lpNdsObject = (LPNDS_OBJECT_PRIV) hStartFromObject;
    DWORD        dwIterHandle;
    DWORD        dwNumEntries;
    DWORD        dwAmountOfNodesSearched;
    DWORD        dwLengthOfSearch;
    DWORD        iter;

    //
    // Search NCP parameters
    //
    DWORD        dwFlags = fDerefAliases ?
                           NDS_DEREF_ALIASES :
                           NDS_DONT_DEREF_ALIASES;
    DWORD        dwNumNodes = 0;
    DWORD        dwInfoType = dwInformationType;

    LPBYTE       FixedPortion;
    LPWSTR       EndOfVariableData;
    BOOL         FitInBuffer = TRUE;

    //
    // A quick check of the buffer passed to us.
    //
    if ( lpNdsBuffer->dwBufferId != NDS_SIGNATURE ||
         lpNdsBuffer->dwOperation != NDS_SEARCH )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    //
    // Prepare request buffer stream with search query.
    //
    status = NwNdsCreateBuffer( NDS_SEARCH,
                                (HANDLE *) &lpNdsQueryTreeBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    status = WriteQueryTreeToBuffer( lpQueryTree, lpNdsQueryTreeBuffer );

    if ( status )
    {
        goto ErrorExit;
    }

    if ( lpNdsBuffer->lpReplyBuffer == NULL ||
         lpNdsBuffer->dwReplyBufferSize == 0 )
    {
        //
        // Reasonable guess is that the initial response buffer needs to
        // be 16K bytes.
        //
        lpNdsBuffer->dwReplyBufferSize = SIXTEEN_KB;
    }

    if ( lpNdsBuffer->lpReplyBuffer )
    {
        //
        // This seems to be a sub-sequent call to NwNdsSearch,
        // need to clean up the hOperationData buffer from the last
        // time this was called.
        //
        (void) LocalFree( (HLOCAL) lpNdsBuffer->lpReplyBuffer );
        lpNdsBuffer->lpReplyBuffer = NULL;
        lpNdsBuffer->dwReplyAvailableBytes = 0;
        lpNdsBuffer->dwNumberOfReplyEntries = 0;
        lpNdsBuffer->dwLengthOfReplyData = 0;

        if ( lpNdsBuffer->lpIndexBuffer )
        {
            (void) LocalFree( (HLOCAL) lpNdsBuffer->lpIndexBuffer );
            lpNdsBuffer->lpIndexBuffer = NULL;
            lpNdsBuffer->dwIndexAvailableBytes = 0;
            lpNdsBuffer->dwNumberOfIndexEntries = 0;
            lpNdsBuffer->dwLengthOfIndexData = 0;
        }

        //
        // Since the last call to NwNdsSearch needed a bigger buffer for all
        // of the response data, let's continue this time with a bigger reply
        // buffer. We grow the buffer up to a point, 64K bytes.
        //
        if ( lpNdsBuffer->dwReplyBufferSize < SIXTY_FOUR_KB )
        {
            lpNdsBuffer->dwReplyBufferSize *= 2;
        }
    }

    lpNdsBuffer->lpReplyBuffer =
        (PVOID) LocalAlloc( LPTR, lpNdsBuffer->dwReplyBufferSize );

    //
    // Check that the memory allocation was successful.
    //
    if ( lpNdsBuffer->lpReplyBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: Search_SomeAttrs LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

/*
    //
    // This is the format of a version 3 search request ...
    //
    ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                               NETWARE_NDS_FUNCTION_SEARCH,
                               lpNdsBuffer->lpReplyBuffer,
                               lpNdsBuffer->dwReplyBufferSize,
                               &dwReplyLength,
                               "DDDDDDDDDDrr",
                               0x00000003,
                               dwFlags,
                               *lpdwIterHandle,
                               lpNdsObject->ObjectId, // Id of object to
                                                      // start search from.
                               dwScope,
                               dwNumNodes,
                               dwInfoType,
                               0x0000281D, // (DWORD) FALSE,// All attributes?
                               0x741E0000, // dwNumAttributes,
                               lpNdsBuffer->dwNumberOfRequestEntries,
                               lpNdsBuffer->lpRequestBuffer,
                               lpNdsBuffer->dwLengthOfRequestData,
                               lpNdsQueryTreeBuffer->lpRequestBuffer,
                               (WORD)lpNdsQueryTreeBuffer->dwLengthOfRequestData );
*/

    ntstatus = FragExWithWait( lpNdsObject->NdsTree,
                               NETWARE_NDS_FUNCTION_SEARCH,
                               lpNdsBuffer->lpReplyBuffer,
                               lpNdsBuffer->dwReplyBufferSize,
                               &dwReplyLength,
                               "DDDDDDDDDrr",
                               0x00000002,
                               dwFlags,
                               *lpdwIterHandle,
                               lpNdsObject->ObjectId, // Id of object to
                                                      // start search from.
                               dwScope,
                               dwNumNodes,
                               dwInfoType,
                               (DWORD) FALSE,         // All attributes?
                               lpNdsBuffer->dwNumberOfRequestEntries,
                               lpNdsBuffer->lpRequestBuffer,
                               lpNdsBuffer->dwLengthOfRequestData,
                               lpNdsQueryTreeBuffer->lpRequestBuffer,
                               (WORD)lpNdsQueryTreeBuffer->dwLengthOfRequestData );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    ntstatus = ParseResponse( lpNdsBuffer->lpReplyBuffer,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        status = nwstatus;
        goto ErrorExit;
    }

    ntstatus = ParseResponse( (BYTE *) lpNdsBuffer->lpReplyBuffer,
                              dwReplyLength,
                              "G_DDDDD",
                              sizeof(DWORD),
                              &dwIterHandle,
                              &dwAmountOfNodesSearched,
                              &dwInfoType,
                              &dwLengthOfSearch,
                              &dwNumEntries );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: ReadAttrDef_SomeAttrs: The read object response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        status = (DWORD) UNSUCCESSFUL;
        goto ErrorExit;
    }

    //
    // Finished the search call, free up lpNDsQueryTreeBuffer
    //
    (void) NwNdsFreeBuffer( (HANDLE) lpNdsQueryTreeBuffer );
    lpNdsQueryTreeBuffer = NULL;

    lpNdsBuffer->dwNumberOfReplyEntries = dwNumEntries;
    lpNdsBuffer->dwReplyInformationType = dwInfoType;
    *lpdwIterHandle = dwIterHandle;
    *lphOperationData = (HANDLE) lpNdsBuffer;

    //
    // Keep the search from object path . . .
    //
    wcscpy( lpNdsBuffer->szPath, lpNdsObject->szContainerName );

    return NO_ERROR;

ErrorExit :

    if ( lpNdsQueryTreeBuffer )
    {
        (void) NwNdsFreeBuffer( (HANDLE) lpNdsQueryTreeBuffer );
        lpNdsQueryTreeBuffer = NULL;
    }

    return status;
}


VOID
GetSubTreeData( IN  DWORD    NdsRawDataPtr,
                OUT LPDWORD  lpdwEntryId,
                OUT LPDWORD  lpdwSubordinateCount,
                OUT LPDWORD  lpdwModificationTime,
                OUT LPDWORD  lpdwClassNameLen,
                OUT LPWSTR * lpszClassName,
                OUT LPDWORD  lpdwObjectNameLen,
                OUT LPWSTR * lpszObjectName )
{
    PNDS_RESPONSE_SUBORDINATE_ENTRY pSubEntry =
                             (PNDS_RESPONSE_SUBORDINATE_ENTRY) NdsRawDataPtr;
    PBYTE pbRaw;

    //
    // The structure of a NDS_RESPONSE_SUBORDINATE_ENTRY consists of 4 DWORDs
    // followed by two standard NDS format UNICODE strings. Below we jump pbRaw
    // into the buffer, past the 4 DWORDs.
    //
    *lpdwEntryId = pSubEntry->EntryId;
    *lpdwSubordinateCount = pSubEntry->SubordinateCount;
    *lpdwModificationTime = pSubEntry->ModificationTime;

    pbRaw = (BYTE *) pSubEntry;
    pbRaw += sizeof(NDS_RESPONSE_SUBORDINATE_ENTRY);

    //
    // Now we get the length of the first string (Base Class).
    //
    *lpdwClassNameLen = * (DWORD *) pbRaw;

    //
    // Now we point pbRaw to the first WCHAR of the first string (Base Class).
    //
    pbRaw += sizeof(DWORD);

    *lpszClassName = (LPWSTR) pbRaw;

    //
    // Move pbRaw into the buffer, past the first UNICODE string (WORD aligned)
    //
    pbRaw += ROUNDUP4( *lpdwClassNameLen );

    //
    // Now we get the length of the second string (Entry Name).
    //
    *lpdwObjectNameLen = * (DWORD *) pbRaw;

    //
    // Now we point pbRaw to the first WCHAR of the second string (Entry Name).
    //
    pbRaw += sizeof(DWORD);

    *lpszObjectName = (LPWSTR) pbRaw;
}


LPBYTE
GetSearchResultData( IN  LPBYTE   lpResultBufferPtr,
                     OUT LPDWORD  lpdwFlags,
                     OUT LPDWORD  lpdwSubordinateCount,
                     OUT LPDWORD  lpdwModificationTime,
                     OUT LPDWORD  lpdwClassNameLen,
                     OUT LPWSTR * lpszClassName,
                     OUT LPDWORD  lpdwObjectNameLen,
                     OUT LPWSTR * lpszObjectName,
                     OUT LPDWORD  lpdwEntryInfo1,
                     OUT LPDWORD  lpdwEntryInfo2 )
{
    LPBYTE lpRaw = lpResultBufferPtr;

    *lpdwFlags = * (LPDWORD) lpRaw;
    lpRaw += sizeof(DWORD);

    *lpdwSubordinateCount = * (LPDWORD) lpRaw;
    lpRaw += sizeof(DWORD);

    *lpdwModificationTime = * (LPDWORD) lpRaw;
    lpRaw += sizeof(DWORD);

    //
    // Now we get the length of the first string (Base Class).
    //
    *lpdwClassNameLen = * (DWORD *) lpRaw;

    //
    // Now we point lpRaw to the first WCHAR of the first string (Base Class).
    //
    lpRaw += sizeof(DWORD);

    *lpszClassName = (LPWSTR) lpRaw;

    //
    // Move lpRaw into the buffer, past the first UNICODE string
    // (DWORD aligned)
    //
    lpRaw += ROUNDUP4( *lpdwClassNameLen );

    //
    // Now we get the length of the second string (Entry Name).
    //
    *lpdwObjectNameLen = * (DWORD *) lpRaw;

    //
    // Now we point lpRaw to the first WCHAR of the second string (Entry Name).
    //
    lpRaw += sizeof(DWORD);

    *lpszObjectName = (LPWSTR) lpRaw;

    //
    // Move lpRaw into the buffer, past the second UNICODE string
    // (DWORD aligned)
    //
    lpRaw += ROUNDUP4( *lpdwObjectNameLen );

    //
    // Now skip over the last two DWORDs, I don't know what they represent?
    //
    *lpdwEntryInfo1 = * (LPDWORD) lpRaw;
    lpRaw += sizeof(DWORD);

    *lpdwEntryInfo2 = * (LPDWORD) lpRaw;
    lpRaw += sizeof(DWORD);

    return lpRaw;
}


DWORD
WriteObjectToBuffer(
    IN OUT LPBYTE *        FixedPortion,
    IN OUT LPWSTR *        EndOfVariableData,
    IN     LPWSTR          szObjectFullName,
    IN     LPWSTR          szObjectName,
    IN     LPWSTR          szClassName,
    IN     DWORD           EntryId,
    IN     DWORD           ModificationTime,
    IN     DWORD           SubordinateCount,
    IN     DWORD           NumberOfAttributes,
    IN     LPNDS_ATTR_INFO lpAttributeInfos )
{
    BOOL              FitInBuffer = TRUE;
    LPNDS_OBJECT_INFO lpNdsObjectInfo = (LPNDS_OBJECT_INFO) *FixedPortion;
    DWORD             EntrySize = sizeof( NDS_OBJECT_INFO ) +
                                  ( wcslen( szObjectFullName ) +
                                    wcslen( szObjectName ) +
                                    wcslen( szClassName ) +
                                    3 ) * sizeof( WCHAR );

    EntrySize = ROUND_UP_COUNT( EntrySize, ALIGN_DWORD );

    //
    // See if buffer is large enough to fit the entry.
    //
    if (((DWORD_PTR) *FixedPortion + EntrySize) >
         (DWORD_PTR) *EndOfVariableData) {

        return WN_MORE_DATA;
    }

    lpNdsObjectInfo->dwEntryId = EntryId;
    lpNdsObjectInfo->dwModificationTime = ModificationTime;
    lpNdsObjectInfo->dwSubordinateCount = SubordinateCount;
    lpNdsObjectInfo->dwNumberOfAttributes = NumberOfAttributes;
    lpNdsObjectInfo->lpAttribute = lpAttributeInfos;

    //
    // Update fixed entry pointer to next entry.
    //
    (DWORD_PTR) (*FixedPortion) += sizeof(NDS_OBJECT_INFO);

    FitInBuffer = NwlibCopyStringToBuffer(
                      szObjectFullName,
                      wcslen(szObjectFullName),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &lpNdsObjectInfo->szObjectFullName );

    ASSERT(FitInBuffer);

    FitInBuffer = NwlibCopyStringToBuffer(
                      szObjectName,
                      wcslen(szObjectName),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &lpNdsObjectInfo->szObjectName );

    ASSERT(FitInBuffer);

    FitInBuffer = NwlibCopyStringToBuffer(
                      szClassName,
                      wcslen(szClassName),
                      (LPCWSTR) *FixedPortion,
                      EndOfVariableData,
                      &lpNdsObjectInfo->szObjectClass );

    ASSERT(FitInBuffer);

    if (! FitInBuffer)
        return WN_MORE_DATA;

    return NO_ERROR;
}


DWORD
VerifyBufferSize(
    IN  LPBYTE  lpRawBuffer,
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwSyntaxID,
    IN  DWORD   dwNumberOfValues,
    OUT LPDWORD lpdwLength )
{
    DWORD  iter;
    LPBYTE lpTemp = lpRawBuffer;

    *lpdwLength = 0;

    for ( iter = 0; iter < dwNumberOfValues; iter++ )
    {
        *lpdwLength += SizeOfASN1Structure( &lpTemp, dwSyntaxID );
    }

    if ( *lpdwLength > dwBufferSize )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}


DWORD
VerifyBufferSizeForStringList(
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwNumberOfValues,
    OUT LPDWORD lpdwLength )
{
    *lpdwLength = sizeof(ASN1_TYPE_6) * dwNumberOfValues;

    if ( *lpdwLength > dwBufferSize )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}


DWORD
WriteQueryTreeToBuffer(
    IN  LPQUERY_TREE lpQueryTree,
    IN  LPNDS_BUFFER lpNdsBuffer )
{
    DWORD status;

    switch( lpQueryTree->dwOperation )
    {
        case NDS_QUERY_OR :
        case NDS_QUERY_AND :

            if ( lpQueryTree->lpLVal == NULL || lpQueryTree->lpRVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryTreeToBuffer was not passed a pointer to an L or R value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            status = WriteQueryNodeToBuffer( (LPQUERY_NODE) lpQueryTree,
                                             lpNdsBuffer );

            if ( status )
                return status;

            status = WriteQueryTreeToBuffer( (LPQUERY_TREE) lpQueryTree->lpLVal,
                                             lpNdsBuffer );

            if ( status )
                return status;

            status = WriteQueryTreeToBuffer( (LPQUERY_TREE) lpQueryTree->lpRVal,
                                             lpNdsBuffer );

            if ( status )
                return status;

            break;

        case NDS_QUERY_NOT :

            if ( lpQueryTree->lpLVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryTreeToBuffer was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            status = WriteQueryNodeToBuffer( (LPQUERY_NODE) lpQueryTree,
                                             lpNdsBuffer );

            if ( status )
                return status;

            status = WriteQueryTreeToBuffer( (LPQUERY_TREE) lpQueryTree->lpLVal,
                                             lpNdsBuffer );

            if ( status )
                return status;

            break;

        case NDS_QUERY_EQUAL :
        case NDS_QUERY_GE :
        case NDS_QUERY_LE :
        case NDS_QUERY_APPROX :
        case NDS_QUERY_PRESENT :

            status = WriteQueryNodeToBuffer( (LPQUERY_NODE) lpQueryTree,
                                             lpNdsBuffer );

            if ( status )
                return status;

            break;

        default :
#if DBG
            KdPrint(( "NDS32: WriteQueryTreeToBuffer was passed an unidentified operation - 0x%.8X.\n", lpQueryTree->dwOperation ));
#endif

             SetLastError( ERROR_INVALID_PARAMETER );
             return (DWORD) UNSUCCESSFUL;
    }

    return NO_ERROR;
}


DWORD
WriteQueryNodeToBuffer(
    IN  LPQUERY_NODE lpQueryNode,
    IN  LPNDS_BUFFER lpNdsBuffer )
{
    DWORD  LengthInBytes = 0;
    DWORD  stringLen;
    LPBYTE lpTemp;

    if ( lpNdsBuffer->dwRequestAvailableBytes < ONE_KB )
    {
        //
        // Buffer to store query is getting small, need to increase
        // request buffer size.
        //
        if ( AllocateOrIncreaseRequestBuffer( lpNdsBuffer ) != NO_ERROR )
        {
#if DBG
            KdPrint(( "NDS32: WriteQueryNodeToBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return (DWORD) UNSUCCESSFUL;
        }
    }

    lpTemp = (LPBYTE)&lpNdsBuffer->lpRequestBuffer[lpNdsBuffer->dwLengthOfRequestData];

    switch( lpQueryNode->dwOperation )
    {
        case NDS_QUERY_OR :
        case NDS_QUERY_AND :

            if ( lpQueryNode->lpLVal == NULL || lpQueryNode->lpRVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryNodeToBuffer was not passed a pointer to an L or R value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            //
            // Write out operation
            //
            *(LPDWORD)lpTemp = lpQueryNode->dwOperation;
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            *(LPDWORD)lpTemp = 2; // The number of items being ANDed or ORed.
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            break;

        case NDS_QUERY_NOT :

            if ( lpQueryNode->lpLVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryNodeToBuffer was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            //
            // Write out operation
            //
            *(LPDWORD)lpTemp = lpQueryNode->dwOperation;
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            break;

        case NDS_QUERY_EQUAL :
        case NDS_QUERY_GE :
        case NDS_QUERY_LE :
        case NDS_QUERY_APPROX :

            if ( lpQueryNode->lpLVal == NULL || lpQueryNode->lpRVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryNodeToBuffer was not passed a pointer to an L or R value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            //
            // Write out operation
            //
            *(LPDWORD)lpTemp = 0; // Zero represents ITEM in NDS
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            *(LPDWORD)lpTemp = lpQueryNode->dwOperation;
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            switch( lpQueryNode->dwSyntaxId )
            {
                case NDS_SYNTAX_ID_1 :
                case NDS_SYNTAX_ID_2 :
                case NDS_SYNTAX_ID_3 :
                case NDS_SYNTAX_ID_4 :
                case NDS_SYNTAX_ID_5 :
                case NDS_SYNTAX_ID_10 :
                case NDS_SYNTAX_ID_20 :
                    //
                    // Write out the attribute name stored in LVal
                    //
                    stringLen = wcslen( (LPWSTR) lpQueryNode->lpLVal );

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   lpQueryNode->lpLVal,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                              ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD );

                    //
                    // Write out the attribute value stored in RVal
                    //
                    stringLen = wcslen( (LPWSTR) lpQueryNode->lpRVal );

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   lpQueryNode->lpRVal,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                              ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD );

                    break;

                case NDS_SYNTAX_ID_7 :

                    //
                    // Write out the attribute name stored in LVal
                    //
                    stringLen = wcslen( (LPWSTR) lpQueryNode->lpLVal );

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   lpQueryNode->lpLVal,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                              ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD );

                    //
                    // Write out the attribute value stored in RVal
                    //
                    *(LPDWORD)lpTemp = 1; // Needs to have value 1,
                                          // representing one byte
                                          // even though it is padded
                                          // out to four bytes.
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);
                    *(LPDWORD)lpTemp = 0; // This clears all bits of the DWORD
                    *(LPBYTE)lpTemp = (BYTE) (((LPASN1_TYPE_7)
                                                lpQueryNode->lpRVal)->Boolean);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    break;

                case NDS_SYNTAX_ID_8 :
                case NDS_SYNTAX_ID_22 :
                case NDS_SYNTAX_ID_24 :
                case NDS_SYNTAX_ID_27 :
                    //
                    // Write out the attribute name stored in LVal
                    //
                    stringLen = wcslen( (LPWSTR) lpQueryNode->lpLVal );

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   lpQueryNode->lpLVal,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                              ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD );

                    //
                    // Write out the attribute value stored in RVal
                    //
                    *(LPDWORD)lpTemp = sizeof( DWORD );
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);
                    *(LPDWORD)lpTemp = *( (LPDWORD) lpQueryNode->lpRVal );
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    break;

                case NDS_SYNTAX_ID_9 :
                    //
                    // Write out the attribute name stored in LVal
                    //
                    stringLen = wcslen( (LPWSTR) lpQueryNode->lpLVal );

                    *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   lpQueryNode->lpLVal,
                                   stringLen*sizeof(WCHAR) );
                    lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                              ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                                     sizeof(WCHAR),
                                                     ALIGN_DWORD );

                    //
                    // Write out the attribute value stored in RVal
                    //
                    stringLen = ((LPASN1_TYPE_9) lpQueryNode->lpRVal)->Length;

                    *(LPDWORD)lpTemp = stringLen;
                    lpTemp += sizeof(DWORD);
                    LengthInBytes += sizeof(DWORD);

                    RtlCopyMemory( lpTemp,
                                   &((LPASN1_TYPE_9) lpQueryNode->lpRVal)->OctetString,
                                   stringLen );
                    lpTemp += ROUND_UP_COUNT( stringLen, ALIGN_DWORD);
                    LengthInBytes += ROUND_UP_COUNT( stringLen, ALIGN_DWORD );

                    break;

                default :
                    SetLastError( ERROR_NOT_SUPPORTED );
                    return (DWORD) UNSUCCESSFUL;
            }

            break;

        case NDS_QUERY_PRESENT :

            if ( lpQueryNode->lpLVal == NULL )
            {
#if DBG
                KdPrint(( "NDS32: WriteQueryNodeToBuffer was not passed a pointer to an L value.\n" ));
#endif

                 SetLastError( ERROR_INVALID_PARAMETER );
                 return (DWORD) UNSUCCESSFUL;
            }

            //
            // Write out operation
            //
            *(LPDWORD)lpTemp = 0; // Zero represents ITEM in NDS
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            *(LPDWORD)lpTemp = lpQueryNode->dwOperation;
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            //
            // Write out the attribute name stored in LVal
            //
            stringLen = wcslen( (LPWSTR) lpQueryNode->lpLVal );

            *(LPDWORD)lpTemp = (stringLen + 1) * sizeof(WCHAR);
            lpTemp += sizeof(DWORD);
            LengthInBytes += sizeof(DWORD);

            RtlCopyMemory( lpTemp,
                           lpQueryNode->lpLVal,
                           stringLen*sizeof(WCHAR) );
            lpTemp += ROUND_UP_COUNT( (stringLen+1)*sizeof(WCHAR),
                                      ALIGN_DWORD);
            LengthInBytes += ROUND_UP_COUNT( (stringLen+1) *
                                             sizeof(WCHAR),
                                             ALIGN_DWORD );

            break;

        default :
#if DBG
            KdPrint(( "NDS32: WriteQueryNodeToBuffer was passed an unidentified operation - 0x%.8X.\n", lpQueryNode->dwOperation ));
#endif

             SetLastError( ERROR_INVALID_PARAMETER );
             return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->dwRequestAvailableBytes -= LengthInBytes;
    lpNdsBuffer->dwLengthOfRequestData += LengthInBytes;

    return NO_ERROR;
}


DWORD
NwNdsGetServerDN(
    IN  HANDLE hTree,
    OUT LPWSTR szServerDN )
{
    DWORD          nwstatus;
    DWORD          status = NO_ERROR;
    NTSTATUS       ntstatus = STATUS_SUCCESS;
    DWORD          dwReplyLength;
    BYTE           NdsReply[NDS_BUFFER_SIZE];
    LPNDS_OBJECT_PRIV   lpNdsObject = (LPNDS_OBJECT_PRIV) hTree;

    if ( lpNdsObject == NULL ||
         lpNdsObject->Signature != NDS_SIGNATURE )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus =
        FragExWithWait( lpNdsObject->NdsTree,
                        NETWARE_NDS_FUNCTION_GET_SERVER_ADDRESS,
                        NdsReply,
                        NDS_BUFFER_SIZE,
                        &dwReplyLength,
                        NULL );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetServerInfo: The call to FragExWithWait failed with 0x%.8X.\n", ntstatus ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    ntstatus = ParseResponse( NdsReply,
                              dwReplyLength,
                              "GD",
                              &nwstatus );

    if ( !NT_SUCCESS( ntstatus ) )
    {
#if DBG
        KdPrint(( "NDS32: NwNdsGetServerInfo: The get server information response was undecipherable.\n" ));
#endif

        SetLastError( RtlNtStatusToDosError( ntstatus ) );
        return (DWORD) UNSUCCESSFUL;
    }

    if ( nwstatus )
    {
        SetLastError( MapNetwareErrorCode( nwstatus ) );
        return nwstatus;
    }
    else
    {
        LPBYTE lpByte = NdsReply;
        DWORD  dwStrLen = 0;
        DWORD  dwNumPartitions = 0;

        //
        // Skip past status return code ...
        //
        lpByte += sizeof( DWORD );

        //
        // Skip past the length value of the Server DN string ...
        //
        lpByte += sizeof( DWORD );

        wcscpy( szServerDN, (LPWSTR) lpByte );

        return NO_ERROR;
    }
}


DWORD
AllocateOrIncreaseSyntaxBuffer(
    IN  LPNDS_BUFFER lpNdsBuffer )
{
    if ( lpNdsBuffer->lpSyntaxBuffer )
    {
        LPBYTE lpTempBuffer = NULL;

        //
        // Need to reallocate buffer to a bigger size.
        //
        lpTempBuffer = (LPBYTE) LocalReAlloc(
                                   (HLOCAL) lpNdsBuffer->lpSyntaxBuffer,
                                   lpNdsBuffer->dwSyntaxBufferSize + FOUR_KB,
                                   LPTR );

        if ( lpTempBuffer )
        {
            lpNdsBuffer->lpSyntaxBuffer = lpTempBuffer;
        }
        else
        {
            lpTempBuffer = (LPBYTE) LocalAlloc( LPTR,
                                       lpNdsBuffer->dwSyntaxBufferSize +
                                       FOUR_KB );

            if ( lpTempBuffer )
            {
                RtlCopyMemory( lpTempBuffer,
                               lpNdsBuffer->lpSyntaxBuffer,
                               lpNdsBuffer->dwSyntaxBufferSize );

                LocalFree( lpNdsBuffer->lpSyntaxBuffer );

                lpNdsBuffer->lpSyntaxBuffer = lpTempBuffer;
            }
            else
            {
                LocalFree( lpNdsBuffer->lpSyntaxBuffer );

                lpNdsBuffer->lpSyntaxBuffer = NULL;
            }
        }
    }
    else
    {
        //
        // Need to allocate a 4K byte buffer.
        //
        lpNdsBuffer->lpSyntaxBuffer = (LPBYTE) LocalAlloc( LPTR,
                                                           FOUR_KB );
        lpNdsBuffer->dwSyntaxBufferSize = 0;
        lpNdsBuffer->dwSyntaxAvailableBytes = 0;
    }

    if ( lpNdsBuffer->lpSyntaxBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: AllocateOrIncreaseSyntaxBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->dwSyntaxBufferSize += FOUR_KB;
    lpNdsBuffer->dwSyntaxAvailableBytes += FOUR_KB;

    return NO_ERROR;
}


DWORD
AllocateOrIncreaseRequestBuffer(
    IN  LPNDS_BUFFER lpNdsBuffer )
{
    if ( lpNdsBuffer->lpRequestBuffer )
    {
        LPBYTE lpTempBuffer = NULL;

        //
        // Need to reallocate buffer to a bigger size.
        //
        lpTempBuffer = (LPBYTE) LocalReAlloc(
                                   (HLOCAL) lpNdsBuffer->lpRequestBuffer,
                                   lpNdsBuffer->dwRequestBufferSize + TWO_KB,
                                   LPTR );

        if ( lpTempBuffer )
        {
            lpNdsBuffer->lpRequestBuffer = lpTempBuffer;
        }
        else
        {
            lpTempBuffer = (LPBYTE) LocalAlloc( LPTR,
                                       lpNdsBuffer->dwRequestBufferSize +
                                       TWO_KB );

            if ( lpTempBuffer )
            {
                RtlCopyMemory( lpTempBuffer,
                               lpNdsBuffer->lpRequestBuffer,
                               lpNdsBuffer->dwRequestBufferSize );

                LocalFree( lpNdsBuffer->lpRequestBuffer );

                lpNdsBuffer->lpRequestBuffer = lpTempBuffer;
            }
            else
            {
                LocalFree( lpNdsBuffer->lpRequestBuffer );

                lpNdsBuffer->lpRequestBuffer = NULL;
            }
        }
    }
    else
    {
        //
        // Need to allocate a 2K byte buffer.
        //
        lpNdsBuffer->lpRequestBuffer = (LPBYTE) LocalAlloc( LPTR,
                                                           TWO_KB );
        lpNdsBuffer->dwRequestBufferSize = 0;
        lpNdsBuffer->dwRequestAvailableBytes = 0;
    }

    if ( lpNdsBuffer->lpRequestBuffer == NULL )
    {
#if DBG
        KdPrint(( "NDS32: AllocateOrIncreaseRequestBuffer LocalAlloc Failed 0x%.8X\n", GetLastError() ));
#endif

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return (DWORD) UNSUCCESSFUL;
    }

    lpNdsBuffer->dwRequestBufferSize += TWO_KB;
    lpNdsBuffer->dwRequestAvailableBytes += TWO_KB;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\procs.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    procs.c

Abstract:

    Common header file for routines which support 16 bit
    applications.

Author:

    Colin Watson    (colinw)    21-Nov-1993

Environment:


Revision History:


--*/

#define UNICODE


#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ctype.h>

#include <validc.h>
#include <nwstatus.h>
#include <nwcanon.h>
#include <ntddnwfs.h>
#include <npapi.h>

#include <nwxchg.h>
#include <nwapi.h>
#include <nwapi32.h>
#include <nwpapi32.h>
#include <ndsapi32.h>
#include <nds.h>

#include <debugfmt.h>   // FORMAT_LPSTR
#include <mpr.h>

#include <lmcons.h>
#include <ntsam.h>
#include <nwpkstr.h>

#ifdef WIN95
#include "defines.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\msnwdef.h ===
/*****************************************************************/
/**               Microsoft Windows 4.00					**/
/**           Copyright (C) Microsoft Corp., 1994-1995	        **/
/*****************************************************************/

/*
 * Internal NetWare access API definitions for use by Windows components
 *
 * History
 *
 * 		vlads	12/15/94	Created
 *
 *
 */

#ifndef _INC_MSNWDEF
#define _INC_MSNWDEF


#ifdef _H2INC

#define WINAPI 	_stdcall
#define VOID	void
#define LPVOID 	void *

typedef unsigned char BYTE;
typedef BYTE *LPBYTE;
typedef	unsigned int UINT;
typedef	unsigned int WORD;

typedef unsigned long DWORD;
typedef unsigned long ULONG;
typedef char *LPSTR;
typedef DWORD *LPDWORD;
typedef UINT	*LPUINT;	
typedef WORD *LPWORD;

#endif

//
// Base definitions
//
#ifndef NWCONN_HANDLE
typedef HANDLE 	NWCONN_HANDLE;	// Connection handle
#endif

typedef NWCONN_HANDLE*	PNWCONN_HANDLE;


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */





#ifdef __cplusplus
}
#endif	/* __cplusplus */


#endif  /* !_INC_MSNWDEF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\exchg95.c ===
/*++

Copyright (c) 1993-1996  Microsoft Corporation

Module Name:

    exchg95.c

Abstract:

    Contains routine which packages the request buffer, makes
    the NCP request, and unpackages the response buffer.

Author:

    Hans Hurvig     (hanshu)       Aug-1992  Created
    Colin Watson    (colinw)    19-Dec-1992
    Rita Wong       (ritaw)     11-Mar-1993  FSCtl version
    Felix Wong      (t-felixw)  16-Sep-1996  Ported for Win95 OLEDS

Environment:


Revision History:


--*/

#include <procs.h>
#include <nw95.h>
#include <msnwerr.h>

// This controls automatic OEM<->ANSI translation for string parameters
#define DO_OEM_TRANSLATION      1

ULONG
FsToNwControlCode(
    ULONG FsControlCode
    )
{
    switch ( FsControlCode) {
        case FSCTL_NWR_NCP_E3H:
            return 0X00e3;
        case FSCTL_NWR_NCP_E2H:
            return 0X00e2;
        case FSCTL_NWR_NCP_E1H:
            return 0X00e1;
        case FSCTL_NWR_NCP_E0H:
            return 0X00e0;
        default:
            return 0xFFFF;
    }
}


NTSTATUS
GetFileServerVersionInfo(
    HANDLE                DeviceHandle,
    VERSION_INFO NWFAR   *lpVerInfo
    )
{
    NTSTATUS NtStatus ;

    NtStatus = NwlibMakeNcp(
                    DeviceHandle,           // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    130,                    // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0x11,                   // b Get File Server Information
                    // === REPLY ==================================
                    lpVerInfo,              // r File Version Structure
                    sizeof(VERSION_INFO)
                    );

    // Convert HI-LO words to LO-HI
    // ===========================================================
    lpVerInfo->ConnsSupported = wSWAP( lpVerInfo->ConnsSupported );
    lpVerInfo->connsInUse     = wSWAP( lpVerInfo->connsInUse );
    lpVerInfo->maxVolumes     = wSWAP( lpVerInfo->maxVolumes );
    lpVerInfo->PeakConns      = wSWAP( lpVerInfo->PeakConns );

    return NtStatus;
}


NTSTATUS
NwlibMakeNcp(
    IN HANDLE DeviceHandle,
    IN ULONG FsControlCode,
    IN ULONG RequestBufferSize,
    IN ULONG ResponseBufferSize,
    IN PCHAR FormatString,
    ...                           // Arguments to FormatString
    )
/*++

Routine Description:

    This function converts the input arguments into an NCP request buffer
    based on the format specified in FormatString (e.g. takes a word
    and writes it in hi-lo format in the request buffer as required by
    an NCP).

    It then makes the NCP call via the NtFsControlFile API.

    The FormatString also specifies how to convert the fields in the
    response buffer from the completed NCP call into the output
    arguments.

    The FormatString takes the form of "xxxx|yyyy" where each 'x'
    indicates an input argument to convert from, and each 'y' indicates
    an output argument to convert into.  The '|' character separates
    the input format from the output format specifications.

        String parameters are expected to be in ANSI code and are translated to
        OEM code before issuing NCP. Reverse translation is done on the way back

Arguments:

    DeviceHandle - Supplies a handle to the network file system driver
        which will be making the network request.  This function
        assumes that the handle was opened for synchronouse I/O access.

    FsControlCode - Supplies the control code which determines the
        NCP.

    RequestBufferSize - Supplies the size of the request buffer in
        bytes to be allocated by this routine.

    ResponseBufferSize - Supplies the size of the response buffer in
        bytes to be allocated by this routine.

    FormatString - Supplies an ANSI string which describes how to
       convert from the input arguments into NCP request fields, and
       from the NCP response fields into the output arguments.

         Field types, request/response:

            'b'      byte              ( byte   /  byte* )
            'w'      hi-lo word        ( word   /  word* )
            'd'      hi-lo dword       ( dword  /  dword* )
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'P'      DBCS pstring      ( char* )
            'c'      cstring           ( char* )
            'C'      cstring followed skip word ( char*, word )
            'r'      raw bytes         ( byte*, word )
            'R'      DBCS raw bytes    ( byte*, word )
            'u'      p unicode string  ( UNICODE_STRING * )
            'U'      p uppercase string( UNICODE_STRING * )
            'W'      word n followed by an array of word[n] ( word, word* )
            
Return Value:

    Return code from the NCP call.

--*/
{
    NTSTATUS BinderyStatus = STATUS_SUCCESS;

    va_list Arguments;
    PCHAR       z;
    WORD        t = 1;
    ULONG       data_size;

    LPBYTE      RequestBuffer = NULL;
    LPBYTE      ResponseBuffer;
    LPBYTE  ScratchBuffer = NULL;

    DWORD       ReturnedDataSize;
    ULONG       NwControlCode;

    BOOL GetVersionInfo = TRUE;
    BOOL DoMapSpecialJapaneseCharThing = TRUE;
    VERSION_INFO VerInfo;

    if ((NwControlCode = FsToNwControlCode(FsControlCode)) == 0xFFFF)
            return STATUS_UNSUCCESSFUL;
                
    //
    // Allocate memory for request and response buffers.
    //
        ScratchBuffer = (LPBYTE)LocalAlloc(
                        LMEM_ZEROINIT,
                        RequestBufferSize + ResponseBufferSize+
                                                2*sizeof(WORD)          // We include size fields in packets
                        );

    if (ScratchBuffer == NULL) {
        KdPrint(("NWLIB: NwlibMakeNcp LocalAlloc failed %lu\n", GetLastError()));
        return STATUS_NO_MEMORY;
    }

    // First fill size field for request buffer in
    *((WORD *)ScratchBuffer) = LOWORD(RequestBufferSize);
    RequestBuffer = ScratchBuffer + sizeof(WORD);

    // Calculate pointer to response part
    ResponseBuffer = (LPBYTE) ((ULONG) RequestBuffer + RequestBufferSize);
        *((WORD *)ResponseBuffer) = LOWORD(ResponseBufferSize);

    va_start( Arguments, FormatString );

    //
    // Convert the input arguments into request packet.
    //
    z = FormatString;

    data_size = 0;

    while ( *z && *z != '|')
    {
        switch ( *z )
        {
        case '=':
            RequestBuffer[data_size++] = 0;
        case '-':
            RequestBuffer[data_size++] = 0;
            break;

        case '_':
        {
            WORD l = va_arg ( Arguments, WORD );
            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case '_' request buffer too small\n"));
                BinderyStatus = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }
            while ( l-- )
                RequestBuffer[data_size++] = 0;
            break;
        }

        case 'b':
            RequestBuffer[data_size++] = va_arg ( Arguments, BYTE );
            break;

        case 'w':
        {
            WORD w = va_arg ( Arguments, WORD );
            RequestBuffer[data_size++] = (BYTE) (w >> 8);
            RequestBuffer[data_size++] = (BYTE) (w >> 0);
            break;
        }

        case 'd':
        {
            DWORD d = va_arg ( Arguments, DWORD );
            RequestBuffer[data_size++] = (BYTE) (d >> 24);
            RequestBuffer[data_size++] = (BYTE) (d >> 16);
            RequestBuffer[data_size++] = (BYTE) (d >>  8);
            RequestBuffer[data_size++] = (BYTE) (d >>  0);
            break;
        }

        case 'c':
        {
            char* c = va_arg ( Arguments, char* );
            WORD  l = strlen( c );
            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'c' request buffer too small\n"));
                BinderyStatus = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RtlCopyMemory( &RequestBuffer[data_size], c, l+1 );

                        #ifdef DO_OEM_TRANSLATION
                        CharToOemA( (LPCSTR)&RequestBuffer[data_size],(LPSTR)&RequestBuffer[data_size]);
                        #endif

            data_size += l + 1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( Arguments, char* );
            WORD l = va_arg ( Arguments, WORD );
            WORD len = strlen( c ) + 1;
            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'C' request buffer too small\n"));
                BinderyStatus = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RtlCopyMemory( &RequestBuffer[data_size], c, len > l? l : len);

                        #ifdef DO_OEM_TRANSLATION
                        CharToOemBuffA((LPCSTR)&RequestBuffer[data_size], (LPSTR)&RequestBuffer[data_size],l);
                        #endif

            data_size += l;
            RequestBuffer[data_size-1] = 0;
            break;
        }

        case 'P':
        case 'p':
        {
            char* c = va_arg ( Arguments, char* );
            BYTE  l = strlen( c );
                char* p;
            
            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'p' request buffer too small\n"));
                BinderyStatus = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }
            RequestBuffer[data_size++] = l;
            RtlCopyMemory(p=(char*)&RequestBuffer[data_size], c, l );

            //
            // Map Japanese special chars
            //
            if (*z == 'P')
            {
                if ( GetVersionInfo )
                {
                    BinderyStatus = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( BinderyStatus == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                     MapSpecialJapaneseChars(p, (WORD)l);
                }
            }
            
#ifdef DO_OEM_TRANSLATION
            CharToOemBuffA( (LPCSTR)&RequestBuffer[data_size],
                            (LPSTR)&RequestBuffer[data_size],
                            l );
#endif

            data_size += l;
            break;
        }
        
        case 'u':
        {
            PUNICODE_STRING pUString = va_arg ( Arguments, PUNICODE_STRING );
            OEM_STRING OemString;
            ULONG Length;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            if ( data_size + Length > RequestBufferSize ) {
                KdPrint(("NWLIB: NwlibMakeNcp case 'u' request buffer too small\n"));
                BinderyStatus = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RequestBuffer[data_size++] = (UCHAR)Length;
            OemString.Buffer = &RequestBuffer[data_size];
            OemString.MaximumLength = (USHORT)Length + 1;

            BinderyStatus = RtlUnicodeStringToOemString( &OemString, pUString, FALSE );
            ASSERT( NT_SUCCESS( BinderyStatus ));
            data_size += (USHORT)Length;
            break;
        }

        case 'U':
        {
            //
            //  UPPERCASE the string, copy it from unicode to the packet
            //

            PUNICODE_STRING pUString = va_arg ( Arguments, PUNICODE_STRING );
            UNICODE_STRING UUppercaseString;
            OEM_STRING OemString;
            ULONG Length;

            BinderyStatus = RtlUpcaseUnicodeString(&UUppercaseString, pUString, TRUE);
            if ( BinderyStatus )
            {
                goto CleanExit;
            }
            
            pUString = &UUppercaseString;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            if ( data_size + Length > RequestBufferSize ) {
                KdPrint(("NWLIB: NwlibMakeNcp case 'U' request buffer too small\n"));
                BinderyStatus = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RequestBuffer[data_size++] = (UCHAR)Length;
            OemString.Buffer = &RequestBuffer[data_size];
            OemString.MaximumLength = (USHORT)Length + 1;

            BinderyStatus = RtlUnicodeStringToOemString( &OemString, pUString, FALSE );
            ASSERT( NT_SUCCESS( BinderyStatus ));

            RtlFreeUnicodeString( &UUppercaseString );

            data_size += (USHORT)Length;
            break;
        }

        case 'R':
        case 'r':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            WORD  l = va_arg ( Arguments, WORD );
                char* c;
            
            if ( data_size + l > RequestBufferSize )
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'r' request buffer too small\n"));
                BinderyStatus = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }
            RtlCopyMemory( c = (char*)&RequestBuffer[data_size], b, l );
            data_size += l;
            
            //
            // Map Japanese special chars
            //
            if (*z == 'R')
            {
                if ( GetVersionInfo )
                {
                    BinderyStatus = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( BinderyStatus == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                     MapSpecialJapaneseChars(c, (WORD)l);
                }
            }

            break;
        }

        default:
            KdPrint(("NWLIB: NwlibMakeNcp invalid request field, %x\n", *z));
            ASSERT(FALSE);
        }

        if ( data_size > RequestBufferSize )
        {
            KdPrint(("NWLIB: NwlibMakeNcp too much request data\n"));
            BinderyStatus = STATUS_BUFFER_TOO_SMALL;
            goto CleanExit;
        }


        z++;
    }

        // Nb: Function code passed to this call should contain full content
        // of AX, while the one which has been passed to us is only AH. So we
        // need to add low byte ( default 0)
        BinderyStatus = NWConnControlRequest(
                                VLMToNWREDIRHandle(DeviceHandle),
                                NwControlCode<<8+0,
                                ScratchBuffer,
                                ResponseBuffer);
        if (BinderyStatus != NWSC_SUCCESS) {
            KdPrint(("NWLIB: NwlibMakeNcp: NtFsControlFile returns x%08lx\n", 
                     BinderyStatus));
        goto CleanExit;
        }

        ReturnedDataSize = *((WORD *)ResponseBuffer);
        ResponseBuffer = ResponseBuffer + sizeof(WORD);



    //
    // Convert the response packet into output arguments.
    //

    data_size = 0;

    if (*z && *z == '|') {
        z++;
    }

    while ( *z )
    {
        switch ( *z )
        {
        case '-':
            data_size += 1;
            break;

        case '=':
            data_size += 2;
            break;

        case '_':
        {
            WORD l = va_arg ( Arguments, WORD );
            data_size += l;
            break;
        }

        case 'b':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            *b = ResponseBuffer[data_size++];
            break;
        }

        case 'w':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            b[1] = ResponseBuffer[data_size++];
            b[0] = ResponseBuffer[data_size++];
            break;
        }

        case 'd':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            b[3] = ResponseBuffer[data_size++];
            b[2] = ResponseBuffer[data_size++];
            b[1] = ResponseBuffer[data_size++];
            b[0] = ResponseBuffer[data_size++];
            break;
        }

        case 'c':
        {
            char* c = va_arg ( Arguments, char* );
            WORD  l = strlen( (LPSTR)&ResponseBuffer[data_size] );
            if ( data_size+l+1 < ReturnedDataSize ) {
                RtlCopyMemory( c, &ResponseBuffer[data_size], l+1 );

                                #ifdef DO_OEM_TRANSLATION
                                OemToCharA(c,c);
                                #endif
            }

            data_size += l+1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( Arguments, char* );
            WORD l = va_arg ( Arguments, WORD );
            WORD len = strlen( (LPSTR)&ResponseBuffer[data_size] ) + 1;

            if ( data_size + l < ReturnedDataSize ) {
                RtlCopyMemory( c, &ResponseBuffer[data_size], len > l ? l :len);

                                #ifdef DO_OEM_TRANSLATION
                                OemToCharBuffA(c,c,len > l ? l :len);
                                #endif
            }

            c[l-1] = 0;
            data_size += l;
            break;

        }
        
        case 'P':
        case 'p':
        {
            char* c = va_arg ( Arguments, char* );
            BYTE  l = ResponseBuffer[data_size++];
            if ( data_size+l <= ReturnedDataSize ) {
                RtlCopyMemory( c, &ResponseBuffer[data_size], l );
                                #ifdef DO_OEM_TRANSLATION
                                OemToCharBuffA(c,c,l);
                                #endif
                c[l] = 0;
            }
            data_size += l;

            //
            // Unmap Japanese special chars
            //
            if (*z == 'P')
            {
                if ( GetVersionInfo )
                {
                    BinderyStatus = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( BinderyStatus == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                    UnmapSpecialJapaneseChars(c, l);
                }
            }
            
            break;
        }

        case 'R':
        case 'r':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            WORD  l = va_arg ( Arguments, WORD );
            RtlCopyMemory( b, &ResponseBuffer[data_size], l );
            data_size += l;
                
            //
            // Unmap Japanese special chars
            //
            if (*z == 'R')
            {
                if ( GetVersionInfo )
                {
                    BinderyStatus = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( BinderyStatus == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                    UnmapSpecialJapaneseChars(b, l);
                }
            }

            break;
            
        }

        case 'W':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            BYTE* w = va_arg ( Arguments, BYTE* );
            WORD  i;

            b[1] = ResponseBuffer[data_size++];
            b[0] = ResponseBuffer[data_size++];

            for ( i = 0; i < ((WORD) *b); i++, w += sizeof(WORD) )
            {
                w[1] = ResponseBuffer[data_size++];
                w[0] = ResponseBuffer[data_size++];
            }
            break;
        }

        default:
            KdPrint(("NWLIB: NwlibMakeNcp invalid response field, %x\n", *z));
            ASSERT(FALSE);
        }

        if ( data_size > ReturnedDataSize )
        {
            KdPrint(("NWLIB: NwlibMakeNcp not enough response data\n"));
            BinderyStatus = STATUS_UNSUCCESSFUL;
            goto CleanExit;
        }

        z++;
    }

    BinderyStatus = STATUS_SUCCESS;

CleanExit:
    if (ScratchBuffer != NULL) {
        (void) LocalFree((HLOCAL) ScratchBuffer);
    }

    va_end( Arguments );

    return BinderyStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\defines.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    defines.h

Abstract:

    header file to define out the unimplemneted functions

Author:

    Felix Wong(t-felixw)    6-Oct-1996

Environment:


Revision History:


--*/
#include "assert.h"
#define NPCloseEnum(p1) (assert(((void)p1,\
                                 FALSE)),\
                         FALSE)
#define NPEnumResource(p1, p2, p3, p4) (assert(((void)p1,\
                                                (void)p2,\
                                                (void)p3,\
                                                (void)p4,\
                                                FALSE)),\
                                        FALSE)
#define NPOpenEnum(p1, p2, p3, p4, p5) (assert(((void)p1,\
                                                (void)p2,\
                                                (void)p3,\
                                                (void)p4,\
                                                (void)p5,\
                                                FALSE)),\
                                        FALSE)
#define NPAddConnection(p1, p2, p3) (assert(((void)p1,\
                                             (void)p2,\
                                             (void)p3,\
                                             FALSE)),\
                                     FALSE)
#define NPCancelConnection(p1, p2) (assert(((void)p1,\
                                            (void)p2,\
                                            FALSE)),\
                                    FALSE)
#define NtOpenFile(p1, p2, p3, p4, p5, p6) (assert(((void)p1,\
                                                    (void)p2,\
                                                    (void)p3,\
                                                    (void)p4,\
                                                    (void)p5,\
                                                    (void)p6,\
                                                    FALSE)),\
                                            FALSE)
#define NtClose(p1) (assert(((void)p1,\
                             FALSE)),\
                     FALSE)
#define NtFsControlFile(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10) (assert(((void)p1,\
                                                                 (void)p2,\
                                                                 (void)p3,\
                                                                 (void)p4,\
                                                                 (void)p5,\
                                                                 (void)p6,\
                                                                 (void)p7,\
                                                                 (void)p8,\
                                                                 (void)p9,\
                                                                 (void)p10,\
                                                                 FALSE)),\
                                                          FALSE)
#define NtCreateFile(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11) (assert(((void)p1,\
                                                                  (void)p2,\
                                                                  (void)p3,\
                                                                  (void)p4,\
                                                                  (void)p5,\
                                                                  (void)p6,\
                                                                  (void)p7,\
                                                                  (void)p8,\
                                                                  (void)p9,\
                                                                  (void)p10,\
                                                                  (void)p11,\
                                                                  FALSE)),\
                                                          FALSE)
#define NtQueryDefaultLocale(p1, p2) \
            *(p2) = LANG_ENGLISH, STATUS_SUCCESS

#define NPCancelConnection(p1, p2) (assert(((void)p1,\
                                            (void)p2,\
                                            FALSE)),\
                                    FALSE)
#define NwAttachToServer(p1, p2) (assert(((void)p1,\
                                          (void)p2,\
                                          FALSE)),\
                                  FALSE)
#define NwDetachFromServer(p1) (assert(((void)p1,\
                                        FALSE)),\
                                FALSE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\tpath.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    tpath.c

Abstract:

    Test for canonicalization helpers.

Author:

    Rita Wong (ritaw) 22-Feb-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>

#include <nwcanon.h>

#ifndef UNICODE
#define UNICODE
#endif

DWORD
TestCanonLocalName(
    IN LPWSTR LocalName,
    IN DWORD ExpectedError
    );

DWORD
TestCanonRemoteName(
    IN LPWSTR RemoteName,
    IN DWORD ExpectedError
    );

// BYTE WorkBuffer[1024];

void __cdecl
main(
    void
    )
{


    TestCanonLocalName(
        L"x:",
        NO_ERROR
        );

    TestCanonLocalName(
        L"B:",
        NO_ERROR
        );

    TestCanonLocalName(
        L"prn",
        NO_ERROR
        );

    TestCanonLocalName(
        L"lpt1:",
        NO_ERROR
        );

    TestCanonLocalName(
        L"*:",
        ERROR_INVALID_NAME
        );

    TestCanonLocalName(
        L"B",
        ERROR_INVALID_NAME
        );

    TestCanonLocalName(
        L"abc",
        ERROR_INVALID_NAME
        );

    TestCanonLocalName(
        L"\\:",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\:",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Ser:ver",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\*",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\:",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volume",
        NO_ERROR
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volume\\Dir1\\Directory2\\ALongDirectory3",
        NO_ERROR
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volume\\",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"Server\\Volume\\",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volu:me",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volume\\\\Dir",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server/Volume\\Dir",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server\\Volume:",
        ERROR_INVALID_NAME
        );

    TestCanonRemoteName(
        L"\\\\Server",
        ERROR_INVALID_NAME
        );

}


DWORD
TestCanonLocalName(
    IN LPWSTR LocalName,
    IN DWORD ExpectedError
    )
{
    DWORD status;
    DWORD OutputBufferLength;
    LPWSTR OutputBuffer;


    printf("\nCanon local name %ws\n", LocalName);

    status = NwLibCanonLocalName(
                 LocalName,
                 &OutputBuffer,
                 &OutputBufferLength
                 );

    if (status == NO_ERROR) {

        printf("   got %ws, length %lu\n", OutputBuffer, OutputBufferLength);

        (void) LocalFree((HLOCAL) OutputBuffer);
    }

    if (status == ExpectedError) {
        printf("   SUCCESS: Got %lu as expected\n", ExpectedError);

    }
    else {
        printf("   FAILED: Got %lu, expected %lu\n", status, ExpectedError);
    }
}


DWORD
TestCanonRemoteName(
    IN LPWSTR RemoteName,
    IN DWORD ExpectedError
    )
{
    DWORD status;
    DWORD OutputBufferLength;
    LPWSTR OutputBuffer;


    printf("\nCanon remote name %ws\n", RemoteName);

    status = NwLibCanonRemoteName(
                 RemoteName,
                 &OutputBuffer,
                 &OutputBufferLength
                 );

    if (status == NO_ERROR) {

        printf("   got %ws, length %lu\n", OutputBuffer, OutputBufferLength);

        (void) LocalFree((HLOCAL) OutputBuffer);
    }

    if (status == ExpectedError) {
        printf("   SUCCESS: Got %lu as expected\n", ExpectedError);

    }
    else {
        printf("   FAILED: Got %lu, expected %lu\n", status, ExpectedError);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\regacl.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    regacl.c

Abstract:

    This module contains the code for adding access permission ACL in a registry
    key.

Author:

    Terrence Kwan (terryk)   25-Sept-1993

Revision History:

--*/

#include <procs.h>

DWORD
NwLibSetEverybodyPermission(
    IN HKEY hKey,
    IN DWORD dwPermission
    )
/*++

Routine Description:

    Set the registry key to everybody "Set Value" (or whatever
    the caller want.)

Arguments:

    hKey - The handle of the registry key to set security on

    dwPermission - The permission to add to "everybody"

Return Value:

    The win32 error.

--*/
{
    LONG err;                           // error code
    PSECURITY_DESCRIPTOR psd = NULL;    // related SD
    PACL pDacl = NULL;                  // Absolute DACL
    PACL pSacl = NULL;                  // Absolute SACL
    PSID pOSid = NULL;                  // Absolute Owner SID
    PSID pPSid = NULL;                  // Absolute Primary SID

    do {  // Not a loop, just for breaking out of error
        //
        // Initialize all the variables...
        //
                                                        // world sid authority
        SID_IDENTIFIER_AUTHORITY SidAuth= SECURITY_WORLD_SID_AUTHORITY;
        DWORD cbSize=0;                                 // Security key size
        PACL pAcl;                                      // original ACL
        BOOL fDaclPresent;
        BOOL fDaclDefault;
        PSID pSid;                                      // original SID
        SECURITY_DESCRIPTOR absSD;                      // Absolute SD
        DWORD AbsSize = sizeof(SECURITY_DESCRIPTOR);    // Absolute SD size
        DWORD DaclSize;                                 // Absolute DACL size
        DWORD SaclSize;                                 // Absolute SACL size
        DWORD OSidSize;                                 // Absolute OSID size
        DWORD PSidSize;                                 // Absolute PSID size


        // Get the original DACL list

        RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION, NULL, &cbSize);

        psd = (PSECURITY_DESCRIPTOR *)LocalAlloc(LMEM_ZEROINIT, cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID));
        pDacl = (PACL)LocalAlloc(LMEM_ZEROINIT, cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID));
        pSacl = (PACL)LocalAlloc(LMEM_ZEROINIT, cbSize);
        pOSid = (PSID)LocalAlloc(LMEM_ZEROINIT, cbSize);
        pPSid = (PSID)LocalAlloc(LMEM_ZEROINIT, cbSize);
        DaclSize = cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID);
        SaclSize = cbSize;
        OSidSize = cbSize;
        PSidSize = cbSize;

        if (( NULL == psd) ||
            ( NULL == pDacl) ||
            ( NULL == pSacl) ||
            ( NULL == pOSid) ||
            ( NULL == pPSid))
        {
            err = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        if ( (err = RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION, psd, &cbSize )) != ERROR_SUCCESS )
        {
            break;
        }
        if ( !GetSecurityDescriptorDacl( psd, &fDaclPresent, &pAcl, &fDaclDefault ))
        {
            err = GetLastError();
            break;
        }

        // Increase the size for an extra ACE

        pAcl->AclSize += sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID);

        // Get World SID

        if ( (err = RtlAllocateAndInitializeSid( &SidAuth, 1,
              SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSid)) != ERROR_SUCCESS)
        {
            break;
        }

        // Add Permission ACE

        if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, dwPermission ,pSid))
        {
            err = GetLastError();
            break;
        }

        // Convert from relate format to absolute format

        if ( !MakeAbsoluteSD( psd, &absSD, &AbsSize, pDacl, &DaclSize, pSacl, &SaclSize,
                        pOSid, &OSidSize, pPSid, &PSidSize ))
        {
            err = GetLastError();
            break;
        }

        // Set SD

        if ( !SetSecurityDescriptorDacl( &absSD, TRUE, pAcl, FALSE ))
        {
            err = GetLastError();
            break;
        }
        if ( (err = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION, psd ))
              != ERROR_SUCCESS )
        {
            break;
        }

    } while (FALSE);

    // Clean up the memory

    LocalFree( psd );
    LocalFree( pDacl );
    LocalFree( pSacl );
    LocalFree( pOSid );
    LocalFree( pPSid );

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\msnwapi.h ===
/*****************************************************************/
/**               Microsoft Windows 4.00					**/
/**           Copyright (C) Microsoft Corp., 1994-1995	        **/
/*****************************************************************/

/*
 * Internal NetWare access API definitions for use by Windows components
 *
 * History
 *
 * 		vlads	12/15/94	Created
 * 		vlads	12/28/94	Added connection management  and authentication prototypes
 *
 *
 *
 */

#ifndef _INC_MSNWAPI
#define _INC_MSNWAPI

#include <msnwdef.h>
#include <msnwerr.h>

//
// We default to byte-packing
//
#include <pshpack1.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef IS_32
#define API_PREFNAME(name)	WINAPI Thk##name
#else
#ifdef DEFINE_INTERNAL_PREFIXES
#define API_PREFNAME(name)	I_##name
#else
#define API_PREFNAME(name)	WINAPI name
#endif
#endif

/*
 * Manifest constants
 *
 */

#define MAX_NDS_NAME_CHARS     256			// object names
#define MAX_NDS_NAME_BYTES     (2*(MAX_NDS_NAME_CHARS+1))
#define MAX_NDS_RDN_CHARS		128			// relative name component
#define MAX_NDS_RDN_BYTES		(2*(MAX_RDN_CHARS + 1))
#define MAX_NDS_TREE_CHARS		32			// tree name
#define MAX_NDS_SCHEMA_NAME_CHARS	32		// class, property names
#define MAX_NDS_SCHEMA_NAME_BYTES	(2*(MAX_NDS_SCHEMA_NAME_CHARS+1))
/*
 * Miscellaneous	APIs
 *
 */


NW_STATUS	NetWGetRequesterVersion(OUT LPBYTE majorVersion,
								    OUT LPBYTE minorVersion,
								    OUT LPBYTE revision);

/*
 * Global directory services context management
 *
 */

NW_STATUS	NDSSetNameContext(IN LPSTR NameContext, BOOL fGlobal);
NW_STATUS	NDSGetNameContext(OUT LPSTR NameContext, BOOL fGlobal);


/*
 * Connection management
 * ---------------------
 *
 *	NetWGetPreferredName	Get/Set preferred connection name, according to type 	
 *	NetWSetPreferredName	parameter.
 *
 *	NetWGetPreferredConnID	Establishes default connection to network resource and
 *							returns created connection handle
 *
 *	NetWAttachByName		Attach to resource by given name. For the tree this is equivalent
 *							to combination ofr SetPreferredName\GetPreferredConnID, but atomic
 *
 *	NetWAttachByAddress		Attaches to server by given address.
 *
 */

typedef enum _NETWARE_CONNECTION_TYPE {
	NETW_AnyType	= 0,
    NETW_BinderyServer,
    NETW_DirectoryServer

} NETWARE_CONNECTION_TYPE, *PNETWARE_CONNECTION_TYPE;


typedef struct _NETWARE_CONNECTION_INFO {
	NETWARE_CONNECTION_TYPE ConnType;
	WORD ConnFlags;		// see below
	WORD ServerConnNum;
	BYTE MajVer;
	BYTE MinVer;
	BYTE ServerAddress[12];		// IPX address of server
} NETWARE_CONNECTION_INFO, *PNETWARE_CONNECTION_INFO;

// ConnFlags values
#define CONN_AUTH_BIT	0
#define CONN_AUTH_FLAG	(1 << CONN_AUTH_BIT )
#define CONN_LOCKED_BIT 1
#define CONN_LOCKED_FLAG (1 << CONN_LOCKED_BIT)

#define CONN_NDS_NAME_BIT 2
#define CONN_NDS_NAME_FLAG (1 << CONN_NDS_NAME_BIT)

// TBD

typedef struct _NETWARE_CONNECTION_REMOTE_INFO {

	DWORD	dwF;

} NETWARE_CONNECTION_REMOTE_INFO, *PNETWARE_CONNECTION_REMOTE_INFO;



UINT
NetWGetNumConnEntries(
	VOID
	);


NW_STATUS
NetWGetPreferredName(
	IN 	NETWARE_CONNECTION_TYPE 	ConnectionType,
	OUT LPSTR  						pszBuf
	);

NW_STATUS
NetWSetPreferredName(
	IN 	NETWARE_CONNECTION_TYPE 	ConnectionType,
	IN 	LPSTR 						pszBuf
	);

NW_STATUS
NetWGetPreferredConnID(
	IN 	NETWARE_CONNECTION_TYPE 	ConnectionType,
	OUT	NWCONN_HANDLE *phConn
	);

NW_STATUS
NetWGetPrimaryConnection(
	OUT NWCONN_HANDLE *phConn
	);

NW_STATUS WINAPI
NetWSetPrimaryConnection(
	IN	NWCONN_HANDLE	hConn
	);

NW_STATUS
NetWAttachByName(
	IN	UINT						ConnFlags,		// if CONN_NDS_NAME_FLAG, try NDS
	IN	LPSTR  						pszResourceName,
	OUT PNWCONN_HANDLE				phConn
	);

NW_STATUS
NetWAttachByAddress(
	IN	PBYTE						pbAddress,
	OUT	PNWCONN_HANDLE				phConn
	);

NW_STATUS
NetWLookupConnection(
	IN	NETWARE_CONNECTION_TYPE		ConnectionType,
	IN OUT NWCONN_HANDLE			*phConn
	);

NW_STATUS
NetWGetConnectionLocalStatus(
	IN	NWCONN_HANDLE 				hConn,
	OUT	PNETWARE_CONNECTION_INFO	pConnInfo,
	OUT	LPSTR						pszResourceName
	);

NW_STATUS
NetWGetConnectionRemoteInformation(
	IN	NWCONN_HANDLE 				hConn,
	OUT	PNETWARE_CONNECTION_REMOTE_INFO	pConnInfo,
	OUT	LPSTR						pszResourceName
	);

NWCONN_HANDLE
NWREDIRToVLMHandle(BYTE connId);

BYTE
VLMToNWREDIRHandle(NWCONN_HANDLE hConn);

// returns 12 byte local net address
NW_STATUS
NetWGetLocalAddress(
	BYTE *buffer        // 12 bytes
	);

//
// For tree - cleans up all NDS connections , for server - just this one
//

NW_STATUS
NetWDetachResource(
	IN 	NETWARE_CONNECTION_TYPE 	ConnectionType,
	IN	NWCONN_HANDLE 				hConn
	);


NW_STATUS
NetWLicenseConnection(
	IN	NWCONN_HANDLE hConn
	);

NW_STATUS
NetWUnLicenseConnection(
	IN	NWCONN_HANDLE hConn
	);

/*
 * Authetication APIs
 * ------------------
 *
 *
 */

NW_STATUS
NDSIsLoggedIn(
	OUT	LPSTR	pszUserName
	);

NW_STATUS
NDSLogin(
	OUT	LPSTR						pszUserName,
	OUT	LPSTR						pszPassword
	);

NW_STATUS
NDSLogout(
	VOID
	);

NW_STATUS										
NDSAuthenticateToServer(
	IN	NWCONN_HANDLE 				hConn
	);

NW_STATUS WINAPI
NDSChangePassword(LPSTR pszUser, LPSTR pszOldPasswd, LPSTR pszNewPasswd);

// Bindery keyed change password
NW_STATUS WINAPI
NWChangeBinderyObjectPassword(
	NWCONN_HANDLE		hConn,
    LPCSTR  pObjectName,
    USHORT ObjectType,	// 0x100 for User
    LPCSTR  pOldPassword,	// upper-cased
    LPCSTR  pNewPassword	// upper-cased
    );

NW_STATUS WINAPI
NWChangeBinderyConnectionPassword(
	LPCSTR	pszResourceName,
	LPCSTR	pszLoggedInUser,
	LPCSTR	pszOldPassword,	
	LPCSTR	pszNewPassword
	);

NW_STATUS
NDSCanonicalizeName(
	IN	UINT flags,	// see below
	IN	LPSTR pszName,
	OUT	LPSTR pszCanonicalName
	);

#define FLAGS_TYPED_NAMES	1	// add/remove name component types (e.g. CN=)
#define FLAGS_NO_CONTEXT	2	// dont append/remove context
#define FLAGS_LOCAL_CONTEXT 4	// use local name context (not global)

NW_STATUS
NDSAbbreviateName(
	IN	UINT flags,
	IN	LPSTR pszCanonicalName,
	OUT	LPSTR pszAbbreviatedName
	);

/*
 *  Netware Directory Syntax IDs
 */

#define NDSI_DIST_NAME			1		// Distinguished Name
#define NDSI_CS_STRING			2		// Case sensitive string
#define NDSI_CI_STRING			3		// Case ignore string
#define NDSI_PRINT_STRING		4		// Printable string (subset of ASCII)
#define NDSI_NUM_STRING			5		// numeric string ('0' - '9' and space)
#define NDSI_CI_STRINGLIST		6		// list of case ignore strings
#define NDSI_BOOLEAN			7		// 0 or 1
#define NDSI_INTEGER			8		// signed 32 bit int
#define NDSI_BYTE_STRING		9		// raw octet string
#define NDSI_PHONE_NUMBER		10
#define NDSI_FAX_NUMBER			11
#define NDSI_NET_ADDRESS    	12		// typed network address
#define NDSI_BYTE_STRINGLIST 	13		// list of octet strings
#define NDSI_EMAIL_ADDRESS  	14
#define NDSI_FILE_PATH      	15
#define NDSI_ACL_ENTRY      	17		// NDS access control list
#define NDSI_POST_ADDRESS   	18		// upto 5 lines
#define NDSI_TIME_STAMP     	19
#define NDSI_CLASS_NAME     	20		// Object Class
#define NDSI_STREAM         	21		// read using file i/o
#define NDSI_COUNTER        	22		// similar to INTEGER
#define NDSI_TIME           	24		// time in secs since 0hrs 1/1/80


/*
 * Directory syntax types
 */
typedef DWORD OBJ_ID;

// Use PSTR for :NDSI_DIST_NAME, NDSI_CS_STRING, NDSI_CI_STRING, NDSI_PRINT_STRING, NDSI_NUM_STRING

typedef unsigned char DS_BOOLEAN;	//NDSI_BOOLEAN

typedef long DS_INT;      //NDSI_INTEGER, NDSI_COUNTER (32 bit signed int)

typedef unsigned long DS_TIME;  //NDSI_TIME (32 bit unsigned)

// NDSI_NET_ADDRESS
typedef struct {
    UINT addrType;		// see below
    UINT addrLen;
    BYTE *addr;     // addrLength bytes of data
} DS_NET_ADDRESS;

// values for addrType
#define NETADDR_IPX		0
#define NETADDR_IP		1
#define NETADDR_SDLC	2
#define NETADDR_ETHERNET_TOKENRING	3
#define NETADDR_OSI		4

// NDSI_EMAIL_ADDRESS
typedef struct {
    UINT addrType;
    LPSTR addr;      // e-mail address
} DS_EMAIL_ADDRESS;

// NDSI_CI_STRINGLIST
typedef struct {
	struct _dsStringList	*next;
	LPSTR	string;
} DS_CI_STRINGLIST;

//NDSI_BYTE_STRING
typedef struct {
    UINT strLen;
    BYTE *data;     // strLen bytes
} DS_BYTE_STRING;

// NDSI_FILE_PATH
typedef struct {
    UINT nameSpace;
    LPSTR volume;
    LPSTR path;
} DS_FILE_PATH;

//NDSI_FAX_NUMBER
typedef struct {
	LPSTR number;
	UINT bitCount;
	UINT parameters;
} DS_FAX_NUMBER;

// values for nameSpace:
//
#define NAMESPACE_DOS		0
#define	NAMESPACE_MAC		1
#define	NAMESPACE_UNIX		2
#define NAMESPACE_FTAM		3
#define NAMESPACE_OS2		4

typedef struct {
	CHAR objectName[MAX_NDS_NAME_CHARS+1];	// canonical name of object
	OBJ_ID entryId;		// NDS internal object Id
	ULONG flags;		// see below
	UINT subordinateCount;	// number of children (if this is a container)
	char className[MAX_NDS_SCHEMA_NAME_CHARS+1];		// e.g. "User"
} DS_OBJ_INFO;

// values for DS_OBJ_INFO flags:
//
//
// Object flags
//

#define	DS_CONTAINER	0x4
#define	DS_ALIAS		0x1
#define NDSOBJ_ALIAS_FLAG		0x1
#define NDSOBJ_PARTITION_FLAG	0x2		// partition root
#define NDSOBJ_CONTAINER_FLAG	0x4		// container object

//
// NDS Class and attributes names
//

#define DSCL_TOP						"Top"
#define DSCL_ALIAS	                    "Alias"
#define DSCL_COMPUTER                   "Computer"
#define DSCL_COUNTRY                    "Country"
#define DSCL_DIRECTORY_MAP				"Directory Map"	
#define DSCL_GROUP						"Group"
#define DSCL_NCP_SERVER					"NCP Server"
#define DSCL_ORGANIZATION				"Organization"
#define DSCL_ORGANIZATIONAL_PERSON      "Organizational Person"
#define DSCL_ORGANIZATIONAL_ROLE        "Organizational Role"
#define DSCL_ORGANIZATIONAL_UNIT        "Organizational Unit"
#define DSCL_PRINTER                    "Printer"
#define DSCL_PRINT_SERVER               "Print Server"
#define DSCL_PROFILE	                "Profile"
#define DSCL_QUEUE		                "Queue"
#define DSCL_SERVER		                "Server"
#define DSCL_UNKNOWN	                "Unknown"
#define DSCL_USER		                "User"
#define DSCL_VOLUME		                "Volume"


#define DSAT_ALIASED_OBJECT_NAME		"Aliased Object Name"
#define DSAT_BINDERY_PROPERTY			"Bindery Property"
#define DSAT_BINDERY_OBJECT_RESTRICTION		"Bindery Object Restriction"
#define DSAT_BINDERY_TYPE		        "Bindery Type"
#define DSAT_COMMON_NAME		        "CN"
#define DSAT_COUNTRY_NAME		        "C"
#define DSAT_DEFAULT_QUEUE		        "Default Queue"
#define DSAT_DESCRIPTION		 	    "Description"
#define DSAT_HOME_DIRECTORY			    "Home Directory"
#define DSAT_HOST_DEVICE			    "Host Device"
#define DSAT_HOST_RESOURCE_NAME		    "Host Resource Name"
#define DSAT_HOST_SERVER			    "Host Server"
#define DSAT_LOGIN_ALLOWED_TIME_MAP	    "Login Allowed Time Map"
#define DSAT_LOGIN_DISABLED				"Login Disabled"
#define DSAT_LOGIN_EXPIRATION_TIME		"Login Expiration Time"
#define DSAT_LOGIN_GRACE_LIMIT			"Login Grace Limit"
#define DSAT_LOGIN_GRACE_REMAINING		"Login Grace Remaining"
#define DSAT_LOGIN_INTRUDER_ADDRESS		"Login Intruder Address"
#define DSAT_LOGIN_INTRUDER_ATTEMPTS	"Login Intruder Attempts"
#define DSAT_LOGIN_INTRUDER_LIMIT		"Login Intruder Limit"
#define DSAT_INTRUDER_ATTEMPT_RESET_INTRVL	"Intruder Attempt Reset Interval"
#define DSAT_LOGIN_INTRUDER_RESET_TIME	"Login Intruder Reset Time"
#define DSAT_LOGIN_MAXIMUM_SIMULTANEOUS	"Login Maximum Simultaneous"
#define DSAT_LOGIN_SCRIPT				"Login Script"
#define DSAT_LOGIN_TIME					"Login Time"
#define DSAT_MINIMUM_ACCOUNT_BALANCE	"Minimum Account Balance"
#define DSAT_MEMBER						"Member"
#define DSAT_EMAIL_ADDRESS				"EMail Address"
#define DSAT_NETWORK_ADDRESS			"Network Address"
#define DSAT_NETWORK_ADDRESS_RESTRICTION		"Network Address Restriction"
#define DSAT_OBJECT_CLASS				"Object Class"
#define DSAT_OPERATOR					"Operator"
#define DSAT_ORGANIZATIONAL_UNIT_NAME	"OU"
#define DSAT_ORGANIZATION_NAME			"O"
#define DSAT_OWNER						"Owner"
#define DSAT_PASSWORDS_USED				"Passwords Used"
#define DSAT_PASSWORD_ALLOW_CHANGE		"Password Allow Change"
#define DSAT_PASSWORD_EXPIRATION_INTERVAL		"Password Expiration Interval"
#define DSAT_PASSWORD_EXPIRATION_TIME	"Password Expiration Time"
#define DSAT_PASSWORD_MINIMUM_LENGTH	"Password Minimum Length"
#define DSAT_PASSWORD_REQUIRED			"Password Required"
#define DSAT_PASSWORD_UNIQUE_REQUIRED		"Password Unique Required"
#define DSAT_PATH						"Path"
#define DSAT_PRINT_JOB_CONFIGURATION	"Print Job Configuration"
#define DSAT_PRINTER_CONTROL			"Printer Control"
#define DSAT_PROFILE					"Profile"
#define DSAT_QUEUE						"Queue"
#define DSAT_QUEUE_DIRECTORY			"Queue Directory"
#define DSAT_SERVER						"Server"
#define DSAT_STATE_OR_PROVINCE_NAME		"S"
#define DSAT_STATUS						"Status"
#define DSAT_UNKNOWN					"Unknown"
#define DSAT_USER						"User"
#define DSAT_VERSION					"Version"
#define DSAT_GROUP_MEMBERSHIP			"Group Membership"
#define DSAT_DEVICE						"Device"
#define DSAT_MESSAGE_SERVER				"Message Server"
#define DSAT_LANGUAGE					"Language"
#define DSAT_QUEUE_TYPE					"Queue Type"
#define DSAT_SUPPORTED_CONNECTIONS		"Supported Connections"
#define DSAT_UNKNOWN_OBJECT_RESTRICTION	"Unknown Object Restriction"
#define DSAT_LOCKED_BY_INTRUDER			"Locked By Intruder"
#define DSAT_PRINTER					"Printer"
#define DSAT_DETECT_INTRUDER			"Detect Intruder"
#define DSAT_LOCKOUT_AFTER_DETECTION	"Lockout After Detection"
#define DSAT_INTRUDER_LOCKOUT_RESET_INTRVL	"Intruder Lockout Reset Interval"
#define DSAT_SERVER_HOLDS				"Server Holds"
#define DSAT_SAP_NAME					"SAP Name"
#define DSAT_VOLUME						"Volume"
#define DSAT_LAST_LOGIN_TIME	 		"Last Login Time"
#define DSAT_PRINT_SERVER				"Print Server"
#define DSAT_ACCOUNT_BALANCE			"Account Balance"
#define DSAT_ALLOW_UNLIMITED_CREDIT		"Allow Unlimited Credit"
#define DSAT_LOCALE						"L"
#define DSAT_POSTAL_CODE				"Postal Code"
#define DSAT_POSTAL_OFFICE_BOX			"Postal Office Box"
#define DSAT_SECURITY_EQUALS			"Security Equals"
#define DSAT_SURNAME					"Surname"
#define	DSAT_FULL_NAME					"Full Name"
#define DSAT_TITLE						"Title"
#define DSAT_TELEPHONE_NUMBER			"Telephone Number"
#define	DSAT_ADMIN_ASSISTANT			"Administrative Assistant"
#define DSAT_EMPLOYEE_ID				"Employee ID"
#define	DSAT_FAX_NUMBER					"Facsimile Telephone Number"
#define	DSAT_HIGHER_PRIVILEGES			"Higher Privileges"
#define	DSAT_INITIALS					"Initials"
#define	DSAT_LOCKED_BY_INTRUDER			"Locked By Intruder"
#define	DSAT_LOGIN_DISABLED				"Login Disabled"
#define	DSAT_LOGIN_GRACE_LIMIT			"Login Grace Limit"
#define DSAT_LOGIN_GRACE_REMAINING		"Login Grace Remaining"
#define DSAT_LOGIN_MAXIMUM_SIMULTANEOUS	"Login Maximum Simultaneous"
#define	DSAT_MAILSTOP					"Mailstop"
#define DSAT_MINIMUM_ACCOUNT_BALANCE	"Minimum Account Balance"
#define	DSAT_OBJECT_CLASS				"Object Class"
#define	DSAT_OU							"OU"
#define	DSAT_PASSWORDS_USED				"Passwords Used"
#define	DSAT_PHYSICAL_DELIVERY_OFFICE_NAME	"Physical Delivery Office Name"
#define	DSAT_POSTAL_ADDRESS				"Postal Address"
#define	DSAT_PRIVATE_KEY				"Private Key"
#define	DSAT_REVISION					"Revision"
#define	DSAT_SECURITY_FLAGS				"Security Flags"
#define	DSAT_SEE_ALSO					"See Also"
#define DSAT_SERVER_HOLDS				"Server Holds"
#define	DSAT_SUPERVISOR					"Supervisor"
#define DSAT_SA							"SA"
#define	DSAT_S							"S"
#define	DSAT_VALIDITY_INTERVAL			"Certificate Validity Interval"
#define	DSAT_EQUIVALENT_TO_ME			"Equivalent To Me"
#define	DSAT_GENERATIONAL_QUALIFIER		"Generational Qualifier"
#define	DSAT_GIVEN_NAME					"Given Name"
#define DSAT_MAILBOX_ID					"Mailbox ID"
#define	DSAT_MAILBOX_LOCATION			"Mailbox Location"
#define	DSAT_PROFILE_MEMBERSHIP			"Profile Membership"


#define	DSAT_MS_SYS_FLAGS				"MS System Flags"
#define	DSAT_MS_SYSPOLICIES_PATH		"MS System Policies"

#define	DSAT_RIGHTS_QUERYSTRING			"[Entry Rights]"

#define	MSSYS_NDS_ENABLED_POLICIES		0x0001

//
// Object rights
//

#define NDS_BROWSE_OBJ		0x1
#define NDS_CREATE_OBJ		0x2
#define NDS_DELETE_OBJ		0x4
#define NDS_RENAME_OBJ		0x8
#define NDS_SUPERVISE_OBJ	0x10

//
// Attribute rights
//
#define NDS_COMPARE_ATTR	0x1
#define NDS_READ_ATTR		0x2
#define NDS_WRITE_ATTR		0x4
#define NDS_ADD_SELF_ATTR	0x8
#define NDS_MANAGED_ATTR	0x10
#define NDS_SUPERVISE_ATTR	0x20


/*
 * Directory browsing APIs
 * -----------------------
 *
 */

NW_STATUS
NDSGetObjectInfo(	
	IN	LPCSTR	lpszObjectName,
	IN OUT DS_OBJ_INFO *pObjInfo	
	);							

NW_STATUS
NDSGetObjectInfoWithId(
    IN NWCONN_HANDLE hConn,     // server to query
	IN  DWORD	dwObjectId,		// objectId
	IN OUT DS_OBJ_INFO *pObjInfo);	

NW_STATUS
NDSGetObjectId(
    IN NWCONN_HANDLE hConn,     // server to query
    IN LPCSTR szName,           // DS object name
    OUT DWORD *pObjId);         // objectId

NW_STATUS
NDSListSubordinates(
	IN LPCSTR ParentName,		// canonical name of parent object
	OUT PVOID ReplyBuf,			// user supplied buffer
	IN UINT  ReplyBufLength,	// buffer length
	IN OUT PUINT phIteration,	// returned value used for subsequent requests
	OUT PUINT pNumObjects		// number of objects returned
	);

NW_STATUS
NDSListNextObject(
	IN PVOID ReplyBuf,			// filled in by NDSListSubordinates
	OUT DS_OBJ_INFO *pObjInfo	// fields describe the object
	);

NW_STATUS
NDSSearch(
	IN LPCSTR ParentName,		// context of search
	IN UINT depth,				// scope
	IN LPCSTR srchString,		// matching condition
	IN LPVOID *pArgList,		// list of parameters referenced by srchString
	IN UINT numArgs,
	OUT PVOID ReplyBuf,	// user supplied buffer
	IN UINT  ReplyBufLength,	// buffer length
	IN OUT UINT *pIterationHandle,	// returned value used for subsequent requests
	OUT PUINT pNumObjects	// number of objects returned
	);

NW_STATUS
NDSReadAttributes(
	IN LPCSTR ObjectName,	// canonical name of object
	IN LPCSTR AttribName,	// attribute Name e.g. "Surname"
	IN PVOID ReplyBuf,		// user supplied buffer
	IN UINT ReplyBufLength,	// length of buffer
	IN OUT PUINT phIteration,	// returned value used for subsequent requests
	OUT PUINT pNumValues,	// number of values read (on exit)
	OUT PUINT pSyntaxId		// syntax id of value (on exit)
	);

NW_STATUS
NDSReadNextValue(
	IN PVOID 	ReplyBuf,	// filled in earlier by NDSReadAttributes
	OUT PVOID 	pValue,	// user allocated buffer, typed according to syntax id
	IN	UINT ValueLength	// size of memory pointed to by pValue
	);

typedef enum {
	SA_Read = 1,
	SA_Write,
	SA_Read_Write
} STREAM_ACCESS;
	

NW_STATUS
NDSOpenStream(
	IN LPCSTR ObjectName,
	IN LPCSTR AttribName,
	IN STREAM_ACCESS Access,
	OUT HANDLE *pFileHandle,
	OUT PUINT pFileLength
	);

NW_STATUS
NDSGetEffectiveRights(
	IN LPCSTR SubjectName,
	IN LPCSTR ObjectName,
	IN LPCSTR AttribName,
	OUT UINT *pRights
	);

NW_STATUS NDSModifyAttribute(
	IN LPCSTR ObjectName,
	IN LPCSTR AttribName,
	IN UINT operation,	// see below
	IN UINT syntaxId,	// of attribute
	IN PVOID pValueList, // list of arguments (PSTRs, DS_INTs, DS_BYTE_STRINGs etc.)
	IN UINT  numValues	// # of values
	);

// Modify attribute operations

#define ADD_ATTRIB			0
#define REMOVE_ATTRIB		1
#define ADD_ATTRIB_VALUE 	2
#define REMOVE_ATTRIB_VALUE	3
#define APPEND_ATTRIB_VALUE	4
#define OVERWRITE_ATTRIB_VALUE 5
#define CLEAR_ATTRIB		6
#define CLEAR_ATTRIB_VALUE	7

NW_STATUS NDSDefineAttribute(
	IN LPCSTR AttribName,
	IN UINT syntaxId,
	IN UINT flags,	// see Attribute flags
	IN LONG lowerLimit,
	IN LONG upperLimit,
	IN PVOID asn1Id			// NULL for now
	);

// Attribute flags

#define ATTRIB_ENTRY_ID		0x1
#define ATTRIB_SIZED		0x2
#define ATTRIB_PERMANENT 	0x4
#define ATTRIB_READ_ONLY	0x8
#define ATTRIB_HIDDEN		0x10
#define ATTRIB_STRING		0x20
#define ATTRIB_SYNC_IMMED	0x40
#define ATTRIB_PUBLIC_READ	0x80
#define ATTRIB_SERVER_ONLY	0x100
#define ATTRIB_WRITE_MANAGED 0x200
#define ATTRIB_PER_REPLICA	0x400

NW_STATUS NDSAddAttributeToClass(
	IN LPCSTR ClassName,
	IN LPCSTR AttribName
	);

//
// System NetWare notification codes . Those are used to inform NP about various
// NetWare related events ( like completion of login script processing)
//
typedef	UINT	NW_SYS_EVENT;

typedef DWORD WINAPI	F_NPNotifyNetworkEvent(HWND,NW_SYS_EVENT,DWORD);
typedef F_NPNotifyNetworkEvent	*PF_NPNotifyNetworkEvent;

BOOL	PrepareNetWareRunTime(HWND	hWnd);
BOOL	FreeNetWareRunTime(VOID);

NW_STATUS
NWMakeRunTimeInitCalls(VOID);

NW_STATUS
NWMakeRunTimeTerminateCalls(VOID);

#define	NW_SE_SCRIPTS_COMPLETED		0x0001

#ifdef __cplusplus
}
#endif	/* __cplusplus */

//
// Restore packing setup
//

#include <poppack.h>


#endif  /* !_INC_MSNWAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\nds32w95.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nds32W95.c

Abstract:

    This module implements functions to Read, Add, Modify, and Remove
    NDS Objects and Attributes using the Microsoft Netware redirector.
    All functions in this file are NT specific.
    
Author:

    Glenn Curtis    [GlennC]    04-Jan-1996
    Glenn Curtis    [GlennC]    24-Apr-1996 - Added schema APIs
    Glenn Curtis    [GlennC]    20-Jun-1996 - Added search API
    Felix Wong      [t-felixw]  24-Sep-1996 - Added Win95 Support
--*/

#include <procs.h>

#ifdef WIN95
#include <msnwapi.h>
#include <utils95.h>
#include <nw95.h>
char ROOT_STR[] = "[Root]";
#endif

typedef struct
{
    DWORD      Signature;
    HANDLE     NdsTree;
    DWORD      ObjectId;
    DWORD      ResumeId;
    DWORD      NdsRawDataBuffer;
    DWORD      NdsRawDataSize;
    DWORD      NdsRawDataId;
    DWORD      NdsRawDataCount;
    WCHAR      Name[1];

} NDS_OBJECT, * LPNDS_OBJECT;

//
// Flags used for the function ParseNdsUncPath()
//
#define  PARSE_NDS_GET_TREE_NAME    0
#define  PARSE_NDS_GET_PATH_NAME    1
#define  PARSE_NDS_GET_OBJECT_NAME  2


WORD
ParseNdsUncPath( IN OUT LPWSTR * Result,
                 IN     LPWSTR   ObjectPathName,
                 IN     DWORD    flag );

DWORD
GetFirstNdsSubTreeEntry(
    OUT LPNDS_OBJECT lpNdsObject,
    IN  DWORD BufferSize )
{
    UNICODE_STRING UName;
    LPSTR   szName;
    struct _nds_tag *pBufTag;
    PBYTE LocalBuffer;
    UINT nObjects;
    DWORD* pBuffer;
    NW_STATUS nwstatus;
    NTSTATUS ntstatus = STATUS_UNSUCCESSFUL;
    lpNdsObject->NdsRawDataSize = BufferSize;
    //
    // Determine size of NDS raw data buffer to use. Set to at least 8KB.
    //
    if ( lpNdsObject->NdsRawDataSize < 8192 )
        lpNdsObject->NdsRawDataSize = 8192;

    //
    // Create NDS raw data buffer.
    //
    lpNdsObject->NdsRawDataBuffer = (DWORD) LocalAlloc( LMEM_ZEROINIT,
                                                     lpNdsObject->NdsRawDataSize );
    LocalBuffer = (PBYTE)LocalAlloc( LMEM_ZEROINIT,lpNdsObject->NdsRawDataSize ); 

    if ( lpNdsObject->NdsRawDataBuffer == 0 || LocalBuffer == 0)
    {
        KdPrint(("NWWORKSTATION: NwGetFirstNdsSubTreeEntry LocalAlloc Failed %lu\n", GetLastError()));
        ntstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    //
    // Set up to get initial NDS subordinate list.
    //
    lpNdsObject->NdsRawDataId = INITIAL_ITERATION;
    
    RtlInitUnicodeString( &UName, lpNdsObject->Name );

    UName.Length = ParseNdsUncPath( (LPWSTR *) &UName.Buffer,
                                         lpNdsObject->Name,
                                         PARSE_NDS_GET_PATH_NAME );
    
    if ( UName.Length == 0 )
    {
        szName = (LPSTR)LocalAlloc( LPTR, sizeof(char) * (strlen(ROOT_STR) + 1));
        if (szName == NULL) {
            ntstatus = STATUS_NO_MEMORY;
            goto Exit;
        };
        strcpy(szName,ROOT_STR);
    }
    else
    {
        szName = AllocateAnsiString(UName.Buffer);
        if (szName == NULL) {
            ntstatus = STATUS_NO_MEMORY;
            goto Exit;
        };
    }
    
    nwstatus = NDSListSubordinates(
                                szName,
                                LocalBuffer,     
                                lpNdsObject->NdsRawDataSize,
                                &lpNdsObject->NdsRawDataId,
                                &nObjects
                                );
    ntstatus = MapNwToNtStatus(nwstatus);
    
    if ( ntstatus == STATUS_SUCCESS) {
        pBufTag = (struct _nds_tag *)LocalBuffer;
        pBuffer = (DWORD*)lpNdsObject->NdsRawDataBuffer;
        *pBuffer++ = (DWORD)ntstatus;
        *pBuffer++ = (DWORD)lpNdsObject->NdsRawDataId;
        *pBuffer++ = (DWORD)nObjects;
        memcpy( (LPBYTE)pBuffer,
                (char *)pBufTag->nextItem,
                pBufTag->bufEnd - (char *)pBufTag->nextItem);
        if (((PNDS_RESPONSE_SUBORDINATE_LIST)
            lpNdsObject->NdsRawDataBuffer)->SubordinateEntries != 0 ) {
            lpNdsObject->NdsRawDataCount = ((PNDS_RESPONSE_SUBORDINATE_LIST)
                                               lpNdsObject->NdsRawDataBuffer)->SubordinateEntries - 1;
        
            lpNdsObject->ResumeId = lpNdsObject->NdsRawDataBuffer +
                                      sizeof(NDS_RESPONSE_SUBORDINATE_LIST);
            // Successful exit
            goto Exit;
        }
    }
    // No entries
    lpNdsObject->NdsRawDataBuffer = 0;
    lpNdsObject->NdsRawDataSize = 0;
    lpNdsObject->NdsRawDataId = INITIAL_ITERATION;
    lpNdsObject->NdsRawDataCount = 0;
    lpNdsObject->ResumeId = 0;
    ntstatus = STATUS_NO_MORE_ENTRIES;
Exit:
    if (szName)
        LocalFree(szName);
    if (LocalBuffer)
        LocalFree(LocalBuffer);
    if (ntstatus != STATUS_SUCCESS) {
        if ( lpNdsObject->NdsRawDataBuffer )
            (void) LocalFree( (HLOCAL) lpNdsObject->NdsRawDataBuffer );
    }
    
    return RtlNtStatusToDosError(ntstatus);
}


DWORD
GetNextNdsSubTreeEntry(
    OUT LPNDS_OBJECT lpNdsObject )
{
    NTSTATUS nwstatus;
    NTSTATUS ntstatus = STATUS_SUCCESS;
    struct _nds_tag *pBufTag;
    PBYTE pbRaw;
    DWORD dwStrLen;
    LPSTR szName;
    UINT nObjects;
    DWORD *pBuffer;

    if ( lpNdsObject->NdsRawDataCount == 0 &&
         lpNdsObject->NdsRawDataId == INITIAL_ITERATION )
        return WN_NO_MORE_ENTRIES;

    if ( lpNdsObject->NdsRawDataCount == 0 &&
         lpNdsObject->NdsRawDataId != INITIAL_ITERATION )
    {
        PBYTE LocalBuffer;
        UNICODE_STRING UName;
        
        LocalBuffer = (PBYTE) LocalAlloc( LMEM_ZEROINIT,lpNdsObject->NdsRawDataSize ); 
        if ( lpNdsObject->NdsRawDataBuffer == 0 || LocalBuffer == 0)
        {
            KdPrint(("NWWORKSTATION: NwGetFirstNdsSubTreeEntry LocalAlloc Failed %lu\n", GetLastError()));
            ntstatus = STATUS_NO_MEMORY;
            goto Exit;
        }
        
        RtlInitUnicodeString( &UName, lpNdsObject->Name );
    
        UName.Length = ParseNdsUncPath( (LPWSTR *) &UName.Buffer,
                                             lpNdsObject->Name,
                                             PARSE_NDS_GET_PATH_NAME );
        
        if ( UName.Length == 0 )
        {
            szName = (LPSTR)LocalAlloc( LPTR, sizeof(char) * (strlen(ROOT_STR) + 1));
            if (szName == NULL) {
                ntstatus = STATUS_NO_MEMORY;
                goto Exit;
            };
            strcpy(szName,ROOT_STR);
        }
        else
        {
            szName = AllocateAnsiString(UName.Buffer);
            if (szName == NULL) {
                ntstatus = STATUS_NO_MEMORY;
                goto Exit;
            };
        }
        
        nwstatus = NDSListSubordinates(
                                    szName,
                                    (LPBYTE)LocalBuffer,     
                                    lpNdsObject->NdsRawDataSize,
                                    &lpNdsObject->NdsRawDataId,
                                    &nObjects
                                    );
        ntstatus = MapNwToNtStatus(nwstatus);
        
        if (ntstatus == STATUS_SUCCESS) {
            pBufTag = (struct _nds_tag *)LocalBuffer;
            pBuffer = (DWORD*)lpNdsObject->NdsRawDataBuffer;
            *pBuffer++ = (DWORD)ntstatus;
            *pBuffer++ = (DWORD)lpNdsObject->NdsRawDataId;
            *pBuffer++ = (DWORD)nObjects;
            memcpy( (LPBYTE)pBuffer,
                    (char *)pBufTag->nextItem,
                    pBufTag->bufEnd - (char *)pBufTag->nextItem);
            lpNdsObject->NdsRawDataCount = ((PNDS_RESPONSE_SUBORDINATE_LIST)
                                               lpNdsObject->NdsRawDataBuffer)->SubordinateEntries - 1;
    
            lpNdsObject->ResumeId = lpNdsObject->NdsRawDataBuffer +
                                      sizeof(NDS_RESPONSE_SUBORDINATE_LIST);
        }
Exit:   
        if (LocalBuffer)
            LocalFree(LocalBuffer);
        if (szName)
            LocalFree(szName);
        if (ntstatus != STATUS_SUCCESS)
        {
            if ( lpNdsObject->NdsRawDataBuffer )
                (void) LocalFree( (HLOCAL) lpNdsObject->NdsRawDataBuffer );
            lpNdsObject->NdsRawDataBuffer = 0;
            lpNdsObject->NdsRawDataSize = 0;
            lpNdsObject->NdsRawDataId = INITIAL_ITERATION;
            lpNdsObject->NdsRawDataCount = 0;
            return WN_NO_MORE_ENTRIES;
        }
        return RtlNtStatusToDosError(ntstatus);
    }

    lpNdsObject->NdsRawDataCount--;

    //
    // Move pointer past the fixed header portion of a
    // NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    pbRaw = (BYTE *) lpNdsObject->ResumeId;
    pbRaw += sizeof(NDS_RESPONSE_SUBORDINATE_ENTRY);

    //
    // Move pointer past the length value of the Class Name string
    // of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    dwStrLen = * (DWORD *) pbRaw;
    pbRaw += sizeof(DWORD);

    //
    // Move pointer past the Class Name string of a
    // NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    pbRaw += ROUNDUP4( dwStrLen );

    //
    // Move pointer past the length value of the Object Name string
    // of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    dwStrLen = * (DWORD *) pbRaw;
    pbRaw += sizeof(DWORD);

    lpNdsObject->ResumeId = (DWORD) ( pbRaw + ROUNDUP4( dwStrLen ) );

    return RtlNtStatusToDosError(ntstatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\nds95.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nds95.h

Abstract:

    Originally nds.h in WIN95 redirector's source, renamed to nds95.h due to 
    name conflict.
    Win95 header for nds services.
    
Author:

    Felix Wong (t-felixw)    27-Sep-1996

Environment:


Revision History:


--*/
/*
 *      Netware Directory Services structures
 */


#define DUMMY_ITER_HANDLE ((unsigned long) 0xffffffff)

#define ENTRY_INFO_NAME_ONLY    0
#define ENTRY_INFO_NAME_VALUE   1
#define ENTRY_INFO_EFF_RIGHTS   2

#define MAX_NDS_NAME_CHARS      256
#define MAX_NDS_NAME_SIZE       (MAX_NDS_NAME_CHARS*2)
typedef DWORD DS_ENTRY_ID;
typedef DWORD NDS_TIME;

/*
typedef struct {
    DWORD length;
    WORD text[];
} NDS_STRING;

typedef struct {
    DWORD syntaxId;
    NDS_STRING attribName;
    DWORD numValues;
    BYTE attribData[];
} ATTRIB;
*/

typedef struct {
    BYTE  subFunction;
    DWORD fragHandle;
    DWORD maxFragSize;
    DWORD messageSize;
    DWORD fragFlags;
    DWORD verb;
    DWORD replyBufSize;
} FRAG_REQ_HEADER;

typedef struct {
        DWORD fragSize;
        DWORD fragHandle;
} FRAG_REPLY_HEADER;


#define NDSV_RESOLVE_NAME 1
typedef struct {
    DWORD version;
    DWORD flags;    // see below
    DWORD scope;
    //NDS_STRING targetName;
    // struct {
    //    DWORD length = 1;
    //    DWORD value = 0;
    //  } transportType;
    //  struct {
    //  DWORD length = 1;
    //  DWORD value = 0;
    //} treeWalkerType;
} REQ_RESOLVE_NAME;

// values for RESOLVE_NAME request flags
//
#define RSLV_DEREF_ALIASES  0x40
#define RSLV_READABLE       0x02
#define RSLV_WRITABLE       0x04
#define RSLV_WALK_TREE      0x20
#define RSLV_CREATE_ID      0x10
#define RSLV_ENTRY_ID       0x1


typedef struct {
    DWORD ccode;
    DWORD remoteEntry;
    DS_ENTRY_ID entryId;
    DWORD cServers;
    DWORD addrType;
    DWORD addrLength;
    //BYTE addr[addrLength];
} REPLY_RESOLVE_NAME;

#define NDSV_READ_ENTRY_INFO 2

typedef struct {
        DWORD version;
        DWORD entryId;
} REQ_READ_ENTRY_INFO;

typedef struct {
        DWORD ccode;
    DWORD flags;
    DWORD subCount;
        DWORD modTime;
        //NDS_STRING BaseClass;
        //NDS_STRING EntryName;
} REPLY_READ_ENTRY_INFO;

#define  NDSV_READ  3
typedef struct {
    DWORD version;
    DWORD iterationHandle;
    DWORD entryId;
    DWORD infoType;
    DWORD allAttribs;
    DWORD numAttribs;
    //NDS_STRING attribNames[];
} REQ_READ;

typedef struct {
    DWORD ccode;
    DWORD iterationHandle;
    DWORD infoType;
    DWORD numAttribs;
    //ATTRIB attribs[];
} REPLY_READ;

#define NDSV_LIST 5

typedef struct {
    DWORD version;
    DWORD flags;
    DWORD iterationHandle;
    DWORD parentEntryId;
} REQ_LIST;

typedef struct {
    DWORD ccode;
    DWORD iterationHandle;
    DWORD numEntries;
    // struct {
    //  DWORD entryId;
    //  DWORD flags;
    //  DWORD subCount;
    //  DWORD modTime;
    //  NDS_STRING BaseClass;
    //  NDS_STRING entryName;
    // } [];
} REPLY_LIST;

#define NDSV_SEARCH     6
typedef struct {
        DWORD version;  // 2
        DWORD flags;    // 0x10000
        DWORD iterationHandle;
        DWORD baseEntryId;
        DWORD scope;
        DWORD numNodes;
        DWORD infoType;
        DWORD allAttribs;
        DWORD numAttribs;
        // Search clause
} REQ_SEARCH;

typedef struct {
        DWORD ccode;
        DWORD iterationHandle;
        DWORD nodesSearched;
        DWORD infoType;
        DWORD searchLength;
        DWORD numEntries;
} REPLY_SEARCH;

#define NDSV_MODIFY_ATTRIB 9
typedef struct {
        DWORD version;  // = 0
        DWORD flags;
        DWORD entryId;  // object
        DWORD Count;    // of changes
//      struct {
//              DWORD modifyType;
//              NDS_STRING attribName;
//              DWORD numValues;
//              ATTRIB attribValues[];
//      } Changes[];
} REQ_MODIFY_ATTRIB;

#define NDSV_DEFINE_ATTRIB 11
typedef struct {
        DWORD version;  // = 0
        DWORD AttribFlags;
//      NDS_STRING AttribName;
//      DWORD syntaxId;
//      DWORD lower;
//      DWORD upper;
//      DWORD asn1IdLength;
//      BYTE asn1Id[asn1IdLength];
} REQ_DEFINE_ATTRIB;

#define NDSV_MODIFY_CLASS       16

#define NDSV_GET_EFF_RIGHTS 19


#define NDSV_OPEN_STREAM 27

typedef struct {
        DWORD version;
        DWORD flags;
        DWORD entryId;
        // NDS_STRING AttribName;
} REQ_OPEN_STREAM;

typedef struct {
        DWORD ccode;
        DWORD hNWFile;
        DWORD fileLength;
} REPLY_OPEN_STREAM;

#define NDSV_GET_SERVER_ADDRESS 53
typedef struct {
    DWORD syntaxId;     // = 9 (OCTET STRING)
    struct {
        DWORD nameLength;
        WORD name[11];    // "Public Key"
        WORD filler;
    } attribName;
    DWORD entries;  // = 1
    DWORD totalLength;  // of attribute value OCTET STRING
    DWORD unknown1;  // =1
    DWORD unknown2;  // = 4
    WORD _issuerDNLength;
    WORD totalDNLength;
    WORD length2;
    WORD length3;
    WORD issuerDNLength;
    WORD userDNLength;
    WORD bsafeSectionLength;
    DWORD length4;
    //WORD issuerDN[];
    //WORD userDN[];
    //DWORD unknown3;
    //DWORD unknown4;
    // WORD bsafePubKeyLength;
} PUBLIC_KEY_ATTRIB;



typedef struct {
    DWORD blockLength;  // cipherLength + size of following hdr fields
    DWORD version;  // = 1
    DWORD encType;  // 0x060001 for RC2; 0x090001 and 0x0A0001 for RSA
    WORD cipherLength;  // of ciphertext
    WORD dataLength;    // of plaintext
} ENC_BLOCK_HDR;

typedef struct {
    DWORD version;
    WORD tag;
} TAG_DATA_HEADER;

#define TAG_PRIVATE_KEY 2
#define TAG_PUBLIC_KEY  4
#define TAG_CREDENTIAL  6
#define TAG_SIGNATURE   7
#define TAG_PROOF       8

typedef struct {
    TAG_DATA_HEADER tdh;
    NDS_TIME validityBegin;
    NDS_TIME validityEnd;
    DWORD random;
    WORD optDataSize;
    WORD userNameLength;
    // BYTE optData[optDataSize];
    // BYTE userName[userNameLength];
} NDS_CREDENTIAL;

typedef struct {
    TAG_DATA_HEADER tdh;
    WORD signDataLength;
    //BYTE signData[signLength];
} NDS_SIGNATURE;

typedef struct {
    TAG_DATA_HEADER tdh;
    WORD keyDataLength;
    //BYTE BsafeKeyData[keyDataLength];
} NDS_PRIVATE_KEY;

typedef struct {
    DWORD challenge;
    DWORD oldPwLength;  // 16
    BYTE oldPwHash[16];
    DWORD newPwStrLength;      //password length
    DWORD newPwLength;  // 16
    BYTE newPwHash[16];
    ENC_BLOCK_HDR encPrivKeyHdr;
    // BYTE encPrivKey[];
} NDS_CHPW_MSG;

#define NDSV_CHANGE_PASSWORD 55
typedef struct {
    DWORD version;      // = 0
    DWORD entryId;
    DWORD totalLength;
    DWORD secVersion;   // = 1
    DWORD envelopId1;   // 0x00020009
    DWORD envelopLength1;
    //ENC_BLOCK_HDR rsaHeader;     // secret key data encrypted with RSA
    //BYTE rsaCipher[53];          // 53 + 3 pad bytes
    //BYTE pad[3];
    //ENC_BLOCK_HDR rc2Header;
    //BYTE rc2Cipher[];
} REQ_CHANGE_PASSWORD;

#define NDSV_BEGIN_LOGIN 57
typedef struct {
    DWORD version;
    DWORD entryId;
} REQ_BEGIN_LOGIN;
 

typedef struct {
    DWORD ccode;
    DWORD entryId;  // need not be same as in request
    DWORD challenge;
} REPLY_BEGIN_LOGIN;

#define NDSV_FINISH_LOGIN   58
typedef struct {
    DWORD version;
    DWORD flags;    // = 0
    DWORD entryId;
    DWORD totalLength;  // = 0x494
    DWORD secVersion;   // = 1
    DWORD envelopId1;   // 0x00020009
    DWORD envelopLength1;   // 0x488
    //ENC_BLOCK_HDR rsaHeader;     // secret key data encrypted with RSA
    //BYTE rsaCipher[53];          // 53 + 3 pad bytes
    //BYTE pad[3];
    //ENC_BLOCK_HDR rc2Header;
    //BYTE rc2Cipher[0x430];
} REQ_FINISH_LOGIN;    

typedef struct {
    DWORD ccode;
    DWORD valStart;
    DWORD valEnd;
    //ENC_BLOCK_HDR rc2Header;
    //BYTE rc2Cipher[0x140];
} REPLY_FINISH_LOGIN;

#define NDSV_BEGIN_AUTHENTICATE 59
typedef struct {
    DWORD version;
    DWORD entryId;
    DWORD clientRand;
} REQ_BEGIN_AUTHENTICATE;

typedef struct {
    DWORD svrRand;
    DWORD totalLength;
    TAG_DATA_HEADER tdh;
    WORD unknown;   // = 2
    DWORD encClientRandLength;
    //CIPHER_BLOCK_HEADER keyCipherHdr;
    //BYTE keyCipher[];
    //CIPHER_BLOCK_HEADER encClientRandHdr;
    //BYTE encClientRand[];
} REPLY_BEGIN_AUTHENTICATE;


#define NDSV_FINISH_AUTHENTICATE    60
//typedef struct {
//   DWORD sessionKeyLength;
//   BYTE  encSessionKey[sessionKeyLength];
//   DWORD credentialLength;
//    BYTE credential[credentialLength];
//   WORD unknown = 0;
//   DWORD proofLength;
//   TAG_DATA_HEADER proofTDH;
//   WORD log2DigestBase;   //=16
//   WORD proofOrder;       //=3;
//   totalXLength;
//   BYTE x1[];
//   BYTE x2[];
//   BYTE x3[];
//   BYTE y1[];
//   BYTE y2[];
//   BYTE y3[];
// } REQ_FINISH_AUTHENTICATE;

#define NDSV_LOGOUT             61

#define ROUNDUP4(x) (((x)+3)&(~3))

// Transport type

// referral scope
#define ANY_SCOPE           0
#define COUNTRY_SCOPE       1
#define ORGANIZATION_SCOPE  2
#define LOCAL_SCOPE         3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\msnwerr.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1993-1995          **/
/*****************************************************************/

/* NWERROR.H -- Return codes from NetWare API
 *
 * History:
 *  03/16/93    vlads   Created
 *  12/15/94	vlads	Renamed and cleaned up
 *
 */

#ifndef _nwerror_h_
#define _nwerror_h_

typedef long  int	NW_STATUS;

//
// NDS errors are -ve, local and NW3 errors are +ve
//

typedef long NDS_RETURN_CODE;


/*
 * Bindery compatible error codes
 */

#define     NWSC_BAD_STATION_NUMBER		0xFD
#define     NWSC_NO_SUCH_OBJECT         0xFC
#define     NWSC_MESSAGE_QUEUE_FULL     0xFC
#define     NWSC_UNKNOWN_REQUEST        0xFB
#define     NWSC_NO_SUCH_PROPERTY       0xFB
#define     NWSC_NO_SUCH_PRIORITY       0xFB
#define     NWSC_TEMPORARY_REMAP_ERROR  0xFA
#define     NWSC_NO_PROPERTY_READ       0xF9
#define     NWSC_NO_PROPERTY_VALUE      0xF8
#define     NWSC_NO_PROPERTY_CREATE     0xF7
#define     NWSC_NO_PROPERTY_DELETE     0xF6
#define     NWSC_NO_OBJECT_CREATE       0xF5
#define     NWSC_NO_OBJECT_DELETE       0xF4
#define     NWSC_NO_OBJECT_RENAME       0xF3
#define     NWSC_NO_OBJECT_READ         0xF2
#define     NWSC_BINDERY_SECURITY       0xF1
#define     NWSC_ILLEGAL_WILDCARD       0xF0
#define     NWSC_ILLEGAL_NAME           0xEF
#define     NWSC_OBJECT_EXISTS          0xEE
#define     NWSC_PROPERTY_EXISTS        0xED
#define     NWSC_NO_SUCH_SET            0xEC
#define     NWSC_NO_SUCH_SEGMENT        0xEC
#define     NWSC_PROPERTY_NOT_SET       0xEB
#define     NWSC_NO_SUCH_MEMBER         0xEA
#define     NWSC_MEMBER_EXISTS          0xE9
#define     NWSC_WRITE_TO_GROUP         0xE8
#define     NWSC_NO_DISK_TRACK          0xE7
#define     NWSC_OLD_PASSWORD           0xDF
#define     NWSC_BAD_PASSWORD           0xDE
#define     NWSC_TALLY_CORRUPT          0xDD
#define     NWSC_EA_KEY_LIMIT           0xDC
#define		NWSC_ACCOUNT_DISABLED		0xDC
#define     NWSC_MAX_QUEUE_SERVERS      0xDB
#define 	NWSC_BAD_LOGIN_STATION		0xDB
#define     NWSC_QUEUE_HALTED           0xDA
#define		NWSC_BAD_LOGIN_TIME			0xDA
#define     NWSC_STATION_NOT_SERVER     0xD9
#define 	NWSC_TOO_MANY_LOGINS		0xD9
#define     NWSC_QUEUE_NOT_ACTIVE       0xD8
#define		NWSC_PASSWORD_TOO_SHORT		0xD8
#define     NWSC_QUEUE_SERVICING        0xD7
#define		NWSC_PASSWORD_NOT_UNIQUE	0xD7
#define     NWSC_NO_JOB_RIGHTS          0xD6
#define     NWSC_NO_QUEUE_JOB           0xD5
#define     NWSC_QUEUE_FULL             0xD4
#define     NWSC_NO_QUEUE_RIGHTS        0xD3
#define     NWSC_NO_QUEUE_SERVER        0xD2
#define     NWSC_NO_QUEUE               0xD1
#define		NWSC_ACCESS_DENIED			0xD1
#define     NWSC_QUEUE_ERROR            0xD0
#define     NWSC_INVALID_EA_HANDLE      0xCF
#define     NWSC_BAD_DIR_NUMBER         0xCE
#define     NWSC_DIR_OUT_OF_RANGE       0xCD
#define     NWSC_INTERNAL_FAILURE       0xCC
#define     NWSC_NO_KEY_NO_DATA         0xCB
#define     NWSC_INVALID_EA_HANDLE_TYPE 0xCA
#define     NWSC_EA_NOT_FOUND           0xC9
#define     NWSC_MISSING_EA_KEY         0xC8
#define     NWSC_NO_CONSOLE_RIGHTS      0xC6
#define     NWSC_LOGIN_LOCKOUT          0xC5
#define     NWSC_ACCOUNT_DISABLED1      0xC4
#define     NWSC_TOO_MANY_HOLDS         0xC3
#define     NWSC_CREDIT_LIMIT_EXCEEDED  0xC2
#define     NWSC_NO_ACCOUNT_BALANCE     0xC1
#define     NWSC_NO_ACCOUNT_PRIVILEGES  0xC0
#define     NWSC_INVALID_NAME_SPACE     0xBF
#define     NWSC_IO_LOCK_ERROR          0xA2
#define     NWSC_DIRECTORY_IO_ERROR     0xA1
#define     NWSC_DIRECTORY_NOT_EMPTY    0xA0
#define     NWSC_DIRECTORY_ACTIVE       0x9F
#define     NWSC_BAD_FILE_NAME          0x9E
#define     NWSC_NO_DIRECTORY_HANDLES   0x9D
#define     NWSC_INVALID_PATH           0x9C
#define     NWSC_BAD_DIRECTORY_ERROR    0x9B
#define     NWSC_RENAME_ACROSS_VOLUME   0x9A
#define     NWSC_DIRECTORY_FULL_ERROR   0x99
#define     NWSC_DISK_MAP_ERROR         0x98
#define     NWSC_ILLEGAL_VOLUME         0x98
#define     NWSC_SERVER_OUT_OF_MEMORY   0x96
#define     NWSC_FILE_DETACHED          0x95
#define     NWSC_NO_WRITE_PRIVILEGES    0x94
#define     NWSC_NO_READ_PRIVILEGES     0x93
#define     NWSC_ALL_NAMES_EXIST        0x92
#define     NWSC_SOME_NAMES_EXIST       0x91
#define     NWSC_ALL_READ_ONLY          0x90
#define     NWSC_SOME_READ_ONLY         0x8F
#define     NWSC_ALL_FILES_IN_USE       0x8E
#define     NWSC_SOME_FILES_IN_USE      0x8D
#define     NWSC_NO_SET_PRIVILEGES      0x8C
#define     NWSC_NO_RENAME_PRIVILEGES   0x8B
#define     NWSC_NO_DELETE_PRIVILEGES   0x8A
#define     NWSC_NO_SEARCH_PRIVILEGES   0x89
#define     NWSC_INVALID_FILE_HANDLE    0x88
#define     NWSC_CREATE_FILENAME_ERROR  0x87
#define     NWSC_NO_CREATE_DELETE_PRIVILEGES 0x85
#define     NWSC_NO_CREATE_PRIVILEGES   0x84
#define     NWSC_HARD_IO_ERROR          0x83
#define     NWSC_NO_OPEN_PRIVILEGES     0x82
#define     NWSC_OUT_OF_HANDLES         0x81
#define     NWSC_FILE_IN_USE            0x80
#define     NWSC_LOCK_FAIL              0x80
#define     NWSC_NWREDIR_EXCHANGE_ERROR 0x07
#define     NWSC_OUT_OF_DISK_SPACE      0x01


#define 	NWSC_SUCCESS            	0x00
#define 	NWSC_SERVEROUTOFMEMORY  	0x96
#define		NWSC_NOSPOOLDISKSPACE		0x97
#define 	NWSC_NOSUCHVOLUME       	0x98   // Volume does not exist
#define		NWSC_DIRECTORYFULL			0x99
#define 	NWSC_BADDIRECTORYHANDLE 	0x9B
#define 	NWSC_NOSUCHPATH         	0x9C
#define 	NWSC_NOJOBRIGHTS        	0xD6
#define 	NWSC_PWD_NOT_UNIQUE			0xD7
#define 	NWSC_PWD_TOO_SHORT			0xD8
#define 	NWSC_PWD_LOGON_DENIED		0xD9
#define		NWSC_NO_QUEUE				0xD1
#define 	NWSC_TIME_RESTRICTED		0xDA
#define 	NWSC_STATION_RESTRICTED		0xDB
#define 	NWSC_ACCOUNT_DISABLED		0xDC
#define		NWSC_PWD_EXPIRED_NO_GRACE	0xDE
#define 	NWSC_EXPIREDPASSWORD    	0xDF
#define 	NWSC_NOSUCHSEGMENT      	0xEC   // Segment does not exist
#define 	NWSC_INVALIDNAME        	0xEF
#define 	NWSC_NOWILDCARD         	0xF0   // Wildcard not allowed
#define 	NWSC_NOPERMBIND         	0xF1   // Invalid bindery security
		
#define 	NWSC_ALREADYATTACHED    	0xF8   // Already attached to file server
#define 	NWSC_NOPERMREADPROP     	0xF9   // No property read privelege
#define 	NWSC_NOFREESLOTS        	0xF9   // No free connection slots locally
#define 	NWSC_NOMORESERVERSLOTS  	0xFA   // No more server slots
#define 	NWSC_NOSUCHPROPERTY     	0xFB   // Property does not exist
#define 	NWSC_UNKNOWN_REQUEST    	0xFB   // Invalid NCP number
#define 	NWSC_NOSUCHOBJECT       	0xFC   // End of Scan Bindery Object service
											   // No such object
#define 	NWSC_UNKNOWNSERVER      	0xFC   // Unknown file server
#define 	NWSC_SERVERBINDERYLOCKED    0xFE   // Server bindery locked
#define 	NWSC_BINDERYFAILURE     	0xFF   // Bindery failure
#define 	NWSC_ILLEGALSERVERADDRESS 	0xFF   // No response from server (illegal server address)
#define 	NWSC_NOSUCHCONNECTION   	0xFF   // Connection ID does not exist
#define 	NWSC_ERROR					0xFF
#define		NWSC_NET_ERROR				0xFD
#define 	NWSC_DIRECTORY_LOCKED   	0xFE
#define		NWSC_NO_NETWORK				0xFF

// This is NOBALL specific error code
//#define NWSC_NO_RESPONSE		7L
//#define NWSC_BAD_CONNECTION		8L

#define  NWSC_NO_RESPONSE		ERROR_REM_NOT_LIST
#define  NWSC_BAD_CONNECTION 	ERROR_DEV_NOT_EXIST


// NW requester error codes
// same as VLM return codes (Netware Client Assembly API)
#define REQUESTR_ERR            0x8800

#define NWRE_INVALID_CONNECTION     (REQUESTR_ERR | 0x01)  //connection handle is invalid
#define NWRE_DRIVE_IN_USE           (REQUESTR_ERR | 0x02)
#define NWRE_CANT_ADD_CDS           (REQUESTR_ERR | 0x03)
#define NWRE_BAD_DRIVE_BASE         (REQUESTR_ERR | 0x04)
#define NWRE_NET_RECV_ERROR         (REQUESTR_ERR | 0x05)
#define NWRE_UNKNOWN_NET_ERROR      (REQUESTR_ERR | 0x06)
#define NWRE_SERVER_INVALID_SLOT    (REQUESTR_ERR | 0x07)
#define NWRE_NO_SERVER_SLOTS        (REQUESTR_ERR | 0x08)  //server refused attach
#define NWRE_SERVER_NO_ROUTE        (REQUESTR_ERR | 0x0A)
#define NWRE_BAD_LOCAL_TARGET       (REQUESTR_ERR | 0x0B)
#define NWRE_TOO_MANY_REQ_FRAGS     (REQUESTR_ERR | 0x0C)  //request buffer too long
#define NWRE_CONNECT_LIST_OVERFLOW  (REQUESTR_ERR | 0x0D)
#define NWRE_BUFFER_OVERFLOW        (REQUESTR_ERR | 0x0E) //reply buffer not big enough
#define NWRE_NO_ROUTER_FOUND        (REQUESTR_ERR | 0x10)
#define NWRE_PARAMETER_NOT_FOUND    (REQUESTR_ERR | 0x10)
#define NWRE_BAD_FUNC               (REQUESTR_ERR | 0x11)
#define NWRE_PRIMARY_CONN_NOT_SET   (REQUESTR_ERR | 0x31) //no default connection set
#define NWRE_INVALID_BUFFER_LENGTH  (REQUESTR_ERR | 0x33)
#define NWRE_INVALID_PARAMETER      (REQUESTR_ERR | 0x36)

#define NWRE_CONNECTION_TABLE_FULL  (REQUESTR_ERR | 0x3F) // too many local connections

#define NWRE_TDS_INVALID_TAG        (REQUESTR_ERR | 0x44)
#define NWRE_NO_SERVER              (REQUESTR_ERR | 0x47)
#define NWRE_DEVICE_NOT_REDIRECTED  (REQUESTR_ERR | 0x4C)

#define NWRE_TOO_MANY_REPLY_FRAGS   (REQUESTR_ERR | 0x50) // too many fragments in reply buff
#define NWRE_OUT_OF_MEMORY          (REQUESTR_ERR | 0x53)    // local memory allocation failure
#define NWRE_PREFERRED_NOT_FOUND    (REQUESTR_ERR | 0x55)
#define NWRE_DEVICE_NOT_RECOGNIZED  (REQUESTR_ERR | 0x56)
#define NWRE_BAD_NET_TYPE           (REQUESTR_ERR | 0x57)

#define NWRE_INVALID_SERVER_NAME    (REQUESTR_ERR | 0x59)

#define NWRE_FAILURE                (REQUESTR_ERR | 0xff)   //  internal shell failure

//NDS errors
#define NDSE_NO_MEM      -301
#define NDSE_BAD_KEY     -302
#define NDSE_BAD_CONTEXT -303
#define NDSE_BUFFER_FULL -304
#define NDSE_NULL_LIST   -305
#define NDSE_BAD_SYNTAX_ID -306
#define NDSE_BUFFER_EMPTY -307
#define NDSE_BAD_VERB    -308
#define NDSE_NOT_TYPED   -309
#define NDSE_EXPECTED_EQUALS -310
#define NDSE_EXPECTED_TYPE   -311
#define NDSE_TYPE_NOT_EXPECTED -312
#define NDSE_FILTER_EMPTY    -313
#define NDSE_BAD_OBJECT_NAME    -314
#define NDSE_EXPECTED_RDN    -315
#define NDSE_TOO_MANY_TOKENS -316
#define NDSE_BAD_MULTI_AVA  -317
#define NDSE_BAD_COUNTRY_NAME -318
#define NDSE_SYSTEM_ERROR    -319
#define NDSE_CANT_ADD_ROOT   -320
#define NDSE_CANT_ATTACH     -321
#define NDSE_INVALID_HANDLE  -322
#define NDSE_ZERO_LENGTH     -323
#define NDSE_REPLICA_TYPE    -324
#define NDSE_BAD_ATTR_SYNTAX_ID -325

#define NDSE_CONTEXT_CREATION -328
#define NDSE_INVALID_UNION_TAG -329
#define NDSE_INVALID_SERVER_RESPONSE    -330
#define NDSE_NULL_POINTER       -331
#define NDSE_BAD_FILTER         -332
#define NDSE_RDN_TOO_LONG       -334
#define NDSE_DUPLICATE_TYPE     -335
#define NDSE_NOT_LOGGED_IN      -337
#define NDSE_BAD_PASSWORD_CHARS -338
#define NDSE_AUTHENT_FAILED     -339
#define NDSE_TRANSPORT          -340
#define NDSE_NO_SUCH_SYNTAX     -341
#define NDSE_BAD_DS_NAME        -342
#define NDSE_ATTR_NAME_TOO_LONG -343
#define NDSE_INVALID_TDS        -344
#define NDSE_INVALID_DS_VERSION  -345
#define NDSE_UNICODE_TRANSLATION -346
#define NDSE_NO_WRITABLE_REPLICAS -352
#define NDSE_DN_TOO_LONG        -353
#define NDSE_RENAME_NOT_ALLOWED -354

//
// Following are NDS server errors
//
#define	NDSE_NAME_NOT_FOUND		-601
#define NDSE_VALUE_NOT_FOUND	-602
#define NDSE_ATTRIB_NOT_FOUND	-603
#define NDSE_NO_SUCH_CLASS		-604
#define NDSE_PARTITION_NOT_FOUND -605
#define NDSE_ENTRY_EXISTS		-606
#define NDSE_ILLEGAL_ATTRIB		-608
#define NDSE_MISSING_MANDATORY	-609
#define NDSE_ILLEGAL_NAME		-610
#define NDSE_ILLEGAL_PARENT		-611
#define NDSE_SINGLE_VALUED		-612
#define NDSE_ILLEGAL_SYNTAX		-613
#define NDSE_DUPLICATE_VALUE	-614
#define NDSE_ATTRIB_EXISTS		-615
#define NDSE_MAXED_ENTRIES		-616
#define NDSE_DB_FORMAT			-617
#define NDSE_BAD_DATABASE		-618
#define NDSE_BAD_COMPARISON		-619
#define NDSE_COMPARISON_FAILED	-620
#define NDSE_TRANSACT_DISABLED	-621
#define NDSE_BAD_TRANSPORT		-622
#define NDSE_INVALID_NAME_SYNTAX -623
#define NDSE_ALL_REFERRALS_FAILED -626
#define	NDSE_DIFFERENT_TREE		-630  	/* No clear meaning */
#define NDSE_SYSTEM_FAILURE		-632
#define NDSE_NO_REFERRALS		-634
#define NDSE_INVALID_REQUEST	-641
#define NDSE_INVALID_ITERATION	-642
#define NDSE_TIME_OUT_OF_SYNC	-659
#define NDSE_DS_LOCKED			-663
#define NDSE_NOT_CONTAINER		-668
#define NDSE_BAD_AUTHENTICATION	-669
#define NDSE_NO_SUCH_PARENT		-671
#define NDSE_ACCESS_DENIED		-672
#define NDSE_ALIAS_OF_ALIAS		-681
#define NDSE_INVALID_VERSION	-683
#define NDSE_FATAL_ERROR		-699


#define	NDSE_PASSWORD_EXPIRED	NWSC_EXPIREDPASSWORD
#define	NDSE_BAD_PASSWORD		NWSC_BAD_PASSWORD

//
//	Error checking macros
//

#define	NW_IS_SUCCESS(err)	(err==NWSC_SUCCESS)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\ndsapi95.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    NdsApi95.c

Abstract:

    NdsApi32 routines specific for Win95. Routines will call into the Windows95
    NWAPI32.DLL directly.


Author:

    Felix Wong [t-felixw]    23-Sept-1996

--*/

#include <procs.h>
#include <nw95.h>
#include <msnwapi.h>
#include <utils95.h>
#include <nwatch95.h>

// Ported from WIN95
void
MadeDSTreeNameDisplayableHack(
    LPSTR lpszDSName
)
{
    int i;
    LPSTR lpszStartTail = NULL;

    if (!lpszDSName)
       return;

    // Tree name is padded by 0x5f looks rather ugly if displayed
    // So we cut off tail of underscores, but being careful with
    // DBCS characters

    i = MAX_NDS_TREE_CHARS;

    while (*lpszDSName && i--) {
        if (*lpszDSName == 0x5f) {
            if (!lpszStartTail) {
                lpszStartTail = lpszDSName;
            }
        }
        else {
            lpszStartTail = NULL;
        }
        lpszDSName = CharNextA(lpszDSName);
    }

    if (lpszStartTail) {
        *lpszStartTail = '\0';
    }
}

// Ported from WIN95
BOOL GetCurrentTree(LPSTR szPrefTree)
{
    NW_STATUS NWStatus;

    NWStatus = NetWGetPreferredName(NETW_DirectoryServer,szPrefTree);
    if (NWStatus != NWSC_SUCCESS)
        return FALSE;

    MadeDSTreeNameDisplayableHack(szPrefTree);
    return TRUE;
};

NTSTATUS
NwNdsResolveNameWin95 (
    IN HANDLE           hNdsTree,
    IN PUNICODE_STRING  puObjectName,
    OUT DWORD           *pdwObjectId,
    OUT HANDLE          *pConn,
    OUT PBYTE           pbRawResponse,
    IN DWORD            dwResponseBufferLen
)
{
    NTSTATUS  NtStatus = STATUS_UNSUCCESSFUL;
    LPSTR ParentName;
    ParentName = AllocateAnsiString((LPWSTR)(puObjectName->Buffer));
    if (ParentName) {
        NW_STATUS NwStatus;

        // puObjectName->Buffer is a wide string but might not be necessarily
        // terminating at the right place. So, we need the following to null
        // terminaite the string correctly.
        ParentName[(puObjectName->Length)/2] = '\0';
        NwStatus = ResolveNameA(ParentName,
                        RSLV_DEREF_ALIASES|RSLV_WALK_TREE|RSLV_WRITABLE,
                        pdwObjectId,
                        pConn);
        NtStatus = MapNwToNtStatus(NwStatus);
        FreeAnsiString(ParentName);
    };
    return NtStatus;
}

NTSTATUS
NwOpenHandleWithSupplementalCredentials(
    IN PUNICODE_STRING puResourceName,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwHandle
) {
    return NwNdsOpenTreeHandle( puResourceName,
                                phNwHandle);
}

NTSTATUS
NwNdsOpenTreeHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT PHANDLE  phNwRdrHandle
) {
    LPSTR         szTree;
    NTSTATUS      NtStatus = STATUS_UNSUCCESSFUL;
    CHAR          szPrefTree[MAX_NDS_TREE_CHARS+1] = {'\0'};
    NWCONN_HANDLE handle;

    szTree = AllocateAnsiString((LPWSTR)(puNdsTree->Buffer));
    if (szTree) {
        NW_STATUS     NwStatus;

        // puObjectName->Buffer is a wide string but might not be necessarily
        // terminating at the right place. So, we need the following to null
        // terminaite the string correctly.
        szTree[(puNdsTree->Length)/2] = '\0';

        if (GetCurrentTree(szPrefTree) &&
            (lstrcmpiA(szTree,szPrefTree) == 0 )) {
            NwStatus = NetWGetPreferredConnID(NETW_DirectoryServer,
                                              phNwRdrHandle);
            NtStatus = MapNwToNtStatus(NwStatus);
        }
        FreeAnsiString(szTree);
    }
    return NtStatus;
}


int
_cdecl
CalculateBuf(
    const char *format,
    va_list args
);

NTSTATUS
_cdecl
FragExWithWait(
    IN HANDLE  hNdsServer,
    IN DWORD   NdsVerb,
    IN BYTE    *pReplyBuffer,
    IN DWORD   ReplyBufferLen,
    IN OUT DWORD *pdwReplyLen,
    IN BYTE    *NdsRequestStr,
    ...
)
/*

Routine Description:

    Exchanges an NDS request in fragments and collects the fragments
    of the response and writes them to the reply buffer.

Routine Arguments:

    hNdsServer      - A handle to the server you want to talk to.
    NdsVerb         - The verb for that indicates the request.

    pReplyBuffer    - The reply buffer.
    ReplyBufferLen  - The length of the reply buffer.

    NdsReqestStr    - The format string for the arguments to this NDS request.
    Arguments       - The arguments that satisfy the NDS format string.

Return Value:

    NTSTATUS - Status of the exchange, but not the result code in the packet.

*/
{
    NTSTATUS NtStatus;
    NW_STATUS NwStatus;
    BYTE  *NdsRequestBuf;
    DWORD NdsRequestLen;
    PNWR_NDS_REQUEST_PACKET RawRequest;
    int   bufferSize = 0;

    va_list Arguments;

    //
    // Allocate a request buffer.
    //

    //
    // Calculate needed buffer size . . .
    //
    if ( NdsRequestStr != NULL ) {
        va_start( Arguments, NdsRequestStr );
        bufferSize = CalculateBuf( NdsRequestStr, Arguments );
        va_end( Arguments );

        if ( bufferSize == 0 )
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto ExitWithCleanup;
        }
    }

    bufferSize += sizeof( NWR_NDS_REQUEST_PACKET ) + 50;

    RawRequest = LocalAlloc( LMEM_ZEROINIT, bufferSize );

    if ( !RawRequest ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the request in our local buffer.  The first DWORD
    // is the verb and the rest is the formatted request.
    //

    NdsRequestBuf = &RawRequest->Parameters.RawRequest.Request[0];

    if ( NdsRequestStr != NULL ) {

        va_start( Arguments, NdsRequestStr );

        NdsRequestLen = FormatBuf( NdsRequestBuf,
                                   bufferSize - sizeof( NWR_NDS_REQUEST_PACKET ),
                                   NdsRequestStr,
                                   Arguments );

        if ( !NdsRequestLen ) {

           NtStatus = STATUS_INVALID_PARAMETER;
           goto ExitWithCleanup;

        }

        va_end( Arguments );

    } else {

        NdsRequestLen = 0;
    }

    *pdwReplyLen = ReplyBufferLen;

    NwStatus = NDSRequest(hNdsServer,
                        NdsVerb,
                        NdsRequestBuf,
                        NdsRequestLen,
                        pReplyBuffer,
                        pdwReplyLen
                        );

    NtStatus = MapNwToNtStatus(NwStatus);
ExitWithCleanup:

    if ( RawRequest ) {
        LocalFree( RawRequest );
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\ndsapi95.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    NdsApi95.h

Abstract:

    Header for NdsApi95
    
Author:

    Felix Wong [t-felixw]    23-Sept-1996

--*/
NTSTATUS
NwNdsResolveNameWin95 (
    IN HANDLE           hNdsTree,
    IN PUNICODE_STRING  puObjectName,
    OUT DWORD           *pdwObjectId,
    OUT HANDLE          *pConn,
    OUT PBYTE           pbRawResponse,
    IN DWORD            dwResponseBufferLen
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\nw95.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    nw95.h

Abstract:

    Header for nwlib. Extracted essential info from WIN95
    Netware Redirector headers

Author:

    Felix Wong (t-felixw)    27-Sep-1996

Environment:


Revision History:


--*/

#define NTAPI                __stdcall
#define NWCCODE              USHORT
#define NWCONN_HANDLE        HANDLE
#define NWFAR
#define NWAPI                WINAPI
#define NW_RETURN_CODE       UINT
#define NW_SUCCESS           0X00
#define NULL_TERMINATED      0
#define NDSV_MODIFY_CLASS    16

typedef LONG                 NTSTATUS;
typedef long int             NW_STATUS;
typedef BYTE                 NWCONN_ID;
typedef HANDLE               NW_CONN_HANDLE;
typedef NWCONN_HANDLE*       PNWCONN_HANDLE;

struct _nds_tag {
        DWORD verb;
        UINT count;
        char  *bufEnd;
        PVOID nextItem;
};

NW_STATUS
ResolveNameA(
    PCSTR szName,
    DWORD flags,
    DWORD *pObjId,
    NWCONN_HANDLE *phConn
    );

NW_STATUS WINAPI
NDSRequest(
    NWCONN_HANDLE   hConn,
    UINT verb,
    PVOID reqBuf,
    int reqLen,
    PVOID replyBuf,
    int *replyLen
    );

BYTE
VLMToNWREDIRHandle(
    NWCONN_HANDLE hConn
    );

NW_RETURN_CODE WINAPI
NWConnControlRequest(
    NWCONN_ID bConnectionID,
    UINT wFunctionNumber,
    LPVOID lpRequest,
    LPVOID lpAnswer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\nwapi95.h ===
/*****************************************************************/
/**               Microsoft Windows 4.00                            **/
/**           Copyright (C) Microsoft Corp., 1994-1995          **/
/*****************************************************************/

/* NWAPI95.H -- Originally NWAPI32.H, renamed due to name conflict.
 *           common header file NW32 API DLL
 *
 * History:
 *
 *  12/14/94    vlads   Created
 *  12/28/94        vlads   Added debugging macros
 *
 */

//#define STRICT        // codework: get strict Windows compilation working

#pragma

//#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#define DEFINE_INTERNAL_PREFIXES 1
#include <msnwdef.h>
#include <msnwapi.h>

#include <string.h>
#include <netlib.h>


#pragma warning(disable : 4200) // Zero sized array

#include <nwnet.h>
#include <npassert.h>

#include <vxdcall.h>
#include <ifs32api.h>

#include <msnwerr.h>

#pragma warning(default : 4200)


//
#define SPN_SET(bits,ch)        bits[(ch)/8] |= (1<<((ch) & 7))
#define SPN_TEST(bits,ch)       (bits[(ch)/8] & (1<<((ch) & 7)))

// Null strings are quite often taken to be either a NULL pointer or a zero
#define IS_EMPTY_STRING(pch) ( !pch || !*(pch) )

// Macros to validate parameters:

// IS_BAD_BUFFER validates that a buffer is good for writing into.
// lpBuf can be NULL, in which case the buffer is not valid.
// lpdwSize must be a valid pointer, but can point to a value of
// 0 (i.e. a null buffer), in which case the buffer is valid.
#define IS_BAD_BUFFER(lpBuf,lpdwSize) (IsBadReadPtr(lpdwSize, sizeof(LPDWORD)) || IsBadWritePtr(lpBuf, *lpdwSize))

// IS_BAD_STRING validates that a valid NULL terminated string is at
// the specified address. Unlike IsBadStringPtr, no limitation is placed
// upon the string length.
#define IS_BAD_STRING(lpString) (IsBadStringPtr(lpString, 0xffffffff))


#define SEG_INSTANCE    ".instance"
#define SEG_SHARED              ".data"
#define SEG_CODE                ".text"

//
// Macros to define process local storage:
//

#define BEGIN_INSTANCED_DATA data_seg(SEG_INSTANCE,"INSTANCE")
#define END_INSTANCED_DATA data_seg()

#define BEGIN_SHARED_DATA data_seg(SEG_SHARED,"SHARED")
#define END_SHARED_DATA data_seg()

#define BEGIN_READONLY_DATA data_seg(SEG_CODE,"CODE")
#define END_READONLY_DATA data_seg()


void NW32_EnterCriticalSection(void);
void NW32_LeaveCriticalSection(void);

#ifdef DEBUG
extern BOOL g_fCritical;
#endif

#define ENTERCRITICAL   NW32_EnterCriticalSection();
#define LEAVECRITICAL   NW32_LeaveCriticalSection();
#define ASSERTCRITICAL  Assert(g_fCritical);


/*
 * External variables reference
 *
 */

extern  BOOL    g_fThunkLayerPresent;   // Is thunk layer successfully loaded
extern  BOOL    g_fIfsmgrOpened;                // -- IFSMGR -----
extern  BOOL    g_fSvrOpened ;                  // -- NWSERVER ---
extern  BOOL    g_fNSCLOpened;                  // -- NSCL -------

extern  HANDLE  g_hRedirDevice ;                // Handle of device for NWREDIR
extern  HANDLE  g_hIfsmgrDevice;                // -- IFSMGR
extern  HANDLE  g_hSvrDevice ;                  // -- NWSERVER
extern  HANDLE  g_hNSCLDevice;                  // -- NSCL
extern  HANDLE  g_hmtxNW32;                             // Initialization time mutex

extern  HANDLE  g_hmodThisDll;                  // Instance handle for DLL executable

extern  CHAR            szLocalComputer[];

extern  HINSTANCE       g_hInst16;
/*
extern "C"  BOOL        g_fNWCallsLayerPresent; // Accessed from asm modules
extern "C"      BOOL    g_fDRVLayerPresent;     // Is thunk layer successfully loaded
extern "C"  BOOL        g_fRedirAvailable ;     // Is NWREDIR Ioctl entry point available
extern "C"  BOOL        g_fRedirVLMAvailable ;
*/

/*
 * Functions prototypes
 *
 */
/*
// We need to do that because allocator for our classes is using out heap management
void *   _cdecl operator new(unsigned int size);
void    _cdecl operator delete(void *ptr);
*/
//extern "C"
extern HANDLE ConvertToGlobalHandle(HANDLE);

BOOL            WINAPI  NWRedirInitializeAPI(VOID);
UINT            WINAPI  NWRedirCallAPI(BYTE  bConnectionID,win32apireq *ReqSet);

BYTE            WINAPI  InterlockedSet(volatile BYTE *pByte);

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

WORD    WINAPI NWWordSwap(WORD wIn);
DWORD   WINAPI NWLongSwap(DWORD dwIn);

WORD            _cdecl WordSwap(WORD wIn);
DWORD           _cdecl LongSwap(DWORD lIn);


//
// Buffer descriptor used for request and reply buffer fragments in the NCP RequestReply call
//
typedef struct {
    char *address;
    unsigned short length;
} BUF_DESC;

void __stdcall IFSMGR_W32_Int21(pwin32apireq preq);
NW_STATUS NWRedirVLMAPI(DWORD vlmFunction,win32apireq *pReqSet);


NW_STATUS VLM_NCPRequest(
        NWCONN_HANDLE hConn,
        UCHAR func,
        UINT reqCount, BUF_DESC *reqList,
        UINT replyCount, BUF_DESC *replyList);
NW_STATUS WINAPI
NDSRequest(NWCONN_HANDLE   hConn, UINT verb, PVOID reqBuf,int reqLen, PVOID replyBuf, int *replyLen);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef DEBUG
// convert generic Netware status code to error message
extern const char *ErrorMsg(long err);
#endif

#define memcpyW(x,y,z) memcpy(x,y,(z)*sizeof(WCHAR))
#define memmoveW(x,y,z) memmove(x,y,(z)*sizeof(WCHAR))
#define UnicodeToAnsi(u,a) WideCharToMultiByte(CP_ACP,0,u,-1,a,MAX_NDS_NAME_CHARS,0,0)
#define UnicodeToAnsiBuff(u,a,l) WideCharToMultiByte(CP_ACP,0,u,l,a,2*l,0,0)
#define AnsiToUnicode(a,u) MultiByteToWideChar(CP_ACP,0,a,-1,u,MAX_NDS_NAME_CHARS)

// roundup to multiple of 4
#define ROUNDUP4(x) (((x)+3)&(~3))



// NW VLM IDs
#define CONN_VLM        0x10
#define MSNW_VLM        0x1f    // private
#define TRAN_VLM        0x20
#define IPX_VLM         0x21
#define TCP_VLM         0x22
#define NWP_VLM         0x30
#define BINDERY_VLM 0x31
#define NDS_VLM         0x32
#define REDIR_VLM       0x40
#define PRINT_VLM       0x42
#define GEN_VLM         0x43
#define NETX_VLM        0x50

// parameter numbers for Connection Entry fields
#define CEI_ERROR               0               // Flag resettable
#define CEI_NET_TYPE    1               // Word
#define CEI_PERM                2               // Flag resettable
#define CEI_AUTH                3               // Flag
#define CEI_PBURST              4               // Flag
#define CEI_CHANGING    5               // Flag resettable
#define CEI_NEEDS_MAXIO 6               // Flag resettable
#define CEI_PBURST_RESET 7              // Flag resettable
#define CEI_VERSION             8               // Word
#define CEI_REF_COUNT   9               // Word
#define CEI_DIST_TIME   10              // Word
#define CEI_MAX_IO              11              // Word
#define CEI_NCP_SEQ             12              // Byte
#define CEI_CONN_NUM    13              // Word
#define CEI_ORDER_NUM   14              // Byte
#define CEI_TRAN_TYPE   15              // Word
#define CEI_NCPREQ_TYPE 16              // Word
#define CEI_TRAN_BUF    17              // Buffer
#define CEI_BCAST               18              // Flag resettable
#define CEI_LIP                 19              // Word
#define CEI_SECURITY    20              // Byte
#define CEI_RES_COUNT   21              // Word (lo = hard, high = soft)
#define CEI_LOCKED              22              // Flag resettable



//
// Resource strings
//
#define IDS_RTDLL_NOT_LOADED    10
#define IDS_TITLE_ERROR                 11
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\nwatch95.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    NwAtch95.h

Abstract:

    Headers for NwAtch95
    
Author:

    Felix Wong [t-felixw]    23-Sept-1996

--*/

NWCCODE
NWAttachToFileServerWin95(
    LPCSTR              pszServerName,
    WORD                ScopeFlag,
    NW_CONN_HANDLE      *phNewConn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\nwatch95.c ===
/*++

Copyright (C) 1996 Microsoft Corporation

Module Name:

    nwatch95.c

Abstract:

    Attachment routines for Win95
    
Author:

    Felix Wong    [t-felixw]    6-Sep-1996

Revision History:

                                  
--*/

#include "procs.h"
#include "nw95.h"

BOOLEAN* NlsMbOemCodePageTag = FALSE;

typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;

DWORD
szToWide( 
    LPWSTR lpszW, 
    LPCSTR lpszC, 
    INT nSize 
);

HINSTANCE g_hinstDLL = NULL;

// Forwards
NWCCODE
NWAttachToFileServerWin95(
    LPCSTR              pszServerName,
    WORD                ScopeFlag,
    NW_CONN_HANDLE      *phNewConn
    );
        

NWCCODE NWDetachFromFileServerWin95(
    NW_CONN_HANDLE      hConn
    );

DWORD
WideToSz( 
    LPSTR lpszC, 
        LPCWSTR lpszW, 
    INT nSize 
    )
{
    if (!WideCharToMultiByte(CP_ACP,
                             WC_COMPOSITECHECK | WC_SEPCHARS,
                             lpszW,
                             -1,
                             lpszC,
                             nSize,
                             NULL,
                             NULL))
    {
        return (GetLastError()) ;
    }
    
    return NO_ERROR ;
}

NWCCODE NWAPI DLLEXPORT
NWDetachFromFileServer(
    NWCONN_HANDLE hConn
    )
{
    NWCCODE nwccode;
    PNWC_SERVER_INFO   pServerInfo;
    
    if (!hConn)
        return (NWCCODE)UNSUCCESSFUL;
    pServerInfo = (PNWC_SERVER_INFO)hConn ; 


    // Do not detach server since Win95 does not have reference count. We will just
    // wait for it to waitout and disconnect itself.
    // This is suggested by VladS.
    //nwccode = NWDetachFromFileServerWin95(pServerInfo->hConn);
    nwccode = SUCCESSFUL;

    if (pServerInfo->ServerString.Buffer != NULL) {
        (void) LocalFree (pServerInfo->ServerString.Buffer);
        pServerInfo->ServerString.Buffer = NULL;
    }

    pServerInfo->hConn = NULL ;
    (void) LocalFree (pServerInfo) ;

    return nwccode;
}


NWCCODE NWAPI DLLEXPORT
NWAttachToFileServerW(
    const WCHAR     NWFAR   *pwszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE   NWFAR   *phNewConn
    )
{
    NW_STATUS        NwStatus;
    LPWSTR           lpwszServerName = NULL;   // Pointer to buffer for WIDE servername
    LPSTR            lpszServerName = NULL;
    int              nSize;
    PNWC_SERVER_INFO pServerInfo = NULL;

    UNREFERENCED_PARAMETER(ScopeFlag) ;

    //
    // check parameters and init return result to be null.
    //
    if (!pwszServerName || !phNewConn)
        return INVALID_CONNECTION ;

    *phNewConn = NULL ; 

    // Setup lpszServerName, used to pass into NWAttachToFileServerWin95
    nSize = wcslen(pwszServerName) + 1;

    if(!(lpszServerName = (LPSTR) LocalAlloc( 
                                            LPTR, 
                                            nSize * sizeof(CHAR) ))) 
    {
        NwStatus =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    if (WideToSz( lpszServerName, 
                  pwszServerName, 
                  nSize ) != NO_ERROR)
    {
        NwStatus =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }

    // Setup lpwszServerName, used as storage in server handle
    nSize = nSize+2 ;      // Adding 2 for the '\\'
    if(!(lpwszServerName = (LPWSTR) LocalAlloc( 
                                        LPTR, 
                                        nSize * sizeof(WCHAR) ))) 
    {
        NwStatus =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    wcscpy( lpwszServerName, 
            L"\\\\" );
    wcscat( lpwszServerName, 
            pwszServerName );

    //
    // Allocate a buffer for the server info (handle + name pointer). Also
    // init the unicode string.
    //
    if( !(pServerInfo = (PNWC_SERVER_INFO) LocalAlloc( 
                                              LPTR, 
                                              sizeof(NWC_SERVER_INFO))) ) 
    {
        NwStatus =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    RtlInitUnicodeString(&pServerInfo->ServerString, lpwszServerName) ;

    if (wcscmp(pwszServerName,L"*") != 0) {
        NwStatus = NWAttachToFileServerWin95( 
                                        lpszServerName,
                                        ScopeFlag, 
                                        &pServerInfo->hConn 
                           );
    }
    else {
        // hConn of NULL works as nearest server in Win95
        pServerInfo->hConn = NULL;
        NwStatus = SUCCESSFUL;
    }


ExitPoint: 

    //
    // Free the memory allocated above before exiting
    //
    if (lpszServerName)
        (void) LocalFree( (HLOCAL) lpszServerName );
    if (NwStatus != SUCCESSFUL) {
        // only deallocate if unsucessful, or else it will
        // be stored in pServerInfo->ServerString
        if (lpwszServerName)
            (void) LocalFree( (HLOCAL) lpwszServerName );
        if (pServerInfo)
            (void) LocalFree( (HLOCAL) pServerInfo );
    }
    else {
        *phNewConn  = (HANDLE) pServerInfo ;
    }

    //
    // Return with NWCCODE
    //
    return( (NWCCODE)NwStatus );
}


NWCCODE NWAPI DLLEXPORT
NWAttachToFileServer(
    const CHAR     NWFAR   *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE   NWFAR   *phNewConn
    )
{
    NW_STATUS        NwStatus;
    LPWSTR           lpwszServerName = NULL;   // Pointer to buffer for WIDE servername
    LPWSTR           lpwszServerNameTmp = NULL;
    int              nSize;
    PNWC_SERVER_INFO pServerInfo = NULL;

    UNREFERENCED_PARAMETER(ScopeFlag) ;

    //
    // check parameters and init return result to be null.
    //
    if (!pszServerName || !phNewConn)
        return INVALID_CONNECTION ;

    *phNewConn = NULL ; 
    nSize = strlen(pszServerName) + 1;
    
    // Setup lpwszServerNameTmp
    if(!(lpwszServerNameTmp = (LPWSTR) LocalAlloc( 
                                        LPTR, 
                                        nSize * sizeof(WCHAR) ))) 
    {
        NwStatus =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    if (szToWide( lpwszServerNameTmp, 
                  pszServerName, 
                  nSize ) != NO_ERROR)
    {
        NwStatus =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    
    // Setup lpwszServerName for storage in server handle
    nSize = nSize + 2;
    if(!(lpwszServerName = (LPWSTR) LocalAlloc( 
                                        LPTR, 
                                        nSize * sizeof(WCHAR) ))) 
    {
        NwStatus =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    wcscpy( lpwszServerName, 
            L"\\\\" );
    wcscat( lpwszServerName, 
            lpwszServerNameTmp );

    //
    // Allocate a buffer for the server info (handle + name pointer). Also
    // init the unicode string.
    //
    if( !(pServerInfo = (PNWC_SERVER_INFO) LocalAlloc( 
                                              LPTR, 
                                              sizeof(NWC_SERVER_INFO))) ) 
    {
        NwStatus =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    RtlInitUnicodeString(&pServerInfo->ServerString, lpwszServerName) ;

    
    if (strcmp(pszServerName,"*") != 0) {
        NwStatus = NWAttachToFileServerWin95( 
                                        pszServerName,
                                        ScopeFlag, 
                                        &pServerInfo->hConn 
                           );
    }
    else {
        // hConn of NULL works as nearest server in Win95
        pServerInfo->hConn = NULL;
        NwStatus = SUCCESSFUL;
    }

ExitPoint: 

    //
    // Free the memory allocated above before exiting
    //
    if (lpwszServerNameTmp)
        (void) LocalFree( (HLOCAL) lpwszServerNameTmp );
    if (NwStatus != SUCCESSFUL) {
        // only deallocate if unsucessful, or else it will
        // be stored in pServerInfo->ServerString
        if (lpwszServerName)
            (void) LocalFree( (HLOCAL) lpwszServerName );
        if (pServerInfo)
            (void) LocalFree( (HLOCAL) pServerInfo );
    }
    else {
        *phNewConn  = (HANDLE) pServerInfo ;
    }
    //
    // Return with NWCCODE
    //
    return( (NWCCODE)NwStatus );
}

NWCCODE
NWAttachToFileServerWin95(
    LPCSTR              pszServerName,
    WORD                ScopeFlag,
    NW_CONN_HANDLE      *phNewConn
    )
{
    NW_STATUS nwstatusReturn = UNSUCCESSFUL;
    NW_STATUS (*lpfnAttachToFileServerWin95) (LPCSTR,
                                              WORD,
                                              NW_CONN_HANDLE      
                                              );
        
    /* Load the NWAPI32.DLL library module. */
    if (g_hinstDLL == NULL)
        g_hinstDLL = LoadLibraryA("NWAPI32.DLL");
    
    if (g_hinstDLL == NULL) {
        goto Exit;
    }
    
    (FARPROC) lpfnAttachToFileServerWin95 =
                    GetProcAddress(g_hinstDLL, "NWAttachToFileServer");
    
    if (lpfnAttachToFileServerWin95 == NULL)
        goto Exit;

    nwstatusReturn = (*lpfnAttachToFileServerWin95) (pszServerName,
                                                     ScopeFlag,
                                                     phNewConn
                                                     );
Exit:
    //FreeLibrary(hinstDLL);
    return (NWCCODE)nwstatusReturn;
}
        

NWCCODE NWDetachFromFileServerWin95(
    NW_CONN_HANDLE      hConn
    )
{
    NW_STATUS nwstatusReturn = UNSUCCESSFUL;
    NW_STATUS (*lpfnDetachFromFileServerWin95) (NW_CONN_HANDLE);
    
    /* Load the NWAPI32.DLL library module. */
    if (g_hinstDLL == NULL)
        g_hinstDLL = LoadLibraryA("NWAPI32.DLL");
    
    if (g_hinstDLL == NULL)
        goto Exit;
    
    (FARPROC) lpfnDetachFromFileServerWin95 =
                    GetProcAddress(g_hinstDLL, "NWDetachFromFileServer");
    
    if (lpfnDetachFromFileServerWin95 == NULL)
        goto Exit;

    nwstatusReturn = (*lpfnDetachFromFileServerWin95) (hConn);
Exit:
    //FreeLibrary(hinstDLL);
    return (NWCCODE)nwstatusReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\utils95.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Utils.h

Abstract:

    Headers for utilities
    
Author:

    Felix Wong [t-felixw]    23-Sept-1996

--*/

NTSTATUS
MapNwToNtStatus( 
    const NW_STATUS nwstatus
    );

int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    );

LPSTR
AllocateAnsiString(
    LPWSTR  pPrinterName
    );

void
FreeAnsiString(
    LPSTR  pAnsiString
    );

int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    );

LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    );

void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\win95\utils95.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Utils95.c

Abstract:

    Utilities for Win95 OLEDS support in NWAPI32

Author:

    Felix Wong [t-felixw]    23-Sept-1996

--*/

#include <procs.h>
#include <nw95.h>

#define NULL_TERMINATED 0

//
// define error mapping structure
//
typedef struct _NWSTATUS_TO_NTSTATUS {
    NTSTATUS NtStatus;
    NW_STATUS  NwStatus;
} NWSTATUS_TO_NTSTATUS, *LPNWSTATUS_TO_NTSTATUS;

//
// Error mappings for bindery errors
//
NWSTATUS_TO_NTSTATUS MapNtErrors[] =
{
    {STATUS_ACCESS_DENIED,                 NO_OBJECT_READ_PRIVILEGE},
    {STATUS_NO_MORE_ENTRIES,               UNKNOWN_FILE_SERVER},
    {STATUS_NO_MORE_ENTRIES,               NO_SUCH_OBJECT},
    {STATUS_INVALID_PARAMETER,             NO_SUCH_PROPERTY},
    {STATUS_UNSUCCESSFUL,                  INVALID_CONNECTION},
    {STATUS_INSUFF_SERVER_RESOURCES,       SERVER_OUT_OF_MEMORY},
    {STATUS_NO_SUCH_DEVICE,                VOLUME_DOES_NOT_EXIST},
    {STATUS_INVALID_HANDLE,                BAD_DIRECTORY_HANDLE},
    {STATUS_OBJECT_PATH_NOT_FOUND,         INVALID_PATH},
    { 0,                                   0 }
} ;

NTSTATUS
MapNwToNtStatus(
    const NW_STATUS nwstatus
    )
{
    LPNWSTATUS_TO_NTSTATUS pErrorMap ;

    if (nwstatus == SUCCESSFUL)
        return STATUS_SUCCESS;

    pErrorMap = MapNtErrors ;

    while (pErrorMap->NwStatus)
    {
        if (pErrorMap->NwStatus == nwstatus)
            return (pErrorMap->NtStatus) ;
        pErrorMap++ ;
    }
    return STATUS_UNSUCCESSFUL;
}

int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
#ifdef  DBCS
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength * 2 );
#else
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength );
#endif
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
#ifdef  DBCS
                                  StringLength*2,
#else
                                  StringLength,
#endif
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}

LPSTR
AllocateAnsiString(
    LPWSTR  pPrinterName
)
{
    LPSTR  pAnsiString;

    if (!pPrinterName)
        return NULL;

    pAnsiString = (LPSTR)LocalAlloc(LPTR, wcslen(pPrinterName)*sizeof(CHAR) +
                                      sizeof(CHAR));

    if (pAnsiString)
        UnicodeToAnsiString(pPrinterName, pAnsiString, NULL_TERMINATED);

    return pAnsiString;
}

void
FreeAnsiString(
    LPSTR  pAnsiString
    )
{
    if (!pAnsiString)
        return;

    LocalFree(pAnsiString);

    return;
}

int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}

LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}

void
FreeUnicodeString(
    LPWSTR pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\winnt\exchange.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    exchange.c

Abstract:

    Contains routine which packages the request buffer, makes
    the NCP request, and unpackages the response buffer.

Author:

    Hans Hurvig     (hanshu)       Aug-1992  Created
    Colin Watson    (colinw)    19-Dec-1992
    Rita Wong       (ritaw)     11-Mar-1993  FSCtl version

Environment:


Revision History:


--*/


#include <procs.h>

NTSTATUS
GetFileServerVersionInfo(
    HANDLE                DeviceHandle,
    VERSION_INFO NWFAR   *lpVerInfo
    )
{
    NTSTATUS NtStatus ;

    NtStatus = NwlibMakeNcp(
                    DeviceHandle,           // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    3,                      // Max request packet size
                    130,                    // Max response packet size
                    "b|r",                  // Format string
                    // === REQUEST ================================
                    0x11,                   // b Get File Server Information
                    // === REPLY ==================================
                    lpVerInfo,              // r File Version Structure
                    sizeof(VERSION_INFO)
                    );

    // Convert HI-LO words to LO-HI
    // ===========================================================
    lpVerInfo->ConnsSupported = wSWAP( lpVerInfo->ConnsSupported );
    lpVerInfo->connsInUse     = wSWAP( lpVerInfo->connsInUse );
    lpVerInfo->maxVolumes     = wSWAP( lpVerInfo->maxVolumes );
    lpVerInfo->PeakConns      = wSWAP( lpVerInfo->PeakConns );

    return NtStatus;
}


NTSTATUS
NwlibMakeNcp(
    IN HANDLE DeviceHandle,
    IN ULONG FsControlCode,
    IN ULONG RequestBufferSize,
    IN ULONG ResponseBufferSize,
    IN PCHAR FormatString,
    ...                           // Arguments to FormatString
    )
/*++

Routine Description:

    This function converts the input arguments into an NCP request buffer
    based on the format specified in FormatString (e.g. takes a word
    and writes it in hi-lo format in the request buffer as required by
    an NCP).

    It then makes the NCP call via the NtFsControlFile API.

    The FormatString also specifies how to convert the fields in the
    response buffer from the completed NCP call into the output
    arguments.

    The FormatString takes the form of "xxxx|yyyy" where each 'x'
    indicates an input argument to convert from, and each 'y' indicates
    an output argument to convert into.  The '|' character separates
    the input format from the output format specifications.

Arguments:

    DeviceHandle - Supplies a handle to the network file system driver
        which will be making the network request.  This function
        assumes that the handle was opened for synchronouse I/O access.

    FsControlCode - Supplies the control code which determines the
        NCP.

    RequestBufferSize - Supplies the size of the request buffer in
        bytes to be allocated by this routine.

    ResponseBufferSize - Supplies the size of the response buffer in
        bytes to be allocated by this routine.

    FormatString - Supplies an ANSI string which describes how to
       convert from the input arguments into NCP request fields, and
       from the NCP response fields into the output arguments.

         Field types, request/response:

            'b'      byte              ( byte   /  byte* )
            'w'      hi-lo word        ( word   /  word* )
            'd'      hi-lo dword       ( dword  /  dword* )
            '-'      zero/skip byte    ( void )
            '='      zero/skip word    ( void )
            ._.      zero/skip string  ( word )
            'p'      pstring           ( char* )
            'P'      DBCS pstring      ( char* )
            'c'      cstring           ( char* )
            'C'      cstring followed skip word ( char*, word )
            'r'      raw bytes         ( byte*, word )
            'R'      DBCS raw bytes    ( byte*, word )
            'u'      p unicode string  ( UNICODE_STRING * )
            'U'      p uppercase string( UNICODE_STRING * )
            'W'      word n followed by an array of word[n] ( word, word* )

Return Value:

    Return code from the NCP call.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    va_list Arguments;
    PCHAR z;
    WORD t = 1;
    ULONG data_size;

    LPBYTE RequestBuffer = NULL;
    LPBYTE ResponseBuffer;

    IO_STATUS_BLOCK IoStatusBlock;
    DWORD ReturnedDataSize;

    BOOL SpecialCaseChangePass = FALSE;
    BOOL DontFreeBuffer = FALSE;
    BOOL GetVersionInfo = TRUE;
    BOOL DoMapSpecialJapaneseCharThing = TRUE;
    VERSION_INFO VerInfo;

    //
    // Allocate memory for request and response buffers.
    //
    RequestBuffer = LocalAlloc(
                        LMEM_ZEROINIT,
                        RequestBufferSize + ResponseBufferSize + 0x20
                        );

    if (RequestBuffer == NULL) {
        KdPrint(("NWLIB: NwlibMakeNcp LocalAlloc failed %lu\n", GetLastError()));
        return STATUS_NO_MEMORY;
    }

    ResponseBuffer = (LPBYTE) ((ULONG_PTR) RequestBuffer + RequestBufferSize);


    va_start( Arguments, FormatString );

    //
    // Convert the input arguments into request packet.
    //
    z = FormatString;

    data_size = 0;

    while ( *z && *z != '|')
    {
        switch ( *z )
        {
        case '=':
            RequestBuffer[data_size++] = 0;
        case '-':
            RequestBuffer[data_size++] = 0;
            break;

        case '_':
        {
            WORD l = va_arg ( Arguments, WORD );
            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case '_' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }
            while ( l-- )
                RequestBuffer[data_size++] = 0;
            break;
        }

        case 'b':
            RequestBuffer[data_size] = va_arg ( Arguments, BYTE );

            //
            // We know the first va_arg is the subfunction. If the function
            // is FSCTL_NWR_NCP_E3H and the subfunctions are those related
            // the Challenge/SetPass then we need do this special case
            // workaround.
            //
            if ( (z == FormatString) &&
                 (FsControlCode == FSCTL_NWR_NCP_E3H) &&
                 ( (RequestBuffer[data_size] == 0x17) ||
                   (RequestBuffer[data_size] == 0x4B) ) ) {

                SpecialCaseChangePass = TRUE ;
            }
            ++data_size ;
            break;

        case 'w':
        {
            WORD w = va_arg ( Arguments, WORD );
            RequestBuffer[data_size++] = (BYTE) (w >> 8);
            RequestBuffer[data_size++] = (BYTE) (w >> 0);
            break;
        }

        case 'd':
        {
            DWORD d = va_arg ( Arguments, DWORD );
            RequestBuffer[data_size++] = (BYTE) (d >> 24);
            RequestBuffer[data_size++] = (BYTE) (d >> 16);
            RequestBuffer[data_size++] = (BYTE) (d >>  8);
            RequestBuffer[data_size++] = (BYTE) (d >>  0);
            break;
        }

        case 'c':
        {
            char* c = va_arg ( Arguments, char* );
            WORD  l = (WORD)strlen( c );
            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'c' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }
            RtlCopyMemory( &RequestBuffer[data_size], c, l+1 );
            data_size += l + 1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( Arguments, char* );
            WORD l = va_arg ( Arguments, WORD );
            WORD len = strlen( c ) + 1;
            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'C' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RtlCopyMemory( &RequestBuffer[data_size], c, len > l? l : len);
            data_size += l;
            RequestBuffer[data_size-1] = 0;
            break;
        }

        case 'P':
        case 'p':
        {
            char* c = va_arg ( Arguments, char* );
            BYTE  l = (BYTE)strlen( c );
            char* p;

            if (data_size + l > RequestBufferSize)
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'p' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }
            RequestBuffer[data_size++] = l;
            RtlCopyMemory( (p=(char*)&RequestBuffer[data_size]), c, l );
            data_size += l;

            //
            // Map Japanese special chars
            //
            if (*z == 'P')
            {
                if ( GetVersionInfo )
                {
                    status = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( status == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                     MapSpecialJapaneseChars(p, (WORD)l);
                }
            }

            break;
        }

        case 'u':
        {
            PUNICODE_STRING pUString = va_arg ( Arguments, PUNICODE_STRING );
            OEM_STRING OemString;
            ULONG Length;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            if ( data_size + Length > RequestBufferSize ) {
                KdPrint(("NWLIB: NwlibMakeNcp case 'u' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RequestBuffer[data_size++] = (UCHAR)Length;
            OemString.Buffer = &RequestBuffer[data_size];
            OemString.MaximumLength = (USHORT)Length + 1;

            status = RtlUnicodeStringToOemString( &OemString, pUString, FALSE );
            ASSERT( NT_SUCCESS( status ));
            data_size += (USHORT)Length;
            break;
        }

        case 'U':
        {
            //
            //  UPPERCASE the string, copy it from unicode to the packet
            //

            PUNICODE_STRING pUString = va_arg ( Arguments, PUNICODE_STRING );
            UNICODE_STRING UUppercaseString;
            OEM_STRING OemString;
            ULONG Length;

            status = RtlUpcaseUnicodeString(&UUppercaseString, pUString, TRUE);
            if ( status )
            {
                goto CleanExit;
            }

            pUString = &UUppercaseString;

            //
            //  Calculate required string length, excluding trailing NUL.
            //

            Length = RtlUnicodeStringToOemSize( pUString ) - 1;
            ASSERT( Length < 0x100 );

            if ( data_size + Length > RequestBufferSize ) {
                KdPrint(("NWLIB: NwlibMakeNcp case 'U' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RequestBuffer[data_size++] = (UCHAR)Length;
            OemString.Buffer = &RequestBuffer[data_size];
            OemString.MaximumLength = (USHORT)Length + 1;

            status = RtlUnicodeStringToOemString( &OemString, pUString, FALSE );
            ASSERT( NT_SUCCESS( status ));

            RtlFreeUnicodeString( &UUppercaseString );

            data_size += (USHORT)Length;
            break;
        }

        case 'R':
        case 'r':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            WORD  l = va_arg ( Arguments, WORD );
            char* c;

            if ( data_size + l > RequestBufferSize )
            {
                KdPrint(("NWLIB: NwlibMakeNcp case 'r' request buffer too small\n"));
                status = STATUS_BUFFER_TOO_SMALL;
                goto CleanExit;
            }

            RtlCopyMemory( (c=(char*)&RequestBuffer[data_size]), b, l );
            data_size += l;

            //
            // Map Japanese special chars
            //
            if (*z == 'R')
            {
                if ( GetVersionInfo )
                {
                    status = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( status == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                     MapSpecialJapaneseChars(c, (WORD)l);
                }
            }

            break;
        }

        default:
            KdPrint(("NWLIB: NwlibMakeNcp invalid request field, %x\n", *z));
            ASSERT(FALSE);
        }

        if ( data_size > RequestBufferSize )
        {
            KdPrint(("NWLIB: NwlibMakeNcp too much request data\n"));
            status = STATUS_BUFFER_TOO_SMALL;
            goto CleanExit;
        }


        z++;
    }


    //
    // Make the NCP request
    //
    status = NtFsControlFile(
                 DeviceHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FsControlCode,
                 (PVOID) RequestBuffer,
                 RequestBufferSize,
                 (PVOID) ResponseBuffer,
                 ResponseBufferSize
                 );

    if ( (status == STATUS_PENDING) && SpecialCaseChangePass ) {

        //
        // TRACKING - remove this when bug 99008 is fixed in NwRdr.
        // The NwRdr fix is nontrivial.
        //
        // This call is supposed to be synchronous. For some reason, if
        // supplemental credentials are used, it is NOT. Since the redir
        // is already shipped, we workaround it. We do so as follows:
        //
        //    a) give the redir a chance to fill in the buffer (not a real fix)
        //    b) dont free the buffer. its better to leak in this case (not
        //       common) than to trash the heap.
        //    c) set result to success so we will continue.
        //
        Sleep(200) ;
        DontFreeBuffer = TRUE ;
        status = STATUS_SUCCESS ;
    }

    if (status == STATUS_SUCCESS) {
        status = IoStatusBlock.Status;
    }

    if (status != STATUS_SUCCESS) {

#if 0
        if (! NT_SUCCESS(status)) {
            KdPrint(("NWLIB: NwlibMakeNcp: NtFsControlFile returns x%08lx\n", status));
        }
#endif

        goto CleanExit;
    }


    ReturnedDataSize = (DWORD) IoStatusBlock.Information; // Number of bytes returned
                                                          //    in ResponseBuffer


    //
    // Convert the response packet into output arguments.
    //

    data_size = 0;

    if (*z && *z == '|') {
        z++;
    }

    while ( *z )
    {
        switch ( *z )
        {
        case '-':
            data_size += 1;
            break;

        case '=':
            data_size += 2;
            break;

        case '_':
        {
            WORD l = va_arg ( Arguments, WORD );
            data_size += l;
            break;
        }

        case 'b':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            *b = ResponseBuffer[data_size++];
            break;
        }

        case 'w':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            b[1] = ResponseBuffer[data_size++];
            b[0] = ResponseBuffer[data_size++];
            break;
        }

        case 'd':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            b[3] = ResponseBuffer[data_size++];
            b[2] = ResponseBuffer[data_size++];
            b[1] = ResponseBuffer[data_size++];
            b[0] = ResponseBuffer[data_size++];
            break;
        }

        case 'c':
        {
            char* c = va_arg ( Arguments, char* );
            WORD  l = (WORD)strlen( &ResponseBuffer[data_size] );
            if ( data_size+l+1 < ReturnedDataSize ) {
                RtlCopyMemory( c, &ResponseBuffer[data_size], l+1 );
            }
            data_size += l+1;
            break;
        }

        case 'C':
        {
            char* c = va_arg ( Arguments, char* );
            WORD l = va_arg ( Arguments, WORD );
            WORD len = strlen( &ResponseBuffer[data_size] ) + 1;

            if ( data_size + l < ReturnedDataSize ) {
                RtlCopyMemory( c, &ResponseBuffer[data_size], len > l ? l :len);
            }
            c[l-1] = 0;
            data_size += l;
            break;

        }

        case 'P':
        case 'p':
        {
            char* c = va_arg ( Arguments, char* );
            BYTE  l = ResponseBuffer[data_size++];
            if ( data_size+l <= ReturnedDataSize ) {
                RtlCopyMemory( c, &ResponseBuffer[data_size], l );
                c[l] = 0;
            }
            data_size += l;

            //
            // Unmap Japanese special chars
            //
            if (*z == 'P')
            {
                if ( GetVersionInfo )
                {
                    status = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( status == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                    UnmapSpecialJapaneseChars(c, l);
                }
            }

            break;
        }

        case 'R':
        case 'r':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            WORD  l = va_arg ( Arguments, WORD );
            RtlCopyMemory( b, &ResponseBuffer[data_size], l );
            data_size += l;

            //
            // Unmap Japanese special chars
            //
            if (*z == 'R')
            {
                if ( GetVersionInfo )
                {
                    status = GetFileServerVersionInfo( DeviceHandle,
                                                       &VerInfo );

                    GetVersionInfo = FALSE;

                    if ( status == STATUS_SUCCESS )
                    {
                        if ( VerInfo.Version > 3 )
                        {
                            DoMapSpecialJapaneseCharThing = FALSE;
                        }
                    }
                }

                if ( DoMapSpecialJapaneseCharThing )
                {
                    UnmapSpecialJapaneseChars(b, l);
                }
            }
            break;
        }

        case 'W':
        {
            BYTE* b = va_arg ( Arguments, BYTE* );
            BYTE* w = va_arg ( Arguments, BYTE* );
            WORD  i;

            b[1] = ResponseBuffer[data_size++];
            b[0] = ResponseBuffer[data_size++];

            for ( i = 0; i < ((WORD) *b); i++, w += sizeof(WORD) )
            {
                w[1] = ResponseBuffer[data_size++];
                w[0] = ResponseBuffer[data_size++];
            }
            break;
        }

        default:
            KdPrint(("NWLIB: NwlibMakeNcp invalid response field, %x\n", *z));
            ASSERT(FALSE);
        }

        if ( data_size > ReturnedDataSize )
        {
            KdPrint(("NWLIB: NwlibMakeNcp not enough response data\n"));
            status = STATUS_UNSUCCESSFUL;
            goto CleanExit;
        }

        z++;
    }

    status = STATUS_SUCCESS;

CleanExit:
    if ((RequestBuffer != NULL) && !DontFreeBuffer) {
        (void) LocalFree((HLOCAL) RequestBuffer);
    }

    va_end( Arguments );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\winnt\nds32nt.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    Nds32NT.c

Abstract:

    This module implements functions to Read, Add, Modify, and Remove
    NDS Objects and Attributes using the Microsoft Netware redirector.
    All functions in this file are NT specific.
    
Author:

    Glenn Curtis    [GlennC]    04-Jan-1996
    Glenn Curtis    [GlennC]    24-Apr-1996 - Added schema APIs
    Glenn Curtis    [GlennC]    20-Jun-1996 - Added search API
    Felix Wong      [t-felixw]  24-Sep-1996 - Added Win95 Support
--*/

#include <procs.h>

typedef struct
{
    DWORD      Signature;
    HANDLE     NdsTree;
    DWORD      ObjectId;
    DWORD_PTR  ResumeId;
    DWORD_PTR  NdsRawDataBuffer;
    DWORD      NdsRawDataSize;
    DWORD      NdsRawDataId;
    DWORD      NdsRawDataCount;
    WCHAR      Name[1];

} NDS_OBJECT, * LPNDS_OBJECT;

DWORD
GetFirstNdsSubTreeEntry(
    OUT LPNDS_OBJECT lpNdsObject,
    IN  DWORD BufferSize )
{
    NTSTATUS ntstatus;

    lpNdsObject->NdsRawDataSize = BufferSize;

    //
    // Determine size of NDS raw data buffer to use. Set to at least 8KB.
    //
    if ( lpNdsObject->NdsRawDataSize < 8192 )
        lpNdsObject->NdsRawDataSize = 8192;

    //
    // Create NDS raw data buffer.
    //
    lpNdsObject->NdsRawDataBuffer = (DWORD_PTR) LocalAlloc( LMEM_ZEROINIT,
                                                     lpNdsObject->NdsRawDataSize );

    if ( lpNdsObject->NdsRawDataBuffer == 0 )
    {
        KdPrint(("NWWORKSTATION: NwGetFirstNdsSubTreeEntry LocalAlloc Failed %lu\n", GetLastError()));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Set up to get initial NDS subordinate list.
    //
    lpNdsObject->NdsRawDataId = INITIAL_ITERATION;

    ntstatus = NwNdsList( lpNdsObject->NdsTree,
                        lpNdsObject->ObjectId,
                        &lpNdsObject->NdsRawDataId,
                        (LPBYTE) lpNdsObject->NdsRawDataBuffer,
                        lpNdsObject->NdsRawDataSize );

    //
    // If error, clean up the Object and return.
    //
    if ( ntstatus != STATUS_SUCCESS ||
         ((PNDS_RESPONSE_SUBORDINATE_LIST)
             lpNdsObject->NdsRawDataBuffer)->SubordinateEntries == 0 )
    {
        if ( lpNdsObject->NdsRawDataBuffer )
            (void) LocalFree( (HLOCAL) lpNdsObject->NdsRawDataBuffer );
        lpNdsObject->NdsRawDataBuffer = 0;
        lpNdsObject->NdsRawDataSize = 0;
        lpNdsObject->NdsRawDataId = INITIAL_ITERATION;
        lpNdsObject->NdsRawDataCount = 0;
        lpNdsObject->ResumeId = 0;

        return WN_NO_MORE_ENTRIES;
    }

    lpNdsObject->NdsRawDataCount = ((PNDS_RESPONSE_SUBORDINATE_LIST)
                                       lpNdsObject->NdsRawDataBuffer)->SubordinateEntries - 1;

    lpNdsObject->ResumeId = lpNdsObject->NdsRawDataBuffer +
                              sizeof(NDS_RESPONSE_SUBORDINATE_LIST);

    return RtlNtStatusToDosError(ntstatus);
}


DWORD
GetNextNdsSubTreeEntry(
    OUT LPNDS_OBJECT lpNdsObject )
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    PBYTE pbRaw;
    DWORD dwStrLen;

    if ( lpNdsObject->NdsRawDataCount == 0 &&
         lpNdsObject->NdsRawDataId == INITIAL_ITERATION )
        return WN_NO_MORE_ENTRIES;

    if ( lpNdsObject->NdsRawDataCount == 0 &&
         lpNdsObject->NdsRawDataId != INITIAL_ITERATION )
    {
        ntstatus = NwNdsList( lpNdsObject->NdsTree,
                            lpNdsObject->ObjectId,
                            &lpNdsObject->NdsRawDataId,
                            (LPBYTE) lpNdsObject->NdsRawDataBuffer,
                            lpNdsObject->NdsRawDataSize );

        //
        // If error, clean up the Object and return.
        //
        if (ntstatus != STATUS_SUCCESS)
        {
            if ( lpNdsObject->NdsRawDataBuffer )
                (void) LocalFree( (HLOCAL) lpNdsObject->NdsRawDataBuffer );
            lpNdsObject->NdsRawDataBuffer = 0;
            lpNdsObject->NdsRawDataSize = 0;
            lpNdsObject->NdsRawDataId = INITIAL_ITERATION;
            lpNdsObject->NdsRawDataCount = 0;

            return WN_NO_MORE_ENTRIES;
        }

        lpNdsObject->NdsRawDataCount = ((PNDS_RESPONSE_SUBORDINATE_LIST)
                                           lpNdsObject->NdsRawDataBuffer)->SubordinateEntries - 1;

        lpNdsObject->ResumeId = lpNdsObject->NdsRawDataBuffer +
                                  sizeof(NDS_RESPONSE_SUBORDINATE_LIST);

        return RtlNtStatusToDosError(ntstatus);
    }

    lpNdsObject->NdsRawDataCount--;

    //
    // Move pointer past the fixed header portion of a
    // NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    pbRaw = (BYTE *) lpNdsObject->ResumeId;
    pbRaw += sizeof(NDS_RESPONSE_SUBORDINATE_ENTRY);

    //
    // Move pointer past the length value of the Class Name string
    // of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    dwStrLen = * (DWORD *) pbRaw;
    pbRaw += sizeof(DWORD);

    //
    // Move pointer past the Class Name string of a
    // NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    pbRaw += ROUNDUP4( dwStrLen );

    //
    // Move pointer past the length value of the Object Name string
    // of a NDS_RESPONSE_SUBORDINATE_ENTRY
    //
    dwStrLen = * (DWORD *) pbRaw;
    pbRaw += sizeof(DWORD);

    lpNdsObject->ResumeId = (DWORD_PTR) ( pbRaw + ROUNDUP4( dwStrLen ) );

    return RtlNtStatusToDosError(ntstatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\winnt\ndsapint.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    NdsApiNT.c

Abstract:

    This module implements the NT specific exposed user-mode link to
    Netware NDS support in the Netware redirector.  For
    more comments, see ndslib32.h.

Author:

    Cory West    [CoryWest]    23-Feb-1995

--*/

#include <procs.h>

NTSTATUS
NwNdsOpenTreeHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT PHANDLE  phNwRdrHandle
) {

    NTSTATUS ntstatus, OpenStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;

    WCHAR DevicePreamble[] = L"\\Device\\Nwrdr\\";
    UINT PreambleLength = 14;

    WCHAR NameStr[128];
    UNICODE_STRING uOpenName;
    UINT i;

    PNWR_NDS_REQUEST_PACKET Rrp;
    BYTE RrpData[1024];

    //
    // Prepare the open name.
    //

    uOpenName.MaximumLength = sizeof( NameStr );

    for ( i = 0; i < PreambleLength ; i++ )
        NameStr[i] = DevicePreamble[i];

    try {

        for ( i = 0 ; i < ( puNdsTree->Length / sizeof( WCHAR ) ) ; i++ ) {
            NameStr[i + PreambleLength] = puNdsTree->Buffer[i];
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;

    }

    uOpenName.Length = (USHORT)(( i * sizeof( WCHAR ) ) +
                       ( PreambleLength * sizeof( WCHAR ) ));
    uOpenName.Buffer = NameStr;

    //
    // Set up the object attributes.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uOpenName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    ntstatus = NtOpenFile(
                   phNwRdrHandle,
                   DesiredAccess,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    OpenStatus = IoStatusBlock.Status;

    //
    // Verify that this is a tree handle, not a server handle.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET)RrpData;

    Rrp->Version = 0;

    RtlCopyMemory( &(Rrp->Parameters).VerifyTree,
                   puNdsTree,
                   sizeof( UNICODE_STRING ) );

    RtlCopyMemory( (BYTE *)(&(Rrp->Parameters).VerifyTree) + sizeof( UNICODE_STRING ),
                   puNdsTree->Buffer,
                   puNdsTree->Length );

    try {

        ntstatus = NtFsControlFile( *phNwRdrHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_VERIFY_TREE,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ) + puNdsTree->Length,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        ntstatus = GetExceptionCode();
        goto CloseAndExit;
    }

    if ( !NT_SUCCESS( ntstatus )) {
        goto CloseAndExit;
    }

    //
    // Otherwise, all is well!
    //

    return OpenStatus;

CloseAndExit:

    NtClose( *phNwRdrHandle );
    *phNwRdrHandle = NULL;

    return ntstatus;
}

NTSTATUS
NwOpenHandleWithSupplementalCredentials(
    IN PUNICODE_STRING puResourceName,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwHandle
) {

    NTSTATUS ntstatus, OpenStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = FILE_GENERIC_READ | FILE_GENERIC_WRITE;

    WCHAR DevicePreamble[] = L"\\Device\\Nwrdr\\";
    UINT PreambleLength = 14;

    WCHAR NameStr[128];
    UNICODE_STRING uOpenName;
    UINT i;

    PFILE_FULL_EA_INFORMATION pEaEntry;
    PBYTE EaBuffer;
    ULONG EaLength, EaNameLength, EaTotalLength;
    ULONG UserNameLen, PasswordLen, TypeLen, CredLen;

    PNWR_NDS_REQUEST_PACKET Rrp;
    BYTE RrpData[1024];

    //
    // Prepare the open name.
    //

    uOpenName.MaximumLength = sizeof( NameStr );

    for ( i = 0; i < PreambleLength ; i++ )
        NameStr[i] = DevicePreamble[i];

    try {

        for ( i = 0 ; i < ( puResourceName->Length / sizeof( WCHAR ) ) ; i++ ) {
            NameStr[i + PreambleLength] = puResourceName->Buffer[i];
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;

    }

    uOpenName.Length = (USHORT)(( i * sizeof( WCHAR ) ) +
                       ( PreambleLength * sizeof( WCHAR ) ));
    uOpenName.Buffer = NameStr;

    //
    // Set up the object attributes.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uOpenName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    //
    // Allocate the EA buffer - be a little generous.
    //

    UserNameLen = strlen( EA_NAME_USERNAME );
    PasswordLen = strlen( EA_NAME_PASSWORD );
    TypeLen = strlen( EA_NAME_TYPE );
    CredLen = strlen( EA_NAME_CREDENTIAL_EX );

    EaLength = 4 * sizeof( FILE_FULL_EA_INFORMATION );
    EaLength += 4 * sizeof( ULONG );
    EaLength += ROUNDUP4( UserNameLen );
    EaLength += ROUNDUP4( PasswordLen );
    EaLength += ROUNDUP4( TypeLen );
    EaLength += ROUNDUP4( CredLen  );
    EaLength += ROUNDUP4( puUserName->Length );
    EaLength += ROUNDUP4( puPassword->Length );

    EaBuffer = LocalAlloc( LMEM_ZEROINIT, EaLength );

    if ( !EaBuffer ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Pack in the first EA: UserName.
    //

    pEaEntry = (PFILE_FULL_EA_INFORMATION) EaBuffer;

    EaNameLength = UserNameLen + sizeof( CHAR );

    pEaEntry->EaNameLength = (UCHAR) EaNameLength;
    pEaEntry->EaValueLength = puUserName->Length;

    RtlCopyMemory( &(pEaEntry->EaName[0]),
                   EA_NAME_USERNAME,
                   EaNameLength );

    EaNameLength = ROUNDUP2( EaNameLength + sizeof( CHAR ) );

    RtlCopyMemory( &(pEaEntry->EaName[EaNameLength]),
                   puUserName->Buffer,
                   puUserName->Length );

    EaLength = ( 2 * sizeof( DWORD ) ) +
               EaNameLength +
               puUserName->Length;

    EaLength = ROUNDUP4( EaLength );

    EaTotalLength = EaLength;

    pEaEntry->NextEntryOffset = EaLength;

    //
    // Pack in the second EA: Password.
    //

    pEaEntry = (PFILE_FULL_EA_INFORMATION)
               ( ( (PBYTE)pEaEntry ) + pEaEntry->NextEntryOffset );

    EaNameLength = PasswordLen + sizeof( CHAR );

    pEaEntry->EaNameLength = (UCHAR) EaNameLength;
    pEaEntry->EaValueLength = puPassword->Length;

    RtlCopyMemory( &(pEaEntry->EaName[0]),
                   EA_NAME_PASSWORD,
                   EaNameLength );

    EaNameLength = ROUNDUP2( EaNameLength + sizeof( CHAR ) );

    RtlCopyMemory( &(pEaEntry->EaName[EaNameLength]),
                   puPassword->Buffer,
                   puPassword->Length );

    EaLength = ( 2 * sizeof( DWORD ) ) +
               EaNameLength +
               puPassword->Length;

    EaLength = ROUNDUP4( EaLength );

    EaTotalLength += EaLength;

    pEaEntry->NextEntryOffset = EaLength;

    //
    // Pack in the third EA: Type.
    //

    pEaEntry = (PFILE_FULL_EA_INFORMATION)
               ( ( (PBYTE)pEaEntry ) + pEaEntry->NextEntryOffset );

    EaNameLength = TypeLen + sizeof( CHAR );

    pEaEntry->EaNameLength = (UCHAR) EaNameLength;
    pEaEntry->EaValueLength = sizeof( ULONG );

    RtlCopyMemory( &(pEaEntry->EaName[0]),
                   EA_NAME_TYPE,
                   EaNameLength );

    EaNameLength = ROUNDUP2( EaNameLength + sizeof( CHAR ) );

    EaLength = ( 2 * sizeof( DWORD ) ) +
               EaNameLength +
               sizeof( ULONG );

    EaLength = ROUNDUP4( EaLength );

    EaTotalLength += EaLength;

    pEaEntry->NextEntryOffset = EaLength;

    //
    // Pack in the fourth EA: the CredentialEx flag.
    //

    pEaEntry = (PFILE_FULL_EA_INFORMATION)
               ( ( (PBYTE)pEaEntry ) + pEaEntry->NextEntryOffset );

    EaNameLength = CredLen + sizeof( CHAR );

    pEaEntry->EaNameLength = (UCHAR) EaNameLength;
    pEaEntry->EaValueLength = sizeof( ULONG );

    RtlCopyMemory( &(pEaEntry->EaName[0]),
                   EA_NAME_CREDENTIAL_EX,
                   EaNameLength );

    EaNameLength = ROUNDUP2( EaNameLength + sizeof( CHAR ) );

    EaLength = ( 2 * sizeof( DWORD ) ) +
               EaNameLength +
               sizeof( ULONG );

    EaLength = ROUNDUP4( EaLength );
    EaTotalLength += EaLength;

    pEaEntry->NextEntryOffset = 0;

    //
    // Do the open.
    //

    ntstatus = NtCreateFile( phNwHandle,              // File handle (OUT)
                             DesiredAccess,           // Access mask
                             &ObjectAttributes,       // Object attributes
                             &IoStatusBlock,          // Io status
                             NULL,                    // Optional Allocation size
                             FILE_ATTRIBUTE_NORMAL,   // File attributes
                             FILE_SHARE_VALID_FLAGS,  // File share access
                             FILE_OPEN,               // Create disposition
                             0,                       // Create options
                             (PVOID) EaBuffer,        // Our EA buffer
                             EaTotalLength );         // Ea buffer length

    LocalFree( EaBuffer );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    OpenStatus = IoStatusBlock.Status;

    //
    // Check the handle type.
    //

    Rrp = (PNWR_NDS_REQUEST_PACKET)RrpData;

    Rrp->Version = 0;

    RtlCopyMemory( &(Rrp->Parameters).VerifyTree,
                   puResourceName,
                   sizeof( UNICODE_STRING ) );

    RtlCopyMemory( (BYTE *)(&(Rrp->Parameters).VerifyTree) + sizeof( UNICODE_STRING ),
                   puResourceName->Buffer,
                   puResourceName->Length );

    try {

        ntstatus = NtFsControlFile( *phNwHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_VERIFY_TREE,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ) + puResourceName->Length,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        ntstatus = GetExceptionCode();
        goto CloseAndExit2;
    }

    if ( !NT_SUCCESS( ntstatus ))
    {
        *lpdwHandleType = HANDLE_TYPE_NCP_SERVER;
    }
    else
    {
        *lpdwHandleType = HANDLE_TYPE_NDS_TREE;
    }

    return OpenStatus;

CloseAndExit2:

    NtClose( *phNwHandle );
    *phNwHandle = NULL;

    return ntstatus;
}

NTSTATUS
NwNdsResolveName (
    IN HANDLE           hNdsTree,
    IN PUNICODE_STRING  puObjectName,
    OUT DWORD           *dwObjectId,
    OUT PUNICODE_STRING puReferredServer,
    OUT PBYTE           pbRawResponse,
    IN DWORD            dwResponseBufferLen
) {

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    PNDS_RESPONSE_RESOLVE_NAME Rsp;
    DWORD dwRspBufferLen, dwNameLen, dwPadding;

    BYTE RrpData[1024];
    BYTE RspData[256];

    Rrp = (PNWR_NDS_REQUEST_PACKET) RrpData;

    RtlZeroMemory( Rrp, 1024 );

    //
    // NW NDS strings are null terminated, so we make sure we
    // report the correct length...
    //

    dwNameLen = puObjectName->Length + sizeof( WCHAR );

    Rrp->Version = 0;
    Rrp->Parameters.ResolveName.ObjectNameLength = ROUNDUP4( dwNameLen );
    Rrp->Parameters.ResolveName.ResolverFlags = RSLV_DEREF_ALIASES |
                                                RSLV_WALK_TREE |
                                                RSLV_WRITABLE;

    try {

        //
        // But don't try to copy more than the user gave us.
        //

        memcpy( Rrp->Parameters.ResolveName.ObjectName,
                puObjectName->Buffer,
                puObjectName->Length );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Send the request to the Redirector FSD.
    //

    if ( dwResponseBufferLen != 0 &&
         pbRawResponse != NULL ) {

        Rsp = ( PNDS_RESPONSE_RESOLVE_NAME ) pbRawResponse;
        dwRspBufferLen = dwResponseBufferLen;

    } else {

        Rsp = ( PNDS_RESPONSE_RESOLVE_NAME ) RspData;
        dwRspBufferLen = 256;

    }

    try {

        ntstatus = NtFsControlFile( hNdsTree,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_RESOLVE_NAME,
                                    (PVOID) Rrp,
                                    sizeof( NWR_NDS_REQUEST_PACKET ) + Rrp->Parameters.ResolveName.ObjectNameLength,
                                    (PVOID) Rsp,
                                    dwRspBufferLen );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        return GetExceptionCode();
    }

    //
    // Dig out the object id and referred server.
    //

    if ( NT_SUCCESS( ntstatus ) ) {

        try {

            *dwObjectId = Rsp->EntryId;

            if ( Rsp->ServerNameLength > puReferredServer->MaximumLength ) {

                ntstatus = STATUS_BUFFER_TOO_SMALL;

            } else {

                RtlCopyMemory( puReferredServer->Buffer,
                               Rsp->ReferredServer,
                               Rsp->ServerNameLength );

                puReferredServer->Length = (USHORT)Rsp->ServerNameLength;

            }

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            return ntstatus;

        }

    }

    return ntstatus;

}

int
_cdecl
FormatBuf(
    char *buf,
    int bufLen,
    const char *format,
    va_list args
);

int
_cdecl
CalculateBuf(
    const char *format,
    va_list args
);


NTSTATUS
_cdecl
FragExWithWait(
    IN HANDLE  hNdsServer,
    IN DWORD   NdsVerb,
    IN BYTE    *pReplyBuffer,
    IN DWORD   pReplyBufferLen,
    IN OUT DWORD *pdwReplyLen,
    IN BYTE    *NdsRequestStr,
    ...
)
/*

Routine Description:

    Exchanges an NDS request in fragments and collects the fragments
    of the response and writes them to the reply buffer.

Routine Arguments:

    hNdsServer      - A handle to the server you want to talk to.
    NdsVerb         - The verb for that indicates the request.

    pReplyBuffer    - The reply buffer.
    pReplyBufferLen - The length of the reply buffer.

    NdsReqestStr    - The format string for the arguments to this NDS request.
    Arguments       - The arguments that satisfy the NDS format string.

Return Value:

    NTSTATUS - Status of the exchange, but not the result code in the packet.

*/
{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET RawRequest = NULL;

    BYTE  *NdsRequestBuf;
    DWORD NdsRequestLen;
    int   bufferSize = 0;

    va_list Arguments;

    //
    // Allocate a request buffer.
    //

    //
    // Calculate needed buffer size . . .
    //
    if ( NdsRequestStr != NULL ) {

        va_start( Arguments, NdsRequestStr );
        bufferSize = CalculateBuf( NdsRequestStr, Arguments );
        va_end( Arguments );

        if ( bufferSize == 0 )
        {
            Status = STATUS_INVALID_PARAMETER;
            goto ExitWithCleanup;
        }

    }

    bufferSize += sizeof( NWR_NDS_REQUEST_PACKET ) + 50;

    RawRequest = LocalAlloc( LMEM_ZEROINIT, bufferSize );

    if ( !RawRequest ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Build the request in our local buffer.  The first DWORD
    // is the verb and the rest is the formatted request.
    //

    RawRequest->Parameters.RawRequest.NdsVerb = NdsVerb;
    NdsRequestBuf = &RawRequest->Parameters.RawRequest.Request[0];

    if ( NdsRequestStr != NULL ) {

        va_start( Arguments, NdsRequestStr );

        NdsRequestLen = FormatBuf( NdsRequestBuf,
                                   bufferSize - sizeof( NWR_NDS_REQUEST_PACKET ),
                                   NdsRequestStr,
                                   Arguments );

        if ( !NdsRequestLen ) {

           Status = STATUS_INVALID_PARAMETER;
           goto ExitWithCleanup;

        }

        va_end( Arguments );

    } else {

        NdsRequestLen = 0;
    }

    RawRequest->Parameters.RawRequest.RequestLength = NdsRequestLen;

    //
    // Pass this buffer to kernel mode via FSCTL.
    //

    try {

        Status = NtFsControlFile( hNdsServer,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_NWR_NDS_RAW_FRAGEX,
                                  (PVOID) RawRequest,
                                  NdsRequestLen + sizeof( NWR_NDS_REQUEST_PACKET ),
                                  (PVOID) pReplyBuffer,
                                  pReplyBufferLen );

        if ( NT_SUCCESS( Status ) ) {
            *pdwReplyLen = RawRequest->Parameters.RawRequest.ReplyLength;
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
    }

ExitWithCleanup:

    if ( RawRequest ) {
        LocalFree( RawRequest );
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwlib\winnt\nwattach.c ===
/*++

Copyright (C) 1993 Microsoft Corporation

Module Name:

      NWATTACH.C

Abstract:

      This module contains the NetWare(R) SDK support to routines
      into the NetWare redirector

Author:

      Chris Sandys    (a-chrisa)  09-Sep-1993

Revision History:

      Chuck Y. Chan (chuckc)   02/06/94  Moved to NWCS. Make it more NT like.
      Chuck Y. Chan (chuckc)   02/27/94  Clear out old code. 
                                         Make logout work.
                                         Check for error in many places.
                                         Dont hard code strings.
                                         Remove non compatible parameters.
                                         Lotsa other cleanup.
      Felix Wong (t-felixw)    09/16/96  Moved functions for Win95 port.
                                  
--*/


#include "procs.h"
#include "nwapi32.h"
#include <stdio.h>

//
// Define structure for internal use. Our handle passed back from attach to
// file server will be pointer to this. We keep server string around for
// discnnecting from the server on logout. The structure is freed on detach.
// Callers should not use this structure but treat pointer as opaque handle.
//
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;

//
// define define categories of errors
//
typedef enum _NCP_CLASS {
    NcpClassConnect,
    NcpClassBindery,
    NcpClassDir
} NCP_CLASS ;

//
// define error mapping structure
//
typedef struct _NTSTATUS_TO_NCP {
    NTSTATUS NtStatus ;
    NWCCODE  NcpCode  ;
} NTSTATUS_TO_NCP, *LPNTSTATUS_TO_NCP ;
    
NWCCODE
MapNtStatus(
    const NTSTATUS ntstatus,
    const NCP_CLASS ncpclass
);

DWORD
SetWin32ErrorFromNtStatus(
    NTSTATUS NtStatus
) ;
DWORD
szToWide(
    LPWSTR lpszW,
    LPCSTR lpszC,
    INT nSize
);
//
// Forwards
//
NTSTATUS 
NwAttachToServer(
    LPWSTR      ServerName,
    LPHANDLE    phandleServer
    );

NTSTATUS 
NwDetachFromServer(
      HANDLE    handleServer
);

NWCCODE NWAPI DLLEXPORT
NWAttachToFileServer(
    const char      NWFAR   *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE   NWFAR   *phNewConn
    )
{
    DWORD            dwRes;
    NWCCODE          nwRes;
    LPWSTR           lpwszServerName;   // Pointer to buffer for WIDE servername
    int              nSize;
    PNWC_SERVER_INFO pServerInfo ;


    //
    // check parameters and init return result to be null.
    //
    if (!pszServerName || !phNewConn)
        return INVALID_CONNECTION ;

    *phNewConn = NULL ; 

    //
    // Allocate a buffer for wide server name 
    //
    nSize = strlen(pszServerName)+1 ;
    if(!(lpwszServerName = (LPWSTR) LocalAlloc( 
                                        LPTR, 
                                        nSize * sizeof(WCHAR) ))) 
    {
        nwRes =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    if (szToWide( lpwszServerName, pszServerName, nSize ) != NO_ERROR)
    {
        nwRes =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }

    //
    // Call createfile to get a handle for the redirector calls
    //
    nwRes = NWAttachToFileServerW( lpwszServerName, 
                                   ScopeFlag,
                                   phNewConn );


ExitPoint: 

    //
    // Free the memory allocated above before exiting
    //
    if (lpwszServerName)
        (void) LocalFree( (HLOCAL) lpwszServerName );

    //
    // Return with NWCCODE
    //
    return( nwRes );
}


NWCCODE NWAPI DLLEXPORT
NWAttachToFileServerW(
    const WCHAR     NWFAR   *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE   NWFAR   *phNewConn
    )
{
    DWORD            NtStatus;
    NWCCODE          nwRes;
    LPWSTR           lpwszServerName;   // Pointer to buffer for WIDE servername
    int              nSize;
    PNWC_SERVER_INFO pServerInfo = NULL;

    UNREFERENCED_PARAMETER(ScopeFlag) ;

    //
    // check parameters and init return result to be null.
    //
    if (!pszServerName || !phNewConn)
        return INVALID_CONNECTION ;

    *phNewConn = NULL ; 

    //
    // Allocate a buffer to store the file server name 
    //
    nSize = wcslen(pszServerName)+3 ;
    if(!(lpwszServerName = (LPWSTR) LocalAlloc( 
                                        LPTR, 
                                        nSize * sizeof(WCHAR) ))) 
    {
        nwRes =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    wcscpy( lpwszServerName, L"\\\\" );
    wcscat( lpwszServerName, pszServerName );

    //
    // Allocate a buffer for the server info (handle + name pointer). Also
    // init the unicode string.
    //
    if( !(pServerInfo = (PNWC_SERVER_INFO) LocalAlloc( 
                                              LPTR, 
                                              sizeof(NWC_SERVER_INFO))) ) 
    {
        nwRes =  REQUESTER_ERROR ;
        goto ExitPoint ;
    }
    RtlInitUnicodeString(&pServerInfo->ServerString, lpwszServerName) ;

    //
    // Call createfile to get a handle for the redirector calls
    //
    NtStatus = NwAttachToServer( lpwszServerName, &pServerInfo->hConn );

    if(NT_SUCCESS(NtStatus))
    {
        nwRes = SUCCESSFUL;
    } 
    else 
    {
        (void) SetWin32ErrorFromNtStatus( NtStatus );
        nwRes = MapNtStatus( NtStatus, NcpClassConnect );
    }

ExitPoint: 

    //
    // Free the memory allocated above before exiting
    //
    if (nwRes != SUCCESSFUL)
    {
        if (lpwszServerName)
            (void) LocalFree( (HLOCAL) lpwszServerName );
        if (pServerInfo)
            (void) LocalFree( (HLOCAL) pServerInfo );
    }
    else
        *phNewConn  = (HANDLE) pServerInfo ;

    //
    // Return with NWCCODE
    //
    return( nwRes );
}


NWCCODE NWAPI DLLEXPORT
NWDetachFromFileServer(
    NWCONN_HANDLE           hConn
    )
{
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)hConn ; 

    (void) NwDetachFromServer( pServerInfo->hConn );

    (void) LocalFree (pServerInfo->ServerString.Buffer) ;

    //
    // catch any body that still trirs to use this puppy...
    //
    pServerInfo->ServerString.Buffer = NULL ;   
    pServerInfo->hConn = NULL ;

    (void) LocalFree (pServerInfo) ;

    return SUCCESSFUL;
}



//
// worker routines
//

#define NW_RDR_SERVER_PREFIX L"\\Device\\Nwrdr\\"

NTSTATUS
NwAttachToServer(
    IN  LPWSTR  ServerName,
    OUT LPHANDLE phandleServer
    )
/*++

Routine Description:

    This routine opens a handle to the given server.

Arguments:

    ServerName    - The server name to attach to.
    phandleServer - Receives an opened handle to the preferred or
                    nearest server.

Return Value:

    0 or reason for failure.

--*/
{
    NTSTATUS            ntstatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    LPWSTR FullName;
    UNICODE_STRING UServerName;

    FullName = (LPWSTR) LocalAlloc( LMEM_ZEROINIT,
                                    (UINT) ( wcslen( NW_RDR_SERVER_PREFIX) +
                                             wcslen( ServerName ) - 1) *
                                             sizeof(WCHAR)
                                  );

    if ( FullName == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES ;
    }

    wcscpy( FullName, NW_RDR_SERVER_PREFIX );
    wcscat( FullName, ServerName + 2 );    // Skip past the prefix "\\"

    RtlInitUnicodeString( &UServerName, FullName );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UServerName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open a handle to the preferred server.
    //
    ntstatus = NtOpenFile(
                   phandleServer,
                   SYNCHRONIZE | FILE_LIST_DIRECTORY,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if ( NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        *phandleServer = NULL;
    }

    LocalFree( FullName );
    return (ntstatus);
}


NTSTATUS
NwDetachFromServer(
    IN HANDLE handleServer
    )
/*++

Routine Description:

    This routine closes a handle to the given server.

Arguments:

    handleServer - Supplies a open handle to be closed.

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    NTSTATUS ntstatus = NtClose( handleServer );
    return (ntstatus);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\break.c ===
/*************************************************************************
*
*  BREAK.C
*
*  Control-C and Control-Break routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\BREAK.C  $
*  
*     Rev 1.2   10 Apr 1996 14:21:38   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:52:16   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:23:38   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:28   terryt
*  Initial revision.
*  
*     Rev 1.0   15 May 1995 19:10:14   terryt
*  Initial revision.
*  
*************************************************************************/
#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "nwscript.h"
#include "ntnw.h"


/*
 *  Handler for console events
 */
BOOL WINAPI
Handler( DWORD CtrlType )
{
    if ( CtrlType & ( CTRL_C_EVENT | CTRL_BREAK_EVENT ) )
        return TRUE;  /* don't execute default handler */
    else
        return FALSE;
}

/*
 * NTBreakOn
 *
 * Routine Description:
 *
 *       Allow Ctrl+C and Ctrl+Break during logon script
 *
 * Arguments:
 *    none
 *
 * Return Value:
 *    none
 */
void NTBreakOn( void )
{
    (void) SetConsoleCtrlHandler( &Handler, FALSE );
}

/*
 * NTBreakOff
 *
 * Routine Description:
 *
 *       Prevent Ctrl+C and Ctrl+Break during logon script
 *
 * Arguments:
 *    none
 *
 * Return Value:
 *    none
 */
void NTBreakOff( void )
{
    (void) SetConsoleCtrlHandler( &Handler, TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\attach.c ===
/*************************************************************************
*
*  ATTACH.C
*
*  NT Attach routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\ATTACH.C  $
*  
*     Rev 1.2   10 Apr 1996 14:21:30   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:52:08   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:23:32   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:26   terryt
*  Initial revision.
*  
*     Rev 1.1   23 May 1995 19:36:30   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:10:10   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <nwapi32.h>
#include <ntddnwfs.h>
#include <nwapi.h>
#include <npapi.h>

#include "inc/common.h"
#include "ntnw.h"

/********************************************************************

        GetDefaultConnectionID

Routine Description:

        Return the default connection ID ( the "preferred server" )

Arguments:

        phNewConn - pointer to connection number

Return Value:
        0 = success
        else NetWare error number

 *******************************************************************/
unsigned int
GetDefaultConnectionID(
    unsigned int   *phNewConn
    )
{
    VERSION_INFO VerInfo;
    unsigned int Result;

    if ( fNDS ) 
    {
        Result = NTAttachToFileServer( NDSTREE, phNewConn );
    }
    else 
    {
        //
        //  "*" is the name for the preferred server
        //
        Result = NTAttachToFileServer( "*", phNewConn );
        if ( Result )
            return Result;

        Result = NWGetFileServerVersionInfo( (NWCONN_HANDLE)*phNewConn,
                                         &VerInfo );
        if ( Result )
            return Result;

        NWDetachFromFileServer( (NWCONN_HANDLE)*phNewConn );

        Result = NTAttachToFileServer( VerInfo.szName, phNewConn );
    }
    return Result;

}

/********************************************************************

        NTAttachToFileServer

Routine Description:

        Given a server name, return a connection handle.
        We need our own because NWAPI32 does it's own mapping
        of errors.

Arguments:

        pszServerName - Ascii server name
        phNewConn     - pointer to connection handle

Return Value:
        0 = success
        else NetWare error number

 *******************************************************************/
unsigned int
NTAttachToFileServer(
    unsigned char  *pszServerName,
    unsigned int   *phNewConn
    )
{
    return ( NWAttachToFileServer( pszServerName, 0,
                                   (NWCONN_HANDLE *)phNewConn ) );
}


/********************************************************************

        NTIsConnected

Routine Description:

        Given a server name, is there already a connection to it?

Arguments:

        pszServerName - ascii server name

Return Value:
        TRUE  - a connection to the server exists
        FALSE - a connection to the server does not exist

 *******************************************************************/
unsigned int
NTIsConnected( unsigned char * pszServerName )
{
    LPBYTE       Buffer ; 
    DWORD        dwErr ;
    HANDLE       EnumHandle ;
    DWORD        Count ;
    LPWSTR       pszServerNameW;
    INT          nSize;
    DWORD        BufferSize = 4096;

    nSize = (strlen( pszServerName ) + 1 + 2) * sizeof( WCHAR );
    
    //
    // allocate memory and open the enumeration
    //
    if (!(pszServerNameW = LocalAlloc( LPTR, nSize ))) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    wcscpy( pszServerNameW, L"\\\\" );
    szToWide( pszServerNameW + 2, pszServerName, nSize );
 
    //
    // allocate memory and open the enumeration
    //
    if (!(Buffer = LocalAlloc( LPTR, BufferSize ))) {
        (void) LocalFree((HLOCAL) pszServerNameW) ;
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    memset( Buffer, 0, BufferSize );

    dwErr = NPOpenEnum(RESOURCE_CONNECTED, 0, 0, NULL, &EnumHandle) ;
    if (dwErr != WN_SUCCESS) {
        (void) LocalFree((HLOCAL) pszServerNameW) ;
        (void) LocalFree((HLOCAL) Buffer) ;
        return FALSE;
    }

    do {

        Count = 0xFFFFFFFF ;
        BufferSize = 4096;
        dwErr = NwEnumConnections(EnumHandle, &Count, Buffer, &BufferSize, TRUE) ;

        if ((dwErr == WN_SUCCESS || dwErr == WN_NO_MORE_ENTRIES)
            && ( Count != 0xFFFFFFFF) )
        {
            LPNETRESOURCE lpNetResource ;
            DWORD i ;
            DWORD ServerLen;

            ServerLen = wcslen( pszServerNameW );
            lpNetResource = (LPNETRESOURCE) Buffer ;
            //
            // search for our server
            //
            for ( i = 0; i < Count; lpNetResource++, i++ )
            {
              if ( lpNetResource->lpProvider )
                  if ( _wcsicmp( lpNetResource->lpProvider, NW_PROVIDER ) ) {
                      continue;
                  }
               if ( lpNetResource->lpRemoteName ) {
                   if ( wcslen(lpNetResource->lpRemoteName) > ServerLen ) {
                       if ( lpNetResource->lpRemoteName[ServerLen] == L'\\' ) 
                           lpNetResource->lpRemoteName[ServerLen] = L'\0';
                   }
                   if ( !_wcsicmp(lpNetResource->lpRemoteName, pszServerNameW )) {
                       (void) WNetCloseEnum(EnumHandle) ; 
                       (void) LocalFree((HLOCAL) pszServerNameW) ;
                       (void) LocalFree((HLOCAL) Buffer) ;
                       return TRUE;
                   }
               }
            }

        }

    } while (dwErr == WN_SUCCESS) ;

    (void ) WNetCloseEnum(EnumHandle) ;
    (void) LocalFree((HLOCAL) pszServerNameW) ;
    (void) LocalFree((HLOCAL) Buffer) ;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\capture.c ===
/*
 * Module Name:
 *        capture.c
 *  Copyright (c) 1995 Microsoft Corporation
 * 
 * Abstract:
 * 
 *      SYNTAX (Command line)
 *                 - Usage:  Capture [/Options]
 * 
 * Author : Congpa You (Congpay)
 * 
 * Revision history :
 *       - 05/24/94      congpay     Created
 */

#include "common.h"

extern char *RemoveSpaces (char * buffer);

typedef struct _CAPTURE_PARAMS {
    UCHAR nLPT;
    char serverName[MAX_NAME_LEN];
    char queueName[MAX_QUEUE_NAME_LEN];
    char bannerUserName[MAX_BANNER_USER_NAME];
    char filePath[_MAX_PATH];
    unsigned int NDSCapture;
    NETWARE_CAPTURE_FLAGS_RW captureFlagsRW;
}CAPTURE_PARAMS, *PCAPTURE_PARAMS;

/* Local Functions*/
void UpcaseArg(int argc, char ** argv);
int  IsShowOption (int argc, char ** argv);
int  IsServerSpecified (int argc, char ** argv);
int  IsNoOption (char * option);
int  IsQuestionMark (int argc, char ** argv);
int  IsValidOption (char *input, char *option, char *shortoption);
void ShowCapture(void);

void GetJobNameFromArg (int argc, char ** argv, char *jobName);

int  InitCaptureParams (unsigned int conn,
                        char *jobName,
                        PCAPTURE_PARAMS pCaptureParams);

int  ReadArguments (int argc,
                    char ** argv,
                    char *jobName,
                    PCAPTURE_PARAMS pCaptureParams);

int  CStartCapture(unsigned int conn,
                   PCAPTURE_PARAMS pCaptureParams);

int GetPrinterDefaultQueue( PCAPTURE_PARAMS, PBYTE );

void
Capture (char ** argv, unsigned int argc)
{
    char jobName[MAX_JOB_NAME_LEN]="";
    CAPTURE_PARAMS captureParams;
    unsigned int conn;

    UpcaseArg(argc, argv);

    memset( (PBYTE)&captureParams, 0, sizeof(captureParams) );

    captureParams.nLPT = 0;
    captureParams.serverName[0] = 0;
    captureParams.queueName[0] = 0;
    captureParams.bannerUserName[0] = 0;
    captureParams.filePath[0] = 0;

    if ( fNDS )
    {
       captureParams.NDSCapture = TRUE;
    }
    else 
    {
       captureParams.NDSCapture = FALSE;
    }

    if ( IsServerSpecified( argc, argv ) ) 
       captureParams.NDSCapture = FALSE;

    // If the option is show, show the current capture settings.
    if (IsShowOption (argc, argv))
    {
        ShowCapture();
        return;
    }

    // If the option is ?, show the usage.
    if (IsQuestionMark(argc, argv))
    {
        DisplayMessage(IDR_CAPTURE_USAGE);
        return;
    }

    // If /Job=jobname is in the parameter, get the jobname.
    GetJobNameFromArg (argc, argv, jobName);

    if (!CGetDefaultConnectionID (&conn) ||
        !InitCaptureParams (conn, jobName, &captureParams) ||
        !ReadArguments (argc,
                        argv,
                        jobName,
                        &captureParams))
        return;

    // Terminate old capture.
    EndCapture ((unsigned char) captureParams.nLPT);

    (void) CStartCapture(conn, &captureParams);
    return;
}

void UpcaseArg(int argc, char ** argv)
{
    int i;
    for (i = 0; i < argc ; i++)
        _strupr (argv[i]);
}

/*
    Return TRUE if input is /Show option.
    FALSE otherwise.
 */
int  IsShowOption (int argc,char ** argv)
{
    int bIsShowOption = FALSE;
    char * p;

    if (argc == 2)
    {
        p = argv[1];
        while ((*p == '/') || (*p == '\\') || (*p == '-'))
            p++;

        if (!strncmp (p, __SHOW__, max (2, strlen(p))))
            bIsShowOption = TRUE;
    }

    return(bIsShowOption);
}

/*
    Return TRUE if input is /? option.
    FALSE otherwise.
 */
int  IsQuestionMark (int argc, char ** argv)
{
    int bIsQuestionMark = FALSE;
    char * p;

    if (argc == 2)
    {
        p = argv[1];
        while ((*p == '/') || (*p == '\\') || (*p == '-'))
            p++;

        if (*p == '?')
            bIsQuestionMark = TRUE;
    }

    return(bIsQuestionMark);
}

int  IsNoOption (char * option)
{
    int bIsNoOption = FALSE;
    char * p;

    p = option;
    while ((*p == '/') || (*p == '\\') || (*p == '-'))
        p++;

    if (!strncmp (p, __OPT_NO__, max (1, strlen(p))))
        bIsNoOption = TRUE;

    return(bIsNoOption);
}

/*
    Return TRUE if the input match option or shortoption.
    FALSE otherwise.
 */
int  IsValidOption (char *input, char *option, char *shortoption)
{
    int bValideInput = FALSE;

    while ((*input == '/') || (*input == '\\') || (*input == '-'))
        input++;

    if (!strcmp (input, shortoption))
    {
        bValideInput = TRUE;
    }
    else if (!strcmp (input, option))
    {
        bValideInput = TRUE;
    }

    return(bValideInput);
}

void GetJobNameFromArg (int argc, char ** argv, char *jobName)
{
    int i;
    char *pEqual;

    for (i = 0; i < argc; i++)
    {
        if (pEqual = strchr (argv[i], '='))
        {
            *pEqual = 0;

            if (IsValidOption (argv[i], __JOB__, __SHORT_FOR_JOB__) &&
                *(pEqual+1) != 0 &&
                strlen (pEqual+1) < MAX_JOB_NAME_LEN)
                strcpy (jobName, pEqual+1);

            *pEqual = '=';
        }
    }

    return;
}

int IsServerSpecified (int argc, char ** argv)
{
    int i;

    for (i = 0; i < argc; i++)
    {
        if (IsValidOption (argv[i], __SERVER__, __SHORT_FOR_SERVER__))
            return TRUE;
    }

    return FALSE;

}

/*
    Initialize the capture flags with job config or default value.
 */
int  InitCaptureParams (unsigned int conn,
                        char *jobName,
                        PCAPTURE_PARAMS pCaptureParams)
{
    PS_JOB_RECORD            psJobRecord;
    unsigned int iRet = 0;

    // Get job configuration.
    if (jobName[0] == 0)
    {
        // Get Default Job Name.
        if ( Is40Server( conn ) )
        {
            iRet = PS40JobGetDefault(  pCaptureParams->NDSCapture,
                                       0,
                                       NULL,
                                       jobName,
                                       &psJobRecord );
        }
        else 
        {
            iRet = PSJobGetDefault( conn,
                                    0,
                                    NULL,
                                    jobName,
                                    &psJobRecord );
        }

        if ( iRet )
        {
            if (iRet == PS_ERR_OPENING_DB || iRet == PS_ERR_GETTING_DEFAULT)
            {
                pCaptureParams->nLPT = 1;
                pCaptureParams->bannerUserName[0]=0;
                pCaptureParams->serverName[0]=0;
                pCaptureParams->queueName[0]=0;
                pCaptureParams->filePath[0]=0;

                pCaptureParams->captureFlagsRW.JobControlFlags = 0;
                pCaptureParams->captureFlagsRW.TabSize = 8;
                pCaptureParams->captureFlagsRW.NumCopies = 1;
                pCaptureParams->captureFlagsRW.PrintFlags = DEFAULT_PRINT_FLAGS;
                pCaptureParams->captureFlagsRW.FormName[0] = 0;
                pCaptureParams->captureFlagsRW.FormType = 0;
                pCaptureParams->captureFlagsRW.FlushCaptureTimeout = 0;
                pCaptureParams->captureFlagsRW.FlushCaptureOnClose = 0;

                strcpy (pCaptureParams->captureFlagsRW.BannerText, DEFAULT_BANNER_TEXT);
                return(TRUE);
            }
            else
            {
                DisplayError (iRet, "PSJobGetDefault");
                return(FALSE);
            }
        }
    }
    else
    {
        if ( Is40Server( conn ) )
        {
            iRet = PS40JobRead(  pCaptureParams->NDSCapture,
                                 NULL,
                                 jobName,
                                 &psJobRecord);
        }
        else
        {
            iRet = PSJobRead(conn,
                             NULL,
                             jobName,
                             &psJobRecord);
        }
        if ( iRet )
        {
            if ( ( iRet == PS_ERR_READING_RECORD) ||
                 ( iRet == PS_ERR_OPENING_DB) )
                DisplayMessage(IDR_JOB_NOT_FOUND, jobName);
            else
                DisplayError (iRet, "PSJobRead");
            return(FALSE);
        }
    }

    pCaptureParams->captureFlagsRW.JobControlFlags = 0;
    pCaptureParams->captureFlagsRW.TabSize = psJobRecord.TabSize;
    pCaptureParams->captureFlagsRW.NumCopies = psJobRecord.Copies;

    pCaptureParams->captureFlagsRW.PrintFlags =
        ((psJobRecord.PrintJobFlag & PS_JOB_EXPAND_TABS)? 0 : CAPTURE_FLAG_EXPAND_TABS)
       +((psJobRecord.PrintJobFlag & PS_JOB_NO_FORMFEED)? CAPTURE_FLAG_NO_FORMFEED : 0)
       +((psJobRecord.PrintJobFlag & PS_JOB_NOTIFY)? CAPTURE_FLAG_NOTIFY : 0)
       +((psJobRecord.PrintJobFlag & PS_JOB_PRINT_BANNER)? CAPTURE_FLAG_PRINT_BANNER : 0);

    pCaptureParams->captureFlagsRW.FormType = 0;
    pCaptureParams->captureFlagsRW.FlushCaptureTimeout = psJobRecord.TimeOutCount;
    pCaptureParams->captureFlagsRW.FlushCaptureOnClose = !(psJobRecord.PrintJobFlag & PS_JOB_AUTO_END);

    strcpy (pCaptureParams->captureFlagsRW.FormName, psJobRecord.FormName);
    strcpy (pCaptureParams->captureFlagsRW.BannerText, (psJobRecord.BannerName[0] == 0)? DEFAULT_BANNER_TEXT : psJobRecord.BannerName);

    pCaptureParams->nLPT = psJobRecord.LocalPrinter;
    strcpy (pCaptureParams->bannerUserName, psJobRecord.Name);
    if ( psJobRecord.PrintJobFlag & PS_JOB_ENV_DS ) {
        strcpy (pCaptureParams->serverName, "");
        if ( psJobRecord.PrintJobFlag & PS_JOB_DS_PRINTER ) 
            GetPrinterDefaultQueue( pCaptureParams, psJobRecord.u.DSObjectName );
        else
            strcpy (pCaptureParams->queueName, psJobRecord.u.DSObjectName );
    }
    else {
        strcpy (pCaptureParams->serverName, psJobRecord.u.NonDS.FileServer);
        strcpy (pCaptureParams->queueName, psJobRecord.u.NonDS.PrintQueue);
    }
    pCaptureParams->filePath[0]=0;

    return(TRUE);
}

int ReadArguments (int argc,
                   char ** argv,
                   char *jobName,
                   PCAPTURE_PARAMS pCaptureParams)
{
    int i, fValidOption = TRUE, fValidParam = TRUE;
    char *pEqual = NULL;

    for (i = 1; i < argc; i++)
    {
        if (IsNoOption(argv[i]))
        {
            if (i != argc - 1)
            {
                i++;

                if (IsValidOption (argv[i], __NOTIFY__, __SHORT_FOR_NOTIFY__))
                {
                    pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF-CAPTURE_FLAG_NOTIFY);
                }
                else if (IsValidOption (argv[i], __AUTOENDCAP__, __SHORT_FOR_AUTOENDCAP__))
                {
                    pCaptureParams->captureFlagsRW.FlushCaptureOnClose = 1;
                }
                else if (IsValidOption (argv[i], __TABS__, __SHORT_FOR_TABS__))
                {
                    pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_EXPAND_TABS);
                }
                else if (IsValidOption (argv[i], __BANNER__, __SHORT_FOR_BANNER__))
                {
                    pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_PRINT_BANNER);
                }
                else if (IsValidOption (argv[i], __FORMFEED__, __SHORT_FOR_FORMFEED__))
                {
                    pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_NO_FORMFEED;
                }
                else
                {
                    i--;
                    fValidOption = FALSE;
                    break;
                }
            }
            else
            {
                fValidOption = FALSE;
                break;
            }
        }
        else if (IsValidOption (argv[i], __NOTIFY__, __SHORT_FOR_NOTIFY__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_NOTIFY;
        }
        else if (IsValidOption (argv[i], __NONOTIFY__, __SHORT_FOR_NONOTIFY__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_NOTIFY);
        }
        else if (IsValidOption (argv[i], __AUTOENDCAP__, __SHORT_FOR_AUTOENDCAP__))
        {
            pCaptureParams->captureFlagsRW.FlushCaptureOnClose = 0;
        }
        else if (IsValidOption (argv[i], __NOAUTOENDCAP__, __SHORT_FOR_NOAUTOENDCAP__))
        {
            pCaptureParams->captureFlagsRW.FlushCaptureOnClose = 1;
        }
        else if (IsValidOption (argv[i], __NOTABS__, __SHORT_FOR_NOTABS__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_EXPAND_TABS);
        }
        else if (IsValidOption (argv[i], __NOBANNER__, __SHORT_FOR_NOBANNER__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_PRINT_BANNER);
        }
        else if (IsValidOption (argv[i], __FORMFEED__, __SHORT_FOR_FORMFEED__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags &= (0xFF - CAPTURE_FLAG_NO_FORMFEED);
        }
        else if (IsValidOption (argv[i], __NOFORMFEED__, __SHORT_FOR_NOFORMFEED__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_NO_FORMFEED;
        }
        else if (IsValidOption (argv[i], __KEEP__, __SHORT_FOR_KEEP__))
        {
            pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_KEEP;
        }
        else
        {
            // All other valid options should have '=' sign in it.
            // Except for LX LPX LPTX
            //
            pEqual = strchr (argv[i], '=');

            // Optionally a ':' works too
            if (pEqual == NULL ) {
                pEqual = strchr (argv[i], ':');
            }

            if (pEqual != NULL)
                *pEqual = 0;

            if (IsValidOption (argv[i], __TIMEOUT__, __SHORT_FOR_TIMEOUT__))
            {
                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_TIME_OUT_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->captureFlagsRW.FlushCaptureTimeout = (USHORT) atoi (pEqual+1);

                if (pCaptureParams->captureFlagsRW.FlushCaptureTimeout > 1000)
                {
                    DisplayMessage(IDR_TIMEOUT_OUTOF_RANGE);
                    fValidParam = FALSE;
                    break;
                }
            }
            else if (IsValidOption (argv[i], __LOCAL__, __SHORT_FOR_LOCAL__))
            {
                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_LPT_NUMBER_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->nLPT = (unsigned char) atoi (pEqual+1);

                if (pCaptureParams->nLPT < 1 || pCaptureParams->nLPT > 3)
                {
                    DisplayMessage(IDR_INVALID_LPT_NUMBER);
                    fValidParam = FALSE;
                    break;
                }
            }
            else if (IsValidOption (argv[i], __LOCAL_3__, __LOCAL_2__))
            {
                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_LPT_NUMBER_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->nLPT = (unsigned char) atoi (pEqual+1);

                if (pCaptureParams->nLPT < 1 || pCaptureParams->nLPT > 3)
                {
                    DisplayMessage(IDR_INVALID_LPT_NUMBER);
                    fValidParam = FALSE;
                    break;
                }
            }
            else if (IsValidOption (argv[i], __JOB__, __SHORT_FOR_JOB__))
            {
                if (pEqual == NULL ||
                    *(pEqual+1) == 0 ||
                    strlen (pEqual+1) > MAX_JOB_NAME_LEN - 1)
                {
                    fValidOption = FALSE;
                    break;
                }
                strcpy (jobName, pEqual+1);
            }
            else if (IsValidOption (argv[i], __SERVER__, __SHORT_FOR_SERVER__))
            {
                if (pEqual == NULL ||
                    *(pEqual+1) == 0 ||
                    strlen (pEqual+1) > MAX_NAME_LEN - 1)
                {
                    fValidOption = FALSE;
                    break;
                }
                pCaptureParams->NDSCapture = FALSE;
                strcpy (pCaptureParams->serverName, pEqual+1);
            }
            else if (IsValidOption (argv[i], __QUEUE__, __SHORT_FOR_QUEUE__))
            {
                if (pEqual == NULL ||
                    *(pEqual+1) == 0 ||
                    strlen (pEqual+1) > MAX_QUEUE_NAME_LEN - 1) //compatible.
                {
                    fValidOption = FALSE;
                    break;
                }
                strcpy (pCaptureParams->queueName, pEqual+1);
            }
            else if (IsValidOption (argv[i], __PRINTER__, __SHORT_FOR_PRINTER__))
            {
                if (pEqual == NULL ||
                    *(pEqual+1) == 0 ||
                    !pCaptureParams->NDSCapture ||
                    strlen (pEqual+1) > MAX_QUEUE_NAME_LEN - 1) //compatible.
                {
                    fValidOption = FALSE;
                    break;
                }
                GetPrinterDefaultQueue( pCaptureParams, pEqual+1 );
            }
            else if (IsValidOption (argv[i], __CREATE__, __SHORT_FOR_CREATE__))
            {
                if (pEqual != NULL)  //compatible.
                {
                    if (strlen (pEqual+1) > _MAX_PATH - 1)
                    {
                        DisplayMessage(IDR_INVALID_PATH_NAME, pEqual+1);
                        fValidParam = FALSE;
                        break;
                    }
                    strcpy (pCaptureParams->filePath, pEqual+1);
                }
            }
            else if (IsValidOption (argv[i], __FORM__, __SHORT_FOR_FORM__))
            {
                int j = 1;
                int bAllNumbers = TRUE;

                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_FORM_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                if (strlen (pEqual+1) > 3) // Only allow 3 digits number.
                {
                    DisplayMessage(IDR_INVALID_FORM_NAME, pEqual+1);
                    fValidParam = FALSE;
                    break;
                }

                while (*(pEqual+j) != 0)
                {
                    if (!isdigit (*(pEqual+j)))
                    {
                        bAllNumbers = FALSE;
                        break;
                    }
                    j++;
                }

                if (bAllNumbers)
                {
                    pCaptureParams->captureFlagsRW.FormType = (USHORT) atoi (pEqual+1);

                    if (pCaptureParams->captureFlagsRW.FormType > 255)
                    {
                        DisplayMessage(IDR_INVALID_FORM_TYPE);
                        fValidParam = FALSE;
                        break;
                    }
                }
                else
                {
                    DisplayMessage(IDR_INVALID_FORM_NAME, pEqual+1);
                    fValidParam = FALSE;
                    break;
                }
            }
            else if (IsValidOption (argv[i], __COPIES__, __SHORT_FOR_COPIES__))
            {
                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_COPIES_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->captureFlagsRW.NumCopies = (USHORT) atoi (pEqual+1);

                if (pCaptureParams->captureFlagsRW.NumCopies < 1 ||
                    pCaptureParams->captureFlagsRW.NumCopies > 255)
                {
                    DisplayMessage(IDR_COPIES_OUTOF_RANGE);
                    fValidParam = FALSE;
                    break;
                }
            }
            else if (IsValidOption (argv[i], __TABS__, __SHORT_FOR_TABS__))
            {
                if (pEqual == NULL || *(pEqual+1) == 0)
                {
                    DisplayMessage(IDR_TAB_SIZE_EXPECTED);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->captureFlagsRW.TabSize = (BYTE) atoi (pEqual+1);

                if (pCaptureParams->captureFlagsRW.TabSize < 1 ||
                    pCaptureParams->captureFlagsRW.TabSize > 18)
                {
                    DisplayMessage(IDR_TABSIZE_OUTOF_RANGE);
                    fValidParam = FALSE;
                    break;
                }

                pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_EXPAND_TABS;
            }
            else if (IsValidOption (argv[i], __NAME__, __SHORT_FOR_NAME__))
            {
                if (pEqual == NULL ||
                    *(pEqual+1) == 0 ||
                    strlen (pEqual+1) > MAX_BANNER_USER_NAME - 1)
                {
                    fValidOption = FALSE;
                    break;
                }
                strcpy (pCaptureParams->bannerUserName, pEqual+1);
            }
            else if (IsValidOption (argv[i], __BANNER__, __SHORT_FOR_BANNER__))
            {
                if (pEqual != NULL)
                {
                    if (strlen (pEqual+1) > MAX_BANNER_USER_NAME - 1)
                    {
                        DisplayMessage(IDR_INVALID_BANNER, pEqual+1);
                        fValidParam = FALSE;
                        break;
                    }
                    strcpy (pCaptureParams->captureFlagsRW.BannerText, pEqual+1);
                    pCaptureParams->captureFlagsRW.PrintFlags |= CAPTURE_FLAG_PRINT_BANNER;
                }
            }
            //
            // Kludge for LX LPX LPTX parameters
            // Note that L:X L=X, etc are also valid
            //
            else if ( ( pEqual == NULL ) && ( *(argv[i]) == 'L' ) ) {
                pEqual = argv[i];
                pEqual++;
                if ( *pEqual == 'P' ) {
                    pEqual++;
                    if ( *pEqual == 'T' ) {
                        pEqual++;
                    }
                }
                pCaptureParams->nLPT = (unsigned char) atoi (pEqual);

                if (pCaptureParams->nLPT < 1 || pCaptureParams->nLPT > 3)
                {
                    DisplayMessage(IDR_INVALID_LPT_NUMBER);
                    fValidParam = FALSE;
                    break;
                }

            }
            else
            {
                fValidOption = FALSE;
                break;
            }
        }
    }

    if (fValidOption && fValidParam)
    {
        sprintf (pCaptureParams->captureFlagsRW.JobDescription, __JOB_DESCRIPTION__, pCaptureParams->nLPT);
        return(TRUE);
    }
    else
    {
        if (!fValidOption)
        {
            if (pEqual)
                *pEqual = '=';
            DisplayMessage(IDR_UNKNOW_FLAG, argv[i]);
        }
        DisplayMessage(IDR_CAPTURE_USAGE);
        return(FALSE);
    }
}

/*
    Show the capture setting.
 */
void ShowCapture(void)
{
    unsigned int iRet = 0;
    int     i;
    char * queueName;

    for (i = 1; i <= 3; i++ )
    {
        NETWARE_CAPTURE_FLAGS_RW captureFlagsRW;
        NETWARE_CAPTURE_FLAGS_RO captureFlagsRO;

        if (iRet = GetCaptureFlags ((unsigned char)i,
                                    &captureFlagsRW,
                                    &captureFlagsRO))
        {
            DisplayError (iRet, "GetCaptureFlags");
        }
        else
        {
            char *serverName;
            WCHAR timeOut[256];
            WCHAR tabs[256];

            if (captureFlagsRO.LPTCaptureFlag == 0)
            {
                DisplayMessage(IDR_NOT_ACTIVE, i);
            }
            else
            {
                serverName = captureFlagsRO.ServerName;

                if ( !CaptureStringsLoaded ) {
                    (void) LoadString( NULL, IDR_DISABLED, __DISABLED__, 256 );
                    (void) LoadString( NULL, IDR_ENABLED, __ENABLED__, 256 );
                    (void) LoadString( NULL, IDR_YES, __YES__, 256 );
                    (void) LoadString( NULL, IDR_NO, __NO__, 256 );
                    (void) LoadString( NULL, IDR_SECONDS, __SECONDS__, 256 );
                    (void) LoadString( NULL, IDR_CONVERT_TO_SPACE, __CONVERT_TO_SPACE__, 256 );
                    (void) LoadString( NULL, IDR_NO_CONVERSION, __NO_CONVERSION__, 256 );
                    (void) LoadString( NULL, IDR_NOTIFY_USER, __NOTIFY_USER__, 256 );
                    (void) LoadString( NULL, IDR_NOT_NOTIFY_USER, __NOT_NOTIFY_USER__, 256 );
                    (void) LoadString( NULL, IDR_NONE, __NONE__, 256 );
                }

                if (captureFlagsRW.FlushCaptureTimeout)
                    wsprintf (timeOut, __SECONDS__, captureFlagsRW.FlushCaptureTimeout);
                else
                    (void) LoadString( NULL, IDR_DISABLED, timeOut, 256 );

                if (captureFlagsRW.PrintFlags & CAPTURE_FLAG_EXPAND_TABS)
                    wsprintf(tabs, __CONVERT_TO_SPACE__, captureFlagsRW.TabSize);
                else
                    (void) LoadString( NULL, IDR_NO_CONVERSION, tabs, 256 );


                queueName = captureFlagsRO.QueueName;

                if ( fNDS )
                {
                    if ( captureFlagsRW.PrintFlags & CAPTURE_FLAG_PRINT_BANNER )
                    {
                        DisplayMessage(IDR_LPT_STATUS_NDS, i, queueName,
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NOTIFY? __NOTIFY_USER__ : __NOT_NOTIFY_USER__,   //Notify
                               __DISABLED__,    //Capture Defaults
                               captureFlagsRW.FlushCaptureOnClose? __DISABLED__ : __ENABLED__,  //AutoEndCap
                               captureFlagsRW.BannerText, //Banner
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NO_FORMFEED? __NO__ : __YES__, //Form Feed
                               captureFlagsRW.NumCopies,    //Copies
                               tabs,                        //Tabs
                               captureFlagsRW.FormType, timeOut); //Timeout Counts
                    }
                    else
                        {
                        DisplayMessage(IDR_LPT_STATUS_NO_BANNER_NDS, i, queueName,
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NOTIFY? __NOTIFY_USER__ : __NOT_NOTIFY_USER__,   //Notify
                               __DISABLED__,     //Capture Defaults
                               captureFlagsRW.FlushCaptureOnClose? __DISABLED__ : __ENABLED__,  //AutoEndCap
                               __NONE__, //Banner
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NO_FORMFEED? __NO__ : __YES__,  //Form Feed
                               captureFlagsRW.NumCopies,     //Copies
                               tabs,                         //Tabs
                               captureFlagsRW.FormType, timeOut); //Timeout Counts
                    }
                }
                else
                {
                    if ( captureFlagsRW.PrintFlags & CAPTURE_FLAG_PRINT_BANNER )
                    {
                        DisplayMessage(IDR_LPT_STATUS, i, serverName, queueName,
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NOTIFY? __NOTIFY_USER__ : __NOT_NOTIFY_USER__,   //Notify
                               __DISABLED__,    //Capture Defaults
                               captureFlagsRW.FlushCaptureOnClose? __DISABLED__ : __ENABLED__,  //AutoEndCap
                               captureFlagsRW.BannerText, //Banner
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NO_FORMFEED? __NO__ : __YES__, //Form Feed
                               captureFlagsRW.NumCopies,    //Copies
                               tabs,                        //Tabs
                               captureFlagsRW.FormType, timeOut); //Timeout Counts
                    }
                    else
                        {
                        DisplayMessage(IDR_LPT_STATUS_NO_BANNER, i, serverName, queueName,
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NOTIFY? __NOTIFY_USER__ : __NOT_NOTIFY_USER__,   //Notify
                               __DISABLED__,     //Capture Defaults
                               captureFlagsRW.FlushCaptureOnClose? __DISABLED__ : __ENABLED__,  //AutoEndCap
                               __NONE__, //Banner
                               captureFlagsRW.PrintFlags & CAPTURE_FLAG_NO_FORMFEED? __NO__ : __YES__,  //Form Feed
                               captureFlagsRW.NumCopies,     //Copies
                               tabs,                         //Tabs
                               captureFlagsRW.FormType, timeOut); //Timeout Counts
                    }
                }
            }
        }
    }
}

int  CStartCapture(unsigned int conn,
                   PCAPTURE_PARAMS pCaptureParams)
{
    unsigned int iRet = 0;
    unsigned char FullPath[255 + NCP_VOLUME_LENGTH];
    unsigned char DirPath[255];
    unsigned char VolumeName[NCP_VOLUME_LENGTH];
    WORD          status;

    // Get connection handle.
    if ( !pCaptureParams->NDSCapture )
    {
        if ( pCaptureParams->serverName[0] == 0 )
        {
            if (iRet = GetFileServerName (conn, pCaptureParams->serverName))
            {
                DisplayError (iRet, "GetFileServerName");
                return (1);
            }
        }
        else
        {
            if (iRet = GetConnectionHandle (pCaptureParams->serverName, &conn))
            {
                if ( iRet = NTLoginToFileServer( pCaptureParams->serverName, "GUEST", "" ) ) {
                    switch ( iRet ) {
                    case ERROR_INVALID_PASSWORD:
                    case ERROR_NO_SUCH_USER:
                    case ERROR_CONNECTION_COUNT_LIMIT:
                    case ERROR_LOGIN_TIME_RESTRICTION:
                    case ERROR_LOGIN_WKSTA_RESTRICTION:
                    case ERROR_ACCOUNT_DISABLED:
                    case ERROR_PASSWORD_EXPIRED:
                    case ERROR_REMOTE_SESSION_LIMIT_EXCEEDED:
                        DisplayMessage( IDR_CAPTURE_FAILED, pCaptureParams->queueName );
                        DisplayMessage( IDR_ACCESS_DENIED );
                        break;
                    default:
                        DisplayMessage(IDR_SERVER_NOT_FOUND, pCaptureParams->serverName);
                    }
                    return (1);
                }
                else {
                    if (iRet = GetConnectionHandle (pCaptureParams->serverName, &conn)) {
                        DisplayMessage(IDR_SERVER_NOT_FOUND, pCaptureParams->serverName);
                        return (1);
                    }
                }
            }
        }
    }

    if (pCaptureParams->filePath[0] != 0)
    {
        DisplayMessage(IDR_FILE_CAPTURE_UNSUPPORTED);
        return (1);
    }
    else
    {
        if (pCaptureParams->queueName[0] == 0)
        {
            if ( pCaptureParams->NDSCapture ) 
            {
                DisplayMessage(IDR_NO_QUEUE);
                return (1);
            }
            else
            {
                // Try to get the default queue ID and name.
                if (iRet = GetDefaultPrinterQueue (conn, pCaptureParams->serverName, pCaptureParams->queueName))
                {
                    DisplayMessage(IDR_NO_PRINTERS, pCaptureParams->serverName);
                    return (1);
                }
            }
        }
        // Start queue capture.
        if ( pCaptureParams->NDSCapture )
        {
            char szCanonName[MAX_QUEUE_NAME_LEN];

            // Get the full name of the printer queue
            // The redirectory wants root based names for
            // everything.

            iRet = NDSCanonicalizeName( pCaptureParams->queueName,
                                        szCanonName,
                                        NDS_NAME_CHARS,
                                        TRUE );
            
            if ( iRet && ( pCaptureParams->queueName[0] != '.' ) )
            {
                // If that didn't work, see if it's a root
                // based name without the leading period.

                strcpy( szCanonName, "." );
                strcat( szCanonName, pCaptureParams->queueName );

                iRet = NDSCanonicalizeName( szCanonName,
                                            szCanonName,
                                            MAX_QUEUE_NAME_LEN,
                                            TRUE );
            }

            if ( iRet )
                iRet = ERROR_BAD_NETPATH;
            else
                iRet = StartQueueCapture ( conn,
                                           pCaptureParams->nLPT,
                                           NDSTREE,
                                           szCanonName );
        }
        else 
        {
            iRet = StartQueueCapture (conn,
                                      pCaptureParams->nLPT,
                                      pCaptureParams->serverName,
                                      pCaptureParams->queueName);
        }

        if ( iRet )
        {
            switch ( iRet ) {
            case ERROR_ACCESS_DENIED:
            case ERROR_INVALID_PASSWORD:
                DisplayMessage (IDR_CAPTURE_FAILED, pCaptureParams->queueName);
                DisplayMessage (IDR_ACCESS_DENIED);
                break;
            case ERROR_EXTENDED_ERROR:
                NTPrintExtendedError();
                break;
            case ERROR_BAD_NET_NAME:
            case ERROR_BAD_NETPATH:
                if ( pCaptureParams->NDSCapture )
                    DisplayMessage (IDR_NDSQUEUE_NOT_EXIST,
                                    pCaptureParams->queueName,
                                    pCaptureParams->serverName );
                else
                    DisplayMessage (IDR_QUEUE_NOT_EXIST,
                                    pCaptureParams->queueName,
                                    pCaptureParams->serverName );
                break;
            default:
                DisplayError (iRet, "StartQueueCapture");
                break;
            }
            return (1);
        }
    }

    if (pCaptureParams->captureFlagsRW.FlushCaptureOnClose == 1)
        DisplayMessage(IDR_NO_AUTOENDCAP);

    if ( pCaptureParams->NDSCapture )
        DisplayMessage(IDR_NDSSUCCESS_QUEUE, pCaptureParams->nLPT,
                       pCaptureParams->queueName);
    else
        DisplayMessage(IDR_SUCCESS_QUEUE, pCaptureParams->nLPT,
                       pCaptureParams->queueName, pCaptureParams->serverName);

    return(0);
}

/*
 * Given an NDS printer name, fill in the default queue name
 *
 */
int
GetPrinterDefaultQueue( PCAPTURE_PARAMS pCaptureParams,
                        PBYTE PrinterName )
{
    BYTE Fixup[ MAX_QUEUE_NAME_LEN];
    PBYTE ptr;
    unsigned int iRet;

    iRet = NDSGetProperty ( PrinterName, "Default Queue",
                            pCaptureParams->queueName,
                            MAX_QUEUE_NAME_LEN,
                            NULL );
    if ( iRet )
    {
        /*
         * Strip off the . in front and add context at end
         */
        ptr = RemoveSpaces (PrinterName);
        if ( *ptr == '.' )
        {
            ptr++;
            strncpy( Fixup, ptr, MAX_QUEUE_NAME_LEN );
        } 
        else
        {
            strncpy( Fixup, ptr, MAX_QUEUE_NAME_LEN );
            if ( Fixup[strlen(Fixup)-1] != '.' )
            {
                strcat( Fixup, "." );
            }
            (void) NDSGetContext( Fixup + strlen(Fixup),
                                  MAX_QUEUE_NAME_LEN - strlen(Fixup) );
        }
        iRet = NDSGetProperty ( Fixup, "Default Queue",
                                pCaptureParams->queueName,
                                MAX_QUEUE_NAME_LEN,
                                NULL );
        if ( !iRet )
            ConvertUnicodeToAscii( pCaptureParams->queueName ); 
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\date.c ===
/*************************************************************************
*
*  DATE.C
*
*  NT date routine
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\DATE.C  $
*  
*     Rev 1.2   10 Apr 1996 14:22:00   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:52:56   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:24:04   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:40   terryt
*  Initial revision.
*  
*     Rev 1.0   15 May 1995 19:10:22   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "nwscript.h"


/*
 *******************************************************************

        NTGetTheDate

Routine Description:

        Return the current date

Arguments:

        yearCurrent  pointer to current year
                     1980-2099
        monthCurrent pointer to current month
                     1-12
        dayCurrent   pointer to current day
                     1-31

Return Value:

        

 *******************************************************************
 */
void NTGetTheDate( unsigned int * yearCurrent,
                   unsigned char * monthCurrent,
                   unsigned char * dayCurrent ) 
{
    time_t timedat;
    struct tm * p_tm;

    (void) time( &timedat );
    p_tm = localtime( &timedat );

    *yearCurrent =  p_tm->tm_year + 1900;
    *monthCurrent = p_tm->tm_mon + 1;
    *dayCurrent =   (UCHAR) p_tm->tm_mday;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\common.c ===
/*************************************************************************
*
*  COMMON.C
*
*  Miscellaneous routines for scripts, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\COMMON.C  $
*  
*     Rev 1.3   10 Apr 1996 14:21:52   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.3   12 Mar 1996 19:52:40   terryt
*  Relative NDS names and merge
*  
*     Rev 1.2   24 Jan 1996 17:14:54   terryt
*  Common read string routine
*  
*     Rev 1.1   22 Dec 1995 14:23:56   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:36   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 16:22:18   terryt
*  Capture support
*  
*     Rev 1.1   26 Jul 1995 14:17:06   terryt
*  Clean up comments
*  
*     Rev 1.0   15 May 1995 19:10:18   terryt
*  Initial revision.
*  
*************************************************************************/
#include "common.h"

/*
    Used by DisplayMapping() only.
    Return search number if the drive is a search drive.
    Return 0 if the drive is not a search drive.
 */
int  IsSearchDrive(int driveNum)
{
    int   searchNum = 1;
    char  *path;

    path = NWGetPath();
    if (path == NULL) {
        return 0;
    }

    while (*path != 0)
    {
        if ((*path - 'A' + 1 == driveNum) &&
            (*(path+1) == ':'))
        {
            return searchNum;
        }

        if (path = strchr (path, ';'))
        {
            path++;
            searchNum++;
        }
        else
            return(0);
    }

    return(0);
}


/*
    Get path enviroment variable. This returns the pointer to the
    path in the parent enviroment segment.
 */
char  * NWGetPath(void)
{
    // 
    // On NT we can't change or get the parent's environment this way
    //
    return( getenv("PATH") );    
}

/*
    Return TRUE if the memory block is large enough for adding new
    search path. FALSE otherwise.
 */
int MemorySegmentLargeEnough (int nInsertByte)
{
    return TRUE;
}

/*
    Display drive maps info.
 */
void DisplayMapping(void)
{
    unsigned int    iRet = 0;
    int        i;
    WORD       status;
    char       rootPath[MAX_PATH_LEN], relativePath[MAX_PATH_LEN];
    char      *envPath, *tokenPath;
    char  *path;
    DWORD LocalDrives;
    DWORD NonSearchDrives;
    char sLocalDrives[26*2+5];
    char * sptr;

    // Don't delete this line. This is for fixing bug 1176.
    DisplayMessage(IDR_NEWLINE);

    LocalDrives = 0;
    NonSearchDrives = 0;

    // Collect local drives and search drives
    for (i = 1; i <= 26; i++) {
        status = NTNetWareDriveStatus( (unsigned short)(i-1) );
        if ((status & NETWARE_LOCAL_DRIVE) && !(status & NETWARE_NETWORK_DRIVE))
            LocalDrives |= ( 1 << (i-1) );
        else if ((status & NETWARE_NETWORK_DRIVE) && (!IsSearchDrive(i)) )
        {
            if (status & NETWARE_NETWARE_DRIVE)
                NonSearchDrives |= ( 1 << (i-1) );
            else
            {
                //For NetWare compatibility
                LocalDrives |= ( 1 << (i-1) );
            }
        }
    }

    // Print out local drives
    if ( LocalDrives ) {
        sptr = &sLocalDrives[0];
        for (i = 1; i <= 26; i++)
        {
            if ( LocalDrives & ( 1 << (i - 1) ) ) { 
                *sptr++ = 'A' + i - 1;
                *sptr++ = ',';
            }
        }
        sptr--;
        *sptr = '\0';
        DisplayMessage(IDR_ALL_LOCAL_DRIVES, sLocalDrives);
    }

    // Print out non search drives.
    for (i = 1; i <= 26; i++)
    {
        if ( NonSearchDrives & ( 1 << (i - 1) ) ) { 

            if (iRet = GetDriveStatus ((unsigned short)i,
                                       NETWARE_FORMAT_SERVER_VOLUME,
                                       &status,
                                       NULL,
                                       rootPath,
                                       relativePath,
                                       NULL))
            {
                DisplayError (iRet, "GetDriveStatus");
            }
            else
            {
                DisplayMessage(IDR_NETWARE_DRIVE, 'A'+i-1, rootPath, relativePath);
            }
        }
    }

    // Print out dashed line as seperator between non search drives
    // and search drives.
    DisplayMessage(IDR_DASHED_LINE);

    // Get the PATH environment variable.
    path = NWGetPath();
    if (path == NULL) {
        return;
    }

    if ((envPath = malloc (strlen (path) + 1)) == NULL)
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }

    strcpy (envPath, path);

    tokenPath = strtok (envPath, PATH_SEPERATOR);

    // Print out search drvies.
    for (i = 1; tokenPath != NULL; i++)
    {
        if (tokenPath[1] == ':')
        {
            if (iRet = GetDriveStatus ((unsigned short)(toupper(tokenPath[0])-'A'+1),
                                       NETWARE_FORMAT_SERVER_VOLUME,
                                       &status,
                                       NULL,
                                       rootPath,
                                       relativePath,
                                       NULL))
            {
                DisplayError (iRet, "GetDriveStatus");
            }
            else
            {
                if (status & NETWARE_NETWARE_DRIVE)
                    DisplayMessage(IDR_NETWARE_SEARCH, i, tokenPath, rootPath, relativePath);
                else
                    DisplayMessage(IDR_LOCAL_SEARCH, i, tokenPath);
            }
        }
        else
        {
            // Path is specified without drive letter.
            DisplayMessage(IDR_LOCAL_SEARCH, i, tokenPath);
        }

        tokenPath = strtok (NULL, PATH_SEPERATOR);
    }

    free (envPath);
}

/*****************************************************************************
 *                                                                           *
 *   GetString                                                               *
 *                                                                           *
 *                                                                           *
 *   entry:  pointer to buffer                                               *
 *           length of buffer                                                *
 *                                                                           *
 *   exit:   length of string                                                *
 *                                                                           *
 *****************************************************************************/

int
GetString( char * pBuffer, int ByteCount )
{
   char * pString = pBuffer;
   char ch;

   if ( ByteCount > 0 )
       ByteCount--;

   for( ;; ) {

       switch ( ch = (char) _getch() ) {

       case '\r' :
           *pString++ = '\0';
           putchar( '\n' );
           return( strlen( pBuffer ) );

       case '\b' :
           if ( pString != pBuffer ) {
               ByteCount++;
               pString--;
               printf( "\b \b" );
           }
           break;

       default :
           if ( ByteCount > 0 && ch >= 0x20 && ch < 0x80 ) {
               *pString++ = ch;
               ByteCount--;
               putchar( ch );
           }
           break;
       }

    }
    fflush(stdin);
}

/*
    Read user or server name from the keyboard input.
    Return TRUE if user typed in a username
           FALSE otherwise.
 */
int ReadName (char * Name)
{
    memset( Name, 0, MAX_NAME_LEN );

    if ( 0 == GetString( Name, MAX_NAME_LEN ) )
        return FALSE;

    _strupr(Name);
    return TRUE;
}



/*
    Try to log the user in.
    Return error code. 0 is success.
 */
int  Login( char *UserName,
            char *ServerName,
            char *Password,
            int   bReadPassword)
{
    unsigned int  iRet = 0;

    // Try log the user in with no password first.
    iRet = NTLoginToFileServer( ServerName,
                                UserName,
                                Password);

    if (iRet == ERROR_INVALID_PASSWORD && bReadPassword)
    {
        // wrong password. ask for passowrd. and try login with
        // the input password.
        DisplayMessage(IDR_PASSWORD, UserName, ServerName);

        ReadPassword (Password);

        iRet = NTLoginToFileServer( ServerName,
                                    UserName,
                                    Password);
    }

    switch(iRet)
    {
    case NO_ERROR: // ok
        DisplayMessage(IDR_ATTACHED, ServerName);
        break;

    case ERROR_INVALID_PASSWORD: // wrong password.
    case ERROR_NO_SUCH_USER: // no such user.
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_ACCESS_DENIED);
        break;

    case ERROR_CONNECTION_COUNT_LIMIT:  // concurrent connection restriction.
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_LOGIN_DENIED_NO_CONNECTION);
        break;

    case ERROR_LOGIN_TIME_RESTRICTION:  // time restriction.
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_UNAUTHORIZED_LOGIN_TIME);
        break;

    case ERROR_LOGIN_WKSTA_RESTRICTION: // station restriction.
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_UNAUTHORIZED_LOGIN_STATION);
        break;

    case ERROR_ACCOUNT_DISABLED:
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_ACCOUNT_DISABLED);
        break;

    case ERROR_PASSWORD_EXPIRED: // password expired and no grace login left.
        DisplayMessage(IDR_SERVER_USER, ServerName, UserName);
        DisplayMessage(IDR_PASSWORD_EXPRIED_NO_GRACE);
        break;

    case ERROR_REMOTE_SESSION_LIMIT_EXCEEDED:
        // Server rejected access
        DisplayMessage(IDR_CONNECTION_REFUSED);
        break;

    case ERROR_EXTENDED_ERROR:
        NTPrintExtendedError();
        break;

    //
    // tommye - MS bug 8194 (MCS 240)
    // If we are already attached to this server under other credentials
    // we get back an ERROR_SESSION_CREDENTIAL_CONFLICT.  This is okay,
    // we'll just print out that we're already attached.  We have to 
    // pass the error on up, though, so we don't add this server to the
    // attach list again.
    //
    case ERROR_SESSION_CREDENTIAL_CONFLICT:
        DisplayMessage(IDR_ALREADY_ATTACHED, ServerName);
        break;

    default :
        DisplayError(iRet,"NtLoginToFileServer");
        break;
    }

    return(iRet);
}

int CAttachToFileServer(char *ServerName, unsigned int *pConn, int * pbAlreadyAttached)
{
    unsigned int  iRet = 0;

    if (pbAlreadyAttached != NULL)
        *pbAlreadyAttached = FALSE;

    // Validate the server name.
    iRet = AttachToFileServer(ServerName,pConn);

    switch (iRet)
    {
        case 0: // OK
            break;

        case 0x8800 : // Already atached.
            if (pbAlreadyAttached != NULL)
                *pbAlreadyAttached = TRUE;

            iRet = GetConnectionHandle (ServerName, pConn);
            break;

        default:
            DisplayMessage(IDR_NO_RESPONSE, ServerName);
            break;
    }

    return(iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\display.c ===
/*************************************************************************
*
*  DISPLAY.C
*
*  NetWare script routines for displaying information, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\DISPLAY.C  $
*  
*     Rev 1.2   10 Apr 1996 14:22:06   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:53:04   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:24:18   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:48   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:22:32   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:10:26   terryt
*  Initial revision.
*  
*************************************************************************/
/*
    File name: display.c
    Do not add any other functions to this file.
    Otherwise many exes size will increase.
 */


#include "common.h"

/*
    Display error report.
 */
void DisplayError(int error ,char *functionName)
{
    DisplayMessage(IDR_ERROR, error ,functionName);
}

void xstrupr(char *buffer)
{
    for (; *buffer; buffer++)
    {
        if (IsDBCSLeadByte(*buffer))
            buffer++;
        else if (*buffer == 0xff80)
            *buffer = (char)0xff87;
        else if (*buffer == 0xff81)
            *buffer = (char)0xff9a;
        else if (*buffer == 0xff82)
            *buffer = (char)0xff90;
        else if (*buffer == 0xff84)
            *buffer = (char)0xff8e;
        else if (*buffer == 0xff88)
            *buffer = (char)0xff9f;
        else if (*buffer == 0xff91)
            *buffer = (char)0xff92;
        else if (*buffer == 0xff94)
            *buffer = (char)0xff99;
        else if (*buffer == 0xffa4)
            *buffer = (char)0xffa5;
    }

    _strupr (buffer);
}

/*
    Read password from the keyboard input.
 */
void ReadPassword(char * Password)
{
    int  i = 0;
    char c;

    do
    {   c=(char)_getch();

        if (c == '\b')
        {
            if (i > 0)
                i--;
        }
        else
        {
            Password[i]=c;
            i++;
        }
    }while((c!='\r') && i< MAX_PASSWORD_LEN );
    Password[i-1]='\0';
    xstrupr(Password);
    DisplayMessage(IDR_NEWLINE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\drive.c ===
/*************************************************************************
*
*  DRIVE.C
*
*  NT drive routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\DRIVE.C  $
*
*     Rev 1.2   10 Apr 1996 14:22:12   terryt
*  Hotfix for 21181hq
*
*     Rev 1.2   12 Mar 1996 19:53:22   terryt
*  Relative NDS names and merge
*
*     Rev 1.1   22 Dec 1995 14:24:24   terryt
*  Add Microsoft headers
*
*     Rev 1.0   15 Nov 1995 18:06:52   terryt
*  Initial revision.
*
*     Rev 1.2   25 Aug 1995 16:22:38   terryt
*  Capture support
*
*     Rev 1.1   23 May 1995 19:36:46   terryt
*  Spruce up source
*
*     Rev 1.0   15 May 1995 19:10:30   terryt
*  Initial revision.
*
*************************************************************************/
#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <nwapi32.h>
#include <nwapi.h>
#include <npapi.h>
#include <regapi.h>

#include "nwscript.h"
#include "ntnw.h"
#include "inc/nwlibs.h"

#include <mpr.h>

extern unsigned char NW_PROVIDERA[];

// now all SKUs have TerminalServer flag.  If App Server is enabled, SingleUserTS flag is cleared
#define IsTerminalServer() (BOOLEAN)(!(USER_SHARED_DATA->SuiteMask & (1 << SingleUserTS)))
/********************************************************************

        GetFirstDrive

Routine Description:

        Return the first non-local drive

Arguments:

        pFirstDrive = pointer to drive
                 1-26

Return Value:
        0 = success
        F = failure

 ********************************************************************/
unsigned int
GetFirstDrive( unsigned short *pFirstDrive )
{
    int i;
    char DriveName[10];
    unsigned int drivetype;
    HKEY hKey;
    char InitDrive[3] = "";
    DWORD dwTemp;


    if (IsTerminalServer()) {
        // Check if there is a override specified in the registry for the
        // initial NetWare drive (to prevent collisions with client drive mappings)
        if (RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                          REG_CONTROL_TSERVER,
                          0,
                          KEY_READ,
                          &hKey) == ERROR_SUCCESS) {

            dwTemp = sizeof(InitDrive);
            if (RegQueryValueExA(hKey,
                                 REG_CITRIX_INITIALNETWAREDRIVE_A,
                                 NULL,
                                 NULL,
                                 InitDrive,
                                 &dwTemp) != ERROR_SUCCESS) {
            }
            RegCloseKey(hKey);
        }

        // Original code defaulted to C:
        if (!isalpha(InitDrive[0])) {
            InitDrive[0] = 'C';
        }

        strcpy( DriveName, "A:\\" );
        dwTemp = toupper(InitDrive[0]) - 'A';
    }
    else {
       strcpy( DriveName, "A:\\" );
       dwTemp=2;
    }

    for ( i = dwTemp; i < 26; i++ ) {
        DriveName[0] = 'A' + i;
        drivetype = GetDriveTypeA( DriveName );
        if ( ( ( drivetype == DRIVE_REMOTE ) &&
               ( NTIsNetWareDrive( i )     )  ) ||
             ( drivetype == DRIVE_NO_ROOT_DIR ) ) {
            *pFirstDrive = i + 1;
            return 0x0000;
        }
    }

    return 0x000F;
}

/********************************************************************

        IsDriveRemote

Routine Description:

        Is the given drive remote?

Arguments:

        DriveNumber 1-26
        pRemote  0x1000 = remote,  0x0000 = local

Return Value:
        0  = success
        F =  invalid drive

 ********************************************************************/
unsigned int
IsDriveRemote(
    unsigned char  DriveNumber,
    unsigned int  *pRemote
    )
{
    char DriveName[10];
    unsigned int drivetype;

    strcpy( DriveName, "A:\\" );
    DriveName[0] = 'A' + DriveNumber;

    drivetype = GetDriveTypeA( DriveName );

    if ( drivetype == DRIVE_REMOTE ) {
        *pRemote = 0x1000;
        return 0;
    }
    else if ( drivetype == DRIVE_NO_ROOT_DIR ) {
        return 0xF;
    }
    else {
        *pRemote = 0;
        return 0;
    }
}


/********************************************************************

        NTNetWareDriveStatus

Routine Description:

        Return the type of drive

Arguments:

        DriveNumber - Number of drive 0-25

Return Value:

        Combination of:
           NETWARE_NETWORK_DRIVE
           NETWARE_NETWARE_DRIVE
           NETWARE_LOCAL_FREE_DRIVE
           NETWARE_LOCAL_DRIVE



 *******************************************************************/
unsigned short
NTNetWareDriveStatus( unsigned short DriveNumber )
{
    char DriveName[10];
    unsigned int drivetype;
    unsigned int Status = 0;

    strcpy( DriveName, "A:\\" );
    DriveName[0] = 'A' + DriveNumber;
    drivetype = GetDriveTypeA( DriveName );

    if ( drivetype == DRIVE_REMOTE ) {
        Status |= NETWARE_NETWORK_DRIVE;
        if ( NTIsNetWareDrive( (unsigned int)DriveNumber ) )
            Status |=  NETWARE_NETWARE_DRIVE;
    }
    else if ( drivetype == DRIVE_NO_ROOT_DIR ) {
        Status = NETWARE_LOCAL_FREE_DRIVE;
    }
    else {
        Status = NETWARE_LOCAL_DRIVE;
    }
    return (USHORT)Status;
}


/********************************************************************

        NTGetNWDrivePath

Routine Description:

        Return the server name and path of the specified drive

Arguments:
        DriveNumber - Number of drive 0-25
        ServerName  - Name of file server
        Path        - Volume:\Path

Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int NTGetNWDrivePath(
          unsigned short DriveNumber,
          unsigned char * ServerName,
          unsigned char * Path )
{
    static char localname[] = "A:";
    unsigned int Result;
    char * p;
    char * volume;
    char remotename[1024];
    int length = 1024;

    if ( ServerName != NULL )
        *ServerName = 0;

    if ( Path != NULL )
        *Path = 0;

    localname[0] = 'A' + DriveNumber;

    Result = WNetGetConnectionA ( localname, remotename, &length );

    if ( Result != NO_ERROR ) {
        Result = GetLastError();
        if ( Result == ERROR_EXTENDED_ERROR )
            NTPrintExtendedError();
        return Result;
    }

    p = strchr (remotename + 2, '\\');
    if ( !p )
        return 0xffffffff;

    *p++ = '\0';
    volume = p;

    if ( ServerName != NULL ) {
        strcpy( ServerName, remotename + 2 );
        _strupr( ServerName );
    }

    if ( Path != NULL ) {
        p = strchr (volume, '\\');
        if ( !p ) {
            strcpy( Path, volume );
            strcat( Path, ":" );
        }
        else {
            *p = ':';
            strcpy( Path, volume );
        }
        _strupr( Path );
    }

    return NO_ERROR;
}


/********************************************************************

        NTIsNetWareDrive

Routine Description:

        Returns TRUE if the drive is a netware mapped drive

Arguments:

        DriveNumber - Number of drive 0-25

Return Value:
        TRUE  - drive is NetWare
        FALSE - drive is not NetWare

 *******************************************************************/
unsigned int
NTIsNetWareDrive( unsigned int DriveNumber )
{
    LPBYTE       Buffer ;
    DWORD        dwErr ;
    HANDLE       EnumHandle ;
    char         DriveName[10];
    DWORD        BufferSize = 4096;
    LPWNET_CONNECTIONINFOA pConnectionInfo;

    strcpy( DriveName, "A:" );

    DriveName[0] = 'A' + DriveNumber;

    //
    // allocate memory and open the enumeration
    //
    if (!(Buffer = LocalAlloc( LPTR, BufferSize ))) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    dwErr = WNetGetConnection2A( DriveName, Buffer, &BufferSize );
    if (dwErr != WN_SUCCESS) {
        dwErr = GetLastError();
        if ( dwErr == ERROR_EXTENDED_ERROR )
            NTPrintExtendedError();
        (void) LocalFree((HLOCAL) Buffer) ;
        return FALSE;
    }

    pConnectionInfo = (LPWNET_CONNECTIONINFOA) Buffer;

    if ( !_strcmpi ( pConnectionInfo->lpProvider, NW_PROVIDERA ) ) {
        (void) LocalFree((HLOCAL) Buffer) ;
        return TRUE;
    }
    else {
        (void) LocalFree((HLOCAL) Buffer) ;
        return FALSE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\drvstat.c ===
/*************************************************************************
*
*  DRVSTAT.C
*
*  Drive status routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\DRVSTAT.C  $
*  
*     Rev 1.2   10 Apr 1996 14:22:20   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:53:36   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:24:32   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:54   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:22:44   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:10:32   terryt
*  Initial revision.
*  
*************************************************************************/

/*++

Copyright (c) 1994  Micro Computer Systems, Inc.

Module Name:

    nwlibs\drvstat.c

Abstract:

    Directory APIs.

Author:

    Shawn Walker (v-swalk) 10-10-1994

Revision History:

--*/
#include "common.h"


/*++
*******************************************************************

        GetDriveStatus

Routine Description:

        Get the drive status.

Arguments:

        DriveNumber = The drive to number to use. (1=A,2=B,C=3,...)
        PathFormat = Format for the return path.
                        NW_FORMAT_NETWARE - volume:path
                        NW_FORMAT_SERVER_VOLUME - server\volume:path
                        NW_FORMAT_DRIVE - G:\path
                        NW_FORMAT_UNC - \\server\volume\path
        pStatus = A pointer to return the status of the drive.
        pConnectionHandle = A pointer to return the connection handle
                                for the drive.
        pRootPath = The pointer to return the base root path. OPTIONAL
        pRelativePath = The pointer to return the relative to root path.
        pFullPath = The pointer to return the full path.

Return Value:

        0x0000      SUCCESSFUL
        0x00FF      INVALID_DRIVE

*******************************************************************
--*/
unsigned int
GetDriveStatus(
    unsigned short  DriveNumber,
    unsigned short  PathFormat,
    unsigned short *pStatus,
    unsigned int   *pConnectionHandle,
    unsigned char  *pRootPath,
    unsigned char  *pRelativePath,
    unsigned char  *pFullPath
    )
{
    unsigned char     *p;
    unsigned int       Result;
    unsigned short     Status;
    unsigned char      Path[NCP_MAX_PATH_LENGTH + 1];
    unsigned char      WorkPath[NCP_MAX_PATH_LENGTH + 1];
    unsigned char      ServerName[NCP_SERVER_NAME_LENGTH + 1];

    /** Make sure the drive number is valid **/

    if (DriveNumber < 1 || DriveNumber > 32) {
        return 0x000F;      /* INVALID_DRIVE */
    }

    Status = 0;

    DriveNumber--;


    if (pConnectionHandle) {
        /* 
         *  This should never occur.
         */
        DisplayError (0xff, "GetDriveStatus");
        return 0xff;
    }

    /** Get the directory path from the server **/
    Result = NTGetNWDrivePath( DriveNumber, ServerName, Path );
    if ( Result ) {
        *Path = 0;
        *ServerName = 0;
    }

    /** Convert the / in the path to \ **/
    for (p = Path; *p != 0 ; p++)
    {
        if (*p == '/')
            *p = '\\';
    }

    /** Get the status of the drive if we need to **/
    Status = NTNetWareDriveStatus( DriveNumber );

    /** Get the status of the drive if we need to **/

    if (pStatus) {
        *pStatus = Status;
    }

    /** Get the full path if we need to **/

    if (pFullPath) {

        if (Status & NETWARE_LOCAL_FREE_DRIVE) {
            *pFullPath = 0;
        }
        else {
            strcpy(WorkPath, Path);

            /** Build the NetWare path format (volume:path) **/

            if (PathFormat == NETWARE_FORMAT_NETWARE) {
                strcpy(pFullPath, WorkPath);
            }

            /** Build the server volume path (server\volume:path) **/

            else if (PathFormat == NETWARE_FORMAT_SERVER_VOLUME) {
                sprintf(pFullPath, "%s\\%s", ServerName, WorkPath);
            }

            /** Build the drive path (G:\path) **/

            else if (PathFormat == NETWARE_FORMAT_DRIVE) {

                p = WorkPath;
                while (*p != ':' && *p) {
                    p++;
                }

                if (*p == ':') {
                    p++;
                }

                sprintf(pFullPath, "%c:\\%s", DriveNumber + 'A', p);
            }

            /** Build the UNC path (\\server\volume\path) **/

            else if (PathFormat == NETWARE_FORMAT_UNC) {

                p = WorkPath;
                while (*p != ':' && *p) {
                    p++;
                }

                if (*p == ':') {
                    *p = '\\';
                }

                sprintf(pFullPath, "\\\\%s\\%s", ServerName, WorkPath);
            }
        }
    }

    strcpy(WorkPath, Path);
    /*
     * Path does not have the relative path (current directory) in it.
     */

    /** Get the root path if we need to **/

    if (pRootPath) {

        if (Status & NETWARE_LOCAL_FREE_DRIVE) {
            *pRootPath = 0;
        }
        else {

            /** Build the NetWare root path format (volume:) **/

            if (PathFormat == NETWARE_FORMAT_NETWARE) {
                sprintf(pRootPath, strchr(WorkPath, ':')? "%s" : "%s:", WorkPath);
            }

            /** Build the server volume root path (server\volume:) **/

            else if (PathFormat == NETWARE_FORMAT_SERVER_VOLUME) {
                if ( fNDS && !_strcmpi( ServerName, NDSTREE) )
                    sprintf(pRootPath, strchr (WorkPath, ':')? "%s" : "%s:", WorkPath);
                else
                    sprintf(pRootPath, strchr (WorkPath, ':')? "%s\\%s" : "%s\\%s:", ServerName, WorkPath);
            }

            /** Build the drive root path (G:\) **/

            else if (PathFormat == NETWARE_FORMAT_DRIVE) {
                sprintf(pRootPath, "%c:\\", DriveNumber + 'A');
            }

            /** Build the UNC root path (\\server\volume) **/

            else if (PathFormat == NETWARE_FORMAT_UNC) {
                sprintf(pRootPath, "\\\\%s\\%s", ServerName, WorkPath);
            }
        }
    }

    /** Get the relative path if we need to **/

    if (pRelativePath) {

        if (Status & NETWARE_LOCAL_FREE_DRIVE) {
            *pRelativePath = 0;
        }
        else {
            int i;
            NTGetCurrentDirectory( (unsigned char)DriveNumber, pRelativePath );
            /* 
             * Skip the drive letter
             */
            if ( pRelativePath[0] ) {
                for ( i = 0; ;i++ ) {
                    pRelativePath[i] = pRelativePath[i+3];
                    if ( !pRelativePath[i] )
                        break;
                }
            }
        }
    }

    return 0x0000;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\dbcs.c ===
/*************************************************************************
*
*  DBCS.C
*
*  DBCS routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\DBCS.C  $
*  
*     Rev 1.1   22 Dec 1995 14:24:10   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:44   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:22:26   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:10:24   terryt
*  Initial revision.
*  
*************************************************************************/
/*
** dbcs.c - DBCS functions for DOS apps.
**
** Written by RokaH and DavidDi.
*/


/* Headers
**********/

// IsDBCSLeadByte taken out of NT because there is one built in.
// I left the Next and Prev in because I don't know whether this 
// algorithm is "safer" than the built in code.

#include "common.h"

/*
** unsigned char *NWAnsiNext(unsigned char *puch);
**
** Moves to the next character in a string.
**
** Arguments:  puch - pointer to current location in string
**
** Returns:    char * - Pointer to next character in string.
**
** Globals:    none
**
** N.b., if puch points to a null character, NWAnsiNext() will return puch.
*/
unsigned char *NWAnsiNext(unsigned char *puch)
{
   if (*puch == '\0')
      return(puch);
   else if (IsDBCSLeadByte(*puch))
      puch++;

   puch++;

   return(puch);
}


/*
** unsigned char *NWAnsiPrev(unsigned char *psz, unsigned char *puch);
**
** Moves back one character in a string.
**
** Arguments:  psz  - pointer to start of string
**             puch - pointer to current location in string
**
** Returns:    char * - Pointer to previous character in string.
**
** Globals:    none
**
** N.b., if puch <= psz, NWAnsiPrev() will return psz.
**
** This function is implemented in a very slow fashion because we do not wish
** to trust that the given string is necessarily DBCS "safe," i.e., contains
** only single-byte characters and valid DBCS characters.  So we start from
** the beginning of the string and work our way forward.
*/
unsigned char *NWAnsiPrev(unsigned char *psz, unsigned char *puch)
{
   unsigned char *puchPrevious;

   do
   {
      puchPrevious = psz;
      psz = NWAnsiNext(psz);
   } while (*psz != '\0' && psz < puch);

   return(puchPrevious);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\env.c ===
/*************************************************************************
*
*  ENV.C
* 
*  Environment export routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\ENV.C  $
*  
*     Rev 1.2   10 Apr 1996 14:22:28   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:53:48   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:24:40   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:06:58   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 16:22:50   terryt
*  Capture support
*  
*     Rev 1.1   23 May 1995 19:36:54   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:10:34   terryt
*  Initial revision.
*  
*************************************************************************/
#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "nwscript.h"

#define MAX_PATH_LEN 2048
#define PATH "Path"
#define LIBPATH "LibPath"
#define OS2LIBPATH "Os2LibPath"

unsigned char * Path_Value = NULL;
unsigned char * LibPath_Value = NULL;
unsigned char * Os2LibPath_Value = NULL;


/********************************************************************

        GetOldPaths

Routine Description:

        Save the orginal paths for 
           Path
           LibPath
           Os2LibPath

Arguments:
        none

Return Value:
        none

 *******************************************************************/
void
GetOldPaths( void )
{
    if (!(Path_Value = (unsigned char *)LocalAlloc( LPTR, MAX_PATH_LEN )))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }
    GetEnvironmentVariableA( PATH, Path_Value, MAX_PATH_LEN );
    if (!(LibPath_Value = (unsigned char *)LocalAlloc( LPTR, MAX_PATH_LEN)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }
    GetEnvironmentVariableA( LIBPATH, LibPath_Value, MAX_PATH_LEN );
    if (!(Os2LibPath_Value = (unsigned char *)LocalAlloc( LPTR, MAX_PATH_LEN)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }
    GetEnvironmentVariableA( OS2LIBPATH, Os2LibPath_Value, MAX_PATH_LEN );
}


/********************************************************************

        AdjustPath

Routine Description:

        Given an old path and a new path, merge the two togther.
        Basically, the Adjusted path is the old path with the
        new values at the end, minus any duplicates.

Arguments:

        Value         - New path
        OldPath_Value - Old path
        AdjustedValue - New value (allocated)

Return Value:
        none

 *******************************************************************/
void
AdjustPath( unsigned char * Value,
            unsigned char * OldPath_Value,
            unsigned char ** AdjustedValue )
{
    unsigned char * tokenPath;
    unsigned char * clipStart;
    unsigned char * clipEnd;
    unsigned char * tokenSearch;
    unsigned char * tokenNext;

    if (!(*AdjustedValue = (unsigned char *)LocalAlloc( LPTR, MAX_PATH_LEN)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }
    strncpy( *AdjustedValue, Value, MAX_PATH_LEN );

    if (!(tokenSearch = (unsigned char *)LocalAlloc( LPTR, MAX_PATH_LEN)))
    {
       DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
       (void) LocalFree((HLOCAL) *AdjustedValue) ;
       return;
    }
    strncpy( tokenSearch, OldPath_Value, MAX_PATH_LEN );

    tokenNext = tokenSearch;

    if ( !tokenNext || !tokenNext[0] ) 
        tokenPath = NULL;
    else {
        tokenPath = tokenNext;
        tokenNext = strchr( tokenPath, ';' );
        if ( tokenNext )  {
            *tokenNext++ = 0;
        }
    }

    while ( tokenPath != NULL )
    {
        if ( clipStart = strstr( *AdjustedValue, tokenPath ) ) {
            if ( clipEnd = strchr( clipStart, ';' ) ) {
                memmove( clipStart, clipEnd + 1, strlen( clipEnd + 1 ) + 1 );
            }
            else {
                clipStart[0] = 0;
            }
        }

        if ( !tokenNext || !tokenNext[0] ) 
            tokenPath = NULL;
        else {
            tokenPath = tokenNext;
            tokenNext = strchr( tokenPath, ';' );
            if ( tokenNext )  {
                *tokenNext++ = 0;
            }
        }
    }
    (void) LocalFree((HLOCAL) tokenSearch) ;

}

/********************************************************************

        ExportEnv

Routine Description:

        Export environment value to the registry

Arguments:

        EnvString - Environment string

Return Value:
        none

 *******************************************************************/
void
ExportEnv( unsigned char * EnvString )
{
    HKEY ScriptEnvironmentKey;
    NTSTATUS Status;
    unsigned char * Value;
    unsigned char * ValueName;
    unsigned char * AdjustedValue = NULL;

    ValueName = EnvString;
    Value = strchr( EnvString, '=' );

    if ( Value == NULL ) {
        wprintf(L"Bad Environment string\n");

        return;
    }
    Value++;

    if (!(ValueName = (unsigned char *)LocalAlloc( LPTR, Value-EnvString + 1)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return;
    }
    strncpy( ValueName, EnvString, (UINT) (Value-EnvString - 1) );

    if ( !_strcmpi( ValueName, PATH ) ) {
       AdjustPath( Value, Path_Value, &AdjustedValue );
       Value = AdjustedValue;
    }
    else if ( !_strcmpi( ValueName, LIBPATH ) ) {
       AdjustPath( Value, LibPath_Value, &AdjustedValue );
       Value = AdjustedValue;
    }
    else if ( !_strcmpi( ValueName, OS2LIBPATH ) ) {
       AdjustPath( Value, Os2LibPath_Value, &AdjustedValue );
       Value = AdjustedValue;
    }

    if (Value == NULL) {
        return;
    }

    Status = RegCreateKeyExW( HKEY_CURRENT_USER,
                                 SCRIPT_ENVIRONMENT_VALUENAME,
                                 0,
                                 WIN31_CLASS,
                                 REG_OPTION_VOLATILE,
                                 KEY_WRITE,
                                 NULL,                      // security attr
                                 &ScriptEnvironmentKey,
                                 NULL
                              );
    
    if ( NT_SUCCESS(Status)) {

        Status = RegSetValueExA( ScriptEnvironmentKey,
                                      ValueName,
                                 0,
                                 REG_SZ,
                                 (LPVOID) Value,
                                 strlen( Value ) + 1
                               );
    }
    else {
        wprintf(L"Cannot create registry key\n");
    }

    (void) LocalFree((HLOCAL) ValueName) ;

    if ( AdjustedValue )
        (void) LocalFree((HLOCAL) AdjustedValue) ;

    RegCloseKey( ScriptEnvironmentKey );
}

/********************************************************************

        ExportCurrentDirectory

Routine Description:

        Return the first non-local drive

Arguments:

        DriveNum - Number of drive 1-26

Return Value:
        none

 *******************************************************************/
void
ExportCurrentDirectory( int DriveNum )
{
    char DriveName[10];
    HKEY ScriptEnvironmentKey;
    NTSTATUS Status;
    char CurrentPath[MAX_PATH_LEN];

    strcpy( DriveName, "=A:" );

    DriveName[1] += (DriveNum - 1);

    if ( NTGetCurrentDirectory( (unsigned char)(DriveNum - 1), CurrentPath ) )
        return;

    Status = RegCreateKeyExW( HKEY_CURRENT_USER,
                                 SCRIPT_ENVIRONMENT_VALUENAME,
                                 0,
                                 WIN31_CLASS,
                                 REG_OPTION_VOLATILE,
                                 KEY_WRITE,
                                 NULL,                      // security attr
                                 &ScriptEnvironmentKey,
                                 NULL
                              );
    
    if ( NT_SUCCESS(Status)) {

        Status = RegSetValueExA( ScriptEnvironmentKey,
                                      DriveName,
                                 0,
                                 REG_SZ,
                                 (LPVOID) CurrentPath,
                                 strlen( CurrentPath ) + 1
                               );
    }
    else {
        wprintf(L"Cannot open registry key\n");
    }

    RegCloseKey( ScriptEnvironmentKey );

}


/********************************************************************

        ExportCurrentDrive

Routine Description:

        Export current drive to registry
        NOT IMPLEMENTED

Arguments:

        DriveNum - drive number

Return Value:
        none

 *******************************************************************/
void
ExportCurrentDrive( int DriveNum )
{
   /* 
    * Don't know if we want to do this or how.
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\helpers.c ===
/******************************************************************************
*
*  HELPERS.C
*
*  Various helper functions.
*
*  Copyright (c) 1995 Microsoft Corporation
*
*   $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\HELPERS.C  $
*  
*     Rev 1.1   22 Dec 1995 14:24:48   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:02   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:22:56   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:10:38   terryt
*  Initial revision.
*  
*  
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <locale.h>

#include "nwscript.h"


/*******************************************************************************
 *
 *  DisplayMessage
 *      Display a message with variable arguments.  Message
 *      format string comes from the application resources.
 *
 *  ENTRY:
 *      nID (input)
 *          Resource ID of the format string to use in the message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID
DisplayMessage( unsigned int nID, ... )
{
    WCHAR sz1[512];
    WCHAR sz2[1536];  
    int cch ;
    HANDLE  hOut;

    va_list args;
    va_start( args, nID );

    if ( LoadString( NULL, nID, sz1, 512 ) ) {

        vswprintf(sz2, sz1, args ) ;
        
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
        cch = wcslen(sz2) ;
        WriteConsole(hOut, sz2, cch, &cch, NULL);

    }

    va_end(args);

}  /* DisplayMessage() */


/*******************************************************************************
 *
 *  DisplayOemString
 *      Display an OEM string
 *
 *  ENTRY:
 *      string: string to display
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID
DisplayOemString( char *string )
{
    // this will print % in strings correctly.
    printf( "%s", string );

} /* DisplayAnsiString() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\maplist.c ===
/*************************************************************************
*
*  QATTACH.C
*
*  Do any neccessary attach user queries
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\MAPLIST.C  $
*  
*     Rev 1.1   10 Apr 1996 14:22:42   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.1   12 Mar 1996 19:53:58   terryt
*  Relative NDS names and merge
*  
*     Rev 1.0   22 Jan 1996 16:49:24   terryt
*  Initial revision.
*  
*************************************************************************/
#include "common.h"

//
//  4X login script behavior for map commands to servers not in the
//  logged in NDS tree that have not been ATTACH'ed is different from
//  the 3X behavior.
//
//  The 4X behavior is to always ask for a user name and password for
//  these servers, doing the attach at that point.  The user gets
//  two trys.
//
//  Since NT doesn't have an list of attached servers, and will try
//  to connect to a volume with the default user name and password,
//  a wrapper must be put around the MAP commands.  This code
//  must determine that a bindery connection will be made and that
//  this server has not previously been MAP'ed or ATTACH'ed.
//  The user will be always prompted for user name and password.
//  The server will then be logged into with those credentials.
//
//  One problem with the below is that it's not easy to tell that
//  a connection "will be" made with the bindery, this is done in
//  the redirector.  So to simplify things the assumption is that
//  only 3X servers use bindery connections.  This means that 
//  4X servers using bindery emulation on a different NDS tree will
//  not always be asked for the user name and password.
//
//  Already processed servers are kept in a list and marked as 4X or 3X
//  for possible future use.
//
//  The behavior for a 3X login depends on the LOGIN.EXE version.
//  The old behavior is that you must always ATTACH before mapping.
//  However, if you login to a 3X server with a 4X version LOGIN.EXE
//  it will try to authenticate using your user name (and password)
//  on the first attempt and ask for a password if that fails.  The
//  second attempt will ask for your user name.  Since this 4X behavior
//  is more forgiving (more scripts "work") that is the one being
//  emulated.
//

typedef struct _SERVERLIST
{
   char * ServerName;
   unsigned int ServerType;
   struct _SERVERLIST *pNextServer;
} SERVERLIST, *PSERVERLIST;

PSERVERLIST pMainList = NULL;

BOOL IsServerInAttachList( char *, unsigned int );
void AddServerToAttachList( char *, unsigned int );
int DoAttachProcessing( char * );

/*
 * Scan the list for the server
 */
BOOL
IsServerInAttachList( char * Server, unsigned int ServerType )
{
   PSERVERLIST pServerList = pMainList;

   while ( pServerList != NULL )
   {
       if ( !_strcmpi( Server, pServerList->ServerName ) &&
            ( ServerType & pServerList->ServerType ) )
           return TRUE;
        pServerList = pServerList->pNextServer;
   }
   
   return FALSE;
}

/*
 * Add the server to the list of attached servers
 *
 * This is used during MAP's and ATTACH's
 */
void
AddServerToAttachList( char * Server, unsigned int ServerType )
{
    PSERVERLIST pServerList;

    pServerList = (PSERVERLIST) malloc( sizeof( SERVERLIST ) );

    if ( pServerList == NULL )
    {
        DisplayMessage( IDR_NOT_ENOUGH_MEMORY );
        return;
    }

    pServerList->ServerName = _strdup( Server );
    pServerList->ServerType = ServerType;
    pServerList->pNextServer = pMainList;
    pMainList = pServerList;
}

/*
 *  Do any Attach processing
 *  Return error code. 0 is success.
 *  880F is the special "attached failed" error
 */

int
DoAttachProcessing( char * PossibleServer )
{
    unsigned int  iRet = 0;
    unsigned int  conn;
    char userName[MAX_NAME_LEN] = "";
    char password[MAX_PASSWORD_LEN] = "";
    BOOL AlreadyConnected = FALSE;

    //
    // Must have a server to process
    //
    if ( !*PossibleServer )
       return iRet;

    // See if this server has been processed before
    // No since in doing a 4X server twice, and you only ask
    // for the user name and password once.

    if ( IsServerInAttachList( PossibleServer,
             LIST_4X_SERVER | LIST_3X_SERVER ) )
        return iRet;

    // See if there is already a connection to the server

    if ( NTIsConnected( PossibleServer ) )
       AlreadyConnected = TRUE;
    else
       AlreadyConnected = FALSE;

    // Try and attach to the server

    iRet = NTAttachToFileServer( PossibleServer, &conn );

    // If attach failed, return

    if ( iRet ) 
       return iRet;

    // If this is a 4X server then add it to the list of attached
    // servers.  We don't want to do this again.  4X servers must 
    // use the NDS attachment anyway (or at least I don't see a 
    // way of telling that it's going to be a bindery emulation
    // connection ahead of time).

    if ( fNDS && Is40Server( conn ) )
    {
        AddServerToAttachList( PossibleServer, LIST_4X_SERVER );
        DetachFromFileServer ( conn );
        return iRet;
    }

    // Close that first connection

    DetachFromFileServer ( conn );

    // If we are already connected, don't mess with things
    // The credentials can't be changed anyway

    if ( AlreadyConnected )
    {
        AddServerToAttachList( PossibleServer, LIST_3X_SERVER );
        return iRet;
    }

    // Ask for user name on an NDS login
    //
    // Use the current login name for a 3X login on the first attempt

    if ( fNDS )
    {
        DisplayMessage(IDR_ENTER_LOGIN_NAME, PossibleServer);
        if (!ReadName(userName))
            return 0x880F;
    }
    else
    {
        strncpy( userName, LOGIN_NAME, sizeof( userName ) );
    }

    // Try to log the user in, asking for a password 

    iRet = Login( userName,
                  PossibleServer,
                  password,
                  TRUE );

    // Clear out the password
    // We don't need it again

    memset( password, 0, sizeof( password ) );

    // If failed, give the user one more chance

    if ( iRet )
    {
        // Ask for user name

        DisplayMessage(IDR_ENTER_LOGIN_NAME, PossibleServer);
        if (!ReadName(userName))
            return 0x880F;

        // Try to log the user in 

        iRet = Login( userName,
                      PossibleServer,
                      password,
                      TRUE );

        // Clear out the password

        memset( password, 0, sizeof( password ) );

    }
    
    // Add servername to list of attached servers, marked as 3X

    if ( !iRet )
    {
        AddServerToAttachList( PossibleServer, LIST_3X_SERVER );
    }
    else
    {  
        iRet = 0x880F;   // Special I am not attached error
    }

    return iRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\lsparse.c ===
/*
 * LSPARSE.C - NetWare Login Script processing routines for our Win32
 *             NetWare 3.x LOGIN clone.
 *
 * Based on code contained in NWPARSE.C, written by Xiao Ying Ding.
 *
 * Modified and re-written for Win32 by J. SOUZA, February 1994.
 *
 * Modified for NT by Terry Treder
 *
 * Copyright (C)1994 Microsoft Corporation.
 *
 */

#include <common.h>

/********************************************************************

        ConverNDSPathToNetWarePathA

Routine Description:

        Convert a NDS path to a Netware format path

Arguments:
        ndspath  - origninal NDS path
        objclass - type of NDS object, NULL if unknown
        nwpath   - Netware format path

Return Value:
        error

 *******************************************************************/
unsigned int
ConverNDSPathToNetWarePathA(char *ndspath, char *objclass, char *nwpath)
{
    CHAR    szDN[MAX_PATH];
    CHAR    szObjName[MAX_PATH];
    CHAR    cSave;
    CHAR    className[MAX_PATH];

    LPSTR   lpDelim = NULL;
    LPSTR   lpFilePath = "";
    LPSTR   lpszValue;
    LPSTR   path;
    LPSTR   volume;

    DWORD   dwRet;
    DWORD   length;
    UINT    NWStatus;
    char    bufAttribute[2048];

    // optimize for path beginning with drive letter
    // This assumes NDS volume and dir map names are at least 2 chars

    if (ndspath[1] == ':')
        return 1;    
    // strip ':' from path before this call
    if ( ( lpDelim = strchr(ndspath,':') ) != NULL
        || ((lpDelim = strchr(ndspath,'\\')) != NULL)) {
        cSave = *lpDelim;
        *lpDelim = '\0';
        lpFilePath = lpDelim+1;
    }

    if ( objclass == NULL ) {

        NWStatus = NDSCanonicalizeName( ndspath, szObjName, MAX_PATH, TRUE );

        if ( NWStatus != 0 ) {
#ifdef DEBUG
            printf("can't canonicalize [%s] (0x%x)\n",
                    ndspath, NWStatus );
#endif

            if (lpDelim) {
                *lpDelim = cSave;    
            }

            return 1;
        }


        NWStatus = NDSGetClassName( szObjName, className );

        if ( NWStatus != 0 ||
                    strcmp ( className, DSCL_SERVER    ) &&
                    strcmp ( className, DSCL_NCP_SERVER ) &&
                    strcmp ( className, DSCL_VOLUME ) &&
                    strcmp ( className, DSCL_QUEUE ) &&
                    strcmp ( className, DSCL_DIRECTORY_MAP )) {

#ifdef DEBUG
            printf("no path DSOBJ: %d (%s) (%s)\n",
                   NWStatus, szObjName, className );
#endif

            if (lpDelim) {
                *lpDelim = cSave;    
            }

            return 1;
        }

        objclass = className;
    }
    else
        strcpy ( szObjName, ndspath );

    if (lpDelim) {
        *lpDelim = cSave;    
    }

#ifdef DEBUG
    printf("ConvertNDSPath BEFORE [%s]\n", szObjName);
#endif

    //
    // Is f this is the server class object , we only need
    // to extract it's common name and put into netware format
    //
    if ((strcmp(objclass,DSCL_SERVER) == 0 ) ||
        (strcmp(objclass,DSCL_NCP_SERVER) == 0 )) {

        // Abbreaviate first to remove type qualifiers
        *szDN = '\0';
        if (0 != NDSAbbreviateName(FLAGS_LOCAL_CONTEXT,(LPSTR)szObjName,szDN)) {
            return 1;
        }

        lpDelim = strchr(szDN,'.');
        if (lpDelim) {
            *lpDelim = '\0';
        }

        strcpy(nwpath,szDN);

#ifdef DEBUG
        printf("Returning Netware path:%s\n",nwpath);
#endif

        return 0;

    } /* endif server class */

    //
    // If this is share class object ( volume or queue), we need
    // to find it's host server name and host resource name
    //
     if ((strcmp(objclass,DSCL_VOLUME) == 0 ) ||
        (strcmp(objclass,DSCL_QUEUE) == 0 )
        ) {

        //
        // Read host server name first. It comes back as distinguished
        // directory name, so we will need to extract server name from it
        //

        NWStatus = NDSGetProperty ( szObjName,
                                    DSAT_HOST_SERVER,
                                    bufAttribute,
                                    sizeof(bufAttribute),
                                    NULL );

        if (NWStatus != 0) {
#ifdef DEBUG
            printf("Get host server  failed. err=0x%x\n",NWStatus);
#endif
            return 1;
        }

        lpszValue = bufAttribute;
        ConvertUnicodeToAscii( lpszValue ); 

        //
        // Now copy server distinguished name into temporary buffer
        // and call ourselves to convert it to Netware
        //
        strcpy(szDN,lpszValue);

        dwRet  = ConverNDSPathToNetWarePathA(szDN, DSCL_SERVER, nwpath);
        if (dwRet) {
#ifdef DEBUG
            printf("Resolving server DN failed\n");
#endif
            //Break();
            return 1;
        }

        //
        // Get volume name itself
        //
        NWStatus = NDSGetProperty ( szObjName,
                                    DSAT_HOST_RESOURCE_NAME,
                                    bufAttribute,
                                    sizeof(bufAttribute),
                                    NULL );

        if (NWStatus != 0) {
#ifdef DEBUG
            printf("Get host resource name  failed. err=0x%x\n",NWStatus);
#endif
            return 1;
        }

        lpszValue = bufAttribute;
        ConvertUnicodeToAscii( lpszValue ); 

        //
        // Now we already have server name in the user buffer,
        // append share name to it
        strcat(nwpath,"/");
        strcat(nwpath,lpszValue);
        strcat(nwpath,":");
        strcat(nwpath, lpFilePath );

#ifdef DEBUG
        printf("Returning Netware path:%s\n",nwpath);
#endif

        return 0;

    }    /* endif Volume class */

    //
    // For directory maps we need to find host volume NDS name and
    // append relative directory path
    //
    if (strcmp(objclass,DSCL_DIRECTORY_MAP) == 0 ) {

        //
        // First get NDS name for host volume object
        //

        NWStatus = NDSGetProperty ( szObjName,
                                    DSAT_PATH,
                                    bufAttribute,
                                    sizeof(bufAttribute),
                                    NULL );

        if (NWStatus != 0) {
#ifdef DEBUG
            printf("Get path %s failed. err=0x%x\n", szObjName, NWStatus);
#endif
            return 1;
        }

        volume = bufAttribute;
        volume += sizeof(DWORD);
        volume += sizeof(DWORD);
        ConvertUnicodeToAscii( volume ); 

        // Path is next

        path = bufAttribute;
        path += sizeof(DWORD);
        length = ROUNDUP4(*(DWORD *)path);
        path += sizeof(DWORD);
        path += length;

        //
        // Check for 0 length paths
        //
        if ( *(DWORD *)path == 0 ) {
            path = "";
        }
        else {
            path += sizeof(DWORD);
            ConvertUnicodeToAscii( path ); 
        }

#ifdef DEBUG
        printf("path is %s\n",path);
#endif

        //
        // Now copy volume distinguished name into temporary buffer
        // and call ourselves to convert it to NetWare
        //
        strcpy(szDN,volume);

        dwRet  = ConverNDSPathToNetWarePathA(szDN, DSCL_VOLUME, nwpath);
        if (dwRet) {
#ifdef DEBUG
            printf("Resolving volume DN failed\n");
#endif
            //Break();
            return 1;
        }

        //
        // Now we already have NetWare server\volume name in the user buffer,
        // append directory path to it
        //strcat(nwpath,"\\");
        // we want only one '\'
        if (path[0] == '\\' || path[0] == '/') path++;
        strcat(nwpath,path);
        // append non-NDS part of path, if any
        if (*lpFilePath) {
            strcat(nwpath,"/");
            strcat(nwpath, lpFilePath );
        }

#ifdef DEBUG
        printf("Returning NetWare path:%s\n",nwpath);
#endif

        return 0;

    } /* endif DirectoryMap class */

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\ntnw.c ===
/*************************************************************************
*
*  NTNW.C
*
*  Dos NetWare to NT NetWare translation 
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NTNW.C  $
*  
*     Rev 1.1   22 Dec 1995 14:25:28   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:24   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 16:23:08   terryt
*  Capture support
*  
*     Rev 1.1   23 May 1995 19:37:10   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:10:44   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <direct.h>
#include <time.h>
#include "common.h"

extern int CONNECTION_ID;

/********************************************************************

        NTGetCurrentDirectory

Routine Description:

        Return the current directory.

Arguments:

        DriveNumber = The drive to get the directory from.
                        (0 = A, 1 = B, 2 = C, etc)
        pPath = A pointer to a 64 byte buffer to return the
                    current directory.

Return Value:

        0       Success
        else    Error

 ********************************************************************/

unsigned int
NTGetCurrentDirectory(
    unsigned char DriveNumber,
    unsigned char *pPath
    )
{
    char * CurPath;
    int currentDrive = _getdrive() ;

    //
    // Change to the drive and get its current working directory.
    // Default to root if fail to get cwd. DriveNumber is from 0.
    //

    _chdrive (DriveNumber+1);

    CurPath = _getcwd(NULL,MAX_PATH) ;

    if ( CurPath != NULL ) {
        
        strcpy( pPath, CurPath );
        free(CurPath) ;
    }
    else {

        strcpy( pPath, "A:\\" );
        pPath[0] += DriveNumber;
    }

    _chdrive (currentDrive);

    return 0;
}

/********************************************************************

        AttachToFileServer

Routine Description:

        Attach to a named file server

Arguments:

        pServerName      - Name of server
        pNewConnectionId - returned connection handle 

Return Value:
        0 = success
        else NetWare error

 *******************************************************************/
unsigned int
AttachToFileServer(
    unsigned char     *pServerName,
    unsigned int      *pNewConnectionId
    )
{
    unsigned int Result;

    if ( NTIsConnected( pServerName ) ) {
        return 0x8800;  // Already atached.
    }

    Result = NTAttachToFileServer( pServerName, pNewConnectionId );

    return Result;
}

/********************************************************************

        GetConnectionHandle

Routine Description:

        Given a server name, return the connection handle.
        The server should already be attached
        Note that this is not called for 4X servers.  It's used
        for attaches and bindery connections.

Arguments:

        pServerName       - Name of server
        pConnectionHandle - pointer to returned connection handle 

Return Value:
        0 = success
        else NetWare error

 *******************************************************************/
unsigned int
GetConnectionHandle(
    unsigned char *pServerName,
    unsigned int  *pConnectionHandle
    )
{
    unsigned int Result;

    if ( !NTIsConnected( pServerName ) ) {
        return 0xFFFF;  // not already connected
    }

    Result = NTAttachToFileServer( pServerName, pConnectionHandle );

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\nt.c ===
/*************************************************************************
*
*  NT.C
*
*  NT NetWare routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NT.C  $
*  
*     Rev 1.4   22 Dec 1995 14:25:12   terryt
*  Add Microsoft headers
*  
*     Rev 1.3   28 Nov 1995 17:13:28   terryt
*  Cleanup resource file
*  
*     Rev 1.2   22 Nov 1995 15:43:44   terryt
*  Use proper NetWare user name call
*  
*     Rev 1.1   20 Nov 1995 16:10:00   terryt
*  Close open NDS handles
*  
*     Rev 1.0   15 Nov 1995 18:07:18   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 16:23:02   terryt
*  Capture support
*  
*     Rev 1.1   23 May 1995 19:37:02   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:10:40   terryt
*  Initial revision.
*  
*************************************************************************/
#include <common.h>

#include <nwapi.h>
#include <npapi.h>

#include "ntnw.h"
/*
 * Name of NetWare provider
 */
TCHAR NW_PROVIDER[60];
unsigned char NW_PROVIDERA[60];

/********************************************************************

        NTPrintExtendedError

Routine Description:

        Print any extended errors from WNet routines

Arguments:
        None

Return Value:
        None

 *******************************************************************/
void
NTPrintExtendedError( void )
{
    DWORD ExError;
    wchar_t provider[32];
    wchar_t description[1024];

    if ( !WNetGetLastErrorW( &ExError, description, 1024, provider, 32 ) )
        wprintf(L"%s\n", description);
}


/********************************************************************

        NTInitProvider

Routine Description:

        Retrieve provider name and save old paths

Arguments:
        None

Return Value:
        None

 *******************************************************************/
void
NTInitProvider( void )
{
    HKEY hKey;
    DWORD dwType, dwSize;
    LONG Status;
    BOOL ret = FALSE;

    dwSize = sizeof(NW_PROVIDER);
    if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_PROVIDER, 0, KEY_READ, &hKey)) == ERROR_SUCCESS) {
        (void) RegQueryValueEx(hKey, REGISTRY_PROVIDERNAME, NULL, &dwType, (LPBYTE) NW_PROVIDER, &dwSize);
        WideTosz( NW_PROVIDERA, NW_PROVIDER, sizeof(NW_PROVIDERA) );
        RegCloseKey(hKey);
    }

    GetOldPaths();
}

/********************************************************************

        DeleteDriveBase

Routine Description:

        Disconnect drive from network

Arguments:

        DriveNumber - number of drive 1-26

Return Value:
        0 - success
        else NetWare error

 *******************************************************************/
unsigned int
DeleteDriveBase( unsigned short DriveNumber)
{
    static char drivename[] = "A:";
    unsigned int dwRes;

    drivename[0] = 'A' + DriveNumber - 1;

    dwRes = WNetCancelConnection2A( drivename, 0, TRUE );

    if ( dwRes != NO_ERROR )
        dwRes = GetLastError();

    if ( dwRes == ERROR_EXTENDED_ERROR )
        NTPrintExtendedError();

    return dwRes;
}

/********************************************************************

        DetachFromFileServer

Routine Description:

        Break connection from a file server

Arguments:

        ConnectionId - Connection handle

Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int
DetachFromFileServer( unsigned int ConnectionId )
{
    return ( NWDetachFromFileServer( (NWCONN_HANDLE)ConnectionId ) );
}


/********************************************************************

        NTLoginToFileServer

Routine Description:

        Login to a file server given a user name and password.

        If a NULL password is passed in, the default password should
        be tried if no password failed.

Arguments:

        pszServerName - Server name
        pszUserName   - User name
        pszPassword   - Password

Return Value:
        0 = success
        else NetWare error

 *******************************************************************/
unsigned int
NTLoginToFileServer(
    char          *pszServerName,
    char          *pszUserName,
    char          *pszPassword
    )
{
    NETRESOURCEA       NetResource;
    DWORD              dwRes;

    //
    // validate parameters
    //
    if (!pszServerName || !pszUserName || !pszPassword) {
        DisplayMessage(IDR_ERROR_DURING, "NTLoginToFileServer");
        return 0xffffffff ;
    }

    NetResource.dwScope      = 0 ;
    NetResource.dwUsage      = 0 ;
    NetResource.dwType       = RESOURCETYPE_ANY;
    NetResource.lpLocalName  = NULL;
    NetResource.lpRemoteName = pszServerName;
    NetResource.lpComment    = NULL;
    // NetResource.lpProvider   = NW_PROVIDERA ;
    // Allow OS to select provider in case localized name doesn't map to OEM code page
    NetResource.lpProvider   = NULL;


    //
    // make the connection 
    //
    dwRes=WNetAddConnection2A ( &NetResource, 
                                pszPassword, 
                                pszUserName,
                                0 );
    if ( dwRes != NO_ERROR )
       dwRes = GetLastError();

    //
    // Try default password if no password was specified
    //
    // The error numbers aren't (or weren't) reliable (ERROR_INVALID_PASSWORD)
    //
    if ( ( dwRes != NO_ERROR ) && ( pszPassword[0] == '\0' ) ) {
        dwRes=WNetAddConnection2A ( &NetResource, 
                                    NULL, 
                                    pszUserName,
                                        0 );
        if ( dwRes != NO_ERROR )
           dwRes = GetLastError();
    }

    return( dwRes );
}

/********************************************************************

        GetFileServerName

Routine Description:

        Return the server name associated with the connection ID

Arguments:

        ConnectionId - Connection ID to a server
        pServerName  - Returned server name

Return Value:
        0 - success
        else NT error

 *******************************************************************/
unsigned int
GetFileServerName(
    unsigned int      ConnectionId,
    char *            pServerName
    )
{
    unsigned int Result;
    VERSION_INFO VerInfo;

    *pServerName = '\0';

    Result = NWGetFileServerVersionInfo( (NWCONN_HANDLE) ConnectionId,
                                         &VerInfo );
    if ( !Result )
    {
        strcpy( pServerName, VerInfo.szName );
    }

    return Result;
}

/********************************************************************

        SetDriveBase

Routine Description:

        Connect a drive to a NetWare volume

Arguments:

        DriveNumber      - number of drive 1-26
        ServerName       - server name
        DirHandle        - not used
        pDirPath         - Volume:\Path

Return Value:
        0 = success
        else NetWare error

 *******************************************************************/
unsigned int
SetDriveBase(
    unsigned short   DriveNumber,
    unsigned char   *ServerName,
    unsigned int     DirHandle,
    unsigned char   *pDirPath
    )
{
    unsigned int Result = 0;
    static char driveName[] = "A:" ;

    /*
     * DirHandle is never used
     */

    driveName[0]= 'A' + DriveNumber - 1;

    if ( ( ServerName[0] == '\0' ) && fNDS ) {

        /*
         * Assume its an NDS volume name, if that fails, then
         * try a default file server volume.
         */
        Result = NTSetDriveBase( driveName, NDSTREE, pDirPath );

        if ( !Result )
            return Result;

        Result = NTSetDriveBase( driveName, PREFERRED_SERVER, pDirPath );

        return Result;
    }

    Result = NTSetDriveBase( driveName, ServerName, pDirPath );

    return Result;
}


/********************************************************************

        NTSetDriveBase

Routine Description:

        Connect a local name to a NetWare volume and path

Arguments:

        pszLocalName   -  local name to connect
        pszServerName  -  name of file server
        pszDirPath     -  Volume:\Path

Return Value:
        0 = success
        else NetWare error

 *******************************************************************/
unsigned int
NTSetDriveBase( unsigned char * pszLocalName,
                unsigned char * pszServerName,
                unsigned char * pszDirPath )
{
    NETRESOURCEA       NetResource;
    DWORD              dwRes, dwSize;
    unsigned char * pszRemoteName = NULL; 
    char * p;

    //
    // validate parameters
    //
    if (!pszLocalName || !pszServerName || !pszDirPath) {
        DisplayMessage(IDR_ERROR_DURING, "NTSetDriveBase");
        return 0xffffffff ;
    }

    //
    // allocate memory for string
    //
    dwSize = strlen(pszDirPath) + strlen(pszServerName) + 5 ;
    if (!(pszRemoteName = (unsigned char *)LocalAlloc(
                                       LPTR, 
                                       dwSize)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        dwRes = 0xffffffff;
        goto ExitPoint ; 
    }

    //
    // The requester understands 
    // server\volume:dir
    // but not
    // server\volume:\dir
    //
    // So just convert it to UNC
    //

    strcpy( pszRemoteName, "\\\\" );
    strcat( pszRemoteName, pszServerName );
    strcat( pszRemoteName, "\\" );
    strcat( pszRemoteName, pszDirPath );

    p = strchr( pszRemoteName, ':' );
    if ( !p ) {
        DisplayMessage(IDR_NO_VOLUME);
        dwRes = 0xffffffff;
        goto ExitPoint ; 
    }
    *p++ = '\\';

    if ( *p == '\\' ) {
       /* Don't want a double backslash */
       *p = '\0';
       p = strchr( pszDirPath, ':' );
       p++;
       p++;
       strcat( pszRemoteName, p );
    }

    //
    // strip off trailing backslash
    //
    if (pszRemoteName[strlen(pszRemoteName)-1] == '\\')
        pszRemoteName[strlen(pszRemoteName)-1] = '\0';

    NetResource.dwScope      = 0 ;
    NetResource.dwUsage      = 0 ;
    NetResource.dwType       = RESOURCETYPE_DISK;
    NetResource.lpLocalName  = pszLocalName;
    NetResource.lpRemoteName = pszRemoteName;
    NetResource.lpComment    = NULL;
    // NetResource.lpProvider   = NW_PROVIDERA ;
    // Allow OS to select provider in case localized name doesn't map to OEM code page
    NetResource.lpProvider   = NULL;

    //
    // make the connection 
    //
    dwRes=WNetAddConnection2A ( &NetResource, NULL, NULL, 0 );

    if ( dwRes != NO_ERROR )
        dwRes = GetLastError();

ExitPoint: 

    if (pszRemoteName)
        (void) LocalFree((HLOCAL) pszRemoteName) ;

    return( dwRes );
}


/********************************************************************

        Is40Server

Routine Description:

        Returns TRUE if 4X server

Arguments:

        ConnectionHandle - Connection Handle

Return Value:
        TRUE = 4X server
        FALSE = pre-4X server

 *******************************************************************/
unsigned int
Is40Server(
    unsigned int       ConnectionHandle
    )
{
    NTSTATUS NtStatus ;
    VERSION_INFO VerInfo;
    unsigned int Version;

    NtStatus = NWGetFileServerVersionInfo( (NWCONN_HANDLE)ConnectionHandle,
                                            &VerInfo );

    if (!NT_SUCCESS(NtStatus)) 
       FALSE;

    Version = VerInfo.Version * 1000 + VerInfo.SubVersion * 10;

    if ( Version >= 4000 ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

/********************************************************************

        CleanupExit

Routine Description:

        Does any cleanup and exits

Arguments:

        ExitCode - exit code for exit()

Return Value:
        does not return

 *******************************************************************/
void 
CleanupExit ( int ExitCode )
{
    if ( fNDS )
       NDSCleanup();

    exit( ExitCode );
}

/********************************************************************

        NTGetNWUserName

Routine Description:

        Get NetWare user name

Arguments:

        TreeBuffer  IN - wide string for server or tree
	UserName    OUT - user name 
	Length      IN - length of user name

Return Value:
        error message

 *******************************************************************/
int
NTGetNWUserName( PWCHAR TreeBuffer, PWCHAR UserName, int Length ) 
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | FILE_LIST_DIRECTORY;
    HANDLE hRdr;

    WCHAR DevicePreamble[] = L"\\Device\\Nwrdr\\";
    UINT PreambleLength = 14;

    WCHAR NameStr[64];
    UNICODE_STRING OpenName;
    UINT i;

    UNICODE_STRING NdsTree;

    //
    // Copy over the preamble.
    //

    OpenName.MaximumLength = sizeof( NameStr );

    for ( i = 0; i < PreambleLength ; i++ )
        NameStr[i] = DevicePreamble[i];

    RtlInitUnicodeString( &NdsTree, TreeBuffer );

    //
    // Copy the server or tree name.
    //

    for ( i = 0 ; i < ( NdsTree.Length / sizeof( WCHAR ) ) ; i++ ) {
        NameStr[i + PreambleLength] = NdsTree.Buffer[i];
    }

    OpenName.Length = (USHORT)(( i * sizeof( WCHAR ) ) +
		       ( PreambleLength * sizeof( WCHAR ) ));
    OpenName.Buffer = NameStr;

    //
    // Set up the object attributes.
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                &OpenName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL );

    ntstatus = NtOpenFile( &hRdr,
                           DesiredAccess,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   FILE_SHARE_VALID_FLAGS,
			   FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        return ntstatus;

    ntstatus = NtFsControlFile( hRdr,
                                NULL,
				NULL,
				NULL,
				&IoStatusBlock,
				FSCTL_NWR_GET_USERNAME,
				(PVOID) TreeBuffer,
				NdsTree.Length,
				(PVOID) UserName,
				Length );

   UserName[(USHORT)IoStatusBlock.Information/2] = 0;

   NtClose( hRdr );
   return ntstatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\ntcap.c ===
/*************************************************************************
*
*  NTCAP.C
*
*  NT NetWare routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NTCAP.C  $
*  
*     Rev 1.2   10 Apr 1996 14:23:04   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:54:36   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:25:20   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:20   terryt
*  Initial revision.
*  
*     Rev 1.0   25 Aug 1995 15:41:14   terryt
*  Initial revision.
*  
*  
*************************************************************************/

#include "common.h"
#include <ntddnwfs.h>
#include <nwapi.h>
#include <npapi.h>
#include "ntnw.h"

extern unsigned char NW_PROVIDERA[];

/********************************************************************

        EndCapture

Routine Description:

        Remove the local printer redirection

Arguments:
        LPTDevice - IN
            1, 2, or 3 - the local printer #

Return Value:
        Error 

 *******************************************************************/
unsigned int
EndCapture(
    unsigned char LPTDevice
    )
{
    char LPTname[] = "LPT1";
    unsigned int dwRes;

    LPTname[3] = '1' + LPTDevice - 1;

    /*
     * Should we check for non-NetWare printers?
     */

    dwRes = WNetCancelConnection2A( LPTname, 0, TRUE );

    if ( dwRes != NO_ERROR )
        dwRes = GetLastError();

    if ( dwRes == ERROR_EXTENDED_ERROR )
        NTPrintExtendedError();

    return dwRes;
}


/********************************************************************

        GetCaptureFlags

Routine Description:

    Return info about the printer capture status.  Note that the only
    options set on NT are on a per-user basis and can be changed with
    the control panel.

Arguments:
    LPTDevice - IN
        LPT device 1, 2 or 3
    pCaptureFlagsRW - OUT
        Capture options
    pCaptureFlagsRO - OUT
        Capture options

Return Value:

 *******************************************************************/
unsigned int
GetCaptureFlags(
    unsigned char        LPTDevice,
    PNETWARE_CAPTURE_FLAGS_RW pCaptureFlagsRW,
    PNETWARE_CAPTURE_FLAGS_RO pCaptureFlagsRO
    )
{
    LPBYTE       Buffer ; 
    DWORD        dwErr ;
    HANDLE       EnumHandle ;
    DWORD        Count ;
    char         LPTName[10];
    DWORD        BufferSize = 4096;
    char        *remotename;
    char        *p;
    DWORD        dwPrintOptions ;
    LPTSTR       pszPreferred ;

    strcpy( LPTName, "LPT1" );

    LPTName[3] = '1' + LPTDevice - 1;

    pCaptureFlagsRO->LPTCaptureFlag = 0;

    //
    // allocate memory and open the enumeration
    //
    if (!(Buffer = LocalAlloc( LPTR, BufferSize ))) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return 0xFFFF;
    }

    dwErr = WNetOpenEnum(RESOURCE_CONNECTED, 0, 0, NULL, &EnumHandle) ;
    if (dwErr != WN_SUCCESS) {
        dwErr = GetLastError();
        if ( dwErr == ERROR_EXTENDED_ERROR )
            NTPrintExtendedError();
        (void) LocalFree((HLOCAL) Buffer) ;
        return 0xFFFF;
    }

    do {

        Count = 0xFFFFFFFF ;
        BufferSize = 4096;
        dwErr = WNetEnumResourceA(EnumHandle, &Count, Buffer, &BufferSize) ;

        if ((dwErr == WN_SUCCESS || dwErr == WN_NO_MORE_ENTRIES)
            && ( Count != 0xFFFFFFFF) )
        {
            LPNETRESOURCEA lpNetResource ;
            DWORD i ;

            lpNetResource = (LPNETRESOURCEA) Buffer ;

            //
            // search for our printer
            //
            for ( i = 0; i < Count; lpNetResource++, i++ )
            {
                if ( lpNetResource->lpLocalName )
                {
                    if ( !_strcmpi(lpNetResource->lpLocalName, LPTName ))
                    {
                        if ( lpNetResource->lpProvider )
                        {
                            if ( _strcmpi( lpNetResource->lpProvider,
                                            NW_PROVIDERA ) )
                            {

                                pCaptureFlagsRO->LPTCaptureFlag = 0;
                            }
                              else
                            {
                                remotename = lpNetResource->lpRemoteName;
                                p = strchr (remotename + 2, '\\');
                                if ( !p ) 
                                    return 0xffffffff;
                                *p++ = '\0';
                                _strupr( remotename+2 );
                                _strupr( p );
                                strcpy( pCaptureFlagsRO->ServerName, remotename+2 );
                                strcpy( pCaptureFlagsRO->QueueName, p );
                                pCaptureFlagsRO->LPTCaptureFlag = 1;

                                pCaptureFlagsRW->JobControlFlags = 0;
                                pCaptureFlagsRW->TabSize = 8;
                                pCaptureFlagsRW->NumCopies = 1;
                                //
                                // query NW wksta for print options
                                //   & preferred server
                                //
                                if ( NwQueryInfo(&dwPrintOptions,
                                     &pszPreferred)) {
                                    pCaptureFlagsRW->PrintFlags =
                                        CAPTURE_FLAG_NOTIFY |
                                        CAPTURE_FLAG_PRINT_BANNER ;
                                }
                                else {
                                    pCaptureFlagsRW->PrintFlags = 0;
                                    if ( dwPrintOptions & NW_PRINT_PRINT_NOTIFY )
                                        pCaptureFlagsRW->PrintFlags |= 
                                            CAPTURE_FLAG_NOTIFY;
                                    if ( dwPrintOptions & NW_PRINT_SUPPRESS_FORMFEED)
                                        pCaptureFlagsRW->PrintFlags |= 
                                            CAPTURE_FLAG_NO_FORMFEED;
                                    if ( dwPrintOptions & NW_PRINT_PRINT_BANNER )
                                        pCaptureFlagsRW->PrintFlags |= 
                                            CAPTURE_FLAG_PRINT_BANNER;
                                }
                                pCaptureFlagsRW->FormName[0] = 0;
                                pCaptureFlagsRW->FormType = 0;
                                pCaptureFlagsRW->BannerText[0] = 0;
                                pCaptureFlagsRW->FlushCaptureTimeout = 0;
                                pCaptureFlagsRW->FlushCaptureOnClose = 1;
                             }
                        }
                         else
                        {
                            pCaptureFlagsRO->LPTCaptureFlag = 0;
                        }
 
                        (void) WNetCloseEnum(EnumHandle) ; 
                        (void) LocalFree((HLOCAL) Buffer) ;
                          return 0;
                    }
                }
            }
        }

    } while (dwErr == WN_SUCCESS) ;

    if ( ( dwErr != WN_SUCCESS ) && ( dwErr != WN_NO_MORE_ENTRIES ) )
    {
        dwErr = GetLastError();
        if ( dwErr == ERROR_EXTENDED_ERROR )
            NTPrintExtendedError();
    }

    (void ) WNetCloseEnum(EnumHandle) ;
    (void) LocalFree((HLOCAL) Buffer) ;

    return 0;
}

/********************************************************************

        StartQueueCapture

Routine Description:

    Attach local name to the queue.


Arguments:
    ConnectionHandle - IN
       Handle to file server
    LPTDevice - IN
       LPT 1, 2 or 3
    pServerName - IN
       Server name
    pQueueName - IN
       Printer queue name

Return Value:

 *******************************************************************/
unsigned int
StartQueueCapture(
    unsigned int    ConnectionHandle,
    unsigned char   LPTDevice,
    unsigned char  *pServerName,
    unsigned char  *pQueueName
    )
{
    NETRESOURCEA       NetResource;
    DWORD              dwRes, dwSize;
    unsigned char * pszRemoteName = NULL; 
    unsigned char pszLocalName[10];
    char * p;

    //
    // validate parameters
    //
    if (!pServerName || !pQueueName || !LPTDevice) {
        DisplayMessage(IDR_ERROR_DURING, "StartQueueCapture");
        return 0xffffffff ;
    }

    //
    // allocate memory for string
    //
    dwSize = strlen(pServerName) + strlen(pQueueName) + 5 ;
    if (!(pszRemoteName = (unsigned char *)LocalAlloc(
                                       LPTR, 
                                       dwSize)))
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        dwRes = 0xffffffff;
        goto ExitPoint ; 
    }

    sprintf(pszRemoteName, "\\\\%s\\%s", pServerName, pQueueName);
    sprintf(pszLocalName, "LPT%d", LPTDevice );

    NetResource.dwScope      = 0 ;
    NetResource.dwUsage      = 0 ;
    NetResource.dwType       = RESOURCETYPE_PRINT;
    NetResource.lpLocalName  = pszLocalName;
    NetResource.lpRemoteName = pszRemoteName;
    NetResource.lpComment    = NULL;
    // NetResource.lpProvider   = NW_PROVIDERA ;
    // Allow OS to select provider in case localized name doesn't map to OEM code page
    NetResource.lpProvider   = NULL; 

    //
    // make the connection 
    //
    dwRes=WNetAddConnection2A ( &NetResource, NULL, NULL, 0 );

    if ( dwRes != NO_ERROR )
        dwRes = GetLastError();

ExitPoint: 

    if (pszRemoteName)
        (void) LocalFree((HLOCAL) pszRemoteName) ;

    return( dwRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\ncp.c ===
/*************************************************************************
*
*  NCP.C
*
*  All routines doing direct NCPs or filecontrol operations
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NCP.C  $
*  
*     Rev 1.2   10 Apr 1996 14:22:50   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:54:06   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:24:56   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:10   terryt
*  Initial revision.
*  
*************************************************************************/
#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <nwapi32.h>
#include <ntddnwfs.h>

#include "nwscript.h"
#include "ntnw.h"
#include "inc/nwlibs.h"


/********************************************************************

        NTGetUserID

Routine Description:

        Given a connection handle, return the user ID

Arguments:

        ConnectionHandle - Connection Handle
        UserID           - returned User ID

Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int
NTGetUserID(
    unsigned int       ConnectionHandle,
    unsigned long      *pUserID
    )
{
    NTSTATUS NtStatus ;
    unsigned int ObjectType;
    unsigned char LoginTime[7];
    unsigned char UserName[48];
    VERSION_INFO VerInfo;
    unsigned int Version;
    unsigned int ConnectionNum;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ; 

    NtStatus = GetConnectionNumber( ConnectionHandle, &ConnectionNum );

    if (!NT_SUCCESS(NtStatus)) 
       return NtStatus;

    NtStatus = NWGetFileServerVersionInfo( (NWCONN_HANDLE)ConnectionHandle,
                                            &VerInfo );

    if (!NT_SUCCESS(NtStatus)) 
       return NtStatus;

    Version = VerInfo.Version * 1000 + VerInfo.SubVersion * 10;

    if ( ( Version >= 3110 ) || ( Version < 2000 ) ) {
        NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    8,                      // Max request packet size
                    63,                     // Max response packet size
                    "br|rrrr",              // Format string
                    // === REQUEST ================================
                    0x1c,                   // b Get Connection Information
                    &ConnectionNum, 4,      // r Connection Number
                    // === REPLY ==================================
                    pUserID, 4,             // r Object ID
                    &ObjectType, 2,         // r Object Type
                    UserName, 48,           // r UserName
                    LoginTime, 7            // r Login Time
                    );
    }
    else {
        NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    4,                      // Max request packet size
                    63,                     // Max response packet size
                    "bb|rrrr",              // Format string
                    // === REQUEST ================================
                    0x16,                   // b Get Connection Information
                    ConnectionNum,          // b Connection Number
                    // === REPLY ==================================
                    pUserID, 4,             // r Object ID
                    &ObjectType, 2,         // r Object Type
                    UserName, 48,           // r UserName
                    LoginTime, 7            // r Login Time
                    );
    }

    return NtStatus;
}

/********************************************************************

        GetConnectionNumber

Routine Description:

        Given a ConnectionHandle, return the NetWare Connection number

Arguments:

        ConnectionHandle  - Connection Handle
        pConnectionNumber - pointer to returned connection number

Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int
GetConnectionNumber(
    unsigned int       ConnectionHandle,
    unsigned int *     pConnectionNumber )
{
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    NWR_GET_CONNECTION_DETAILS Details;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ; 

    Status = NtFsControlFile(
                 pServerInfo->hConn,     // Connection Handle
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 FSCTL_NWR_GET_CONN_DETAILS,
                 NULL,
                 0,
                 (PVOID) &Details,
                 sizeof(Details));

    if (Status == STATUS_SUCCESS) {
        Status = IoStatusBlock.Status;
    }

    if (NT_SUCCESS(Status)) {
        *pConnectionNumber = 256 * Details.ConnectionNumberHi +
                             Details.ConnectionNumberLo;
    }

    return Status;
}

/********************************************************************

        GetInternetAddress

Routine Description:

        Return the address of the current system

Arguments:

        ConnectionHandle - Connection Handle
        ConnectionNum    - Connection Number
        pAddress         - returned address

Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int
GetInternetAddress(
    unsigned int       ConnectionHandle,
    unsigned int       ConnectionNum,
    unsigned char      *pAddress
    )
{
    NTSTATUS NtStatus ;
    VERSION_INFO VerInfo;
    unsigned int Version;
    unsigned char Address[12];
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ; 

    NtStatus = NWGetFileServerVersionInfo( (NWCONN_HANDLE)ConnectionHandle,
                                            &VerInfo );

    if (!NT_SUCCESS(NtStatus)) 
       return NtStatus;

    Version = VerInfo.Version * 1000 + VerInfo.SubVersion * 10;

    if ( ( Version >= 3110 ) || ( Version < 2000 ) ) {
        NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    7,                      // Max request packet size
                    14,                     // Max response packet size
                    "br|r",                 // Format string
                    // === REQUEST ================================
                    0x1a,                   // b Get Connection Information
                    &ConnectionNum, 4,      // r Connection Number
                    // === REPLY ==================================
                    Address, 12             // r Login Time
                    );
    }
    else {
        NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Bindery function
                    4,                      // Max request packet size
                    14,                     // Max response packet size
                    "bb|r",                 // Format string
                    // === REQUEST ================================
                    0x13,                   // b Get Connection Information
                    (unsigned char)ConnectionNum, // b Connection Number
                    // === REPLY ==================================
                    Address, 12             // r Login Time
                    );
    }
    memcpy( pAddress, Address, 10 );

    return NtStatus;
}


/********************************************************************

        GetBinderyObjectID

Routine Description:

        Get the object ID of a named object in the bindery

Arguments:

        ConnectionHandle - Server connection handle
        pObjectName      - Name of object
        ObjectType       - Object type
        pObjectId        - returned object ID


Return Value:
        0 = success
        else NT error

 *******************************************************************/
unsigned int
GetBinderyObjectID( 
    unsigned int       ConnectionHandle,
    char              *pObjectName,
    unsigned short     ObjectType,
    unsigned long     *pObjectId )
{
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ; 
    unsigned int reply;

    reply = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    FSCTL_NWR_NCP_E3H,      // Directory function
                    54,                     // Max request packet size
                    56,                     // Max response packet size
                    "brp|r",                // Format string
                    // === REQUEST ================================
                    0x35,                   // b Get object ID
                    &ObjectType, W_SIZE,    // r Object type HI-LO
                    pObjectName,            // p UserName
                    // === REPLY ==================================
                    pObjectId, 4            // 4 bytes of raw data
                    );
    return reply;
}

/********************************************************************

        GetDefaultPrinterQueue

Routine Description:

    Get the default printer queue.

Arguments:
    ConnectionHandle - IN
       Handle to server
    pServerName - IN
       File server name
    pQueueName - OUT
       Default printer queue name
        

Return Value:

 *******************************************************************/
unsigned int
GetDefaultPrinterQueue (
    unsigned int  ConnectionHandle,
    unsigned char *pServerName,
    unsigned char *pQueueName
    )
{
    unsigned long      ObjectID;
    NTSTATUS           NtStatus ;
    PNWC_SERVER_INFO   pServerInfo = (PNWC_SERVER_INFO)ConnectionHandle ; 
    NWOBJ_TYPE         ObjectType;
    NWCCODE            Nwcode;

    NtStatus = NwlibMakeNcp(
                    pServerInfo->hConn,     // Connection Handle
                    NWR_ANY_F2_NCP(0x11),   // F2 Function function
                    4,                      // Max request packet size
                    4,                      // Max response packet size
                    "wbb|d",                // Format string
                    // === REQUEST ================================
                    0x2,                    // w Length
                    0xA,                    // b Subfunction
                    0,                      // b printer number
                    // === REPLY ==================================
                    &ObjectID               // d Object ID of Queue
                    );

    if ( !NT_SUCCESS( NtStatus ) )
        return ( NtStatus & 0xFF );

    Nwcode = NWGetObjectName( (NWCONN_HANDLE) ConnectionHandle,
                              ObjectID,
                              pQueueName,
                              &ObjectType ); 

    return Nwcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\nds.c ===
/*************************************************************************
*
*  NDS.C
*
*  NT NetWare NDS routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*************************************************************************/
#include <common.h>

DWORD GUserObjectID;
HANDLE GhRdrForUser;
HANDLE GhRdr;


WCHAR * NDSTREE_w = NULL;
UNICODE_STRING NDSTREE_u;

/********************************************************************

        ExpandRelativeName

Routine Description:

        If the name is a relative NDS name append the proper context
        to the end.   A relative name has periods on the end.  Each
        period represents one level up the NDS tree.

Arguments:

Return Value:

 *******************************************************************/
void
ExpandRelativeName( LPSTR RelativeName, LPSTR AbsoluteName, unsigned int Len,
                    LPSTR Context )
{

   PBYTE ptr;
   unsigned int   i;
   unsigned int   count = 0;

   strncpy( AbsoluteName, RelativeName, Len );

   if ( ( AbsoluteName[0] == '.' ) &&
        ( AbsoluteName[ strlen( AbsoluteName ) - 1 ] != '.' ) )
       return;

   if ( ( strlen( AbsoluteName ) + strlen( Context ) ) > Len )
   {
       DisplayMessage( IDR_NOT_ENOUGH_MEMORY );
       return;
   }

   if ( AbsoluteName[0] == '\0' )
   {
       return;
   }

   ptr = &AbsoluteName[ strlen( AbsoluteName ) - 1 ];

   // Count the number of periods and back up over them.

   if ( *ptr != '.' )
   {
       //
       // No periods at the end
       // Assume this is a relative name and append the context
       //
       strcat( AbsoluteName, "." );
       strcat( AbsoluteName + strlen( AbsoluteName ), Context );
       return;
   }

   while ( *ptr == '.' )
   {
       ptr--;
       count++;
   }

   ptr++;
   *ptr = '\0';

   // ptr now points to where the copy of the rest of the context should start
   // skip the first "count" entries in the context

   ptr = Context;

   for ( i = 0; i < count; i++ )
   {
      ptr = strchr( ptr, '.' );
      if ( ptr == NULL )
      {
          return;
      }
      ptr++;
   }
   ptr--;

   // Now append

   strcat( AbsoluteName, ptr );

}



/********************************************************************

        NDSGetNameContext

Routine Description:

        Get the current context

Arguments:
        none

Return Value:
        none

 *******************************************************************/
NTSTATUS
NDSGetNameContext( LPSTR Context, BOOLEAN flag )
{
    //
    // For NdsResolveName.
    //

    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    HANDLE hReferredServer;
    DWORD dwHandleType;

    NTSTATUS Status;

    OEM_STRING oemStr;
    UNICODE_STRING defaultcontext;
    DWORD ThisObjectID;
    BYTE  Buffer[2048];
    WCHAR NdsStr[1024];
    PBYTE ptr;

    defaultcontext.Length = 0;
    defaultcontext.MaximumLength = sizeof( NdsStr );
    defaultcontext.Buffer = NdsStr;

    Status = NwNdsGetTreeContext( GhRdr, &NDSTREE_u, &defaultcontext );

    if ( !NT_SUCCESS( Status ) ) {
       return Status;
    }

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( GhRdr,
                                &defaultcontext,
                                &ThisObjectID,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       return Status;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // should change the global handle.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            DisplayMessage(IDR_NDS_USERNAME_FAILED);
            return Status;
        }

        if( GhRdr != GhRdrForUser ) {
            CloseHandle( GhRdr );
        }
        GhRdr = hReferredServer;
    }

    Status = NwNdsReadObjectInfo( GhRdr, ThisObjectID, Buffer, 2048 );

    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    ptr = Buffer + sizeof( NDS_RESPONSE_GET_OBJECT_INFO );
    ptr += ROUNDUP4(*(DWORD *)ptr);
    ptr += sizeof(DWORD);
    ptr += sizeof(DWORD);

    defaultcontext.Length = wcslen( (WCHAR *)ptr ) * 2;
    defaultcontext.MaximumLength = defaultcontext.Length;
    defaultcontext.Buffer = (WCHAR *)ptr;

    oemStr.Length = 0;
    oemStr.MaximumLength = NDS_NAME_CHARS;
    oemStr.Buffer = Context;

    RtlUnicodeStringToOemString( &oemStr, &defaultcontext, FALSE );

    return 0;
}

/********************************************************************

        NDSTypeless

Routine Description:

        Change name to typelese

Arguments:
        none

Return Value:
        none

 *******************************************************************/
unsigned int
NDSTypeless( LPSTR OrigName , LPSTR TypelessName )
{
    int i,j;
    PBYTE p;

    i = 0;
    j = 0;

    if ( !_strnicmp( "CN=", OrigName, 3 ) ||
         !_strnicmp( "OU=", OrigName, 3 ) )
    {
       i += 3;
    }
    else if ( !_strnicmp( "C=", OrigName, 2 ) ||
              !_strnicmp( "O=", OrigName, 2 ) )
    {
       i += 2;
    }

    for ( ; (( i < NDS_NAME_CHARS ) && ( OrigName[i] ) ); i++ )
    {
       if ( !_strnicmp( ".CN=", &OrigName[i], 4 ) ||
            !_strnicmp( ".OU=", &OrigName[i], 4 ) )
       {
          TypelessName[j++]= '.';
          i += 3;
          continue;
       }
       if ( !_strnicmp( ".C=", &OrigName[i], 3 ) ||
            !_strnicmp( ".O=", &OrigName[i], 3 ) )
       {
          TypelessName[j++]= '.';
          i += 2;
          continue;
       }
       /*
        * Strip out multiple blanks
        */
       if ( !_strnicmp( "  ", &OrigName[i], 2 ) )
       {
          continue;
       }
       TypelessName[j++] = OrigName[i];
    }

    TypelessName[j] = '\0';

    return 0;
}

/********************************************************************

        NDSAbbreviateName

Routine Description:

        Abbreviate name

Arguments:
        none

Return Value:
        none

 *******************************************************************/
unsigned int
NDSAbbreviateName( DWORD Flags, LPSTR OrigName , LPSTR AbbrevName )
{
    BYTE Buffer[NDS_NAME_CHARS];
    BYTE CurrentContext[NDS_NAME_CHARS];
    PBYTE p;
    PBYTE c;
    NTSTATUS Status;

    if ( OrigName[0] == '.' )
        NDSTypeless( OrigName + 1, Buffer );
    else
        NDSTypeless( OrigName, Buffer );

    /*
     * We want a relative name
     */
    if ( Flags & FLAGS_LOCAL_CONTEXT )
    {
        p = &Buffer[strlen(Buffer)-strlen(REQUESTER_CONTEXT)];
        if ( !_strcmpi( REQUESTER_CONTEXT, p ) )
        {
            // The name is below us

            if ( ( *(p-1) == '.' ) && ( p > Buffer ) )
               p--;
            *p = '\0';
            strcpy( AbbrevName, Buffer );
        }
        else
        {
            //
            // Going from back to front for each section of context
            // in common with AbbrevName
            //    truncate both
            // Going from back to front for each section of context
            // left over
            //    concatonate a period to AbbrevName
            //
            // Example
            //
            // Name: w.x.y.z  Context: a.b.z  =>  w.x.y..
            //

            strcpy( CurrentContext, REQUESTER_CONTEXT );
            strcpy( AbbrevName, Buffer );

            if ( CurrentContext[0] && AbbrevName[0] )
            {
                c = &CurrentContext[ strlen( CurrentContext ) ] - 1;
                p = &AbbrevName[ strlen( AbbrevName ) ] - 1;

                //
                // Strip off the matching names from end to front
                //
                for ( ;; )
                {
                    if ( ( c == CurrentContext ) && ( *p == '.' ) )
                    {
                        *c = '\0';
                        *p = '\0';
                        break;
                    }

                    if ( *c != *p )
                        break;

                    if ( ( *c == '.' ) && ( *p == '.' ) )
                    {
                        *c = '\0';
                        *p = '\0';
                    }

                    if ( ( c == CurrentContext ) || ( p == AbbrevName ) )
                    {
                        break;
                    }

                    c--; p--;
                }

                //
                // Count the remaining sections of the context and
                // add that number of periods to the end of the buffer.
                // That is how far we need to back up before getting
                // to a matching branch of the tree.
                //

                if ( CurrentContext[0] ) {
                    strcat( AbbrevName, "." );
                    for ( c = CurrentContext; *c; c++ ) {
                        if ( *c == '.' )
                            strcat( AbbrevName, "." );
                    }
                }
            }

        }
    }
    else
        strcpy( AbbrevName, Buffer );

    return 0;
}


/********************************************************************

        NDSInitUserProperty

Routine Description:

        none

Arguments:
        none

Return Value:
        0 = no error

 *******************************************************************/
unsigned int
NDSInitUserProperty( )
{
    NTSTATUS Status;
    UNICODE_STRING ObjectName;
    PWCHAR lpT;
    UNICODE_STRING defaultcontext;

    //
    // For NdsResolveName.
    //

    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    HANDLE hReferredServer;
    DWORD dwHandleType;

    //
    // Get a handle to the redirector.
    //

    Status = NwNdsOpenTreeHandle( &NDSTREE_u, &GhRdr );

    if ( !NT_SUCCESS( Status ) ) {
        DisplayMessage(IDR_TREE_OPEN_FAILED);
        return 1;
    }

    //
    // Resolve the name that we have to an object id.
    //

    RtlInitUnicodeString( &ObjectName, TYPED_USER_NAME_w );

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( GhRdr,
                                &ObjectName,
                                &GUserObjectID,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       DisplayMessage(IDR_NDS_USERNAME_FAILED);
       return 1;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // should change the global handle.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            DisplayMessage(IDR_NDS_USERNAME_FAILED);
            return 1;
        }

        CloseHandle( GhRdr );
        GhRdr = hReferredServer;

    }

    //
    //  Save off this handle for the user so that we can use it to
    //  get information about the user.
    //

    GhRdrForUser = GhRdr;

    //
    // Set the current context to what we think it should be
    // (At the user's location.)
    //

    lpT = wcschr( TYPED_USER_NAME_w, L'.' );
    while (lpT) // handle usernames with embedded/escaped dots
    {
        if (*(lpT-1) == L'\\')
        {
            lpT = wcschr (lpT+1, L'.');
        }
        else
            break;
    }
    if ( lpT )
    {
        RtlInitUnicodeString( &defaultcontext, lpT+1 );
    }
    else
    {
        RtlInitUnicodeString( &defaultcontext, L"" );
    }

    Status = NwNdsSetTreeContext( GhRdr, &NDSTREE_u, &defaultcontext );

    if ( !NT_SUCCESS( Status ) ) {
       DisplayMessage(IDR_NDS_CONTEXT_INVALID);
       return 1;
    }

    return 0;


}

/********************************************************************

        NDSCanonicalizeName

Routine Description:

        return a canonicalized version of a name

Arguments:
        Name - original name
        CanonName - Canonicalized name
        Len - length of CanonName
        fCurrentContext - TRUE => use current contex, FALSE use
                          requester context

Return Value:
        status error

 *******************************************************************/
unsigned int
NDSCanonicalizeName( PBYTE Name, PBYTE CanonName, int Len, int fCurrentContext )
{
    NTSTATUS Status;
    int ccode = -1;
    DWORD ThisObjectID;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    BYTE Buffer[2048];
    BYTE FullName[NDS_NAME_CHARS];
    PBYTE ptr;
    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    DWORD dwHandleType;
    HANDLE hReferredServer;
    unsigned char CurrentContext[NDS_NAME_CHARS];

    //
    // Cope with relative names
    //
    if ( fCurrentContext )
    {
        Status = NDSGetNameContext( CurrentContext, TRUE );
        if ( !NT_SUCCESS( Status ) )
            return Status;
        ExpandRelativeName( Name, FullName, NDS_NAME_CHARS, CurrentContext );
    }
    else
        ExpandRelativeName( Name, FullName, NDS_NAME_CHARS, REQUESTER_CONTEXT );

    //
    // Fill it in in case we have an error
    //
    strncpy( CanonName, FullName, Len);

    //
    // Resolve the name that we have to an object id.
    //
    // Unfortuneately, the name resolver doesn't understand periods at the
    // front or end (absolute or relative names)
    //

    if ( FullName[0] == '.' )
    {
        oemStr.Length = (USHORT)strlen( FullName + 1 );
        oemStr.MaximumLength = oemStr.Length;
        oemStr.Buffer = FullName + 1;
    }
    else
    {
        oemStr.Length = (USHORT)strlen( FullName );
        oemStr.MaximumLength = oemStr.Length;
        oemStr.Buffer = FullName;
    }

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(Buffer);
    ObjectName.Buffer = (WCHAR *)Buffer;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( GhRdr,
                                &ObjectName,
                                &ThisObjectID,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       return Status;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // should change the global handle.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            return Status;
        }

        if( GhRdr != GhRdrForUser ) {
            CloseHandle( GhRdr );
        }
        GhRdr = hReferredServer;
    }

    Status = NwNdsReadObjectInfo( GhRdr, ThisObjectID, Buffer, 2048 );
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    ptr = Buffer + sizeof( NDS_RESPONSE_GET_OBJECT_INFO );
    ptr += ROUNDUP4(*(DWORD *)ptr);
    ptr += sizeof(DWORD);
    ptr += sizeof(DWORD);

    RtlInitUnicodeString( &ObjectName, (PWCHAR)ptr );

    oemStr.Length = 0;
    oemStr.MaximumLength = (USHORT) Len;
    oemStr.Buffer = CanonName;

    RtlUnicodeStringToOemString( &oemStr, &ObjectName, FALSE );

    return 0;
}

/********************************************************************

        NDSGetUserProperty

Routine Description:

        Return the NDS property for the object

Arguments:
        Property - property name
        Data     - data buffer
        Size     - size of data buffer

Return Value:
        0 no error

 *******************************************************************/
unsigned int
NDSGetUserProperty( PBYTE Property,
                    PBYTE Data,
                    unsigned int Size,
                    SYNTAX * pSyntaxID,
                    unsigned int * pActualSize )
{
    NTSTATUS Status = STATUS_SUCCESS;
    int ccode = -1;

    OEM_STRING oemStr;
    UNICODE_STRING PropertyName;
    WCHAR NdsStr[1024];
    DWORD iterhandle = INITIAL_ITERATION;

    PBYTE szBuffer;
    DWORD dwBufferSize = 2048;
    PNDS_RESPONSE_READ_ATTRIBUTE pReadAttribute;
    PNDS_ATTRIBUTE pAttribute;
    PBYTE pAttribValue;
    BOOL  fContinue = TRUE;

    //
    // Read the User property
    //

    szBuffer = (PBYTE)malloc(dwBufferSize);

    if ( !szBuffer ) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        Status = STATUS_NO_MEMORY;
        return Status;
    }
    memset( szBuffer, 0, dwBufferSize );

    oemStr.Length = (USHORT) strlen( Property );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Property;

    PropertyName.Length = 0;
    PropertyName.MaximumLength = sizeof(NdsStr);
    PropertyName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &PropertyName, &oemStr, FALSE );

    while ( fContinue )
    {
        Status = NwNdsReadAttribute ( GhRdrForUser,
                                      GUserObjectID,
                                      &iterhandle,
                                      &PropertyName,
                                      szBuffer,
                                      dwBufferSize );

        if ( NT_SUCCESS(Status) && iterhandle != INITIAL_ITERATION )
        {
            dwBufferSize *= 2;

            free( szBuffer );

            szBuffer = (PBYTE)malloc(dwBufferSize);

            if ( !szBuffer ) {
                DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
                Status = STATUS_NO_MEMORY;
                return Status;
            }
            memset( szBuffer, 0, dwBufferSize );
            iterhandle = INITIAL_ITERATION;
        }
        else
        {
            fContinue = FALSE;
        }
    }

    if ( !NT_SUCCESS(Status) )
    {
        if ( szBuffer )
            free( szBuffer );
        return Status;
    }

    if ( NT_SUCCESS(Status) )
    {
        int i;
        pReadAttribute = (PNDS_RESPONSE_READ_ATTRIBUTE)szBuffer;
        pAttribute = (PNDS_ATTRIBUTE)(szBuffer
                      + sizeof(NDS_RESPONSE_READ_ATTRIBUTE));
        if ( pSyntaxID )
        {
            *pSyntaxID = pAttribute->SyntaxID;
        }

        pAttribValue = (PBYTE)(pAttribute->AttribName) +
                       ROUNDUP4(pAttribute->AttribNameLength) +
                       sizeof(DWORD);

        if ( pActualSize )
        {
            *pActualSize = *(DWORD *)pAttribValue;
        }

        memcpy( Data, pAttribValue + sizeof(DWORD),
                min(*(DWORD *)pAttribValue, Size) );

    }

    return Status;
}


/********************************************************************

        NDSGetVar

Routine Description:

        Return value of user property

        Get the syntax type of the property
        Retrieve the data
        Do any data conversion

Arguments:
        Name - of NDS property IN
        Value - value buffer OUT
        Size - size of value buffer IN

Return Value:
        none

 *******************************************************************/
void
NDSGetVar ( PBYTE Name, PBYTE Value, unsigned int Size)
{
   unsigned int err;
   SYNTAX Syntax;
   BYTE Buffer[ATTRBUFSIZE];
   DWORD ActualSize;

   Value[0] = 0;

   err = NDSGetUserProperty( Name, Buffer, ATTRBUFSIZE, &Syntax, &ActualSize );

   if ( err )
   {
       return;
   }

   switch ( Syntax )
   {
   case NDSI_BOOLEAN:
       if ( *(PBYTE)Buffer )
       {
           strcpy( Value, "Y" );
       }
       else
       {
           strcpy( Value, "N" );
       }
       break;
   case NDSI_DIST_NAME:
   case NDSI_CE_STRING:
   case NDSI_CI_STRING:
   case NDSI_OCTET_STRING:
   case NDSI_PR_STRING:
   case NDSI_NU_STRING:
   case NDSI_TEL_NUMBER:
   case NDSI_CLASS_NAME:
       ConvertUnicodeToAscii( Buffer );
       if ( Syntax == NDSI_DIST_NAME )
           NDSAbbreviateName(FLAGS_LOCAL_CONTEXT, Buffer, Buffer);
       strncpy( Value, Buffer, Size );
       break;
   case NDSI_CI_LIST:
       ConvertUnicodeToAscii( Buffer+8 );
       strncpy( Value, Buffer+8, Size );
       break;
       break;
   case NDSI_INTEGER:
   case NDSI_COUNTER:
   case NDSI_TIME:
   case NDSI_INTERVAL:
   case NDSI_TIMESTAMP:
       sprintf( Value, "%d", *(int *)Buffer );
       break;
   case NDSI_PO_ADDRESS:
       {
           // 6 null terminated lines
           int line,len;
           PBYTE ptr = Buffer + 4;

           // Stop if not 6 lines
           if ( *(int *)Buffer != 6 )
               break;

           for (line = 0; line <= 5; line++) {
               len = ROUNDUP4(*(int *)ptr);
               ptr += 4;
               if ( !len )
                   break;
               ConvertUnicodeToAscii( ptr );
               strcat( Value, ptr );
               strcat( Value, "\n" );
               ptr += len;
           }
       }
       break;
   case NDSI_FAX_NUMBER:
       if ( *(int *)Buffer == 0 )
           return;
       ConvertUnicodeToAscii( Buffer+4 );
       strncpy( Value, Buffer+4, Size );
       break;
   case NDSI_EMAIL_ADDRESS:
       if ( *(int *)(Buffer+4) == 0 )
           return;
       ConvertUnicodeToAscii( Buffer+8 );
       strncpy( Value, Buffer+8, Size );
       break;
   case NDSI_PATH:
       {
           int len;

           len = *(int *)(Buffer+4);
           if ( len == 0 )
               break;
           len = ROUNDUP4( len );
           ConvertUnicodeToAscii( Buffer+8 );
           strcpy( Value, Buffer+8 );
           NDSAbbreviateName(FLAGS_LOCAL_CONTEXT, Value, Value);
           strcat( Value, ":" );
           if ( *(int *)(Buffer + 8 + len) == 0 )
               break;
           ConvertUnicodeToAscii( Buffer+8+len+4 );
           strcat( Value, Buffer+8+len+4 );
           break;
       }
   case NDSI_NET_ADDRESS:
   case NDSI_OCTET_LIST:
   case NDSI_OBJECT_ACL:
   case NDSI_STREAM:
   case NDSI_UNKNOWN:
   case NDSI_REPLICA_POINTER:
   case NDSI_BACK_LINK:
   case NDSI_TYPED_NAME:
   case NDSI_HOLD:
   case NDSI_TAX_COUNT:
   default:
       Value[0] = '\0';
       Value[1] = '\0';
       break;
   }

}

/********************************************************************

        NDSChangeContext

Routine Description:

        Change the current context

Arguments:
        Context - context string IN

Return Value:
        error number

 *******************************************************************/
unsigned int
NDSChangeContext( PBYTE Context )
{
    NTSTATUS Status;

    OEM_STRING oemStr;
    UNICODE_STRING defaultcontext;
    WCHAR NdsStr[1024];

    oemStr.Length = (USHORT)strlen( Context );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Context;

    defaultcontext.Length = 0;
    defaultcontext.MaximumLength = sizeof(NdsStr);
    defaultcontext.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &defaultcontext, &oemStr, FALSE );

    Status = NwNdsSetTreeContext( GhRdr, &NDSTREE_u, &defaultcontext );

    return Status;
}

/********************************************************************

        NDSGetContext

Routine Description:

        Retrieve the current context

Arguments:
        Buffer - data buffer for context string OUT
        len    - length of data buffer IN

Return Value:
        error number

 *******************************************************************/
unsigned int
NDSGetContext( PBYTE Buffer,
               unsigned int len )
{
    NTSTATUS Status;

    Status = NDSGetNameContext( Buffer, TRUE );
    if ( !NT_SUCCESS( Status ) )
        return Status;
    NDSAbbreviateName(FLAGS_NO_CONTEXT, Buffer, Buffer);
    return 0;
}

/********************************************************************

        NDSfopenStream

Routine Description:

        Open a file handle to an NDS stream property

Arguments:
        Object - name of object IN
        Property - name of property IN
        pStream - pointer to file handle OUT
        pFileSize - pointer to file size OUT

Return Value:
        error

 *******************************************************************/
unsigned int
NDSfopenStream ( PBYTE Object,
                 PBYTE Property,
                 PHANDLE pStream,
                 unsigned int * pFileSize )
{
    //
    // Status variables.
    //

    NTSTATUS Status;
    int ccode = -1;

    //
    // For NwNdsOpenTreeHandle.
    //

    HANDLE hRdr;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    WCHAR NdsStr[1024];

    //
    // For NwNdsResolveName.
    //

    DWORD dwOid;
    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    DWORD dwHandleType;
    HANDLE hReferredServer;

    //
    // Get a handle to the redirector.
    //

    Status = NwNdsOpenTreeHandle( &NDSTREE_u, &hRdr );

    if ( !NT_SUCCESS( Status ) ) {
        DisplayMessage(IDR_TREE_OPEN_FAILED);
        return ccode;
    }

    //
    // Resolve the name that we have to an object id.
    //

    if ( !Object )
    {
        return 1;
    }

    oemStr.Length = (USHORT)strlen( Object );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Object;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( hRdr,
                                &ObjectName,
                                &dwOid,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       return 0xffffffff;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // must jump to that server before continuing.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            return 0xffffffff;
        }

        CloseHandle( hRdr );
        hRdr = hReferredServer;
    }

    //
    // Open the file stream.
    //

    oemStr.Length = (USHORT)strlen( Property );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Property;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    //
    // Try to open a file stream for read access.
    //

    Status = NwNdsOpenStream( hRdr,
                              dwOid,
                              &ObjectName,
                              1,                // Read access.
                              pFileSize );

    if ( !NT_SUCCESS( Status ) ) {
        return 0xffffffff;
    }

    *pStream = hRdr;

    return 0;
}

/*
 * IsMemberOfNDSGroup
 * ------------------
 *
 * Returns true if currently logged in user object is member of group with given name
 *
 */
unsigned int
IsMemberOfNDSGroup(
        PBYTE        nwGroup
        )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT        nwRet;
    BYTE        szCanonTargetGroupName[NDS_NAME_CHARS+1];
    UINT        syntaxid;
    UINT        actualsize;
    PBYTE       szBuffer;
    LPSTR       pProp;
    UINT        i;
    DWORD iterhandle = INITIAL_ITERATION;
    DWORD dwBufferSize = ATTRBUFSIZE;
    UINT        fFoundGroup = FALSE;
    PNDS_RESPONSE_READ_ATTRIBUTE pReadAttribute;
    PNDS_ATTRIBUTE pAttribute;
    PBYTE pAttribValue;
    UNICODE_STRING PropertyName;
    UINT    numvalues = 0;
    BOOL    fContinue = TRUE;

    szBuffer = (PBYTE)malloc(dwBufferSize);

    if ( !szBuffer ) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    memset( szBuffer, 0, dwBufferSize );

    // Canonicalize name according to current context

    strcpy( szCanonTargetGroupName, nwGroup );

    nwRet = NDSCanonicalizeName( szCanonTargetGroupName,
                                 szCanonTargetGroupName,
                                 NDS_NAME_CHARS,
                                 TRUE );
    if (nwRet) {

        if ( nwGroup[0] != '.' ) {

            // Try an absolute name

            strcpy( szCanonTargetGroupName, "." );
            strcat( szCanonTargetGroupName, nwGroup );

            nwRet = NDSCanonicalizeName( szCanonTargetGroupName,
                                         szCanonTargetGroupName,
                                         NDS_NAME_CHARS,
                                         TRUE );
        }

        if ( nwRet )
            goto CleanRet;
    }

    // Should check class name of object

    RtlInitUnicodeString( &PropertyName, L"Group Membership" );

    while ( fContinue )
    {
        Status = NwNdsReadAttribute ( GhRdrForUser,
                                      GUserObjectID,
                                      &iterhandle,
                                      &PropertyName,
                                      szBuffer,
                                      dwBufferSize );

        if ( NT_SUCCESS(Status) && iterhandle != INITIAL_ITERATION )
        {
            dwBufferSize *= 2;

            free( szBuffer );

            szBuffer = (PBYTE)malloc(dwBufferSize);

            if ( !szBuffer ) {
                DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            memset( szBuffer, 0, dwBufferSize );
            iterhandle = INITIAL_ITERATION;
        }
        else
        {
            fContinue = FALSE;
        }
    }

    if ( !NT_SUCCESS(Status) )
    {
        goto CleanRet;
    }

    pReadAttribute = (PNDS_RESPONSE_READ_ATTRIBUTE)szBuffer;

    pAttribute = (PNDS_ATTRIBUTE)(szBuffer
                  + sizeof(NDS_RESPONSE_READ_ATTRIBUTE));
    pAttribute->SyntaxID;

    pAttribValue = (PBYTE)(pAttribute->AttribName) +
                   ROUNDUP4(pAttribute->AttribNameLength) +
                   sizeof(DWORD);

    numvalues = *(PUINT)((PBYTE)(pAttribute->AttribName) +
                         ROUNDUP4(pAttribute->AttribNameLength));

    if ( *(DWORD *)pAttribValue == 0 )
    {
        goto CleanRet;
    }

    for ( i = 0; i < numvalues; i++ ) {
        ConvertUnicodeToAscii( pAttribValue+sizeof(DWORD) );
        if (!_stricmp(pAttribValue+sizeof(DWORD),szCanonTargetGroupName)) {
            fFoundGroup = TRUE;
            break;
        }
        pAttribValue += ROUNDUP4(*(PUINT)pAttribValue) + sizeof(DWORD);
    }



CleanRet:
    if (szBuffer ) {
        free (szBuffer);
    }
    return fFoundGroup;
}

/********************************************************************

        NDSGetProperty

Routine Description:

        Return the NDS property for the object

Arguments:
        Object   - name of object IN
        Property - property name  IN
        Data     - data buffer    OUT
        Size     - size of data buffer IN
        pActualSize - real data size OUT

Return Value:
        error

 *******************************************************************/
unsigned int
NDSGetProperty ( PBYTE Object,
                 PBYTE Property,
                 PBYTE Data,
                 unsigned int Size,
                 unsigned int * pActualSize )
{
    //
    // Status variables.
    //

    NTSTATUS Status = STATUS_SUCCESS;
    int ccode = -1;

    //
    // For NwNdsOpenTreeHandle.
    //

    HANDLE hRdr;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    WCHAR NdsStr[1024];

    //
    // For NwNdsResolveName.
    //

    DWORD dwOid;
    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    DWORD dwHandleType;
    HANDLE hReferredServer;

    //
    // For NwNdsReadAttribute
    //
    PBYTE szBuffer;
    DWORD dwBufferSize = 2048;
    DWORD iterhandle = INITIAL_ITERATION;
    PNDS_RESPONSE_READ_ATTRIBUTE pReadAttribute;
    PNDS_ATTRIBUTE pAttribute;
    PBYTE pAttribValue;
    BOOL fContinue = TRUE;

    //
    // Allocate a buffer for the NDS request.
    //

    szBuffer = (PBYTE)malloc(dwBufferSize);

    if ( !szBuffer ) {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        Status = STATUS_NO_MEMORY;
        return Status;
    }
    memset( szBuffer, 0, dwBufferSize );

    //
    // Get a handle to the redirector.
    //

    Status = NwNdsOpenTreeHandle( &NDSTREE_u, &hRdr );

    if ( !NT_SUCCESS( Status ) ) {
        DisplayMessage(IDR_TREE_OPEN_FAILED);
        return ccode;
    }

    //
    // Resolve the name that we have to an object id.
    //

    if ( !Object )
    {
        return 1;
    }

    oemStr.Length = (USHORT)strlen( Object );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Object;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( hRdr,
                                &ObjectName,
                                &dwOid,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       return 0xffffffff;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // must jump to that server before continuing.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            return 0xffffffff;
        }

        CloseHandle( hRdr );
        hRdr = hReferredServer;
    }

    //
    // Get the attribute
    //

    oemStr.Length = (USHORT)strlen( Property );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = Property;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(NdsStr);
    ObjectName.Buffer = NdsStr;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );



    while ( fContinue )
    {
        Status = NwNdsReadAttribute ( hRdr,
                                      dwOid,
                                      &iterhandle,
                                      &ObjectName,
                                      szBuffer,
                                      dwBufferSize );

        if ( NT_SUCCESS(Status) && iterhandle != INITIAL_ITERATION )
        {
            dwBufferSize *= 2;

            free( szBuffer );

            szBuffer = (PBYTE)malloc(dwBufferSize);

            if ( !szBuffer ) {
                DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
                Status = STATUS_NO_MEMORY;
                return Status;
            }
            memset( szBuffer, 0, dwBufferSize );
            iterhandle = INITIAL_ITERATION;
        }
        else
        {
            fContinue = FALSE;
        }
    }

    if ( !NT_SUCCESS(Status) )
    {
        NtClose( hRdr );
        free( szBuffer );

        return Status;
    }

    if ( NT_SUCCESS(Status) )
    {
        int i;
        pReadAttribute = (PNDS_RESPONSE_READ_ATTRIBUTE)szBuffer;
        pAttribute = (PNDS_ATTRIBUTE)(szBuffer
                      + sizeof(NDS_RESPONSE_READ_ATTRIBUTE));

        pAttribValue = (PBYTE)(pAttribute->AttribName) +
                       ROUNDUP4(pAttribute->AttribNameLength) +
                       sizeof(DWORD);

        if ( pActualSize )
        {
            *pActualSize = *(DWORD *)pAttribValue;
        }

        memcpy( Data, pAttribValue + sizeof(DWORD),
                min(*(DWORD *)pAttribValue, Size) );

    }

    NtClose( hRdr );

    return Status;
}


/********************************************************************

        NDSCleanup

Routine Description:

        Does any NDS cleanup

Arguments:
        none

Return Value:
        none

 *******************************************************************/
void
NDSCleanup ( void )
{
    NtClose( GhRdr );
    if( GhRdr != GhRdrForUser ) {
        NtClose( GhRdrForUser );
    }
}

/********************************************************************

        NDSGetClassName

Routine Description:

        return a class name for an object

Arguments:
        szObjectName
        ClassName

Return Value:
        none

 *******************************************************************/
unsigned int
NDSGetClassName( LPSTR szObjectName, LPSTR ClassName )
{
    NTSTATUS Status;
    int ccode = -1;
    DWORD ThisObjectID;
    OEM_STRING oemStr;
    UNICODE_STRING ObjectName;
    BYTE Buffer[2048];
    BYTE FullName[NDS_NAME_CHARS];
    PBYTE ptr;
    UNICODE_STRING ReferredServer;
    WCHAR ServerStr[MAX_NAME_LEN];
    DWORD dwHandleType;
    HANDLE hReferredServer;
    DWORD Length;

    //
    // Resolve the name that we have to an object id.
    //

    oemStr.Length = (USHORT)strlen( szObjectName );
    oemStr.MaximumLength = oemStr.Length;
    oemStr.Buffer = szObjectName;

    ObjectName.Length = 0;
    ObjectName.MaximumLength = sizeof(Buffer);
    ObjectName.Buffer = (WCHAR *)Buffer;

    RtlOemStringToUnicodeString( &ObjectName, &oemStr, FALSE );

    ReferredServer.Buffer = ServerStr;
    ReferredServer.Length = 0;
    ReferredServer.MaximumLength = sizeof( ServerStr );

    Status = NwNdsResolveName ( GhRdr,
                                &ObjectName,
                                &ThisObjectID,
                                &ReferredServer,
                                NULL,
                                0 );

    if ( !NT_SUCCESS( Status ) ) {
       return Status;
    }

    if ( ReferredServer.Length > 0 ) {

        //
        // We've been referred to another server, so we
        // should change the global handle.
        //

        Status = NwNdsOpenGenericHandle( &ReferredServer,
                                         &dwHandleType,
                                         &hReferredServer );

        if ( !NT_SUCCESS( Status ) ) {
            return Status;
        }

        if( GhRdr != GhRdrForUser ) {
            CloseHandle( GhRdr );
        }
        GhRdr = hReferredServer;
    }

    Status = NwNdsReadObjectInfo( GhRdr, ThisObjectID, Buffer, 2048 );
    if ( !NT_SUCCESS( Status ) ) {
        return Status;
    }

    ptr = Buffer + sizeof( NDS_RESPONSE_GET_OBJECT_INFO ) + sizeof( DWORD );

    RtlInitUnicodeString( &ObjectName, (PWCHAR)ptr );

    oemStr.Length = 0;
    oemStr.MaximumLength = NDS_NAME_CHARS;
    oemStr.Buffer = ClassName;

    RtlUnicodeStringToOemString( &oemStr, &ObjectName, FALSE );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\ntscript.c ===
/*************************************************************************
*
*  NTSCRIPT.C
*
*  Process all login scripts
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NTSCRIPT.C  $
*  
*     Rev 1.8   10 Apr 1996 14:23:12   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.9   12 Mar 1996 19:54:58   terryt
*  Relative NDS names and merge
*  
*     Rev 1.8   07 Mar 1996 18:36:56   terryt
*  Misc fixes
*  
*     Rev 1.7   22 Jan 1996 16:48:26   terryt
*  Add automatic attach query during map
*  
*     Rev 1.6   08 Jan 1996 13:57:58   terryt
*  Correct NDS Preferred Server
*  
*     Rev 1.5   05 Jan 1996 17:18:26   terryt
*  Ensure context is the correct login default
*  
*     Rev 1.4   04 Jan 1996 18:56:48   terryt
*  Bug fixes reported by MS
*  
*     Rev 1.3   22 Dec 1995 11:08:16   terryt
*  Fixes
*  
*     Rev 1.2   22 Nov 1995 15:43:52   terryt
*  Use proper NetWare user name call
*  
*     Rev 1.1   20 Nov 1995 15:09:38   terryt
*  Context and capture changes
*  
*     Rev 1.0   15 Nov 1995 18:07:28   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 16:23:14   terryt
*  Capture support
*  
*     Rev 1.1   26 Jul 1995 16:02:00   terryt
*  Allow deletion of current drive
*  
*     Rev 1.0   15 May 1995 19:10:46   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <direct.h>
#include <process.h>
#include <string.h>
#include <malloc.h>

#include "common.h"

#include "inc/ntnw.h"

#include <nwapi.h>

void ProcessLoginScripts(unsigned int conn, char * UserName, int argc, char **argv, char *lpScript);

extern int SafeDisk;

extern unsigned int ConvertNDSPathToNetWarePath(char *, char *, char *);

/*************************************************************************
*
*  NTNetWareLoginScripts
*     Main logon script processor
*
*  ENTRY:
*
*  EXIT
*
*************************************************************************/

int
NTNetWareLoginScripts( int argc, char ** argv )
{
    unsigned int  defConn;
    char          UserName[MAX_NAME_LEN]="";
    WCHAR         UserName_w[MAX_NAME_LEN * sizeof(WCHAR)]=L"";
    char          MessageServer[NDS_NAME_CHARS]="";
    char         *lpScript = NULL;
    DWORD         PrintOptions;
    LPTSTR        pszPreferredSrv;
    LPTSTR        ptreeW;
    LPTSTR        pcontextW;
    NTSTATUS      ntstatus;
    char *        lpC1;
    char *        lpC2;
    unsigned int  NewConn;
    unsigned int  Result;

    if ( NwQueryInfo( &PrintOptions, &pszPreferredSrv ) || !pszPreferredSrv )
    {
        DisplayMessage(IDR_QUERY_INFO_FAILED);
        return( FALSE );
    }

    //
    // nwscript /S filename
    //
    // can be used to pass a local script file for testing
    //
    if ( ( argc >= 3 ) && !_strcmpi(argv[1], "/S") )
    {
        lpScript = argv[2];
        argc -= 2;
        argv += 2;
    }

    //
    // NDS preferred server format is:
    // *<tree name>\<context>
    
    fNDS = ( *pszPreferredSrv == L'*' );

    if ( fNDS )
    {

        // Get the NDS tree name

        ptreeW = pszPreferredSrv + 1;

        pcontextW = wcschr( pszPreferredSrv, L'\\' );

        if ( pcontextW )
        {
           *pcontextW++ = L'\0';
        }

        NDSTREE = malloc ( CONTEXT_MAX );
        if (NDSTREE == NULL) {
            goto ExitWithError;
        }

        NDSTREE_w = malloc ( CONTEXT_MAX * sizeof(WCHAR) );
        if (NDSTREE_w == NULL) {
            goto ExitWithError;
        }

        if ( ptreeW )
        {
            wcscpy( NDSTREE_w, ptreeW );
            RtlInitUnicodeString( &NDSTREE_u, NDSTREE_w );
            WideTosz( NDSTREE, ptreeW, CONTEXT_MAX );
            _strupr( NDSTREE );
        }
        else
        {
            strcpy( NDSTREE, "" ); 
            wcscpy( NDSTREE_w, L"" ); 
        }

        // Get the fully typed user name

        TYPED_USER_NAME_w = malloc ( sizeof(WCHAR) * NDS_NAME_CHARS );
        if (TYPED_USER_NAME_w == NULL) {
            goto ExitWithError;
        }
        TYPED_USER_NAME = malloc ( NDS_NAME_CHARS );
        if (TYPED_USER_NAME == NULL) {
            goto ExitWithError;
        }

        ntstatus = NTGetNWUserName( NDSTREE_w, TYPED_USER_NAME_w,
                                    sizeof(WCHAR) * NDS_NAME_CHARS  );
        if ( !NT_SUCCESS( ntstatus ) ) {
            DisplayMessage(IDR_QUERY_INFO_FAILED);
            return ( FALSE );
        }

        WideTosz( TYPED_USER_NAME, TYPED_USER_NAME_w, NDS_NAME_CHARS );

        // Get the user name stripped of context and type

        lpC1 = strchr( TYPED_USER_NAME, '=' );
        if ( lpC1 )
            lpC1++;
        else 
            lpC1 = TYPED_USER_NAME;

        lpC2 = strchr( TYPED_USER_NAME, '.' );

        while ( lpC2 ) // Handle usernames with embedded/escaped dots ("\.")
        {
            if (*(lpC2-1) == '\\')
                lpC2 = strchr(lpC2+1, '.');
            else
                break;
        }

        if ( lpC2 )
            strncpy( UserName, lpC1, (UINT)(lpC2 - lpC1) );
        else
            strcpy( UserName, lpC1 );

        // Get the default context
        // This should be where the user is

        REQUESTER_CONTEXT = malloc( CONTEXT_MAX );
        if (REQUESTER_CONTEXT == NULL) {
            goto ExitWithError;
        }

        if ( lpC2 ) 
        {
            strcpy( REQUESTER_CONTEXT, lpC2+1 ); 
        }
        else 
        {
            strcpy( REQUESTER_CONTEXT, "" ); 
        }
        NDSTypeless( REQUESTER_CONTEXT, REQUESTER_CONTEXT );

        //
        //  This finishes the NDS initialization
        //
        if ( NDSInitUserProperty () )
            return ( FALSE );

    }
    else
    {
        ntstatus = NTGetNWUserName( pszPreferredSrv, UserName_w,
                                    MAX_NAME_LEN * sizeof(WCHAR) );
        if ( !NT_SUCCESS( ntstatus ) ) {
            DisplayMessage(IDR_QUERY_INFO_FAILED);
            return ( FALSE );
        }
        WideTosz( UserName, UserName_w, MAX_NAME_LEN );
        _strupr( UserName );
    }

    //
    // If we map over a drive, the SafeDisk is used.
    //
    SafeDisk = _getdrive();

    NTInitProvider();

    //
    // Get the default connection handle.
    //
    // This is used to get the preferred server!

    if ( !CGetDefaultConnectionID (&defConn) )
        return( FALSE );

    PREFERRED_SERVER = malloc( NDS_NAME_CHARS );
    if (PREFERRED_SERVER == NULL) {
        goto ExitWithError;
    }

    GetFileServerName(defConn, PREFERRED_SERVER);

    //
    // By default we are "attached" to the default server
    //
    if ( fNDS )
        AddServerToAttachList( PREFERRED_SERVER, LIST_4X_SERVER );
    else
        AddServerToAttachList( PREFERRED_SERVER, LIST_3X_SERVER );

    //
    // Print out status
    //
    if ( fNDS ) 
    {
        DisplayMessage( IDR_CURRENT_CONTEXT, REQUESTER_CONTEXT );
        DisplayMessage( IDR_CURRENT_TREE, NDSTREE_w );
    }

    DisplayMessage( IDR_CURRENT_SERVER, PREFERRED_SERVER );

    //
    // We may want to change the Preferred Server based on the DS.
    // "MESSAGE_SERVER" should be the Preferred Server (if possible).
    //
    if ( fNDS )
    {
        NDSGetVar ( "MESSAGE_SERVER", MessageServer, NDS_NAME_CHARS );
        if ( strlen( MessageServer ) ) 
        {
            NDSAbbreviateName(FLAGS_NO_CONTEXT, MessageServer, MessageServer);
            lpC1 = strchr( MessageServer, '.' );
            if ( lpC1 )
                *lpC1 = '\0';
            if ( strcmp( MessageServer, PREFERRED_SERVER) )
            {
                DisplayMessage( IDR_AUTHENTICATING_SERVER, MessageServer );
                Result = NTAttachToFileServer( MessageServer, &NewConn );
                if ( Result )
                {
                    DisplayMessage( IDR_SERVER_NOT_FOUND, MessageServer );
                }
                else
                {
                    NWDetachFromFileServer( (NWCONN_HANDLE)NewConn );
                    strncpy( PREFERRED_SERVER, MessageServer, NDS_NAME_CHARS);
                    DisplayMessage( IDR_CURRENT_SERVER, PREFERRED_SERVER );

                    // By default we are "attached" to the preferred server

                    AddServerToAttachList( PREFERRED_SERVER, LIST_4X_SERVER );
                }
            }
        }
    }

    //
    // Just like login we ignore any errors from setting the login
    // directory.
    //
    SetLoginDirectory (PREFERRED_SERVER);

    // Process login scripts.

    ProcessLoginScripts(defConn, UserName, argc, argv, lpScript);

    return( TRUE );

ExitWithError:
    if (NDSTREE) {
        free(NDSTREE);
        NDSTREE = NULL;
    }
    if (NDSTREE_w) {
        free(NDSTREE_w);
        NDSTREE_w = NULL;
    }
    if (TYPED_USER_NAME) {
        free(TYPED_USER_NAME);
        TYPED_USER_NAME = NULL;
    }
    if (TYPED_USER_NAME_w) {
        free(TYPED_USER_NAME_w);
        TYPED_USER_NAME_w = NULL;
    }
    if (REQUESTER_CONTEXT) {
        free(REQUESTER_CONTEXT);
        REQUESTER_CONTEXT = NULL;
    }
    if (PREFERRED_SERVER) {
        free(PREFERRED_SERVER);
        PREFERRED_SERVER = NULL;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\nwapi1.c ===
/*************************************************************************
*
*  NWAPI1.C
*
*  NetWare routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NWAPI1.C  $
*  
*     Rev 1.1   22 Dec 1995 14:25:48   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:32   terryt
*  Initial revision.
*  
*     Rev 1.0   15 May 1995 19:10:48   terryt
*  Initial revision.
*  
*************************************************************************/
#include "common.h"

/*
    Get default connection handle.
    return TRUE if succeeded, FALSE otherwise.
 */
int CGetDefaultConnectionID ( unsigned int * pConn )
{
    unsigned int iRet = GetDefaultConnectionID(pConn);

    switch (iRet)
    {
    case 0:
        break;

    case 0x880f:
        DisplayMessage(IDR_NO_KNOWN_FILE_SERVER);
        break;
    default:
        DisplayMessage(IDR_NO_DEFAULT_CONNECTION);
        break;
    }

    return(iRet == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\nwapi2.c ===
/*************************************************************************
*
*  NWAPI2.C
*
*  NetWare routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NWAPI2.C  $
*  
*     Rev 1.1   22 Dec 1995 14:25:54   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:07:34   terryt
*  Initial revision.
*  
*     Rev 1.0   15 May 1995 19:10:50   terryt
*  Initial revision.
*  
*************************************************************************/

#include <direct.h>
#include "common.h"

/*
    Set the current drive to the login directory
    of the default server.
 */
void SetLoginDirectory( PBYTE serverName )
{
    unsigned int        iRet = 0;
    WORD           firstDrive;

    if(iRet = GetFirstDrive (&firstDrive))
    {
        DisplayError(iRet,"GetFirstDrive");
        return;
    }

    // Nothing we can do if SetDriveBase failed.
    // Don't report the error.

    if ( !( SetDriveBase (firstDrive, serverName, 0, "SYS:LOGIN") ) )
    {
        _chdrive (firstDrive);
        ExportCurrentDrive( firstDrive );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\nwapi3.c ===
/*************************************************************************
*
*  NWAPI3.C
*
*  NetWare routines ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NWAPI3.C  $
*  
*     Rev 1.4   18 Apr 1996 16:52:14   terryt
*  Various enhancements
*  
*     Rev 1.3   10 Apr 1996 14:23:20   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.5   13 Mar 1996 18:49:28   terryt
*  Support directory maps
*  
*     Rev 1.4   12 Mar 1996 19:55:10   terryt
*  Relative NDS names and merge
*  
*     Rev 1.2   22 Dec 1995 14:26:02   terryt
*  Add Microsoft headers
*  
*     Rev 1.1   22 Nov 1995 15:41:56   terryt
*  Fix MAP ROOT of search drives
*  
*     Rev 1.0   15 Nov 1995 18:07:38   terryt
*  Initial revision.
*  
*     Rev 1.3   25 Aug 1995 16:23:22   terryt
*  Capture support
*  
*     Rev 1.2   26 Jul 1995 16:02:08   terryt
*  Allow deletion of current drive
*  
*     Rev 1.1   23 Jun 1995 09:49:22   terryt
*  Add error message for mapping over MS network drive
*  
*     Rev 1.0   15 May 1995 19:10:54   terryt
*  Initial revision.
*  
*************************************************************************/

/*
Module Name:
        nwapi3.c

Abstract:
        can :
                - view current mapping
                - create/change a drive mapping
                - create/change a search drive mapping
                - map a drive to a fake root
                - map the next available drive

    SYNTAX (Command line)
        View current mapping.
                MAP [drive:]
        Create or change network drive mappings
                MAP path
                MAP drive:=[drive:|path]
                MAP [DEL[ete] | REM[ove]] drive:
        Create or change search dirve mappings
                MAP [INS[ert]] drive:=[drive:|path]
        Map a drive to a fake root directory
                MAP ROOT drive:=[drive:|path]
        Map the next available dirve
                MAP N[ext] [drive:|path]



Author : Thierry TABARD (thierryt)

Revision history :
        - 03/10/94      thierryt    started
        - 05/13/94      congpay     rewrote.
*/

#include <ctype.h>
#include <direct.h>
#include "common.h"

/* Local functions*/
int  IsDrive( char * input);
int  GetSearchNumber( char * input);
int  IsNetwareDrive (int driveNum);
int  IsLocalDrive (int driveNum);
int  IsNonNetwareNetworkDrive (int driveNum);
int  GetDriveFromSearchNumber (int searchNumber);

void DisplayDriveMapping(WORD drive);
void DisplaySearchDriveMapping(int searchNumber);

int  ParseMapPath(char * mapPath, char * volName, char * dirPath, char * serverName, int fMapErrorsOn, char *lpCommand);
int  MapDrive (int driveNum, int searchNum, char * mapPath, int bRoot, int bInsert, int fMapErrorsOn, char *lpCommand);
int  MapNonSearchDrive (int driveNum, char *mapPath, int bRoot, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand);
int  MapSearchDrive (int searchNum, int driveNum, char *mapPath, int bInsert, int bRoot, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand);
int  MapNextAvailableDrive (char *mapPath, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand);

void RemoveDriveFromPath(int searchNumber, int fMapErrorsOn);
int  RemoveDrive (WORD drive, int fMapDisplayOn, int fMapErrorsOn);
void RemoveSearchDrive (int searchNumber, int fMapDisplayOn, int fMapErrorsOn);
int  InsertSearchDrive(int searchNum, int driveNum, int bInsert, char * insertPath);

#define CM_MAP         0
#define CM_DEL         1
#define CM_NEXT        2
#define CM_HELP        3
#define MAX_INPUT_PATH_LEN 128

int fMapDisplayOn = TRUE;
int fMapErrorsOn = TRUE;
int SafeDisk = 2; 

int GetFlag (char *buffer, int *pfInsert, int *pfRoot, char **ppPath)
{
    int nFlag, nLen;
    char *lpSpace, *lpTemp;

    if (((*buffer == '/') || (*buffer == '-') || (*buffer == '\\')) &&
             (*(buffer+1) == '?'))
        return CM_HELP;

    lpSpace = strchr (buffer, ' ');

    nFlag = CM_MAP;   // A bug!

    if (lpSpace == NULL)
    {
        *ppPath = buffer;
        return CM_MAP;
    }

    nLen = (int)(lpSpace - buffer);
    lpSpace++;

    if (!strncmp(buffer, __DEL__, max (3, nLen)) ||
        !strncmp(buffer, __REM__, max (3, nLen)))
        nFlag = CM_DEL;
    else if (!strncmp(buffer, __NEXT__, nLen))
        nFlag = CM_NEXT;
    else if (!strncmp(buffer, __INS__, max (3, nLen)))
    {
        *pfInsert = TRUE;
        if (lpTemp = strchr (lpSpace, ' '))
        {
            nLen = (int)(lpTemp - lpSpace);
            if (!strncmp(lpSpace, __ROOT__, nLen))
            {
                *pfRoot = TRUE;
                lpSpace = lpTemp+1;
            }
        }
    }
    else if (!strncmp(buffer, __ROOT__, nLen))
    {
        *pfRoot = TRUE;
        if (lpTemp = strchr (lpSpace, ' '))
        {
            nLen = (int)(lpTemp - lpSpace);
            if (!strncmp(lpSpace, __INS__, max (3, nLen)))
            {
                *pfInsert = TRUE;
                lpSpace = lpTemp+1;
            }
        }
    }
    else
        lpSpace = buffer;

    *ppPath = lpSpace;

    return(nFlag);
}

int Map (char * buffer)
{
    WORD  status, driveNum;
    char *lpCommand, *inputPath, *lpEqual;
    int   fRoot, fInsert, fSpace, fCommandHandled;
    int   nFlag, searchNumber, iRet;

    // Fix for NWCS.
    // NWGetDriveStatus() always returns 1800 on first call for non-Network
    // drives on NWCS. So we call with c: first to pass the first call.
    GetDriveStatus (3,
                    NETWARE_FORMAT_SERVER_VOLUME,
                    &status,
                    NULL,
                    NULL,
                    NULL,
                    NULL);

    lpCommand =  strtok (buffer, ";");

    if (lpCommand == NULL)
    {
        DisplayMapping();
        return(0);
    }

    do
    {
        fRoot = FALSE;
        fInsert = FALSE;
        fSpace = FALSE;
        fCommandHandled = TRUE;

        // Make sure first and last char of the command are not spaces.
        if (*lpCommand == ' ')
            lpCommand++;

        if (*(lpCommand+strlen (lpCommand)-1) == ' ')
            *(lpCommand+strlen (lpCommand)-1) = 0;

        if (!strcmp (lpCommand, "DISPLAY ON"))
        {
            fMapDisplayOn = TRUE;
            continue;
        }
        else if (!strcmp (lpCommand, "DISPLAY OFF"))
        {
            fMapDisplayOn = FALSE;
            continue;
        }
        else if (!strcmp (lpCommand, "ERROR ON") || !strcmp (lpCommand, "ERRORS ON"))
        {
            fMapErrorsOn = TRUE;
            continue;
        }
        else if (!strcmp (lpCommand, "ERROR OFF") || !strcmp (lpCommand, "ERRORS OFF"))
        {
            fMapErrorsOn = FALSE;
            continue;
        }

        nFlag = GetFlag (lpCommand, &fInsert, &fRoot, &inputPath);

        /*
         *  The 4X login program is much more forgiving about spaces
         *  in the map command.  
         */
        {
            char *lpTemp;
            char *lpCur;
            int  inquote = FALSE;

            lpTemp = inputPath;
            lpCur = inputPath;

            /*
             * Compress blanks unless the string is quoted
             */
            while ( *lpTemp )
            {
                if ( *lpTemp == '\"' )
                {
                    if ( inquote )
                        inquote = FALSE;
                    else
                        inquote = TRUE;
                }
                else if ( !inquote &&
                         (( *lpTemp == ' ' ) ||
                          ( *lpTemp == '\t' )  ) )
                {
                }
                else
                {
                   *lpCur++ = *lpTemp;
                   
                   if (IsDBCSLeadByte(*lpTemp)) {
                       *lpCur++ = *(lpTemp+1);
                    }

                }
                lpTemp = NWAnsiNext(lpTemp);
            }
            *lpCur = '\0';
        }


        if (nFlag == CM_HELP && fMapErrorsOn)
            DisplayMessage(IDR_MAP_USAGE);
        else if (nFlag == CM_NEXT)
        {
            if (strchr (inputPath, '=') ||
                strchr (inputPath, ' ') ||
                strchr (inputPath, '\t'))
                fCommandHandled = FALSE;
            else
                iRet = MapNextAvailableDrive (inputPath, fMapDisplayOn, fMapErrorsOn, lpCommand);
        }
        else if (nFlag == CM_DEL)
        {
            if (driveNum = (WORD) IsDrive (inputPath))
                iRet = RemoveDrive (driveNum, fMapDisplayOn, fMapErrorsOn);
            else if (searchNumber = GetSearchNumber(inputPath))
                RemoveSearchDrive (searchNumber, fMapDisplayOn, fMapErrorsOn);
            else
                fCommandHandled = FALSE;
        }
        else //nFlag = CM_MAP
        {
            if (driveNum = (WORD) IsDrive (inputPath))
            {
                if (fInsert)
                    fCommandHandled = FALSE;
                else if (fRoot)
                    iRet = MapNonSearchDrive (0, inputPath, TRUE, fMapDisplayOn, fMapErrorsOn, lpCommand);
                else
                    DisplayDriveMapping(driveNum);
            }
            else if (searchNumber = GetSearchNumber (inputPath))
            {
                if (fInsert || fRoot)
                    fCommandHandled = FALSE;
                else
                    DisplaySearchDriveMapping(searchNumber);
            }
            else if ((lpEqual = strchr (inputPath, '=')) == NULL)
            {
                if (fInsert || strchr (inputPath, ' '))
                    fCommandHandled = FALSE;
                else
                {
                    /*
                     * We must cope with MAP K:DIR which means change the
                     * directory on K:
                     */
                    driveNum = 0;
                    if (isalpha(inputPath[0]) && (inputPath[1] == ':'))
                    {
                        driveNum = toupper(inputPath[0]) - 'A' + 1;
                        if ( !IsNetwareDrive(driveNum) )
                        {
                            driveNum = 0;
                        }
                    }
                    iRet = MapNonSearchDrive (driveNum, inputPath, fRoot, fMapDisplayOn, fMapErrorsOn, lpCommand);
                }
            }
            else
            {
                if ( ( !fNDS && strchr (lpEqual+2, ' ') )
                     || lpEqual == inputPath) {
                    fCommandHandled = FALSE;
                }
                else
                {
                    if (*AnsiPrev(inputPath, lpEqual) == ' ')
                    {
                        fSpace = TRUE;
                        *(lpEqual-1) = 0;
                    }
                    else
                        *lpEqual = 0;

                    if (*(lpEqual+1) == ' ')
                        lpEqual++;

                    driveNum = (WORD) IsDrive (inputPath);
                    searchNumber = GetSearchNumber (inputPath);
                    *(inputPath+strlen(inputPath)) = fSpace? ' ' : '=';

                    /*
                     * This is to handle the cases:
                     *
                     * map x:=s3:=sys:public
                     * map s3:=x:=sys:public
                     *
                     * Unfortuneatly the underlying parsing routines
                     * want everything null terminated, so we need
                     * to do the following shuffle.
                     *
                     */
                    if ( driveNum || searchNumber )
                    {
                        if ((strchr (lpEqual+1, '=')) != NULL)
                        {
                            char * lpEqual2;
                            char *tmpPath = _strdup( lpEqual+1 );

                            lpEqual2 = strchr (tmpPath, '=');

                            if (*AnsiPrev(tmpPath, lpEqual2) == ' ')
                            {
                                fSpace = TRUE;
                                *(lpEqual2-1) = 0;
                            }
                            else
                                *lpEqual2 = 0;

                            if (*(lpEqual2+1) == ' ')
                                lpEqual2++;

                            if ( searchNumber ) 
                            {
                                driveNum = (WORD) IsDrive (tmpPath);
                            }
                            else 
                            {
                                searchNumber = GetSearchNumber (tmpPath);
                            }

                            if ( driveNum && searchNumber ) 
                            {
                                lpEqual += (lpEqual2 - tmpPath) + 1;
                            }

                            free (tmpPath);

                        }
                    }

                    if (searchNumber)
                    {
                        iRet = MapSearchDrive (searchNumber, driveNum, lpEqual+1, fInsert, fRoot, fMapDisplayOn, fMapErrorsOn, lpCommand);
                    }
                    else if (driveNum)
                    {
                        if (fInsert)
                            fCommandHandled = FALSE;
                        else
                            iRet = MapNonSearchDrive (driveNum, lpEqual+1, fRoot, fMapDisplayOn, fMapErrorsOn, lpCommand);
                    }
                    else
                        fCommandHandled = FALSE;
                }
            }
        }

        if (!fCommandHandled && fMapErrorsOn)
        {
            DisplayMessage(IDR_MAP_INVALID_PATH, lpCommand);
        }
    }while ((lpCommand = strtok (NULL, ";")) != NULL);

    return(iRet & 0xFF);
}

/*  Return drive number if input is a drive specified as a letter followed
    by ':' for example if input is "A:", return 1
    or netware drive could be specified as *1: for example.
    Otherwise, return 0.
 */
int IsDrive( char * input)
{
    unsigned short driveNum = 0, n = 0;

    if (isalpha(input[0]) && (input[1] == ':') && (input[2] == 0))
        driveNum = toupper(input[0]) - 'A' + 1;
    else if (input[0] == '*' && isdigit (input[1]) && input[1] != '0')
    {
        if (isdigit (input[2]) && input[3] == ':' && input[4] == 0)
            n = (input[1]-'0')*10+(input[2]-'0');
        else if (input[2] == ':' && input[3] == 0)
            n = input[1]-'0';

        if (n)
        {
            GetFirstDrive (&driveNum);
            driveNum += (n-1);
            if (driveNum < 1 || driveNum > 26)
                driveNum = 0;
        }
    }

    return driveNum;
}

/*
    If the input is "Sn:", return n, where n > 0 && n <= 16.
    Otherwise return 0.
 */
int  GetSearchNumber( char * input)
{
    int searchNumber = 0;
    char *lpTemp;

    if (input[0] != 'S')
        return(0);

    lpTemp = input+1;
    while (*lpTemp && isalpha(*lpTemp))
        lpTemp++;

    if (strncmp (input, "SEARCH", (UINT)(lpTemp-input)))
        return(0);

    if ((lpTemp[0] > '0') &&
        (lpTemp[0] <= '9'))
    {
        if ((lpTemp[1] == ':') &&
            (lpTemp[2] == 0))
        {
            searchNumber = lpTemp[0] - '0';
        }
        else if ((lpTemp[0] == '1') &&
                 (lpTemp[1] >= '0') &&
                 (lpTemp[1] <= '6') &&
                 (lpTemp[2] == ':') &&
                 (lpTemp[3] == 0))
        {
            searchNumber = 10 + lpTemp[1] - '0';
        }
    }

    return(searchNumber);
}

/*
    Return TRUE if the drive is a NetWare drive.
    FALSE otherwise.
 */
int  IsNetwareDrive (int driveNum)
{
    unsigned int    iRet=0;
    WORD       status;

    if (iRet = GetDriveStatus ((unsigned short)driveNum,
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               NULL,
                               NULL,
                               NULL))
    {
        return FALSE;
    }

    return (status & NETWARE_NETWARE_DRIVE);
}

/*
    Return TRUE if the drive is a local drive.
    FALSE otherwise.
 */
int  IsLocalDrive (int driveNum)
{
    unsigned int    iRet=0;
    WORD       status;

    if (iRet = GetDriveStatus ((unsigned short)driveNum,
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               NULL,
                               NULL,
                               NULL))
    {
        return FALSE;
    }

    return ((status & NETWARE_LOCAL_DRIVE) && !(status & NETWARE_NETWORK_DRIVE));
}

/*
    Return TRUE if the drive is a network drive that is not netware
    FALSE otherwise.
 */
int  IsNonNetwareNetworkDrive (int driveNum)
{
    unsigned int    iRet=0;
    WORD       status;

    if (iRet = GetDriveStatus ((unsigned short)driveNum,
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               NULL,
                               NULL,
                               NULL))
    {
        return FALSE;
    }

    return ((status & NETWARE_NETWORK_DRIVE) && !(status & NETWARE_NETWARE_DRIVE));
}

/*
    Return the drive number of search drive n.
    Return 0 if search drive n does not exist.
 */
int  GetDriveFromSearchNumber (int searchNumber)
{
    char *path;
    int   i;

    path = getenv("PATH");
    if (path == NULL) {
        return 0;
    }

    for (i = 1; i < searchNumber; i++)
    {
        path =strchr (path, ';');

        if (path == NULL || *(path+1) == 0)
            return(0);

        path++;
    }

    return(toupper(*path) - 'A' + 1);
}

/*
    Display a specific drive's mapping.
 */
void DisplayDriveMapping(WORD drive)
{
    unsigned int    iRet = 0;
    WORD       status = 0;
    char       rootPath[MAX_PATH_LEN], relativePath[MAX_PATH_LEN];

    iRet = GetDriveStatus (drive,
                           NETWARE_FORMAT_SERVER_VOLUME,
                           &status,
                           NULL,
                           rootPath,
                           relativePath,
                           NULL);
    if (iRet)
    {
        DisplayError (iRet, "GetDriveStatus");
        return;
    }

    if (status & NETWARE_NETWARE_DRIVE)
        DisplayMessage(IDR_NETWARE_DRIVE, 'A'+drive-1, rootPath, relativePath);
    else if ((status & NETWARE_NETWORK_DRIVE) || (status & NETWARE_LOCAL_DRIVE))
        DisplayMessage(IDR_LOCAL_DRIVE, 'A'+drive-1);
    else
        DisplayMessage(IDR_UNDEFINED, 'A'+drive-1);
}

/*
    Display a specific search drive's mapping.
 */
void DisplaySearchDriveMapping(int searchNumber)
{
    unsigned int    iRet = 0;
    char  *p,  *searchPath;
    int        i;
    WORD       status;
    char       path[MAX_PATH_LEN], rootPath[MAX_PATH_LEN], relativePath[MAX_PATH_LEN];

    searchPath = NWGetPath();
    if (searchPath == NULL) {
        return;
    }

    for (i = 0; i < searchNumber-1; i++)
    {
        searchPath = strchr (searchPath, ';');
        if (searchPath != NULL)
            searchPath++;
        else
            return;
    }

    p = strchr (searchPath, ';');
    if (p != NULL)
    {
        i= (int)(p-searchPath);
        strncpy (path, searchPath, i);
        path[i] = 0;
    }
    else
        strcpy (path, searchPath);

    if (isalpha(*path) && *(path+1) == ':')
    {
        iRet = GetDriveStatus ((unsigned short)(toupper(*path)-'A'+1),
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               rootPath,
                               relativePath,
                               NULL);

        if (iRet)
        {
            DisplayError (iRet, "GetDriveStatus");
            return;
        }
        else
        {
            if (status & NETWARE_NETWARE_DRIVE)
                DisplayMessage(IDR_NETWARE_SEARCH, searchNumber, path, rootPath, relativePath);
            else
                DisplayMessage(IDR_LOCAL_SEARCH, searchNumber, path);
        }
    }
    else
        DisplayMessage(IDR_LOCAL_SEARCH, searchNumber, path);
}

/*
    Return TRUE if the mapPath is parsed, FALSE otherwise.
 */
int  ParseMapPath(char * mapPath, char * volName, char * dirPath, char * serverName, int fMapErrorsOn, char * lpCommand)
{
    unsigned int  iRet=0;
    char         *pColon, inputPath[MAX_PATH_LEN];
    int           drive, nDriveNum;

    // fix g:=:sys:\public case.
    if (*mapPath == ':')
        mapPath++;

    if (strlen (mapPath) > MAX_INPUT_PATH_LEN)
    {
        if (fMapErrorsOn)
            DisplayMessage(IDR_INVALID_PATH, mapPath);
        return FALSE;
    }

    // Get the drive or volume part if there is one.
    if (pColon = strchr (mapPath, ':'))
    {
        char *directory = pColon+1;
        int  searchNumber;

        // Assing drive: part to input.
        strncpy (inputPath, mapPath, (UINT)(directory-mapPath));
        inputPath[directory-mapPath] = 0;

        if (nDriveNum = IsDrive (inputPath))
        {
            if (*inputPath == '*')
            {
                *inputPath = 'A' + nDriveNum - 1;
                *(inputPath+1) = ':';
                *(inputPath+2) = 0;
            }
            else if (!IsNetwareDrive(nDriveNum))
            {
                if (fMapErrorsOn)
                    DisplayMessage(IDR_NOT_NETWORK_DRIVE);
                return(FALSE);
            }
        }
        else if (searchNumber = GetSearchNumber(inputPath))
        {
            int drive = GetDriveFromSearchNumber (searchNumber);

            if (!drive)
            {
                if (fMapErrorsOn)
                    DisplayMessage(IDR_SEARCH_DRIVE_NOT_EXIST, searchNumber);
                return FALSE;
            }

            if (!IsNetwareDrive(drive))
            {
                if (fMapErrorsOn)
                    DisplayMessage(IDR_NOT_NETWORK_DRIVE);
                return(FALSE);
            }

            inputPath[0] = 'A' + drive - 1;
            inputPath[1] = ':';
            inputPath[2] = 0;
        }

        strcat (inputPath, directory);
    }
    else
    {
        if ( fNDS )
        {
            CHAR fullname[MAX_PATH];
            if ( !NDSCanonicalizeName( mapPath, fullname, MAX_PATH, TRUE ) )
                if ( !ConverNDSPathToNetWarePathA( fullname, DSCL_DIRECTORY_MAP,
                     inputPath ) )
                    goto ParseThePath;
        }

        // If drive is not specified, the current drive is used.
        drive = _getdrive();
        if (!IsNetwareDrive(drive))
        {
            if (fMapErrorsOn)
                DisplayMessage(IDR_NOT_NETWORK_DRIVE);
            return(FALSE);
        }

        inputPath[0] = 'A'+drive-1;
        inputPath[1] = ':';
        inputPath[2] = 0;

        strcat (inputPath, mapPath);
    }

ParseThePath:

    iRet = ParsePath (inputPath,
                      serverName,
                      volName,
                      dirPath);
    if (iRet)
    {
        if (iRet == 0x880F)
        {
            DisplayMessage(IDR_MAP_NOT_ATTACHED_SERVER, lpCommand);
            return(FALSE);
        }
        else 
        {
            if (fMapErrorsOn)
                DisplayMessage(IDR_INVALID_PATH, inputPath);
            return(FALSE);
        }
    }

    return(TRUE);
}

/*
    Map drive to mapPath
 */
int  MapDrive (int drive, int searchNum, char * mapPath, int bRoot, int bInsert, int fMapErrorsOn, char *lpCommand)
{
    unsigned int  iRet=0;
    char          volName[MAX_VOLUME_LEN+1]; //+1 for append ':'.
    char          dirPath[MAX_DIR_PATH_LEN];
    int           currentDrive;
    int           OvermapDrive = -1;
    char          serverName[MAX_NAME_LEN];

    if (!ParseMapPath(mapPath, volName, dirPath, serverName, fMapErrorsOn, lpCommand))
        return(3);

    if (IsNetwareDrive(drive))
    {
        if ( drive == _getdrive() ) {
            OvermapDrive = drive;
            _chdrive (SafeDisk);
        }
        if (iRet = DeleteDriveBase ((unsigned short)drive))
        {
            if (fMapErrorsOn) { 
                /* Cannot delete the drive you are on */
                if (iRet == ERROR_DEVICE_IN_USE)
                    DisplayMessage(IDR_CAN_NOT_CHANGE_DRIVE);
                else
                    DisplayError (iRet, "DeleteDriveBase");
            }
            return iRet;
        }
    }
    else if ( IsNonNetwareNetworkDrive(drive) ) {
        if (fMapErrorsOn)
            DisplayMessage(IDR_NON_NETWARE_NETWORK_DRIVE, lpCommand);
        return 3;
    }

    if (bRoot)
    {
        // +2 is for strcat with ":".
        char *fullPath = malloc( MAX_VOLUME_LEN + strlen (dirPath) + 2);
        if (fullPath == NULL)
        {
            if (fMapErrorsOn)
                DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
            return 8;
        }

        strcpy (fullPath, volName);
        strcat (fullPath, ":");
        strcat (fullPath, dirPath);

        iRet = SetDriveBase ((unsigned short)drive,
                             serverName,
                             0,
                             fullPath);

        // Relative names need to be expanded for the redirector

        if ( iRet && fNDS && ( volName[strlen(volName) - 1] == '.' ) )
        {
            char canonName[MAX_VOLUME_LEN+1];
            if ( !NDSCanonicalizeName( volName, canonName, MAX_VOLUME_LEN, TRUE ) ) 
            {
                strcpy (fullPath, canonName);
                strcat (fullPath, ":");
                strcat (fullPath, dirPath);

                iRet = SetDriveBase ((unsigned short)drive,
                                     serverName,
                                     0,
                                     fullPath);
            }
        }

        if (iRet == 0)
        {
            if (searchNum)
                searchNum = InsertSearchDrive(searchNum, drive, bInsert, NULL);

            currentDrive = _getdrive();
            _chdrive (drive);
            _chdir( "\\" );
            _chdrive (currentDrive);
               ExportCurrentDirectory( drive );

            if (fMapDisplayOn)
            {
                if (searchNum)
                    DisplaySearchDriveMapping (searchNum);
                else
                    DisplayDriveMapping((unsigned short)drive);
            }
        }
        else
        {
            if (fMapErrorsOn)
            {
                switch ( iRet )
                {
                case ERROR_DEVICE_IN_USE:
                    DisplayMessage(IDR_CAN_NOT_CHANGE_DRIVE);
                    break;
                case ERROR_BAD_NETPATH:
                case ERROR_BAD_NET_NAME:
                    DisplayMessage(IDR_VOLUME_NOT_EXIST, volName);
                    iRet = 3;
                    break;
                case ERROR_EXTENDED_ERROR:
                    NTPrintExtendedError();
                    iRet = 3;
                    break;
                default:
                    DisplayMessage(IDR_MAP_ERROR, iRet);
                    DisplayMessage(IDR_MAP_FAILED, lpCommand);
                    iRet = 3;
                    break;
                }
            }
        }

        free (fullPath);
    }
    else
    {
        // NETX requires to end the volName with ':'.
        strcat (volName, ":");

        iRet = SetDriveBase ((unsigned short)drive,
                             serverName,
                             0,
                             volName);

        // Relative names need to be expanded for the redirector

        if ( iRet && fNDS && ( volName[strlen(volName) - 2] == '.' ) )
        {
            char canonName[MAX_VOLUME_LEN+1];

            volName[strlen(volName)-1] = '\0';
            if ( !NDSCanonicalizeName( volName, canonName, MAX_VOLUME_LEN, TRUE ) ) 
            {
                strcat (canonName, ":");

                iRet = SetDriveBase ((unsigned short)drive,
                                     serverName,
                                     0,
                                     canonName);
            }
        }

        if (iRet)
        {
            if (fMapErrorsOn)
            {
                switch ( iRet )
                {
                case ERROR_DEVICE_IN_USE:
                    DisplayMessage(IDR_CAN_NOT_CHANGE_DRIVE);
                    break;
                case ERROR_EXTENDED_ERROR:
                    NTPrintExtendedError();
                    iRet = 3;
                    break;
                case ERROR_BAD_NETPATH:
                case ERROR_BAD_NET_NAME:
                default:
                    DisplayMessage(IDR_MAP_INVALID_PATH, lpCommand);
                    iRet = 3;
                    break;
                }
            }
        }
        else
        {
            // Succeed.

            if (searchNum)
                searchNum = InsertSearchDrive(searchNum, drive, bInsert, NULL);

            currentDrive = _getdrive();
            _chdrive (drive);
            if (!iRet && *dirPath)
            {
                iRet = _chdir( "\\" );
                if ( !iRet ) 
                    iRet = _chdir (dirPath);
                if ( iRet ) {
                    if (fMapErrorsOn)
                    {
                        DisplayMessage(IDR_MAP_INVALID_PATH, lpCommand);
                    }

                    iRet = 3;
                }

            }
            else
            {
                _chdir( "\\" );
            }
            _chdrive (currentDrive);
               ExportCurrentDirectory( drive );

            if (iRet == 0 && fMapDisplayOn)
            {
                if (searchNum)
                    DisplaySearchDriveMapping (searchNum);
                else
                    DisplayDriveMapping((unsigned short)drive);
            }

        }
    }

    if ( OvermapDrive != -1 )
        _chdrive (OvermapDrive);

    return(iRet);
}

/*
    Map drive secified by driveNum to mapPath.
    If bRoot is TRUE, use mapPath as the drive base.
 */
int MapNonSearchDrive (int driveNum, char *mapPath, int bRoot, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand)
{
    int driveLetter, iRet = 0;

    if ((driveNum == 0) && (!strchr(mapPath, ':') && !bRoot))
    {
        // map current drive to different directory.
        if (_chdir(mapPath) && fMapErrorsOn)
        {
            DisplayMessage(IDR_DIRECTORY_NOT_FOUND, mapPath);
            iRet = 3;
        }
        else {
            ExportCurrentDirectory( _getdrive() );
            if (fMapDisplayOn)
                DisplayDriveMapping((unsigned short)driveNum);
        }
        return(iRet);
    }
    else if ( (driveNum) && (isalpha(mapPath[0]) && (mapPath[1] == ':')))
    {
        int mapdriveNum = toupper(mapPath[0]) - 'A' + 1;

        if ( driveNum == mapdriveNum )
        {
            // map drive to different directory.
            // map k:=k:\dir

            WORD currentDrive; 
            currentDrive = (USHORT) _getdrive();
            _chdrive (driveNum);
            if (_chdir(mapPath) && fMapErrorsOn)
            {
                DisplayMessage(IDR_DIRECTORY_NOT_FOUND, mapPath);
                iRet = 3;
            }
            else
            {
                ExportCurrentDirectory( _getdrive() );
                if (fMapDisplayOn)
                    DisplayDriveMapping((unsigned short)driveNum);
            }
            _chdrive (currentDrive);
            return(iRet);
        }
    }

    if (driveNum == 0)
        driveNum = _getdrive();
    
    driveLetter = 'A' + driveNum -1;

    return MapDrive (driveNum, 0, mapPath, bRoot, 0, fMapErrorsOn, lpCommand);
}

/*
    Map the last free drive to mapPath and put it in the search path.
    If bInsert is TRUE, don't replace search drive n, otherwise,
    replace.
    If bRoot is TRUE, use mapPath as the drive base.
 */
int MapSearchDrive (int searchNum, int driveNum, char *mapPath, int bInsert, int bRoot, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand)
{
    unsigned int    iRet=0;
    int        i;
    WORD       status;
    char *     lpEqual;

    /*
     * Handle syntax map s2:=w:=volume:
     * Handle syntax map w:=s2:=volume:
     */
    if ( driveNum ) 
    {
        return MapDrive (driveNum, searchNum, mapPath, bRoot, bInsert, fMapErrorsOn, lpCommand);
    }

    // Check if mapPath is local path.
    if (mapPath[1] == ':' &&
        IsLocalDrive (toupper(mapPath[0])-'A'+1))
    {
        i = 0;  // a bug?
        searchNum = InsertSearchDrive(searchNum, i, bInsert, mapPath);
        if ((searchNum != 0) && fMapDisplayOn)
            DisplayMessage(IDR_LOCAL_SEARCH, searchNum, mapPath);
        return 0;
    }

    // Try to find the last available drive.
    for (i = 26; i >= 1; i--)
    {
        iRet = GetDriveStatus ((unsigned short)i,
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        if (iRet)
            continue;

        if (!(status & NETWARE_LOCAL_DRIVE) &&
            !(status & NETWARE_NETWORK_DRIVE))
        {
            // Found. Map it to the path.
            return MapDrive (i, searchNum, mapPath, bRoot, bInsert, fMapErrorsOn, lpCommand);
        }
    }

    if (fMapErrorsOn)
        DisplayMessage (IDR_NO_DRIVE_AVAIL);
    return(0);
}

/*
    Map the next available drive to the mapPath.
 */
int MapNextAvailableDrive (char *mapPath, int fMapDisplayOn, int fMapErrorsOn, char *lpCommand)
{
    unsigned int iRet = 0;
    int        i;
    WORD       status;

    // Find a free drive that is not mapped.
    // Then map it to the mapPath.
    for (i = 1; i <= 26; i++)
    {
        iRet = GetDriveStatus ((unsigned short)i,
                               NETWARE_FORMAT_SERVER_VOLUME,
                               &status,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        if (iRet)
        {
            if (fMapErrorsOn)
                DisplayError (iRet, "GetDriveStatus");
            return iRet;
        }

        if (!(status & NETWARE_LOCAL_DRIVE) &&
            !(status & NETWARE_NETWORK_DRIVE))
        {
            iRet = MapNonSearchDrive (i, mapPath, FALSE, fMapDisplayOn, fMapErrorsOn, lpCommand);
            return iRet;
        }
    }

    if (fMapErrorsOn)
        DisplayMessage(IDR_NO_DRIVE_AVAIL);

    return(0);
}

/*
    Remove a drive mapping.
 */
int RemoveDrive (WORD drive, int fMapDisplayOn, int fMapErrorsOn)
{
    unsigned int    iRet=0;
    int        searchNum;

    if (IsNetwareDrive (drive))
    {
        if (searchNum = IsSearchDrive(drive))
        {
            RemoveSearchDrive (searchNum, fMapDisplayOn, fMapErrorsOn);
        }
        else
        {
            /*
                 * Can't delete current drive on NT
             */
            if ( drive == _getdrive() ) {
                _chdrive (SafeDisk);
            }
            if (iRet = DeleteDriveBase (drive))
            {
                if (fMapErrorsOn)
                    DisplayError (iRet, "DeleteDriveBase");
            }
            else
            {
                if (fMapDisplayOn)
                    DisplayMessage(IDR_DEL_DRIVE, 'A'+drive-1);
            }
        }
    }
    else
    {
        if (fMapErrorsOn)
            DisplayMessage(IDR_WRONG_DRIVE, 'A'+drive-1);

        return(50); //error level.
    }

    return(0);
}

/*
    Remove a search drive.
 */
void RemoveSearchDrive (int searchNumber, int fMapDisplayOn, int fMapErrorsOn)
{
    WORD       drive;

    // Get the drive number.
    drive = (WORD) GetDriveFromSearchNumber (searchNumber);

    if (!drive)
    {
        if (fMapErrorsOn)
            DisplayMessage(IDR_SEARCH_DRIVE_NOT_EXIST, searchNumber);
        return;
    }

    // If the drive is a netware drive, remove the drive mapping.
    if (IsNetwareDrive (drive))
    {
        unsigned int    iRet=0;
        /*
         * Can't delete current drive on NT
         */
        if ( drive == _getdrive() ) {
            _chdrive (SafeDisk);
        }
        if (iRet = DeleteDriveBase (drive))
        {
            if (fMapErrorsOn)
                DisplayError (iRet, "DeleteDriveBase");
            return;
        }
    }

    RemoveDriveFromPath (searchNumber, fMapErrorsOn);

    if (fMapDisplayOn)
        DisplayMessage(IDR_DEL_SEARCH_DRIVE, 'A'+drive-1);

    // If the drive is not a local drive, remove all reference
    // to the drive in the path.
    if (!IsLocalDrive (drive))
    {
        while (searchNumber = IsSearchDrive (drive))
        {
            RemoveDriveFromPath (searchNumber, fMapErrorsOn);
        }
    }
}

/*
    Remove a search drive from the path.
 */
void RemoveDriveFromPath(int searchNumber, int fMapErrorsOn)
{
    char  *pOldPath,  *pNewPath,  *restEnvSeg,  *pPath, *Path;
    int        i, n;

    // Move pOldPath to where we want to put the new path string.
    pOldPath = NWGetPath();
    if (pOldPath == NULL) {
        return;
    }

    pPath = malloc( strlen(pOldPath) + 5 + 1 + 1 );
    if (pPath == NULL) {
        return;
    }
    strcpy(pPath, "PATH=");
    strcat(pPath, pOldPath);
    pOldPath = pPath + 5;

    for (i = 1; i < searchNumber; i++)
    {
        pOldPath=strchr (pOldPath, ';');

        if (pOldPath == NULL)
        {
            if (fMapErrorsOn)
                DisplayMessage(IDR_SEARCH_DRIVE_NOT_EXIST, searchNumber);
            free( pPath );
            return;
        }

        pOldPath++;
    }

    // Move pNewPath to the beginning of the path string that
    // needs to be moved.
    if (pNewPath = strchr (pOldPath, ';'))
        pNewPath++ ;
    else
        pNewPath = pOldPath + strlen (pOldPath);

    // Calculate the number of characters needs to be moved.
    n = strlen (pNewPath) + 1;
    restEnvSeg = pNewPath + n;

    n++;

    // Move the path string to overwrite the search drive.
    memmove (pOldPath, pNewPath, n);

    Path = malloc (strlen (pPath)+1);
    if (Path) {
        strcpy (Path, pPath);
        _putenv (Path);
    }
    ExportEnv( pPath );
    free( pPath );
}


/*
    If bInsert is TRUE, insert dirve specified by driveNum as search
    drive specified by searchNum. Otherwise replace search drive
    specified by searchNum with drive specified by driveNum.
 */
int InsertSearchDrive(int searchNum, int driveNum, int bInsert, char * insertPath)
{
    char  *pOldPath,  *pNewPath,  *restEnvSeg,  *pPath, *Path;
    int        i, n = 0, bSemiColon, nInsertChar;

    nInsertChar = (insertPath == NULL)? 3 : strlen (insertPath);

    // Check if memory block is large enough.
    if (!MemorySegmentLargeEnough (nInsertChar+1))
        return 0;

    // Move pNewPath to where we put the new drive.
    pNewPath = NWGetPath();

    //-- Multi user code merge. Citrix bug fixes ----
    // 8/14/96 cjc  Fix trap cause path is NULL.
    pPath = NULL;    //compiler error
    if (!pNewPath) {
       pPath = malloc(  5 + 1 + nInsertChar + 1 + 1 );
    }
    else {
       pPath = malloc( strlen(pNewPath) + 5 + 1 + nInsertChar + 1 + 1 );
    }
    if (pPath == NULL) {
        return 0;
    }
    strcpy(pPath, "PATH=");

    if (pNewPath) {
       strcat(pPath, pNewPath);
    }

    pNewPath = pPath + 5;

    for (i = 1; i < searchNum; i++)
    {
        if (strchr (pNewPath, ';'))
        {
            pNewPath = strchr (pNewPath, ';');
        }
        else
        {
            pNewPath += strlen (pNewPath);
            bInsert = TRUE;
            i++;
            break;
        }

        pNewPath++;
    }

    // Move pOldPath to the begining of the path string that needs
    // to be moved.
    if (bInsert)
        pOldPath = pNewPath;
    else
    {
        if ((pOldPath = strchr (pNewPath, ';')) == NULL)
            pOldPath = pNewPath + strlen (pNewPath);
        else
            pOldPath++;
    }

    // Figure out the number of characters that need to be moved.
    n = strlen (pOldPath) + 1;
    restEnvSeg = pOldPath + strlen (pOldPath) + 1;

    n++;

    // If we insert a new drive to the end of the path which ends with
    // a ';', or if we replace the last search drive, no ';' is needed.
    bSemiColon = bInsert ? (*(pNewPath-1) != ';' || *pOldPath != 0)
                         : (*pOldPath != 0);

    // Move the old path so that we will have space for the new search drive.
    memmove (pNewPath + (bSemiColon? nInsertChar+1:nInsertChar), pOldPath, n);

    if ((*pNewPath == 0)&& bSemiColon)
    {
        // Insert as the last one to the path.
        // Put ';' at the begining.
        *pNewPath = ';';
        if (insertPath == NULL)
        {
            *(pNewPath+1) = 'A' + driveNum - 1;
            *(pNewPath+2) = ':';
            *(pNewPath+3) = '.';
        }
        else
            memcpy (pNewPath+1, insertPath, nInsertChar);
    }
    else
    {
        if (insertPath == NULL)
        {
            *pNewPath = 'A' + driveNum - 1;
            *(pNewPath+1) = ':';
            *(pNewPath+2) = '.';
        }
        else
            memcpy (pNewPath, insertPath, nInsertChar);
        if (bSemiColon)
            *(pNewPath+nInsertChar) = ';';
    }

    Path = malloc (strlen (pPath)+1);
    if (Path) {
        strcpy (Path, pPath);
        _putenv (Path);
    }
    ExportEnv( pPath );
    free( pPath );

    return (i);
}

/*
 *  Used by SetEnv().
 *  Return the number of bytes of environment variable pointed by lpRest
 */
int GetRestEnvLen (char  *lpRest)
{
    int  nTotal = 1;
    nTotal += strlen (lpRest);

    return(nTotal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\psdb.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nwlibs\psdb.c

Abstract:

    Read the Print Con database file APIs.

Author:

    Shawn Walker (v-swalk) 12-12-1994

Revision History:

--*/
#include "common.h"

extern DWORD SwapLong(DWORD number);

unsigned int
PSGetJobName(
    unsigned int    ConnectionHandle,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord,
    unsigned char   GetDefault
    );

#define MAX_JOB_NAME_ENTRY  37

#define O_RDONLY        0x0000        /* open for reading only */
#define O_WRONLY        0x0001        /* open for writing only */
#define O_RDWR          0x0002        /* open for reading and writing */
#define O_APPEND        0x0008        /* writes done at eof */
#define O_CREAT         0x0100        /* create and open file */
#define O_TRUNC         0x0200        /* open and truncate */
#define O_EXCL          0x0400        /* open only if file doesn't already exist */
#define O_TEXT          0x4000        /* file mode is text (translated) */
#define O_BINARY        0x8000        /* file mode is binary (untranslated) */

#define S_IEXEC         0000100         /* execute/search permission, owner */
#define S_IWRITE        0000200         /* write permission, owner */
#define S_IREAD         0000400         /* read permission, owner */
#define S_IFCHR         0020000         /* character special */
#define S_IFDIR         0040000         /* directory */
#define S_IFREG         0100000         /* regular */
#define S_IFMT          0170000         /* file type mask */

#include <pshpack1.h>
typedef struct _PRINTCON_HEADER {
    unsigned char   Text[115];
    unsigned char   MajorVersion;
    unsigned char   MinorVersion1;
    unsigned char   MinorVersion2;
    unsigned char   DefaultJobName[32];
} PRINTCON_HEADER, *PPRINTCON_HEADER;

#define PRINTCON_HEADER_SIZE    sizeof(PRINTCON_HEADER)

typedef struct _JOB_NAME_AREA {
    unsigned char   JobName[32];
    unsigned long   JobRecordOffset;
} JOB_NAME_AREA, *PJOB_NAME_AREA;

#define JOB_NAME_AREA_SIZE    sizeof(JOB_NAME_AREA)

typedef struct _JOB_RECORD_AREA {
    unsigned char   ServerName[NCP_BINDERY_OBJECT_NAME_LENGTH];
    unsigned char   QueueName[NCP_BINDERY_OBJECT_NAME_LENGTH];
    unsigned char   TabSize;
    unsigned short  NumberOfCopies;
    unsigned char   FormName[40];
    unsigned char   NotifyWhenDone; //0=No, 1=Yes
    unsigned long   PrintServerID;
    unsigned char   Name[13];
    unsigned char   BannerName[13];
    unsigned char   Device[33];
    unsigned char   Mode[33];
    unsigned char   BannerFlag;     //0=No Banner, 1=Banner
    unsigned char   DataType;       //1=Byte,0=Stream
    unsigned char   FormFeed;       //0=Don't Suppress FF, 1=Suppress FF
    unsigned short  TimeoutCount;
    unsigned char   LocalPrinter;   //1=LPT1, 2=LPT2, 3=LPT3
    unsigned char   AutoEndCap;     //0=Don't Auto EndCap, 1=Do Auto EndCap
} JOB_RECORD_AREA, *PJOB_RECORD_AREA;
#include <poppack.h>

#define JOB_RECORD_AREA_SIZE    sizeof(JOB_RECORD_AREA)


/*++
*******************************************************************

        PSJobGetDefault

Routine Description:

        Get the default print job configuration from the printcon.dat
        file.

Arguments:

        ConnectionHandle = The connection handle to use.
        SearchFlag = 
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PSJobGetDefault(
    unsigned int    ConnectionHandle,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    )
{
    return PSGetJobName(
                ConnectionHandle,
                SearchFlag,
                pOwner,
                pJobName,
                pJobRecord,
                TRUE);
}


/*++
*******************************************************************

        PSJobRead

Routine Description:

        Get the print job configuration from the printcon.dat file.

Arguments:

        ConnectionHandle = The connection handle to use.
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PSJobRead(
    unsigned int    ConnectionHandle,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    )
{
    return PSGetJobName(
                ConnectionHandle,
                0,
                pOwner,
                pJobName,
                pJobRecord,
                FALSE);
}


/*++
*******************************************************************

        PSGetJobName

Routine Description:

        Common routine to get the print job configuration from the
        printcon.dat file.

Arguments:

        ConnectionHandle = The connection handle to use.
        SearchFlag = 
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.
        GetDefault = TRUE = get the default job name, FALSE = Don't get
                      the default job name.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PSGetJobName(
    unsigned int    ConnectionHandle,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord,
    unsigned char   GetDefault
    )
{
    unsigned char   *pSearchJobName;
    unsigned long   ObjectId;
    FILE            *stream = NULL;
    unsigned int    Count;
    unsigned int    Bytes;
    unsigned int    RetCode;
    unsigned int    ConnectionNumber;
    JOB_NAME_AREA   JobNameArea;
    JOB_RECORD_AREA JobRecord;
    PRINTCON_HEADER PrintConHeader;
    unsigned char   MailDirPath[NCP_MAX_PATH_LENGTH];

    /** Get the connection number for this connection **/

    RetCode = GetConnectionNumber(ConnectionHandle, &ConnectionNumber);
    if (RetCode) {
        goto CommonExit;
    }

    RetCode = GetBinderyObjectID (ConnectionHandle, LOGIN_NAME,
                                  OT_USER, &ObjectId);
    if (RetCode) {
        goto CommonExit;
    }

    /** Build the path to open the file **/

    sprintf(MailDirPath, "SYS:MAIL/%lX/PRINTCON.DAT", SwapLong(ObjectId));

    stream = fopen(NTNWtoUNCFormat( MailDirPath), "rb");
    if (stream == NULL) {
        RetCode = PS_ERR_OPENING_DB;
        goto CommonExit;
    }

    Bytes = fread( (unsigned char *) &PrintConHeader, sizeof( char), PRINTCON_HEADER_SIZE, stream);
    if (Bytes < PRINTCON_HEADER_SIZE) {
        RetCode = PS_ERR_INTERNAL_ERROR;
        goto CommonExit;
    }

    /** Check the version number **/

    if ((PrintConHeader.MajorVersion != 3 &&
         PrintConHeader.MajorVersion != 1) ||
        PrintConHeader.MinorVersion1 != 1 ||
        PrintConHeader.MinorVersion2 != 1) {

        RetCode = PS_ERR_BAD_VERSION;
        goto CommonExit;
    }
    /** Get the name we are looking for **/

    if (GetDefault) {
        if (PrintConHeader.DefaultJobName[0] == 0) {
            RetCode = PS_ERR_NO_DEFAULT_SPECIFIED;
            goto CommonExit;
        }
        pSearchJobName = PrintConHeader.DefaultJobName;
    }
    else {
        pSearchJobName = pJobName;
    }

    Count = 0;

    /** Go through all of the job entry to look for the name **/

    while (Count < MAX_JOB_NAME_ENTRY) {
        Bytes = fread( (unsigned char *) &JobNameArea, sizeof(unsigned char), JOB_NAME_AREA_SIZE, stream);
        if (Bytes < JOB_NAME_AREA_SIZE) {
            RetCode = PS_ERR_INTERNAL_ERROR;
            goto CommonExit;
        }
        Count++;

        /** Skip the entry with a null job name **/

        if (JobNameArea.JobName[0] == 0) {
            continue;
        }
    
        /** Is this the job name we are looking for? **/

        if (!_strcmpi(pSearchJobName, JobNameArea.JobName)) {
            break;
        }
    }

    /** See if we found the job name **/

    if (Count > MAX_JOB_NAME_ENTRY) {
        if (GetDefault) {
            RetCode = PS_ERR_GETTING_DEFAULT;
        }
        else {
            RetCode = PS_ERR_READING_RECORD;
        }
        goto CommonExit;
    }

    if (fseek(stream, JobNameArea.JobRecordOffset, SEEK_SET)) {
        RetCode = PS_ERR_READING_RECORD;
        goto CommonExit;
    }

    Bytes = fread( (unsigned char *) &JobRecord, sizeof(unsigned char), JOB_RECORD_AREA_SIZE, stream);
    if (Bytes < JOB_RECORD_AREA_SIZE) {
        RetCode = PS_ERR_READING_RECORD;
        goto CommonExit;
    }

    memset(pJobRecord, 0, PS_JOB_RECORD_SIZE);

    if (JobRecord.NotifyWhenDone) {
        pJobRecord->PrintJobFlag |= PS_JOB_NOTIFY;
    }
    if (JobRecord.BannerFlag) {
        pJobRecord->PrintJobFlag |= PS_JOB_PRINT_BANNER;
    }
    if (JobRecord.DataType) {
        pJobRecord->PrintJobFlag |= PS_JOB_EXPAND_TABS;
    }
    if (JobRecord.FormFeed) {
        pJobRecord->PrintJobFlag |= PS_JOB_NO_FORMFEED;
    }
    if (JobRecord.AutoEndCap) {
        pJobRecord->PrintJobFlag |= PS_JOB_AUTO_END;
    }
    if (JobRecord.TimeoutCount) {
        pJobRecord->PrintJobFlag |= PS_JOB_TIMEOUT;
    }

    pJobRecord->Copies                    = JobRecord.NumberOfCopies;
    pJobRecord->TabSize                   = JobRecord.TabSize;
    pJobRecord->TimeOutCount              = JobRecord.TimeoutCount;
    pJobRecord->LocalPrinter              = JobRecord.LocalPrinter;

    strcpy(pJobRecord->Mode,                JobRecord.Mode);
    strcpy(pJobRecord->Device,              JobRecord.Device);
    strcpy(pJobRecord->FormName,            JobRecord.FormName);
    strcpy(pJobRecord->BannerName,          JobRecord.BannerName);
    strcpy(pJobRecord->u.NonDS.PrintQueue,  JobRecord.QueueName);
    strcpy(pJobRecord->u.NonDS.FileServer,  JobRecord.ServerName);

    if (GetDefault && pJobName) {
        strcpy(pJobName, JobNameArea.JobName);
    }

    if (pOwner) {
        *pOwner = 0;
    }

CommonExit:

    if (stream != NULL) {
        fclose( stream );
    }

    return RetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\script.c ===
/*************************************************************************
*
*  SCRIPT.C
*
*  Script routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*************************************************************************/

#include "common.h"
#include <direct.h>
#include <time.h>
#include <ctype.h>
#include <process.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <io.h>
#include <time.h>

extern VOID nwShowLastLoginTime( VOID );

#define MAXLEN     256
#define MAX_NUM_IF 10

#define NUMCOMMAND 45

#define CM_IF     20
#define CM_ELSE   21
#define CM_ENDIF  22
#define CM_END    23

//
// 3X and 4X variables
//

#define IDS_DAY_OF_WEEK                    0
#define IDS_DAY                            1
#define IDS_MONTH_NAME                     2
#define IDS_MONTH                          3
#define IDS_NDAY_OF_WEEK                   4
#define IDS_SHORT_YEAR                     5
#define IDS_YEAR                           6
#define IDS_AM_PM                          7
#define IDS_GREETING_TIME                  8
#define IDS_HOUR24                         9
#define IDS_HOUR                          10
#define IDS_MINUTE                        11
#define IDS_SECOND                        12
#define IDS_FULL_NAME                     13
#define IDS_LOGIN_NAME                    14
#define IDS_USER_ID                       15
#define IDS_PASSWORD_EXPIRES              16
#define IDS_NETWORK_ADDRESS               17
#define IDS_FILE_SERVER                   18
#define IDS_ACCESS_SERVER                 19
#define IDS_ERROR_LEVEL                   20
#define IDS_ERRORLEVEL                    21
#define IDS_MACHINE                       22
#define IDS_OS_VERSION                    23
#define IDS_OS                            24
#define IDS_SMACHINE                      25
#define IDS_SHELL_TYPE                    26
#define IDS_STATION                       27
#define IDS_P_STATION                     28
#define IDS_SHELL_VERSION                 29
#define NUMVAR_3X                         IDS_SHELL_VERSION + 1 

#define IDS_LAST_NAME                     30
#define IDS_LOGIN_CONTEXT                 31
#define IDS_NETWARE_REQUESTER             32
#define IDS_REQUESTER_CONTEXT             33
#define IDS_ACCOUNT_BALANCE               34
#define IDS_CN                            35
#define IDS_REQUESTER_VERSION             36
#define IDS_SURNAME                       37
#define IDS_DOS_REQUESTER                 38
#define IDS_REQUESTER                     39
#define IDS_ADMINISTRATIVE_ASSISTANT      40
#define IDS_ALLOW_UNLIMITED_CREDIT        41
#define IDS_DESCRIPTION                   42
#define IDS_EMAIL_ADDRESS                 43
#define IDS_EMPLOYEE_ID                   44
#define IDS_FACSIMILE_TELEPHONE_NUMBER    45
#define IDS_GROUP_MEMBERSHIP              46
#define IDS_HIGHER_PRIVILEGES             47
#define IDS_HOME_DIRECTORY                48
#define IDS_INITIALS                      49
#define IDS_LANGUAGE                      50
#define IDS_LOCKED_BY_INTRUDER            51
#define IDS_LOGIN_DISABLED                52
#define IDS_LOGIN_GRACE_LIMIT             53
#define IDS_LOGIN_GRACE_REMAINING         54
#define IDS_LOGIN_INTRUDER_ATTEMPTS       55
#define IDS_LOGIN_MAXIMUM_SIMULTANEOUS    56
#define IDS_MAILSTOP                      57
#define IDS_MESSAGE_SERVER                58
#define IDS_MINIMUM_ACCOUNT_BALANCE       59
#define IDS_NETWORK                       60
#define IDS_OBJECT_CLASS                  61
#define IDS_OU                            62
#define IDS_PASSWORD_ALLOW_CHANGE         63
#define IDS_PASSWORD_MINIMUM_LENGTH       64
#define IDS_PASSWORD_REQUIRED             65
#define IDS_PASSWORD_UNIQUE_REQUIRED      66
#define IDS_PASSWORDS_USED                67
#define IDS_PHYSICAL_DELIVERY_OFFICE_NAME 68
#define IDS_POSTAL_ADDRESS                69
#define IDS_POSTAL_CODE                   70
#define IDS_POSTAL_OFFICE_BOX             71
#define IDS_PRIVATE_KEY                   72
#define IDS_PROFILE                       73
#define IDS_REVISION                      74
#define IDS_SECURITY_EQUALS               75
#define IDS_SECURITY_FLAGS                76
#define IDS_SEE_ALSO                      77
#define IDS_SERVER_HOLDS                  78
#define IDS_SUPERVISOR                    79
#define IDS_TELEPHONE_NUMBER              80
#define IDS_TITLE                         81
#define IDS_CERTIFICATE_VALIDITY_INTERVAL 82
#define IDS_EQUIVALENT_TO_ME              83
#define IDS_GENERATIONAL_QUALIFIER        84
#define IDS_GIVEN_NAME                    85
#define IDS_MAILBOX_ID                    86
#define IDS_MAILBOX_LOCATION              87
#define IDS_PROFILE_MEMBERSHIP            88
#define IDS_SA                            89
#define IDS_S                             90
#define IDS_L                             91
#define IDS_ACCESS                        92
#define NUMVAR                            IDS_ACCESS + 1

/*
 *  String constants.
 */

/*
 *  Text for default Login Script.  Don't change.
 */
BYTE   DefaultLoginScript[] =
    "WRITE \"Good %GREETING_TIME, %LOGIN_NAME.\\n\"\n"
    "MAP DISPLAY OFF\n"
    "MAP ERRORS OFF\n"
    "Rem: Set 1st drive to most appropriate directory.\n"
    "MAP *1:=%FILE_SERVER/SYS:;*1:=%FILE_SERVER/SYS:%LOGIN_NAME\n"
    "If LOGIN_NAME=\"SUPERVISOR\" || LOGIN_NAME=\"ADMIN\" || LOGIN_NAME=\"SUPERVIS\" THEN MAP *1:=%FILE_SERVER/SYS:SYSTEM\n"
    "Rem: Set search drives (S2 machine-OS dependent).\n"
    "MAP INS S1:=%FILE_SERVER/SYS:PUBLIC\n"
    "MAP INS S2:=%FILE_SERVER/SYS:\n"
    "Rem: Now display all the current drive settings.\n"
    "MAP DISPLAY ON\n"
    "MAP\n"
    "\0";

char *__SPACES__=" \t";

/*
 *  Do not change the order of this array.
 */
char * COMPARE_OPERATORS[] =
{
    "!=",
    "<>",
    "NOT EQUAL TO",
    "DOES NOT EQUAL",
    "NOT EQUAL",
    "IS NOT EQUAL",
    "#",
    "IS NOT",                      // 7
    ">=",                          // 8
    "IS GREATER THAN OR EQUAL TO",
    "IS GREATER THAN OR EQUAL",
    "GREATER THAN OR EQUAL TO",
    "GREATER THAN OR EQUAL",
    ">",                           // 13
    "IS GREATER THAN",
    "GREATER THAN",
    "<=",                          // 16
    "IS LESS THAN OR EQUAL TO",
    "IS LESS THAN OR EQUAL",
    "LESS THAN OR EQUAL TO",
    "LESS THAN OR EQUAL",
    "<",                           // 21
    "IS LESS THAN",
    "LESS THAN",
    "==",                          // 24
    "=",
    "EQUALS",
    "EQUAL",
    "IS",
    "\0"
};

int IsNotEqual (int nIndex)
{
    return(nIndex < 8);
}

int IsGreaterOrEqual (int nIndex)
{
    return(nIndex >= 8 && nIndex < 13);
}

int IsGreater (int nIndex)
{
    return(nIndex >= 13 && nIndex < 16);
}

int IsLessOrEqual (int nIndex)
{
    return(nIndex >= 16 && nIndex < 21);
}

int IsLess (int nIndex)
{
    return(nIndex >= 21 && nIndex < 24);
}

/*
 *  Type defs.
 */
typedef int (*PFCommandHandler) (char *lpParam);

typedef struct tagCOMMANDTABLE
{
    char *commandStr0;
    char *commandStr1;
    char *commandStr2;
    PFCommandHandler commandhandler;
}COMMANDTABLE;

typedef struct tagLABEL_LIST
{
    char *pLabel;
    char *pNextLine;
    struct tagLABEL_LIST *pNext;
}LABEL_LIST, *PLABEL_LIST;

/*
 *  Functions that are in command dispatch table.
 */
int AttachHandler    (char *lpParam);
int BreakHandler     (char *lpParam);
int ComspecHandler   (char *lpParam);
int DisplayHandler   (char *lpParam);
int DosBreakHandler  (char *lpParam);
int SetHandler       (char *lpParam);
int LocalSetHandler  (char *lpParam);
int DosVerifyHandler (char *lpParam);
int DriveHandler     (char *lpParam);
int FireHandler      (char *lpParam);
int ExitHandler      (char *lpParam);
int IfHandler        (char *lpParam);
int ElseHandler      (char *lpParam);
int EndHandler       (char *lpParam);
int IncludeHandler   (char *lpParam);
int MapHandler       (char *lpParam);
int PauseHandler     (char *lpParam);
int WriteHandler     (char *lpParam);
int NullHandler      (char *lpParam);
int GotoHandler      (char *lpParam);
int ShiftHandler     (char *lpParam);
int MachineHandler   (char *lpParam);
int CompatibleHandler(char *lpParam);
int ClearHandler     (char *lpParam);
int LastLoginTimeHandler(char *lpParam);
int ContextHandler   (char *lpParam);
int ScriptServerHandler(char *lpParam);
int NoDefaultHandler (char *lpParam);

/*
 *  Command dispatch table. Do not change.
 *
 *  If you do, you must change CM_IF, CM_ELSE, CM_END and CM_ENDIF
 */
COMMANDTABLE nwCommand[NUMCOMMAND] =
{
    "LOCAL",            "DOS",     "SET",    LocalSetHandler,
    "TEMP",             "DOS",     "SET",    LocalSetHandler,
    "TEMPORARY",        "DOS",     "SET",    LocalSetHandler,
    "LOCAL",            "SET",     NULL,     LocalSetHandler,
    "TEMP",             "SET",     NULL,     LocalSetHandler,
    "TEMPORARY",        "SET",     NULL,     LocalSetHandler,
    "DOS",              "SET",     NULL,     SetHandler,
    "DOS",              "VERIFY",  NULL,     DosVerifyHandler,
    "DOS",              "BREAK",   NULL,     DosBreakHandler,
    "FIRE",             "PHASERS", NULL,     FireHandler,
    "ATTACH",           NULL,      NULL,     AttachHandler,
    "BREAK",            NULL,      NULL,     BreakHandler,
    "COMSPEC",          NULL,      NULL,     NullHandler,
    "DISPLAY",          NULL,      NULL,     DisplayHandler,
    "SET_TIME",         NULL,      NULL,     NullHandler,     
    "SET",              NULL,      NULL,     SetHandler,
    "DRIVE",            NULL,      NULL,     DriveHandler,
    "FDISPLAY",         NULL,      NULL,     DisplayHandler,
    "FIRE",             NULL,      NULL,     FireHandler,
    "EXIT",             NULL,      NULL,     ExitHandler,
    "IF",               NULL,      NULL,     IfHandler,       // CM_IF
    "ELSE",             NULL,      NULL,     ElseHandler,     // CM_ELSE 
    "ENDIF",            NULL,      NULL,     EndHandler,      // CM_ENDIF
    "END",              NULL,      NULL,     EndHandler,      // CM_END
    "INCLUDE",          NULL,      NULL,     IncludeHandler,
    "MACHINE",          NULL,      NULL,     MachineHandler,
    "MAP",              NULL,      NULL,     MapHandler,
    "PAUSE",            NULL,      NULL,     PauseHandler,
    "COMPATIBLE",       NULL,      NULL,     CompatibleHandler,
    "PCCOMPATIBLE",     NULL,      NULL,     CompatibleHandler,
    "REMARK",           NULL,      NULL,     NullHandler,
    "REM",              NULL,      NULL,     NullHandler,
    "SHIFT",            NULL,      NULL,     ShiftHandler,
    "WAIT",             NULL,      NULL,     PauseHandler,
    "WRITE",            NULL,      NULL,     WriteHandler,   
    "GOTO",             NULL,      NULL,     GotoHandler,   
    "CLS",              NULL,      NULL,     ClearHandler, 
    "CLEAR",            NULL,      NULL,     ClearHandler,
    "SWAP",             NULL,      NULL,     NullHandler,     
    "LASTLOGIN",        NULL,      NULL,     LastLoginTimeHandler, // 39
    "CONTEXT",          NULL,      NULL,     ContextHandler,       // 40
    "SCRIPT_SERVER",    NULL,      NULL,     ScriptServerHandler,  // 41
    "NO_DEFAULT",       NULL,      NULL,     NoDefaultHandler,     // 42
    "CX",               NULL,      NULL,     ContextHandler,       // 43
    "PATH",             NULL,      NULL,     MapHandler,           // 44
};

typedef struct tagVARTABLE
{
    char *VarName;
}VARTABLE;

VARTABLE varTable[NUMVAR] =
{
    "DAY_OF_WEEK",
    "DAY",       
    "MONTH_NAME",
    "MONTH",    
    "NDAY_OF_WEEK",
    "SHORT_YEAR", 
    "YEAR",      
    "AM_PM",    
    "GREETING_TIME",
    "HOUR24",      
    "HOUR",       
    "MINUTE",    
    "SECOND",   
    "FULL_NAME", 
    "LOGIN_NAME",
    "USER_ID",  
    "PASSWORD_EXPIRES",
    "NETWORK_ADDRESS",
    "FILE_SERVER",   
    "ACCESS_SERVER",
    "ERROR_LEVEL", 
    "ERRORLEVEL", 
    "MACHINE",   
    "OS_VERSION", 
    "OS",        
    "SMACHINE", 
    "SHELL_TYPE",
    "STATION",  
    "P_STATION", 
    "SHELL_VERSION",
    "LAST_NAME", 
    "LOGIN_CONTEXT",
    "NETWARE_REQUESTER",
    "REQUESTER_CONTEXT",
    "ACCOUNT_BALANCE",  
    "CN",               
    "REQUESTER_VERSION",
    "SURNAME",          
    "DOS_REQUESTER",
    "REQUESTER",
    "ADMINISTRATIVE_ASSISTANT",
    "ALLOW_UNLIMITED_CREDIT",
    "DESCRIPTION",
    "EMAIL_ADDRESS",
    "EMPLOYEE_ID",
    "FACSIMILE_TELEPHONE_NUMBER",
    "GROUP_MEMBERSHIP",
    "HIGHER_PRIVILEGES",
    "HOME_DIRECTORY",
    "INITIALS",
    "LANGUAGE",
    "LOCKED_BY_INTRUDER",
    "LOGIN_DISABLED",
    "LOGIN_GRACE_LIMIT",
    "LOGIN_GRACE_REMAINING",
    "LOGIN_INTRUDER_ATTEMPTS",
    "LOGIN_MAXIMUM_SIMULTANEOUS",
    "MAILSTOP",
    "MESSAGE_SERVER",
    "MINIMUM_ACCOUNT_BALANCE",
    "NETWORK",
    "OBJECT_CLASS",
    "OU",
    "PASSWORD_ALLOW_CHANGE",
    "PASSWORD_MINIMUM_LENGTH",
    "PASSWORD_REQUIRED",
    "PASSWORD_UNIQUE_REQUIRED",
    "PASSWORDS_USED",
    "PHYSICAL_DELIVERY_OFFICE_NAME",
    "POSTAL_ADDRESS",
    "POSTAL_CODE",
    "POSTAL_OFFICE_BOX",
    "PRIVATE_KEY",
    "PROFILE",
    "REVISION",
    "SECURITY_EQUALS",
    "SECURITY_FLAGS",
    "SEE_ALSO",
    "SERVER_HOLDS",
    "SUPERVISOR",
    "TELEPHONE_NUMBER",
    "TITLE",
    "CERTIFICATE_VALIDITY_INTERVAL",
    "EQUIVALENT_TO_ME",
    "GENERATIONAL_QUALIFIER",
    "GIVEN_NAME",
    "MAILBOX_ID",
    "MAILBOX_LOCATION",
    "PROFILE_MEMBERSHIP",
    "SA",
    "S",
    "L",
    "ACCESS",
};

/*
 *  Local functions.
 */
void  SmartCap(char *ptr);
int   NWGetFileSize (char * lpFileName);
void  LoadFile (char *lpFileName, char *lpFileBuffer, int nFileSize);
int   ProcessLoginScriptFile (char *lpLoginScriptFile);
void  ProcessLoginScript (char *lpLoginScript);
int   ProcessLoginScriptProperty (unsigned char *);

int   CreateLabelList (PLABEL_LIST *ppLabelList, char *lpLoginScript);
void  FreeLabelList (LABEL_LIST *pLabelList);

void  ExternalCmdHandler(char *lpCommand);
void  BadCommandHandler (char *lpCommand);

void  CommandDispatch (char *lpCommand);
int   GetTableIndex(char *lpCommand, char ** prestbuffer);

DWORD SwapLong(DWORD number);
int   EndOfLine (char *buffer);
char *RemoveSpaces (char * buffer);
int   IsOn (char *lpParam);
int   IsOff (char *lpParam);
int   VarTranslate(char *vartext);
int   QuotedStringTranslate (char *buffer);
void  NotQuotedStringTranslate(char *buffer, BOOL remove_dbs);
void  SetLocalEnv(char *buffer);
int   SetEnv (char *lpEnvLine);
char *ConvertPercent (char *buffer);
void  GetShellVersion(char *buffer, int index);

/*
 *  Global Defines
 */
#define IsWhiteSpace(x) ((x==' ')||(x=='\t')||(x=='\n')||(x=='\r')||(x==0))

/*
 *  Global variables.
 */

//
//  The following globals are used for goto processing... this allows us
//  to manipulate the line we're processing outside ProcessLoginScript.
//

LABEL_LIST *pGlobalLabelList;
char *lpGlobalLine;
char *lpGlobalLineSeparator;
int   fGlobalHaveNulledLineSeparator;
int   fGlobalExitFlag;
int   fGlobalIfTooDeep;

int  fBreakOn = TRUE;

int  nCondIndex;
int  aCondVal[MAX_NUM_IF];

int  ARGC;
char **ARGV;
int  nGlobalShiftDelta = 0;
int  fGlobalCompatible = FALSE;
int  fNoDefaultLoginScript = FALSE;

char *LOGIN_NAME;
char *LAST_NAME;
char *LOGIN_CONTEXT;
char *REQUESTER_CONTEXT;
char *COMMON_NAME;
char *TYPED_USER_NAME;
PWCHAR TYPED_USER_NAME_w;
PBYTE NDSTREE;
PBYTE PREFERRED_SERVER;

HANDLE hconout = INVALID_HANDLE_VALUE;

unsigned int CONNECTION_ID;
unsigned int CONNECTION_NUMBER;
unsigned int SCRIPT_ERROR = 0;

#define REQUESTER_VERSION "V1.20"

extern DWORD GUserObjectID;

int IsEmptyFile (char *lpFile)
{
    while (*lpFile != 0)
    {
        if (*lpFile != ' ' &&
            *lpFile != '\t'&&
            *lpFile != '\n'&&
            *lpFile != '\r')
        {
            return(FALSE);
        }
        lpFile++;
    }

    return(TRUE);
}

/*
 *  Login was successful.  Process both Login Scripts: the System Login
 *  Script and the User Login Script.  If there is an EXIT command in the
 *  System Login Script, then we do not process the User Login Script.
 *  If there is no User Login Script, we process a default Login Script,
 *  which is hard-coded internally.  See the Login Script appendix in
 *  the NetWare Installation guide for more info.
 */
void ProcessLoginScripts (unsigned int conn, char *UserName, int argc, char ** argv, char *lpScript)
{
    unsigned int  iRet = 0;
    unsigned long userID ;
    char     pchUserLoginScriptFile[24];

    // Initalize LOGIN_NAME, CONNECTION_ID and CONNECTION_NUMBER.
    ARGC = argc;
    ARGV = argv;
    LOGIN_NAME = UserName;
    CONNECTION_ID = conn;

    // Initialize some 4X variables
    if ( fNDS )
    {
        COMMON_NAME = UserName;

        LOGIN_CONTEXT = malloc ( CONTEXT_MAX );
        if (LOGIN_CONTEXT) {
            strcpy( LOGIN_CONTEXT, REQUESTER_CONTEXT );
        }

        LAST_NAME = malloc( MAXLEN );
        if (LAST_NAME ) {
            NDSGetVar ( "SURNAME", LAST_NAME, MAXLEN );
        }
    }
    else {
        LAST_NAME = UserName;
        COMMON_NAME = UserName;
        LOGIN_CONTEXT = "";
        REQUESTER_CONTEXT = "";
    }

    if (iRet = GetConnectionNumber (conn, &CONNECTION_NUMBER))
    {
        DisplayError (iRet, "GetConnectionNumber");
        return;
    }

    if (lpScript)
    {
        if (!ProcessLoginScriptFile(lpScript))
            DisplayMessage(IDR_NO_SCRIPT_FILE, lpScript);
    }
    else
    {
        if ( fNDS )
        {
            unsigned char Object[128];
            unsigned char ProfileObject[256];
            PBYTE p;
            int err;

            // Browse back from user's node to first occurrence
            // or organizational unit or organization and look for
            // system script there. If the nearest OU or O doesn't have
            // a system script, don't run one.

            for ( p = TYPED_USER_NAME; p ; p = strchr ( p, '.' ) )
            {

                p++;
                             
                if ( *p == 'O' && *(p+1) == 'U' && *(p+2) == '=' )
                    break;

                if ( *p == 'O' && *(p+1) == '=' )
                    break;
            }

            if ( p != NULL )
            {
                ProcessLoginScriptProperty( p );
            }

            // profile login script.

            if ( !NDSGetUserProperty ( "Profile", ProfileObject, 256, NULL, NULL) )
            {
                ConvertUnicodeToAscii( ProfileObject );
                ProcessLoginScriptProperty( ProfileObject );
            }

            // user login script

            if ( (!ProcessLoginScriptProperty( TYPED_USER_NAME )) &&
                 (!fNoDefaultLoginScript) ) 
            {
                ProcessLoginScript (DefaultLoginScript);
            }
        }
        else
        {
            static char SysLoginScriptFile[] = "SYS:PUBLIC/NET$LOG.DAT" ;

            // Process system login script file.
            ProcessLoginScriptFile (SysLoginScriptFile);

            // Check if user login script exists.
            if (iRet = GetBinderyObjectID (conn, UserName, OT_USER,
                       &userID))
                return;

            sprintf(pchUserLoginScriptFile, "SYS:MAIL/%lx/LOGIN", SwapLong(userID));

            if ( (!ProcessLoginScriptFile (pchUserLoginScriptFile)) &&
                 (!fNoDefaultLoginScript) )
            {
                ProcessLoginScript (DefaultLoginScript);
            }
        }
    }
}

int ProcessLoginScriptFile (char *lpLoginScriptFile)
{
    int   nFileSize = 0, bEmpty;
    char *lpLoginScript;

    nFileSize = NWGetFileSize (lpLoginScriptFile);

    if (nFileSize <= 2)
        return(FALSE);

    // system login script exists.
    lpLoginScript = malloc (nFileSize);
    if (lpLoginScript == NULL)
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    LoadFile (lpLoginScriptFile, lpLoginScript, nFileSize);

    bEmpty = IsEmptyFile(lpLoginScript);

    if (!bEmpty)
        ProcessLoginScript (lpLoginScript);

    free (lpLoginScript);

    return(!bEmpty);
}


/*
 * Retrieve and process the Login Script property 
 */
int ProcessLoginScriptProperty ( unsigned char * Object )
{
    unsigned int nFileSize = 0;
    unsigned int Actual = 0;
    unsigned int bEmpty;
    char *lpLoginScript;
    HANDLE Stream;
    int  err;
    unsigned int  i,j;

    if ( NDSfopenStream ( Object, "Login Script", &Stream, &nFileSize ) )
        return(FALSE);

    if ( nFileSize <= 2) 
        return(FALSE);

    // login script exists.
    lpLoginScript = malloc (nFileSize+2);
    if (lpLoginScript == NULL)
    {
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    memset(lpLoginScript, 0, nFileSize+2);

    if ( !ReadFile ( Stream, lpLoginScript, nFileSize, &Actual, NULL ) )
    { 
       bEmpty = TRUE;
    }
    else if ( IsEmptyFile(lpLoginScript) ) 
       bEmpty = TRUE;
    else
       bEmpty = FALSE;

    if (!bEmpty) {
        for ( i = 0, j = 0; i < nFileSize; i++, j++ )
        {
            if (( lpLoginScript[i] == '\r' ) &&
                ( lpLoginScript[i+1] == '\n' ) )
                i++;

            lpLoginScript[j] = lpLoginScript[i];
        }

        while ( j < nFileSize )
        {
            lpLoginScript[j++] = 0;
        }
    }

    CloseHandle( Stream );

    if (!bEmpty)
        ProcessLoginScript (lpLoginScript);

    free (lpLoginScript);

    return(!bEmpty);
}

/*
 *  Return the size of the file.
 */
int NWGetFileSize (char * lpFileName)
{
    int nFileSize = 0;
    FILE * stream;

    do
    {
        if ((stream = fopen (NTNWtoUNCFormat(lpFileName), "r")) == NULL)
            break;

        while (feof (stream) == 0)
        {
            fgetc (stream);
            nFileSize++;
        }

        if (fclose (stream))
            nFileSize = 0;
    }while (FALSE);


    return(nFileSize);
}

/*
 *  Read the file into memory pointed by lpFileBuffer.
 */
void LoadFile (char *lpFileName, char *lpFileBuffer, int nFileSize)
{
    FILE * stream;

    if ((stream = fopen (NTNWtoUNCFormat(lpFileName), "r")) != NULL)
    {
        (void)fread (lpFileBuffer, sizeof (char), nFileSize, stream);
        fclose (stream);
    }

    *(lpFileBuffer+nFileSize-1) = 0;

}

/*
 *  Process Login Script that is in memory pointed by lpLoginScript
 *  line by line.
 */
void ProcessLoginScript (char *lpLoginScript)
{
    nCondIndex = -1;
    fGlobalExitFlag = FALSE;
    fGlobalIfTooDeep = FALSE;

    lpGlobalLine = lpLoginScript;   // we start at the top of the login script

    if (!CreateLabelList (&pGlobalLabelList, lpLoginScript))
    {
        if (pGlobalLabelList != NULL) {

            FreeLabelList (pGlobalLabelList);
            pGlobalLabelList = NULL;
        }
        return;
    }

    while (*lpGlobalLine != 0) {

        //
        //  search for the end of the current line and replace with a null
        //

        if (lpGlobalLineSeparator = strchr(lpGlobalLine, '\n')) {

            //
            //  we may reset this manually in the goto handler, remember so that
            //  we don't trample anything needlessly.
            //

            *lpGlobalLineSeparator = 0;
            fGlobalHaveNulledLineSeparator = TRUE;

        } else {

            fGlobalHaveNulledLineSeparator = FALSE;
        }

        //
        // Now lpGlobalLine points to one line only.
        //

        CommandDispatch (lpGlobalLine);

        if (fGlobalExitFlag)
        {
            if (fGlobalIfTooDeep)
                DisplayMessage(IDR_ORIGINAL_LINE_WAS, lpGlobalLine);
            break;
        }

        if (lpGlobalLineSeparator) {

            if ( fGlobalHaveNulledLineSeparator ) {

                *lpGlobalLineSeparator = '\n';    // recover the changes made.
                fGlobalHaveNulledLineSeparator = FALSE;
            }

            lpGlobalLine = lpGlobalLineSeparator + 1;   // next line please

        } else {

            break;
        }
    }

    if (pGlobalLabelList != NULL) {
        FreeLabelList (pGlobalLabelList);
        pGlobalLabelList = NULL;
    }
}

/*
 *  Scan the login script, put labels in a link list and comment out
 *  those label lines.
 */
int CreateLabelList (PLABEL_LIST *ppLabelList, char *lpLoginScript)
{
    char *lpLine = lpLoginScript, *lpEnd, *lpLabel, *lpTemp;
    int   nLen;
    PLABEL_LIST *ppNext = ppLabelList;

    while (*lpLine != 0)
    {
        if (lpEnd = strchr (lpLine, '\n'))
            *lpEnd = 0;

        // Now lpLine points to one line only.
        lpLabel = RemoveSpaces (lpLine);
        if (isalnum (*lpLabel) || (*lpLabel == '%'))
        {
            lpTemp = lpLabel;
            nLen = 0;
            while (*lpTemp != 0 && *lpTemp != ' ' && *lpTemp != '\t' && *lpTemp != ':')
            {
                if (IsDBCSLeadByte(*lpTemp))
                {
                    lpTemp++;
                    nLen++;
                }

                lpTemp++;
                nLen++;
            }

            lpTemp = RemoveSpaces (lpTemp);
            if (*lpTemp == ':' && EndOfLine (lpTemp+1))
            {
                // The Line is label line.
                if ((*ppNext = malloc (sizeof (LABEL_LIST))) == NULL ||
                    ((*ppNext)->pLabel = malloc (nLen+1)) == NULL)
                {
                    DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }

                SmartCap(lpLabel);
                strncpy ((*ppNext)->pLabel, lpLabel, nLen);
                *((*ppNext)->pLabel+nLen) = 0;
                (*ppNext)->pNextLine = lpEnd? lpEnd+1 : lpEnd;
                (*ppNext)->pNext = NULL;
                ppNext = &((*ppNext)->pNext);

                // Comment out the label line.
                *(lpLine) = ';';
            }
        }

        if (lpEnd)
        {
            *lpEnd = '\n';    // recover the changes made.
            lpLine = lpEnd+1;
        }
        else
            break;
    }

    return(TRUE);
}

/*
 *  Free up the memory allocated for the link list.
 */
void FreeLabelList (LABEL_LIST *pLabelList)
{
    LABEL_LIST *pNext = pLabelList;

    while (pLabelList)
    {
        pNext = pLabelList->pNext;
        free (pLabelList->pLabel);
        free (pLabelList);
        pLabelList = pNext;
    }
}

/*
 *  Dispatch to command hander according to the command.
 */
void CommandDispatch (char *lpCommand)
{
    char buffer[MAXLEN];
    char *restBuffer;
    int  index, fCommandHandled = FALSE;
    int  nTemp = -1;

    // Get rid of leading spaces.
    lpCommand = RemoveSpaces(lpCommand);

    // Don't do anything if it's a comment line or empty line.
    if (*lpCommand == ';' || *lpCommand == '*' || *lpCommand == '\0' ||
        *lpCommand == '\r'|| *lpCommand == '\n')
        return;

    do  // FALSE loop.
    {
        // Make sure the command line is not too long to process.
        if (strlen (lpCommand) > MAXLEN -1) {
            break;
        }

        // Make a copy of the command line to buffer.
        strcpy (buffer, lpCommand);

        // external command line.
        if (*buffer == '#')
        {
            ExternalCmdHandler (buffer);
            return;
        }

        // Get the command index in the command table.
        if ((index = GetTableIndex(buffer, &restBuffer)) == -1)
            break;

        // Dispatch to the corresponding command handler.
        if (nCondIndex > -1 &&
            !aCondVal[nCondIndex] &&
            index != CM_IF   &&
            index != CM_ELSE &&
            index != CM_END  &&
            index != CM_ENDIF)
            fCommandHandled = TRUE;
        else
            fCommandHandled = (*nwCommand[index].commandhandler)(restBuffer);

    } while (FALSE);

    if (!fCommandHandled) {
        BadCommandHandler (lpCommand);
    }
}

/*
 * Used by GetTableIndex().
 * This function should capitalize the entire command string except
 * those in quotes. It should also skip DBCS characters.
 */
void SmartCap(char *ptr)
{
    int inquotes = (*ptr == '\"');
    char *pNext;

    while (*ptr)
    {
        if (!inquotes && !IsDBCSLeadByte(*ptr))
        {
            *ptr = (char) toupper((int)*ptr);
        }

        pNext = NWAnsiNext(ptr);

        if (*pNext == '\"' && *ptr != '\\')
            inquotes = !inquotes;

        ptr = pNext;
    }
}

/*
 * Return the index of the command in the command dispatch table.
 * Return -1 if the command is not found in the command dispatch table.
 */
int GetTableIndex(char *buffer, char **prestBuffer)
{
    int i, nStrLen;

    // Upcase every thing except those in quotes.
    SmartCap (buffer);

    for (i=0; i<NUMCOMMAND; i++)
    {
        if (*(WORD *)nwCommand[i].commandStr0 != *(WORD *)buffer)
            continue;

        nStrLen = strlen (nwCommand[i].commandStr0);

        if (strncmp(nwCommand[i].commandStr0, buffer, nStrLen))
            continue;

        *prestBuffer = buffer + nStrLen;
        *prestBuffer = RemoveSpaces (*prestBuffer);

        if (nwCommand[i].commandStr1)
        {
            nStrLen = strlen (nwCommand[i].commandStr1);

            if (strncmp(nwCommand[i].commandStr1, *prestBuffer, nStrLen))
                continue;

            *prestBuffer += nStrLen;
            *prestBuffer = RemoveSpaces (*prestBuffer);

            if (nwCommand[i].commandStr2)
            {
                nStrLen = strlen (nwCommand[i].commandStr2);

                if (strncmp(nwCommand[i].commandStr2, *prestBuffer, nStrLen))
                    continue;

                *prestBuffer += nStrLen;
                *prestBuffer = RemoveSpaces (*prestBuffer);
            }
        }

        return (i);
    }

    return(-1);
}

/*
 *   Goto label...  We modify the globals controlling what line we're on.
 */
int  GotoHandler  (char *lpParam)
{
    int fLabelFound = FALSE;
    char *lpLabel, *lpEnd, chEnd;
    LABEL_LIST *pLabelList = pGlobalLabelList;

    lpLabel = lpParam;
    lpLabel = RemoveSpaces (lpLabel);

    //
    //  find the end of the label, we'll slam in a null for the search and
    //  restore the char after we're done searching.
    //

    lpEnd = lpLabel;
    while (*lpEnd != 0 &&
           *lpEnd != ' ' &&
           *lpEnd != '\t' &&
           *lpEnd != '\r' &&
           *lpEnd != '\n')
    {
        if (*lpEnd == ':')
            return(FALSE);
        else
            lpEnd = NWAnsiNext(lpEnd);
    }

    chEnd = *lpEnd;
    *lpEnd = 0;

    while (pLabelList)
    {
        if (!_stricmp (pLabelList->pLabel, lpLabel))
        {
            if ( fGlobalHaveNulledLineSeparator )
            {

                *lpGlobalLineSeparator = '\n';    // recover the changes made.
                fGlobalHaveNulledLineSeparator = FALSE;
            }

            lpGlobalLine = pLabelList->pNextLine;

            lpGlobalLineSeparator = lpGlobalLine ? (lpGlobalLine - 1) : NULL;

            fLabelFound = TRUE;
            break;
        }

        pLabelList = pLabelList->pNext;
    }

    if (!fLabelFound)
    {
        DisplayMessage (IDR_LABEL_NOT_FOUND, lpLabel);
        fGlobalExitFlag = TRUE;
    }

    *lpEnd = chEnd;
    return( TRUE );
}

/*
 * Attach [FileServer[/UserName[;Password]]]
 */
int AttachHandler (char *lpParam)
{
    unsigned int iRet = 0;
    int  fCommandHandled = FALSE;
    char serverName[MAX_NAME_LEN] = "";
    char userName[MAX_NAME_LEN] = "";
    char password[MAX_PASSWORD_LEN] = "";
    char *lpSlash, *lpSemiColon, *lpServerName, *lpUserName;
    unsigned int conn;
    int  bAlreadyAttached = FALSE, bReadPassword = TRUE;

    do // FALSE loop.
    {
        NotQuotedStringTranslate (lpParam, TRUE);

        // Make sure that there is at most 1 slash.
        lpSlash = strchr (lpParam, '\\');

        if (lpSlash == NULL)
        {
            lpSlash = strchr (lpParam, '/');
            if (lpSlash != NULL && strchr (lpSlash+1, '/'))
                break;
        }
        else
        {
            if (strchr (lpParam, '/') ||
                strchr (lpSlash+1, '/') ||
                strchr (lpSlash+1, '\\'))
            break;
        }

        // Break the string at slash.
        if (lpSlash)
            *lpSlash = 0;

        // Server name should not contain semicolon.
        if (strchr (lpParam, ';'))
            break;

        lpServerName = strtok (lpParam, __SPACES__);

        if (lpServerName = NULL)
        {
            if (lpSlash)
                break;
        }
        else
        {
            // Make sure that there is only one name in front of the slash.
            if (strtok (NULL, __SPACES__))
                break;

            // Copy the server name to the buffer.
            if (strlen (lpParam) > MAX_NAME_LEN-1)
                break;

            strcpy (serverName, lpParam);

            if (lpSlash)
            {
                lpSemiColon = strchr (lpSlash+1, ';');
                if (lpSemiColon)
                    *lpSemiColon = 0;

                lpUserName = strtok (lpSlash+1, __SPACES__);
                if (lpUserName)
                {
                    if ( strtok (NULL, __SPACES__))
                        break;

                    if (strlen (lpUserName) > MAX_NAME_LEN-1 )
                        break;

                    strcpy (userName, lpUserName);
                }

                if (lpSemiColon)
                {
                    if (strlen (lpSemiColon+1) > MAX_PASSWORD_LEN-1)
                        break;
                    strcpy (password, strtok (lpSemiColon+1, __SPACES__));
                    xstrupr (password);
                    bReadPassword = FALSE;
                }
            }
        }

        fCommandHandled = TRUE;

        if (serverName[0] == 0)
        {
            DisplayMessage(IDR_ENTER_SERVER_NAME);
            if (!ReadName(serverName))
                break;

            DisplayMessage(IDR_ENTER_LOGIN_NAME, serverName);
            if (!ReadName(userName))
                break;
        }
        else if (userName[0] == 0)
            strcpy (userName, LOGIN_NAME);

        if (iRet = CAttachToFileServer(serverName, &conn, &bAlreadyAttached))
        {
            if (!SCRIPT_ERROR)
                SCRIPT_ERROR = iRet;
            break;
        }

        // Do not need this connection
        DetachFromFileServer (conn);

        iRet = Login(userName, serverName, password, bReadPassword);

        // Clear out the password
        memset( password, 0, sizeof( password ) );

        //
        // tommye - MS bug 8194 (MCS 240)
        //
        // If we are already attached to this server, then 
        // pretend we were never here - just let everything 
        // succeed without adding this server to the attach
        // list again.
        //

        if (iRet == ERROR_SESSION_CREDENTIAL_CONFLICT) {
            memset( password, 0, sizeof( password ) );
            continue;
        }

        if (iRet)
        {
            // Ask for user name

            DisplayMessage(IDR_ENTER_LOGIN_NAME, serverName);
            if (!ReadName(userName))
                break;

            if (Login(userName, serverName, password, bReadPassword))
            {
                // Clear out the password
                memset( password, 0, sizeof( password ) );
                break;
            }
        }

        AddServerToAttachList( serverName, LIST_3X_SERVER );

    } while (FALSE);

    return(fCommandHandled);
}

/*
 * BREAK ON, enable ctrl-c, ctrl-break
 * BREAK OFF, disable ctrl-c, ctrl-break
 */
int BreakHandler (char *lpParam)
{
    int fCommandHandled = TRUE;

    if (IsOn(lpParam))
    {
        if (!fBreakOn)
            BreakOn();
    }
    else if (IsOff(lpParam))
    {
        if (fBreakOn)
            BreakOff();
    }
    else
        fCommandHandled = FALSE;

    return(fCommandHandled);
}


/*
 * DISPLAY [pathname]file
 * FDISPLAY [pathname]file
 */
int DisplayHandler (char *lpParam)
{
    FILE * stream;

    NotQuotedStringTranslate (lpParam, TRUE);

    if ((stream = fopen (lpParam, "r")) != NULL)
    {
        while (feof (stream) == 0)
            _fputchar(fgetc (stream));

        fclose (stream);
        DisplayMessage(IDR_NEWLINE);
    }

    return(TRUE);
}

/*
 * DOS BREAK ON,  enable ctrl-break checking for DOS
 * DOS BREAK OFF, disable ctrl-break checking for DOS
 */
int DosBreakHandler (char *lpParam)
{
    int fCommandHandled = TRUE;

    if (IsOn (lpParam))
        system ("BREAK ON");
    else if(IsOff (lpParam))
        system ("BREAK OFF");
    else
        fCommandHandled = FALSE;

    return(fCommandHandled);
}

/*
 * Used by SetHandler() and LocalSetHandler()
 * Return TRUE if lpParam points to name = "value", and set
 * lpParam to "name=value" on return.
 * Return FALSE otherwise.
 */
int VerifySetFormat (char *lpParam)
{
    int fCorrect = FALSE;
    char buffer[MAXLEN];
    char *lpBuffer = buffer;

    strcpy (buffer, lpParam);

    do
    {
        while (*lpBuffer != 0 && *lpBuffer != '=' && *lpBuffer != ' ' && *lpBuffer != '\t')
            lpBuffer = NWAnsiNext(lpBuffer);

        lpParam[lpBuffer-buffer]=0;
        strcat (lpParam, "=");

        if (*lpBuffer != '=')
            lpBuffer = RemoveSpaces (lpBuffer);

        if (*lpBuffer != '=')
            break;

        lpBuffer = RemoveSpaces (lpBuffer+1);

        if (*lpBuffer)
        {
            if (!QuotedStringTranslate (lpBuffer))
                break;

            strcat (lpParam, lpBuffer);
        }

        fCorrect = TRUE;
    }while (FALSE);

    return(fCorrect);
}

/*
 * Used by SetHandler() and LocalSetHandler()
 * Set the local environment variable.
 * Don't free the memory allocated because the environment variable will
 * point to free space otherwise.
 */
void SetLocalEnv(char *buffer)
{
    char *lpEnvString;
    lpEnvString = malloc(strlen (buffer) + 1);

    if (lpEnvString == NULL)
        DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
    else
    {
        strcpy (lpEnvString, buffer);
        _putenv (lpEnvString);
    }
}

/*
 * Set Dos environment variable.
 * [DOS] SET name = "value"
 */
int SetHandler (char *lpParam)
{

    int fCommandHandled;

    fCommandHandled = VerifySetFormat(lpParam);

    if (fCommandHandled)
    {

        if ( _strnicmp( "COMSPEC=", lpParam, strlen( "COMSPEC=" ) ) )
        {
            SetLocalEnv(lpParam);
            SetEnv (lpParam);
        }
    }

    return(fCommandHandled);
}

/*
 * Set local Dos environment variable.
 * [OPTION] [DOS] SET name = "value"
 */
int LocalSetHandler (char *lpParam)
{
    int fCommandHandled;

    fCommandHandled = VerifySetFormat(lpParam);

    if (fCommandHandled)
        if ( _strnicmp( "COMSPEC=", lpParam, strlen( "COMSPEC=" ) ) )
        {
            SetLocalEnv (lpParam);
        }

    return(fCommandHandled);
}

/*
 *  Used by DosVerifyHandler().
 *  Turn /V option of copy on.
 */
void DosVerifyOn(void)
{
}

/*
 *  Used by DosVerifyHandler().
 *  Turn /V option of copy off.
 */
void DosVerifyOff(void)
{
}

/*
 *  DOS VERYFY [ON|OFF], Turn /V option of copy on or off.
 */
int DosVerifyHandler (char *lpParam)
{
    int fCommandHandled = TRUE;

    if (IsOn(lpParam))
        DosVerifyOn();
    else if (IsOff(lpParam))
        DosVerifyOff();
    else
        fCommandHandled = FALSE;

    return(fCommandHandled);
}

/*
 *  DRIVE [driveletter: | n*:], set the default drive to the one specified.
 */
int DriveHandler (char *lpParam)
{
    int fCommandHandled = FALSE;
    WORD driveNum=0, n;
    char *pColon;

    do  // FALSE loop.
    {
        if ((pColon = strchr (lpParam, ':')) == NULL ||
            !EndOfLine (pColon + 1))
            break;

        if (*lpParam == '*')
        {
            *pColon = 0;
            if ((n = (USHORT) atoi (lpParam+1)) < 1)
                break;

            GetFirstDrive (&driveNum);
            driveNum += (n-1);
        }
        else if (pColon == lpParam+1 && isupper(*lpParam))
            driveNum = *lpParam - 'A' + 1;
        else
            break;

        if (_chdrive (driveNum))
            DisplayMessage(IDR_ERROR_SET_DEFAULT_DRIVE, 'A'+driveNum-1);
        else
            ExportCurrentDrive( driveNum );

        fCommandHandled = TRUE;

    } while (FALSE);

    return(fCommandHandled);
}

/*
 * Used by FireHandler()
 * Return TRUE if lpTemp points to the legal end of fire statement, ie
 * [TIMES][COMMENTS]. It also set the *lpTemp to 0 if lpTemp is not NULL.
 * Return FALSE otherwise.
 */
int IsEndOfFireCmd (char *lpTemp)
{
    int fEnd = FALSE;
    do
    {
        if (*lpTemp != 0)
        {
            if (*lpTemp != ' ' && *lpTemp != '\t' && *lpTemp != '\r')
                break;

            *lpTemp = 0;

            lpTemp = RemoveSpaces (lpTemp+1);

            if (!strncmp (lpTemp, "TIMES", 5))
                lpTemp += 5;

            if (!EndOfLine (lpTemp))
                break;
        }

        fEnd = TRUE;
    }while (FALSE);

    return(fEnd);
}

/*
 *  [FIRE | FIRE PHASERS] n TIMES.
 */
int FireHandler (char *lpParam)
{
    char *lpTemp, vartext[MAXLEN];
    int n = 0, nLen;
    time_t ltimeStart, ltimeEnd;

    if (EndOfLine (lpParam))
        n = 1;
    else if (isdigit(*lpParam))
    {
        lpTemp = lpParam;
        while (isdigit(*lpTemp))
            lpTemp++;

        if (IsEndOfFireCmd (lpTemp))
            n = atoi (lpParam);
    }
    else if (*lpParam == '%')
    {
        strcpy (vartext, lpParam+1);
        if (((nLen = VarTranslate (lpParam)) != 0) &&
            EndOfLine (lpParam+1+nLen))
            n = atoi (vartext);
    }

    if (n < 0)
        return(FALSE);
    else if (n == 0)  // Compatible with NetWare.
        n = 1;

    while (n--)
    {
        _beep( 610, 100 );
        _beep( 440, 50 );
        time(&ltimeStart);
        do
        {
            time(&ltimeEnd);
        }while (ltimeEnd-ltimeStart == 0);
    }

    return(TRUE);
}

/*
 * EXIT, terminate login script processing.
 */
int ExitHandler (char *lpParam)
{
    int  n;
    char buffer[16], *argv[10];

    // --- Multi user code merge. Citrix bug fixes ---
    // 11/18/96 cjc (Citrix)  Fix DrWatson for EXIT "" command.
    if (!lpParam || !strcmp(lpParam, "\"\"") ){
        CleanupExit(0);
    }

    if (EndOfLine (lpParam)) {
        CleanupExit(0);
        return(TRUE);
    }
    else if (QuotedStringTranslate (lpParam))
    {
        if (!fGlobalCompatible)
        {
            GetShellVersion (buffer, IDS_MACHINE);
            if (_stricmp (buffer, "IBM_PC"))
            {
                DisplayMessage(IDR_EXIT_NOT_SUPPORTED);
                return(TRUE);
            }
        }

        argv[0] = strtok (lpParam, __SPACES__);

        for (n = 1; n < 9; n++)
        {
            if ((argv[n] = strtok (NULL, __SPACES__)) == NULL)
                break;
        }

        argv[9] = NULL;

        if ((SCRIPT_ERROR = (int) _spawnvp (P_WAIT, argv[0], argv)) == -1)
            DisplayMessage(IDR_BAD_COMMAND);

        CleanupExit (0);
        return(TRUE);
    }
    else
        return(FALSE);
}

BOOL    nwVarNameCompare(LPCSTR src,LPCSTR target)
{
    CHAR    szTempName[64];
    LPSTR   pT = szTempName;

    if (!_strnicmp(src,target,strlen(target))) {

        //
        // try to reject obvious problems like
        // %LJUNK where %L would be fine
        //
        if ( !isalpha(src[strlen(target)]) 
             || IsDBCSLeadByte(src[strlen(target)])
           )

            return 0;

        else 
            return 1;

    }

    strcpy(szTempName,target);

    while (*pT) {
        if (!IsDBCSLeadByte(*pT)) {
            if ('_' == *pT)
                *pT = ' ';
        }
        pT = NWAnsiNext(pT);
    }

    if (!_strnicmp(src,szTempName,strlen(szTempName))) {

        //
        // try to reject obvious problems like
        // %LJUNK where %L would be fine
        //
        if ( !isalpha(src[strlen(target)]) 
            || IsDBCSLeadByte(src[strlen(target)])
           )

            return 0;

        else 
            return 1;

    }

    return 1;
}


/*
 *  Used by the EvalSingleCond() in IfHandler()
 *  Return TRUE if buffer is the right member of condition statement.
 *  *pfCondition is TRUE if the condition meet, FALSE if not.
 *  *ppRest points to the end of the condition statement.
 *  Return FALSE if buffer is not the right member of condition statement.
 */
int MemberOf (char *buffer, int *pfCondition, char **ppRest)
{
    int i, nChar, fSucceed = FALSE;
    char *lpTemp;
    BYTE dataBuffer[128];
    unsigned char moreFlag;
    unsigned char propertyType;
    unsigned long dwObjectId, *pdwGroups;
    char GroupName[MAXLEN];
    unsigned char segment;

    *pfCondition = FALSE;
    do
    {
        if ((buffer = strchr (buffer, '\"')) == NULL)
            break;

        if ((lpTemp = strchr (buffer+1, '\"')) == NULL)
            break;

        nChar = (int) (lpTemp - buffer + 1);

        if (nChar >= MAXLEN)
            break;

        strncpy (GroupName, buffer, nChar);
        GroupName[nChar] = 0;
        if (!QuotedStringTranslate (GroupName))
            break;

        fSucceed = TRUE;
        *pfCondition = FALSE;
        *ppRest = RemoveSpaces (lpTemp+1);

        if (strlen(GroupName) > MAX_NAME_LEN)
            break;

        if ( fNDS )
        {
            if ( IsMemberOfNDSGroup( GroupName ) )
            {
                *pfCondition = TRUE;
                return(TRUE);
            }

        }
        else 
        {
            if (GetBinderyObjectID (CONNECTION_ID,
                                    _strupr(GroupName),
                                    OT_USER_GROUP,
                                    &dwObjectId) )
                goto done;

            //
            // For all the group ID's, try and find a match
            //
            for ( segment = 1, moreFlag = TRUE; moreFlag && segment; segment++ )
            {
                if ( NWReadPropertyValue ((NWCONN_HANDLE)CONNECTION_ID,
                                         LOGIN_NAME,
                                         OT_USER,
                                         "GROUPS_I'M_IN",
                                         segment,
                                         dataBuffer,
                                         &moreFlag,
                                         &propertyType)) 
                    goto done;

                pdwGroups = (unsigned long *) dataBuffer;

                for (i = 0; i < 32 && *(pdwGroups+i); i++)
                {
                    if (*(pdwGroups+i) == dwObjectId)
                    {
                        *pfCondition = TRUE;
                        return(TRUE);
                    }
                }
            }
        }

        *pfCondition = FALSE;
        fSucceed = TRUE;
    } while (FALSE);

done:

    return(fSucceed);
}

/*
 * Used by IsCompare() in EvalSingleCond() in IfHandler()
 * Return the next token.
 */
char *GetNextPart (char *lpTemp)
{
    INT i;

    if (strncmp (lpTemp, "VALUE", 5) == 0)
        lpTemp = RemoveSpaces (lpTemp+5);

    if (*lpTemp == '\"')
    {
        lpTemp++;
        while (*lpTemp != 0 && *lpTemp != '\"')
            lpTemp = NWAnsiNext(lpTemp);

        if (*lpTemp == 0)
            return(NULL);
        else
            lpTemp++;
    }
    else if (*lpTemp == '<')
    {
        while (*lpTemp != 0 && *lpTemp != '>')
            lpTemp = NWAnsiNext(lpTemp);

        if (*lpTemp == 0)
            return(NULL);
        else
            lpTemp++;
    }
    else
    {
        if (*lpTemp == '%')
            lpTemp++;

        for (i = 0; i < (fNDS ? NUMVAR : NUMVAR_3X); i++)
        {
            if (!nwVarNameCompare(lpTemp, varTable[i].VarName))
            {
                lpTemp += strlen(varTable[i].VarName);
                break;
            }
        }

        if (i == (fNDS ? NUMVAR : NUMVAR_3X))
            return(NULL);
    }

    return(lpTemp);
}

/*
 * Used by EvalSingleCond() in IfHandler()
 * left part of buffer could be "...", <...>, or ... for variables.
 * Return TRUE if buffer consists of <left> <compare operator> <right part> +
 * optional rest parts.
 * Return FALSE otherwise.
 */
int IsCompare (char *buffer, char **ppright,
               int *pnLeftLen, int *pnRightLen,
               int *pindex, char **ppRest)
{
    int i, nLen;
    char *lpTemp;

    if ((lpTemp = GetNextPart (buffer)) == NULL)
        return (FALSE);

    *pnLeftLen = (int) (lpTemp-buffer);
    lpTemp = RemoveSpaces (lpTemp);

    for (i = 0; COMPARE_OPERATORS[i][0]; i++)
    {
        nLen = strlen (COMPARE_OPERATORS[i]);

        if (!strncmp(lpTemp, COMPARE_OPERATORS[i], nLen))
        {
            *lpTemp = 0;
            lpTemp += nLen;
            *ppright = RemoveSpaces (lpTemp);
            *pindex = i;
            *ppRest = GetNextPart (*ppright);
            if ( *ppRest == NULL )
                return (FALSE);
            *pnRightLen = (int) (*ppRest - *ppright);
            *ppRest = RemoveSpaces (*ppRest);
            return(TRUE);
        }
    }

    return(FALSE);
}

/*
 *  Used by EvalSingleCond() in IfHandler()
 *  Evaluate lpLeft and lpRight and do the compare operation of index
 *  and put the result in *pfCondition.
 *  Return TRUE if succeed, FALSE otherwise.
 */
int Compare (char *lpLeft, char *lpRight,
             int nLeftLen, int nRightLen,
             int index, int *pfCondition)
{
    char szLeft[MAXLEN], szRight[MAXLEN], *lpTemp;
    int  nCompare, fValue = FALSE;

    if (strncmp (lpLeft, "VALUE", 5) == 0)
    {
        fValue = TRUE;
        lpTemp = RemoveSpaces (lpLeft+5);
        nLeftLen -= (int) (lpTemp - lpLeft);
        lpLeft = lpTemp;
    }
    if (strncmp (lpRight, "VALUE", 5) == 0)
    {
        fValue = TRUE;
        lpTemp = RemoveSpaces (lpRight+5);
        nRightLen -= (int) (lpTemp - lpRight);
        lpRight = lpTemp;
    }

    strncpy (szLeft, lpLeft, nLeftLen);
    strncpy (szRight, lpRight, nRightLen);

    szLeft[nLeftLen] = 0;
    szRight[nRightLen] = 0;

    if (!QuotedStringTranslate (szLeft) ||
        !QuotedStringTranslate (szRight))
        return(FALSE);

    if (fValue)
        nCompare = atoi(szLeft)-atoi(szRight);
    else
        nCompare = _stricmp (szLeft, szRight);

    if (IsNotEqual(index))
        *pfCondition = (nCompare != 0);
    else if (IsGreaterOrEqual(index))
        *pfCondition = (nCompare >= 0);
    else if (IsGreater(index))
        *pfCondition = (nCompare > 0);
    else if (IsLessOrEqual(index))
        *pfCondition =  (nCompare <= 0);
    else if (IsLess(index))
        *pfCondition = (nCompare < 0);
    else
        *pfCondition = (nCompare == 0);

    return(TRUE);
}

int IsMemberOf (char *buffer)
{
    int fIsMemberOf = FALSE;

    if (!strncmp (buffer, "MEMBER", 6))
    {
        buffer += 6;
        if (*buffer == ' ' || *buffer == '\t')
        {
            buffer = RemoveSpaces (buffer);
            if (!strncmp (buffer, "OF", 2))
            {
                buffer += 2;
                if (*buffer == ' ' || *buffer == '\t')
                    buffer = RemoveSpaces (buffer);
            }
        }

        fIsMemberOf = (*buffer == '"');
    }

    return(fIsMemberOf);
}

int NotMemberOf (char *buffer)
{
    int fNotMemberOf = FALSE;
    if (!strncmp (buffer, "NOT", 3))
    {
        buffer += 3;
        if (*buffer == ' ' || *buffer == '\t')
        {
            buffer = RemoveSpaces (buffer);
            fNotMemberOf = IsMemberOf (buffer);
        }
    }

    return(fNotMemberOf);
}


/*
 *  Used by IfHandler()
 *  Evaluate one condition clause and put result in *pfCondition, *ppRest
 *  points to the rest part of buffer.
 *  Return TRUE if succeed, FALSE otherwise.
 */
int EvalSingleCond (char *buffer, int *pfCondition)
{
    int index, fSuccess = FALSE, nLeftLen, nRightLen;
    char *pright, *pRest;

    if (IsMemberOf(buffer))
        fSuccess = MemberOf (buffer, pfCondition, &pRest);
    else if (NotMemberOf (buffer))
    {
        fSuccess = MemberOf (buffer, pfCondition, &pRest);
        *pfCondition = !(*pfCondition);
    }
    else if (IsCompare (buffer, &pright, &nLeftLen, &nRightLen, &index, &pRest))
        fSuccess = Compare (buffer, pright, nLeftLen, nRightLen, index, pfCondition);
    else if ( !_strnicmp ("ACCESS_SERVER", buffer, strlen("ACCESS_SERVER")) )
    {
        fSuccess = TRUE;
        *pfCondition = FALSE;
        pRest = buffer + strlen ("ACCESS_SERVER"); 
    }

    if (fSuccess)
        memmove (buffer, pRest, strlen (pRest)+1);
    
    return(fSuccess);
}

int EvaluateCondExpression(char *lpCondExpression, int *pfCondition)
{
    int fSuccess = FALSE, fCond;
    char *lpRight, *lpLeft, *lpOp;

    if (lpRight = strchr (lpCondExpression, ')'))
    {
        *lpRight = 0;
        if ((lpLeft = strrchr (lpCondExpression, '(')) == NULL ||
            !EvaluateCondExpression(lpLeft+1, pfCondition))
            return(FALSE);

        *lpLeft = (*pfCondition)? '1' : '0';
        memmove (lpLeft+1, lpRight+1, strlen (lpRight+1)+1);
        return(EvaluateCondExpression (lpCondExpression, pfCondition));
    }

    if (lpOp = strrchr (lpCondExpression, '+'))
    {
        *lpOp = 0;

        if (!EvaluateCondExpression (lpCondExpression, pfCondition) ||
            !EvaluateCondExpression (lpOp+1, &fCond))
            return(FALSE);

        *pfCondition = (*pfCondition || fCond);
        return(TRUE);
    }

    if (lpOp = strrchr (lpCondExpression, '*'))
    {
        *lpOp = 0;

        if (!EvaluateCondExpression (lpCondExpression, pfCondition) ||
            !EvaluateCondExpression (lpOp+1, &fCond))
            return(FALSE);

        *pfCondition = (*pfCondition && fCond);
        return(TRUE);
    }

    if (lpOp = strrchr (lpCondExpression, '^'))
    {
        *lpOp = 0;

        if (!EvaluateCondExpression (lpCondExpression, pfCondition) ||
            !EvaluateCondExpression (lpOp+1, &fCond))
            return(FALSE);

        *pfCondition = !(*pfCondition && fCond);
        return(TRUE);
    }

    if (!strcmp (lpCondExpression, "1"))
    {
        *pfCondition = TRUE;
        return(TRUE);
    }
    else if (!strcmp (lpCondExpression, "0"))
    {
        *pfCondition = FALSE;
        return(TRUE);
    }
    else
        return(FALSE);
}

/*
 *  Used by IfHandler()
 *  Evaluate up to 10 conditions.
 *  Return TRUE if succeed, FALSE otherwise.
 *  On return, buffer stores whatever after conditional expressions
 *  without leading spaces.
 */
int EvaluateCond(char *buffer, int *pfCondition)
{
    int fCondition = TRUE, fCurrent, fSucceed = FALSE, nCount;
    char CondExpression[MAXLEN], *lpCond = CondExpression, *lpBuffer = buffer;

    for (nCount = 0; nCount < 10; nCount++)
    {
        while (*lpBuffer == '(')
        {
            *lpCond = *lpBuffer;
            lpCond++;
            lpBuffer++;
        }

        lpBuffer = RemoveSpaces (lpBuffer);

        if (!EvalSingleCond (lpBuffer, &fCurrent))
            break;

        *lpCond = fCurrent? '1' : '0';
        lpCond++;

        while (*lpBuffer == ')')
        {
            *lpCond = *lpBuffer;
            lpCond++;
            lpBuffer++;
        }

        lpBuffer = RemoveSpaces (lpBuffer);

        if (*lpBuffer == ',')
        {
            *lpCond = '*';
            lpCond++;

            lpBuffer = RemoveSpaces (lpBuffer+1);

            if (!strncmp (lpBuffer, "AND", 3))
                lpBuffer = RemoveSpaces (lpBuffer+3);
        }
        else if (!strncmp (lpBuffer, "AND", 3))
        {
            *lpCond = '*';
            lpCond++;
            lpBuffer = RemoveSpaces (lpBuffer+3);
        }
        else if (!strncmp (lpBuffer, "&&", 2))
        {
            *lpCond = '*';
            lpCond++;
            lpBuffer = RemoveSpaces (lpBuffer+2);
        }
        else if ( (!strncmp (lpBuffer, "OR", 2)) ||
                  (!strncmp (lpBuffer, "||", 2)) )
        {
            *lpCond = '+';
            lpCond++;
            lpBuffer = RemoveSpaces (lpBuffer+2);
        }
        /*
         * A NOR expression is documented in some books, but isn't
         * implemented in the 4X login.exe I have.
         */
        else if (!strncmp (lpBuffer, "NOR", 3))
        {
            *lpCond = '^';
            lpCond++;
            lpBuffer = RemoveSpaces (lpBuffer+3);
        }
        else
        {
            fSucceed = TRUE;
            *lpCond = 0;
            lpBuffer = RemoveSpaces (lpBuffer);
            memmove (buffer, lpBuffer, strlen (lpBuffer)+1);
            break;
        }
    }

    if (fSucceed)
        fSucceed = EvaluateCondExpression (CondExpression, pfCondition);

    return(fSucceed);
}

/*
 *  If statement handler.
 */
int IfHandler (char *lpParam)
{
    int fCommandHandled = FALSE, fCondition;

    do
    {
        if (nCondIndex+1 == MAX_NUM_IF)
        {
            DisplayMessage(IDR_IF_TOO_DEEP);
            fGlobalExitFlag = TRUE;
            fGlobalIfTooDeep = TRUE;
            return TRUE;
        }

        if (EndOfLine (lpParam))
            break;

        if (!EvaluateCond (lpParam, &fCondition))
            break;

        if (!strncmp (lpParam, "THEN", 4))
        {
            lpParam = RemoveSpaces (lpParam+4);

            if (!strncmp (lpParam, "BEGIN", 5))
            {
                lpParam += 5;

                if (!EndOfLine (lpParam))
                    break;
            }
            else if((!strncmp (lpParam, "DO", 2)) &&
                    (strncmp (lpParam, "DOS", 3)))
            {
                lpParam += 2;
                if (!EndOfLine (lpParam))
                    break;
            }
        }
        else if (!strncmp (lpParam, "BEGIN", 5))
        {
            lpParam += 5;

            if (!EndOfLine (lpParam))
                break;
        }

        if (EndOfLine (lpParam))
        {
            nCondIndex++;
            aCondVal[nCondIndex] =
                (nCondIndex > 0 && !aCondVal[nCondIndex-1])?
                FALSE : fCondition;
        }
        else
        {
            if (fCondition && (nCondIndex == -1 || aCondVal[nCondIndex]))
                CommandDispatch (lpParam);
        }

        fCommandHandled = TRUE;

    }while (FALSE);

    return(fCommandHandled);
}

/*
 *  Else statement handler.
 */
int ElseHandler (char *lpParam)
{
    int fCommandHandled = FALSE;

    if (EndOfLine (lpParam))
    {
        if (nCondIndex == 0 ||
            nCondIndex > 0 && aCondVal[nCondIndex-1])
            aCondVal[nCondIndex] = !aCondVal[nCondIndex];

        fCommandHandled = TRUE;
    }

    return(fCommandHandled);
}

/*
 *  End statement handler.
 */
int EndHandler (char *lpParam)
{
    int fCommandHandled = FALSE;

    if (EndOfLine (lpParam))
    {
        if (nCondIndex > -1)
            nCondIndex--;

        fCommandHandled = TRUE;
    }

    return(fCommandHandled);
}

/*
 *  INCLUDE [pathname]filename
 */
int IncludeHandler (char *lpParam)
{
    int fCommandHandled = FALSE, nFileSize;
    char *lpLoginScript, *lpTemp;
    int  i, nCondIndexCopy;
    int  aCondValCopy[MAX_NUM_IF];
    int iRet;

    //
    //  Save off the old globals that track where we are.
    //

    LABEL_LIST *pLabelList = pGlobalLabelList;
    char *lpLine = lpGlobalLine;
    char *lpLineSeparator = lpGlobalLineSeparator;
    int  fHaveNulledLineSeparator = fGlobalHaveNulledLineSeparator;

    pGlobalLabelList = NULL;        // so that we don't free it.

    do
    {
        if (strtok (lpParam, __SPACES__) == NULL)
            break;

        lpTemp = strtok(NULL, __SPACES__);
        if (lpTemp && !EndOfLine (lpTemp))
            break;

        fCommandHandled = TRUE;

        // 8/6/96 cjc (Citrix merge) Fix problem with UNC names causing errors.
        NotQuotedStringTranslate(lpParam, FALSE);
//        NotQuotedStringTranslate(lpParam, TRUE);

        nCondIndexCopy = nCondIndex;
        for (i = 0; i < MAX_NUM_IF; i++)
            aCondValCopy[i] = aCondVal[i];

        /*
         * First we try a NDS object and then a file
         */
        iRet = FALSE;
        if ( fNDS ) 
        {
            iRet = ProcessLoginScriptProperty( lpParam );
            if ( !iRet )
            {
                char Fixup[MAXLEN];
                char * ptr;
                /*
                 * Strip off the . in front and add context at end
                 */
                ptr = RemoveSpaces (lpParam);
                if ( *ptr == '.' ) {
                    ptr++;
                    strncpy( Fixup, ptr, MAXLEN );
                }
                else {
                    strncpy( Fixup, ptr, MAXLEN );
                    if ( Fixup[strlen(Fixup)-1] != '.' )
                        strcat( Fixup, "." );
                    strcat( Fixup, LOGIN_CONTEXT );
                }
                iRet = ProcessLoginScriptProperty( Fixup );
            }
        }

        if ( !fNDS || !iRet )
        {
            nFileSize = NWGetFileSize (lpParam);
            if (nFileSize == 0)
            {
                DisplayMessage(IDR_ERROR_OPEN_SCRIPT, lpParam);
                break;
            }

            // user login script exists.
            lpLoginScript = malloc (nFileSize);
            if (lpLoginScript == NULL)
            {
                DisplayMessage(IDR_NOT_ENOUGH_MEMORY);
                break;
            }

            LoadFile (lpParam, lpLoginScript, nFileSize);

            // dfergus 19 Apr 2001 - 192395
            // check lpLoginScript for contents
            //
            if( lpLoginScript[0] )
                ProcessLoginScript (lpLoginScript);

            free (lpLoginScript);
        }

        fGlobalExitFlag = FALSE;

        nCondIndex = nCondIndexCopy;
        for (i = 0; i < MAX_NUM_IF; i++)
            aCondVal[i] = aCondValCopy[i];

    }while (FALSE);

    //
    //  restore the globals that track where we are in the file.
    //

    pGlobalLabelList = pLabelList;
    lpGlobalLine = lpLine;
    lpGlobalLineSeparator = lpLineSeparator;
    fGlobalHaveNulledLineSeparator = fHaveNulledLineSeparator;


    return(fCommandHandled);
}

/*
 *  Map command handler.
 */
int MapHandler (char *lpParam)
{
    char buffer[MAXLEN]="";

    strcpy( buffer, lpParam );

    NotQuotedStringTranslate( buffer, TRUE );

    Map( buffer );

    return(TRUE);
}

/*
 *  PAUSE or WAIT.
 */
int PauseHandler (char *lpParam)
{
    int fCommandHandled = FALSE;

    if (EndOfLine (lpParam))
    {
        //Empty kb buffer first.
        while (_kbhit())
            _getch();

        DisplayMessage(IDR_STRIKE_KEY);
        _getch();
        DisplayMessage(IDR_NEWLINE);
        fCommandHandled = TRUE;
    }

    return(fCommandHandled);
}

/*
 * Used by WriteHandler().
 * Return TRUE if buffer ends with ';'. Set it to 0
 * Return FALSE otherwise.
 */
int EndWithSemicolon (char *buffer)
{
    char *lpLastSemicolon, *lpRest;
    lpLastSemicolon = strrchr (buffer, ';');
    if (lpLastSemicolon)
    {
        lpRest = RemoveSpaces (lpLastSemicolon+1);
        if (*lpRest == 0)
        {
            *lpLastSemicolon = 0;
            return(TRUE);
        }
    }

    return(FALSE);
}

char *ConvertPercent (char *buffer)
{
    char *lpPercent, *lpBuffer = buffer;
    int   nPercent = 0;

    while (lpPercent = strchr (lpBuffer, '%'))
    {
        nPercent++;
        lpBuffer = lpPercent+1;
    }

    if (nPercent == 0)
        return(NULL);

    lpBuffer = malloc (strlen(buffer)+nPercent+1);
    if (lpBuffer == NULL)
        return(NULL);

    strcpy (lpBuffer, buffer);

    lpPercent = strchr (lpBuffer, '%');

    while (lpPercent)
    {
        memmove (lpPercent+1, lpPercent, strlen (lpPercent)+1);
        lpPercent = strchr ( lpPercent+2, '%');
    }

    return(lpBuffer);
}

/*
 *  WRITE text, display a text message on the screen.
 */
int WriteHandler (char *lpParam)
{
    int fNewLine;
    char *lpBuffer;

    if (*lpParam == 0)
    {
        DisplayMessage(IDR_NEWLINE);
        return(TRUE);
    }

    fNewLine = !EndWithSemicolon (lpParam);

    if (!QuotedStringTranslate (lpParam))
        return FALSE;

    lpBuffer = ConvertPercent (lpParam);
    if (lpBuffer == NULL)
    {
        DisplayOemString(lpParam);
    }
    else
    {
        DisplayOemString(lpBuffer);
        free (lpBuffer);
    }

    if (fNewLine)
        DisplayMessage(IDR_NEWLINE);

    return(TRUE);
}

/*
 * Used by ShiftHandler().
 * Return TURE if the line is all numbers + [comments]
 * Return FALSE otherwise.
 */
int AreAllNumbers(char *buffer)
{
    while (isdigit(*buffer))
        buffer++;

    return(EndOfLine (buffer));
}

/*
 *  Set the nGlobalShiftDelta variable.
 */
int ShiftHandler (char *lpParam)
{
    int fCommandHandled = TRUE;

    if (EndOfLine (lpParam))
        nGlobalShiftDelta++;
    else if (*lpParam == '-')
    {
        lpParam = RemoveSpaces (lpParam+1);
        if (!AreAllNumbers(lpParam))
            fCommandHandled = FALSE;
        else
            nGlobalShiftDelta -= atoi (lpParam);
    }
    else
    {
        if (*lpParam == '+')
            lpParam = RemoveSpaces (lpParam+1);

        if (!AreAllNumbers(lpParam))
            fCommandHandled = FALSE;
        else
            nGlobalShiftDelta += atoi (lpParam);
    }

    return(fCommandHandled);
}

/*
 *  Set the machine name.
 */
int MachineHandler   (char *lpParam)
{
    int nLen, i;

    if (*lpParam != '=')
        return(FALSE);

    lpParam = RemoveSpaces (lpParam+1);
    if (!QuotedStringTranslate(lpParam))
        return(FALSE);

    nLen = strlen (lpParam);
    for (i = nLen; i < 15; i++)
        *(lpParam+i) = ' ';

    *(lpParam+15) = 0;

    return(TRUE);
}

/*
 *  Set the fGlobalCompatible variable.
 */
int CompatibleHandler(char *lpParam)
{
    if (!EndOfLine (lpParam))
        return(FALSE);

    fGlobalCompatible = TRUE;
    return(TRUE);
}

/*
 *  Clear the screen
 */
int ClearHandler(char *lpParam)
{
    CONSOLE_SCREEN_BUFFER_INFO coninfo;
    COORD scrolltarget;
    CHAR_INFO chinfo;
    SMALL_RECT scrollrect;

    if ( hconout == INVALID_HANDLE_VALUE )
    {
        hconout = CreateFile( L"CONOUT$", GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                              OPEN_EXISTING, 0, NULL );
    }

    if ( hconout == INVALID_HANDLE_VALUE )
        return TRUE;

    GetConsoleScreenBufferInfo( hconout, &coninfo );

    scrolltarget.Y = (SHORT)(0 - coninfo.dwSize.Y);
    scrolltarget.X = 0;

    scrollrect.Top = 0;
    scrollrect.Left = 0;
    scrollrect.Bottom = coninfo.dwSize.Y;
    scrollrect.Right =  coninfo.dwSize.X;
    chinfo.Char.AsciiChar = ' ';
    chinfo.Attributes = coninfo.wAttributes;
    ScrollConsoleScreenBufferA( hconout, &scrollrect, NULL,
                               scrolltarget, &chinfo);

    coninfo.dwCursorPosition.X = 0;
    coninfo.dwCursorPosition.Y = 0;

    SetConsoleCursorPosition( hconout, coninfo.dwCursorPosition );
    return(TRUE);
}

/*
 *  Display the Last Login Time 
 */

int LastLoginTimeHandler(char *lpParam)
{
    BYTE dataBuffer[128];
    unsigned char moreFlag;
    unsigned char propertyType;

    if ( fNDS )
    {
        nwShowLastLoginTime();
    }
    else
    {
        SYSTEMTIME st;
        WCHAR DateBuffer[TIMEDATE_SIZE];
        WCHAR TimeBuffer[TIMEDATE_SIZE];

        NWReadPropertyValue ((NWCONN_HANDLE)CONNECTION_ID,
                             LOGIN_NAME,
                             OT_USER,
                             "MISC_LOGIN_INFO",
                             1,
                             dataBuffer,
                             &moreFlag,
                             &propertyType);

        /**
            Get the data into SYSTEMTIME format:
                0 = year
                1 = month
                2 = day
                3 = hour
                4 = minute
                5 = second
                6 = day of week
        **/

        memset(&st, 0, sizeof(SYSTEMTIME));
        st.wYear        = dataBuffer[0];
        st.wMonth       = dataBuffer[1];
        st.wDay         = dataBuffer[2];
        st.wHour        = dataBuffer[3];
        st.wMinute      = dataBuffer[4];
        st.wSecond      = dataBuffer[5];
        st.wDayOfWeek   = dataBuffer[6];

        /** Get the info based on the local settings **/

        GetDateFormat(
                    LOCALE_USER_DEFAULT,
                    DATE_LONGDATE,
                    &st,
                    NULL,
                    TimeBuffer,
                    TIMEDATE_SIZE);

        GetTimeFormat(
                    LOCALE_USER_DEFAULT,
                    0,
                    &st,
                    NULL,
                    TimeBuffer,
                    TIMEDATE_SIZE);

       DisplayMessage(IDR_LASTLOGIN, DateBuffer, TimeBuffer);
    }

    return(TRUE);
}



/*
 *  Change and/or display the current context.
 */
int ContextHandler (char *lpParam)
{
    unsigned char Buffer[MAXLEN];
    unsigned char * ptr;
    unsigned char CurrentContext[MAXLEN];

    if ( *lpParam ) 
    {
        NotQuotedStringTranslate(lpParam, TRUE);

        ptr = RemoveSpaces (lpParam);

        if ( NDSCanonicalizeName( lpParam, Buffer, MAXLEN, TRUE ) )
        {
            DisplayMessage(IDR_CHANGE_CONTEXT_ERROR, lpParam);
            return(TRUE);
        }

        if ( NDSChangeContext( Buffer ) )
        {
            DisplayMessage(IDR_CHANGE_CONTEXT_ERROR, lpParam);
            return(TRUE);
        }
    }

    if ( NDSGetContext( CurrentContext, MAXLEN ) )
    {
        DisplayMessage(IDR_GET_CONTEXT_ERROR);
    }
    else
    {
        DisplayMessage(IDR_DISPLAY_CONTEXT, CurrentContext);
    }
    return(TRUE);
}

/*
 *  Do nothing. Return TRUE so the the command will not
 *  be considered as bad.
 */
int ScriptServerHandler (char *lpParam)
{
    return(TRUE);
}

/*
 *  If this is a 4X login, do not execute the default login script.
 */
int NoDefaultHandler (char *lpParam)
{
    if ( fNDS )
        fNoDefaultLoginScript = TRUE;
    return(TRUE);
}

/*
 *  Do nothing. Return TRUE so the the command will not
 *  be considered as bad.
 */
int NullHandler (char *lpParam)
{
    return(TRUE);
}

#define NUMBER_ARGUMENTS 20

/*
 *   External commands start with '#', such as #command /c cls
 */
void ExternalCmdHandler (char *lpCommand)
{
    int n;
    int i;
    unsigned int CommandLength;
    char *lpCmdName, *argv[NUMBER_ARGUMENTS];

    for ( n = 0; n < NUMBER_ARGUMENTS; n++ )
        argv[n] = NULL;

    if ((nCondIndex == -1) || aCondVal[nCondIndex])
    {
        //Convert variables first.
        NotQuotedStringTranslate(lpCommand, FALSE);

        lpCommand = RemoveSpaces(lpCommand+1);
        lpCmdName = strtok (lpCommand, __SPACES__);

        lpCmdName = NTNWtoUNCFormat(lpCmdName);

        argv[0] = lpCmdName;

        for (n = 1; n < NUMBER_ARGUMENTS - 1; n++)
        {
            if ((argv[n] = strtok (NULL, __SPACES__)) == NULL)
                break;
        }


        /*
         * Capture command 
         */
        CommandLength = strlen( lpCommand );

        /*
         * First see if a COMMAND.COM is invoked
         */
        if ( ( ( CommandLength >= strlen("COMMAND.COM") )  &&
             ( !_stricmp( &lpCommand[CommandLength-strlen("COMMAND.COM")], "COMMAND.COM") ) ) ||
                 ( ( CommandLength >= strlen("COMMAND") )  &&
                 ( !_stricmp( &lpCommand[CommandLength-strlen("COMMAND")], "COMMAND") ) ) )
        {
            /*
             * Search for the CAPTURE argument
             */
            for ( i = 1; i < n; i++ )
            {
                CommandLength = strlen( argv[i] );
                if ( ( ( CommandLength >= strlen("CAPTURE.EXE") )  &&
                       ( !_stricmp( &(argv[i])[CommandLength-strlen("CAPTURE.EXE")], "CAPTURE.EXE") ) ) ||
                     ( ( CommandLength >= strlen("CAPTURE") )  &&
                     ( !_stricmp( &(argv[i])[CommandLength-strlen("CAPTURE")], "CAPTURE") ) ) ) {
                    Capture( argv + i, n - i );
                    return;
                }
            }
        }
        else
        {
            /*
             * Is this a CAPTURE command?
             */
            if ( ( ( CommandLength >= strlen("CAPTURE.EXE") )  &&
                 ( !_stricmp( &lpCommand[CommandLength-strlen("CAPTURE.EXE")], "CAPTURE.EXE") ) ) ||
                 ( ( CommandLength >= strlen("CAPTURE") )  &&
                 ( !_stricmp( &lpCommand[CommandLength-strlen("CAPTURE")], "CAPTURE") ) ) ) {
                    Capture( argv, n );
                    return;
            }
        }

        if ((SCRIPT_ERROR = (int) _spawnvp (P_WAIT, lpCmdName, argv)) == -1)
        {
            if (errno == ENOENT)
                DisplayMessage(IDR_ENOENT, lpCommand);
            else
                DisplayMessage(IDR_CANNOT_EXECUTE, lpCommand);
        }
    }
}

/*
 *  Printe out the bad command line.
 */
void BadCommandHandler (char *lpCommand)
{
    DisplayMessage(IDR_SCRIPT_ERROR);
    DisplayMessage(IDR_ORIGINAL_LINE_WAS, lpCommand);
}


/*
 *  Swap the object id.
 */
DWORD SwapLong(DWORD number)
{
    BYTE    *p, tmp[4];

    p = (BYTE *)&number;

    tmp[0] = p[3];
    tmp[1] = p[2];
    tmp[2] = p[1];
    tmp[3] = p[0];

    return(*(DWORD *)tmp);
}

/*
 *  Remove leading spaces, including tabs.
 */
char *RemoveSpaces (char * buffer)
{
    while (*buffer == ' ' || *buffer == '\t')
        buffer++;
    return(buffer);
}

/*
 *  Return TRUE if buffer points to the end of the lind, FALSE otherwise.
 */
int EndOfLine (char *buffer)
{
    int fEndOfLine = FALSE;

    buffer = RemoveSpaces (buffer);

    if (*buffer == '\0' ||
        *buffer == ';' ||
        *buffer == '*' ||
        *buffer == '\r')
        fEndOfLine = TRUE;

    return(fEndOfLine);
}

/*
 *  Return TRUE if lpParam points to "ON", FALSE otherwise.
 */
int IsOn (char *lpParam)
{
    int fOn = FALSE;

    if (!strncmp (lpParam, "ON", 2))
    {
        lpParam += 2;
        fOn = EndOfLine (lpParam);
    }

    return(fOn);
}

/*
 *  Return TRUE if lpParam points to "OFF", FALSE otherwise.
 */
int IsOff (char *lpParam)
{
    int fOff = FALSE;

    if (!strncmp (lpParam, "OFF", 3))
    {
        lpParam += 3;
        fOff = EndOfLine (lpParam);
    }

    return(fOff);
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer the value of time variable specified by index.
 */
void GetTime (char *buffer, int index)
{
    time_t     currentTime;
    struct tm *tmCurrentTime;

    time (&currentTime);
    tmCurrentTime = localtime(&currentTime);

    switch (index)
    {
    case IDS_DAY:
        sprintf (buffer, "%02d\0", tmCurrentTime->tm_mday);
        break;
    case IDS_DAY_OF_WEEK:
        LoadStringA(NULL, IDR_SUNDAY+tmCurrentTime->tm_wday, buffer, 256);
        break;
    case IDS_MONTH:
        sprintf (buffer, "%02d\0", tmCurrentTime->tm_mon+1);
        break;
    case IDS_MONTH_NAME:
        LoadStringA(NULL, IDR_JANUARY+tmCurrentTime->tm_mon, buffer, 256);
        break;
    case IDS_NDAY_OF_WEEK:
        sprintf (buffer, "%d\0", tmCurrentTime->tm_wday+1);
        break;
    case IDS_SHORT_YEAR:
        sprintf (buffer, "%04d\0", tmCurrentTime->tm_year+1900);
        strcpy (buffer, buffer+2);
        break;
    case IDS_YEAR:
        sprintf (buffer, "%04d\0", tmCurrentTime->tm_year+1900);
        break;
    case IDS_AM_PM:
        LoadStringA(NULL, IDR_AM+(tmCurrentTime->tm_hour>=12? 1:0),buffer, 256);
        break;
    case IDS_GREETING_TIME:
        if (tmCurrentTime->tm_hour >= 6 && tmCurrentTime->tm_hour < 12)
            index=0;
        else if (tmCurrentTime->tm_hour >= 12 && tmCurrentTime->tm_hour < 18)
            index=1;
        else
            index=2;

        LoadStringA(NULL, IDR_GREETING_MORNING+index, buffer, 256);
        break;
    case IDS_HOUR:
        if (tmCurrentTime->tm_hour > 12)
            tmCurrentTime->tm_hour -= 12;
        sprintf (buffer, "%d\0", tmCurrentTime->tm_hour);
        break;
    case IDS_HOUR24:
        sprintf (buffer, "%02d\0", tmCurrentTime->tm_hour);
        break;
    case IDS_MINUTE:
        sprintf (buffer, "%02d\0", tmCurrentTime->tm_min);
        break;
    case IDS_SECOND:
        sprintf (buffer, "%02d\0", tmCurrentTime->tm_sec);
        break;
    default:
        *buffer = 0;
    }
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer login user's full name.
 */
void GetFullName (char *buffer)
{
    unsigned int  iRet = 0;
    unsigned char moreFlag;
    unsigned char propertyType;

    if ( fNDS )
    {
        NDSGetVar ( "Full Name", buffer, 128 );
        if ( buffer[0] == '\0' )
            strcpy (buffer, "* Unknown *");
    }
    else
    {
        iRet = NWReadPropertyValue ((NWCONN_HANDLE)CONNECTION_ID,
                                    LOGIN_NAME,
                                    OT_USER,
                                    "IDENTIFICATION",
                                    1,
                                    buffer,
                                    &moreFlag,
                                    &propertyType);
        if (iRet)
            strcpy (buffer, "* Unknown *");
    }
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer login user's object id.
 */
void GetUserID (char *buffer)
{
    unsigned long dwObjectID = 0;

    if ( fNDS )
        dwObjectID = GUserObjectID;
    else
        NTGetUserID( CONNECTION_ID, &dwObjectID );
    sprintf (buffer, "%lx\0", SwapLong(dwObjectID));
    _strupr (buffer);
}

unsigned int GetDays (unsigned int year, BYTE month, BYTE date)
{
    unsigned int i, days = 0;

    for (i = 1; i < month; i++)
    {
        if (i == 2)
            days += (year%4)? 28 : 29;
        else if (i == 4 || i == 6 || i == 9 || i == 11)
            days += 30;
        else
            days += 31;
    }

    days += date;
    return(days);
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer the days in which the password expires.
 */
void GetPasswordExpires (char *buffer)
{
    unsigned int  iRet = 0;
    unsigned int  iRet2 = 0;
    unsigned char moreFlag;
    unsigned int  yearCurrent, yearEnd, days;
    BYTE          monthCurrent, dayCurrent, monthEnd, dayEnd;
    unsigned int exptime = 0, logintime = 0;
    unsigned char propertyType;


    if ( fNDS )
    {
        iRet = NDSGetUserProperty ("Password Expiration Time", (PBYTE)&exptime,
                             4, NULL, NULL);
        iRet2 = NDSGetUserProperty ("Login Time", (PBYTE)&logintime,
                             4, NULL, NULL);

        if ( ( exptime && logintime ) && !iRet && !iRet2 )
        {
            if ( exptime <= logintime )
                strcpy( buffer, "0" );
            else
                sprintf( buffer, "%u", ((exptime-logintime)/(60*60*24)) + 1 );
        }
        else
        {
            sprintf( buffer, "%u", 0x7FFF );
        }
    }
    else 
    {
        NTGetTheDate( &yearCurrent, &monthCurrent, &dayCurrent );
        NWReadPropertyValue ((NWCONN_HANDLE)CONNECTION_ID,
                             LOGIN_NAME,
                             OT_USER,
                             "LOGIN_CONTROL",
                             1,
                             buffer,
                             &moreFlag,
                             &propertyType);

        yearEnd = 1900 + buffer[4];
        monthEnd = buffer[5];
        dayEnd = buffer[6];

        if (monthEnd == 0)
            days = (((yearCurrent%4)? 365 : 366) - GetDays (yearCurrent, monthCurrent, dayCurrent));
        else if (yearEnd == yearCurrent)
        {
            if (monthEnd < monthCurrent ||
                (monthEnd == monthCurrent && dayEnd <= dayCurrent))
                days = 0;
            else
                days = GetDays (yearEnd, monthEnd, dayEnd) - GetDays (yearCurrent, monthCurrent, dayCurrent) - 1;
        }
        else
            days = ((yearCurrent%4)? 364 : 365) + GetDays (yearEnd, monthEnd, dayEnd) - GetDays (yearCurrent, monthCurrent, dayCurrent);

        sprintf (buffer, "%u", days);
    }
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer value of the dos environment variable.
 *  If the variable is not found, buffer is set to be empty string.
 */
void GetDosEnv (char *buffer)
{
    char *lpTemp;

    // This could be called from "%<x>" where x is not upcase. capitalize
    // the string first to be sure.
    _strupr(buffer);

    lpTemp = strchr (buffer, '>');
    if (lpTemp) {
        *lpTemp = 0;

        lpTemp = getenv (buffer+1);

        if (lpTemp && (strlen(lpTemp) < MAXLEN)) {
            strcpy (buffer, lpTemp);
            return;
        }
    }

    *buffer = 0;
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer the 8 bytes network address.
 */
void GetNetWorkAddr (char *buffer)
{
    unsigned char   internetAddress[10] = {0,0,0,0,0,0,0,0,0,0};

    GetInternetAddress (CONNECTION_ID,
                        CONNECTION_NUMBER,
                        internetAddress);

    sprintf (buffer,
             "%02X%02X%02X%02X\0",
             internetAddress[0],
             internetAddress[1],
             internetAddress[2],
             internetAddress[3] );
}


/*
 *  Used by VarTranslate().
 *  Copy to buffer the 12 bytes node address to buffer.
 */
void GetPStation (char *buffer)
{
    unsigned char   internetAddress[10] = {0,0,0,0,0,0,0,0,0,0};

    GetInternetAddress (CONNECTION_ID,
                        CONNECTION_NUMBER,
                        internetAddress);

    sprintf (buffer,
             "%02X%02X%02X%02X%02X%02X\0",
             internetAddress[4],
             internetAddress[5],
             internetAddress[6],
             internetAddress[7],
             internetAddress[8],
             internetAddress[9]);
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer the decimal string representing the remaining account
 *  balance
 */
void GetAccountBalance (char *buffer)
{
    DWORD balance;
    BYTE dataBuffer[128];
    unsigned char moreFlag;
    unsigned char propertyType;
    unsigned int err;

    if ( fNDS )
    {
        err = NDSGetUserProperty ("Account Balance", dataBuffer,128, NULL, NULL);
    }
    else
    {
        err = NWReadPropertyValue ((NWCONN_HANDLE)CONNECTION_ID,
                                   LOGIN_NAME,
                                   OT_USER,
                                   "ACCOUNT_BALANCE",
                                   1,
                                   dataBuffer,
                                   &moreFlag,
                                   &propertyType);
    }

    if ( err )
        balance = 0;
    else 
        balance = *((DWORD *)dataBuffer); 

    sprintf (buffer, "%d", balance);
}

/*
 *  Used by VarTranslate().
 *  Copy to buffer MACHINE, SMACHINE, OS, OS_VERSION or SHELL_TYPE
 *  to buffer according to index.
 */
void GetShellVersion(char *buffer, int index)
{
    static char szTemp[40];
    char *lpTemp;
    BYTE shellmajor, shellminor, shellnum;

    NTGetVersionOfShell( szTemp, &shellmajor, &shellminor, &shellnum );

    lpTemp = szTemp;

    switch (index)
    {
    case IDS_OS:
        strcpy (buffer, lpTemp);
        break;
    case IDS_OS_VERSION:
        lpTemp += (strlen (lpTemp)+1);
        strcpy (buffer, lpTemp);
        break;
    case IDS_MACHINE:
        lpTemp += (strlen (lpTemp)+1);
        lpTemp += (strlen (lpTemp)+1);
        strcpy (buffer, lpTemp);
        break;
    case IDS_SMACHINE:
        lpTemp += (strlen (lpTemp)+1);
        lpTemp += (strlen (lpTemp)+1);
        lpTemp += (strlen (lpTemp)+1);
        strcpy (buffer, lpTemp);
        break;
    case IDS_SHELL_TYPE:
    case IDS_SHELL_VERSION:
        sprintf (buffer, "V%d.%d%d%c", shellmajor, shellminor/10, shellminor%10, 'A'+shellnum);
        break;
    default:
        *buffer = 0;
        break;
    }
}

void GetArgv(char *buffer)
{
    int n;

    n = atoi (buffer)+nGlobalShiftDelta;

    if (n == 0)
        strcpy (buffer, PREFERRED_SERVER);
    else if (n == 1)
        strcpy (buffer, LOGIN_NAME);
    else if (n > 1 && n < ARGC)
        strcpy (buffer, ARGV[n]);
    else
        *buffer = 0;
}

/*
 *  vartext is an array of size MAXLEN.
 *  vartext points to a string starts with a variable on enter.
 *  vartext stores the value of the variable on exit.
 *  Return the lenth of the variable.
 */
int VarTranslate(char *vartext)
{
    int i, nVarLen = 0;

    for (i = 0; i < (fNDS ? NUMVAR : NUMVAR_3X); i++)
    {
        if (!nwVarNameCompare(vartext, varTable[i].VarName))
        {
            nVarLen = strlen(varTable[i].VarName);

            switch ( i )
            {
            case IDS_DAY_OF_WEEK:
            case IDS_DAY:
            case IDS_MONTH_NAME:
            case IDS_MONTH:
            case IDS_NDAY_OF_WEEK:
            case IDS_SHORT_YEAR:
            case IDS_YEAR:
            case IDS_AM_PM:
            case IDS_GREETING_TIME:
            case IDS_HOUR24:
            case IDS_HOUR:
            case IDS_MINUTE:
            case IDS_SECOND:
                GetTime (vartext, i);
                break;
            case IDS_FULL_NAME:
                GetFullName (vartext);
                break;
            case IDS_LOGIN_NAME:
                strcpy (vartext, LOGIN_NAME);
                /*
                 *  4X LOGIN.EXE always truncates and replaces spaces
                 *  with underscores.   There was a report that some
                 *  versions of 3X LOGIN.EXE do this also. 
                 */
                if ( fNDS )
                {
                    int i;
                    vartext[8] = '\0';
                    for ( i = 0; i < 8; i++ )
                        if ( vartext[i] == ' ' )
                            vartext[i] = '_';
                }
                break;
            case IDS_USER_ID:
                GetUserID (vartext);
                break;
            case IDS_PASSWORD_EXPIRES:
                GetPasswordExpires (vartext);
                break;
            case IDS_NETWORK_ADDRESS:
            case IDS_NETWORK:
                GetNetWorkAddr (vartext);
                break;
            case IDS_FILE_SERVER:
                strcpy (vartext, PREFERRED_SERVER);
                break;
            case IDS_ACCESS_SERVER:
            case IDS_ACCESS:
                strcpy (vartext, "0");
                break;
            case IDS_ERROR_LEVEL:
            case IDS_ERRORLEVEL:
                sprintf (vartext, "%u", SCRIPT_ERROR);
                break;
            case IDS_MACHINE:
            case IDS_OS_VERSION:
            case IDS_OS:
            case IDS_SMACHINE:
            case IDS_SHELL_TYPE:
            case IDS_SHELL_VERSION:
                GetShellVersion (vartext, i);
                break;
            case IDS_STATION:
                sprintf (vartext, "%d", CONNECTION_NUMBER);
                break;
            case IDS_P_STATION:
                GetPStation (vartext);
                break;
            case IDS_LAST_NAME:
            case IDS_SURNAME:
                strcpy (vartext, LAST_NAME);
                break;
            case IDS_LOGIN_CONTEXT: 
                strcpy (vartext, LOGIN_CONTEXT);
                break;
            case IDS_NETWARE_REQUESTER:
            case IDS_REQUESTER_VERSION:
            case IDS_DOS_REQUESTER:
            case IDS_REQUESTER:
                strcpy (vartext, REQUESTER_VERSION);
                break;
            case IDS_REQUESTER_CONTEXT:
                strcpy (vartext, REQUESTER_CONTEXT);
                break;
            case IDS_ACCOUNT_BALANCE: 
                GetAccountBalance (vartext);
                break;
            case IDS_CN: 
                strcpy (vartext, COMMON_NAME);
                break;
            case IDS_HOME_DIRECTORY:
                {
                    char buffer[MAXLEN];

                    vartext[0] = '\0';
                    NDSGetVar ( varTable[i].VarName, buffer, MAXLEN );
                    if ( buffer[0] )
                        ConverNDSPathToNetWarePathA( buffer, NULL, vartext );
                }
                break;
            case IDS_ADMINISTRATIVE_ASSISTANT:
            case IDS_ALLOW_UNLIMITED_CREDIT:
            case IDS_DESCRIPTION:
            case IDS_EMAIL_ADDRESS:
            case IDS_EMPLOYEE_ID:
            case IDS_FACSIMILE_TELEPHONE_NUMBER:
            case IDS_GROUP_MEMBERSHIP:
            case IDS_HIGHER_PRIVILEGES:
            case IDS_INITIALS:
            case IDS_LANGUAGE:
            case IDS_LOCKED_BY_INTRUDER:
            case IDS_LOGIN_DISABLED:
            case IDS_LOGIN_GRACE_LIMIT:
            case IDS_LOGIN_GRACE_REMAINING:
            case IDS_LOGIN_INTRUDER_ATTEMPTS:
            case IDS_LOGIN_MAXIMUM_SIMULTANEOUS:
            case IDS_MAILSTOP:
            case IDS_MESSAGE_SERVER:
            case IDS_MINIMUM_ACCOUNT_BALANCE:
            case IDS_OBJECT_CLASS:
            case IDS_OU:
            case IDS_PASSWORD_ALLOW_CHANGE:
            case IDS_PASSWORD_MINIMUM_LENGTH:
            case IDS_PASSWORD_REQUIRED:
            case IDS_PASSWORD_UNIQUE_REQUIRED:
            case IDS_PASSWORDS_USED:
            case IDS_PHYSICAL_DELIVERY_OFFICE_NAME:
            case IDS_POSTAL_ADDRESS:
            case IDS_POSTAL_CODE:
            case IDS_POSTAL_OFFICE_BOX:
            case IDS_PRIVATE_KEY:
            case IDS_PROFILE:
            case IDS_REVISION:
            case IDS_SECURITY_EQUALS:
            case IDS_SECURITY_FLAGS:
            case IDS_SEE_ALSO:
            case IDS_SERVER_HOLDS:
            case IDS_SUPERVISOR:
            case IDS_TELEPHONE_NUMBER:
            case IDS_TITLE:
            case IDS_CERTIFICATE_VALIDITY_INTERVAL:
            case IDS_EQUIVALENT_TO_ME:
            case IDS_GENERATIONAL_QUALIFIER:
            case IDS_GIVEN_NAME:
            case IDS_MAILBOX_ID:
            case IDS_MAILBOX_LOCATION:
            case IDS_PROFILE_MEMBERSHIP:
            case IDS_SA:
            case IDS_S:
            case IDS_L:
                NDSGetVar ( varTable[i].VarName, vartext, MAXLEN );
                break;
            }
            return(nVarLen);
        }
    }

    if (isdigit(*vartext))
    {
        while (isdigit(vartext[nVarLen]))
            nVarLen++;
        GetArgv(vartext);
    }
    else if (*vartext == '<')
    {
        nVarLen = 1;
        while (vartext[nVarLen] != '>' && vartext[nVarLen] != 0)
        {
            if (IsDBCSLeadByte(vartext[nVarLen]))
                nVarLen++;
            nVarLen++;
        }

        if (vartext[nVarLen] == 0)
            nVarLen = 0;
        else
        {
            nVarLen++;
            GetDosEnv (vartext);
        }
    }

    return(nVarLen);
}

/*
 *  Parse path string.
 *  If find the %variable value, replace it, otherwise keep as it is.
 */
void  NotQuotedStringTranslate(char *buf, BOOL Remove_dbs)
{
    char *pPercentSign, *pRest, vartext[MAXLEN];
    int   nVarLen, nInsertlen;

    if ( Remove_dbs )
    {
        // Convert \\ to \.
        pRest = buf;
        for (pRest = buf; *pRest; pRest = NWAnsiNext(pRest))
        {
            if (*pRest == '\\' && *(pRest+1) == '\\')
                memmove (pRest, pRest+1, strlen (pRest));
        }
    }

    // Convert variables following '%' sign.
    pRest = buf;
    while (pPercentSign = strchr(pRest, '%'))
    {
        pRest = pPercentSign+1;

        strcpy (vartext, pRest);

        nVarLen = VarTranslate(vartext);

        if (nVarLen == 0)
            continue;

        nInsertlen = strlen (vartext);
        if (strlen (buf) + nInsertlen - nVarLen < MAXLEN)
        {
            pRest = pPercentSign+1+nVarLen;

            memmove (pPercentSign+nInsertlen, pRest, strlen (pRest)+1);
            memmove (pPercentSign, vartext, nInsertlen);
            pRest = pPercentSign+nInsertlen;
        }
    }
}

/*
 *  Used by QuotedStringTranslate()
 *  On enter, *ppTemp point to a variable, on exit *ppTemp points to the
 *  charecter next to the variable. *ppBuffer points to the end of the
 *  value of the variable.
 */
int DoVarTranslate (char **ppTemp, char **ppBuffer, unsigned int nMaxLen, int fInquotes)
{
    int nVarLen;
    char vartext[MAXLEN];

    strcpy (vartext, *ppTemp);

    nVarLen = VarTranslate (vartext);

    if (nVarLen != 0)
    {
        if (strlen(vartext) >= nMaxLen)
            return(FALSE);

        strcpy (*ppBuffer, vartext);
        (*ppBuffer) = (*ppBuffer) + strlen (vartext);
        (*ppTemp) += nVarLen;
    }
    else if (fInquotes)
    {
        strcpy (*ppBuffer, "%");
        (*ppBuffer) += 1;
    }
    else
        return(FALSE);

    return(TRUE);
}

/*
 *  Used by QuotedStringTranslate()
 *  On entry, *(*ppTemp -1) is '\', if **ppTemp is one of those special
 *  characters, put the value in **ppBuffer, otherwise copy '\\\ and
 *  whatever is in *ppBuffer to *ppBuffer.
 */
void TranslateSpecialChar (char **ppTemp, char **ppBuffer)
{
    (*ppTemp)++;

    if (**ppTemp == '\\')
        **(ppBuffer) = '\\';
    else if (**ppTemp == 'n')
        **(ppBuffer) ='\n';
    else if (**ppTemp == 'r')
        **(ppBuffer) ='\r';
    else if (**ppTemp == '\"')
        **(ppBuffer) ='\"';
    else if (**ppTemp == '7')
        **(ppBuffer) ='\7';
    else
    {
        **(ppBuffer) = '\\';
        (*ppBuffer)++;
        return;
    }

    (*ppBuffer)++;
    (*ppTemp)++;;
}

/*
 *  Used by QuotedStringTranslate().
 *  Return TRUE if there are more interesting strings and it's seperated by ';'
 *  FALSE otherwise.
 */
int GetNextString (char **ppTemp, int *pfEnd)
{
    int fMore = FALSE;

    (*ppTemp) = RemoveSpaces (*ppTemp);

    *pfEnd = (**ppTemp == 0);

    if (**ppTemp == ';')
    {
        (*ppTemp) = RemoveSpaces (*ppTemp+1);
        fMore = TRUE;
    }

    return(fMore);
}


int GetLastShiftOp (char *buffer, char *pchOp, char *lpRest)
{
    int i, inquotes = FALSE;

    // NetWare compatibility fix.
    // for (i = strlen (buffer)-1; i >= 0; i--)

    for (i = 0; buffer[i]; i++)
    {
        if (buffer[i] == '\"' && buffer [i-1] != '\\')
            inquotes = !inquotes;
        if (!inquotes &&
            ( (buffer[i] == '>' && buffer[i+1] == '>')
            ||(buffer[i] == '<' && buffer[i+1] == '<')))
        {
            *pchOp = buffer[i];
            buffer[i] = 0;
            strcpy (lpRest, RemoveSpaces(buffer+i+2));
            return(TRUE);
        }
    }

    return(FALSE);
}
int GetLastAddOp (char *buffer, char *pchOp, char *lpRest)
{
    int i, inquotes = FALSE;

    // NetWare compatibility fix.
    // for (i = strlen (buffer)-1; i >= 0; i--)

    for (i = 0; buffer[i]; i++)
    {
        if (buffer[i] == '\"' && buffer [i-1] != '\\')
            inquotes = !inquotes;
        if (!inquotes &&
            (buffer[i] == '+' || buffer[i] == '-') )
        {
            *pchOp = buffer[i];
            buffer[i] = 0;
            strcpy (lpRest, RemoveSpaces(buffer+i+1));
            return(TRUE);
        }
    }

    return(FALSE);
}

int GetLastMultiplyOp (char *buffer, char *pchOp, char *lpRest)
{
    int i, inquotes = FALSE;

    // NetWare compatibility fix.
    // for (i = strlen (buffer)-1; i >= 0; i--)
    for (i = 0; buffer[i]; i++)
    {
        if (buffer[i] == '\"' && buffer [i-1] != '\\')
            inquotes = !inquotes;
        if (!inquotes &&
            (buffer[i] == '*' || buffer[i] == '/' || buffer[i] == '%') )
        {

            *pchOp = buffer[i];
            buffer[i] = 0;
            strcpy (lpRest, RemoveSpaces(buffer+i+1));
            return(TRUE);
        }
    }

    return(FALSE);
}

/*
 *  Used by QuotedStringTranslate.
 *  Return TRUE if input buffer is right format, FALSE otherwise.
 */
int SingleStringTranslate (char *buffer)
{
    int   inquotes = FALSE, fEnd = FALSE, nShift, nLen;
    char  szRest[MAXLEN], chOp;
    char *lpTemp = szRest, *lpBuffer=buffer;

    buffer = RemoveSpaces (buffer);

    if (GetLastShiftOp (buffer, &chOp, szRest))
    {
        if (!QuotedStringTranslate (buffer))
            return(FALSE);

        while (isdigit (*lpTemp))
            lpTemp++;

        if (!EndOfLine(lpTemp))
            return(FALSE);

        *lpTemp = 0;

        nShift = atoi (szRest);
        nLen = strlen (buffer);

        if (nShift >= nLen)
            *buffer = 0;
        else
        {
            if (chOp == '<')
                memmove (buffer, buffer+nShift, nLen-nShift);

            *(buffer+nLen-nShift) = 0;
        }
    }
    else if (GetLastAddOp (buffer, &chOp, szRest))
    {
        if (!QuotedStringTranslate (buffer) ||
            !QuotedStringTranslate (szRest))
            return(FALSE);

        sprintf (buffer, "%d", (chOp == '+')? (atoi (buffer) + atoi (szRest))
                                            : (atoi (buffer) - atoi (szRest)));
    }
    else if (GetLastMultiplyOp (buffer, &chOp, szRest))
    {
        if (!QuotedStringTranslate (buffer) ||
            !QuotedStringTranslate (szRest))
            return(FALSE);

        if (chOp == '*')
            sprintf (buffer, "%d", atoi (buffer) * atoi (szRest));
        else
        {
            if (atoi (szRest) == 0)
            {
                DisplayMessage(IDR_DIVIDE_BY_ZERO);
                strcpy (buffer, "0");
            }
            else
            {
                sprintf (buffer, "%d",(chOp == '/')? (atoi (buffer) / atoi (szRest))
                                                   : (atoi (buffer) % atoi (szRest)));
            }
        }
    }
    else
    {
        strcpy (szRest, buffer);
        *buffer = 0;

        while (*lpTemp)
        {
            if (inquotes)
            {
                if (*lpTemp == '\\')
                    TranslateSpecialChar (&lpTemp, &buffer);
                else if (*lpTemp == '\"')
                {
                    inquotes = !inquotes;
                    lpTemp++;
                    if (!GetNextString (&lpTemp, &fEnd))
                        break;
                }
                else if (*lpTemp == '%')
                {
                    lpTemp++;
                    DoVarTranslate (&lpTemp, &buffer, MAXLEN-(UINT)(buffer-lpBuffer), TRUE);
                }
                else
                {
                    *buffer =  *lpTemp;
                    if (IsDBCSLeadByte(*buffer))
                    {
                        buffer++;
                        lpTemp++;
                        *buffer =  *lpTemp;
                    }
                    buffer++;
                    lpTemp++;
                }
            }
            else
            {
                if (*lpTemp == '\"')
                {
                    inquotes = !inquotes;
                    lpTemp++;
                }
                else
                {
                    if (!DoVarTranslate (&lpTemp, &buffer, MAXLEN-(UINT)(buffer-lpBuffer), FALSE) ||
                        !GetNextString (&lpTemp, &fEnd))
                        break;
                }
            }
        }
        if (!fEnd)
        {
            if ( inquotes )
                DisplayMessage( IDR_NO_END_QUOTE );
            return(FALSE);
        }
        *buffer = 0;
    }

    return(TRUE);
}

/*
 *  Replace the variables in the string with their value.
 *  Use this function when the input string is quoted format.
 *  Return TRUE if input buffer is right format, FALSE otherwise.
 */
int QuotedStringTranslate (char *buffer)
{
    char  szTemp[MAXLEN], *lpLeft, *lpRight, *ptr = buffer, *pNext;
    int inquotes;

    lpLeft = *buffer == '('? buffer : NULL;
    lpRight = *buffer == ')'? buffer : NULL;
    inquotes = (*ptr == '"');

    while (*ptr)
    {
        pNext = NWAnsiNext (ptr);

        if (*pNext == '"' && *(ptr) != '\\')
        {
            pNext++;
            inquotes = !inquotes;
        }

        ptr = pNext;

        if (!inquotes)
        {
            if (*ptr == '(')
                lpLeft = ptr;
            else if (*ptr == ')')
            {
                lpRight = ptr;

                *lpRight = 0;

                if (lpLeft == NULL)
                    return(FALSE);

                if (lpRight - lpLeft <= 1) //There should be something in the backets.
                    return(FALSE);

                *lpLeft = 0;

                strncpy (szTemp, lpLeft+1, (UINT)(lpRight-lpLeft));

                if (!SingleStringTranslate (szTemp))
                    return(FALSE);

                if (strlen (buffer) + strlen(szTemp) + strlen (lpRight+1) + 2 >= MAXLEN)
                    return(FALSE);

                *lpLeft = '"';
                *(lpLeft+1+strlen(szTemp)) = '"';
                memmove (lpLeft+2+strlen(szTemp), lpRight+1, strlen (lpRight+1)+1);
                memmove (lpLeft+1, szTemp, strlen(szTemp));

                lpLeft = *buffer == '('? buffer : NULL;
                lpRight = *buffer == ')'? buffer : NULL;
                ptr = buffer;
                inquotes = (*ptr == '"');
            }
        }
    }

    if (lpLeft != NULL || lpRight != NULL)
        return(FALSE);
    return(SingleStringTranslate (buffer));
}


void BreakOff(void)
{
    fBreakOn = FALSE;

    NTBreakOff();
}

void BreakOn(void)
{
    fBreakOn = TRUE;

    NTBreakOn();
}

/*
 *  Used by ComspecHandler() and SetHandler()
 *  Set dos environment variable.
 */
int SetEnv (char *lpEnvLine)
{
    ExportEnv( lpEnvLine );
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\nwscript.c ===
/*************************************************************************
*
*  NWSCRIPT.C
*
*  This module is the NetWare Logon Script utility.
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\NWSCRIPT.C  $
*  
*     Rev 1.3   22 Jan 1996 16:48:32   terryt
*  Add automatic attach query during map
*  
*     Rev 1.2   22 Dec 1995 14:26:08   terryt
*  Add Microsoft headers
*  
*     Rev 1.1   20 Nov 1995 16:10:38   terryt
*  Close open NDS handles
*  
*     Rev 1.0   15 Nov 1995 18:07:42   terryt
*  Initial revision.
*  
*     Rev 1.1   23 May 1995 19:37:18   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:10:58   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <windows.h>
#include <locale.h>
#include <stdlib.h>
#include <time.h>
#include <direct.h>
#include <process.h>
#include <string.h>
#include <malloc.h>
#include <nwapi.h>

#include "nwscript.h"

int NTNetWareLoginScripts( int argc, char ** argv );

unsigned int fNDS = FALSE;

/*************************************************************************
*
*  main
*     Main function and entry point
*
*  ENTRY:
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments;
*           (not used due to always being ANSI strings).
*
*  EXIT
*       (int) exit code: SUCCESS for success; FAILURE for error.
*
*************************************************************************/

int __cdecl
main( int argc,
      char **argv )
{
    //
    // Call wksta to reset the sync login script flag if it did set it.
    // This flag is set and reset everytime so that if nw login scripts
    // are not used, user does not need wait.
    // Ignore any errors.
    //

    // Sets the locale to the default, which is the system-default 
    // ANSI  or DBCS code page obtained from the operating system.


    setlocale( LC_ALL, "" );

    (void) NwSetLogonScript(RESET_SYNC_LOGONSCRIPT) ;

    (void)NTNetWareLoginScripts( argc, argv );

    CleanupExit( 0 );

    return 0;

} /* main() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\ps40db.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    psndsdb.c

Abstract:

    Read the Print Configuration Attributes 

  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\PS40DB.C  $
*  
*     Rev 1.4   10 Apr 1996 14:23:28   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.4   12 Mar 1996 19:55:22   terryt
*  Relative NDS names and merge
*  
*     Rev 1.3   04 Jan 1996 18:57:36   terryt
*  Bug fixes reported by MS
*  
*     Rev 1.2   22 Dec 1995 14:26:22   terryt
*  Add Microsoft headers
*  
*     Rev 1.1   20 Nov 1995 15:09:46   terryt
*  Context and capture changes
*  
*     Rev 1.0   15 Nov 1995 18:07:52   terryt
*  Initial revision.

--*/
#include "common.h"

extern DWORD SwapLong(DWORD number);
extern char *TYPED_USER_NAME;

unsigned int
PS40GetJobName(
    unsigned int    NDSCaptureFlag,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord,
    unsigned char   GetDefault
    );

#include <pshpack1.h>
#define NWPS_JOB_NAME_SIZE          32    /* 31 bytes and a '\0' */ 
#define NWPS_FORM_NAME_SIZE         12    /* 12 bytes and a '\0' */ 
#define NWPS_BANNER_NAME_SIZE       12    /* 12 bytes and a '\0' */ 
#define NWPS_BANNER_FILE_SIZE       12    /* 12 bytes and a '\0' */ 
#define NWPS_DEVI_NAME_SIZE         32    /* 32 bytes and a '\0' */ 
#define NWPS_MODE_NAME_SIZE         32    /* 32 bytes and a '\0' */ 
#define NWPS_BIND_NAME_SIZE         48
#define NWPS_MAX_NAME_SIZE          514
/*
//   NWPS_Job_Old_Db_Hdr is the first record in the 4.0 PrnConDB database.
//   It contains the following information about the database:
//     The version number,
//     the number of NWPS_Job_Rec records in PrnConDB,
//     the name of the default print job configuration and
//     the name of the job record owner.
*/
typedef struct {
  char  text[ 76 ];             /* Printcon database. Version 4.0     */
  char  DefaultJobName[ 32 ];   /* Name of default Job                */
  char  Owner[ 256 ];           /* owner of the job record            */
  WORD  NumberOfRecords;        /* # of NWPS_Job_Rec's in PrnConDB    */
  WORD  NumberOfBlocks;         /* # of 50-(NWPS_Job_Name_Rec) blocks */
  BYTE  MajorVersion;           /* 4                                  */
  BYTE  MinorVersion;           /* 0                                  */
} PRINTCON_40_HEADER;

#define PRINTCON_40_HEADER_SIZE    sizeof(PRINTCON_40_HEADER)

/*
//   NWPS_Job_41_Db_Hdr is the first record in the 4.1 PrnConDB database.
//   It contains the following information about the database:
//     The version number,
//     the number of NWPS_Job_Rec records in PrnConDB,
//     the name of the default print job configuration and
//     the name of the job record owner IN UNICODE.
*/
typedef struct {
  char  text[ 76 ];              /* Printcon database. Version 4.1     */
  char  DefaultJobName[ 32 ];    /* Name of default Job                */
  char  unused[ 256 ];           /* no longer used.                    */
  WORD  NumberOfRecords;         /* # of NWPS_Job_Rec's in PrnConDB    */
  WORD  NumberOfBlocks;          /* # of 50-(NWPS_Job_Name_Rec) blocks */
  BYTE  MajorVersion;            /* 4                                  */
  BYTE  MinorVersion;            /* 1 unicode defaultPJOwner etc.      */
  WORD  Owner[ 256 ];            /* owner of the default job record    */
} PRINTCON_41_HEADER;

#define PRINTCON_41_HEADER_SIZE    sizeof(PRINTCON_41_HEADER)

/*
//   NWPS_Job_Name_Rec is the type of record found in the
//   second section of the PrnConDB database.  Each one of
//   these records contains the name of each NWPS_Job_Rec
//   and a pointer to their location in the third section of
//   the database.  There is space set aside in this second
//   section for fifty NWPS_Job_Name_Rec records; if this
//   limit is exceeded then another fifty-record block following
//   the first one is allocated after the third section of the
//   database is moved down to make room for the expansion.
*/
typedef struct {
  char  JobName[ NWPS_JOB_NAME_SIZE ]; /* 1 - 31 chars long + 0        */
  long  JobRecordOffset; /* Offset of the record
                         // (from the beginning 
                         // of the 3rd section for 4.0
                         // databases and from the start
                         // of the file for pre-4.0)                
                         */
} JOB_NAME_AREA;

#define JOB_NAME_AREA_SIZE       sizeof(JOB_NAME_AREA)

typedef struct {
  union {
      struct {
          DWORD DataType : 1;    /* 0=Byte stream 1 = Text */
          DWORD FormFeed : 1;    /* 0 = FF; 1 = suppress FF */
          DWORD NotifyWhenDone : 1; /* 0 = no, 1 = yes */
          DWORD BannerFlag : 1;    /* 0 = no, 1 = yes */
          DWORD AutoEndCap : 1;    /* 0 = no, 1 = yes */
          DWORD TimeOutFlag: 1;    /* 0 = no, 1 = yes */
          DWORD SystemType : 3;  /* 0 = bindery 1 = NDS  */
          DWORD Destination: 3;  /* 0 = queue 1 = printer */
          DWORD unknown : 20;
      }; 
      DWORD   PrintJobFlags;
  }; 
  
  WORD  NumberOfCopies; /* 1 - 65,000                             */
  WORD  TimeoutCount;   /* 1 - 1,000                              */
  BYTE  TabSize;        /* 1 - 18                                 */
  BYTE  LocalPrinter;   /* 0=Lpt1, 1=Lpt2, 2=Lpt3 etc.            */
  char  FormName[ NWPS_FORM_NAME_SIZE + 2 ];     /* 1-12 chars    */
  char  Name[ NWPS_BANNER_NAME_SIZE + 2 ];       /* 1-12 chars    */
  char  BannerName[ NWPS_BANNER_FILE_SIZE + 2 ]; /* 1-12 chars    */
  char  Device[ NWPS_DEVI_NAME_SIZE + 2 ];       /* 1-32 chars    */
  char  Mode[ NWPS_MODE_NAME_SIZE + 2 ];         /* 1-32 chars    */
  union {
      struct {
        /* pad structures on even boundries */
        char    Server[ NWPS_BIND_NAME_SIZE + 2 ];      /* 2-48 chars */
        char    QueueName[ NWPS_BIND_NAME_SIZE + 2 ];   /* 1-48 chars */
        char    PrintServer[ NWPS_BIND_NAME_SIZE + 2 ]; /* 1-48 chars */
      } NonDS;
      char    DSObjectName[ NWPS_MAX_NAME_SIZE ];   
  } u;
  BYTE  reserved[390];  /* Adds up to 1024 total (was 1026)       */
} JOB_RECORD_AREA;

#define JOB_RECORD_AREA_SIZE    sizeof(JOB_RECORD_AREA)


#include <poppack.h>



/*++
*******************************************************************

        PS40JobGetDefault

Routine Description:

        Get the default print job configuration from 40.

Arguments:
        NDSCaptureFlag
        SearchFlag = 
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PS40JobGetDefault(
    unsigned int    NDSCaptureFlag,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    )
{
    return PS40GetJobName(
                    NDSCaptureFlag,
                    SearchFlag,
                    pOwner,
                    pJobName,
                    pJobRecord,
                    TRUE);
}


/*++
*******************************************************************

        PS40JobRead

Routine Description:

        Get the print job configuration from 40.

Arguments:

        NDSCaptureFlag =
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PS40JobRead(
    unsigned int    NDSCaptureFlag, 
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    )
{
    return PS40GetJobName(
                NDSCaptureFlag,
                0,
                pOwner,
                pJobName,
                pJobRecord,
                FALSE);
}


/*++
*******************************************************************

        PS40GetJobName

Routine Description:

        Common routine to get the print job configuration from 40.

Arguments:
        NDSCaptureFlag =
        SearchFlag = 
        pOwner = 
        pJobName = A pointer to return the default job configuration name.
        pJobRecord = A pointer to return the default job configuration.
        GetDefault = TRUE = get the default job name, FALSE = Don't get
                      the default job name.

Return Value:

        SUCCESSFUL                      0x0000
        PS_ERR_BAD_VERSION              0x7770
        PS_ERR_GETTING_DEFAULT          0x7773
        PS_ERR_OPENING_DB               0x7774
        PS_ERR_READING_DB               0x7775
        PS_ERR_READING_RECORD           0x7776
        PS_ERR_INTERNAL_ERROR           0x7779
        PS_ERR_NO_DEFAULT_SPECIFIED     0x777B
        INVALID_CONNECTION              0x8801

*******************************************************************
--*/
unsigned int
PS40GetJobName(
    unsigned int    NDSCaptureFlag, 
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord,
    unsigned char   GetDefault
    )
{
    unsigned char   *pSearchJobName;
    unsigned long   ObjectId;
    HANDLE          stream = NULL;
    unsigned int    Count;
    unsigned int    Bytes;
    unsigned int    RetCode = 0;
    unsigned int    ConnectionNumber;
    JOB_NAME_AREA   JobNameArea;
    JOB_RECORD_AREA JobRecord;
    PRINTCON_40_HEADER PrintConHeader;
    unsigned int    Version40 = FALSE;
    unsigned int ConnectionHandle;
    unsigned char   MailDirPath[NCP_MAX_PATH_LENGTH];
    unsigned char   TempJobName[33];
    PBYTE           JobContext = NULL;
    unsigned        FileSize;

    // TRACKING Printer names can be used instead of queues
    // Must lookup  "default print queue" if NT doesn't 

    if ( NDSCaptureFlag ) {

        if ( !GetDefault ) {
            JobContext = strchr( pJobName, ':' );
            if ( JobContext ) {
                *JobContext = '\0';
                strncpy( TempJobName, pJobName, 32 );
                TempJobName[32] = 0;
                *JobContext++ = ':';
                pJobName = TempJobName;
            }
        }

        if ( JobContext ) {
            if (NDSfopenStream ( JobContext, "Print Job Configuration", &stream, 
                 &FileSize )) {
                RetCode = PS_ERR_OPENING_DB;
                goto CommonExit;
            }
        }
        else {
            if (NDSfopenStream ( TYPED_USER_NAME, "Print Job Configuration",
                    &stream, &FileSize)) {
                PBYTE p;

                for ( p = TYPED_USER_NAME; p ; p = strchr ( p, '.' ) )
                {
                    p++;
                             
                    if ( *p == 'O' && *(p+1) == 'U' && *(p+2) == '=' )
                        break;

                    if ( *p == 'O' && *(p+1) == '=' )
                        break;
                }
                if (NDSfopenStream ( p, "Print Job Configuration", &stream,
                     &FileSize)) {
                    RetCode = PS_ERR_OPENING_DB;
                    goto CommonExit;
                }
            }
        }
    }
    else {

        if (!CGetDefaultConnectionID (&ConnectionHandle)) {
            RetCode = PS_ERR_OPENING_DB;
            goto CommonExit;
        }

        RetCode = GetConnectionNumber(ConnectionHandle, &ConnectionNumber);
        if (RetCode) {
            goto CommonExit;
        }

        RetCode = GetBinderyObjectID (ConnectionHandle, LOGIN_NAME,
                  OT_USER, &ObjectId);
        if (RetCode) {
            goto CommonExit;
        }

        /** Build the path to open the file **/

        sprintf(MailDirPath, "SYS:MAIL/%lX/PRINTJOB.DAT", SwapLong(ObjectId));
        stream = CreateFileA( NTNWtoUNCFormat( MailDirPath ),
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );
        if (stream == INVALID_HANDLE_VALUE) {

            sprintf(MailDirPath, "SYS:PUBLIC/PRINTJOB.DAT");

            stream = CreateFileA( NTNWtoUNCFormat(MailDirPath),
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );

            if (stream == INVALID_HANDLE_VALUE) {
                RetCode = PS_ERR_OPENING_DB;
                goto CommonExit;
            }
        }
    }

    if ( !ReadFile( stream, (PBYTE) &PrintConHeader, PRINTCON_40_HEADER_SIZE, &Bytes, NULL ) ) {
        RetCode = PS_ERR_INTERNAL_ERROR;
        goto CommonExit;
    }

    if (Bytes < PRINTCON_40_HEADER_SIZE) {
        if ( !( NDSCaptureFlag && Bytes) ) {
            RetCode = PS_ERR_INTERNAL_ERROR;
            goto CommonExit;
        }
    }

    /** Check the version number **/

    if ( PrintConHeader.MajorVersion != 4 ) {
        RetCode = PS_ERR_BAD_VERSION;
        goto CommonExit;
    }

    if ( PrintConHeader.MinorVersion == 0 ) {
        Version40 = TRUE;
    }

    /** Get the name we are looking for **/

    if (GetDefault) {
        if (PrintConHeader.DefaultJobName[0] == 0) {
            RetCode = PS_ERR_GETTING_DEFAULT;
            goto CommonExit;
        }
        pSearchJobName = PrintConHeader.DefaultJobName;
    }
    else {
        pSearchJobName = pJobName;
    }

    if ( !Version40 ) {
        SetFilePointer( stream, PRINTCON_41_HEADER_SIZE, NULL, FILE_BEGIN );
    }

    Count = 0;

    /** Go through all of the job entry to look for the name **/

    while (Count < PrintConHeader.NumberOfRecords) {
        if ( !ReadFile( stream, (PBYTE) &JobNameArea, JOB_NAME_AREA_SIZE, &Bytes, NULL) ) {
            RetCode = PS_ERR_INTERNAL_ERROR;
            goto CommonExit;
        }

        if (Bytes < JOB_NAME_AREA_SIZE) {
            if ( !( NDSCaptureFlag && Bytes) ) {
                RetCode = PS_ERR_INTERNAL_ERROR;
                goto CommonExit;
            }
        }
        Count++;


        /** Skip the entry with a null job name **/

        if (JobNameArea.JobName[0] == 0) {
            continue;
        }
    
        /** Is this the job name we are looking for? **/

        if (!_strcmpi(pSearchJobName, JobNameArea.JobName)) {
            break;
        }
    }

    /** See if we found the job name **/

    if (Count > PrintConHeader.NumberOfRecords) {
        if (GetDefault) {
            RetCode = PS_ERR_GETTING_DEFAULT;
        }
        else {
            RetCode = PS_ERR_READING_RECORD;
        }
        goto CommonExit;
    }

    /*
     * The Job offset starts at the beginning of the third section.
     * The third section starts after the Header and after the
     * 50 record blocks.
     */
    if ( Version40 ) {
        SetFilePointer( stream,
            PRINTCON_40_HEADER_SIZE +
            ( PrintConHeader.NumberOfBlocks * 50) * JOB_NAME_AREA_SIZE +
            JobNameArea.JobRecordOffset,
            NULL,
            FILE_BEGIN );
    }
    else {
        SetFilePointer( stream,
            PRINTCON_41_HEADER_SIZE +
            ( PrintConHeader.NumberOfBlocks * 50) * JOB_NAME_AREA_SIZE +
            JobNameArea.JobRecordOffset,
            NULL,
            FILE_BEGIN );
    }

    memset((PBYTE)&JobRecord, 0, sizeof(JobRecord));

    if ( !ReadFile( stream, (PBYTE) &JobRecord, JOB_RECORD_AREA_SIZE, &Bytes, NULL) ) {
        RetCode = PS_ERR_READING_RECORD;
        goto CommonExit;
    }

    if (Bytes < JOB_RECORD_AREA_SIZE) {
        if ( !( NDSCaptureFlag && Bytes) ) {
            RetCode = PS_ERR_READING_RECORD;
            goto CommonExit;
        }
    }

    memset(pJobRecord, 0, PS_JOB_RECORD_SIZE);

    if (JobRecord.NotifyWhenDone) {
        pJobRecord->PrintJobFlag |= PS_JOB_NOTIFY;
    }
    if (JobRecord.BannerFlag) {
        pJobRecord->PrintJobFlag |= PS_JOB_PRINT_BANNER;
    }
    if (JobRecord.DataType) {
        pJobRecord->PrintJobFlag |= PS_JOB_EXPAND_TABS;
    }
    if (JobRecord.FormFeed) {
        pJobRecord->PrintJobFlag |= PS_JOB_NO_FORMFEED;
    }
    if (JobRecord.AutoEndCap) {
        pJobRecord->PrintJobFlag |= PS_JOB_AUTO_END;
    }
    if (JobRecord.TimeoutCount) {
        pJobRecord->PrintJobFlag |= PS_JOB_TIMEOUT;
    }
    if (JobRecord.Destination) {
        pJobRecord->PrintJobFlag |= PS_JOB_DS_PRINTER;
    }
    if ( JobRecord.SystemType ) {
        pJobRecord->PrintJobFlag |= PS_JOB_ENV_DS;
    }

    pJobRecord->Copies                    = JobRecord.NumberOfCopies;
    pJobRecord->TabSize                   = JobRecord.TabSize;
    pJobRecord->TimeOutCount              = JobRecord.TimeoutCount;
    pJobRecord->LocalPrinter              = JobRecord.LocalPrinter;

    strcpy(pJobRecord->Mode,                JobRecord.Mode);
    strcpy(pJobRecord->Device,              JobRecord.Device);
    strcpy(pJobRecord->FormName,            JobRecord.FormName);
    strcpy(pJobRecord->BannerName,          JobRecord.BannerName);

    if ( JobRecord.SystemType ) {
        ConvertUnicodeToAscii( JobRecord.u.DSObjectName ); 
        strcpy(pJobRecord->u.DSObjectName,  JobRecord.u.DSObjectName);
    }
    else {
        strcpy(pJobRecord->u.NonDS.PrintQueue,  JobRecord.u.NonDS.QueueName);
        strcpy(pJobRecord->u.NonDS.FileServer,  JobRecord.u.NonDS.Server);
    }

    if (GetDefault && pJobName) {
        strcpy(pJobName, JobNameArea.JobName);
    }

    if (pOwner) {
        *pOwner = 0;
    }

CommonExit:
    if (stream != NULL) {
        
	// 07/19/96 cjc (Citrix code merge) 
	//              fclose causes a trap cause it expects *stream but 
	//              really should be using CloseHandle anyway.
        CloseHandle( stream );
//        if ( NDSCaptureFlag ) 
//            CloseHandle( stream );
//        else
//            fclose( stream );
    }

    return RetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\parspath.c ===
/*************************************************************************
*
*  PARSPATH.C
*
*  NetWare parsing routines, ported from DOS
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\PARSPATH.C  $
*  
*     Rev 1.3   22 Jan 1996 16:48:38   terryt
*  Add automatic attach query during map
*  
*     Rev 1.2   22 Dec 1995 14:26:16   terryt
*  Add Microsoft headers
*  
*     Rev 1.1   22 Dec 1995 11:08:50   terryt
*  Fixes
*  
*     Rev 1.0   15 Nov 1995 18:07:48   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:23:34   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:11:00   terryt
*  Initial revision.
*  
*************************************************************************/

/*++

Copyright (c) 1994  Micro Computer Systems, Inc.

Module Name:

    nwlibs\parspath.c

Abstract:

    Directory APIs.

Author:

    Shawn Walker (v-swalk) 10-10-1994

Revision History:

--*/
#include "common.h"
#include <ctype.h>
#include <direct.h>
#include "inc\nwlibs.h"


/*++
*******************************************************************

        ParsePath

Routine Description:

        Parse the path string.

Arguments:

        pPath = The pointer to the path to parse.
        pServerName = The pointer to return the server name.
        pVolumeName = The pointer to return the volume name.
        pDirPath = The pointer to return the directory path.

Return Value:

        0x0000      SUCCESSFUL
        0x000F      INVALID_DRIVE
        0x8800      Unknown error

*******************************************************************
--*/
unsigned int
ParsePath(
    unsigned char   *pPath,
    unsigned char   *pServerName,           //OPTIONAL
    unsigned char   *pVolumeName,           //OPTIONAL
    unsigned char   *pDirPath               //OPTIONAL
    )
{
    unsigned char     *p, *p2;
    unsigned int       Result;
    unsigned int       Remote;
    unsigned int       NcpError = 0;
    unsigned char      DriveNumber = (unsigned char)-1;
    unsigned char      CurrentPath[64];
    unsigned char      RootPath[NCP_MAX_PATH_LENGTH];
    unsigned char      ServerName[NCP_MAX_PATH_LENGTH];
    unsigned char     *pRootDir;
    unsigned char      NetWarePath[NCP_MAX_PATH_LENGTH];
    unsigned char      VolumeName[NCP_VOLUME_LENGTH];
    unsigned int       LocalDriveForce = FALSE;

    RootPath[0] = 0;
    VolumeName[0] = 0;
    ServerName[0] = 0;

    if ( pServerName )
       *pServerName = '\0';

    /** See if there is a volume on the path **/

    p = pPath;
    while (*p != ':' && *p) {
        p++;
    }

    if (*p == ':') {
        *p = 0;

        /**
            Check to see if this is a drive letter.  The volume must
            be 2 characters or more.
        **/

        if ((p - pPath) == 1) {

            /** Make sure it is a valid alpha char **/

            if (!isalpha((int) *pPath)) {
                return 0x000F;
            }

            *pPath = (unsigned char) toupper((int) *pPath);

            /** Make it a drive number **/

            DriveNumber = (unsigned char) (*pPath - 'A');
            GetDriveStatus ((unsigned short)(DriveNumber+1),
                            NETWARE_FORMAT_SERVER_VOLUME,
                            NULL,
                            NULL,
                            RootPath,
                            NULL,
                            NULL);
            pRootDir = strchr (RootPath, ':');
            if (pRootDir)
            {
                /*
                 * Setup the pServerName here
                 */

                 pRootDir[0] = '\0';
                 p2 = RootPath;
                 while (*p2)
                 {
                    if (*p2 == '\\' || *p2 == '/')
                    {
                        *p2++ = 0;
                        strcpy(ServerName, RootPath);
                        if (pServerName) {
                            strcpy(pServerName, RootPath);
                        }
                        break;
                    }
                    p2++;
                }
                strcpy (RootPath, pRootDir+1);
            }
            else
                RootPath[0] = 0;
        }
        else {

            DriveNumber = 0;
            LocalDriveForce = TRUE;

            /**
                If there is a server name, save the server name
                and set the error code to 0x880F but still parse
                the path.  This just means that there is no connection
                for this server.  Even if we do have one.
            **/

            p2 = pPath;
            while (*p2) {
                if (*p2 == '\\' || *p2 == '/') {
                    *p2++ = 0;

                    strcpy(ServerName, pPath);
                    if (pServerName) {
                        strcpy(pServerName, pPath);
                    }
                    pPath = p2;

                    NcpError = 0x880F;
                    break;
                }
                p2++;
            }

            if (NcpError == 0x880F) {
                /**
                    Do any attach processing.
                 **/

                NcpError = DoAttachProcessing( ServerName );

            }

            strcpy(VolumeName, pPath);
        }

        /** Get the directory **/

        p++;
        pPath = p;
    }

    /**
        If we did not get the drive letter of volume name
        from above, then get the current drive we are on.
    **/

    if (DriveNumber == (unsigned char) -1) {
        DriveNumber = (UCHAR) _getdrive();
    }

    /*
     * Use the PREFERRED_SERVER for 3X logins if no server name
     * was specified.  
     */
    if (pServerName && !fNDS && !pServerName[0] ) {
        strcpy( pServerName, PREFERRED_SERVER );
    }

    if (pVolumeName) {

        /**
            Check if the drive is remote, if so, then go get the path
            from the server.
        **/
        if ( LocalDriveForce ) {
            Result = 0;
            Remote = 0;
        }
        else {
            Result = IsDriveRemote(DriveNumber, &Remote);

        }

        if (NcpError != 0x880F && !VolumeName[0] && (Result || !Remote)) {
            pVolumeName[0] = (unsigned char) (DriveNumber + 'A');
            pVolumeName[1] = 0;
        }
        else {
            if (VolumeName[0]) {
                strcpy(pVolumeName, VolumeName);
            }
            else {
                Result = NTGetNWDrivePath( DriveNumber, NULL, NetWarePath );
                if (Result) {
                    return Result;
                }

                p = NetWarePath;
                while (*p != ':' && *p) {
                    p++;
                }

                if (*p == ':') {
                    *p = 0;
                }
                strcpy(pVolumeName, NetWarePath);
            }
        }
    }

    if (pDirPath) {

        memset(CurrentPath, 0, sizeof(CurrentPath));

        if (VolumeName[0]) {
            strcpy(pDirPath, pPath);
        }
        else {
            Result = NTGetCurrentDirectory(DriveNumber, CurrentPath);
            if (Result) {
                CurrentPath[0] = 0;
            }
            else  {
                /* 
                 * Skip the drive letter
                 */
                if ( CurrentPath[0] ) {
                    int i;
                    for ( i = 0; ;i++ ) {
                        CurrentPath[i] = CurrentPath[i+3];
                        if ( !CurrentPath[i] )
                            break;
                    }
                }
            }

            if (CurrentPath[0] == 0) {
                if ( (*pPath == '\\') || ( *pPath == '/' ) ) {
                    sprintf(pDirPath, "%s%s", RootPath, pPath);
                }
                else if ( !(*pPath) ) {
                    sprintf(pDirPath, "%s", RootPath);
                }
                else {
                    sprintf(pDirPath, "%s\\%s", RootPath, pPath);
                }
            }
            else {
                if (*pPath) {
                    if ( (*pPath == '\\') || ( *pPath == '/' ) ) {
                        strcpy (pDirPath, RootPath);
                        if (pPath[1]) {
                            strcat(pDirPath, pPath);
                        }
                    }
                    else {
                        sprintf(pDirPath, "%s\\%s\\%s", RootPath, CurrentPath, pPath);
                    }
                }
                else {
                    sprintf(pDirPath, "%s\\%s", RootPath, CurrentPath);
                }
            }
        }

        /** Convert the / in the path to \ **/
        for (p = pDirPath; ( p && ( *p != 0 ) ) ; p++)
        {
            if (*p == '/')
                *p = '\\';
        }
    }

    return NcpError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\strings.c ===
/*************************************************************************
*
*  STRINGS.C
*
*  Various strings
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\STRINGS.C  $
*  
*     Rev 1.1   22 Dec 1995 14:26:50   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:08:06   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 16:23:56   terryt
*  Capture support
*  
*     Rev 1.0   15 May 1995 19:11:06   terryt
*  Initial revision.
*  
*************************************************************************/

#include "common.h"

/*
 * These haven't been put into resource files, because they aren't user
 * messages.  Most are control information or variables.  To do this
 * right, all output and string processing would have to be changed to
 * unicode.  This can't be done until NetWare and International are
 * understood.
 */


char *__GREETING__[3]       = {"morning", "afternoon", "evening"};
char *__AMPM__[2]           = {"am", "pm"};
char *__Day__[7]            = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
char *__Month__[12]         = {"January", "Feburary", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
char __DEL__[]              ="DELETE";
char __REM__[]              ="REMOVE";
char __INS__[]              ="INSERT";
char __ROOT__[]             ="ROOT";
char __NEXT__[]             ="NEXT";

/*
 * Capture strings
 */
unsigned int CaptureStringsLoaded = FALSE;
WCHAR __DISABLED__[256];
WCHAR __ENABLED__[256];
WCHAR __YES__[256];
WCHAR __NO__[256];
WCHAR __SECONDS__[256];
WCHAR __CONVERT_TO_SPACE__[256];
WCHAR __NO_CONVERSION__[256];
WCHAR __NOTIFY_USER__[256];
WCHAR __NOT_NOTIFY_USER__[256];
WCHAR __NONE__[256];

char __JOB_DESCRIPTION__[]   ="LPT%d Catch";

char __OPT_NO__[]            ="No";

char __SHOW__[]              ="SHOW";

char __NOTIFY__[]            ="NOTIFY";
char __SHORT_FOR_NOTIFY__[]  ="NOTI";

char __NONOTIFY__[]          ="NONOTIFY";
char __SHORT_FOR_NONOTIFY__[]="NNOTI";

char __AUTOENDCAP__[]            ="AUTOENDCAP";
char __SHORT_FOR_AUTOENDCAP__[]  ="AU";

char __NOAUTOENDCAP__[]            ="NOAUTOENDCAP";
char __SHORT_FOR_NOAUTOENDCAP__[]  ="NA";

char __NOTABS__[]            ="NOTABS";
char __SHORT_FOR_NOTABS__[]  ="NT";

char __NOBANNER__[]            ="NOBANNER";
char __SHORT_FOR_NOBANNER__[]  ="NB";

char __FORMFEED__[]            ="FORMFEED";
char __SHORT_FOR_FORMFEED__[]  ="FF";

char __NOFORMFEED__[]            ="NOFORMFEED";
char __SHORT_FOR_NOFORMFEED__[]  ="NFF";

char __KEEP__[]            ="KEEP";
char __SHORT_FOR_KEEP__[]  ="K";

char __TIMEOUT__[]            ="TIMEOUT";
char __SHORT_FOR_TIMEOUT__[]  ="TI";

char __LOCAL__[]            ="LOCAL";
char __SHORT_FOR_LOCAL__[]  ="L";

char __LOCAL_3__[]          ="LPT";
char __LOCAL_2__[]          ="LP";

char __JOB__[]              ="JOB";
char __SHORT_FOR_JOB__[]    ="J";

char __SERVER__[]            ="SERVER";
char __SHORT_FOR_SERVER__[]  ="S";

char __QUEUE__[]            ="QUEUE";
char __SHORT_FOR_QUEUE__[]  ="Q";

char __PRINTER__[]            ="PRINTER";
char __SHORT_FOR_PRINTER__[]  ="P";

char __CREATE__[]            ="CREATE";
char __SHORT_FOR_CREATE__[]  ="CR";

char __FORM__[]            ="FORM";
char __SHORT_FOR_FORM__[]  ="F";

char __COPIES__[]            ="COPIES";
char __SHORT_FOR_COPIES__[]  ="C";

char __TABS__[]            ="TABS";
char __SHORT_FOR_TABS__[]  ="T";

char __NAME__[]            ="NAME";
char __SHORT_FOR_NAME__[]  ="NAM";

char __BANNER__[]            ="BANNER";
char __SHORT_FOR_BANNER__[]  ="B";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\unc.c ===
/*************************************************************************
*
*  UNC.C
*
*  NetWare format to UNC format
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\UNC.C  $
*  
*     Rev 1.4   10 Apr 1996 14:24:00   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.4   12 Mar 1996 19:56:18   terryt
*  Relative NDS names and merge
*  
*     Rev 1.3   04 Jan 1996 18:57:26   terryt
*  Bug fixes reported by MS
*  
*     Rev 1.2   22 Dec 1995 14:27:04   terryt
*  Add Microsoft headers
*  
*     Rev 1.1   22 Dec 1995 11:09:18   terryt
*  Fixes
*  
*     Rev 1.0   15 Nov 1995 18:08:14   terryt
*  Initial revision.
*  
*     Rev 1.1   23 May 1995 19:37:24   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:11:10   terryt
*  Initial revision.
*  
*************************************************************************/
#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "inc/common.h"

/********************************************************************

        NTNWtoUNCFormat

Routine Description:

        Given a connection handle and a path, change it to UNC format
        if it's in NetWare format.  I.E.

        SYS:\usr\terryt   ==>   \\HELIUM\SYS\usr\terryt

        Don't do the conversion if it's not in NetWare format.

Arguments:

        ConnectionHandle   -  Connection Handle
        NetWarePath        -  Input original path

Return Value:
        UNC string

 *******************************************************************/
char *
NTNWtoUNCFormat( char * NetWarePath )
{
    static char UNCPath[1024];
    unsigned int Result;
    char ServerName[48];
    char * p;
    char * q;

    /*
     *  If it's UNC already, leave it alone
     */
    if ( ( NetWarePath[0] == '\\' ) && ( NetWarePath[1] == '\\' ) )
        return NetWarePath;
    if ( ( NetWarePath[0] == '/' ) && ( NetWarePath[1] == '/' ) )
        return NetWarePath;

    /*
     *  if it's drive:dir, leave it alone
     */
    if ( NetWarePath[0] && ( NetWarePath[1] == ':' ) )
        return NetWarePath;

    /*
     *  if it's not volume:dir, leave it alone
     */
    p = strchr( NetWarePath, ':' );
    if ( !p )
        return NetWarePath;

    /*
     * if slashes before :, it must be a file server
     */
    q = strchr( NetWarePath, '\\' );
    if ( q && ( q < p ) )
    {
        strcpy( UNCPath, "\\\\" );
        *p = '\0';
        strcat( UNCPath, NetWarePath );
        if (( *(p + 1) != '\\' ) && ( *(p + 1) != '/' ) )
           strcat( UNCPath, "\\" );
        strcat( UNCPath, p + 1 );
        *p = ':';
        return UNCPath;
    }

    q = strchr( NetWarePath, '/' );
    if ( q && ( q < p ) )
    {
        strcpy( UNCPath, "\\\\" );
        *q = '\\';
        *p = '\0';
        strcat( UNCPath, NetWarePath );
        if (( *(p + 1) != '\\' ) && ( *(p + 1) != '/' ) )
           strcat( UNCPath, "\\" );
        strcat( UNCPath, p + 1 );
        *q = '/';
        *p = ':';
        return UNCPath;
    }

    strcpy( UNCPath, "\\\\" );
    strcat( UNCPath, PREFERRED_SERVER );
    strcat( UNCPath, "\\" );
    *p = '\0';
    strcat( UNCPath, NetWarePath );
    if (( *(p + 1) != '\\' ) && ( *(p + 1) != '/' ) )
        strcat( UNCPath, "\\" );
    strcat( UNCPath, p + 1 );
    *p = ':';

    return UNCPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\inc\dbcs.h ===
/*************************************************************************
*
*  DBCS.H
*
*  DBCS header file
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\INC\VCS\DBCS.H  $
*  
*     Rev 1.1   22 Dec 1995 14:20:14   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:05:32   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 17:03:40   terryt
*  CAPTURE support
*  
*     Rev 1.0   15 May 1995 19:09:32   terryt
*  Initial revision.
*  
*************************************************************************/
unsigned char *NWAnsiNext(unsigned char *puch);
unsigned char *NWAnsiPrev(unsigned char *psz, unsigned char *puch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\version.c ===
/*************************************************************************
*
*  VERSION.C
*
*  Shell version information
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\VERSION.C  $
*  
*     Rev 1.2   10 Apr 1996 14:24:08   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:56:28   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:27:10   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:08:18   terryt
*  Initial revision.
*  
*     Rev 1.1   26 Jul 1995 14:17:24   terryt
*  Clean up comments
*  
*     Rev 1.0   15 May 1995 19:11:12   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "nwscript.h"


/*
 *  MSDOS is not neccessarily the best thing to put out,
 *  maybe Windows_NT, NT or NTDOS.  The OS_VERSION is also a problem.
 *  The script variables don't neccessarily have to match the DOS variables.
 *
 *  The shell version numbers may change with 4.X support.
 */
 
#define CLIENT_ID_STRING "MSDOS\0V5.00\0IBM_PC\0IBM"
#define CLIENT_SHELL_MAJOR  0x03
#define CLIENT_SHELL_MINOR  0x1a
#define CLIENT_SHELL_NUMBER 0x00


void
NTGetVersionOfShell( char * buffer,
                     unsigned char * shellmajor,
                     unsigned char * shellminor,
                     unsigned char * shellnum )
{
    *shellmajor = CLIENT_SHELL_MAJOR;
    *shellminor = CLIENT_SHELL_MINOR;
    *shellnum = CLIENT_SHELL_NUMBER;
    memcpy( buffer, CLIENT_ID_STRING, strlen(CLIENT_ID_STRING));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\wide.c ===
/*************************************************************************
*
*  WIDE.C
*
*  Wide character translation routines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\VCS\WIDE.C  $
*  
*     Rev 1.2   10 Apr 1996 14:24:14   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.2   12 Mar 1996 19:56:36   terryt
*  Relative NDS names and merge
*  
*     Rev 1.1   22 Dec 1995 14:27:18   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:08:20   terryt
*  Initial revision.
*  
*     Rev 1.1   23 May 1995 19:37:32   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:11:14   terryt
*  Initial revision.
*  
*************************************************************************/

#include <stdio.h>
#include <direct.h>
#include <time.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "nwscript.h"


/********************************************************************

        szToWide

Routine Description:

        Given a single byte character string, convert to wide

Arguments:

        lpszW   - Wide character string returned
        lpszC   - Single character string input
        nSize   - length of Wide character buffer

Return Value:
        0 = success
        else NT error

 *******************************************************************/
DWORD
szToWide( 
    LPWSTR lpszW, 
    LPCSTR lpszC, 
    INT nSize 
    )
{
    if (!MultiByteToWideChar(CP_OEMCP,
                             MB_PRECOMPOSED,
                             lpszC,
                             -1,
                             lpszW,
                             nSize))
    {
        return (GetLastError()) ;
    }
    
    return NO_ERROR ;
}

/********************************************************************

        WideTosz

Routine Description:

        Given a wide character string, convert to single

Arguments:

        lpszC   - Single character string returned
        lpszW   - Wide character string input
        nSize   - length of single character buffer

Return Value:
        0 = success
        else NT error

 *******************************************************************/
DWORD
WideTosz( 
    LPSTR lpszC, 
    LPWSTR lpszW, 
    INT nSize 
    )
{
    if (!WideCharToMultiByte(CP_OEMCP,
                             0,
                             (LPCWSTR) lpszW,
                             -1,
                             lpszC,
                             nSize,
                             NULL, 
                             NULL))
    {
        return (GetLastError()) ;
    }
    
    return NO_ERROR ;
}

/********************************************************************

        ConvertUnicodeToAscii

Routine Description:

        Given a wide character string, convert to single

Arguments:

        Buffer - buffer to be converted

Return Value:
        none

 *******************************************************************/
void
ConvertUnicodeToAscii( PVOID Buffer ) 
{
    LPCWSTR lpszW = Buffer;
    BYTE Destination[1024];

    WideTosz( (LPSTR)Destination, (LPWSTR)Buffer, 1024 );

    strcpy( Buffer, Destination );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\inc\ntnw.h ===
/*************************************************************************
*
*  NTNW.H
*
*  NT specific NetWare defines
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\INC\VCS\NTNW.H  $
*  
*     Rev 1.1   22 Dec 1995 14:20:20   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:05:34   terryt
*  Initial revision.
*  
*     Rev 1.0   15 May 1995 19:09:36   terryt
*  Initial revision.
*  
*************************************************************************/

/*
 * This must be kept in sync with the NWAPI32 library.  This are
 * internal data structures and routines.
 */
typedef struct _NWC_SERVER_INFO {
    HANDLE          hConn ;
    UNICODE_STRING  ServerString ;
} NWC_SERVER_INFO, *PNWC_SERVER_INFO ;

extern NTSTATUS
NwlibMakeNcp(
    IN HANDLE DeviceHandle,
    IN ULONG FsControlCode,
    IN ULONG RequestBufferSize,
    IN ULONG ResponseBufferSize,
    IN PCHAR FormatString,
    ...                           // Arguments to FormatString
    );

DWORD szToWide( LPWSTR lpszW, LPCSTR lpszC, INT nSize );
DWORD WideTosz( LPSTR lpszC, LPWSTR lpszW, INT nSize );

extern TCHAR NW_PROVIDER[60];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\inc\common.h ===
/*************************************************************************
*
*  COMMON.H
*
*  Common header file
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\INC\VCS\COMMON.H  $
*  
*     Rev 1.3   22 Dec 1995 14:20:06   terryt
*  Add Microsoft headers
*  
*     Rev 1.2   22 Nov 1995 15:44:26   terryt
*  Use proper NetWare user name call
*  
*     Rev 1.1   20 Nov 1995 15:18:46   terryt
*  Context and capture changes
*  
*     Rev 1.0   15 Nov 1995 18:05:30   terryt
*  Initial revision.
*  
*     Rev 1.2   25 Aug 1995 17:03:32   terryt
*  CAPTURE support
*  
*     Rev 1.1   26 Jul 1995 16:01:12   terryt
*  Get rid of unneccessary externs
*  
*     Rev 1.0   15 May 1995 19:09:28   terryt
*  Initial revision.
*  
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <nds.h>
#include <ndsapi32.h>
#include <nwapi32.h>

#include "dbcs.h"
#include "inc\nwlibs.h"

#include "nwscript.h"


#define MAX_NAME_LEN      48
#define MAX_PASSWORD_LEN  128
#define MAX_PATH_LEN      304  //From NW programmer's guide p268.

/* for map only */
#define MAX_VOLUME_LEN    256      // 17 for 3X
#define MAX_DIR_PATH_LEN  256

/* for capture only */
#define MAX_JOB_NAME_LEN     32
#define MAX_QUEUE_NAME_LEN   1024
#define MAX_BANNER_USER_NAME 13

/* for common only */
#define PATH_SEPERATOR   ";"

/* For building time/date strings */

#define TIMEDATE_SIZE 64

/*
    Function definations
 */
/* used by login.c and script.c */
void BreakOff(void);
void BreakOn(void);

/* used by common setpass*/
void xstrupr(char *buffer);
void ReadPassword(char * Password);

/* used by map attach login*/
int  CAttachToFileServer(char *ServerName, unsigned int *pConn, int * pbAlreadyAttached);
int  Login(char *UserName, char *ServerName, char *Password, int bReadPassword);

/* used by map attach login*/
int  ReadName (char * Name);

/* used by map login */
void DisplayError(int error ,char *functionName);
char * GetDosEnv1(void);
char * NWGetPath(void);
int GetRestEnvLen (char *lpRest);

int MemorySegmentLargeEnough (int nInsertByte);
int  IsSearchDrive(int driveNum);
int  GetDriveFromSearchNumber (int searchNumber);

/* used by login logout*/
void SetLoginDirectory (PBYTE);

/* used by all */
int  Map (char * buffer);
void DisplayMapping(void);
int  CGetDefaultConnectionID ( unsigned int * pConn );
int  GetConnectionInfo (unsigned int conn,
                        char * serverName,
                        char * userName,
                        unsigned int * pconnNum,
                        unsigned char * loginTime);

extern char * LOGIN_NAME;
extern char *NDS_FULL_NAME;
extern char *REQUESTER_CONTEXT;
extern char *TYPED_USER_NAME;
extern PWCHAR TYPED_USER_NAME_w;
extern PBYTE NDSTREE;
extern PWCHAR NDSTREE_w;
extern UNICODE_STRING NDSTREE_u;
extern PBYTE PREFERRED_SERVER;

/*
    String definitions.
 */
extern char *__Day__[7];
extern char *__Month__[12];
extern char *__AMPM__[2];
extern char *__GREETING__[3];

extern char __DEL__[];
extern char __REM__[];
extern char __INS__[];
extern char __ROOT__[];
extern char __NEXT__[];

extern char __AUTOENDCAP__[];
extern char __BANNER__[];
extern char __COPIES__[];
extern char __CREATE__[];
extern WCHAR __DISABLED__[];
extern WCHAR __ENABLED__[];
extern WCHAR __YES__[];
extern WCHAR __NO__[];
extern WCHAR __SECONDS__[];
extern WCHAR __CONVERT_TO_SPACE__[];
extern WCHAR __NO_CONVERSION__[];
extern WCHAR __NOTIFY_USER__[];
extern WCHAR __NOT_NOTIFY_USER__[];
extern WCHAR __NONE__[];
extern char __FORMFEED__[];
extern char __FORM__[];
extern char __JOB_DESCRIPTION__[];
extern char __JOB__[];
extern char __KEEP__[];
extern char __LOCAL__[];
extern char __LOCAL_2__[];
extern char __LOCAL_3__[];
extern char __NAME__[];
extern char __NOAUTOENDCAP__[];
extern char __NOBANNER__[];
extern char __NOFORMFEED__[];
extern char __NONOTIFY__[];
extern char __NOTABS__[];
extern char __NOTIFY__[];
extern char __QUEUE__[];
extern char __PRINTER__[];
extern char __OPT_NO__[];
extern char __SERVER__[];
extern char __SHORT_FOR_AUTOENDCAP__[];
extern char __SHORT_FOR_BANNER__[];
extern char __SHORT_FOR_COPIES__[];
extern char __SHORT_FOR_CREATE__[];
extern char __SHORT_FOR_FORMFEED__[];
extern char __SHORT_FOR_FORM__[];
extern char __SHORT_FOR_JOB__[];
extern char __SHORT_FOR_KEEP__[];
extern char __SHORT_FOR_LOCAL__[];
extern char __SHORT_FOR_NAME__[];
extern char __SHORT_FOR_NOAUTOENDCAP__[];
extern char __SHORT_FOR_NOBANNER__[];
extern char __SHORT_FOR_NOFORMFEED__[];
extern char __SHORT_FOR_NONOTIFY__[];
extern char __SHORT_FOR_NOTABS__[];
extern char __SHORT_FOR_NOTIFY__[];
extern char __SHORT_FOR_QUEUE__[];
extern char __SHORT_FOR_PRINTER__[];
extern char __SHORT_FOR_SERVER__[];
extern char __SHORT_FOR_TABS__[];
extern char __SHORT_FOR_TIMEOUT__[];
extern char __SHOW__[];
extern char __TABS__[];
extern char __TIMEOUT__[];

extern unsigned int CaptureStringsLoaded;
extern unsigned int fNDS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\time.c ===
/*
 * TIME.C - Various time subroutines needed by NetWare Login Script
 *
 *  Copyright (c) 1995 Microsoft Corporation
 */

#include "common.h"

// Needed to convert netware net date to DOS date
#define _70_to_80_bias        0x012CEA600L
#define SECS_IN_DAY (60L*60L*24L)
#define SEC2S_IN_DAY (30L*60L*24L)
#define FOURYEARS        (3*365+366)

WORD MonTotal[] = { 0,                       // dummy entry for month 0
        0,                                   // days before Jan 1
        31,                                  // days before Feb 1
        31+28,                               // days before Mar 1
        31+28+31,                            // days before Apr 1
        31+28+31+30,                         // days before May 1
        31+28+31+30+31,                      // days before Jun 1
        31+28+31+30+31+30,                   // days before Jul 1
        31+28+31+30+31+30+31,                // days before Aug 1
        31+28+31+30+31+30+31+31,             // days before Sep 1
        31+28+31+30+31+30+31+31+30,          // days before Oct 1
        31+28+31+30+31+30+31+31+30+31,       // days before Nov 1
        31+28+31+30+31+30+31+31+30+31+30,    // days before Dec 1
        31+28+31+30+31+30+31+31+30+31+30+31  // days before end of year
};

#define YR_MASK         0xFE00
#define LEAPYR_MASK     0x0600
#define YR_BITS         7
#define MON_MASK        0x01E0
#define MON_BITS        4
#define DAY_MASK        0x001F
#define DAY_BITS        5

#define HOUR_MASK       0xF800
#define HOUR_BITS       5
#define MIN_MASK        0x07E0
#define MIN_BITS        6
#define SEC2_MASK       0x001F
#define SEC2_BITS       5

static void NetToDosDate( DWORD time, WORD * dosdate, WORD * dostime )
{
        DWORD secs, days;
        WORD r;

    time = (time - _70_to_80_bias) / 2;     // # of 2 second periods since 1980
        secs = time % SEC2S_IN_DAY;         // 2 second period into day
        days = time / SEC2S_IN_DAY;         // days since Jan 1 1980

        r = (WORD) ( secs % 30 );           // # of 2 second steps
        secs /= 30;
        r |= (secs % 60) << SEC2_BITS;              // # of minutes
        r |= (secs / 60) << (SEC2_BITS+MIN_BITS);     // # of hours
        *dostime = r;

        r = (WORD) ( days / FOURYEARS );// (r) = four year period past 1980
        days %= FOURYEARS;              // (days) = days into four year period
        r *= 4;                         // (r) = years since 1980 (within 3)

        if (days == 31+28) {
                //* Special case for FEB 29th
                r = (r<<(MON_BITS+DAY_BITS)) + (2<<DAY_BITS) + 29;
        } else {
                if (days > 31+28)
                        --days;         // compensate for leap year
                while (days >= 365) {
                        ++r;
                        days -= 365;
                }

                for (secs = 1; days >= MonTotal[secs+1] ; ++secs)
                        ;
                days -= MonTotal[secs];
                r <<= MON_BITS;
                r += (WORD)secs;
                r <<= DAY_BITS;
                r += (WORD)days+1;
        }
        *dosdate = r;
}


void        nwShowLastLoginTime(VOID)
{
        LONG lTime = 0L;
        SYSTEMTIME st;
        FILETIME ft;
        TIME_ZONE_INFORMATION tz;
        WCHAR szTimeBuf[TIMEDATE_SIZE];
        WCHAR szDateBuf[TIMEDATE_SIZE];
        int ret;
        WORD dostime, dosdate;
        DWORD tzStat;

        if ( ret = NDSGetUserProperty ("Last Login Time", (PBYTE)&lTime,
                             4, NULL, NULL) )
        {
                #ifdef DEBUG
                OutputDebugString("NWLSPROC: error getting LOGIN TIME\n\r");
                #endif
                return;
        }

        // From NetWare we get seconds from 1970, need to go through
        // several conversions to get system time for NLS

        // First deduct bias from UTC time to correct for local time
        tzStat = GetTimeZoneInformation(&tz);
        if ( tzStat != (DWORD)-1 ) {
                if (tzStat == TIME_ZONE_ID_STANDARD)
                        tz.Bias += tz.StandardBias;
                else if (tzStat == TIME_ZONE_ID_DAYLIGHT)
                        tz.Bias += tz.DaylightBias;
                lTime -= tz.Bias*60;
        }
#ifdef DEBUG
        else {
                OutputDebugString("NWLSPROC: GetTimeZoneInformation failed\n\r");
        }
#endif // DEBUG

        NetToDosDate( lTime, &dosdate, &dostime );
        DosDateTimeToFileTime ( dosdate, dostime, &ft );
        FileTimeToSystemTime ( &ft, &st );

#ifdef notdef
        // I don't understand this comment, this code doesn't seem to be
        // needed for NT. - terry
        //
        // This code will work on NT, but not on Win95.
        // Convert the resulting system (UTC) time to local time
        if ( GetTimeZoneInformation(&tz) != (DWORD)-1 ) {
                SYSTEMTIME utcTime = st;
                SystemTimeToTzSpecificLocalTime ( &tz, &utcTime, &st );
        }
#ifdef DEBUG
        else {
                OutputDebugString("NWLSPROC: GetTimeZoneInformation failed\n\r");
        }
#endif // DEBUG
#endif

        wcscpy(szTimeBuf, L"");
        ret = GetTimeFormat (        GetSystemDefaultLCID(),
                                                TIME_FORCE24HOURFORMAT|TIME_NOTIMEMARKER,
                                                &st,
                                                NULL,
                                                szTimeBuf,
                                                TIMEDATE_SIZE );
#ifdef DEBUG
        if ( !ret ) {
                char buf[80];
                wsprintf(buf,"NWLSPROC: GetTimeFormatA failure: %d sec:%ld\n\r",
                        GetLastError(), lTime );
                OutputDebugString(buf);
        }
#endif
        ret = GetDateFormat(LOCALE_USER_DEFAULT,
                                                DATE_LONGDATE,
                                                &st,
                                                NULL,
                                                szDateBuf,
                                                TIMEDATE_SIZE );
#ifdef DEBUG
        if ( !ret ) {
                char buf[80];
                wsprintf(buf,"NWLSPROC: GetDateFormatA failure: %d sec:%ld\n\r",
                        GetLastError(), lTime );
                OutputDebugString(buf);
        }
#endif

        DisplayMessage( IDR_LASTLOGIN, szDateBuf, szTimeBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\inc\nwlibs.h ===
/*************************************************************************
*
*  NWLIBS.H
*
*  Prototypes
*
*  Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\INC\VCS\NWLIBS.H  $
*  
*     Rev 1.1   22 Dec 1995 14:20:28   terryt
*  Add Microsoft headers
*  
*     Rev 1.0   15 Nov 1995 18:05:36   terryt
*  Initial revision.
*  
*     Rev 1.1   25 Aug 1995 17:03:46   terryt
*  CAPTURE support
*  
*     Rev 1.0   15 May 1995 19:09:40   terryt
*  Initial revision.
*  
*************************************************************************/

/*++

Copyright (c) 1994  Micro Computer Systems, Inc.

Module Name:

    nwlibs\nwlibs.h

Abstract:

    NW Libs prototypes.

Author:

    Shawn Walker (v-swalk) 10-10-1994

Revision History:

--*/

#ifndef _NWLIBS_H_
#define _NWLIBS_H_


/*++
*******************************************************************
        NetWare defaults
*******************************************************************
--*/
#define NCP_BINDERY_OBJECT_NAME_LENGTH      48
#define NCP_SERVER_NAME_LENGTH              NCP_BINDERY_OBJECT_NAME_LENGTH

#define NCP_MAX_PATH_LENGTH                 255
#define NCP_VOLUME_LENGTH                   256   // 16 in 3X


/*++
*******************************************************************
        Defines for GetDrive Status
*******************************************************************
--*/

#define NETWARE_UNMAPPED_DRIVE          0x0000
#define NETWARE_FREE_DRIVE              0x0000
#define NETWARE_LOCAL_FREE_DRIVE        0x0800
#define NETWARE_LOCAL_DRIVE             0x1000
#define NETWARE_NETWORK_DRIVE           0x2000
#define NETWARE_LITE_DRIVE              0x4000
#define NETWARE_PNW_DRIVE               0x4000
#define NETWARE_NETWARE_DRIVE           0x8000

#define NETWARE_FORMAT_NETWARE          0
#define NETWARE_FORMAT_SERVER_VOLUME    1
#define NETWARE_FORMAT_DRIVE            2
#define NETWARE_FORMAT_UNC              3

#define NCP_JOB_DESCRIPTION_LENGTH  50
#define NCP_BANNER_TEXT_LENGTH      13
#define NCP_FORM_NAME_LENGTH        13
#define NCP_QUEUE_NAME_LENGTH       65

#define CAPTURE_FLAG_PRINT_BANNER  0x80
#define CAPTURE_FLAG_EXPAND_TABS   0x40
#define CAPTURE_FLAG_NOTIFY        0x10
#define CAPTURE_FLAG_NO_FORMFEED   0x08
#define CAPTURE_FLAG_KEEP          0x04
#define DEFAULT_PRINT_FLAGS        0xC0
#define DEFAULT_BANNER_TEXT        "LPT:"

typedef struct _NETWARE_CAPTURE_FLAGS_RW {
    unsigned char   JobDescription[NCP_JOB_DESCRIPTION_LENGTH];
    unsigned char   JobControlFlags;
    unsigned char   TabSize;
    unsigned short  NumCopies;
    unsigned short  PrintFlags;
    unsigned short  MaxLines;
    unsigned short  MaxChars;
    unsigned char   FormName[NCP_FORM_NAME_LENGTH];
    unsigned char   Reserved1[9];
    unsigned short  FormType;
    unsigned char   BannerText[NCP_BANNER_TEXT_LENGTH];
    unsigned char   Reserved2;
    unsigned short  FlushCaptureTimeout;
    unsigned char   FlushCaptureOnClose;
} NETWARE_CAPTURE_FLAGS_RW, *PNETWARE_CAPTURE_FLAGS_RW, *LPNETWARE_CAPTURE_FLAGS_RW;

typedef struct _NETWARE_CAPTURE_FLAGS_RO {
    unsigned short  ConnectionID;
    unsigned short  SetupStringMaxLen;
    unsigned short  ResetStringMaxLen;
    unsigned char   LPTCaptureFlag;
    unsigned char   FileCaptureFlag;
    unsigned char   TimingOutFlag;
    unsigned char   InProgress;
    unsigned char   PrintQueueFlag;
    unsigned char   PrintJobValid;
    unsigned char   QueueName[NCP_QUEUE_NAME_LENGTH];
    unsigned char   ServerName[NCP_SERVER_NAME_LENGTH];
} NETWARE_CAPTURE_FLAGS_RO, *PNETWARE_CAPTURE_FLAGS_RO, *LPNETWARE_CAPTURE_FLAGS_RO;

#define NETWARE_CAPTURE_FLAGS_RO_SIZE    sizeof(NETWARE_CAPTURE_FLAGS_RO)
#define NETWARE_CAPTURE_FLAGS_RW_SIZE    sizeof(NETWARE_CAPTURE_FLAGS_RW)

#define PS_FORM_NAME_SIZE       12
#define PS_BANNER_NAME_SIZE     12
#define PS_BANNER_FILE_SIZE     12
#define PS_DEVICE_NAME_SIZE     32
#define PS_MODE_NAME_SIZE       32

#define PS_BIND_NAME_SIZE       NCP_BINDERY_OBJECT_NAME_LENGTH
#define PS_MAX_NAME_SIZE        514

/** Flags for the PS_JOB_REC structure PrintJobFlag field **/

#define PS_JOB_EXPAND_TABS          0x00000001    /* File type:0=Stream 1=Tab */
#define PS_JOB_NO_FORMFEED          0x00000002    /* Formfeed tail:0=Yes 1=No */
#define PS_JOB_NOTIFY               0x00000004    /* Notify:0=No 1=Yes */
#define PS_JOB_PRINT_BANNER         0x00000008    /* Banner:0=No 1=Yes */
#define PS_JOB_AUTO_END             0x00000010    /* Auto endcap:0=No 1=Yes */
#define PS_JOB_TIMEOUT              0x00000020    /* Enable T.O.:0=No 1=Yes */

#define PS_JOB_ENV_DS               0x00000040    /* Use D.S. Environment */
#define PS_JOB_ENV_MASK             0x000001C0    /* Bindery vs. D.S. Mask */

#define PS_JOB_DS_PRINTER           0x00000200    /* D.S. Printer not Queue */
#define PS_JOB_PRINTER_MASK         0x00000E00    /* D.S. Printer vs. Queue */

/** Default Flags **/

#define PS_JOB_DEFAULT              (NWPS_JOB_PRINT_BANNER | NWPS_JOB_AUTO_END)
#define PS_JOB_DEFAULT_COPIES       1             /* Default Number of Copies */
#define PS_JOB_DEFAULT_TAB          8             /* Default Tab Expansion */

typedef struct _PS_JOB_RECORD {
    DWORD   PrintJobFlag;
    SHORT   Copies;
    SHORT   TimeOutCount;
    UCHAR   TabSize;
    UCHAR   LocalPrinter;
    CHAR    FormName[PS_FORM_NAME_SIZE + 2];
    CHAR    Name[PS_BANNER_NAME_SIZE + 2];
    CHAR    BannerName[PS_BANNER_FILE_SIZE + 2];
    CHAR    Device[PS_DEVICE_NAME_SIZE + 2];
    CHAR    Mode[PS_MODE_NAME_SIZE + 2];
    union {
        struct {
            /** Pad structures on even boundries **/

            CHAR    FileServer[PS_BIND_NAME_SIZE + 2];
            CHAR    PrintQueue[PS_BIND_NAME_SIZE + 2];
            CHAR    PrintServer[PS_BIND_NAME_SIZE + 2];
        } NonDS;
        CHAR    DSObjectName[PS_MAX_NAME_SIZE];
    } u;
    UCHAR   Reserved[392];
} PS_JOB_RECORD, *PPS_JOB_RECORD;

#define PS_JOB_RECORD_SIZE      sizeof(PS_JOB_RECORD)


/*++
*******************************************************************
        FUCNTION PROTOTYPES
*******************************************************************
--*/

/** ATTACH.C **/

unsigned int
AttachToFileServer(
    unsigned char     *pServerName,
    unsigned int      *pNewConnectionId
    );

unsigned int
DetachFromFileServer(
    unsigned int ConnectionId
    );

/** NCP.C **/

unsigned int
GetBinderyObjectID(
    unsigned int       ConnectionHandle,
    char              *pObjectName,
    unsigned short     ObjectType,
    unsigned long     *pObjectId
    );


/** CONNECT.C **/

unsigned int
GetDefaultConnectionID(
    unsigned int *pConnectionHandle
    );

unsigned int
GetConnectionHandle(
    unsigned char *pServerName,
    unsigned int  *pConnectionHandle
    );

unsigned int
GetConnectionNumber(
    unsigned int  ConnectionHandle,
    unsigned int *pConnectionNumber
    );

unsigned int
GetFileServerName(
    unsigned int  ConnectionHandle,
    char          *pServerName
    );

unsigned int
GetInternetAddress(
    unsigned int     ConnectionHandle,
    unsigned int     ConnectionNumber,
    unsigned char   *pInternetAddress
    );

/** DRIVE.C **/

unsigned int
GetDriveStatus(
    unsigned short  DriveNumber,
    unsigned short  PathFormat,
    unsigned short *pStatus,
    unsigned int   *pConnectionHandle,
    unsigned char  *pRootPath,
    unsigned char  *pRelativePath,
    unsigned char  *pFullPath
    );

unsigned int
GetFirstDrive(
    unsigned short *pFirstDrive
    );

unsigned int
ParsePath(
    unsigned char   *pPath,
    unsigned char   *pServerName,           //OPTIONAL
    unsigned char   *pVolumeName,           //OPTIONAL
    unsigned char   *pDirPath               //OPTIONAL
    );

unsigned int
SetDriveBase(
    unsigned short   DriveNumber,
    unsigned char   *ServerName,
    unsigned int     DirHandle,
    unsigned char   *pDirPath
    );

unsigned int
DeleteDriveBase(
    unsigned short DriveNumber
    );

unsigned int
GetDirectoryPath(
    unsigned char  ConnectionHandle,
    unsigned char  Handle,
    unsigned char *pPath
    );

unsigned int
IsDriveRemote(
    unsigned char  DriveNumber,
    unsigned int  *pRemote
    );

/** CAPTURE.C **/

unsigned int
EndCapture(
    unsigned char LPTDevice
    );

#define PS_ERR_BAD_VERSION                  0x7770
#define PS_ERR_GETTING_DEFAULT              0x7773
#define PS_ERR_OPENING_DB                   0x7774
#define PS_ERR_READING_DB                   0x7775
#define PS_ERR_READING_RECORD               0x7776
#define PS_ERR_INTERNAL_ERROR               0x7779
#define PS_ERR_NO_DEFAULT_SPECIFIED         0x777B

unsigned int
PSJobGetDefault(
    unsigned int    ConnectionHandle,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    );

unsigned int
PSJobRead(
    unsigned int    ConnectionHandle,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    );

unsigned int
PS40JobGetDefault(
    unsigned int    NDSCaptureFlag,
    unsigned short  SearchFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    );

unsigned int
PS40JobRead(
    unsigned int    NDSCaptureFlag,
    unsigned char   *pOwner,
    unsigned char   *pJobName,
    PPS_JOB_RECORD  pJobRecord
    );

unsigned int
GetCaptureFlags(
    unsigned char        LPTDevice,
    PNETWARE_CAPTURE_FLAGS_RW pCaptureFlagsRW,
    PNETWARE_CAPTURE_FLAGS_RO pCaptureFlagsRO
    );

unsigned int
StartQueueCapture(
    unsigned int    ConnectionHandle,
    unsigned char   LPTDevice,
    unsigned char  *pServerName,
    unsigned char  *pQueueName
    );

unsigned int
GetDefaultPrinterQueue (
    unsigned int  ConnectionHandle,
    unsigned char *pServerName,
    unsigned char *pQueueName
    );

#endif /* _NWLIBS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\perf\nwdata.c ===
//
//  NWData.c
//
// This file contains the initalized Object and counter definition for NetWare
// redirector performance extensible DLL.
// This would be the place to add more counters and the change the definitions
// of the current ones.
// 
#include "windows.h"
#include <winperf.h>
#include "NWPerf.h"

NW_DATA_DEFINITION NWDataDefinition = {
    {   sizeof(NW_DATA_DEFINITION)+ 
        SIZE_OF_COUNTER_BLOCK,        // Total Bytes ( Size of this header, the counter definitions
                                      // and the size of the actual counter data )
        sizeof(NW_DATA_DEFINITION),   // Definition length ( This header and the counter definitions )
        sizeof(PERF_OBJECT_TYPE),     // Header Length ( This header )
        NWOBJ,                        // Object Name Title Index    
        0,                            // Object Name Title
        NWOBJ,                        // Object Help Title Index
        0,                            // Object Help Title
        PERF_DETAIL_NOVICE,           // Detail Level
        (sizeof(NW_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
        sizeof(PERF_COUNTER_DEFINITION), // Number of Counters
        0,                            // Default Counters
       -1,                            // On NT5, signifies no instances
        0,                            // Code Page
        {0,0},                        // Perf Time
        {0,0}                         // Perf Freq
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        388,
        0,
        389,
        0,
        -4,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        BYTES_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        406,
        0,
        391,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        IO_OPERATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        400,
        0,
        401,
        0,
        -1,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        PACKETS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        264,
        0,
        265,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        BYTES_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        266,
        0,
        267,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        NCPS_RECEIVED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        276,
        0,
        277,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        BYTES_TRANSMITTED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        278,
        0,
        279,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        NCPS_TRANSMITTED_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        10,
        0,
        289,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        RDR_READ_OPERATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        290,
        0,
        291,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        RANDOM_READ_OPERATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        292,
        0,
        293,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        READ_NCPS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        12,
        0,
        299,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        RDR_WRITE_OPERATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        300,
        0,
        301,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        RANDOM_WRITE_OPERATIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        302,
        0,
        303,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        WRITE_NCPS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        314,
        0,
        315,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SESSIONS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        316,
        0,
        317,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        RECONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        CONNECT_2X_ID,
        0,
        CONNECT_2X_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NETWARE_2X_CONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        CONNECT_3X_ID,
        0,
        CONNECT_3X_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NETWARE_3X_CONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        CONNECT_4X_ID,
        0,
        CONNECT_4X_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NETWARE_4X_CONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        326,
        0,
        327,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        SERVER_DISCONNECTS_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        PACKET_BURST_READ_ID,
        0,
        PACKET_BURST_READ_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKET_BURST_READ_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        PACKET_BURST_READ_TO_ID,
        0,
        PACKET_BURST_READ_TO_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKET_BURST_READ_TO_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        PACKET_BURST_WRITE_ID,
        0,
        PACKET_BURST_WRITE_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKET_BURST_WRITE_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        PACKET_BURST_WRITE_TO_ID,
        0,
        PACKET_BURST_WRITE_TO_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKET_BURST_WRITE_TO_OFFSET
    },
    {   sizeof(PERF_COUNTER_DEFINITION),
        PACKET_BURST_IO_ID,
        0,
        PACKET_BURST_IO_ID,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        PACKET_BURST_IO_OFFSET
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\perf\nwperf.h ===
//
//    MODULE: NWPerf.H
//
//    This file contains all the defines and prototypes for the performnce
//    monitoring DLL for NetWare redirector
//
//    Date: Sept, 28 1993


//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
// All these definitions will have to be updated when new counters are added.
// if a new counter called COUNTX is added then the Help and Title indicies
// defines should include a new entry -  "#define COUNTXOBJ 4". This increases
// in increments of 2 because each counter has a title and help index.
//
// The Offset of the counters should have another entry - with the size of
// the data for COUNT -
// "#define COUNTER_OFFSET_COUNTX COUNTER_OFFSET_USERS+sizeof(COUNTX_TYPE)"
//
// The SIZE_OF_COUNTER_BLOCK will be updated to:
// "#define SIZE_OF_COUNTER_BLOCK  COUNTER_OFFSET_COUNTX + sizeof(DWORD)"
//
// Finally the NW_DATA_DEFINITION will have a new PERF_COUNTER_DEFINTIION
// entry

// Title and Help index defines. These are used for looking up the Registry
// to get at the counter indicies for the title and help strings.

#define NW_NUM_OBJECTS              1
#define NWOBJ                       0
#define PACKET_BURST_READ_ID        2
#define PACKET_BURST_READ_TO_ID     4
#define PACKET_BURST_WRITE_ID       6
#define PACKET_BURST_WRITE_TO_ID    8
#define PACKET_BURST_IO_ID         10
#define CONNECT_2X_ID              12
#define CONNECT_3X_ID              14
#define CONNECT_4X_ID              16

//
// NetWare Redirector data object definitions.
// The offsets of the counters. The first DWORD is the size of the counter
// data block. In WinPerf, you will see this as PERF_COUNTER_BLOCK.ByteLength
//
#define BYTES_OFFSET                    sizeof(DWORD)
#define IO_OPERATIONS_OFFSET            BYTES_OFFSET + sizeof(LARGE_INTEGER)
#define PACKETS_OFFSET                  IO_OPERATIONS_OFFSET + sizeof(DWORD)
#define BYTES_RECEIVED_OFFSET           PACKETS_OFFSET + \
                                        sizeof(LARGE_INTEGER)
#define NCPS_RECEIVED_OFFSET            BYTES_RECEIVED_OFFSET + \
                                        sizeof(LARGE_INTEGER)
#define BYTES_TRANSMITTED_OFFSET               \
                                        NCPS_RECEIVED_OFFSET + \
                                        sizeof(LARGE_INTEGER)
#define NCPS_TRANSMITTED_OFFSET                \
                                        BYTES_TRANSMITTED_OFFSET + \
                                        sizeof(LARGE_INTEGER)
#define RDR_READ_OPERATIONS_OFFSET                 \
                                        NCPS_TRANSMITTED_OFFSET  + \
                                        sizeof(LARGE_INTEGER)
#define RANDOM_READ_OPERATIONS_OFFSET   RDR_READ_OPERATIONS_OFFSET + \
                                        sizeof(DWORD)
#define READ_NCPS_OFFSET                RANDOM_READ_OPERATIONS_OFFSET + \
                                        sizeof(DWORD)
#define RDR_WRITE_OPERATIONS_OFFSET     READ_NCPS_OFFSET + \
                                        sizeof(DWORD)
#define RANDOM_WRITE_OPERATIONS_OFFSET  RDR_WRITE_OPERATIONS_OFFSET + \
                                        sizeof(DWORD)
#define WRITE_NCPS_OFFSET               RANDOM_WRITE_OPERATIONS_OFFSET + \
                                        sizeof(DWORD)
#define SESSIONS_OFFSET                 WRITE_NCPS_OFFSET + \
                                        sizeof(DWORD)
#define RECONNECTS_OFFSET               SESSIONS_OFFSET + \
                                        sizeof(DWORD)
#define NETWARE_2X_CONNECTS_OFFSET      RECONNECTS_OFFSET + \
                                        sizeof(DWORD)
#define NETWARE_3X_CONNECTS_OFFSET      NETWARE_2X_CONNECTS_OFFSET + \
                                        sizeof(DWORD)
#define NETWARE_4X_CONNECTS_OFFSET      NETWARE_3X_CONNECTS_OFFSET + \
                                        sizeof(DWORD)
#define SERVER_DISCONNECTS_OFFSET       NETWARE_4X_CONNECTS_OFFSET + \
                                        sizeof(DWORD)
#define PACKET_BURST_READ_OFFSET        SERVER_DISCONNECTS_OFFSET + \
                                        sizeof(DWORD)
#define PACKET_BURST_READ_TO_OFFSET     PACKET_BURST_READ_OFFSET + \
                                        sizeof(DWORD)
#define PACKET_BURST_WRITE_OFFSET       PACKET_BURST_READ_TO_OFFSET + \
                                        sizeof(DWORD)
#define PACKET_BURST_WRITE_TO_OFFSET    PACKET_BURST_WRITE_OFFSET + \
                                        sizeof(DWORD)
#define PACKET_BURST_IO_OFFSET          PACKET_BURST_WRITE_TO_OFFSET + \
                                        sizeof(DWORD)
#define EIGHT_BYTE_PAD_OFFSET           PACKET_BURST_IO_OFFSET + \
                                        sizeof(DWORD)
#define SIZE_OF_COUNTER_BLOCK           EIGHT_BYTE_PAD_OFFSET + \
                                        sizeof(DWORD)




// The definition of the NetWare Data definition. This structure holds the
// definition for actual NetWare object and the definition for each of the
// counters.
typedef struct _NW_DATA_DEFINITION {
    PERF_OBJECT_TYPE        NWObjectType;
    PERF_COUNTER_DEFINITION Bytes;
    PERF_COUNTER_DEFINITION IoOperations;
    PERF_COUNTER_DEFINITION Ncps;
    PERF_COUNTER_DEFINITION BytesReceived;
    PERF_COUNTER_DEFINITION NcpsReceived;
    PERF_COUNTER_DEFINITION BytesTransmitted;
    PERF_COUNTER_DEFINITION NcpsTransmitted;
    PERF_COUNTER_DEFINITION ReadOperations;
    PERF_COUNTER_DEFINITION RandomReadOperations;
    PERF_COUNTER_DEFINITION ReadNcps;
    PERF_COUNTER_DEFINITION WriteOperations;
    PERF_COUNTER_DEFINITION RandomWriteOperations;
    PERF_COUNTER_DEFINITION WriteNcps;
    PERF_COUNTER_DEFINITION Sessions;
    PERF_COUNTER_DEFINITION Reconnects;
    PERF_COUNTER_DEFINITION NetWare2XConnects;
    PERF_COUNTER_DEFINITION NetWare3XConnects;
    PERF_COUNTER_DEFINITION NetWare4XConnects;
    PERF_COUNTER_DEFINITION ServerDisconnects;
    PERF_COUNTER_DEFINITION PacketBurstRead;
    PERF_COUNTER_DEFINITION PacketBurstReadTimeouts;
    PERF_COUNTER_DEFINITION PacketBurstWrite;
    PERF_COUNTER_DEFINITION PacketBurstWriteTimeouts;
    PERF_COUNTER_DEFINITION PacketBurstIO;
} NW_DATA_DEFINITION;

#pragma pack ()

PM_OPEN_PROC         OpenNetWarePerformanceData;
PM_COLLECT_PROC      CollectNetWarePerformanceData;
PM_CLOSE_PROC        CloseNetWarePerformanceData;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\perf\prfutil.c ===
//
// Prfutil.h
//
// Utility procedures from the VGACTRS code in the DDK
//
#include "windows.h"
#include <winperf.h>

#define DEFINE_STRING
#include "prfutil.h"

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    TCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    TCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    TCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = TEXT(' ');
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - TEXT('0'));
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\perf\prfutil.h ===
//
// Prfutil.h
//
// Utility procedures from the VGACTRS code in the DDK
//
#ifndef _PRFUTIL_
#define _PRF_UTIL_

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

#define DIGIT           1
#define DELIMITER       2
#define INVALID         3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

BOOL  IsNumberInUnicodeList ( IN DWORD   dwNumber, IN LPWSTR  lpwszUnicodeList );
DWORD GetQueryType          ( IN LPWSTR lpValue );

// only prfutil.c will define GLOBAL_STRING
#ifdef DEFINE_STRING
TCHAR GLOBAL_STRING[]  = TEXT("Global");
TCHAR FOREIGN_STRING[] = TEXT("Foreign");
TCHAR COSTLY_STRING[]  = TEXT("Costly");
TCHAR NULL_STRING[]    = TEXT("\0");    // pointer to null string
#else
extern TCHAR GLOBAL_STRING[];
extern TCHAR FOREIGN_STRING[];
extern TCHAR COSTLY_STRING[];
extern TCHAR NULL_STRING[];
#endif


#endif // _PRFUTIL_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\perf\nwperf.c ===
/****************************************************************************

    PROGRAM: NWPerf.c

    PURPOSE: Contains library routines for providing perfmon with data

    FUNCTIONS:
*******************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include <ntddnwfs.h>
#include "NWPerf.h"
#include "prfutil.h"

#ifndef QFE_BUILD
#include "ntprfctr.h"
#endif



BOOL gbInitOK = FALSE;

HANDLE hNetWareRdr ;
extern NW_DATA_DEFINITION NWDataDefinition;

#ifdef QFE_BUILD
TCHAR PerformanceKeyName [] =
        TEXT("SYSTEM\\CurrentControlSet\\Services\\NWrdr\\Performance");
TCHAR FirstCounterKeyName [] = TEXT("First Counter");
TCHAR FirstHelpKeyName [] = TEXT("First Help");
#endif

/****************************************************************************
   FUNCTION: OpenNetWarePerformanceData

   Purpose:  This routine also initializes the data structures used to pass
             data back to the registry

   Return:   None.
r****************************************************************************/
DWORD APIENTRY
OpenNetWarePerformanceData(
                       LPWSTR pInstances )
{

    LONG status;
#ifdef QFE_BUILD
    HKEY hKeyPerf = 0;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
#else
    NT_PRODUCT_TYPE ProductType;
    DWORD dwFirstCounter = NWCS_CLIENT_COUNTER_INDEX ;
    DWORD dwFirstHelp = NWCS_CLIENT_HELP_INDEX ;
#endif

    IO_STATUS_BLOCK IoStatusBlock;
    RTL_RELATIVE_NAME RelativeName;
    UNICODE_STRING DeviceNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;

#ifdef QFE_BUILD
    status = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
        PerformanceKeyName,
        0L, KEY_ALL_ACCESS, &hKeyPerf );

    if (status != ERROR_SUCCESS) {
        goto OpenExitPoint;
    }

    size = sizeof (DWORD);
    status = RegQueryValueEx( hKeyPerf, FirstCounterKeyName, 0L, &type,
        (LPBYTE)&dwFirstCounter, &size);

    if (status != ERROR_SUCCESS) {
        goto OpenExitPoint;
    }

    size = sizeof (DWORD);
    status = RegQueryValueEx( hKeyPerf, FirstHelpKeyName,
        0L, &type, (LPBYTE)&dwFirstHelp, &size );

    if (status != ERROR_SUCCESS) {
        goto OpenExitPoint;
    }
#endif

    //
    //  NOTE: the initialization program could also retrieve
    //      LastCounter and LastHelp if they wanted to do
    //      bounds checking on the new number. e.g.
    //
    //      counter->CounterNameTitleIndex += dwFirstCounter;
    //      if (counter->CounterNameTitleIndex > dwLastCounter) {
    //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS);
    //      }

    NWDataDefinition.NWObjectType.ObjectNameTitleIndex += dwFirstCounter;
    NWDataDefinition.NWObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    // Counters not defined in Redirector, setup the correct IDs
    NWDataDefinition.PacketBurstRead.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.PacketBurstRead.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.PacketBurstReadTimeouts.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.PacketBurstReadTimeouts.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.PacketBurstWrite.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.PacketBurstWrite.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.PacketBurstWriteTimeouts.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.PacketBurstWriteTimeouts.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.PacketBurstIO.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.PacketBurstIO.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.NetWare2XConnects.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.NetWare2XConnects.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.NetWare3XConnects.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.NetWare3XConnects.CounterHelpTitleIndex += dwFirstHelp;
    NWDataDefinition.NetWare4XConnects.CounterNameTitleIndex += dwFirstCounter;
    NWDataDefinition.NetWare4XConnects.CounterHelpTitleIndex += dwFirstHelp;


#ifndef QFE_BUILD
    // Check for WorkStation or Server and use the gateway indexes if
    // currently running on Server.
    // If RtlGetNtProductType is not successful or ProductType is
    // WinNt machine, ObjectNameTitleIndex and ObjectHelpTitleIndex are set
    // to the correct values already.
#ifdef GATEWAY_ENABLED
    if ( RtlGetNtProductType( &ProductType))
    {
        if ( ProductType != NtProductWinNt )
        {
            NWDataDefinition.NWObjectType.ObjectNameTitleIndex = NWCS_GATEWAY_COUNTER_INDEX;
            NWDataDefinition.NWObjectType.ObjectHelpTitleIndex = NWCS_GATEWAY_HELP_INDEX;
        }
    }
#endif
#endif

    hNetWareRdr = NULL;

    RtlInitUnicodeString(&DeviceNameU, DD_NWFS_DEVICE_NAME_U);
    RelativeName.ContainingDirectory = NULL;

    InitializeObjectAttributes(&ObjectAttributes,
                               &DeviceNameU,
                               OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL
                               );

    status = NtCreateFile(&hNetWareRdr,
                          SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0
                          );

    gbInitOK = TRUE; // ok to use this function

    status = ERROR_SUCCESS; // for successful exit

#ifdef QFE_BUILD
OpenExitPoint:
    if (hKeyPerf)
       RegCloseKey (hKeyPerf); // close key to registry
#endif

    return ((DWORD) status);
}


/****************************************************************************
   FUNCTION: CollectNetWarePerformanceData

   Purpose:  This routine will return the data for the NetWare counters.

   Arguments:IN       LPWSTR   lpValueName
                 pointer to a wide character string passed by registry.

             IN OUT   LPVOID   *lppData
                 IN: pointer to the address of the buffer to receive the
                 completed PerfDataBlock and subordinate structures. This
                 routine will append its data to the buffer starting at
                 the point referenced by *lppData.

                 OUT: points to the first byte after the data structure
                 added by this routine. This routine updated the value at
                 lppdata after appending its data.

             IN OUT   LPDWORD  lpcbTotalBytes
                 IN: the address of the DWORD that tells the size in bytes
                 of the buffer referenced by the lppData argument

                 OUT: the number of bytes added by this routine is written
                 to the DWORD pointed to by this argument

             IN OUT   LPDWORD  NumObjectTypes
                 IN: the address of the DWORD to receive the number of
                 objects added by this routine

                 OUT: the number of objects added by this routine is written
                 to the DWORD pointed to by this argument

    Return:  ERROR_MORE_DATA if buffer passed is too small to hold data
                             any error conditions encountered are reported
                             to the event log if event logging is enabled.

             ERROR_SUCCESS   if success or any other error. Errors, however
                             are also reported to the event log.

****************************************************************************/
DWORD APIENTRY
CollectNetWarePerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes)
{
    ULONG SpaceNeeded;
    PDWORD pdwCounter;
    DWORD  dwQueryType;
    PERF_COUNTER_BLOCK *pPerfCounterBlock;
    NW_DATA_DEFINITION *pNWDataDefinition;
    LONG status;
    NW_REDIR_STATISTICS NWRdrStatistics;
    LARGE_INTEGER UNALIGNED *pliCounter;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // before doing anything else, see if Open went OK
    //
    if (!gbInitOK) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN) {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    // If the caller only wanted some counter, check if we have 'em
    if (dwQueryType == QUERY_ITEMS){
        if ( !(IsNumberInUnicodeList (
               NWDataDefinition.NWObjectType.ObjectNameTitleIndex,
                lpValueName))) {
             // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pNWDataDefinition = (NW_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(NW_DATA_DEFINITION) + SIZE_OF_COUNTER_BLOCK;

    if ( *lpcbTotalBytes < SpaceNeeded ) {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ((DWORD) ERROR_MORE_DATA);
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //
    memmove( pNWDataDefinition, &NWDataDefinition,
             sizeof(NW_DATA_DEFINITION) );

    // Point at the byte right after all the definitions
    pPerfCounterBlock = (PERF_COUNTER_BLOCK *) &pNWDataDefinition[1];

    // The first DWORD should specify the size of actual data block
    pPerfCounterBlock->ByteLength = SIZE_OF_COUNTER_BLOCK;

    // Move the pointer up
    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);


    // Open the NetWare data
    if ( hNetWareRdr != NULL) {
        status = NtFsControlFile(hNetWareRdr,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 FSCTL_NWR_GET_STATISTICS,
                                 NULL,
                                 0,
                                 &NWRdrStatistics,
                                 sizeof(NWRdrStatistics)
                                 );
    }
    if ( hNetWareRdr != NULL && NT_SUCCESS(status) ) {

        pliCounter = (LARGE_INTEGER UNALIGNED * ) (&pPerfCounterBlock[1]);

        pliCounter->QuadPart = NWRdrStatistics.BytesReceived.QuadPart +
                                NWRdrStatistics.BytesTransmitted.QuadPart;

        pdwCounter = (PDWORD) ++pliCounter;
        *pdwCounter = NWRdrStatistics.ReadOperations +
                      NWRdrStatistics.WriteOperations;
        pliCounter = (LARGE_INTEGER UNALIGNED * ) ++pdwCounter;
        pliCounter->QuadPart = NWRdrStatistics.NcpsReceived.QuadPart + 
                               NWRdrStatistics.NcpsTransmitted.QuadPart;
        *++pliCounter = NWRdrStatistics.BytesReceived;
        *++pliCounter = NWRdrStatistics.NcpsReceived;
        *++pliCounter = NWRdrStatistics.BytesTransmitted;
        *++pliCounter = NWRdrStatistics.NcpsTransmitted;
        pdwCounter = (PDWORD) ++pliCounter;
        *pdwCounter = NWRdrStatistics.ReadOperations;
        *++pdwCounter = NWRdrStatistics.RandomReadOperations;
        *++pdwCounter = NWRdrStatistics.ReadNcps;
        *++pdwCounter = NWRdrStatistics.WriteOperations;
        *++pdwCounter = NWRdrStatistics.RandomWriteOperations;
        *++pdwCounter = NWRdrStatistics.WriteNcps;
        *++pdwCounter = NWRdrStatistics.Sessions;
        *++pdwCounter = NWRdrStatistics.Reconnects;
        *++pdwCounter = NWRdrStatistics.NW2xConnects;
        *++pdwCounter = NWRdrStatistics.NW3xConnects;
        *++pdwCounter = NWRdrStatistics.NW4xConnects;
        *++pdwCounter = NWRdrStatistics.ServerDisconnects;

        *++pdwCounter = NWRdrStatistics.PacketBurstReadNcps;
        *++pdwCounter = NWRdrStatistics.PacketBurstReadTimeouts;
        *++pdwCounter = NWRdrStatistics.PacketBurstWriteNcps;
        *++pdwCounter = NWRdrStatistics.PacketBurstWriteTimeouts;
        *++pdwCounter = NWRdrStatistics.PacketBurstReadNcps +
                        NWRdrStatistics.PacketBurstWriteNcps;

        //
        // Add an extra empty DWORD to pad the buffer to an 8-byte boundary
        //
        *++pdwCounter = 0;

        *lppData = (LPVOID) ++pdwCounter;

    } else {

        //
        // Failure to access Redirector: clear counters to 0
        //

        memset(&pPerfCounterBlock[1],
               0,
               SIZE_OF_COUNTER_BLOCK - sizeof(pPerfCounterBlock));

        pdwCounter = (PDWORD) ((PBYTE) pPerfCounterBlock + SIZE_OF_COUNTER_BLOCK);
        *lppData = (LPVOID) pdwCounter;

    }


    // We sent data for only one Object. (Remember not to confuse this
    // with counters. Even if more counters are added, the number of object
    // is still only one. However, this does not mean more objects cannot
    // be added
    *lpNumObjectTypes = 1;

    // Fill in the number of bytes we copied - incl. the definitions and the
    // counter data.
    *lpcbTotalBytes = (DWORD) ((PBYTE) pdwCounter - (PBYTE) pNWDataDefinition);

    //
    // Make sure the output buffer is 8-byte aligned
    //
    ASSERT((*lpcbTotalBytes & 0x7) == 0);

    return ERROR_SUCCESS;
}

/****************************************************************************
   FUNCTION: CloseNetWarePerformanceData

   Purpose:  This routine closes the open handles to NetWare performance counters


   Return:   ERROR_SUCCESS

****************************************************************************/
DWORD APIENTRY
CloseNetWarePerformanceData(
)
{
    if ( hNetWareRdr ) {

        NtClose( hNetWareRdr );
        hNetWareRdr = NULL;
    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\nwscript\inc\nwscript.h ===
/******************************************************************************
*
*  NWSCRIPT.H
*
*   This module contains typedefs and defines required for the
*   NetWare script utility.
*
*   Copyright (c) 1995 Microsoft Corporation
*
*  $Log:   N:\NT\PRIVATE\NW4\NWSCRIPT\INC\VCS\NWSCRIPT.H  $
*  
*     Rev 1.10   18 Apr 1996 16:53:02   terryt
*  Various enhancements
*  
*     Rev 1.9   10 Apr 1996 14:22:36   terryt
*  Hotfix for 21181hq
*  
*     Rev 1.10   12 Mar 1996 19:42:52   terryt
*  Relative NDS name support
*  
*     Rev 1.9   07 Mar 1996 18:34:46   terryt
*  Misc fixes
*  
*     Rev 1.8   22 Jan 1996 16:44:02   terryt
*  Add automatic map attaches
*  
*     Rev 1.7   08 Jan 1996 13:58:34   terryt
*  Correct NDS Preferred Server
*  
*     Rev 1.6   05 Jan 1996 17:19:08   terryt
*  Ensure context is the correct login default
*  
*     Rev 1.5   04 Jan 1996 18:58:34   terryt
*  Bug fixes reported by MS
*  
*     Rev 1.4   22 Dec 1995 14:20:34   terryt
*  Add Microsoft headers
*  
*     Rev 1.3   28 Nov 1995 17:13:56   terryt
*  Cleanup resource file
*  
*     Rev 1.2   22 Nov 1995 15:44:34   terryt
*  Use proper NetWare user name call
*  
*     Rev 1.1   20 Nov 1995 16:11:34   terryt
*  Context and capture changes
*  
*     Rev 1.0   15 Nov 1995 18:05:38   terryt
*  Initial revision.
*  
*     Rev 1.5   25 Aug 1995 17:03:52   terryt
*  CAPTURE support
*  
*     Rev 1.4   18 Jul 1995 16:07:52   terryt
*  Screen out capture commands
*  
*     Rev 1.3   17 Jul 1995 09:43:02   terryt
*  Use Microsoft name for environment
*  
*     Rev 1.2   23 Jun 1995 09:49:58   terryt
*  Add error message for mapping over MS network drive
*  
*     Rev 1.1   23 May 1995 19:38:14   terryt
*  Spruce up source
*  
*     Rev 1.0   15 May 1995 19:09:42   terryt
*  Initial revision.
*  
******************************************************************************/


#define SCRIPT_ENVIRONMENT_VALUENAME L"Volatile Environment"
#define REGISTRY_PROVIDER L"System\\CurrentControlSet\\Services\\NWCWorkstation\\networkProvider"
#define REGISTRY_PROVIDERNAME L"Name"

typedef enum SYNTAX
{
        NDSI_UNKNOWN,                                   /* 0  */
        NDSI_DIST_NAME,                                 /* 1  */
        NDSI_CE_STRING,                                 /* 2  */
        NDSI_CI_STRING,                                 /* 3  */
        NDSI_PR_STRING,                                 /* 4  */
        NDSI_NU_STRING,                                 /* 5  */
        NDSI_CI_LIST,                                   /* 6  */
        NDSI_BOOLEAN,                                   /* 7  */
        NDSI_INTEGER,                                   /* 8  */
        NDSI_OCTET_STRING,                              /* 9  */
        NDSI_TEL_NUMBER,                                /* 10 */
        NDSI_FAX_NUMBER,                                /* 11 */
        NDSI_NET_ADDRESS,                               /* 12 */
        NDSI_OCTET_LIST,                                /* 13 */
        NDSI_EMAIL_ADDRESS,                             /* 14 */
        NDSI_PATH,                                      /* 15 */
        NDSI_REPLICA_POINTER,                           /* 16 */
        NDSI_OBJECT_ACL,                                /* 17 */
        NDSI_PO_ADDRESS,                                /* 18 */
        NDSI_TIMESTAMP,                                 /* 19 */
        NDSI_CLASS_NAME,                                /* 20 */
        NDSI_STREAM,                                    /* 21 */
        NDSI_COUNTER,                                   /* 22 */
        NDSI_BACK_LINK,                                 /* 23 */
        NDSI_TIME,                                      /* 24 */
        NDSI_TYPED_NAME,                                /* 25 */
        NDSI_HOLD,                                      /* 26 */
        NDSI_INTERVAL,                                  /* 27 */
        NDSI_TAX_COUNT                                  /* 28 */
} SYNTAX;

#define DSCL_AFP_SERVER                      "AFP Server"
#define DSCL_ALIAS                           "Alias"
#define DSCL_BINDERY_OBJECT                  "Bindery Object"
#define DSCL_BINDERY_QUEUE                   "Bindery Queue"
#define DSCL_COMPUTER                        "Computer"
#define DSCL_COUNTRY                         "Country"
#define DSCL_DEVICE                          "Device"
#define DSCL_DIRECTORY_MAP                   "Directory Map"
#define DSCL_EXTERNAL_ENTITY                 "External Entity"
#define DSCL_GROUP                           "Group"
#define DSCL_LIST                            "List"
#define DSCL_LOCALITY                        "Locality"
#define DSCL_MESSAGE_ROUTING_GROUP           "Message Routing Group"
#define DSCL_MESSAGING_SERVER                "Messaging Server"
#define DSCL_NCP_SERVER                      "NCP Server"
#define DSCL_ORGANIZATION                    "Organization"
#define DSCL_ORGANIZATIONAL_PERSON           "Organizational Person"
#define DSCL_ORGANIZATIONAL_ROLE             "Organizational Role"
#define DSCL_ORGANIZATIONAL_UNIT             "Organizational Unit"
#define DSCL_PARTITION                       "Partition"
#define DSCL_PERSON                          "Person"
#define DSCL_PRINT_SERVER                    "Print Server"
#define DSCL_PRINTER                         "Printer"
#define DSCL_PROFILE                         "Profile"
#define DSCL_QUEUE                           "Queue"
#define DSCL_RESOURCE                        "Resource"
#define DSCL_SERVER                          "Server"
#define DSCL_TOP                             "Top"
#define DSCL_UNKNOWN                         "Unknown"
#define DSCL_USER                            "User"
#define DSCL_VOLUME                          "Volume"

#define DSAT_HOST_SERVER                     "Host Server"
#define DSAT_HOST_RESOURCE_NAME              "Host Resource Name"
#define DSAT_PATH                            "Path"

void ConvertUnicodeToAscii( PVOID );

void NTGetTheDate( unsigned int *, unsigned char *, unsigned char * );
void NTGetVersionOfShell( char *, unsigned char *, unsigned char *, unsigned char * );
void NTBreakOff( void );
void NTBreakOn( void );
unsigned short NTNetWareDriveStatus( unsigned short );
unsigned int NTGetNWDrivePath( unsigned short, unsigned char *, unsigned char * );
char * NTNWtoUNCFormat( char * );
unsigned int NTLoginToFileServer( char *, char *, char * );
unsigned int NTAttachToFileServer( unsigned char *, unsigned int * );
unsigned int NTIsConnected( unsigned char * );
unsigned int NTSetDriveBase( unsigned char *, unsigned char *, unsigned char * );
unsigned int NTGetUserID( unsigned int, unsigned long * );
unsigned int NTIsNetWareDrive( unsigned int );
void NTInitProvider( void );
void DisplayMessage( unsigned int, ... );
void DisplayOemString( char * );
void ExportEnv( unsigned char * );
void ExportCurrentDirectory( int );
void ExportCurrentDrive( int );
void GetOldPaths( void );
void NTPrintExtendedError( void );
unsigned int NTGetCurrentDirectory( unsigned char, unsigned char * );
void Capture( char ** argv, unsigned int );
unsigned int ConverNDSPathToNetWarePathA(char *, char *, char *);

#define CONTEXT_MAX 256
#define ATTRBUFSIZE 2048
#define NDS_NAME_CHARS 1024


unsigned int NDSInitUserProperty( void );
unsigned int NDSGetUserProperty( PBYTE, PBYTE Data, unsigned int, SYNTAX *, unsigned int * );
void NDSGetVar ( PBYTE, PBYTE, unsigned int );
unsigned int NDSChangeContext( PBYTE );
unsigned int NDSGetContext( PBYTE, unsigned int );
unsigned int Is40Server( unsigned int );
unsigned int NDSfopenStream ( PBYTE, PBYTE, PHANDLE, unsigned int * );
unsigned int IsMemberOfNDSGroup( PBYTE );
unsigned int NDSGetProperty ( PBYTE, PBYTE, PBYTE, unsigned int, unsigned int * );
unsigned int NDSTypeless( LPSTR, LPSTR );
void CleanupExit( int );
void NDSCleanup( void );
int NTGetNWUserName( PWCHAR, PWCHAR, int );
unsigned int NDSGetClassName( LPSTR, LPSTR );

unsigned int NDSCanonicalizeName( PBYTE, PBYTE, int, int );

#define LIST_3X_SERVER 1
#define LIST_4X_SERVER 2

BOOL IsServerInAttachList( char *, unsigned int );
void AddServerToAttachList( char *, unsigned int );
int DoAttachProcessing( char * );

#define FLAGS_LOCAL_CONTEXT   0x1
#define FLAGS_NO_CONTEXT      0x2
#define FLAGS_TYPED_NAMES     0x4

unsigned int NDSAbbreviateName( DWORD, LPSTR, LPSTR );

/*
 * Resource string IDs
 */
#define IDR_ERROR                       100
#define IDR_NO_DEFAULT_CONNECTION       101
#define IDR_NO_KNOWN_FILE_SERVER        102
#define IDR_LOCAL_DRIVE                 103
#define IDR_NETWARE_DRIVE               104
#define IDR_DASHED_LINE                 105
#define IDR_LOCAL_SEARCH                106
#define IDR_NETWARE_SEARCH              107
#define IDR_NOT_ENOUGH_MEMORY           108
#define IDR_PASSWORD                    109
#define IDR_ATTACHED                    110
#define IDR_ACCESS_DENIED               111
#define IDR_UNAUTHORIZED_LOGIN_TIME     112
#define IDR_LOGIN_DENIED_NO_CONNECTION  113
#define IDR_UNAUTHORIZED_LOGIN_STATION  114
#define IDR_ACCOUNT_DISABLED            115
#define IDR_PASSWORD_EXPRIED_NO_GRACE   116
#define IDR_MAP_NOT_ATTACHED_SERVER     117
#define IDR_MAP_USAGE                   118
#define IDR_UNDEFINED                   119
#define IDR_DIRECTORY_NOT_FOUND         120
#define IDR_VOLUME_NOT_EXIST            121
#define IDR_WRONG_DRIVE                 122
#define IDR_DEL_DRIVE                   123
#define IDR_DEL_SEARCH_DRIVE            124
#define IDR_SEARCH_DRIVE_NOT_EXIST      125
#define IDR_NOT_NETWORK_DRIVE           126
#define IDR_NO_DRIVE_AVAIL              127
#define IDR_INVALID_PATH                128
#define IDR_CAN_NOT_CHANGE_DRIVE        129
#define IDR_MAP_INVALID_PATH            130
#define IDR_MAP_FAILED                  131
#define IDR_NO_SCRIPT_FILE              132
#define IDR_STRIKE_KEY                  133
#define IDR_CANNOT_EXECUTE              134
#define IDR_ENOENT                      135
#define IDR_EXIT_NOT_SUPPORTED          136
#define IDR_IF_TOO_DEEP                 137
#define IDR_SCRIPT_ERROR                138
#define IDR_ORIGINAL_LINE_WAS           139
#define IDR_BAD_COMMAND                 140
#define IDR_LABEL_NOT_FOUND             141
#define IDR_NO_VOLUME                   142
#define IDR_ERROR_DURING                143
#define IDR_MAP_ERROR                   144
#define IDR_ENTER_SERVER_NAME           145
#define IDR_ENTER_LOGIN_NAME            146
#define IDR_ERROR_SET_DEFAULT_DRIVE     147
#define IDR_ERROR_OPEN_SCRIPT           148
#define IDR_DIVIDE_BY_ZERO              149
#define IDR_NEWLINE                     150
#define IDR_SERVER_USER                 151
#define IDR_NON_NETWARE_NETWORK_DRIVE   152
#define IDR_CAPTURE_USAGE               153
#define IDR_COPIES_EXPECTED             154
#define IDR_COPIES_OUTOF_RANGE          155
#define IDR_FILE_CAPTURE_UNSUPPORTED    156
#define IDR_FORM_EXPECTED               157
#define IDR_INVALID_BANNER              158
#define IDR_INVALID_FORM_NAME           159
#define IDR_INVALID_FORM_TYPE           160
#define IDR_INVALID_LPT_NUMBER          161
#define IDR_INVALID_PATH_NAME           162
#define IDR_JOB_NOT_FOUND               163
#define IDR_LPT_NUMBER_EXPECTED         164
#define IDR_LPT_STATUS                  165
#define IDR_NOT_ACTIVE                  166
#define IDR_NO_AUTOENDCAP               167
#define IDR_NO_PRINTERS                 168
#define IDR_LPT_STATUS_NO_BANNER        169
#define IDR_QUEUE_NOT_EXIST             170
#define IDR_SERVER_NOT_FOUND            171
#define IDR_SUCCESS_QUEUE               172
#define IDR_TABSIZE_OUTOF_RANGE         173
#define IDR_TAB_SIZE_EXPECTED           174
#define IDR_TIMEOUT_OUTOF_RANGE         175
#define IDR_TIME_OUT_EXPECTED           176
#define IDR_UNKNOW_FLAG                 177
#define IDR_DISABLED                    178
#define IDR_ENABLED                     179
#define IDR_YES                         180
#define IDR_NO                          181
#define IDR_SECONDS                     182
#define IDR_CONVERT_TO_SPACE            183
#define IDR_NO_CONVERSION               184
#define IDR_NOTIFY_USER                 185
#define IDR_NOT_NOTIFY_USER             186
#define IDR_NONE                        187
#define IDR_CONNECTION_REFUSED          188
#define IDR_LASTLOGIN_PM                189
#define IDR_LASTLOGIN_AM                190
#define IDR_ALL_LOCAL_DRIVES            191
#define IDR_CHANGE_CONTEXT_ERROR        192
#define IDR_GET_CONTEXT_ERROR           193
#define IDR_DISPLAY_CONTEXT             194
#define IDR_LPT_STATUS_NDS              195
#define IDR_LPT_STATUS_NO_BANNER_NDS    196
#define IDR_NO_QUEUE                    197
#define IDR_LASTLOGIN                   198
#define IDR_TREE_OPEN_FAILED            199
#define IDR_NDS_CONTEXT_INVALID         200
#define IDR_NDS_USERNAME_FAILED         201
#define IDR_QUERY_INFO_FAILED           202
#define IDR_NO_RESPONSE                 203
#define IDR_NDSQUEUE_NOT_EXIST          204
#define IDR_NDSSUCCESS_QUEUE            205
#define IDR_CAPTURE_FAILED              206
#define IDR_CURRENT_TREE                207
#define IDR_CURRENT_SERVER              208
#define IDR_CURRENT_CONTEXT             209
#define IDR_AUTHENTICATING_SERVER       210
#define IDR_NO_END_QUOTE                211
#define IDR_ALREADY_ATTACHED            212

//
// BEGIN WARNING!!!  Items below MUST be consequtive. Eg. the code assumes 
// that March is January+2.
//

#define IDR_GREETING_MORNING            300
#define IDR_GREETING_AFTERNOON          301
#define IDR_GREETING_EVENING            302

#define IDR_AM                          305
#define IDR_PM                          306

#define IDR_SUNDAY                      310
#define IDR_MONDAY                      311
#define IDR_TUESDAY                     312
#define IDR_WEDNESDAY                   313
#define IDR_THURSDAY                    314
#define IDR_FRIDAY                      315
#define IDR_SATURDAY                    316

#define IDR_JANUARY                     320
#define IDR_FEBRUARY                    321
#define IDR_MARCH                       322
#define IDR_APRIL                       323
#define IDR_MAY                         324
#define IDR_JUNE                        325
#define IDR_JULY                        326
#define IDR_AUGUST                      327
#define IDR_SEPTEMBER                   328
#define IDR_OCTOBER                     329
#define IDR_NOVEMBER                    330
#define IDR_DECEMBER                    331

//
// END WARNING!!!  
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\rdr\attach.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Attach.c

Abstract:

    This module implements the routines for the NetWare
    redirector to connect and disconnect from a server.

Author:

    Colin Watson    [ColinW]    10-Jan-1992

Revision History:

--*/

#include "Procs.h"
#include <stdlib.h>   // rand

//
// The number of bytes in the ipx host address, not
// including the socket.
//

#define IPX_HOST_ADDR_LEN 10

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

VOID
ExtractNextComponentName (
    OUT PUNICODE_STRING Name,
    IN PUNICODE_STRING Path,
    IN BOOLEAN ColonSeparator
    );

NTSTATUS
ExtractPathAndFileName(
    IN PUNICODE_STRING EntryPath,
    OUT PUNICODE_STRING PathString,
    OUT PUNICODE_STRING FileName
    );

NTSTATUS
DoBinderyLogon(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password
    );

NTSTATUS
ConnectToServer(
    IN PIRP_CONTEXT pIrpContext,
    OUT PSCB *pScbCollision
    );

BOOLEAN
ProcessFindNearestEntry(
    PIRP_CONTEXT IrpContext,
    PSAP_FIND_NEAREST_RESPONSE FindNearestResponse
    );

NTSTATUS
GetMaxPacketSize(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    );

PNONPAGED_SCB
FindServer(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb,
    PUNICODE_STRING ServerName
    );

NTSTATUS
NwAllocateAndInitScb(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING UidServerName OPTIONAL,
    IN PUNICODE_STRING ServerName OPTIONAL,
    OUT PSCB *ppScb
);

NTSTATUS
IndirectToSeedServer(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING pServerName,
    PUNICODE_STRING pNewServer
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, ExtractNextComponentName )
#pragma alloc_text( PAGE, ExtractPathAndFileName )
#pragma alloc_text( PAGE, CrackPath )
#pragma alloc_text( PAGE, CreateScb )
#pragma alloc_text( PAGE, FindServer )
#pragma alloc_text( PAGE, ProcessFindNearestEntry )
#pragma alloc_text( PAGE, NegotiateBurstMode )
#pragma alloc_text( PAGE, GetMaxPacketSize )
#pragma alloc_text( PAGE, NwDeleteScb )
#pragma alloc_text( PAGE, NwLogoffAndDisconnect )
#pragma alloc_text( PAGE, InitializeAttach )
#pragma alloc_text( PAGE, OpenScbSockets )
#pragma alloc_text( PAGE, DoBinderyLogon )
#pragma alloc_text( PAGE, QueryServersAddress )
#pragma alloc_text( PAGE, TreeConnectScb )
#pragma alloc_text( PAGE, TreeDisconnectScb )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, ProcessFindNearest )
#pragma alloc_text( PAGE1, NwLogoffAllServers )
#pragma alloc_text( PAGE1, DestroyAllScb )
#pragma alloc_text( PAGE1, SelectConnection )
#pragma alloc_text( PAGE1, NwFindScb )
#pragma alloc_text( PAGE1, ConnectToServer )
#endif

#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif


VOID
ExtractNextComponentName (
    OUT PUNICODE_STRING Name,
    IN PUNICODE_STRING Path,
    IN BOOLEAN ColonSeparator
    )

/*++

Routine Description:

    This routine extracts a the "next" component from a path string.

    It assumes that

Arguments:

    Name - Returns a pointer to the component.

    Path - Supplies a pointer to the backslash seperated pathname.

    ColonSeparator - A colon can be used to terminate this component
        name.

Return Value:

    None

--*/

{
    register USHORT i;                   // Index into Name string.

    PAGED_CODE();

    if (Path->Length == 0) {
        RtlInitUnicodeString(Name, NULL);
        return;
    }

    //
    //  Initialize the extracted name to the name passed in skipping the
    //  leading backslash.
    //

    //  DebugTrace(+0, Dbg, "NwExtractNextComponentName = %wZ\n", Path );

    Name->Buffer = Path->Buffer + 1;
    Name->Length = Path->Length - sizeof(WCHAR);
    Name->MaximumLength = Path->MaximumLength - sizeof(WCHAR);

    //
    // Scan forward finding the terminal "\" in the server name.
    //

    for (i=0;i<(USHORT)(Name->Length/sizeof(WCHAR));i++) {

        if ( Name->Buffer[i] == OBJ_NAME_PATH_SEPARATOR ||
             ( ColonSeparator && Name->Buffer[i] == L':' ) ) {
            break;
        }
    }

    //
    //  Update the length and maximum length of the structure
    //  to match the new length.
    //

    Name->Length = Name->MaximumLength = (USHORT)(i*sizeof(WCHAR));
}


NTSTATUS
ExtractPathAndFileName (
    IN PUNICODE_STRING EntryPath,
    OUT PUNICODE_STRING PathString,
    OUT PUNICODE_STRING FileName
    )
/*++

Routine Description:

    This routine cracks the entry path into two pieces, the path and the file
name component at the start of the name.


Arguments:

    IN PUNICODE_STRING EntryPath - Supplies the path to disect.
    OUT PUNICODE_STRING PathString - Returns the directory containing the file.
    OUT PUNICODE_STRING FileName - Returns the file name specified.

Return Value:

    NTSTATUS - SUCCESS


--*/

{
    UNICODE_STRING Component;
    UNICODE_STRING FilePath = *EntryPath;

    PAGED_CODE();

    //  Strip trailing separators
    while ( (FilePath.Length != 0) &&
            FilePath.Buffer[(FilePath.Length-1)/sizeof(WCHAR)] ==
                OBJ_NAME_PATH_SEPARATOR ) {

        FilePath.Length         -= sizeof(WCHAR);
        FilePath.MaximumLength  -= sizeof(WCHAR);
    }

    // PathString will become EntryPath minus FileName and trailing separators
    *PathString = FilePath;

    //  Initialize FileName just incase there are no components at all.
    RtlInitUnicodeString( FileName, NULL );

    //
    //  Scan through the current file name to find the entire path
    //  up to (but not including) the last component in the path.
    //

    do {

        //
        //  Extract the next component from the name.
        //

        ExtractNextComponentName(&Component, &FilePath, FALSE);

        //
        //  Bump the "remaining name" pointer by the length of this
        //  component
        //

        if (Component.Length != 0) {

            FilePath.Length         -= Component.Length+sizeof(WCHAR);
            FilePath.MaximumLength  -= Component.MaximumLength+sizeof(WCHAR);
            FilePath.Buffer         += (Component.Length/sizeof(WCHAR))+1;

            *FileName = Component;
        }


    } while (Component.Length != 0);

    //
    //  Take the name, subtract the last component of the name
    //  and concatenate the current path with the new path.
    //

    if ( FileName->Length != 0 ) {

        //
        //  Set the path's name based on the original name, subtracting
        //  the length of the name portion (including the "\")
        //

        PathString->Length -= (FileName->Length + sizeof(WCHAR));
        if ( PathString->Length != 0 ) {
            PathString->MaximumLength -= (FileName->MaximumLength + sizeof(WCHAR));
        } else{
            RtlInitUnicodeString( PathString, NULL );
        }
    } else {

        //  There was no path or filename

        RtlInitUnicodeString( PathString, NULL );
    }

    return STATUS_SUCCESS;
}


NTSTATUS
CrackPath (
    IN PUNICODE_STRING BaseName,
    OUT PUNICODE_STRING DriveName,
    OUT PWCHAR DriveLetter,
    OUT PUNICODE_STRING ServerName,
    OUT PUNICODE_STRING VolumeName,
    OUT PUNICODE_STRING PathName,
    OUT PUNICODE_STRING FileName,
    OUT PUNICODE_STRING FullName OPTIONAL
    )

/*++

Routine Description:

    This routine extracts the relevant portions from BaseName to extract
    the components of the user's string.


Arguments:

    BaseName - Supplies the base user's path.

    DriveName - Supplies a string to hold the drive specifier.

    DriveLetter - Returns the drive letter.  0 for none, 'A'-'Z' for
        disk drives, '1'-'9' for LPT connections.

    ServerName - Supplies a string to hold the remote server name.

    VolumeName - Supplies a string to hold the volume name.

    PathName - Supplies a string to hold the remaining part of the path.

    FileName - Supplies a string to hold the final component of the path.

    FullName - Supplies a string to put the Path followed by FileName

Return Value:

    NTSTATUS - Status of operation


--*/

{
    NTSTATUS Status;

    UNICODE_STRING BaseCopy = *BaseName;
    UNICODE_STRING ShareName;

    PAGED_CODE();

    RtlInitUnicodeString( DriveName, NULL);
    RtlInitUnicodeString( ServerName, NULL);
    RtlInitUnicodeString( VolumeName, NULL);
    RtlInitUnicodeString( PathName, NULL);
    RtlInitUnicodeString( FileName, NULL);
    *DriveLetter = 0;

    if (ARGUMENT_PRESENT(FullName)) {
        RtlInitUnicodeString( FullName, NULL);
    }

    //
    //  If the name is "\", or empty, there is nothing to do.
    //

    if ( BaseName->Length <= sizeof( WCHAR ) ) {
        return STATUS_SUCCESS;
    }

    ExtractNextComponentName(ServerName, &BaseCopy, FALSE);

    //
    //  Skip over the server name.
    //

    BaseCopy.Buffer += (ServerName->Length / sizeof(WCHAR)) + 1;
    BaseCopy.Length -= ServerName->Length + sizeof(WCHAR);
    BaseCopy.MaximumLength -= ServerName->MaximumLength + sizeof(WCHAR);

    if ((ServerName->Length == sizeof(L"X:") - sizeof(WCHAR) ) &&
        (ServerName->Buffer[(ServerName->Length / sizeof(WCHAR)) - 1] == L':'))
    {

        //
        //  The file name is of the form x:\server\volume\foo\bar
        //

        *DriveName = *ServerName;
        *DriveLetter = DriveName->Buffer[0];

        RtlInitUnicodeString( ServerName, NULL );
        ExtractNextComponentName(ServerName, &BaseCopy, FALSE);

        if ( ServerName->Length != 0 ) {

            //
            //  Skip over the server name.
            //

            BaseCopy.Buffer += (ServerName->Length / sizeof(WCHAR)) + 1;
            BaseCopy.Length -= ServerName->Length + sizeof(WCHAR);
            BaseCopy.MaximumLength -= ServerName->MaximumLength + sizeof(WCHAR);
        }
    }
    else if ( ( ServerName->Length == sizeof(L"LPTx") - sizeof(WCHAR) ) &&
         ( _wcsnicmp( ServerName->Buffer, L"LPT", 3 ) == 0) &&
         ( ServerName->Buffer[3] >= '0' && ServerName->Buffer[3] <= '9' ) )
    {

        //
        //  The file name is of the form LPTx\server\printq
        //

        *DriveName = *ServerName;
        *DriveLetter = DriveName->Buffer[3];

        RtlInitUnicodeString( ServerName, NULL );
        ExtractNextComponentName(ServerName, &BaseCopy, FALSE);

        if ( ServerName->Length != 0 ) {

            //
            //  Skip over the server name.
            //

            BaseCopy.Buffer += (ServerName->Length / sizeof(WCHAR)) + 1;
            BaseCopy.Length -= ServerName->Length + sizeof(WCHAR);
            BaseCopy.MaximumLength -= ServerName->MaximumLength + sizeof(WCHAR);
        }
    }

    if ( ServerName->Length != 0 ) {

        //
        //  The file name is of the form \\server\volume\foo\bar
        //  Set volume name to server\volume.
        //

        ExtractNextComponentName( &ShareName, &BaseCopy, TRUE );

        //
        //  Set volume name = \drive:\server\share  or \server\share if the
        //  path is UNC.
        //

        VolumeName->Buffer = ServerName->Buffer - 1;

        if ( ShareName.Length != 0 ) {

            VolumeName->Length = ServerName->Length + ShareName.Length + 2 * sizeof( WCHAR );

            if ( DriveName->Buffer != NULL ) {
                VolumeName->Buffer = DriveName->Buffer - 1;
                VolumeName->Length += DriveName->Length + sizeof(WCHAR);
            }

            BaseCopy.Buffer += ShareName.Length / sizeof(WCHAR) + 1;
            BaseCopy.Length -= ShareName.Length + sizeof(WCHAR);
            BaseCopy.MaximumLength -= ShareName.MaximumLength + sizeof(WCHAR);

        } else {

            VolumeName->Length = ServerName->Length + sizeof( WCHAR );
            return( STATUS_SUCCESS );

        }

        VolumeName->MaximumLength = VolumeName->Length;
    }
    else
    {
        //
        // server name is empty. this should only happen if we are
        // opening the redirector itself. if there is volume or other
        // components left, fail it.
        //

        if (BaseCopy.Length > sizeof(WCHAR))
        {
            return STATUS_BAD_NETWORK_PATH ;
        }
    }

    Status = ExtractPathAndFileName ( &BaseCopy, PathName, FileName );

    if (NT_SUCCESS(Status) &&
        ARGUMENT_PRESENT(FullName)) {

        //
        //  Use the feature that PathName and FileName are in the same buffer
        //  to return <pathname>\<filename>
        //

        if ( PathName->Buffer == NULL ) {

            //  return just <filename> or NULL

            *FullName =  *FileName;

        } else {
            //  Set FullFileName to <PathName>'\'<FileName>

            FullName->Buffer =  PathName->Buffer;

            FullName->Length = PathName->Length +
                FileName->Length +
                sizeof(WCHAR);

            FullName->MaximumLength = PathName->MaximumLength +
                FileName->MaximumLength +
                sizeof(WCHAR);
        }
    }

    return( Status );
}

NTSTATUS
GetServerByAddress(
    IN PIRP_CONTEXT pIrpContext,
    OUT PSCB *Scb,
    IN IPXaddress *pServerAddress
)
/*+++

Description:

    This routine looks up a server by address.  If it finds a server that
    has been connected, it returns it referenced.  Otherwise, it returns no
    server.

---*/
{

    NTSTATUS Status;
    PLIST_ENTRY ScbQueueEntry;
    KIRQL OldIrql;
    PNONPAGED_SCB pFirstNpScb, pNextNpScb;
    PNONPAGED_SCB pFoundNpScb = NULL;
    UNICODE_STRING CredentialName;

    //
    // Start at the head of the SCB list.
    //

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    if ( ScbQueue.Flink == &ScbQueue ) {
        KeReleaseSpinLock( &ScbSpinLock, OldIrql);
        return STATUS_UNSUCCESSFUL;
    }

    ScbQueueEntry = ScbQueue.Flink;
    pFirstNpScb = CONTAINING_RECORD( ScbQueueEntry,
                                     NONPAGED_SCB,
                                     ScbLinks );
    pNextNpScb = pFirstNpScb;

    //
    // Leave the first SCB referenced since we need it to
    // be there for when we walk all the way around the list.
    //

    NwReferenceScb( pFirstNpScb );
    NwReferenceScb( pNextNpScb );

    KeReleaseSpinLock( &ScbSpinLock, OldIrql);

    while ( TRUE ) {

        //
        // Check to see if the SCB address matches the address we have
        // and if the user uid matches the uid for this request.  Skip
        // matches that are abandoned anonymous creates.
        //

        if ( pNextNpScb->pScb ) {

            if ( ( RtlCompareMemory( (BYTE *) pServerAddress,
                                   (BYTE *) &pNextNpScb->ServerAddress,
                                   IPX_HOST_ADDR_LEN ) == IPX_HOST_ADDR_LEN ) &&
                 ( pIrpContext->Specific.Create.UserUid.QuadPart ==
                       pNextNpScb->pScb->UserUid.QuadPart ) &&
                 ( pNextNpScb->State != SCB_STATE_FLAG_SHUTDOWN ) &&
                 ( !IS_ANONYMOUS_SCB( pNextNpScb->pScb ) ) ) {

                if ( pIrpContext->Specific.Create.fExCredentialCreate ) {

                    //
                    // If this isn't an ex-create server, you can't use
                    // it for this operation.
                    //

                    if ( !IsCredentialName( &(pNextNpScb->ServerName) ) ) {
                        goto ContinueLoop;
                    }

                    //
                    // On a credential create, the credential supplied has
                    // to match the extended credential for the server.
                    //

                    Status = GetCredentialFromServerName( &pNextNpScb->ServerName,
                                                          &CredentialName );
                    if ( !NT_SUCCESS( Status ) ) {
                        goto ContinueLoop;
                    }

                    if ( RtlCompareUnicodeString( &CredentialName,
                                                  pIrpContext->Specific.Create.puCredentialName,
                                                  TRUE ) ) {
                        goto ContinueLoop;
                    }

                } else {

                    //
                    // If this is an ex-create server, you can't use it for
                    // this operation.
                    //

                    if ( IsCredentialName( &(pNextNpScb->ServerName) ) ) {
                        goto ContinueLoop;
                    }
                }

                pFoundNpScb = pNextNpScb;
                DebugTrace( 0, Dbg, "GetServerByAddress: %wZ\n", &pFoundNpScb->ServerName );
                break;

            }
        }

ContinueLoop:

        //
        // Otherwise, get the next one in the list.  Don't
        // forget to skip the list head.
        //

        KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

        ScbQueueEntry = pNextNpScb->ScbLinks.Flink;

        if ( ScbQueueEntry == &ScbQueue ) {
            ScbQueueEntry = ScbQueue.Flink;
        }

        NwDereferenceScb( pNextNpScb );
        pNextNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );

        if ( pNextNpScb == pFirstNpScb ) {
            KeReleaseSpinLock( &ScbSpinLock, OldIrql );
            break;
        }

        //
        // Otherwise, reference this SCB and continue.
        //

        NwReferenceScb( pNextNpScb );
        KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    }

    NwDereferenceScb( pFirstNpScb );

    if ( pFoundNpScb ) {
        *Scb = pFoundNpScb->pScb;
        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;

}

NTSTATUS
CheckScbSecurity(
    IN PIRP_CONTEXT pIrpContext,
    IN PSCB pScb,
    IN PUNICODE_STRING puUserName,
    IN PUNICODE_STRING puPassword,
    IN BOOLEAN fDeferLogon
)
/*+++

    You must be at the head of the queue to call this function.
    This function makes sure that the Scb is valid for the user
    that requested it.

---*/
{

    NTSTATUS Status;
    BOOLEAN SecurityConflict = FALSE;

    ASSERT( pScb->pNpScb->State == SCB_STATE_IN_USE );

    //
    // If there's no user name or password, there's no conflict.
    //

    if ( ( puUserName == NULL ) &&
         ( puPassword == NULL ) ) {

        return STATUS_SUCCESS;
    }

    if ( pScb->UserName.Length &&
         pScb->UserName.Buffer ) {

        //
        // Do a bindery security check if we were bindery
        // authenticated to this server.
        //

        if ( !fDeferLogon &&
             puUserName != NULL &&
             puUserName->Buffer != NULL ) {

            ASSERT( pScb->Password.Buffer != NULL );

            if ( !RtlEqualUnicodeString( &pScb->UserName, puUserName, TRUE ) ||
                 ( puPassword &&
                   puPassword->Buffer &&
                   puPassword->Length &&
                   !RtlEqualUnicodeString( &pScb->Password, puPassword, TRUE ) )) {

                SecurityConflict = TRUE;

            }
        }

    } else {

        //
        // Do an nds security check.
        //

        Status = NdsCheckCredentials( pIrpContext,
                                      puUserName,
                                      puPassword );

        if ( !NT_SUCCESS( Status )) {

            SecurityConflict = TRUE;
        }

    }

    //
    // If there was a security conflict, see if we can just
    // take this connection over (i.e. there are no open
    // files or open handles to the server).
    //

    if ( SecurityConflict ) {

        if ( ( pScb->OpenFileCount == 0 ) &&
             ( pScb->IcbCount == 0 ) ) {

            if ( pScb->UserName.Buffer ) {
                FREE_POOL( pScb->UserName.Buffer );
            }

            RtlInitUnicodeString( &pScb->UserName, NULL );
            RtlInitUnicodeString( &pScb->Password, NULL );
            pScb->pNpScb->State = SCB_STATE_LOGIN_REQUIRED;

        } else {

            DebugTrace( 0, Dbg, "SCB security conflict.\n", 0 );
            return STATUS_NETWORK_CREDENTIAL_CONFLICT;

        }

    }

    DebugTrace( 0, Dbg, "SCB security check succeeded.\n", 0 );
    return STATUS_SUCCESS;

}

NTSTATUS
GetScb(
    OUT PSCB *Scb,
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING Server,
    IN IPXaddress *pServerAddress,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN DeferLogon,
    OUT PBOOLEAN Existing
)
/*+++

Description:

    This routine locates an existing SCB or creates a new SCB.
    This is the first half of the original CreateScb routine.

Locks:

    See the anonymous create information in CreateScb().

---*/
{

    NTSTATUS Status;
    PSCB pScb = NULL;
    PNONPAGED_SCB pNpScb = NULL;
    BOOLEAN ExistingScb = TRUE;
    UNICODE_STRING UidServer;
    UNICODE_STRING ExCredName;
    PUNICODE_STRING puConnectName;
    KIRQL OldIrql;

    DebugTrace( 0, Dbg, "GetScb... %wZ\n", Server );

    if ( pServerAddress != NULL ) {
        DebugTrace( 0, Dbg, " ->Server Address         = (provided)\n", 0 );
    } else {
        DebugTrace( 0, Dbg, " ->Server Address         = NULL\n", 0 );
    }

    RtlInitUnicodeString( &UidServer, NULL );

    if ( ( Server == NULL ) ||
         ( Server->Length == 0 ) ) {

        //
        // No server name was provided.  Either this is a connect by address,
        // or a connect to a nearby bindery server (defaulting to the preferred
        // server).
        //

        if ( pServerAddress == NULL ) {

            //
            // No server address was provided, so this is an attempt to open
            // a nearby bindery server.
            //

            while (TRUE) {

                //
                // The loop checks that after we get to the front, the SCB
                // is still in the state we wanted.  If not, we need to
                // reselect another.
                //

                pNpScb = SelectConnection( NULL );

                //
                // Note: We'd like to call SelectConnection with the pNpScb
                // that we last tried, but if the scavenger runs before
                // this loop gets back to the select connection, we could
                // pass a bum pointer to SelectConnection, which is bad.
                //

                if ( pNpScb != NULL) {

                    pScb = pNpScb->pScb;

                    //
                    //  Queue ourselves to the SCB, wait to get to the front to
                    //  protect access to server State.
                    //

                    pIrpContext->pNpScb = pNpScb;
                    pIrpContext->pScb = pScb;

                    NwAppendToQueueAndWait( pIrpContext );

                    //
                    // These states have to match the conditions of the
                    // SelectConnection to prevent an infinite loop.
                    //

                    if (!((pNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) ||
                          (pNpScb->State == SCB_STATE_LOGIN_REQUIRED ) ||
                          (pNpScb->State == SCB_STATE_IN_USE ))) {

                        //
                        // No good any more as default server, select another.
                        //

                        pScb = NULL ;
                        NwDequeueIrpContext( pIrpContext, FALSE );
                        NwDereferenceScb( pNpScb );
                        continue ;

                    }
                }

                //
                // otherwise, we're done
                //

                break ;

            }

        } else {

            //
            // An address was provided, so we are attempting to do a lookup
            // based on address.  The server that we are looking for might
            // exist but not yet have its address recorded, so if we do an
            // anonymous create, we have to check at the end whether or not
            // someone else came in and successfully created while we were
            // looking up the name.
            //
            // We don't have to hold the RCB anymore since colliding creates
            // have to be handled gracefully anyway.
            //

            Status = GetServerByAddress( pIrpContext, &pScb, pServerAddress );

            if ( !NT_SUCCESS( Status ) ) {

                PLIST_ENTRY pTemp;

                //
                // No anonymous creates are allowed if we are not allowed
                // to send packets to the net (because it's not possible for
                // us to resolve the address to a name).
                //

                if ( BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_NOCONNECT ) ) {
                    return STATUS_BAD_NETWORK_PATH;
                }

                //
                // There's no connection to this server, so we'll
                // have to create one.  Let's start with an anonymous
                // Scb.
                //

                Status = NwAllocateAndInitScb( pIrpContext,
                                               NULL,
                                               NULL,
                                               &pScb );

                if ( !NT_SUCCESS( Status )) {
                    return Status;
                }

                //
                // We've made the anonymous create, so put it on the scb
                // list and get to the head of the queue.
                //

                SetFlag( pIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE );

                pIrpContext->pScb = pScb;
                pIrpContext->pNpScb = pScb->pNpScb;

                ExInterlockedInsertHeadList( &pScb->pNpScb->Requests,
                                             &pIrpContext->NextRequest,
                                             &pScb->pNpScb->NpScbSpinLock );

                pTemp = &pScb->pNpScb->ScbLinks;
                KeAcquireSpinLock(&ScbSpinLock, &OldIrql);
                InsertTailList(&ScbQueue, pTemp);
                KeReleaseSpinLock(&ScbSpinLock, OldIrql);

                DebugTrace( 0, Dbg, "GetScb started an anonymous create.\n", 0 );
                ExistingScb = FALSE;

            } else {

                //
                // Get to the head of the queue and see if this was
                // an abandoned anonymous create.  If so, get the
                // right server and continue.
                //

                pIrpContext->pScb = pScb;
                pIrpContext->pNpScb = pScb->pNpScb;
                NwAppendToQueueAndWait( pIrpContext );

                if ( pScb->pNpScb->State == SCB_STATE_FLAG_SHUTDOWN ) {

                    //
                    // The create abandoned this scb, redoing a
                    // GetServerByAddress() is guaranteed to get
                    // us a good server if there is a server out
                    // there.
                    //

                    NwDequeueIrpContext( pIrpContext, FALSE );
                    NwDereferenceScb( pScb->pNpScb );

                    Status = GetServerByAddress( pIrpContext, &pScb, pServerAddress );

                    if ( NT_SUCCESS( Status ) ) {
                        ASSERT( pScb != NULL );
                        ASSERT( !IS_ANONYMOUS_SCB( pScb ) );
                    }

                } else {

                    ASSERT( !IS_ANONYMOUS_SCB( pScb ) );
                }
            }

            ASSERT( pScb != NULL );
            pNpScb = pScb->pNpScb;
        }

    } else {

        //
        // A server name was provided, so we are doing a straight
        // lookup or create by name.  Do we need to munge the name
        // for a supplemental credential connect?
        //

        RtlInitUnicodeString( &ExCredName, NULL );

        if ( ( pIrpContext->Specific.Create.fExCredentialCreate ) &&
             ( !IsCredentialName( Server ) ) ) {

            Status = BuildExCredentialServerName( Server,
                                                  pIrpContext->Specific.Create.puCredentialName,
                                                  &ExCredName );

            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }

            puConnectName = &ExCredName;

        } else {

            puConnectName = Server;
        }

        Status = MakeUidServer( &UidServer,
                                &pIrpContext->Specific.Create.UserUid,
                                puConnectName );


        if ( ExCredName.Buffer ) {
            FREE_POOL( ExCredName.Buffer );
        }

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        DebugTrace( 0, Dbg, " ->UidServer              = %wZ\n", &UidServer );

        ExistingScb = NwFindScb( &pScb, pIrpContext, &UidServer, Server );

        ASSERT( pScb != NULL );
        pNpScb = pScb->pNpScb;

        pIrpContext->pNpScb = pNpScb;
        pIrpContext->pScb = pScb;
        NwAppendToQueueAndWait(pIrpContext);

    }

    //
    // 1) We may or may not have a server (evidenced by pScb).
    //
    // 2) If we have a server and ExistingScb is TRUE, we have
    //    an existing server, possibly already connected.
    //    Otherwise, we have a newly created server that
    //    may or may not be anonymous.
    //
    // 3) If we are logged into this server make sure the supplied
    //    username and password, match the username and password
    //    that we logged in with.
    //

    if ( ( pScb ) && ( ExistingScb ) ) {

        if ( pNpScb->State == SCB_STATE_IN_USE ) {

            Status = CheckScbSecurity( pIrpContext,
                                       pScb,
                                       UserName,
                                       Password,
                                       DeferLogon );

            if ( !NT_SUCCESS( Status ) ) {

                if ( UidServer.Buffer != NULL ) {
                    FREE_POOL( UidServer.Buffer );
                }

                NwDequeueIrpContext( pIrpContext, FALSE );
                NwDereferenceScb( pNpScb );
                return Status;
            }
        }
    }

    *Scb = pScb;
    *Existing = ExistingScb;

#ifdef NWDBG

    if ( pScb != NULL ) {

        //
        // If we have a server, the SCB is referenced and we will
        // be at the head of the queue.
        //

        ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );

    }

#endif

    if ( UidServer.Buffer != NULL ) {
        FREE_POOL( UidServer.Buffer );
    }

    DebugTrace( 0, Dbg, "GetScb returned %08lx\n", pScb );
    return STATUS_SUCCESS;

}

NTSTATUS
ConnectScb(
    IN PSCB *Scb,
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING Server,
    IN IPXaddress *pServerAddress,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN DeferLogon,
    IN BOOLEAN DeleteConnection,
    IN BOOLEAN ExistingScb
)
/*+++

Description:

    This routine puts the provided scb in the connected state.
    This is the second half of the original CreateScb routine.

Arguments:

    Scb              - The scb for the server we want to connect.
    pIrpContext      - The context for this request.
    Server           - The name of the server, or NULL.
    pServerAddress   - The address of the server, or NULL,
    UserName         - The name of the user to connect as, or NULL.
    Password         - The password for the user, or NULL.
    DeferLogon       - Should we defer the logon?
    DeleteConnection - Should we succeed even without the net so that
                       the delete request will succeed?
    ExistingScb      - Is this an existing SCB?

    If the SCB is anonymous, we need to safely check for colliding
    creates when we find out who the server is.

    If this is a reconnect attempt, this routine will not dequeue the
    irp context, which could cause a deadlock in the reconnect logic.

---*/
{

    NTSTATUS Status = STATUS_SUCCESS;

    PSCB pScb = *Scb;
    PNONPAGED_SCB pNpScb = NULL;

    BOOLEAN AnonymousScb = FALSE;
    PSCB pCollisionScb = NULL;

    NTSTATUS LoginStatus;
    BOOLEAN TriedNdsLogin;

    PLOGON pLogon;
    BOOLEAN DeferredLogon = DeferLogon;
    PNDS_SECURITY_CONTEXT pNdsContext;
    NTSTATUS CredStatus;

    DebugTrace( 0, Dbg, "ConnectScb... %08lx\n", pScb );

    //
    // If we already have an SCB, find out where in the
    // connect chain we need to start off.
    //

    if ( pScb ) {

        pNpScb = pScb->pNpScb;
        AnonymousScb = IS_ANONYMOUS_SCB( pScb );

        if ( ExistingScb ) {

            ASSERT( !AnonymousScb );

            //
            //  If this SCB is in STATE_ATTACHING, we need to check
            //  the address in the SCB to make sure that it was at one
            //  point a valid server.  If it wasn't, then we shouldn't
            //  honor this create because it's probably a tree create.
            //

            if ( DeleteConnection ) {

                ASSERT( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) );

                if ( ( pNpScb->State == SCB_STATE_ATTACHING ) &&
                     ( (pNpScb->ServerAddress).Socket == 0 ) ) {

                    Status = STATUS_BAD_NETWORK_PATH;
                    goto CleanupAndExit;

                } else {

                    NwDequeueIrpContext( pIrpContext, FALSE );
                    return STATUS_SUCCESS;
                }
            }

RedoConnect:

            if ( pNpScb->State == SCB_STATE_ATTACHING ) {
                goto GetAddress;
            } else if ( pNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) {
                goto Connect;
            } else if ( pNpScb->State == SCB_STATE_LOGIN_REQUIRED ) {
                goto Login;
            } else if ( pNpScb->State == SCB_STATE_IN_USE ) {
                goto InUse;
            } else {

                DebugTrace( 0, Dbg, "ConnectScb: Unknown Scb State %08lx\n", pNpScb->State );
                Status = STATUS_INVALID_PARAMETER;
                goto CleanupAndExit;
            }

        } else {

            //
            // This is a new SCB, we have to run through the whole routine.
            //

            pNpScb->State = SCB_STATE_ATTACHING;
        }

    }

GetAddress:

    //
    //  Set the reroute attempted bit so that we don't try
    //  to reconnect during the connect.
    //

    SetFlag( pIrpContext->Flags, IRP_FLAG_REROUTE_ATTEMPTED );

    if ( !pServerAddress ) {

        //
        // If we don't have an address, this SCB cannot be anonymous!!
        //

        ASSERT( !AnonymousScb );

        //
        // We have to cast an exception frame for this legacy routine
        // that still uses structured exceptions.
        //

        try {

            pNpScb = FindServer( pIrpContext, pNpScb, Server );

            ASSERT( pNpScb != NULL );

            //
            // This is redundant unless the starting server was NULL.
            // FindServer returns the same SCB we provided to it
            // unless we called it with NULL.
            //

            pScb = pNpScb->pScb;
            pIrpContext->pNpScb = pNpScb;
            pIrpContext->pScb = pScb;
            NwAppendToQueueAndWait( pIrpContext );

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
            goto CleanupAndExit;
        }

    } else {

        //
        // Build the address into the NpScb since we already know it.
        //

        RtlCopyMemory( &pNpScb->ServerAddress,
                       pServerAddress,
                       sizeof( TDI_ADDRESS_IPX ) );

        if ( pNpScb->ServerAddress.Socket != NCP_SOCKET ) {
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "CreateScb supplied server socket is deviant.\n", 0 );
        }

        BuildIpxAddress( pNpScb->ServerAddress.Net,
                         pNpScb->ServerAddress.Node,
                         pNpScb->ServerAddress.Socket,
                         &pNpScb->RemoteAddress );

        pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;

    }

Connect:

    //
    // FindServer may have connected us to the server already,
    // so we may be able to skip the reconnect here.
    //

    if ( pNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) {

        //
        // If this is an anonymous scb, we have to be prepared
        // for ConnectToServer() to find that we've already connected
        // this server by name.  In this case, we cancel the
        // anonymous create and use the server that was created
        // while we were looking up the name.
        //

        Status = ConnectToServer( pIrpContext, &pCollisionScb );

        if (!NT_SUCCESS(Status)) {
            goto CleanupAndExit;
        }

        //
        // We succeeded.  If there's a collision scb, then we need to
        // abandon the anonymous scb and use the scb that we collided
        // with.  Otherwise, we successfully completed an anonymous
        // connect and can go on with the create normally.
        //

        if ( pCollisionScb ) {

            ASSERT( AnonymousScb );

            //
            // Deref and dequeue from the abandoned server.
            //

            NwDequeueIrpContext( pIrpContext, FALSE );
            NwDereferenceScb( pIrpContext->pNpScb );

            //
            // Queue to the appropriate server.
            //

            pIrpContext->pScb = pCollisionScb;
            pIrpContext->pNpScb = pCollisionScb->pNpScb;
            NwAppendToQueueAndWait( pIrpContext );

            pScb = pCollisionScb;
            pNpScb = pCollisionScb->pNpScb;
            *Scb = pCollisionScb;

            //
            // Re-start connecting the scb.
            //

            AnonymousScb = FALSE;
            ExistingScb = TRUE;

            pCollisionScb = NULL;

            DebugTrace( 0, Dbg, "Re-doing connect on anonymous collision.\n", 0 );
            goto RedoConnect;

        }

        DebugTrace( +0, Dbg, " Logout from server - just in case\n", 0);

        Status = ExchangeWithWait (
                     pIrpContext,
                     SynchronousResponseCallback,
                     "F",
                     NCP_LOGOUT );

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( !NT_SUCCESS( Status ) ) {
            goto CleanupAndExit;
        }

        DebugTrace( +0, Dbg, " Connect to real server = %X\n", Status);

        pNpScb->State = SCB_STATE_LOGIN_REQUIRED;
    }

Login:

    //
    // If we have credentials for the tree and this server was named
    // explicitly, we shouldn't defer the login or else the browse
    // view of the tree may be wrong.  For this reason, NdsServerAuthenticate
    // has to be a straight shot call and can't remove us from the head
    // of the queue.
    //

    if ( ( ( Server != NULL ) || ( pServerAddress != NULL ) ) &&
         ( DeferredLogon ) &&
         ( pScb->MajorVersion > 3 ) &&
         ( pScb->UserName.Length == 0 ) ) {

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        pLogon = FindUser( &pScb->UserUid, FALSE );
        NwReleaseRcb( &NwRcb );

        if ( pLogon ) {

            CredStatus = NdsLookupCredentials( pIrpContext,
                                               &pScb->NdsTreeName,
                                               pLogon,
                                               &pNdsContext,
                                               CREDENTIAL_READ,
                                               FALSE );

            if ( NT_SUCCESS( CredStatus ) ) {

                if ( ( pNdsContext->Credential != NULL ) &&
                     ( pNdsContext->CredentialLocked == FALSE ) ) {

                    DebugTrace( 0, Dbg, "Forcing authentication to %wZ.\n",
                                &pScb->UidServerName );
                    DeferredLogon = FALSE;
                }

                NwReleaseCredList( pLogon, pIrpContext );
            }
        }
    }

    if (pNpScb->State == SCB_STATE_LOGIN_REQUIRED && !DeferredLogon ) {

        //
        //  NOTE:   DoBinderyLogon() and DoNdsLogon() may return a
        //          warning status. If they do, we must return the
        //          warning status to the caller.
        //

        Status = STATUS_UNSUCCESSFUL;
        TriedNdsLogin = FALSE;

        //
        // We force a bindery login for a non 4.x server.  Otherwise, we
        // allow a fall-back from NDS style authentication to bindery style
        // authentication.
        //

        if ( pScb->MajorVersion >= 4 ) {

            ASSERT( pScb->NdsTreeName.Length != 0 );

            Status = DoNdsLogon( pIrpContext, UserName, Password );

            if ( NT_SUCCESS( Status ) ) {

                //
                // Do we need to re-license the connection?
                //

                if ( ( pScb->VcbCount > 0 ) || ( pScb->OpenNdsStreams > 0 ) ) {

                    Status = NdsLicenseConnection( pIrpContext );

                    if ( !NT_SUCCESS( Status ) ) {
                        Status = STATUS_REMOTE_SESSION_LIMIT;
                    }
                }

            }

            TriedNdsLogin = TRUE;
            LoginStatus = Status;

        }

        if ( !NT_SUCCESS( Status ) ) {

            Status = DoBinderyLogon( pIrpContext, UserName, Password );

        }

        if ( !NT_SUCCESS( Status ) ) {

            if ( TriedNdsLogin ) {

                //
                // Both login attempts have failed.  We usually prefer
                // the NDS status, but not always.
                //

               if ( ( Status != STATUS_WRONG_PASSWORD ) &&
                    ( Status != STATUS_ACCOUNT_DISABLED ) ) {
                   Status = LoginStatus;
               }
            }

            //
            //  Couldn't log on, be good boys and disconnect.
            //

            ExchangeWithWait (
                pIrpContext,
                SynchronousResponseCallback,
                "D-" );          // Disconnect

            Stats.Sessions--;

            if ( pScb->MajorVersion == 2 ) {
                Stats.NW2xConnects--;
            } else if ( pScb->MajorVersion == 3 ) {
                Stats.NW3xConnects--;
            } else if ( pScb->MajorVersion >= 4 ) {
                Stats.NW4xConnects--;
            }

            //
            // Demote this scb to reconnect required and exit.
            //

            pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;
            goto CleanupAndExit;
        }

        pNpScb->State = SCB_STATE_IN_USE;
    }

    //
    // We have to be at the head of the queue to do the reconnect.
    //

    if ( BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) ) {
        ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );
    } else {
        NwAppendToQueueAndWait( pIrpContext );
    }

    ReconnectScb( pIrpContext, pScb );

InUse:

    //
    // Ok, we've completed the connect routine.  Return this good server.
    //

    *Scb = pScb;

CleanupAndExit:

    //
    // The reconnect path must not do anything to remove the irp context from
    // the head of the queue since it also owns the irp context in the second
    // position on the queue and that irp context is running.
    //

    if ( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_RECONNECT_ATTEMPT ) ) {
        NwDequeueIrpContext( pIrpContext, FALSE );
    }

    DebugTrace( 0, Dbg, "ConnectScb: Connected %08lx\n", pScb );
    DebugTrace( 0, Dbg, "ConnectScb: Status was %08lx\n", Status );
    return Status;

}

NTSTATUS
CreateScb(
    OUT PSCB *Scb,
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING Server,
    IN IPXaddress *pServerAddress,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN DeferLogon,
    IN BOOLEAN DeleteConnection
)
/*++

Routine Description:

    This routine connects to the requested server.

    The following mix of parameters are valid:

       Server Name, No Net Address - The routine will look up
           up the SCB or create a new one if necessary, getting
           the server address from a nearby bindery.

       No Server Name, Valid Net Address - The routine will
           look up the SCB by address or create a new one if
           necessary.  The name of the server will be set in
           the SCB upon return.

       Server Name, Valid Net Address - The routine will look
           up the SCB by name or will create a new one if
           necessary.  The supplied server address will be used,
           sparing a bindery query.

       No Server Name, No Net Address - A connection to the
           preferred server or a nearby server will be returned.

Arguments:

    Scb              - The pointer to the scb in question.
    pIrpContext      - The information for this request.
    Server           - The name of the server, or NULL.
    pServerAddress   - The address of the server, or NULL.
    UserName         - The username for the connect, or NULL.
    Password         - The password for the connect, or NULL.
    DeferLogon       - Should we defer the logon until later?
    DeleteConnection - Should we allow this even when there's no
                       net response so that the connection can
                       be deleted?

Return Value:

    NTSTATUS - Status of operation.  If the return status is STATUS_SUCCESS,
    then Scb must point to a valid Scb.  The irp context pointers will also
    be set, but the irp context will not be on the scb queue.

--*/
{

    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PSCB pScb = NULL;
    PNONPAGED_SCB pOriginalNpScb = pIrpContext->pNpScb;
    PSCB pOriginalScb = pIrpContext->pScb;
    BOOLEAN ExistingScb = FALSE;
    BOOLEAN AnonymousScb = FALSE;
    PLOGON pLogon;
    PNDS_SECURITY_CONTEXT pNdsContext;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "CreateScb....\n", 0);

    //
    // Do not allow any SCB opens unless the redirector is running
    // unless they are no connect creates and we are waiting to bind.
    //

    if ( NwRcb.State != RCB_STATE_RUNNING ) {

        if ( ( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_NOCONNECT ) ||
             ( NwRcb.State != RCB_STATE_NEED_BIND ) ) ) {

            *Scb = NULL;
            DebugTrace( -1, Dbg, "CreateScb -> %08lx\n", STATUS_REDIRECTOR_NOT_STARTED );
            return STATUS_REDIRECTOR_NOT_STARTED;
        }
    }

    if ( UserName != NULL ) {
        DebugTrace( 0, Dbg, " ->UserName               = %wZ\n", UserName );
    } else {
        DebugTrace( 0, Dbg, " ->UserName               = NULL\n", 0 );
    }

    if ( Password != NULL ) {
        DebugTrace( 0, Dbg, " ->Password               = %wZ\n", Password );
    } else {
        DebugTrace( 0, Dbg, " ->Password               = NULL\n", 0 );
    }

    //
    // Get the SCB for this server.
    //

    Status = GetScb( &pScb,
                     pIrpContext,
                     Server,
                     pServerAddress,
                     UserName,
                     Password,
                     DeferLogon,
                     &ExistingScb );

    if ( !NT_SUCCESS( Status ) ) {
        *Scb = NULL;
        return Status;
    }

    //
    // At this point, we may or may not have an SCB.
    //
    // If we have an SCB, we know:
    //
    //     1. The scb is referenced.
    //     2. We are at the head of the queue.
    //
    // IMPORTANT POINT: The SCB may be anonymous.  If it is,
    // we do not hold the RCB, but rather we have to re-check
    // whether or not the server has shown up via a different
    // create when we find out who the anonymous server is.
    // We do this because there is a window where we have a
    // servers name but not its address and so our lookup by
    // address might be inaccurate.
    //

    if ( ( pScb ) && IS_ANONYMOUS_SCB( pScb ) ) {
        AnonymousScb = TRUE;
    }

    //
    // If we have a fully connected SCB, we need to go no further.
    //

    if ( ( pScb ) && ( pScb->pNpScb->State == SCB_STATE_IN_USE ) ) {

        ASSERT( !AnonymousScb );

        if ( ( pScb->MajorVersion >= 4 ) &&
             ( pScb->UserName.Buffer == NULL ) ) {

            //
            // This is an NDS authenticated server and we have
            // to make sure the credentials aren't locked for
            // logout.
            //

            NwAcquireExclusiveRcb( &NwRcb, TRUE );
            pLogon = FindUser( &pScb->UserUid, FALSE );
            NwReleaseRcb( &NwRcb );

            if ( pLogon ) {

                Status = NdsLookupCredentials( pIrpContext,
                                               &pScb->NdsTreeName,
                                               pLogon,
                                               &pNdsContext,
                                               CREDENTIAL_READ,
                                               FALSE );

                if ( NT_SUCCESS( Status ) ) {

                    if ( ( pNdsContext->Credential != NULL ) &&
                         ( pNdsContext->CredentialLocked == TRUE ) ) {

                        DebugTrace( 0, Dbg, "Denying create... we're logging out.\n", 0 );
                        Status = STATUS_DEVICE_BUSY;
                    }

                    NwReleaseCredList( pLogon, pIrpContext );
                }
            }
        }

        NwDequeueIrpContext( pIrpContext, FALSE );

        //
        // We must not change the irp context pointers if we're going
        // to fail this call or we may mess up ref counts and what not.
        //

        if ( NT_SUCCESS( Status ) ) {

           *Scb = pScb;

        } else {

           *Scb = NULL;
           NwDereferenceScb( pScb->pNpScb );

           pIrpContext->pNpScb = pOriginalNpScb;
           pIrpContext->pScb = pOriginalScb;

        }


        DebugTrace( -1, Dbg, "CreateScb: pScb = %08lx\n", pScb );
        return Status;
    }

    //
    // Run through the connect routines for this scb.  The scb may
    // be NULL if we're still looking for a nearby server.
    //

    Status = ConnectScb( &pScb,
                         pIrpContext,
                         Server,
                         pServerAddress,
                         UserName,
                         Password,
                         DeferLogon,
                         DeleteConnection,
                         ExistingScb );

    //
    // If ConnectScb fails, remove the extra ref count so
    // the scavenger will clean it up.  Anonymous failures
    // are also cleaned up by the scavenger.
    //

    if ( !NT_SUCCESS( Status ) ) {

        if ( pScb ) {
            NwDereferenceScb( pScb->pNpScb );
        }

        //
        // We must not change the irp context pointers if we're going
        // to fail this call or we may mess up ref counts and what not.
        //

        pIrpContext->pNpScb = pOriginalNpScb;
        pIrpContext->pScb = pOriginalScb;
        *Scb = NULL;

        DebugTrace( -1, Dbg, "CreateScb: Status = %08lx\n", Status );
        return Status;
    }

    //
    // If ConnectScb succeeds, then we must have an scb, the scb must
    // be in the IN_USE state (or LOGIN_REQUIRED if DeferLogon was
    // specified), it must be referenced, and we should not be on the
    // queue.
    //

    ASSERT( pScb );
    ASSERT( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE ) );
    ASSERT( pIrpContext->pNpScb == pScb->pNpScb );
    ASSERT( pIrpContext->pScb == pScb );
    ASSERT( pScb->pNpScb->Reference > 0 );

    *Scb = pScb;
    DebugTrace(-1, Dbg, "CreateScb -> pScb = %08lx\n", pScb );
    ASSERT( NT_SUCCESS( Status ) );

    return Status;
}
#define CTX_Retries 10

PNONPAGED_SCB
FindServer(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb,
    PUNICODE_STRING ServerName
    )
/*++

Routine Description:

    This routine attempts to get the network address of a server.  If no
    servers are known, it first sends a find nearest SAP.

Arguments:

    pIrpContext - A pointer to the request parameters.

    pNpScb - A pointer to the non paged SCB for the server to get the
        address of.

Return Value:

    NONPAGED_SCB - A pointer the nonpaged SCB.  This is the same as the
        input value, unless the input SCB was NULL.  Then this is a
        pointer to the nearest server SCB.

    This routine raises status if it fails to get the server's address.

--*/
{
    NTSTATUS Status;
    ULONG Attempts;
    BOOLEAN FoundServer = FALSE;
    PNONPAGED_SCB pNearestNpScb = NULL;
    PNONPAGED_SCB pLastNpScb = NULL;

    BOOLEAN SentFindNearest = FALSE;
    BOOLEAN SentGeneral = FALSE;
    PMDL ReceiveMdl = NULL;
    PUCHAR ReceiveBuffer = NULL;
    IPXaddress  ServerAddress;

    BOOLEAN ConnectedToNearest = FALSE;
    BOOLEAN AllocatedIrpContext = FALSE;
    BOOLEAN LastScbWasValid;
    PIRP_CONTEXT pNewIrpContext;
    int ResponseCount;
    int NewServers;
    ULONG RetryCount = MAX_SAP_RETRIES;

    static LARGE_INTEGER TimeoutWait = {0,0};
    LARGE_INTEGER Now;

    PAGED_CODE();

    //
    //  If we had a SAP timeout less than 10 seconds ago, just fail this
    //  request immediately.  This allows dumb apps to exit a lot faster.
    //

    KeQuerySystemTime( &Now );
    if ( Now.QuadPart < TimeoutWait.QuadPart ) {
        ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
    }

    try {

        if (IsTerminalServer()) {
            // 
            // 1/31/97 cjc (Citrix code merge)
            //             Fix for Mellon Bank who restricted access based on the 
            //             preferred server the user logs into.  This caused a 
            //             problem for a user who tries to logon to a server that 
            //             the previous user doesn't have accesss to.  The previous 
            //             user's server is used to get the address of the current 
            //             logon user's preferred server but he can't see the new
            //             user's server.  Modifed this so it loops thru 10 servers
            //             rather than just the 1st 2 in the list.
            //
            RetryCount =CTX_Retries;
        }
        for ( Attempts = 0;  Attempts < RetryCount && !FoundServer ; Attempts++ ) {

            //
            //  If this SCB is now marked RECONNECT_REQUIRED, then
            //  it responded to the find nearest and we can immediately
            //  try to connect to it.
            //

            if ( pNpScb != NULL &&
                 pNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) {

                return pNpScb;
            }

            //
            //  Pick a server to use to find the address of the server that
            //  we are really interested in.
            //

            if (pLastNpScb) {

                //
                //  For some reason we couldn't use pNearestScb. Scan from this
                //  server onwards.
                //

                pNearestNpScb = SelectConnection( pLastNpScb );

                //  Allow pLastNpScb to be deleted.

                NwDereferenceScb( pLastNpScb );

                pLastNpScb = NULL;

                LastScbWasValid = TRUE;

            } else {

                pNearestNpScb = SelectConnection( NULL );
                LastScbWasValid = FALSE;

            }

            if ( pNearestNpScb == NULL ) {

                int i;

                if (LastScbWasValid) {
                    ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
                    return NULL;
                }
                //
                //  If we sent a find nearest, and still don't have a single
                //  entry in the server list, it's time to give up.
                //

                if (( SentFindNearest) &&
                    ( SentGeneral )) {

                    Error(
                        EVENT_NWRDR_NO_SERVER_ON_NETWORK,
                        STATUS_OBJECT_NAME_NOT_FOUND,
                        NULL,
                        0,
                        0 );

                    ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
                    return NULL;
                }

                //
                //  We don't have any active servers in the list.  Queue our
                //  IrpContext to the NwPermanentNpScb.  This insures that
                //  only one thread in the system in doing a find nearest at
                //  any one time.
                //

                DebugTrace( +0, Dbg, " Nearest Server\n", 0);

                if ( !AllocatedIrpContext ) {
                    AllocatedIrpContext = NwAllocateExtraIrpContext(
                                              &pNewIrpContext,
                                              &NwPermanentNpScb );

                    if ( !AllocatedIrpContext ) {
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                    }
                }

                pNewIrpContext->pNpScb = &NwPermanentNpScb;

                //
                //  Allocate an extra buffer large enough for 4
                //  find nearest responses, or a general SAP response.
                //

                pNewIrpContext->Specific.Create.FindNearestResponseCount = 0;
                NewServers = 0;


                ReceiveBuffer = ALLOCATE_POOL_EX(
                                    NonPagedPool,
                                    MAX_SAP_RESPONSE_SIZE );

                pNewIrpContext->Specific.Create.FindNearestResponse[0] = ReceiveBuffer;

                for ( i = 1; i < MAX_SAP_RESPONSES ; i++ ) {
                    pNewIrpContext->Specific.Create.FindNearestResponse[i] =
                        ReceiveBuffer + i * SAP_RECORD_SIZE;
                }

                //
                //  Get the tick count for this net, so that we know how
                //  long to wait for SAP responses.
                //

                (VOID)GetTickCount( pNewIrpContext, &NwPermanentNpScb.TickCount );
                NwPermanentNpScb.SendTimeout = NwPermanentNpScb.TickCount + 10;

                if (!SentFindNearest) {

                    //
                    //  Send a find nearest SAP, and wait for up to several
                    //  responses. This allows us to handle a busy server
                    //  that responds quickly to SAPs but will not accept
                    //  connections.
                    //

                    Status = ExchangeWithWait (
                                pNewIrpContext,
                                ProcessFindNearest,
                                "Aww",
                                SAP_FIND_NEAREST,
                                SAP_SERVICE_TYPE_SERVER );

                    if ( Status == STATUS_NETWORK_UNREACHABLE ) {
                       
                        //
                        // IPX is not bound to anything that is currently
                        // up (which means it's probably bound only to the
                        // RAS WAN wrapper).  Don't waste 20 seconds trying
                        // to find a server.
                        //
                        
                        DebugTrace( 0, Dbg, "Aborting FindNearest.  No Net.\n", 0 );
                        NwDequeueIrpContext( pNewIrpContext, FALSE );
                        ExRaiseStatus( STATUS_NETWORK_UNREACHABLE );
                    }

                    //
                    //  Process the set of find nearest responses.
                    //

                    for (i = 0; i < (int)pNewIrpContext->Specific.Create.FindNearestResponseCount; i++ ) {
                        if (ProcessFindNearestEntry(
                                pNewIrpContext,
                                (PSAP_FIND_NEAREST_RESPONSE)pNewIrpContext->Specific.Create.FindNearestResponse[i] )
                            ) {

                            //
                            //  We found a server that was previously unknown.
                            //

                            NewServers++;
                        }
                    }
                }

                if (( !NewServers ) &&
                    ( !SentGeneral)){

                    SentGeneral = TRUE;

                    //
                    //  Either no SAP responses or can't connect to nearest servers.
                    //  Try a general SAP.
                    //

                    ReceiveMdl = ALLOCATE_MDL(
                                     ReceiveBuffer,
                                     MAX_SAP_RESPONSE_SIZE,
                                     TRUE,
                                     FALSE,
                                     NULL );

                    if ( ReceiveMdl == NULL ) {
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                    }

                    MmBuildMdlForNonPagedPool( ReceiveMdl );
                    pNewIrpContext->RxMdl->Next = ReceiveMdl;

                    Status = ExchangeWithWait (
                                 pNewIrpContext,
                                 SynchronousResponseCallback,
                                 "Aww",
                                 SAP_GENERAL_REQUEST,
                                 SAP_SERVICE_TYPE_SERVER );

                    if ( NT_SUCCESS( Status ) ) {
                        DebugTrace( 0, Dbg, "Received %d bytes\n", pNewIrpContext->ResponseLength );
                        ResponseCount = ( pNewIrpContext->ResponseLength - 2 ) / SAP_RECORD_SIZE;

                        //
                        //  Process at most MAX_SAP_RESPONSES servers.
                        //

                        if ( ResponseCount > MAX_SAP_RESPONSES ) {
                            ResponseCount = MAX_SAP_RESPONSES;
                        }

                        for ( i = 0; i < ResponseCount; i++ ) {
                            ProcessFindNearestEntry(
                                pNewIrpContext,
                                (PSAP_FIND_NEAREST_RESPONSE)(pNewIrpContext->rsp + SAP_RECORD_SIZE * i)  );
                        }
                    }

                    pNewIrpContext->RxMdl->Next = NULL;
                    FREE_MDL( ReceiveMdl );
                    ReceiveMdl = NULL;
                }

                //
                //  We're done with the find nearest.  Free the buffer and
                //  dequeue from the permanent SCB.
                //

                FREE_POOL( ReceiveBuffer );
                ReceiveBuffer = NULL;
                NwDequeueIrpContext( pNewIrpContext, FALSE );

                if ( !NT_SUCCESS( Status ) &&
                     pNewIrpContext->Specific.Create.FindNearestResponseCount == 0 ) {

                    //
                    //  If the SAP timed out, map the error for MPR.
                    //

                    if ( Status == STATUS_REMOTE_NOT_LISTENING ) {
                        Status = STATUS_BAD_NETWORK_PATH;
                    }

                    //
                    //  Setup the WaitTimeout, and fail this request.
                    //

                    KeQuerySystemTime( &TimeoutWait );
                    TimeoutWait.QuadPart += NwOneSecond * 10;

                    ExRaiseStatus( Status );
                    return NULL;
                }

                SentFindNearest = TRUE;

            } else {

                if ( !AllocatedIrpContext ) {
                    AllocatedIrpContext = NwAllocateExtraIrpContext(
                                              &pNewIrpContext,
                                              pNearestNpScb );

                    if ( !AllocatedIrpContext ) {
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                    }
                }

                //
                //  Point the IRP context at the nearest server.
                //

                pNewIrpContext->pNpScb = pNearestNpScb;
                NwAppendToQueueAndWait( pNewIrpContext );

                if ( pNearestNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) {

                    //
                    //  We have no connection to this server, try to
                    //  connect now.  This is not a valid path for an
                    //  anonymous create, so there's no chance that
                    //  there will be a name collision.
                    //

                    Status = ConnectToServer( pNewIrpContext, NULL );
                    if ( !NT_SUCCESS( Status ) ) {

                        //
                        //  Failed to connect to the server.  Give up.
                        //  We'll try another server.
                        //

                        NwDequeueIrpContext( pNewIrpContext, FALSE );

                        //  Keep pNearestScb referenced
                        //  so it doesn't disappear.

                        pLastNpScb = pNearestNpScb;

                        continue;

                    } else {

                        pNearestNpScb->State = SCB_STATE_LOGIN_REQUIRED;
                        ConnectedToNearest = TRUE;

                    }
                }

                //
                // update the last used time for this SCB.
                //

                KeQuerySystemTime( &pNearestNpScb->LastUsedTime );

                if (( pNpScb == NULL ) ||
                    ( ServerName == NULL )) {

                    //
                    //  We're looking for any server so use this one.
                    //
                    //  We'll exit the for loop on the SCB queue,
                    //  and with this SCB referenced.
                    //

                    pNpScb = pNearestNpScb;
                    Status = STATUS_SUCCESS;
                    FoundServer = TRUE;
                    NwDequeueIrpContext( pNewIrpContext, FALSE );

                } else {

                    Status = QueryServersAddress(
                                 pNewIrpContext,
                                 pNearestNpScb,
                                 ServerName,
                                 &ServerAddress );

                    //
                    //  If we connect to this server just to query it's
                    //  bindery, disconnect now.
                    //

                    if (IsTerminalServer()) {
                        if (ConnectedToNearest) {

                            ExchangeWithWait (
                                             pNewIrpContext,
                                             SynchronousResponseCallback,
                                             "D-" );          // Disconnect
                            ConnectedToNearest = FALSE;
                            Stats.Sessions--;

                            if ( pNearestNpScb->MajorVersion == 2 ) {
                                Stats.NW2xConnects--;
                            } else if ( pNearestNpScb->MajorVersion == 3 ) {
                                Stats.NW3xConnects--;
                            } else if ( pNearestNpScb->MajorVersion == 4 ) {
                                Stats.NW4xConnects--;
                            }
                            pNearestNpScb->State = SCB_STATE_RECONNECT_REQUIRED;

                        }
                    } else {

                        if ( ConnectedToNearest && NT_SUCCESS(Status) ) {

                            ExchangeWithWait (
                                             pNewIrpContext,
                                             SynchronousResponseCallback,
                                             "D-" );          // Disconnect

                            pNearestNpScb->State = SCB_STATE_RECONNECT_REQUIRED;
                        }
                    }

                    if ( NT_SUCCESS( Status ) ) {

                        //
                        //  Success!
                        //
                        //  Point the SCB at the real server address and connect to it,
                        //  then logout.  (We logout for no apparent reason except
                        //  because this is what a netware redir does.)
                        //

                        RtlCopyMemory(
                            &pNpScb->ServerAddress,
                            &ServerAddress,
                            sizeof( TDI_ADDRESS_IPX ) );

                        if ( ServerAddress.Socket != NCP_SOCKET ) {
                            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "FindServer server socket is deviant.\n", 0 );
                        }

                        BuildIpxAddress(
                            ServerAddress.Net,
                            ServerAddress.Node,
                            ServerAddress.Socket,
                            &pNpScb->RemoteAddress );

                        FoundServer = TRUE;

                        NwDequeueIrpContext( pNewIrpContext, FALSE );
                        NwDereferenceScb( pNearestNpScb );

                        pNewIrpContext->pNpScb = pNpScb;
                        pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;

                    } else {

                        NwDequeueIrpContext( pNewIrpContext, FALSE );

                        if ( (Status == STATUS_REMOTE_NOT_LISTENING ) ||
                             (Status == STATUS_BAD_NETWORK_PATH)) {

                            //
                            //  This server is no longer talking to us.
                            //  Try again. Keep pNearestScb referenced
                            //  so it doesn't disappear.
                            //

                            pLastNpScb = pNearestNpScb;

                            continue;

                        } else {

                            NwDereferenceScb( pNearestNpScb );

                            //
                            //  This nearest server doesn't know about
                            //  the server we are looking for. Give up
                            //  and let another rdr try.
                            //

                            ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
                            return NULL;
                        }
                    }
                }

            } // else
        } // for

    } finally {

        if ( ReceiveBuffer != NULL ) {
            FREE_POOL( ReceiveBuffer );
        }

        if ( ReceiveMdl != NULL ) {
            FREE_MDL( ReceiveMdl );
        }

        if ( AllocatedIrpContext ) {
            NwDequeueIrpContext( pNewIrpContext, FALSE );
            NwFreeExtraIrpContext( pNewIrpContext );
        }

        if (IsTerminalServer()) {
            if ( (Attempts == CTX_Retries) && pLastNpScb) {
                NwDereferenceScb( pLastNpScb );
            }
        } else {
            if (pLastNpScb) {
                NwDereferenceScb( pLastNpScb );
            }
        }

    }

    if ( !FoundServer ) {
        ExRaiseStatus( STATUS_BAD_NETWORK_PATH );
    }

    return pNpScb;
}


NTSTATUS
ProcessFindNearest(
    IN struct _IRP_CONTEXT* pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR Response
    )
/*++

Routine Description:

    This routine takes the full address of the remote server and builds
    the corresponding TA_IPX_ADDRESS.

Arguments:


Return Value:


--*/

{
    ULONG ResponseCount;
    KIRQL OldIrql;

    DebugTrace(+1, Dbg, "ProcessFindNearest...\n", 0);

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    if ( BytesAvailable == 0) {

        //
        //   Timeout.
        //

        pIrpContext->ResponseParameters.Error = 0;
        pIrpContext->pNpScb->OkToReceive = FALSE;

        ASSERT( pIrpContext->Event.Header.SignalState == 0 );
#if NWDBG
        pIrpContext->DebugValue = 0x101;
#endif
        NwSetIrpContextEvent( pIrpContext );
        DebugTrace(-1, Dbg, "ProcessFindNearest -> %08lx\n", STATUS_REMOTE_NOT_LISTENING);
        KeReleaseSpinLock( &ScbSpinLock, OldIrql );
        return STATUS_REMOTE_NOT_LISTENING;
    }

    if ( BytesAvailable >= FIND_NEAREST_RESP_SIZE &&
         Response[0] == 0 &&
         Response[1] == SAP_SERVICE_TYPE_SERVER ) {

        //
        //  This is a valid find nearest response.  Process the packet.
        //

        ResponseCount = pIrpContext->Specific.Create.FindNearestResponseCount++;
        ASSERT( ResponseCount < MAX_SAP_RESPONSES );

        //
        //  Copy the Find Nearest server response to the receive buffer.
        //

        RtlCopyMemory(
            pIrpContext->Specific.Create.FindNearestResponse[ResponseCount],
            Response,
            FIND_NEAREST_RESP_SIZE );

        //
        //  If we have reached critical mass on the number of find
        //  nearest responses, set the event to indicate that we
        //  are done.
        //

        if ( ResponseCount == MAX_SAP_RESPONSES - 1 ) {

            ASSERT( pIrpContext->Event.Header.SignalState == 0 );
#ifdef NWDBG
            pIrpContext->DebugValue = 0x102;
#endif
            pIrpContext->ResponseParameters.Error = 0;
            NwSetIrpContextEvent( pIrpContext );

        } else {
            pIrpContext->pNpScb->OkToReceive = TRUE;
        }

    } else {

        //
        //  Discard the invalid find nearest response.
        //

        pIrpContext->pNpScb->OkToReceive = TRUE;
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );

    DebugTrace(-1, Dbg, "ProcessFindNearest -> %08lx\n", STATUS_SUCCESS );
    return( STATUS_SUCCESS );
}

BOOLEAN
ProcessFindNearestEntry(
    PIRP_CONTEXT IrpContext,
    PSAP_FIND_NEAREST_RESPONSE FindNearestResponse
    )
{
    OEM_STRING OemServerName;
    UNICODE_STRING UidServerName;
    UNICODE_STRING ServerName;
    NTSTATUS Status;
    PSCB pScb;
    PNONPAGED_SCB pNpScb = NULL;
    BOOLEAN ExistingScb = TRUE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "ProcessFindNearestEntry\n", 0);

    ServerName.Buffer = NULL;
    UidServerName.Buffer = NULL;

    try {

        RtlInitString( &OemServerName, FindNearestResponse->ServerName );
        ASSERT( OemServerName.Length < MAX_SERVER_NAME_LENGTH * sizeof( WCHAR ) );

        Status = RtlOemStringToCountedUnicodeString(
                     &ServerName,
                     &OemServerName,
                     TRUE );

        if ( !NT_SUCCESS( Status ) ) {
            try_return( NOTHING );
        }

        //
        //  Lookup of the SCB by name.  If it is not found, an SCB
        //  will be created.
        //

        Status = MakeUidServer(
                        &UidServerName,
                        &IrpContext->Specific.Create.UserUid,
                        &ServerName );

        if (!NT_SUCCESS(Status)) {
            try_return( NOTHING );
        }

        ExistingScb = NwFindScb( &pScb, IrpContext, &UidServerName, &ServerName );
        ASSERT( pScb != NULL );
        pNpScb = pScb->pNpScb;

        //
        //  Copy the network address to the SCB, and calculate the
        //  IPX address.
        //

        RtlCopyMemory(
            &pNpScb->ServerAddress,
            &FindNearestResponse->Network,
            sizeof( TDI_ADDRESS_IPX )  );

        if ( pNpScb->ServerAddress.Socket != NCP_SOCKET ) {
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "FindNearest server socket is deviant.\n", 0 );
        }

        BuildIpxAddress(
            pNpScb->ServerAddress.Net,
            pNpScb->ServerAddress.Node,
            pNpScb->ServerAddress.Socket,
            &pNpScb->RemoteAddress );

        if ( pNpScb->State == SCB_STATE_ATTACHING ) {

            //
            //  We are in the process of trying to connect to this
            //  server so mark it reconnect required so that
            //  CreateScb will know that we've found it address.
            //

            pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;
        }

try_exit: NOTHING;

    } finally {

        if ( pNpScb != NULL ) {
            NwDereferenceScb( pNpScb );
        }

        if (UidServerName.Buffer != NULL) {
            FREE_POOL(UidServerName.Buffer);
        }

        RtlFreeUnicodeString( &ServerName );
    }

    //
    //  Tell the caller if we created a new Scb
    //


    if (ExistingScb) {
        DebugTrace(-1, Dbg, "ProcessFindNearestEntry ->%08lx\n", FALSE );
        return FALSE;
    } else {
        DebugTrace(-1, Dbg, "ProcessFindNearestEntry ->%08lx\n", TRUE );
        return TRUE;
    }
}


NTSTATUS
ConnectToServer(
    IN struct _IRP_CONTEXT* pIrpContext,
    OUT PSCB *pScbCollision
    )
/*++

Routine Description:

    This routine transfers connect and negotiate buffer NCPs to the server.

    This routine may be called upon to connect an anonymous scb.  Upon
    learning the name of the anonymous scb, it will determine if another
    create has completed while the name lookup was in progress.  If it has,
    then the routine will refer the called to that new scb.  Otherwise, the
    scb will be entered onto the scb list and used normally.  The RCB
    protects the scb list by name only.  For more info, see the comment
    in CreateScb().

Arguments:

    pIrpContext - supplies context and server information

Return Value:

    Status of operation

--*/
{
    NTSTATUS Status, BurstStatus;
    PNONPAGED_SCB pNpScb = pIrpContext->pNpScb;
    PSCB pScb = pNpScb->pScb;
    BOOLEAN AnonymousScb = IS_ANONYMOUS_SCB( pScb );
    ULONG MaxSafeSize ;
    BOOLEAN LIPNegotiated ;
    PLOGON Logon;

    OEM_STRING OemServerName;
    UNICODE_STRING ServerName;
    UNICODE_STRING CredentialName;
    PUNICODE_STRING puConnectName;
    BYTE OemName[MAX_SERVER_NAME_LENGTH];
    WCHAR Server[MAX_SERVER_NAME_LENGTH];
    KIRQL OldIrql;
    UNICODE_STRING UidServerName;
    BOOLEAN Success;
    PLIST_ENTRY ScbQueueEntry;
    PUNICODE_PREFIX_TABLE_ENTRY PrefixEntry;

    PAGED_CODE();

    DebugTrace( +0, Dbg, " Connect\n", 0);

    RtlInitUnicodeString( &CredentialName, NULL );

    //
    //  Get the tick count for our connection to this server
    //

    Status = GetTickCount( pIrpContext, &pNpScb->TickCount );

    if ( !NT_SUCCESS( Status ) ) {
        pNpScb->TickCount = DEFAULT_TICK_COUNT;
    }

    pNpScb->SendTimeout = pNpScb->TickCount + 10;

    //
    //  Initialize timers for a server that supports burst but not LIP
    //

    pNpScb->NwLoopTime = pNpScb->NwSingleBurstPacketTime = pNpScb->SendTimeout;
    pNpScb->NwReceiveDelay = pNpScb->NwSendDelay = 0;

    pNpScb->NtSendDelay.QuadPart = 0;

    //
    //  Request connection
    //

    Status = ExchangeWithWait (
                 pIrpContext,
                 SynchronousResponseCallback,
                 "C-");

    DebugTrace( +0, Dbg, "                 %X\n", Status);

    if (!NT_SUCCESS(Status)) {
        if ( Status == STATUS_UNSUCCESSFUL ) {
#ifdef QFE_BUILD
            Status = STATUS_TOO_MANY_SESSIONS;
#else
            Status = STATUS_REMOTE_SESSION_LIMIT;
#endif
            pNpScb->State = SCB_STATE_ATTACHING;

        } else if ( Status == STATUS_REMOTE_NOT_LISTENING ) {

            //
            //  The connect timed out, suspect that the server is down
            //  and put it back in the attaching state.
            //

            pNpScb->State = SCB_STATE_ATTACHING;
        }

        goto ExitWithStatus;
    }

    pNpScb->SequenceNo++;

    Stats.Sessions++;

    //
    //  Get server information
    //

    DebugTrace( +0, Dbg, "Get file server information\n", 0);

    Status = ExchangeWithWait (  pIrpContext,
                SynchronousResponseCallback,
                "S",
                NCP_ADMIN_FUNCTION, NCP_GET_SERVER_INFO );

    if ( NT_SUCCESS( Status ) ) {
        Status = ParseResponse( pIrpContext,
                                pIrpContext->rsp,
                                pIrpContext->ResponseLength,
                                "Nrbb",
                                OemName,
                                MAX_SERVER_NAME_LENGTH,
                                &pScb->MajorVersion,
                                &pScb->MinorVersion );
    }

    pNpScb->MajorVersion = pScb->MajorVersion;

    if (!NT_SUCCESS(Status)) {
        goto ExitWithStatus;
    }

    //
    // If this was an anonymous SCB, we need to check the name
    // for a create collision before we do anything else.
    //

    if ( AnonymousScb ) {

        //
        // Grab the RCB to protect the server prefix table.  We've
        // spent the time sending the packet to look up the server
        // name so we are a little greedy with the RCB to help
        // minimize the chance of a collision.
        //

        NwAcquireExclusiveRcb( &NwRcb, TRUE );

        //
        // Make the uid server name.
        //

        OemServerName.Buffer = OemName;
        OemServerName.Length = 0;
        OemServerName.MaximumLength = sizeof( OemName );

        while ( ( OemServerName.Length < MAX_SERVER_NAME_LENGTH ) &&
                ( OemName[OemServerName.Length] != '\0' ) ) {
            OemServerName.Length++;
        }

        ServerName.Buffer = Server;
        ServerName.MaximumLength = sizeof( Server );
        ServerName.Length = 0;

        RtlOemStringToUnicodeString( &ServerName,
                                     &OemServerName,
                                     FALSE );

        //
        // If this is an extended credential create, munge the server name.
        //

        if ( pIrpContext->Specific.Create.fExCredentialCreate ) {

            Status = BuildExCredentialServerName( &ServerName,
                                                  pIrpContext->Specific.Create.puCredentialName,
                                                  &CredentialName );

            if ( !NT_SUCCESS( Status ) ) {
                NwReleaseRcb( &NwRcb );
                goto ExitWithStatus;
            }

            puConnectName = &CredentialName;

        } else {

            puConnectName = &ServerName;
        }

        //
        // Tack on the uid.
        //

        Status = MakeUidServer( &UidServerName,
                                &pScb->UserUid,
                                puConnectName );

        if ( !NT_SUCCESS( Status ) ) {
            NwReleaseRcb( &NwRcb );
            goto ExitWithStatus;
        }

        //
        // Actually do the look up in the prefix table.
        //

        PrefixEntry = RtlFindUnicodePrefix( &NwRcb.ServerNameTable, &UidServerName, 0 );

        if ( PrefixEntry != NULL ) {

            //
            // There was a collision with this anonymous create.  Dump
            // the anonymous scb and pick up the new one.
            //

            NwReleaseRcb( &NwRcb );
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Anonymous create collided for %wZ.\n", &UidServerName );

            //
            // Disconnect this connection so we don't clutter the server.
            //

            ExchangeWithWait ( pIrpContext,
                               SynchronousResponseCallback,
                               "D-" );

            FREE_POOL( UidServerName.Buffer );

            //
            // Since there was a collision, we know for a fact that there's another
            // good SCB for this server somewhere.  We set the state on this anonymous
            // SCB to SCB_STATE_FLAG_SHUTDOWN so that no one ever plays with the
            // anonymous SCB again.  The scavenger will clean it up soon.
            //

            pNpScb->State = SCB_STATE_FLAG_SHUTDOWN;

            if ( pScbCollision ) {
                *pScbCollision = CONTAINING_RECORD( PrefixEntry, SCB, PrefixEntry );
                NwReferenceScb( (*pScbCollision)->pNpScb );
                Status = STATUS_SUCCESS;
                goto ExitWithStatus;
            } else {
                 DebugTrace( 0, Dbg, "Invalid path for an anonymous create.\n", 0 );
                 Status = STATUS_INVALID_PARAMETER;
                 goto ExitWithStatus;
            }

        }

        //
        // This anonymous create didn't collide - cool!  Fill in the server
        // name, check the preferred, server setting, and put the SCB on the
        // SCB queue in the correct location.  This code is similar to pieces
        // of code in NwAllocateAndInitScb() and NwFindScb().
        //

        DebugTrace( 0, Dbg, "Completing anonymous create for %wZ!\n", &UidServerName );

        RtlCopyUnicodeString ( &pScb->UidServerName, &UidServerName );
        pScb->UidServerName.Buffer[ UidServerName.Length / sizeof( WCHAR ) ] = L'\0';

        pScb->UnicodeUid = pScb->UidServerName;
        pScb->UnicodeUid.Length = UidServerName.Length -
                                  puConnectName->Length -
                                  sizeof(WCHAR);

        //
        //  Make ServerName point partway down the buffer for UidServerName
        //

        pNpScb->ServerName.Buffer = (PWSTR)((PUCHAR)pScb->UidServerName.Buffer +
                                    UidServerName.Length - puConnectName->Length);

        pNpScb->ServerName.MaximumLength = puConnectName->Length;
        pNpScb->ServerName.Length = puConnectName->Length;

        //
        // Determine if this is our preferred server.
        //

        Logon = FindUser( &pScb->UserUid, FALSE );

        if (( Logon != NULL) &&
            (RtlCompareUnicodeString( puConnectName, &Logon->ServerName, TRUE ) == 0 )) {
           pScb->PreferredServer = TRUE;
           NwReferenceScb( pNpScb );
        }

        FREE_POOL( UidServerName.Buffer );

        //
        //  Insert the name of this server into the prefix table.
        //

        Success = RtlInsertUnicodePrefix( &NwRcb.ServerNameTable,
                                          &pScb->UidServerName,
                                          &pScb->PrefixEntry );

#ifdef NWDBG
        if ( !Success ) {
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Entering duplicate SCB %wZ.\n", &pScb->UidServerName );
            DbgBreakPoint();
        }
#endif

        //
        // This create is complete, release the RCB.
        //

        NwReleaseRcb( &NwRcb );

        //
        // If this is our preferred server, we have to move this guy
        // to the head of the scb list.  We do this after the create
        // because we can't acquire the ScbSpinLock while holding the
        // RCB.
        //

        if ( pScb->PreferredServer ) {

            KeAcquireSpinLock(&ScbSpinLock, &OldIrql);
            RemoveEntryList( &pNpScb->ScbLinks );
            InsertHeadList( &ScbQueue, &pNpScb->ScbLinks );
            KeReleaseSpinLock( &ScbSpinLock, OldIrql );
        }

    }

    if ( pScb->MajorVersion == 2 ) {

        Stats.NW2xConnects++;
        pNpScb->PageAlign = TRUE;

    } else if ( pScb->MajorVersion == 3 ) {

        Stats.NW3xConnects++;

        if (pScb->MinorVersion > 0xb) {
            pNpScb->PageAlign = FALSE;
        } else {
            pNpScb->PageAlign = TRUE;
        }

    } else if ( pScb->MajorVersion >= 4 ) {

        Stats.NW4xConnects++;
        pNpScb->PageAlign = FALSE;

        NdsPing( pIrpContext, pScb );

    }

    //
    //  Get the local net max packet size.  This is the max frame size
    //  does not include space for IPX or lower level headers.
    //

    Status = GetMaximumPacketSize( pIrpContext, &pNpScb->Server, &pNpScb->MaxPacketSize );

    //
    //  If the transport won't tell us, pick the largest size that
    //  is guaranteed to work.
    //
    if ( !NT_SUCCESS( Status ) ) {
        pNpScb->BufferSize = DEFAULT_PACKET_SIZE;
        pNpScb->MaxPacketSize = DEFAULT_PACKET_SIZE;
    } else {
        pNpScb->BufferSize = (USHORT)pNpScb->MaxPacketSize;
    }
    MaxSafeSize = pNpScb->MaxPacketSize ;

    //
    //  Negotiate a burst mode connection. Keep track of that status.
    //

    Status = NegotiateBurstMode( pIrpContext, pNpScb, &LIPNegotiated );
    BurstStatus = Status ;

    if (!NT_SUCCESS(Status) || !LIPNegotiated) {

        //
        //  Negotiate buffer size with server if we didnt do burst
        //  sucessfully or if burst succeeded but we didnt do LIP.
        //

        DebugTrace( +0, Dbg, "Negotiate Buffer Size\n", 0);

        Status = ExchangeWithWait (  pIrpContext,
                    SynchronousResponseCallback,
                    "Fw",
                    NCP_NEGOTIATE_BUFFER_SIZE,
                    pNpScb->BufferSize );

        DebugTrace( +0, Dbg, "                 %X\n", Status);
        DebugTrace( +0, Dbg, " Parse response\n", 0);

        if ( NT_SUCCESS( Status ) ) {
            Status = ParseResponse( pIrpContext,
                                    pIrpContext->rsp,
                                    pIrpContext->ResponseLength,
                                    "Nw",
                                    &pNpScb->BufferSize );

            //
            // Dont allow the server to fool us into using a
            // packet size bigger than what the media can support.
            // We have at least one case of server returning 4K while
            // on ethernet.
            //
            // Use PacketThreshold so that the PacketAdjustment can be
            // avoided on small packet sizes such as those on ethernet.
            //

            if (MaxSafeSize > (ULONG)PacketThreshold) {
                MaxSafeSize -= (ULONG)LargePacketAdjustment;
            }

            //
            // If larger than number we got from transport, taking in account
            // IPX header (30) & NCP header (BURST_RESPONSE is a good worst
            // case), we adjust accordingly.
            //
            if (pNpScb->BufferSize >
                    (MaxSafeSize - (30 + sizeof(NCP_BURST_READ_RESPONSE))))
            {
                pNpScb->BufferSize = (USHORT)
                    (MaxSafeSize - (30 + sizeof(NCP_BURST_READ_RESPONSE))) ;
            }

            //
            //  An SFT III server responded with a BufferSize of 0!
            //

            pNpScb->BufferSize = MAX(pNpScb->BufferSize,DEFAULT_PACKET_SIZE);

            //
            // If an explicit registry default was set, we honour that.
            // Note that this only applies in the 'default' case, ie. we
            // didnt negotiate LIP successfully. Typically, we dont
            // expect to use this, because the server will drop to 512 if
            // it finds routers in between. But if for some reason the server
            // came back with a number that was higher than what some router
            // in between can take, we have this as manual override.
            //

            if (DefaultMaxPacketSize != 0)
            {
                pNpScb->BufferSize = MIN (pNpScb->BufferSize,
                                          (USHORT)DefaultMaxPacketSize) ;
            }
        }

        if (NT_SUCCESS(BurstStatus)) {
            //
            // We negotiated burst but not LIP. Save the packet size we
            // have from above and renegotiate the burst so that the
            // server knows how much it can send to us. And then take
            // the minimum of the two to make sure we are safe.
            //
            USHORT SavedPacketSize =  pNpScb->BufferSize ;

            Status = NegotiateBurstMode( pIrpContext, pNpScb, &LIPNegotiated );

            pNpScb->BufferSize = MIN(pNpScb->BufferSize,SavedPacketSize) ;
        }
    }

ExitWithStatus:

    if ( CredentialName.Buffer ) {
        FREE_POOL( CredentialName.Buffer );
    }

    return Status;
}


NTSTATUS
NegotiateBurstMode(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb,
    BOOLEAN *LIPNegotiated
    )
/*++

Routine Description:

    This routine negotiates a burst mode connection with the specified
    server.

Arguments:

    pIrpContext - Supplies context and server information.

    pNpScb - A pointer to the NONPAGED_SCB for the server we are
        negotiating with.

Return Value:

    None.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    *LIPNegotiated = FALSE ;

    if (pNpScb->MaxPacketSize == DEFAULT_PACKET_SIZE) {
        return STATUS_NOT_SUPPORTED;
    }

    if ( NwBurstModeEnabled ) {

        pNpScb->BurstRenegotiateReqd = TRUE;

        pNpScb->SourceConnectionId = rand();
        pNpScb->MaxSendSize = NwMaxSendSize;
        pNpScb->MaxReceiveSize = NwMaxReceiveSize;
        pNpScb->BurstSequenceNo = 0;
        pNpScb->BurstRequestNo = 0;

        Status = ExchangeWithWait(
                     pIrpContext,
                     SynchronousResponseCallback,
                     "FDdWdd",
                     NCP_NEGOTIATE_BURST_CONNECTION,
                     pNpScb->SourceConnectionId,
                     pNpScb->BufferSize,
                     pNpScb->Burst.Socket,
                     pNpScb->MaxSendSize,
                     pNpScb->MaxReceiveSize );

        if ( NT_SUCCESS( Status )) {
            Status = ParseResponse(
                         pIrpContext,
                         pIrpContext->rsp,
                         pIrpContext->ResponseLength,
                         "Ned",
                         &pNpScb->DestinationConnectionId,
                         &pNpScb->MaxPacketSize );

            if (pNpScb->MaxPacketSize <= DEFAULT_PACKET_SIZE) {
                pNpScb->MaxPacketSize = DEFAULT_PACKET_SIZE;
            }
        }

        if ( NT_SUCCESS( Status )) {

            if (NT_SUCCESS(GetMaxPacketSize( pIrpContext, pNpScb ))) {
                *LIPNegotiated = TRUE ;
            }

            pNpScb->SendBurstModeEnabled = TRUE;
            pNpScb->ReceiveBurstModeEnabled = TRUE;

            //
            //  Use this size as the max read and write size instead of
            //  negotiating. This is what the VLM client does and is
            //  important because the negotiate will give a smaller value.
            //

            pNpScb->BufferSize = (USHORT)pNpScb->MaxPacketSize;

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_SUPPORTED;
}



VOID
RenegotiateBurstMode(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    )
/*++

Routine Description:

    This routine renegotiates a burst mode connection with the specified
    server.   I don't know why we need this but it seems to be required
    by Netware latest burst implementation.

Arguments:

    pIrpContext - Supplies context and server information.

    pNpScb - A pointer to the NONPAGED_SCB for the server we are
        negotiating with.

Return Value:

    None.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace( 0, DEBUG_TRACE_LIP, "Re-negotiating burst mode.\n", 0);

    pNpScb->SourceConnectionId = rand();
    pNpScb->MaxSendSize = NwMaxSendSize;
    pNpScb->MaxReceiveSize = NwMaxReceiveSize;
    pNpScb->BurstSequenceNo = 0;
    pNpScb->BurstRequestNo = 0;

    Status = ExchangeWithWait(
                 pIrpContext,
                 SynchronousResponseCallback,
                 "FDdWdd",
                 NCP_NEGOTIATE_BURST_CONNECTION,
                 pNpScb->SourceConnectionId,
                 pNpScb->MaxPacketSize,
                 pNpScb->Burst.Socket,
                 pNpScb->MaxSendSize,
                 pNpScb->MaxReceiveSize );

    if ( NT_SUCCESS( Status )) {
        Status = ParseResponse(
                     pIrpContext,
                     pIrpContext->rsp,
                     pIrpContext->ResponseLength,
                     "Ned",
                     &pNpScb->DestinationConnectionId,
                     &pNpScb->MaxPacketSize );

        //
        //  Randomly downgrade the max burst size, because that is what
        //  the netware server does, and the new burst NLM requires.
        //

        pNpScb->MaxPacketSize -= 66;

    }

    if ( !NT_SUCCESS( Status ) ||
         (pNpScb->MaxPacketSize <= DEFAULT_PACKET_SIZE)) {

        pNpScb->MaxPacketSize = DEFAULT_PACKET_SIZE;
        pNpScb->SendBurstModeEnabled = FALSE;
        pNpScb->ReceiveBurstModeEnabled = FALSE;

    } else {

        //
        //  Use this size as the max read and write size instead of
        //  negotiating. This is what the VLM client does and is
        //  important because the negotiate will give a smaller value.
        //

        pNpScb->BufferSize = (USHORT)pNpScb->MaxPacketSize;

    }
}


NTSTATUS
GetMaxPacketSize(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    )
/*++

Routine Description:

    This routine attempts to use the LIP protocol to find the true MTU of
    the network.

Arguments:

    pIrpContext - Supplies context and server information.

    pNpScb - A pointer to the NONPAGED_SCB for the server we are '
        negotiating with.

Return Value:

    None.

--*/
{
    PUSHORT Buffer = NULL;
    USHORT value;
    int index;
    PMDL PartialMdl = NULL, FullMdl = NULL;
    PMDL ReceiveMdl;
    NTSTATUS Status;
    USHORT EchoSocket, LipPacketSize = 0;
    int MinPacketSize, MaxPacketSize, CurrentPacketSize;
    ULONG RxMdlLength = MdlLength(pIrpContext->RxMdl);  //  Save so we can restore it on exit.

    BOOLEAN SecondTime = FALSE;
    LARGE_INTEGER StartTime, Now, FirstPing, SecondPing, temp;

    PAGED_CODE();

    DebugTrace( +1, DEBUG_TRACE_LIP, "GetMaxPacketSize...\n", 0);

    //
    //  Negotiate LIP, attempt to negotiate a buffer of full network
    //  size.
    //

    Status = ExchangeWithWait(
                 pIrpContext,
                 SynchronousResponseCallback,
                 "Fwb",
                 NCP_NEGOTIATE_LIP_CONNECTION,
                 pNpScb->BufferSize,
                 0 );  // Flags

    if ( NT_SUCCESS( Status )) {
        Status = ParseResponse(
                     pIrpContext,
                     pIrpContext->rsp,
                     pIrpContext->ResponseLength,
                     "Nwx",
                     &LipPacketSize,
                     &EchoSocket );
    }

      //
      //  Speedup RAS
      //

      MaxPacketSize = (int) LipPacketSize - LipPacketAdjustment ;

    if (( !NT_SUCCESS( Status )) ||
        ( MaxPacketSize <= DEFAULT_PACKET_SIZE ) ||
        ( EchoSocket == 0 )) {

        //
        //  The server does not support LIP.
        //  Portable NW gives no error but socket 0.
        //  We have a report of a 3.11 server returning MaxPacketSize 0
        //

        return STATUS_NOT_SUPPORTED;
    }

    //
    // Account for the IPX header, which is not counted in
    // the reported packet size.  This causes problems for
    // servers with poorly written net card drivers that
    // abend when they get an oversize packet.
    //
    // This was reported by Richard Florance (richfl).
    //

    MaxPacketSize -= 30;

    pNpScb->EchoCounter = MaxPacketSize;

    //
    //  We will use the Echo address for the LIP protocol.
    //

    BuildIpxAddress(
        pNpScb->ServerAddress.Net,
        pNpScb->ServerAddress.Node,
        EchoSocket,
        &pNpScb->EchoAddress );

    try {

        Buffer = ALLOCATE_POOL_EX( NonPagedPool, MaxPacketSize );

        //
        //  Avoid RAS compression algorithm from making the large and small
        //  buffers the same length since we want to see the difference in
        //  transmission times.
        //

        for (index = 0, value = 0; index < MaxPacketSize/2; index++, value++) {
            Buffer[index] = value;
        }

        FullMdl = ALLOCATE_MDL( Buffer, MaxPacketSize, TRUE, FALSE, NULL );
        if ( FullMdl == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        PartialMdl = ALLOCATE_MDL( Buffer, MaxPacketSize, TRUE, FALSE, NULL );
        if ( PartialMdl == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        ReceiveMdl = ALLOCATE_MDL( Buffer, MaxPacketSize, TRUE, FALSE, NULL );
        if ( ReceiveMdl == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

    } except( NwExceptionFilter( pIrpContext->pOriginalIrp, GetExceptionInformation() )) {

        if ( Buffer != NULL ) {
            FREE_POOL( Buffer );
        }

        if ( FullMdl != NULL ) {
            FREE_MDL( FullMdl );
        }

        if ( PartialMdl != NULL ) {
            FREE_MDL( FullMdl );
        }

        return STATUS_NOT_SUPPORTED;
    }

    MmBuildMdlForNonPagedPool( FullMdl );

    //
    //  Allocate a receive MDL and chain in to the IrpContext receive MDL.
    //

    pIrpContext->RxMdl->ByteCount = sizeof( NCP_RESPONSE ) + sizeof(ULONG);
    MmBuildMdlForNonPagedPool( ReceiveMdl );
    pIrpContext->RxMdl->Next = ReceiveMdl;

    CurrentPacketSize = MaxPacketSize;
    MinPacketSize = DEFAULT_PACKET_SIZE;

    //  Log values before we update them.
    DebugTrace( 0, DEBUG_TRACE_LIP, "Using TickCount       = %08lx\n", pNpScb->TickCount * pNpScb->MaxPacketSize);
    DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NwSendDelay   = %08lx\n", pNpScb->NwSendDelay );
    DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NtSendDelay H = %08lx\n", pNpScb->NtSendDelay.HighPart );
    DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NtSendDelay L = %08lx\n", pNpScb->NtSendDelay.LowPart );

    //
    // The LIP sequence number is used to let us know if the response packet we are looking
    // at goes with the packet that we just sent.  On a really slow link, it could be a
    // response that we have already given up on.
    // 
    // The LIP tick adjustment tells ExchangeWithWait to try waiting a little longer.
    //

    pNpScb->LipSequenceNumber = 0;
    pNpScb->LipTickAdjustment = 0;

    //
    //  Loop using the bisection method to find the maximum packet size. Feel free to
    //  use shortcuts to avoid unnecessary timeouts.
    //

    while (TRUE) {

        //
        // Every time we send a packet, increment the LIP sequence number.
        // We check the LIP sequence number in ServerDatagramHandler.
        //

        pNpScb->LipSequenceNumber++;

        DebugTrace( 0, DEBUG_TRACE_LIP, "Sending %d byte echo\n", CurrentPacketSize );

        IoBuildPartialMdl(
            FullMdl,
            PartialMdl,
            Buffer,
            CurrentPacketSize - sizeof(NCP_RESPONSE) - sizeof(ULONG) );

        //
        //  Send an echo packet.  If we get a response, then we know that
        //  the minimum packet size we can use is at least as big as the
        //  echo packet size.
        //

        pIrpContext->pTdiStruct = &pIrpContext->pNpScb->Echo;

        //
        // Short-circuit the even better RAS compression.
        //

        for ( index = 0; index < MaxPacketSize/2; index++, value++) {
            Buffer[index] = value;
        }

        KeQuerySystemTime( &StartTime );

        Status = ExchangeWithWait(
                      pIrpContext,
                      SynchronousResponseCallback,
                      "E_DDf",
                      sizeof(NCP_RESPONSE ),
                      pNpScb->EchoCounter,
                      pNpScb->LipSequenceNumber,
                      PartialMdl );

        if (( Status != STATUS_REMOTE_NOT_LISTENING ) ||
            ( SecondTime )) {

            KeQuerySystemTime( &Now );
            DebugTrace( 0, DEBUG_TRACE_LIP, "Response received %08lx\n", Status);

            if (!SecondTime) {

                MinPacketSize = CurrentPacketSize;
                FirstPing.QuadPart = Now.QuadPart - StartTime.QuadPart;
            }

        } else {

            DebugTrace( 0, DEBUG_TRACE_LIP, "No response\n", 0);
            MaxPacketSize = CurrentPacketSize;
        }

        pNpScb->EchoCounter++;
        MmPrepareMdlForReuse( PartialMdl );


        if ((  MaxPacketSize - MinPacketSize <= LipAccuracy ) ||
            (  SecondTime )) {

            //
            //  We have the maximum packet size.
            //  Now - StartTime is how long it takes for the round-trip.  Now we'll
            //  try the same thing with a small packet and see how long it takes.  From
            //  this we'll derive a throughput rating.
            //


            if ( SecondTime) {

                SecondPing.QuadPart = Now.QuadPart - StartTime.QuadPart;
                break;

            } else {
                SecondTime = TRUE;
                //  Use a small packet size to verify that the server is still up.
                CurrentPacketSize = sizeof(NCP_RESPONSE) + sizeof(ULONG) * 2;
            }

        } else {

            //
            //  Calculate the next packet size guess.
            //

            if (( Status == STATUS_REMOTE_NOT_LISTENING ) &&
                ( MaxPacketSize == 1463 )) {

                CurrentPacketSize = 1458;

            } else if (( Status == STATUS_REMOTE_NOT_LISTENING ) &&
                ( MaxPacketSize == 1458 )) {

                CurrentPacketSize = 1436;

            } else {

                //
                //  We didn't try one of our standard sizes so use the chop search
                //  to get to the next value.
                //

                CurrentPacketSize = ( MaxPacketSize + MinPacketSize ) / 2;

            }
        }
    }

    DebugTrace( 0, DEBUG_TRACE_LIP, "Set maximum burst packet size to %d\n", MinPacketSize );
    DebugTrace( 0, DEBUG_TRACE_LIP, "FirstPing  H = %08lx\n", FirstPing.HighPart );
    DebugTrace( 0, DEBUG_TRACE_LIP, "FirstPing  L = %08lx\n", FirstPing.LowPart );
    DebugTrace( 0, DEBUG_TRACE_LIP, "SecondPing H = %08lx\n", SecondPing.HighPart );
    DebugTrace( 0, DEBUG_TRACE_LIP, "SecondPing L = %08lx\n", SecondPing.LowPart );

    //
    // Avoid a divide by zero error if something bad happened.
    //

    if ( FirstPing.QuadPart != 0 ) {
        pNpScb->LipDataSpeed = (ULONG) ( ( (LONGLONG)MinPacketSize * (LONGLONG)1600000 )
                                         / FirstPing.QuadPart );
    } else {
        pNpScb->LipDataSpeed = 0;
    }

    DebugTrace( 0, DEBUG_TRACE_LIP, "LipDataSpeed: %d\n", pNpScb->LipDataSpeed );

    if ((NT_SUCCESS(Status)) &&
        ( MinPacketSize > DEFAULT_PACKET_SIZE )) {

        temp.QuadPart = FirstPing.QuadPart - SecondPing.QuadPart;

        if (temp.QuadPart > 0) {

            //
            //  Convert to single trip instead of both ways.
            //

            temp.QuadPart = temp.QuadPart / (2 * 1000);

        } else {

            //
            //  Small packet ping is slower or the same speed as the big ping.
            //  We can't time a small enough interval so go for no delay at all.
            //

            temp.QuadPart = 0;

        }


        ASSERT(temp.HighPart == 0);

        pNpScb->NwGoodSendDelay = pNpScb->NwBadSendDelay = pNpScb->NwSendDelay =
            MAX(temp.LowPart, (ULONG)MinSendDelay);

        pNpScb->NwGoodReceiveDelay = pNpScb->NwBadReceiveDelay = pNpScb->NwReceiveDelay =
            MAX(temp.LowPart, (ULONG)MinReceiveDelay);

        //
        //  Time for a big packet to go one way.
        //

        pNpScb->NwSingleBurstPacketTime = pNpScb->NwReceiveDelay;

        pNpScb->NtSendDelay.QuadPart = pNpScb->NwReceiveDelay * -1000;


        //
        //  Maximum that SendDelay is allowed to reach
        //

        pNpScb->NwMaxSendDelay = MAX( 52, MIN( pNpScb->NwSendDelay, MaxSendDelay ));
        pNpScb->NwMaxReceiveDelay = MAX( 52, MIN( pNpScb->NwReceiveDelay, MaxReceiveDelay ));

        //
        //  Time for a small packet to get to the server and back.
        //

        temp.QuadPart = SecondPing.QuadPart / 1000;
        pNpScb->NwLoopTime = temp.LowPart;

        DebugTrace( 0, DEBUG_TRACE_LIP, "Using TickCount            = %08lx\n", pNpScb->TickCount * pNpScb->MaxPacketSize);
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NwSendDelay        = %08lx\n", pNpScb->NwSendDelay );
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NwMaxSendDelay     = %08lx\n", pNpScb->NwMaxSendDelay );
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NwMaxReceiveDelay  = %08lx\n", pNpScb->NwMaxReceiveDelay );
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NwLoopTime         = %08lx\n", pNpScb->NwLoopTime );
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NtSendDelay H      = %08lx\n", pNpScb->NtSendDelay.HighPart );
        DebugTrace( 0, DEBUG_TRACE_LIP, "pNpScb->NtSendDelay L      = %08lx\n", pNpScb->NtSendDelay.LowPart );

        //
        //  Reset Tdi struct so that we send future NCPs from the server socket.
        //

        pIrpContext->pTdiStruct = NULL;

        //
        //  Now decouple the MDL
        //

        pIrpContext->TxMdl->Next = NULL;
        pIrpContext->RxMdl->Next = NULL;
        pIrpContext->RxMdl->ByteCount = RxMdlLength;

        //
        //  Calculate the maximum amount of data we can send in a burst write
        //  packet after all the header info is stripped.
        //

        pNpScb->MaxPacketSize = MinPacketSize - sizeof( NCP_BURST_WRITE_REQUEST );

        FREE_MDL( PartialMdl );
        FREE_MDL( ReceiveMdl );
        FREE_MDL( FullMdl );
        FREE_POOL( Buffer );


        DebugTrace( -1, DEBUG_TRACE_LIP, "GetMaxPacketSize -> VOID\n", 0);
        return STATUS_SUCCESS;

    } else {

        //
        //  If the small packet couldn't echo then assume the worst.
        //

        //
        //  Reset Tdi struct so that we send future NCPs from the server socket.
        //

        pIrpContext->pTdiStruct = NULL;

        //
        //  Now decouple the MDL
        //

        pIrpContext->TxMdl->Next = NULL;
        pIrpContext->RxMdl->Next = NULL;
        pIrpContext->RxMdl->ByteCount = RxMdlLength;

        FREE_MDL( PartialMdl );
        FREE_MDL( ReceiveMdl );
        FREE_MDL( FullMdl );
        FREE_POOL( Buffer );


        DebugTrace( -1, DEBUG_TRACE_LIP, "GetMaxPacketSize -> VOID\n", 0);
        return STATUS_NOT_SUPPORTED;
    }

}


VOID
DestroyAllScb(
    VOID
    )

/*++

Routine Description:

    This routine destroys all server control blocks.

Arguments:


Return Value:


--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY ScbQueueEntry;
    PNONPAGED_SCB pNpScb;

    DebugTrace(+1, Dbg, "DestroyAllScbs....\n", 0);

    KeAcquireSpinLock(&ScbSpinLock, &OldIrql);

    //
    //  Walk the list of SCBs and kill them all.
    //

    while (!IsListEmpty(&ScbQueue)) {

        ScbQueueEntry = RemoveHeadList( &ScbQueue );
        pNpScb = CONTAINING_RECORD(ScbQueueEntry, NONPAGED_SCB, ScbLinks);

        //
        //  We can't hold the spin lock while deleting an SCB, so release
        //  it now.
        //

        KeReleaseSpinLock(&ScbSpinLock, OldIrql);

        NwDeleteScb( pNpScb->pScb );

        KeAcquireSpinLock(&ScbSpinLock, &OldIrql);
    }

    KeReleaseSpinLock(&ScbSpinLock, OldIrql);

    DebugTrace(-1, Dbg, "DestroyAllScb\n", 0 );
}


VOID
NwDeleteScb(
    PSCB pScb
    )
/*++

Routine Description:

    This routine deletes an SCB.  The SCB must not be in use.

    *** The caller must own the RCB exclusive.

Arguments:

    Scb - The SCB to delete

Return Value:

    None.

--*/
{
    PNONPAGED_SCB pNpScb;
    PLIST_ENTRY CacheEntry;
    PNDS_OBJECT_CACHE_ENTRY ObjectCache;
    BOOLEAN AnonymousScb = IS_ANONYMOUS_SCB( pScb );

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwDeleteScb...\n", 0);

    pNpScb = pScb->pNpScb;

    //
    // Make sure we are not deleting a logged in connection
    // or we will hang up the license until the server times
    // it out.
    //

    ASSERT( pNpScb->State != SCB_STATE_IN_USE );
    ASSERT( pNpScb->Reference == 0 );
    ASSERT( !pNpScb->Sending );
    ASSERT( !pNpScb->Receiving );
    ASSERT( !pNpScb->OkToReceive );
    ASSERT( IsListEmpty( &pNpScb->Requests ) );
    ASSERT( IsListEmpty( &pScb->IcbList ) );
    ASSERT( pScb->IcbCount == 0 );
    ASSERT( pScb->VcbCount == 0 );


    DebugTrace(0, Dbg, "Cleaning up SCB %08lx\n", pScb);

    if ( AnonymousScb ) {
        DebugTrace(0, Dbg, "SCB is anonymous\n", &pNpScb->ServerName );
    } else {
        ASSERT( IsListEmpty( &pScb->ScbSpecificVcbQueue ) );
        DebugTrace(0, Dbg, "SCB is %wZ\n", &pNpScb->ServerName );
    }

    DebugTrace(0, Dbg, "SCB state is %d\n", &pNpScb->State );

    if ( !AnonymousScb ) {
        RtlRemoveUnicodePrefix ( &NwRcb.ServerNameTable, &pScb->PrefixEntry );
    }

    IPX_Close_Socket( &pNpScb->Server );
    IPX_Close_Socket( &pNpScb->WatchDog );
    IPX_Close_Socket( &pNpScb->Send );
    IPX_Close_Socket( &pNpScb->Echo);
    IPX_Close_Socket( &pNpScb->Burst);

    NwUninitializePidTable( pNpScb );        

    FREE_POOL( pNpScb );

    if ( pScb->UserName.Buffer != NULL ) {
        FREE_POOL( pScb->UserName.Buffer );
    }

    //
    //  Free the object cache buffer if there is one.
    //

    if( pScb->ObjectCacheBuffer != NULL ) {

        //
        //  Remove any references this cache has to other SCBs.
        //
        //  NOTE:  We do not need the lock here, since no one else
        //         can be using this SCB.
        //

        CacheEntry = pScb->ObjectCacheList.Flink;

        while( CacheEntry != &(pScb->ObjectCacheList) ) {

            ObjectCache = CONTAINING_RECORD( CacheEntry, NDS_OBJECT_CACHE_ENTRY, Links );

            if( ObjectCache->Scb != NULL ) {

                NwDereferenceScb( ObjectCache->Scb->pNpScb );
                ObjectCache->Scb = NULL;
            }

            CacheEntry = CacheEntry->Flink;
        }

        FREE_POOL( pScb->ObjectCacheBuffer );
    }

    FREE_POOL( pScb );

    DebugTrace(-1, Dbg, "NwDeleteScb -> VOID\n", 0);
}


PNONPAGED_SCB
SelectConnection(
    PNONPAGED_SCB NpScb OPTIONAL
    )
/*++

Routine Description:

    Find a default server (which is also the nearest server).
    If NpScb is not supplied, simply return the first server in
    the list.  If it is supplied return the next server in the
    list after the given server.

Arguments:

    NpScb - The starting point for the server search.

Return Value:

    Scb to be used or NULL.

--*/
{
    PLIST_ENTRY ScbQueueEntry;
    KIRQL OldIrql;
    PNONPAGED_SCB pNextNpScb;

    DebugTrace(+1, Dbg, "SelectConnection....\n", 0);
    KeAcquireSpinLock(&ScbSpinLock, &OldIrql);

    if ( NpScb == NULL ) {
        ScbQueueEntry = ScbQueue.Flink ;
    } else {
        ScbQueueEntry = NpScb->ScbLinks.Flink;
    }

    for ( ;
          ScbQueueEntry != &ScbQueue ;
          ScbQueueEntry = ScbQueueEntry->Flink ) {

        pNextNpScb = CONTAINING_RECORD(
                         ScbQueueEntry,
                         NONPAGED_SCB,
                         ScbLinks );

        //
        //  Check to make sure that this SCB is usable.
        //

        if (( pNextNpScb->State == SCB_STATE_RECONNECT_REQUIRED ) ||
            ( pNextNpScb->State == SCB_STATE_LOGIN_REQUIRED ) ||
            ( pNextNpScb->State == SCB_STATE_IN_USE )) {

            NwReferenceScb( pNextNpScb );

            KeReleaseSpinLock(&ScbSpinLock, OldIrql);
            DebugTrace(+0, Dbg, "  NpScb        = %lx\n", pNextNpScb );
            DebugTrace(-1, Dbg, "   NpScb->State = %x\n", pNextNpScb->State );
            return pNextNpScb;
        }
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql);
    DebugTrace(-1, Dbg, "       NULL\n", 0);
    return NULL;
}


VOID
NwLogoffAllServers(
    PIRP_CONTEXT pIrpContext,
    PLARGE_INTEGER Uid
    )
/*++

Routine Description:

    This routine sends a logoff to all connected servers created by the Logon
    user or all servers if Logon is NULL.

Arguments:

    Uid - Supplies the servers to disconnect from.

Return Value:

    none.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY ScbQueueEntry;
    PLIST_ENTRY NextScbQueueEntry;
    PNONPAGED_SCB pNpScb;

    DebugTrace( 0, Dbg, "NwLogoffAllServers\n", 0 );

    KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

    for (ScbQueueEntry = ScbQueue.Flink ;
         ScbQueueEntry != &ScbQueue ;
         ScbQueueEntry =  NextScbQueueEntry ) {

        pNpScb = CONTAINING_RECORD( ScbQueueEntry, NONPAGED_SCB, ScbLinks );

        //
        //  Reference the SCB so that it doesn't disappear while we
        //  are disconnecting.
        //

        NwReferenceScb( pNpScb );

        //
        //  Release the SCB spin lock so that we can send a logoff
        //  NCP.
        //

        KeReleaseSpinLock( &ScbSpinLock, OldIrql );

        //
        //  Destroy this Scb if its not the permanent Scb and either we
        //  are destroying all Scb's or it was created for this user.
        //

        if (( pNpScb->pScb != NULL ) &&
            (( Uid == NULL ) ||
             ( pNpScb->pScb->UserUid.QuadPart == (*Uid).QuadPart))) {

            NwLogoffAndDisconnect( pIrpContext, pNpScb );
        }

        KeAcquireSpinLock( &ScbSpinLock, &OldIrql );

        //
        //  Release the temporary reference.
        //

        NextScbQueueEntry = pNpScb->ScbLinks.Flink;
        NwDereferenceScb( pNpScb );
    }

    KeReleaseSpinLock( &ScbSpinLock, OldIrql );
}


VOID
NwLogoffAndDisconnect(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    )
/*++

Routine Description:

    This routine sends a logoff and disconnects from the name server.

Arguments:

    pIrpContext - A pointer to the current IRP context.
    pNpScb - A pointer to the server to logoff and disconnect.

Return Value:

    None.

--*/
{
    PSCB pScb = pNpScb->pScb;

    PAGED_CODE();

    pIrpContext->pNpScb = pNpScb;
    pIrpContext->pScb = pScb;

    //
    //  Queue ourselves to the SCB, and wait to get to the front to
    //  protect access to server State.
    //

    NwAppendToQueueAndWait( pIrpContext );

    //
    //  If we are logging out from the preferred server, free the preferred
    //  server reference.
    //

    if ( pScb != NULL &&
         pScb->PreferredServer ) {
        pScb->PreferredServer = FALSE;
        NwDereferenceScb( pNpScb );
    }

    //
    //  Nothing to do if we are not connected.
    //

    if ( pNpScb->State != SCB_STATE_IN_USE &&
         pNpScb->State != SCB_STATE_LOGIN_REQUIRED ) {

        NwDequeueIrpContext( pIrpContext, FALSE );
        return;
    }

    //
    //  If we timeout then we don't want to go to the bother of
    //  reconnecting.
    //

    ClearFlag( pIrpContext->Flags, IRP_FLAG_RECONNECTABLE );

    //
    //  Logout and disconnect.
    //

    if ( pNpScb->State == SCB_STATE_IN_USE ) {

        ExchangeWithWait (
            pIrpContext,
            SynchronousResponseCallback,
            "F",
            NCP_LOGOUT );
    }

    ExchangeWithWait (
        pIrpContext,
        SynchronousResponseCallback,
        "D-" );          // Disconnect

    Stats.Sessions--;

    if ( pScb->MajorVersion == 2 ) {
        Stats.NW2xConnects--;
    } else if ( pScb->MajorVersion == 3 ) {
        Stats.NW3xConnects--;
    } else if ( pScb->MajorVersion >= 4 ) {
        Stats.NW4xConnects--;
    }

    //
    //  dfergus 19 Apr 2001 #302137
    //  Removed the following fix for fix #302137
    //
    // tommye - MS 25584 / MCS 274
    //
    // Added code to look for this tree in the user's cached
    // credentials and remove it if there is one.  This fixes
    // a problem where the user could perform a tree connect 
    // providing the user name and password, delete the connection
    // then connect again successfully providing only the user name 
    // (we would get the password from the cached credentials).
    //
    // 5/31/00 - made changes to locking per conversation with Anoop
    //
/*  // Begin 302137
    {
        PLOGON pLogon = NULL;

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        pLogon = FindUser( &pScb->UserUid, FALSE );
        NwReleaseRcb( &NwRcb );

        if (pLogon) {
            PLIST_ENTRY pFirst, pNext;
            PNDS_SECURITY_CONTEXT pNdsContext;

            // Lock the credential list while we walk it

            NwAcquireExclusiveCredList( pLogon, pIrpContext );

            pFirst = &pLogon->NdsCredentialList;
            pNext  = pLogon->NdsCredentialList.Flink;

            // Go through the credential list and find a match for the tree name 

            while ( pNext && ( pFirst != pNext ) ) {

                pNdsContext = (PNDS_SECURITY_CONTEXT)
                              CONTAINING_RECORD( pNext,
                                                 NDS_SECURITY_CONTEXT,
                                                 Next );

                ASSERT( pNdsContext->ntc == NW_NTC_NDS_CREDENTIAL );

                // If this is the same tree, free the entry

                if ( !RtlCompareUnicodeString( &pScb->NdsTreeName,
                                               &pNdsContext->NdsTreeName,
                                               TRUE ) ) {

                    DebugTrace(0, Dbg, "   Removing cached credential for tree %wZ\n", &pNdsContext->NdsTreeName);

                    RemoveEntryList( &pNdsContext->Next );
                    FreeNdsContext( pNdsContext );

                    break;
                }

                pNext = pNdsContext->Next.Flink;
            }

            // Release the lock 

            NwReleaseCredList( pLogon, pIrpContext );
        }
    }
*/  //  End 302137
    //
    //  Free the remembered username and password.
    //

    if ( pScb != NULL && pScb->UserName.Buffer != NULL ) {
        FREE_POOL( pScb->UserName.Buffer );
        RtlInitUnicodeString( &pScb->UserName, NULL );
        RtlInitUnicodeString( &pScb->Password, NULL );
    }

    pNpScb->State = SCB_STATE_RECONNECT_REQUIRED;

    NwDequeueIrpContext( pIrpContext, FALSE );
    return;
}


VOID
InitializeAttach (
    VOID
    )
/*++

Routine Description:

    Initialize global structures for attaching to servers.

Arguments:

    none.

Return Value:

    none.

--*/
{
    PAGED_CODE();

    KeInitializeSpinLock( &ScbSpinLock );
    InitializeListHead(&ScbQueue);
}


NTSTATUS
OpenScbSockets(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNpScb
    )
/*++

Routine Description:

    Open the communications sockets for an SCB.

Arguments:

    pIrpContext - The IRP context pointers for the request in progress.

    pNpScb - The SCB to connect to the network.

Return Value:

    The status of the operation.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Auto allocate to the server socket.
    //

    pNpScb->Server.Socket = 0;

    Status = IPX_Open_Socket (pIrpContext, &pNpScb->Server);

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    //
    //  Watchdog Socket is Server.Socket+1
    //

    pNpScb->WatchDog.Socket = NextSocket( pNpScb->Server.Socket );
    Status = IPX_Open_Socket ( pIrpContext, &pNpScb->WatchDog );

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    //
    //  Send Socket is WatchDog.Socket+1
    //

    pNpScb->Send.Socket = NextSocket( pNpScb->WatchDog.Socket );
    Status = IPX_Open_Socket ( pIrpContext, &pNpScb->Send );

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    //
    //  Echo socket
    //

    pNpScb->Echo.Socket = NextSocket( pNpScb->Send.Socket );
    Status = IPX_Open_Socket ( pIrpContext, &pNpScb->Echo );

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    //
    //  Burst socket
    //

    pNpScb->Burst.Socket = NextSocket( pNpScb->Echo.Socket );
    Status = IPX_Open_Socket ( pIrpContext, &pNpScb->Burst );

    if ( !NT_SUCCESS(Status) ) {
        return( Status );
    }

    return( STATUS_SUCCESS );
}

NTSTATUS
DoBinderyLogon(
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Password
    )
/*++

Routine Description:

    Performs a bindery based encrypted logon.

    Note: Rcb is held exclusively so that we can access the Logon queue
          safely.

Arguments:

    pIrpContext - The IRP context pointers for the request in progress.

    UserName - The user name to use to login.

    Password - The password to use to login.

Return Value:

    The status of the operation.

--*/
{
    PNONPAGED_SCB pNpScb;
    PSCB pScb;
    UNICODE_STRING Name;
    UNICODE_STRING PWord;
    UCHAR EncryptKey[ENCRYPTION_KEY_SIZE ];
    NTSTATUS Status;
    PVOID Buffer;
    PLOGON Logon = NULL;
    PWCH OldBuffer;

    PAGED_CODE();

    DebugTrace( +1, Dbg, "DoBinderyLogon...\n", 0);

    //
    //  First get an encryption key.
    //

    DebugTrace( +0, Dbg, " Get Login key\n", 0);

    Status = ExchangeWithWait (
                IrpContext,
                SynchronousResponseCallback,
                "S",
                NCP_ADMIN_FUNCTION, NCP_GET_LOGIN_KEY );

    pNpScb = IrpContext->pNpScb;
    pScb = pNpScb->pScb;

    DebugTrace( +0, Dbg, "                 %X\n", Status);

    if ( NT_SUCCESS( Status ) ) {
        Status = ParseResponse(
                     IrpContext,
                     IrpContext->rsp,
                     IrpContext->ResponseLength,
                     "Nr",
                     EncryptKey, sizeof(EncryptKey) );
    }

    DebugTrace( +0, Dbg, "                 %X\n", Status);

    //
    //  Choose a name and password to use to connect to the server.  Use
    //  the user supplied if the exist.  Otherwise if the server already
    //  has a remembered username use the remembered name.   If nothing
    //  else is available use the defaults from logon.  Finally, if the
    //  user didn't even logon, use GUEST no password.
    //


    if ( UserName != NULL && UserName->Buffer != NULL ) {

        Name = *UserName;

    } else if ( pScb->UserName.Buffer != NULL ) {

        Name = pScb->UserName;

    } else {

        Logon = FindUser( &pScb->UserUid, FALSE );

        if (Logon != NULL ) {
            Name = Logon->UserName;
        } else {
            ASSERT( FALSE && "No logon record found" );
            return( STATUS_ACCESS_DENIED );
        }
    }

    if ( Password != NULL && Password->Buffer != NULL ) {

        PWord = *Password;

    } else if ( pScb->Password.Buffer != NULL ) {
        /*
         *  Password is not passed in, or implied.
         *  If the user name matches or was not passed in,
         *  then use the SCB password,
         *  else use a null password.
         */
        if ( UserName == NULL || UserName->Buffer == NULL ||
             ( RtlEqualUnicodeString( &pScb->UserName, UserName, TRUE )) ) {
            PWord = pScb->Password;
        } else {
            PWord.Buffer = L"";
            PWord.Length = PWord.MaximumLength = 0;
        }

    } else {

        if ( Logon == NULL ) {
            Logon = FindUser( &pScb->UserUid, FALSE );
        }

        if ( Logon != NULL ) {
            PWord = Logon->PassWord;
        } else {
            ASSERT( FALSE && "No logon record found" );
            return( STATUS_ACCESS_DENIED );
        }
    }


    if ( !NT_SUCCESS(Status) ) {

        //
        //  Failed to get an encryption key.  Login to server, plain text
        //

        DebugTrace( +0, Dbg, " Plain Text Login\n", 0);

        Status = ExchangeWithWait (
                    IrpContext,
                    SynchronousResponseCallback,
                    "SwJU",  // JimTh 5/19/2001 - Send Name using 'J' option, DBCS translation if on Far East system
                    NCP_ADMIN_FUNCTION, NCP_PLAIN_TEXT_LOGIN,
                    OT_USER,
                    &Name,
                    &PWord);

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( NT_SUCCESS( Status ) ) {
            Status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "N" );
        }

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( !NT_SUCCESS( Status )) {
            return( STATUS_WRONG_PASSWORD);
        }

    } else if ( NT_SUCCESS( Status ) ) {

        //
        //  We have an encryption key. Get the ObjectId
        //

        UCHAR Response[ENCRYPTION_KEY_SIZE];
        UCHAR ObjectId[OBJECT_ID_SIZE];
        OEM_STRING UOPassword;

        DebugTrace( +0, Dbg, " Query users objectid\n", 0);

        Status = ExchangeWithWait (
                    IrpContext,
                    SynchronousResponseCallback,
                    "SwJ", // JimTh 5/19/2001 - Send Name using 'J' option, DBCS translation if on Far East system
                    NCP_ADMIN_FUNCTION, NCP_QUERY_OBJECT_ID,
                    OT_USER,
                    &Name);

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( NT_SUCCESS( Status ) ) {

            //
            //  Save the new address in a local copy so that we can logout.
            //

            Status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "Nr",
                         ObjectId, OBJECT_ID_SIZE );
        }

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if (!NT_SUCCESS(Status)) {
            return( STATUS_NO_SUCH_USER );
        }

        //
        //  Convert the unicode password to uppercase and then the oem
        //  character set.
        //

        if ( PWord.Length > 0 ) {

            Status = RtlUpcaseUnicodeStringToOemString( &UOPassword, &PWord, TRUE );
            if (!NT_SUCCESS(Status)) {
                return( Status );
            }

        } else {
            UOPassword.Buffer = "";
            UOPassword.Length = UOPassword.MaximumLength = 0;
        }

        RespondToChallenge( ObjectId, &UOPassword, EncryptKey, Response);

        if ( PWord.Length > 0) {
            RtlFreeAnsiString( &UOPassword );
        }

        DebugTrace( +0, Dbg, " Encrypted Login\n", 0);

        Status = ExchangeWithWait (
                     IrpContext,
                     SynchronousResponseCallback,
                     "SrwJ", // JimTh 5/19/2001 - Send Name using 'J' option, DBCS translation if on Far East system
                     NCP_ADMIN_FUNCTION, NCP_ENCRYPTED_LOGIN,
                     Response, sizeof(Response),
                     OT_USER,
                     &Name);

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( NT_SUCCESS( Status ) ) {

            //
            //  Save the new address in a local copy so that we can logout
            //

            Status = ParseResponse(
                         IrpContext,
                         IrpContext->rsp,
                         IrpContext->ResponseLength,
                         "N" );
        }

        DebugTrace( +0, Dbg, "                 %X\n", Status);

        if ( !NT_SUCCESS( Status )) {

            //
            //  Special case error mappings.
            //

            if (( Status == STATUS_UNSUCCESSFUL ) ||
                ( Status == STATUS_UNEXPECTED_NETWORK_ERROR /* 2.2 servers */  )) {
                Status = STATUS_WRONG_PASSWORD;
            }

            if ( Status == STATUS_LOCK_NOT_GRANTED ) {
                Status = STATUS_ACCOUNT_RESTRICTION;  // Bindery locked
            }

            if ( Status == STATUS_DISK_FULL ) {
#ifdef QFE_BUILD
                Status = STATUS_TOO_MANY_SESSIONS;
#else
                Status = STATUS_REMOTE_SESSION_LIMIT;
#endif
            }

            if ( Status == STATUS_FILE_LOCK_CONFLICT ) {
                Status = STATUS_SHARING_PAUSED;
            }

            if ( Status == STATUS_NO_MORE_ENTRIES ) {
                Status = STATUS_NO_SUCH_USER;    // No such object on "Login Object Encrypted" NCP.
            }

            //
            // Netware 4.x servers return a different NCP error for
            // a disabled account (from intruder lockout) on bindery login,
            // and nwconvert maps this to a dos error.  In this special case,
            // we'll catch it and map it back.
            //

            if ( ( IrpContext->pNpScb->pScb->MajorVersion >= 4 ) &&
                 ( Status == 0xC001003B ) ) {
                Status = STATUS_ACCOUNT_DISABLED;
            }

            return( Status );
        }

    } else {

        return( Status );

    }

    //
    //  If the Uid is for the system process then the username must be
    //  in the NtGateway group on the server.
    //

    if ( IrpContext->Specific.Create.UserUid.QuadPart == DefaultLuid.QuadPart) {

        NTSTATUS Status1 ;

        //  IsBinderyObjectInSet?
        Status1 = ExchangeWithWait (
                      IrpContext,
                      SynchronousResponseCallback,
                      "SwppwU",
                      NCP_ADMIN_FUNCTION, NCP_IS_OBJECT_IN_SET,
                      OT_GROUP,
                      "NTGATEWAY",
                      "GROUP_MEMBERS",
                      OT_USER,
                      &Name);

        if ( !NT_SUCCESS( Status1 ) ) {
            return STATUS_ACCESS_DENIED;
        }

    }

    //
    //  Success.  Save the username & password for reconnect.
    //

    //
    //  Setup to free the old user name and password buffer.
    //

    if ( pScb->UserName.Buffer != NULL ) {
        OldBuffer = pScb->UserName.Buffer;
    } else {
        OldBuffer = NULL;
    }

    Buffer = ALLOCATE_POOL( NonPagedPool, Name.Length + PWord.Length );
    if ( Buffer == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    pScb->UserName.Buffer = Buffer;
    pScb->UserName.Length = pScb->UserName.MaximumLength = Name.Length;
    RtlMoveMemory( pScb->UserName.Buffer, Name.Buffer, Name.Length );

    pScb->Password.Buffer = (PWCHAR)((PCHAR)Buffer + Name.Length);
    pScb->Password.Length = pScb->Password.MaximumLength = PWord.Length;
    RtlMoveMemory( pScb->Password.Buffer, PWord.Buffer, PWord.Length );

    if ( OldBuffer != NULL ) {
        FREE_POOL( OldBuffer );
    }
    return( Status );
}

NTSTATUS
NwAllocateAndInitScb(
    IN PIRP_CONTEXT pIrpContext,
    IN PUNICODE_STRING UidServerName OPTIONAL,
    IN PUNICODE_STRING ServerName OPTIONAL,
    OUT PSCB *ppScb
)
/*++

Routine Description:

    This routine returns a pointer to a newly created SCB.  If
    the UidServerName and ServerName are supplied, the SCB name
    fields are initialized to this name.  Otherwise, the name
    fields are left blank to be filled in later.

    If UidServerName is provided, ServerName MUST also be provided!!

    The returned SCB is NOT filed in the server prefix table since
    it might not yet have a name.

Return Value:

    The created SCB or NULL.

--*/
{

    NTSTATUS Status;
    PSCB pScb = NULL;
    PNONPAGED_SCB pNpScb = NULL;
    USHORT ServerNameLength;
    PLOGON Logon;
    PNDS_OBJECT_CACHE_ENTRY ObjectEntry;
    ULONG EntrySize;
    ULONG i;

    //
    // Allocate enough space for a credential munged tree name.
    //

    pScb = ALLOCATE_POOL ( PagedPool,
               sizeof( SCB ) +
               ( ( NDS_TREE_NAME_LEN + MAX_NDS_NAME_CHARS + 2 ) * sizeof( WCHAR ) ) );

    if ( !pScb ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( pScb, sizeof( SCB ) );
    RtlInitializeBitMap( &pScb->DriveMapHeader, pScb->DriveMap, MAX_DRIVES );

    //
    //  Initialize pointers to ensure cleanup on error case operates
    //  correctly.
    //

    if ( UidServerName &&
         UidServerName->Length ) {

        ServerNameLength = UidServerName->Length + sizeof( WCHAR );

    } else {

        ServerNameLength = ( MAX_SERVER_NAME_LENGTH * sizeof( WCHAR ) ) +
                           ( MAX_UNICODE_UID_LENGTH * sizeof( WCHAR ) ) +
                           ( 2 * sizeof( WCHAR ) );

    }

    pScb->pNpScb = ALLOCATE_POOL ( NonPagedPool,
                       sizeof( NONPAGED_SCB ) + ServerNameLength );

    if ( !pScb->pNpScb ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitWithCleanup;
    }

    RtlZeroMemory( pScb->pNpScb, sizeof( NONPAGED_SCB ) );

    pNpScb = pScb->pNpScb;
    pNpScb->pScb = pScb;

    //
    //  If we know the server name, copy it to the allocated buffer.
    //  Append a NULL so that we can use the name a nul-terminated string.
    //

    pScb->UidServerName.Buffer = (PWCHAR)( pScb->pNpScb + 1 );
    pScb->UidServerName.MaximumLength = ServerNameLength;
    pScb->UidServerName.Length = 0;

    RtlInitUnicodeString( &(pNpScb->ServerName), NULL );

    if ( UidServerName &&
         UidServerName->Length ) {

        RtlCopyUnicodeString ( &pScb->UidServerName, UidServerName );
        pScb->UidServerName.Buffer[ UidServerName->Length / sizeof( WCHAR ) ] = L'\0';

        pScb->UnicodeUid = pScb->UidServerName;
        pScb->UnicodeUid.Length = UidServerName->Length -
                                  ServerName->Length -
                                  sizeof(WCHAR);

        //
        //  Make ServerName point partway down the buffer for UidServerName
        //

        pNpScb->ServerName.Buffer = (PWSTR)((PUCHAR)pScb->UidServerName.Buffer +
                                    UidServerName->Length - ServerName->Length);

        pNpScb->ServerName.MaximumLength = ServerName->Length;
        pNpScb->ServerName.Length = ServerName->Length;

    }

    pScb->NdsTreeName.MaximumLength = NDS_TREE_NAME_LEN * sizeof( WCHAR );
    pScb->NdsTreeName.Buffer = (PWCHAR)(pScb + 1);

    pScb->NodeTypeCode = NW_NTC_SCB;
    pScb->NodeByteSize = sizeof(SCB);
    InitializeListHead( &pScb->ScbSpecificVcbQueue );
    InitializeListHead( &pScb->IcbList );

    //
    // Remember UID of the file creator so we can find the username and
    // password to use for this Scb when we need it.
    //

    pScb->UserUid = pIrpContext->Specific.Create.UserUid;

    //
    //  Initialize the non-paged part of the SCB.
    //

    pNpScb->NodeTypeCode = NW_NTC_SCBNP;
    pNpScb->NodeByteSize = sizeof(NONPAGED_SCB);

    //
    //  Set the initial SCB reference count.
    //

    if ( UidServerName &&
         UidServerName->Length ) {

        Logon = FindUser( &pScb->UserUid, FALSE );

        if (( Logon != NULL) &&
            (RtlCompareUnicodeString( ServerName, &Logon->ServerName, TRUE ) == 0 )) {
            pScb->PreferredServer = TRUE;
        }
    }

    if ( pScb->PreferredServer ) {
        pNpScb->Reference = 2;
    } else {
        pNpScb->Reference = 1;
    }

    //
    //  Finish linking the two parts of the Scb together.
    //

    pNpScb->pScb = pScb;

    KeInitializeSpinLock( &pNpScb->NpScbSpinLock );
    KeInitializeSpinLock( &pNpScb->NpScbInterLock );
    InitializeListHead( &pNpScb->Requests );

    RtlFillMemory( &pNpScb->LocalAddress, sizeof(IPXaddress), 0xff);

    pNpScb->State = SCB_STATE_ATTACHING;
    pNpScb->SequenceNo = 1;

    Status = OpenScbSockets( pIrpContext, pNpScb );
    if ( !NT_SUCCESS(Status) ) {
        goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 pIrpContext,
                 &pNpScb->Server,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &ServerDatagramHandler,
                 pNpScb );

    if ( !NT_SUCCESS(Status) ) {
        goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 pIrpContext,
                 &pNpScb->WatchDog,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &WatchDogDatagramHandler,
                 pNpScb );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 pIrpContext,
                 &pNpScb->Send,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &SendDatagramHandler,
                 pNpScb );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 pIrpContext,
                 &pNpScb->Echo,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &ServerDatagramHandler,
                 pNpScb );

    pNpScb->EchoCounter = 2;

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    Status = SetEventHandler (
                 pIrpContext,
                 &pNpScb->Burst,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 &ServerDatagramHandler,
                 pNpScb );

    if ( !NT_SUCCESS( Status ) ) {
        goto ExitWithCleanup;
    }

    KeQuerySystemTime( &pNpScb->LastUsedTime );

    //
    //  Set burst mode data.
    //

    pNpScb->BurstRequestNo = 0;
    pNpScb->BurstSequenceNo = 0;

    //
    //  Initialize the NDS object cache if it is enabled.
    //

    if( NdsObjectCacheSize != 0 ) {

        //
        //  Determine the size of each entry.  This must be eight byte aligned,
        //  since they will all be allocated in one big block.
        //
        //  NOTE:  The NDS_OBJECT_CACHE_ENTRY structure must already be aligned.
        //

        EntrySize = sizeof(NDS_OBJECT_CACHE_ENTRY) + (((sizeof(WCHAR) * MAX_NDS_NAME_CHARS) + 7) & ~7);

        //
        //  Allocate the buffer for the cache.  If memory cannot be allocated, it is not
        //  fatal.  In this case, the object cache is just disabled for this SCB.
        //

        pScb->ObjectCacheBuffer = ALLOCATE_POOL( PagedPool,
                                                 (EntrySize * NdsObjectCacheSize) );

        if( pScb->ObjectCacheBuffer != NULL ) {

            //
            //  Initialize the object cache buffer.  It is one big block of memory that
            //  is broken up into cache entries.  Each entry is connected to the next
            //  via a list entry.  This way the entries can be manipulated on the linked
            //  list, but there is only one allocation to deal with.
            //

            InitializeListHead( &(pScb->ObjectCacheList) );

            RtlZeroMemory( pScb->ObjectCacheBuffer,
                           (EntrySize * NdsObjectCacheSize) );

            for( i = 0; i < NdsObjectCacheSize; i++ ) {

                ObjectEntry = (PNDS_OBJECT_CACHE_ENTRY)(((PBYTE)(pScb->ObjectCacheBuffer)) + (EntrySize * i));

                InsertTailList( &(pScb->ObjectCacheList), &(ObjectEntry->Links) );

                //
                //  The buffer for the object name string immediately follows the cache entry.
                //

                ObjectEntry->ObjectName.Buffer = (PWCHAR)(ObjectEntry + 1);
                ObjectEntry->ObjectName.MaximumLength = MAX_NDS_NAME_CHARS * sizeof(WCHAR);
            }

            //
            //  This semaphore protects the object cache.
            //

            KeInitializeSemaphore( &(pScb->ObjectCacheLock),
                                   1,
                                   1 );
        }
    }

    if ( ppScb ) {
        *ppScb = pScb;
    }

    if (NwInitializePidTable( pNpScb )) {

        return STATUS_SUCCESS;
    
    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

ExitWithCleanup:

    if ( pNpScb != NULL ) {

        IPX_Close_Socket( &pNpScb->Server );
        IPX_Close_Socket( &pNpScb->WatchDog );
        IPX_Close_Socket( &pNpScb->Send );
        IPX_Close_Socket( &pNpScb->Echo );
        IPX_Close_Socket( &pNpScb->Burst );

        FREE_POOL( pNpScb );
    }

    FREE_POOL(pScb);
    return Status;

}


BOOLEAN
NwFindScb(
    OUT PSCB *Scb,
    PIRP_CONTEXT IrpContext,
    PUNICODE_STRING UidServerName,
    PUNICODE_STRING ServerName
    )
/*++

Routine Description:

    This routine returns a pointer to the SCB for the named server.
    The name is looked up in the SCB table.  If it is found, a
    pointer to the SCB is returned.  If none is found an SCB is
    created and initialized.

    This routine returns with the SCB referenced and the SCB
    resources held.

Arguments:

    Scb - Returns a pointer to the found / created SCB.

    IrpContext - The IRP context pointers for the request in progress.

    ServerName - The name of the server to find / create.

Return Value:

    TRUE - An old SCB was found.

    FALSE - A new SCB was created, or an attempt to create the SCB failed.

--*/
{
    BOOLEAN RcbHeld;
    PUNICODE_PREFIX_TABLE_ENTRY PrefixEntry;
    NTSTATUS Status;
    PSCB pScb = NULL;
    PNONPAGED_SCB pNpScb = NULL;
    KIRQL OldIrql;
    BOOLEAN Success, PreferredServerIsSet;

    //
    //  Acquire the RCB exclusive to protect the prefix table.
    //  Then lookup the name of this server.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    RcbHeld = TRUE;
    PrefixEntry = RtlFindUnicodePrefix( &NwRcb.ServerNameTable, UidServerName, 0 );

    if ( PrefixEntry != NULL ) {

        PSCB pScb = NULL;
        PNONPAGED_SCB pNpScb = NULL;

        //
        // We found the SCB, increment the reference count and return
        // success.
        //

        pScb = CONTAINING_RECORD( PrefixEntry, SCB, PrefixEntry );
        pNpScb = pScb->pNpScb;

        NwReferenceScb( pNpScb );

        //
        //  Release the RCB.
        //

        NwReleaseRcb( &NwRcb );

        DebugTrace(-1, Dbg, "NwFindScb -> %08lx\n", pScb );
        *Scb = pScb;
        return( TRUE );
    }

    //
    //  We do not have a connection to this server so create the new Scb if requested.
    //

    if ( BooleanFlagOn( IrpContext->Flags, IRP_FLAG_NOCONNECT ) ) {
        NwReleaseRcb( &NwRcb );
        *Scb = NULL;
        return(FALSE);
    }

    try {

        Status = NwAllocateAndInitScb( IrpContext,
                                       UidServerName,
                                       ServerName,
                                       &pScb );

        if ( !NT_SUCCESS( Status )) {
            ExRaiseStatus( Status );
        }

        ASSERT( pScb != NULL );

        pNpScb = pScb->pNpScb;

        PreferredServerIsSet = pScb->PreferredServer;

        //
        //*******************************************************************
        //
        //  From this point on we must not fail to create the Scb because the
        //  another thread will be able to reference the Scb causing severe
        //  problems in the finaly clause or in the other thread.
        //
        //*******************************************************************
        //

        //
        //  Insert this SCB in the global list if SCBs.
        //  If it is the default (i.e. preferred) server, stick it at the
        //  front of the queue so that SelectConnection() will select it
        //  for bindery queries.
        //

        KeAcquireSpinLock(&ScbSpinLock, &OldIrql);

        if ( PreferredServerIsSet ) {
            InsertHeadList(&ScbQueue, &pNpScb->ScbLinks);
        } else {
            InsertTailList(&ScbQueue, &pNpScb->ScbLinks);
        }

        KeReleaseSpinLock(&ScbSpinLock, OldIrql);

        //
        //  Insert the name of this server into the prefix table.
        //

        Success = RtlInsertUnicodePrefix(
                      &NwRcb.ServerNameTable,
                      &pScb->UidServerName,
                      &pScb->PrefixEntry );

#ifdef NWDBG
        if ( !Success ) {
            DebugTrace( 0, DEBUG_TRACE_ALWAYS, "Entering duplicate SCB %wZ.\n", &pScb->UidServerName );
            DbgBreakPoint();
        }
#endif

        //
        //  The Scb is now in the prefix table. Any new requests for this
        //  connection can be added to the Scb->Requests queue while we
        //  attach to the server.
        //

        NwReleaseRcb( &NwRcb );
        RcbHeld = FALSE;

        //
        // If we got an error we should have raised an exception.
        //

        ASSERT( NT_SUCCESS( Status ) );

    } finally {

        if ( !NT_SUCCESS( Status ) || AbnormalTermination() ) {
            *Scb = NULL;
        } else {
            *Scb = pScb;
        }

        if (RcbHeld) {
            NwReleaseRcb( &NwRcb );
        }

    }

    return( FALSE );
}

NTSTATUS
QueryServersAddress(
    PIRP_CONTEXT pIrpContext,
    PNONPAGED_SCB pNearestScb,
    PUNICODE_STRING pServerName,
    IPXaddress *pServerAddress
    )
{
    NTSTATUS Status;
    UNICODE_STRING NewServer;
    USHORT CurrChar = 0;
    BOOLEAN SeedServerRedirect = FALSE;
    PNONPAGED_SCB pOrigNpScb;

    PAGED_CODE();

    if ( pIrpContext->Specific.Create.fExCredentialCreate ) {

        //
        //  Unmunge the server name if this is a
        //  supplemental credential connect.
        //

        UnmungeCredentialName( pServerName, &NewServer );

    } else if ( EnableMultipleConnects ) {

        //
        //  Strip server name trailer, if it exists.  If there
        //  was no trailer, the length will end up being exactly
        //  the same as when we started.
        //

         Status = DuplicateUnicodeStringWithString(
                                                   &NewServer,
                                                   pServerName,
                                                   PagedPool
                                                   );
         if ( NT_SUCCESS( Status ) ) {

            return Status;
         }

        while ( (CurrChar < (NewServer.Length / sizeof(WCHAR))) &&
            NewServer.Buffer[CurrChar] != ((WCHAR)L'#') ) {
            CurrChar++;
        }
        NewServer.Length = CurrChar * sizeof(WCHAR);

    } else {
    
        //
        // If we support seed server indirection, check the server
        // name for a seed server.  If there is a seed server specified,
        // connect us to it.
        //


        if ( AllowSeedServerRedirection ) {
   
            pOrigNpScb = pIrpContext->pNpScb;
            NwDequeueIrpContext( pIrpContext, FALSE );

            Status = IndirectToSeedServer( pIrpContext,
                                           pServerName,
                                           &NewServer );

            if ( NT_SUCCESS( Status ) ) {

                SeedServerRedirect = TRUE;

            } else {

                NwAppendToQueueAndWait( pIrpContext );
            }
        }

        //
        // If we didn't get redirected to a seed server, then
        // just set up the server name like normal and try that.
        // 

        if ( !SeedServerRedirect ) {

           NewServer.Length = pServerName->Length;
           NewServer.MaximumLength = pServerName->MaximumLength;
           NewServer.Buffer = pServerName->Buffer;

        }

    }

    //
    //  Query the bindery of the nearest server looking for
    //  the network address of the target server.
    //

    DebugTrace( +0, Dbg, "Query servers address\n", 0);

    Status = ExchangeWithWait (
                 pIrpContext,
                 SynchronousResponseCallback,
                 "SwUbp",
                 NCP_ADMIN_FUNCTION, NCP_QUERY_PROPERTY_VALUE,
                 OT_FILESERVER,
                 &NewServer,
                 1,     //  Segment number
                 NET_ADDRESS_PROPERTY );

    DebugTrace( +0, Dbg, "                 %X\n", Status);

    if ( NT_SUCCESS( Status ) ) {

        //
        //  Save the new address.
        //

        Status = ParseResponse(
                     pIrpContext,
                     pIrpContext->rsp,
                     pIrpContext->ResponseLength,
                     "Nr",
                     pServerAddress, sizeof(TDI_ADDRESS_IPX) );
    }

    DebugTrace( +0, Dbg, "                 %X\n", Status);

    //
    //  Map the server not found error to something sensible.
    //

    if (( Status == STATUS_NO_MORE_ENTRIES ) ||
        ( Status == STATUS_VIRTUAL_CIRCUIT_CLOSED ) ||
        ( Status == NwErrorToNtStatus(ERROR_UNEXP_NET_ERR))) {
        Status = STATUS_BAD_NETWORK_PATH;
    }

    if ( SeedServerRedirect ) {

         //
         // Dequeue from the seed server and free the ref count.
         // There should always be an original server, but just
         // in case there's not, we check.
         //

         NwDequeueIrpContext( pIrpContext, FALSE );
         NwDereferenceScb( pIrpContext->pNpScb );

         ASSERT( pOrigNpScb != NULL );

         if ( pOrigNpScb ) {

             pIrpContext->pNpScb = pOrigNpScb;
             pIrpContext->pScb = pOrigNpScb->pScb;
             NwAppendToQueueAndWait( pIrpContext );

         } else {

             pIrpContext->pNpScb = NULL;
             pIrpContext->pScb = NULL;
         }

    }

    return( Status );
}



VOID
TreeConnectScb(
    IN PSCB Scb
    )
/*++

Routine Description:

    This routine increments the tree connect count for a SCB.

Arguments:

    Scb - A pointer to the SCB to connect to.

Return Value:

    None.

--*/
{
    NwAcquireExclusiveRcb( &NwRcb, TRUE );
    Scb->AttachCount++;
    Scb->OpenFileCount++;
    NwReferenceScb( Scb->pNpScb );
    NwReleaseRcb( &NwRcb );
}


NTSTATUS
TreeDisconnectScb(
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb
    )
/*++

Routine Description:

    This routine decrements the tree connect count for a SCB.

    ***  This routine must be called with the RCB resource held.

Arguments:

    Scb - A pointer to the SCB to disconnect.

Return Value:

    None.

--*/
{
    NTSTATUS Status;

    if ( Scb->AttachCount > 0 ) {

        Scb->AttachCount--;
        Scb->OpenFileCount--;
        NwDereferenceScb( Scb->pNpScb );

        Status = STATUS_SUCCESS;

        if ( Scb->OpenFileCount == 0 ) {

            //
            //  Logoff and disconnect from the server now.
            //  Hold on to the SCB lock.
            //  This prevents another thread from trying to access
            //  SCB will this thread is logging off.
            //

            NwLogoffAndDisconnect( IrpContext, Scb->pNpScb );
        }
    } else {
        Status = STATUS_INVALID_HANDLE;
    }

    NwDequeueIrpContext( IrpContext, FALSE );
    return( Status );
}


VOID
ReconnectScb(
    IN PIRP_CONTEXT pIrpContext,
    IN PSCB pScb
    )
/*++

Routine Description:

    This routine reconnects all the dir handles to a server
    when reconnecting an SCB.


Arguments:

    pScb - A pointer to the SCB that has just been reconnected.

Return Value:

    None.

--*/
{
    //
    //  If this is a reconnect, kill all old ICB and VCB handles
    //

    if ( pScb->VcbCount != 0 ) {

        NwAcquireExclusiveRcb( &NwRcb, TRUE );

        //
        //  Invalid all ICBs
        //

        NwInvalidateAllHandlesForScb( pScb );
        NwReleaseRcb( &NwRcb );

        //
        //  Acquire new VCB handles for all VCBs.
        //

        NwReopenVcbHandlesForScb( pIrpContext, pScb );
    }
}

NTSTATUS
IndirectToSeedServer(
    PIRP_CONTEXT pIrpContext,
    PUNICODE_STRING pServerName,
    PUNICODE_STRING pNewServer
)
/*+++

    Description: This function takes a server name.  If that server name
    is in the format target_server(seed_server), this routine will:
     
      1) put the target server in pNewServer
      2) lookup the seed server and queue the irp context to it
    
---*/
{

    NTSTATUS Status;
    UNICODE_STRING SeedServer;
    PWCHAR pwCurrent;
    PSCB pScb;
    
    RtlInitUnicodeString( &SeedServer, NULL );
    RtlInitUnicodeString( pNewServer, NULL );

    pwCurrent = pServerName->Buffer;

    DebugTrace( 0, Dbg, "IndirectToSeedServer: %wZ\n", pServerName );

    while ( pNewServer->Length <= pServerName->Length ) {

        if ( *pwCurrent == L'(' ) {

            pNewServer->Buffer = pServerName->Buffer;
            pNewServer->MaximumLength = pNewServer->Length;
            DebugTrace( 0, Dbg, "Target server is %wZ.\n", pNewServer );

            SeedServer.Length = pServerName->Length -
                                pNewServer->Length;

            if ( SeedServer.Length <= ( 2 * sizeof( WCHAR ) ) ) {
                
                SeedServer.Length = 0;

            } else {

                SeedServer.Length -= ( 2 * sizeof( WCHAR ) );
                SeedServer.Buffer = pwCurrent + 1;
                SeedServer.MaximumLength = SeedServer.Length;
                DebugTrace( 0, Dbg, "Seed server is %wZ.\n", &SeedServer );

            }

            break;
            
        } else {

            pNewServer->Length += sizeof( WCHAR );
            pwCurrent++;
        }
    }

    if ( SeedServer.Length == 0 ) {
        DebugTrace( 0, Dbg, "IndirectToSeedServer failed to decode nested name.\n", 0 );
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now do something about it.
    //

    Status = CreateScb( &pScb,
                        pIrpContext,
                        &SeedServer,
                        NULL,
                        NULL,
                        NULL,
                        TRUE,
                        FALSE );
    
    if ( !NT_SUCCESS( Status ) ) {
        DebugTrace( 0, Dbg, "Couldn't contact seed server.\n", 0 );
        return STATUS_UNSUCCESSFUL;
    }

    NwAppendToQueueAndWait( pIrpContext );
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\rdr\callback.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    callback.c

Abstract:

    This module implements NCP Response callback routines.

Author:

    Manny Weiser    [MannyW]    3-Mar-1993

Revision History:

--*/

#include "procs.h"

#define Dbg                              (DEBUG_TRACE_EXCHANGE)

#ifdef ALLOC_PRAGMA
#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, SynchronousResponseCallback )
#pragma alloc_text( PAGE1, AsynchResponseCallback )
#endif
#endif

#if 0  // Not pageable

// see ifndef QFE_BUILD above

#endif


NTSTATUS
SynchronousResponseCallback (
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR RspData
    )
/*++

Routine Description:

    This routine is the callback routine for an NCP which has no
    return parameters and the caller blocks waiting for a response.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

    BytesAvailable - Actual number of bytes in the received message.

    RspData - Points to the receive buffer.

Return Value:

    NTSTATUS - Status of the operation.

--*/

{
    PEPrequest  *pNcpHeader;
    PEPresponse *pNcpResponse;

    DebugTrace( 0, Dbg, "SynchronousResponseCallback\n", 0 );
    ASSERT( pIrpContext->pNpScb->Requests.Flink == &pIrpContext->NextRequest );

    if ( BytesAvailable == 0) {

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

#ifdef MSWDBG
        ASSERT( pIrpContext->Event.Header.SignalState == 0 );
        pIrpContext->DebugValue = 0x103;
#endif
        pIrpContext->pOriginalIrp->IoStatus.Status = STATUS_REMOTE_NOT_LISTENING;
        NwSetIrpContextEvent( pIrpContext );

        return STATUS_REMOTE_NOT_LISTENING;
    }

    pIrpContext->ResponseLength = BytesAvailable;

    //
    //  Simply copy the data into the response buffer, if it is not
    //  already there (because we used an IRP to receive the data).
    //

    if ( RspData != pIrpContext->rsp ) {
        CopyBufferToMdl( pIrpContext->RxMdl, 0, RspData, pIrpContext->ResponseLength );
    }

    //
    // Remember the returned error code.
    //

    pNcpHeader = (PEPrequest *)pIrpContext->rsp;
    pNcpResponse = (PEPresponse *)(pNcpHeader + 1);

    pIrpContext->ResponseParameters.Error = pNcpResponse->error;

    //
    //  Tell the caller that the response has been received.
    //

#ifdef MSWDBG
    ASSERT( pIrpContext->Event.Header.SignalState == 0 );
    pIrpContext->DebugValue = 0x104;
#endif

    pIrpContext->pOriginalIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrpContext->pOriginalIrp->IoStatus.Information = BytesAvailable;

    NwSetIrpContextEvent( pIrpContext );
    return STATUS_SUCCESS;
}

NTSTATUS
AsynchResponseCallback (
    IN PIRP_CONTEXT pIrpContext,
    IN ULONG BytesAvailable,
    IN PUCHAR RspData
    )
/*++

Routine Description:

    This routine is the callback routine for an NCP which has no
    return parameters and the caller DOES NOT BLOCK waiting for a
    response.

Arguments:

    pIrpContext - A pointer to the context information for this IRP.

    BytesAvailable - Actual number of bytes in the received message.

    RspData - Points to the receive buffer.

Return Value:

    NTSTATUS - Status of the operation.

--*/

{
    NTSTATUS Status;

    if ( BytesAvailable == 0) {

        //
        //  No response from server. Status is in pIrpContext->
        //  ResponseParameters.Error
        //

        Status = STATUS_REMOTE_NOT_LISTENING;

    } else {

        if ( ((PNCP_RESPONSE)RspData)->Status != 0 ) {

            Status = STATUS_LINK_FAILED;

        } else {

            Status = NwErrorToNtStatus( ((PNCP_RESPONSE)RspData)->Error );

        }
    }

    //
    //  We're done with this request.  Dequeue the IRP context from
    //  SCB and complete the request.
    //

    NwDequeueIrpContext( pIrpContext, FALSE );
    NwCompleteRequest( pIrpContext, Status );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\rdr\cleanup.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module implements the file cleanup routine for Netware Redirector.

Author:

    Manny Weiser (mannyw)    9-Feb-1993

Revision History:

--*/

#include "procs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  local procedure prototypes
//

NTSTATUS
NwCommonCleanup (
    IN PIRP_CONTEXT IrpContext
    );


NTSTATUS
NwCleanupRcb (
    IN PIRP Irp,
    IN PRCB Rcb
    );

NTSTATUS
NwCleanupScb (
    IN PIRP Irp,
    IN PSCB Scb
    );

NTSTATUS
NwCleanupIcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PICB Icb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdCleanup )
#pragma alloc_text( PAGE, NwCommonCleanup )
#pragma alloc_text( PAGE, NwCleanupScb )

#ifndef QFE_BUILD
#pragma alloc_text( PAGE1, NwCleanupIcb )
#endif

#endif

#if 0   // Not pageable

NwCleanupRcb

// see ifndef QFE_BUILD above

#endif


NTSTATUS
NwFsdCleanup (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCleanupFile API calls.

Arguments:

    DeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS status;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdCleanup\n", 0);

    //
    // Call the common cleanup routine.
    //

    TopLevel = NwIsIrpTopLevel( Irp );

    FsRtlEnterFileSystem();

    try {

        IrpContext = AllocateIrpContext( Irp );
        status = NwCommonCleanup( IrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( IrpContext == NULL ) {
        
            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            // We had some trouble trying to perform the requested
            // operation, so we'll abort the I/O request with
            // the error status that we get back from the
            // execption code.
            //

            status = NwProcessException( IrpContext, GetExceptionCode() );
        }
    }

    if ( IrpContext ) {
        NwCompleteRequest( IrpContext, status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    // Return to our caller.
    //

    DebugTrace(-1, Dbg, "NwFsdCleanup -> %08lx\n", status );
    return status;
}


NTSTATUS
NwCommonCleanup (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the common routine for cleaning up a file.

Arguments:

    IrpContext - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    NODE_TYPE_CODE nodeTypeCode;
    PVOID fsContext, fsContext2;

    PAGED_CODE();

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NwCommonCleanup\n", 0);
    DebugTrace( 0, Dbg, "IrpContext       = %08lx\n", (ULONG_PTR)IrpContext);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG_PTR)Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG_PTR)irpSp->FileObject);

    try {

        //
        // Get the a referenced pointer to the node and make sure it is
        // not being closed.
        //

        if ((nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                                &fsContext,
                                                &fsContext2 )) == NTC_UNDEFINED) {

            DebugTrace(0, Dbg, "The file is disconnected\n", 0);

            status = STATUS_INVALID_HANDLE;

            DebugTrace(-1, Dbg, "NwCommonCleanup -> %08lx\n", status );
            try_return( NOTHING );
        }

        //
        // Decide how to handle this IRP.
        //

        switch (nodeTypeCode) {

        case NW_NTC_RCB:       // Cleanup the file system

            status = NwCleanupRcb( Irp, (PRCB)fsContext2 );
            break;

        case NW_NTC_SCB:       // Cleanup the server control block

            status = NwCleanupScb( Irp, (PSCB)fsContext2 );
            break;

        case NW_NTC_ICB:       // Cleanup the remote file
        case NW_NTC_ICB_SCB:   // Cleanup the server

            status = NwCleanupIcb( IrpContext, Irp, (PICB)fsContext2 );
            break;

#ifdef NWDBG
        default:

            //
            // This is not one of ours.
            //

            KeBugCheck( RDR_FILE_SYSTEM );
            break;
#endif

        }

    try_exit: NOTHING;

    } finally {

        DebugTrace(-1, Dbg, "NwCommonCleanup -> %08lx\n", status);

    }

    return status;
}


NTSTATUS
NwCleanupRcb (
    IN PIRP Irp,
    IN PRCB Rcb
    )

/*++

Routine Description:

    The routine cleans up a RCB.

    This routine grabs a spinlock so must not be paged out while running.

    Do not reference the code section since this will start the timer and
    we don't stop it in the rcb close path.

Arguments:

    Irp - Supplies the IRP associated with the cleanup.

    Rcb - Supplies the RCB for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT closingFileObject;
    BOOLEAN OwnRcb;
    BOOLEAN OwnMessageLock = FALSE;
    KIRQL OldIrql;
    PLIST_ENTRY listEntry, nextListEntry;
    PIRP_CONTEXT pTestIrpContext;
    PIO_STACK_LOCATION pTestIrpSp;
    PIRP pTestIrp;

    DebugTrace(+1, Dbg, "NwCleanupRcb...\n", 0);

    //
    //  Now acquire exclusive access to the Rcb
    //

    NwAcquireExclusiveRcb( Rcb, TRUE );
    OwnRcb = TRUE;

    status = STATUS_SUCCESS;

    try {

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        IoRemoveShareAccess( irpSp->FileObject,
                             &Rcb->ShareAccess );

        NwReleaseRcb( Rcb );
        OwnRcb = FALSE;

        closingFileObject = irpSp->FileObject;


        //
        //  Walk the message queue and complete any outstanding Get Message IRPs
        //

        KeAcquireSpinLock( &NwMessageSpinLock, &OldIrql );
        OwnMessageLock = TRUE;

        for ( listEntry = NwGetMessageList.Flink;
              listEntry != &NwGetMessageList;
              listEntry = nextListEntry ) {

            nextListEntry = listEntry->Flink;

            //
            //  If the file object of the queued request, matches the file object
            //  that is being closed, remove the IRP from the queue, and
            //  complete it with an error.
            //

            pTestIrpContext = CONTAINING_RECORD( listEntry, IRP_CONTEXT, NextRequest );
            pTestIrp = pTestIrpContext->pOriginalIrp;
            pTestIrpSp = IoGetCurrentIrpStackLocation( pTestIrp );

            if ( pTestIrpSp->FileObject == closingFileObject ) {
                RemoveEntryList( listEntry );

                IoAcquireCancelSpinLock( &pTestIrp->CancelIrql );
                IoSetCancelRoutine( pTestIrp, NULL );
                IoReleaseCancelSpinLock( pTestIrp->CancelIrql );

                NwCompleteRequest( pTestIrpContext, STATUS_INVALID_HANDLE );
            }

        }

        KeReleaseSpinLock( &NwMessageSpinLock, OldIrql );
        OwnMessageLock = FALSE;

    } finally {

        if ( OwnRcb ) {
            NwReleaseRcb( Rcb );
        }

        if ( OwnMessageLock ) {
            KeReleaseSpinLock( &NwMessageSpinLock, OldIrql );
        }

        DebugTrace(-1, Dbg, "NwCleanupRcb -> %08lx\n", status);
    }

    //
    //  And return to our caller
    //

    return status;
}


NTSTATUS
NwCleanupScb (
    IN PIRP Irp,
    IN PSCB Scb
    )

/*++

Routine Description:

    The routine cleans up an ICB.

Arguments:

    Irp - Supplies the IRP associated with the cleanup.

    Scb - Supplies the SCB to cleanup.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwCleanupScb...\n", 0);

    Status = STATUS_SUCCESS;

    try {

        //
        // Ensure that this SCB is still active.
        //

        NwVerifyScb( Scb );

        //
        // Cancel any IO on this SCB.
        //

    } finally {

        DebugTrace(-1, Dbg, "NwCleanupScb -> %08lx\n", Status);
    }

    //
    //  And return to our caller
    //

    return Status;
}


NTSTATUS
NwCleanupIcb (
    IN PIRP_CONTEXT pIrpContext,
    IN PIRP Irp,
    IN PICB Icb
    )

/*++

Routine Description:

    The routine cleans up an ICB.

Arguments:

    Irp - Supplies the IRP associated with the cleanup.

    Rcb - Supplies the RCB for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS Status;
    PNONPAGED_FCB NpFcb;

    DebugTrace(+1, Dbg, "NwCleanupIcb...\n", 0);

    Status = STATUS_SUCCESS;

    try {

        Icb->State = ICB_STATE_CLEANED_UP;

        //
        // Cancel any IO on this ICB.
        //

#if 0
        //  HACKHACK

        if ( Icb->SuperType.Fcb->NodeTypeCode == NW_NTC_DCB ) {

            PLIST_ENTRY listEntry;

            NwAcquireExclusiveRcb( &NwRcb, TRUE );

            for ( listEntry = FnList.Flink; listEntry != &FnList ; listEntry = listEntry->Flink ) {

                PIRP_CONTEXT IrpContext;

                IrpContext = CONTAINING_RECORD( listEntry, IRP_CONTEXT, NextRequest );

                if ( IrpContext->Icb == Icb ) {

                    PIRP irp = pIrpContext->pOriginalIrp;

                    IoAcquireCancelSpinLock( &irp->CancelIrql );
                    IoSetCancelRoutine( irp, NULL );
                    IoReleaseCancelSpinLock( irp->CancelIrql );

                    RemoveEntryList( &IrpContext->NextRequest );
                    NwCompleteRequest( IrpContext, STATUS_NOT_SUPPORTED );
                    break;
                }
            }

            NwReleaseRcb( &NwRcb );
        }
#endif

        //
        // If this is a remote file clear all the cache garbage.
        //

        if ( Icb->NodeTypeCode == NW_NTC_ICB ) {

            if ( Icb->HasRemoteHandle ) {

                //
                // Free all of file lock structures that are still hanging around.
                //

                pIrpContext->pScb = Icb->SuperType.Fcb->Scb;
                pIrpContext->pNpScb = Icb->SuperType.Fcb->Scb->pNpScb;

                NwFreeLocksForIcb( pIrpContext, Icb );

                NwDequeueIrpContext( pIrpContext, FALSE );

                //
                //
                //
                //  If this is an executable opened over the net, then
                //  its possible that the executables image section
                //  might still be kept open.
                //
                //  Ask MM to flush the section closed.  This will fail
                //  if the executable in question is still running.
                //

                NpFcb = Icb->SuperType.Fcb->NonPagedFcb;
                MmFlushImageSection(&NpFcb->SegmentObject, MmFlushForWrite);

                //
                //  There is also a possiblity that there is a user section
                //  open on this file, in which case we need to force the
                //  section closed to make sure that they are cleaned up.
                //

                MmForceSectionClosed(&NpFcb->SegmentObject, TRUE);

            }

            //
            //  Acquire the fcb and remove shared access.
            //

            NwAcquireExclusiveFcb( Icb->SuperType.Fcb->NonPagedFcb, TRUE );

            IoRemoveShareAccess(
                Icb->FileObject,
                &Icb->SuperType.Fcb->ShareAccess );

            NwReleaseFcb( Icb->SuperType.Fcb->NonPagedFcb );
        }


    } finally {

        DebugTrace(-1, Dbg, "NwCleanupIcb -> %08lx\n", Status);
    }

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\rdr\const.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Const.h

Abstract:

    This module declares the obal data used by the NetWare redirector
    file system.

Author:

    Colin Watson    [ColinW]    14-Jan-1993

Revision History:

--*/

#ifndef _NWCONST_
#define _NWCONST_

//  Number of spare stack locations required in Irp's submitted to this
//  filesystem

#define NWRDR_IO_STACKSIZE 2

//
// NT uses a system time measured in 100 nanosecnd intervals. define
// convenient constants for setting the timer.
//

#define MICROSECONDS                10
#define MILLISECONDS                MICROSECONDS*1000
#define SECONDS                     MILLISECONDS*1000

#define NwOneSecond 10000000

//
//  Default number of times to retranmit a packet before giving up
//  on waiting for a response.
//

#define  DEFAULT_RETRY_COUNT   10

//
//  Amount of time, in seconds, an idle SCB or VCB should be kept around before
//  being cleaned up.
//

#define  DORMANT_SCB_KEEP_TIME   120
#define  DORMANT_VCB_KEEP_TIME   120

//
//  Largest netware file name
//

#define NW_MAX_FILENAME_LENGTH  255
#define NW_MAX_FILENAME_SIZE    ( NW_MAX_FILENAME_LENGTH * sizeof(WCHAR) )

//
//  Default frequency for running the scavenger (in 1/18th second ticks)
//  Approx once per minute.
//

#define DEFAULT_SCAVENGER_TICK_RUN_COUNT 1100

//
//  Size of the drive map table.   With room for 26 letter connections,
//  and 10 LPT connections.
//

#define MAX_DISK_REDIRECTIONS  26
#define MAX_LPT_REDIRECTIONS   10
#define DRIVE_MAP_TABLE_SIZE   (MAX_DISK_REDIRECTIONS + MAX_LPT_REDIRECTIONS)

//
//  The size of the largest packet we can generate, rounded up to DWORD
//  size.  This longest packet is a rename with two long filenames plus 
//  the header (256*2) + 32
//

#define  MAX_SEND_DATA      (512)+32
//
//  The size of the largest non READ packet we can receive, rounded up to DWORD
//  size. This longest packet is read queue job list of 250 jobs
//

#define  MAX_RECV_DATA      544+32

//
//  Best guess at max packet size, if the transport can't tell us.
//  Pick the largest value that will work on any net.
//

#define DEFAULT_PACKET_SIZE  512

//
//  How close we want to get to true MTU of a connection
//

#define BURST_PACKET_SIZE_TOLERANCE  8

//
//  Default tick count, in case the transport won't fess up.
//

#define DEFAULT_TICK_COUNT      2

//
//  Maximum number of times to retry SAP broadcast if we get no response
//

#define MAX_SAP_RETRIES         2

//
//  The maximum number of SAP response to process if we get many.
//

#define MAX_SAP_RESPONSES       4


#define LFN_NO_OS2_NAME_SPACE   -1

//
// The ordinal for the long namespace in the namespace packet.
//

#define DOS_NAME_SPACE_ORDINAL  0
#define LONG_NAME_SPACE_ORDINAL 4

//
//  Largest possible SAP Response size and size of a SAP record
//

#define MAX_SAP_RESPONSE_SIZE   512
#define SAP_RECORD_SIZE         (2 + 48 + 12 + 2)
#define FIND_NEAREST_RESP_SIZE  (2 + SAP_RECORD_SIZE)

//
//  Netware limits
//

#define MAX_SERVER_NAME_LENGTH   48
#define MAX_UNICODE_UID_LENGTH   8
#define MAX_USER_NAME_LENGTH     49
#define MAX_VOLUME_NAME_LENGTH   17

//
//  Maximum number of unique drive letters we will send to a server.
//  Only seems to matter to portable netWare servers.
//
#define MAX_DRIVES              64


//
//  Default Timeout Event interval. We do not want to fill up the
//  event-log with timeout events. If a timeout event has been logged
//  in the last timeout event interval, we will ignore further timeout
//  events.
//

#define DEFAULT_TIMEOUT_EVENT_INTERVAL  5


#endif // _NWCONST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\rdr\cache.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Cache.c

Abstract:

    This module implements internal caching support routines.  It does
    not interact with the cache manager.

Author:

    Manny Weiser     [MannyW]    05-Jan-1994

Revision History:

--*/

#include "Procs.h"

//
//  The local debug trace level
//

BOOLEAN
SpaceForWriteBehind(
    PNONPAGED_FCB NpFcb,
    ULONG FileOffset,
    ULONG BytesToWrite
    );

BOOLEAN
OkToReadAhead(
    PFCB Fcb,
    IN ULONG FileOffset,
    IN UCHAR IoType
    );

#define Dbg                              (DEBUG_TRACE_CACHE)

//
//  Local procedure prototypes
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, CacheRead )
#pragma alloc_text( PAGE, SpaceForWriteBehind )
#pragma alloc_text( PAGE, CacheWrite )
#pragma alloc_text( PAGE, OkToReadAhead )
#pragma alloc_text( PAGE, CalculateReadAheadSize )
#pragma alloc_text( PAGE, FlushCache )
#pragma alloc_text( PAGE, AcquireFcbAndFlushCache )
#endif


ULONG
CacheRead(
    IN PNONPAGED_FCB NpFcb,
    IN ULONG FileOffset,
    IN ULONG BytesToRead,
    IN PVOID UserBuffer
    , IN BOOLEAN WholeBufferOnly
    )
/*++

Routine Description:

    This routine attempts to satisfy a user read from cache.  It returns
    the number of bytes actually copied from cache.

Arguments:

    NpFcb - A pointer the the nonpaged FCB of the file being read.

    FileOffset - The file offset to read.

    BytesToRead - The number of bytes to read.

    UserBuffer - A pointer to the users target buffer.

    WholeBufferOnly - Do a cache read only if we can satisfy the entire
        read request.

Return Value:

    The number of bytes copied to the user buffer.

--*/
{
    ULONG BytesToCopy;

    PAGED_CODE();

    if (DisableReadCache) return 0 ;

    DebugTrace(0, Dbg, "CacheRead...\n", 0 );
    DebugTrace( 0, Dbg, "FileOffset = %d\n", FileOffset );
    DebugTrace( 0, Dbg, "ByteCount  = %d\n", BytesToRead );

    NwAcquireSharedFcb( NpFcb, TRUE );

    //
    //  If this is a read ahead and it contains some data that the user
    //  could be interested in, copy the interesting data.
    //

    if ( NpFcb->CacheType == ReadAhead &&
         NpFcb->CacheDataSize != 0 &&
         FileOffset >= NpFcb->CacheFileOffset &&
         FileOffset <= NpFcb->CacheFileOffset + NpFcb->CacheDataSize ) {

        if ( NpFcb->CacheBuffer ) {

            //
            // Make sure we have a CacheBuffer.
            //

            BytesToCopy =
                MIN ( BytesToRead,
                      NpFcb->CacheFileOffset +
                          NpFcb->CacheDataSize - FileOffset );

            if ( WholeBufferOnly && BytesToCopy != BytesToRead ) {
                NwReleaseFcb( NpFcb );
                return( 0 );
            }

            RtlCopyMemory(
                UserBuffer,
                NpFcb->CacheBuffer + ( FileOffset - NpFcb->CacheFileOffset ),
                BytesToCopy );

            DebugTrace(0, Dbg, "CacheRead -> %d\n", BytesToCopy );

        } else {

            ASSERT(FALSE);      // we should never get here
            DebugTrace(0, Dbg, "CacheRead -> %08lx\n", 0 );
            BytesToCopy = 0;
        }


    } else {

        DebugTrace(0, Dbg, "CacheRead -> %08lx\n", 0 );
        BytesToCopy = 0;
    }

    NwReleaseFcb( NpFcb );
    return( BytesToCopy );
}


BOOLEAN
SpaceForWriteBehind(
    PNONPAGED_FCB NpFcb,
    ULONG FileOffset,
    ULONG BytesToWrite
    )
/*++

Routine Description:

    This routine determines if it is ok to write behind this data to
    this FCB.

Arguments:

    NpFcb - A pointer the the NONPAGED_FCB of the file being written.

    FileOffset - The file offset to write.

    BytesToWrite - The number of bytes to write.

Return Value:

    The number of bytes copied to the user buffer.

--*/
{
    PAGED_CODE();


    if ( NpFcb->CacheDataSize == 0 ) {
        NpFcb->CacheFileOffset = FileOffset;
    }

    if ( NpFcb->CacheDataSize == 0 && BytesToWrite >= NpFcb->CacheSize ) {
        return( FALSE );
    }

    if ( FileOffset - NpFcb->CacheFileOffset + BytesToWrite >
         NpFcb->CacheSize )  {

        return( FALSE );

    }

    return( TRUE );
}


BOOLEAN
CacheWrite(
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PNONPAGED_FCB NpFcb,
    IN ULONG FileOffset,
    IN ULONG BytesToWrite,
    IN PVOID UserBuffer
    )
/*++

Routine Description:

    This routine attempts to satisfy a user write to cache.  The write
    succeeds if it is sequential and fits in the cache buffer.

Arguments:

    IrpContext - A pointer to request parameters.

    NpFcb - A pointer the the NONPAGED_FCB of the file being read.

    FileOffset - The file offset to write.

    BytesToWrite - The number of bytes to write.

    UserBuffer - A pointer to the users source buffer.

Return Value:

    The number of bytes copied to the user buffer.

--*/
{
    ULONG CacheSize;
    NTSTATUS status;

    PAGED_CODE();

    if (DisableWriteCache) return FALSE ;

    DebugTrace( +1, Dbg, "CacheWrite...\n", 0 );
    DebugTrace(  0, Dbg, "FileOffset = %d\n", FileOffset );
    DebugTrace(  0, Dbg, "ByteCount  = %d\n", BytesToWrite );

    //
    // Grab the FCB resource so that we can check the
    // share access.  (Bug 68546)
    //

    NwAcquireSharedFcb( NpFcb, TRUE );

    if ( NpFcb->Fcb->ShareAccess.SharedWrite ||
         NpFcb->Fcb->ShareAccess.SharedRead ) {

        DebugTrace(  0, Dbg, "File is not open in exclusive mode\n", 0 );
        DebugTrace( -1, Dbg, "CacheWrite -> FALSE\n", 0 );

        NwReleaseFcb( NpFcb );
        return( FALSE );
    }

    NwReleaseFcb( NpFcb );

    //
    //  Note, If we decide to send data to the server we must be at the front
    //  of the queue before we grab the Fcb exclusive.
    //

TryAgain:

    NwAcquireExclusiveFcb( NpFcb, TRUE );

    //
    //  Allocate a cache buffer if we don't already have one.
    //

    if ( NpFcb->CacheBuffer == NULL ) {

        if ( IrpContext == NULL ) {
            DebugTrace(  0, Dbg, "No cache buffer\n", 0 );
            DebugTrace( -1, Dbg, "CacheWrite -> FALSE\n", 0 );
            NwReleaseFcb( NpFcb );
            return( FALSE );
        }

        NpFcb->CacheType = WriteBehind;

        if (( IrpContext->pNpScb->SendBurstModeEnabled ) ||
            ( IrpContext->pNpScb->ReceiveBurstModeEnabled )) {

           CacheSize = IrpContext->pNpScb->MaxReceiveSize;

        } else {

           CacheSize = IrpContext->pNpScb->BufferSize;

        }

        try {

            NpFcb->CacheBuffer = ALLOCATE_POOL_EX( NonPagedPool, CacheSize );
            NpFcb->CacheSize = CacheSize;

            NpFcb->CacheMdl = ALLOCATE_MDL( NpFcb->CacheBuffer, CacheSize, FALSE, FALSE, NULL );

            if ( NpFcb->CacheMdl == NULL ) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            MmBuildMdlForNonPagedPool( NpFcb->CacheMdl );

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            if ( NpFcb->CacheBuffer != NULL) {
                FREE_POOL( NpFcb->CacheBuffer );

                NpFcb->CacheBuffer = NULL;
                NpFcb->CacheSize = 0;

            }

            DebugTrace(  0, Dbg, "Allocate failed\n", 0 );
            DebugTrace( -1, Dbg, "CacheWrite -> FALSE\n", 0 );

            NpFcb->CacheDataSize = 0;
            NwReleaseFcb( NpFcb );
            return( FALSE );
        }

        NpFcb->CacheFileOffset = 0;
        NpFcb->CacheDataSize = 0;

    } else if ( NpFcb->CacheType != WriteBehind ) {

        DebugTrace( -1, Dbg, "CacheWrite not writebehind -> FALSE\n", 0 );
        NwReleaseFcb( NpFcb );
        return( FALSE );

    }

    //
    //  If the data is non sequential and non overlapping, flush the
    //  existing cache.
    //

    if ( NpFcb->CacheDataSize != 0 &&
         ( FileOffset < NpFcb->CacheFileOffset ||
           FileOffset > NpFcb->CacheFileOffset + NpFcb->CacheDataSize ) ) {

        //
        // Release and then AcquireFcbAndFlush() will get us to the front
        // of the queue before re-acquiring. This avoids potential deadlocks.
        //

        NwReleaseFcb( NpFcb );

        if ( IrpContext != NULL ) {
            DebugTrace(  0, Dbg, "Data is not sequential, flushing data\n", 0 );

            status = AcquireFcbAndFlushCache( IrpContext, NpFcb );

            if ( !NT_SUCCESS( status ) ) {
                ExRaiseStatus( status );
            }

        }

    DebugTrace( -1, Dbg, "CacheWrite -> FALSE\n", 0 );
    return( FALSE );

    }

    //
    //  The data is sequential, see if it fits.
    //

    if ( SpaceForWriteBehind( NpFcb, FileOffset, BytesToWrite ) ) {

        try {

            RtlCopyMemory(
                NpFcb->CacheBuffer + ( FileOffset - NpFcb->CacheFileOffset ),
                UserBuffer,
                BytesToWrite );

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            DebugTrace( 0, Dbg, "Bad user mode buffer in CacheWrite.\n", 0 );
            DebugTrace(-1, Dbg, "CacheWrite -> FALSE\n", 0 );
            NwReleaseFcb( NpFcb );
            return ( FALSE );
        }

        if ( NpFcb->CacheDataSize <
             (FileOffset - NpFcb->CacheFileOffset + BytesToWrite) ) {

            NpFcb->CacheDataSize =
                FileOffset - NpFcb->CacheFileOffset + BytesToWrite;

        }

        DebugTrace(-1, Dbg, "CacheWrite -> TRUE\n", 0 );
        NwReleaseFcb( NpFcb );
        return( TRUE );

    } else if ( IrpContext != NULL ) {

        //
        //  The data didn't fit in the cache. If the cache is empty
        //  then its time to return because it never will fit and we
        //  have no stale data. This can happen if this request or
        //  another being processed in parallel flush the cache and
        //  TryAgain.
        //

        if ( NpFcb->CacheDataSize == 0 ) {
            DebugTrace(-1, Dbg, "CacheWrite -> FALSE\n", 0 );
            NwReleaseFcb( NpFcb );
            return( FALSE );
        }

        //
        //  The data didn't fit in the cache, flush the cache
        //

        DebugTrace(  0, Dbg, "Cache is full, flushing data\n", 0 );

        //
        //  We must be at the front of the Queue before writing.
        //

        NwReleaseFcb( NpFcb );

        status = AcquireFcbAndFlushCache( IrpContext, NpFcb );

        if ( !NT_SUCCESS( status ) ) {
            ExRaiseStatus( status );
        }

        //
        //  Now see if it fits in the cache. We need to repeat all
        //  the tests again because two requests can flush the cache at the
        //  same time and the other one of them could have nearly filled it again.
        //

        goto TryAgain;

    } else {
        DebugTrace(-1, Dbg, "CacheWrite full -> FALSE\n", 0 );
        NwReleaseFcb( NpFcb );
        return( FALSE );
    }
}


BOOLEAN
OkToReadAhead(
    PFCB Fcb,
    IN ULONG FileOffset,
    IN UCHAR IoType
    )
/*++

Routine Description:

    This routine determines whether the attempted i/o is sequential (so that
    we can use the cache).

Arguments:

    Fcb - A pointer the the Fcb of the file being read.

    FileOffset - The file offset to read.

Return Value:

    TRUE - The operation is sequential.
    FALSE - The operation is not sequential.

--*/
{
    PAGED_CODE();

    if ( Fcb->NonPagedFcb->CacheType == IoType &&
         !Fcb->ShareAccess.SharedWrite &&
         FileOffset == Fcb->LastReadOffset + Fcb->LastReadSize ) {

        DebugTrace(0, Dbg, "Io is sequential\n", 0 );
        return( TRUE );

    } else {

        DebugTrace(0, Dbg, "Io is not sequential\n", 0 );
        return( FALSE );

    }
}


ULONG
CalculateReadAheadSize(
    IN PIRP_CONTEXT IrpContext,
    IN PNONPAGED_FCB NpFcb,
    IN ULONG CacheReadSize,
    IN ULONG FileOffset,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine determines the amount of data that can be read ahead,
    and sets up for the read.

    Note: Fcb must be acquired exclusive before calling.

Arguments:

    NpFcb - A pointer the the nonpaged FCB of the file being read.

    FileOffset - The file offset to read.

Return Value:

    The amount of data to read.

--*/
{
    ULONG ReadSize;
    ULONG CacheSize;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "CalculateReadAheadSize\n", 0 );

    if (( IrpContext->pNpScb->SendBurstModeEnabled ) ||
        ( IrpContext->pNpScb->ReceiveBurstModeEnabled )) {

        CacheSize = IrpContext->pNpScb->MaxReceiveSize;

    } else {

        CacheSize = IrpContext->pNpScb->BufferSize;

    }

    //
    // The caller of this routine owns the FCB exclusive, so
    // we don't have to worry about the NpFcb fields like
    // ShareAccess.
    //

    if ( OkToReadAhead( NpFcb->Fcb, FileOffset - CacheReadSize, ReadAhead ) &&
         ByteCount < CacheSize ) {

        ReadSize = CacheSize;

    } else {

        //
        //  Do not read ahead.
        //

        DebugTrace( 0, Dbg, "No read ahead\n", 0 );
        DebugTrace(-1, Dbg, "CalculateReadAheadSize -> %d\n", ByteCount );
        return ( ByteCount );

    }

    //
    //  Allocate pool for the segment of the read
    //

    if ( NpFcb->CacheBuffer == NULL ) {

        try {

            NpFcb->CacheBuffer = ALLOCATE_POOL_EX( NonPagedPool, ReadSize );
            NpFcb->CacheSize = ReadSize;

            NpFcb->CacheMdl = ALLOCATE_MDL( NpFcb->CacheBuffer, ReadSize, FALSE, FALSE, NULL );
            if ( NpFcb->CacheMdl == NULL ) {
                ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
            }

            MmBuildMdlForNonPagedPool( NpFcb->CacheMdl );

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            if ( NpFcb->CacheBuffer != NULL) {
                FREE_POOL( NpFcb->CacheBuffer );

                NpFcb->CacheBuffer = NULL;
            }

            NpFcb->CacheSize = 0;
            NpFcb->CacheDataSize = 0;

            DebugTrace( 0, Dbg, "Failed to allocated buffer\n", 0 );
            DebugTrace(-1, Dbg, "CalculateReadAheadSize -> %d\n", ByteCount );
            return( ByteCount );
        }

    } else {
        ReadSize = MIN ( NpFcb->CacheSize, ReadSize );
    }

    DebugTrace(-1, Dbg, "CalculateReadAheadSize -> %d\n", ReadSize );
    return( ReadSize );
}

NTSTATUS
FlushCache(
    PIRP_CONTEXT IrpContext,
    PNONPAGED_FCB NpFcb
    )
/*++

Routine Description:

    This routine flushes the cache buffer for the NpFcb.  The caller must
    have acquired the FCB exclusive prior to making this call!

Arguments:

    IrpContext - A pointer to request parameters.

    NpFcb - A pointer the the nonpaged FCB of the file to flush.

Return Value:

    The amount of data to read.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    if ( NpFcb->CacheDataSize != 0 && NpFcb->CacheType == WriteBehind ) {

        LARGE_INTEGER ByteOffset;

        ByteOffset.QuadPart = NpFcb->CacheFileOffset;

        status = DoWrite(
                    IrpContext,
                    ByteOffset,
                    NpFcb->CacheDataSize,
                    NpFcb->CacheBuffer,
                    NpFcb->CacheMdl );

        //
        // DoWrite leaves us at the head of the queue.  The caller
        // is responsible for dequeueing the irp context appropriately.
        //

        if ( NT_SUCCESS( status ) ) {
            NpFcb->CacheDataSize = 0;
        }
    }

    return( status );
}

NTSTATUS
AcquireFcbAndFlushCache(
    PIRP_CONTEXT IrpContext,
    PNONPAGED_FCB NpFcb
    )
/*++

Routine Description:

    This routine acquires the FCB exclusive and flushes the cache
    buffer for the acquired NpFcb.

Arguments:

    IrpContext - A pointer to request parameters.

    NpFcb - A pointer the the nonpaged FCB of the file to flush.

Return Value:

    The amount of data to read.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    NwAppendToQueueAndWait( IrpContext );

    NwAcquireExclusiveFcb( NpFcb, TRUE );

    status = FlushCache( IrpContext, NpFcb );

    //
    //  Release the FCB and remove ourselves from the queue.
    //  Frequently the caller will want to grab a resource so
    //  we need to be off the queue then.
    //

    NwReleaseFcb( NpFcb );
    NwDequeueIrpContext( IrpContext, FALSE );

    return( status );
}

VOID
FlushAllBuffers(
    PIRP_CONTEXT pIrpContext
)
/*+++

    Pretty self descriptive - flush all the buffers.  The caller should
    not own any locks and should not be on an SCB queue.
    
---*/
{

    PLIST_ENTRY pVcbListEntry;
    PLIST_ENTRY pFcbListEntry;
    PVCB pVcb;
    PFCB pFcb;
    PNONPAGED_SCB pOriginalNpScb;
    PNONPAGED_SCB pNpScb;
    PNONPAGED_FCB pNpFcb;
    
    DebugTrace( 0, Dbg, "FlushAllBuffers...\n", 0 );

    ASSERT( !BooleanFlagOn( pIrpContext->Flags, IRP_FLAG_ON_SCB_QUEUE ) );
    pOriginalNpScb = pIrpContext->pNpScb;

    //
    // Grab the RCB so that we can touch the global VCB list.
    //

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    for ( pVcbListEntry = GlobalVcbList.Flink;
          pVcbListEntry != &GlobalVcbList;
          pVcbListEntry = pVcbListEntry->Flink ) {

        pVcb = CONTAINING_RECORD( pVcbListEntry, VCB, GlobalVcbListEntry );
        pNpScb = pVcb->Scb->pNpScb;

        pIrpContext->pNpScb = pNpScb;
        pIrpContext->pNpScb->pScb;

        //
        // Reference this SCB and VCB so they don't go away.
        //

        NwReferenceScb( pNpScb );
        NwReferenceVcb( pVcb );

        //
        // Release the RCB so we can get to the head of
        // the queue safely...
        //

        NwReleaseRcb( &NwRcb );
        NwAppendToQueueAndWait( pIrpContext );

        //
        // Reacquire the RCB so we can walk the FCB list safely.
        //

        NwAcquireExclusiveRcb( &NwRcb, TRUE );

        //
        // Flush all the FCBs for this VCB.
        //

        for ( pFcbListEntry = pVcb->FcbList.Flink;
              pFcbListEntry != &(pVcb->FcbList) ;
              pFcbListEntry = pFcbListEntry->Flink ) {

            pFcb = CONTAINING_RECORD( pFcbListEntry, FCB, FcbListEntry );
            pNpFcb = pFcb->NonPagedFcb;

            NwAcquireExclusiveFcb( pNpFcb, TRUE ); 
            FlushCache( pIrpContext, pNpFcb );
            NwReleaseFcb( pNpFcb );
        }

        NwDereferenceVcb( pVcb, pIrpContext, TRUE );
        NwReleaseRcb( &NwRcb );

        NwDequeueIrpContext( pIrpContext, FALSE );

        NwAcquireExclusiveRcb( &NwRcb, TRUE );
        NwDereferenceScb( pNpScb );

    }

    //
    // Release and restore.
    //

    NwReleaseRcb( &NwRcb );

    if ( pOriginalNpScb ) {

        pIrpContext->pNpScb = pOriginalNpScb;
        pIrpContext->pScb = pOriginalNpScb->pScb;

    } else {

        pIrpContext->pNpScb = NULL;
        pIrpContext->pScb = NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\rdr\close.c ===
/*++

Copyright (c) 1992-4  Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for the NetWare
    redirector called by the dispatch driver.

Author:

    Colin Watson     [ColinW]    19-Dec-1992

Revision History:

--*/

#include "Procs.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

//
//  Local procedure prototypes
//

NTSTATUS
NwCommonClose (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
NwCloseRcb (
    IN PIRP_CONTEXT IrpContext,
    IN PRCB Rcb
    );

NTSTATUS
NwCloseIcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdClose )
#pragma alloc_text( PAGE, NwCommonClose )
#pragma alloc_text( PAGE, NwCloseRcb )
#pragma alloc_text( PAGE, NwCloseIcb )
#endif


NTSTATUS
NwFsdClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Close.

Arguments:

    DeviceObject - Supplies the redirector device object.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwFsdClose\n", 0);

    FsRtlEnterFileSystem();
    
    NwReferenceUnlockableCodeSection ();
    
    //
    //  Call the common Close routine
    //

    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        IrpContext = AllocateIrpContext( Irp );
        Status = NwCommonClose( IrpContext );

    } except(NwExceptionFilter( Irp, GetExceptionInformation() )) {

       if ( IrpContext == NULL ) {

           //
           //  If we couldn't allocate an irp context, just complete
           //  irp without any fanfare.
           //

           Status = STATUS_INSUFFICIENT_RESOURCES;
           Irp->IoStatus.Status = Status;
           Irp->IoStatus.Information = 0;
           IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

       } else {

           //
           // We had some trouble trying to perform the requested
           // operation, so we'll abort the I/O request with
           // the error status that we get back from the
           // execption code.
           //

           Status = NwProcessException( IrpContext, GetExceptionCode() );
       }

    }

    if ( IrpContext ) {
        NwDequeueIrpContext( IrpContext, FALSE );
        NwCompleteRequest( IrpContext, Status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NwFsdClose -> %08lx\n", Status);

    NwDereferenceUnlockableCodeSection ();
    UNREFERENCED_PARAMETER( DeviceObject );

    FsRtlExitFileSystem();
    
    return Status;
}


NTSTATUS
NwCommonClose (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the common routine for closing a file.

Arguments:

    IrpContext - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    NODE_TYPE_CODE nodeTypeCode;
    PVOID fsContext, fsContext2;

    PAGED_CODE();

    Irp = IrpContext->pOriginalIrp;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NwCommonClose\n", 0);
    DebugTrace( 0, Dbg, "IrpContext       = %08lx\n", (ULONG_PTR)IrpContext);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", (ULONG_PTR)Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", (ULONG_PTR)irpSp->FileObject);
    try {

        //
        // Get the a referenced pointer to the node and make sure it is
        // not being closed.
        //

        if ((nodeTypeCode = NwDecodeFileObject( irpSp->FileObject,
                                                &fsContext,
                                                &fsContext2 )) == NTC_UNDEFINED) {

            DebugTrace(0, Dbg, "The file is disconnected\n", 0);

            status = STATUS_INVALID_HANDLE;

            DebugTrace(-1, Dbg, "NwCommonClose -> %08lx\n", status );
            try_return( NOTHING );
        }

        //
        // Decide how to handle this IRP.
        //

        switch (nodeTypeCode) {


        case NW_NTC_RCB:       // Close the file system

            status = NwCloseRcb( IrpContext, (PRCB)fsContext2 );
            status = STATUS_SUCCESS;
            break;

        case NW_NTC_ICB:       // Close the remote file
        case NW_NTC_ICB_SCB:   // Close the SCB

            status = NwCloseIcb( IrpContext, (PICB)fsContext2 );
            NwDereferenceUnlockableCodeSection ();
            break;

#ifdef NWDBG
        default:

            //
            // This is not one of ours.
            //

            KeBugCheck( RDR_FILE_SYSTEM );
            break;
#endif

        }

    try_exit: NOTHING;

    } finally {

        //
        //  Just in-case this handle was the last one before we unload.
        //

        NwUnlockCodeSections(TRUE);

        DebugTrace(-1, Dbg, "NwCommonClose -> %08lx\n", status);

    }

    return status;
}


NTSTATUS
NwCloseRcb (
    IN PIRP_CONTEXT IrpContext,
    IN PRCB Rcb
    )

/*++

Routine Description:

    The routine cleans up a RCB.

Arguments:

    IrpContext - Supplies the IRP context pointers for this close.

    Rcb - Supplies the RCB for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwCloseRcb...\n", 0);

    //
    //  Now acquire exclusive access to the Rcb
    //

    NwAcquireExclusiveRcb( Rcb, TRUE );

    status = STATUS_SUCCESS;
    --Rcb->OpenCount;

    NwReleaseRcb( Rcb );

    DebugTrace(-1, Dbg, "MsCloseRcb -> %08lx\n", status);

    //
    //  And return to our caller
    //

    return status;
}


NTSTATUS
NwCloseIcb (
    IN PIRP_CONTEXT IrpContext,
    IN PICB Icb
    )

/*++

Routine Description:

    The routine cleans up an ICB.

Arguments:

    IrpContext - Supplies the IRP context pointers for this close.

    Rcb - Supplies the RCB for MSFS.

Return Value:

    NTSTATUS - An appropriate completion status

--*/
{
    NTSTATUS Status;
    PNONPAGED_SCB pNpScb;
    PVCB Vcb;
    PFCB Fcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NwCloseIcb...\n", 0);

    ASSERT( Icb->State == ICB_STATE_CLEANED_UP ||
            Icb->State == ICB_STATE_CLOSE_PENDING );

    //
    // If this is a remote file close the remote handle.
    //

    Status = STATUS_SUCCESS;
    IrpContext->Icb = Icb;
    Fcb = Icb->SuperType.Fcb;

    if (( Icb->NodeTypeCode == NW_NTC_ICB ) ||
        ( Icb->NodeTypeCode == NW_NTC_DCB )) {

        pNpScb = Fcb->Scb->pNpScb;
        IrpContext->pNpScb = pNpScb;

        if ( Icb->HasRemoteHandle ) {

            Vcb = Fcb->Vcb;

            //
            //  Dump the write behind cache.
            //

            Status = AcquireFcbAndFlushCache( IrpContext, Fcb->NonPagedFcb );

            if ( !NT_SUCCESS( Status ) ) {
                IoRaiseInformationalHardError(
                    STATUS_LOST_WRITEBEHIND_DATA,
                    &Fcb->FullFileName,
                    (PKTHREAD)IrpContext->pOriginalIrp->Tail.Overlay.Thread );
            }

            //
            //  Is this a print job?
            //  Icb->IsPrintJob will be false if a 16 bit app is
            //  responsible for sending the job.
            //

            if ( FlagOn( Vcb->Flags, VCB_FLAG_PRINT_QUEUE ) &&
                 Icb->IsPrintJob ) {

                //
                //  Yes, did we print?
                //

                if ( Icb->ActuallyPrinted ) {

                    //
                    //  Yes.  Send a close file and start queue job NCP
                    //

                    Status = ExchangeWithWait(
                                IrpContext,
                                SynchronousResponseCallback,
                                "Sdw",
                                NCP_ADMIN_FUNCTION, NCP_CLOSE_FILE_AND_START_JOB,
                                Vcb->Specific.Print.QueueId,
                                Icb->JobId );
                } else {

                    //
                    //  No.  Cancel the job.
                    //

                    Status = ExchangeWithWait(
                                IrpContext,
                                SynchronousResponseCallback,
                                "Sdw",
                                NCP_ADMIN_FUNCTION, NCP_CLOSE_FILE_AND_CANCEL_JOB,
                                Vcb->Specific.Print.QueueId,
                                Icb->JobId );
                }

            } else {

                if ( Icb->SuperType.Fcb->NodeTypeCode != NW_NTC_DCB ) {

                    //
                    //  No, send a close file NCP.
                    //

                    ASSERT( IrpContext->pTdiStruct == NULL );

                    Status = ExchangeWithWait(
                                IrpContext,
                                SynchronousResponseCallback,
                                "F-r",
                                NCP_CLOSE,
                                Icb->Handle, sizeof( Icb->Handle ) );

                    // If this is in the long file name space and
                    // the last access flag has been set, we have to
                    // reset the last access time _after_ closing the file.

                    if ( Icb->UserSetLastAccessTime &&
                         BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LONG_NAME ) ) {

                        Status = ExchangeWithWait(
                            IrpContext,
                            SynchronousResponseCallback,
                            "LbbWD_W_bDbC",
                            NCP_LFN_SET_INFO,
                            Fcb->Vcb->Specific.Disk.LongNameSpace,
                            Fcb->Vcb->Specific.Disk.LongNameSpace,
                            SEARCH_ALL_FILES,
                            LFN_FLAG_SET_INFO_LASTACCESS_DATE,
                            28,
                            Fcb->LastAccessDate,
                            8,
                            Fcb->Vcb->Specific.Disk.VolumeNumber,
                            Fcb->Vcb->Specific.Disk.Handle,
                            0,
                            &Fcb->RelativeFileName );
                    }

                    //
                    // If someone set the shareable bit, then
                    // see if we can send the NCP over the wire (all
                    // instances of the file need to be closed).
                    //

                    if ( BooleanFlagOn( Fcb->Flags, FCB_FLAGS_LAZY_SET_SHAREABLE ) ) {
                        LazySetShareable( IrpContext, Icb, Fcb );
                    }

                } else {

                    Status = ExchangeWithWait (
                                 IrpContext,
                                 SynchronousResponseCallback,
                                 "Sb",
                                 NCP_DIR_FUNCTION, NCP_DEALLOCATE_DIR_HANDLE,
                                 Icb->Handle[0]);
                }

            }

            Icb->HasRemoteHandle = FALSE;
        }

    } else {

        pNpScb = Icb->SuperType.Scb->pNpScb;
        IrpContext->pNpScb = pNpScb;
        IrpContext->pScb = pNpScb->pScb;

        if ( Icb->HasRemoteHandle ) {

            //
            // If we have a remote handle this is a file stream ICB.  We
            // need to close the remote handle.  The exchange will get us
            // to the head of the queue to protect the SCB state.
            //

            Status = ExchangeWithWait(
                IrpContext,
                SynchronousResponseCallback,
                "F-r",
                NCP_CLOSE,
                Icb->Handle, sizeof( Icb->Handle ) );

            Icb->HasRemoteHandle = FALSE;

            pNpScb->pScb->OpenNdsStreams--;

            ASSERT( pNpScb->pScb->MajorVersion > 3 );

            //
            // Do we need to unlicense this connection?
            //

            if ( ( pNpScb->pScb->UserName.Length == 0 ) &&
                 ( pNpScb->pScb->VcbCount == 0 ) &&
                 ( pNpScb->pScb->OpenNdsStreams == 0 ) ) {
                NdsUnlicenseConnection( IrpContext );
            }

            NwDequeueIrpContext( IrpContext, FALSE );
        }

        if ( Icb->IsExCredentialHandle ) {
            ExCreateDereferenceCredentials( IrpContext, Icb->pContext );
        }

    }

    if ( Icb->Pid != INVALID_PID ) {

        //
        //  This ICB was involved in a search, send the end job,
        //  then free the PID.
        //

        NwUnmapPid(pNpScb, Icb->Pid, IrpContext );
    }

    //
    //  Update the time the SCB was last used.
    //

    KeQuerySystemTime( &pNpScb->LastUsedTime );

    //
    //  Wait the SCB queue.  We do this now since NwDeleteIcb may cause
    //  a packet to be sent by this thread (from NwCleanupVcb()) while
    //  holding the RCB.  To eliminate this potential source of deadlock,
    //  queue this IrpContext to the SCB queue before acquiring the RCB.
    //
    //  Also, we mark this IRP context not reconnectable, since the
    //  reconnect logic, will try to acquire the RCB.
    //

    NwAppendToQueueAndWait( IrpContext );
    ClearFlag( IrpContext->Flags, IRP_FLAG_RECONNECTABLE );

    //
    //  Delete the ICB.
    //

    NwDeleteIcb( IrpContext, Icb );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NwCloseIcb -> %08lx\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\rdr\convert.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Convert.h

Abstract:

    This module declares the types used to permit exchange.c to be used
    with minimal change in the NetWare file system.

Author:

    Colin Watson    [ColinW]    23-Dec-1992

Revision History:

--*/

#ifndef _CONVERT_
#define _CONVERT_

#define byte UCHAR
#define word USHORT
#define dword ULONG

#define offsetof(r,f)  ((size_t)&(((r*)0)->f))
#define byteswap(x)    ((x>>8)+((x&0xFF)<<8))

#endif //_CONVERT_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\rdr\create.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for the NetWare
    redirector called by the dispatch driver.

Author:

    Colin Watson    [ColinW]    19-Dec-1992
    Manny Weiser    [MannyW]    15-Feb-1993

Revision History:

--*/

#include "Procs.h"

NTSTATUS
NwCommonCreate (
    IN PIRP_CONTEXT IrpContext
    );

IO_STATUS_BLOCK
OpenRedirector(
    IN PIRP_CONTEXT IrpContext,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    PFILE_OBJECT FileObject
    );

IO_STATUS_BLOCK
CreateRemoteFile(
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING DriveName
    );

IO_STATUS_BLOCK
ChangeDirectory(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PICB Icb
    );

IO_STATUS_BLOCK
CreateDir(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PICB Icb
    );

NTSTATUS
FileOrDirectoryExists(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    PUNICODE_STRING Name,
    OUT PBOOLEAN IsAFile
    );

IO_STATUS_BLOCK
OpenFile(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    IN BYTE SearchFlags,
    IN BYTE ShareFlags
    );

IO_STATUS_BLOCK
CreateNewFile(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    IN BYTE SearchFlags,
    IN BYTE ShareFlags
    );

IO_STATUS_BLOCK
CreateOrOverwriteFile(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PICB Icb,
    IN BYTE CreateAttributes,
    IN BYTE OpenFlags,
    IN BOOLEAN CreateOperation
    );

IO_STATUS_BLOCK
OpenRenameTarget(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDCB Dcb,
    IN PICB* Icb
    );

IO_STATUS_BLOCK
CreatePrintJob(
    PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    PICB Icb,
    PUNICODE_STRING DriveName
    );

VOID
CloseFile(
    PIRP_CONTEXT pIrpContext,
    PICB pIcb
    );


BOOLEAN
MmDisableModifiedWriteOfSection (
    IN PSECTION_OBJECT_POINTERS SectionObjectPointer
    );

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, NwFsdCreate )
#pragma alloc_text( PAGE, NwCommonCreate )
#pragma alloc_text( PAGE, ReadAttachEas )
#pragma alloc_text( PAGE, OpenRedirector )
#pragma alloc_text( PAGE, CreateRemoteFile )
#pragma alloc_text( PAGE, ChangeDirectory )
#pragma alloc_text( PAGE, CreateDir )
#pragma alloc_text( PAGE, FileOrDirectoryExists )
#pragma alloc_text( PAGE, OpenFile )
#pragma alloc_text( PAGE, CreateNewFile )
#pragma alloc_text( PAGE, CreateOrOverwriteFile )
#pragma alloc_text( PAGE, OpenRenameTarget )
#pragma alloc_text( PAGE, CreatePrintJob )
#pragma alloc_text( PAGE, CloseFile )
#endif


NTSTATUS
NwFsdCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateFile and NtOpenFile
    API calls.

Arguments:

    DeviceObject - Supplies the device object for the redirector.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN TopLevel;

    PAGED_CODE();

    TimerStart(Dbg);
    DebugTrace(+1, Dbg, "NwFsdCreate\n", 0);

    //
    //  Call the common create routine, with block allowed if the operation
    //  is synchronous.
    //

    FsRtlEnterFileSystem();
    TopLevel = NwIsIrpTopLevel( Irp );

    try {

        IrpContext = AllocateIrpContext( Irp );
        Status = NwCommonCreate( IrpContext );

    } except( NwExceptionFilter( Irp, GetExceptionInformation() )) {

        if ( IrpContext == NULL ) {

            //
            //  If we couldn't allocate an irp context, just complete
            //  irp without any fanfare.
            //

            Status = STATUS_INSUFFICIENT_RESOURCES;
            Irp->IoStatus.Status = Status;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest ( Irp, IO_NETWORK_INCREMENT );

        } else {

            //
            //  We had some trouble trying to perform the requested
            //  operation, so we'll abort the I/O request with
            //  the error Status that we get back from the
            //  execption code
            //

            Status = NwProcessException( IrpContext, GetExceptionCode() );
        }
    }

    if ( IrpContext  ) {
        NwDequeueIrpContext( IrpContext, FALSE );
        NwCompleteRequest( IrpContext, Status );
    }

    if ( TopLevel ) {
        NwSetTopLevelIrp( NULL );
    }
    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NwFsdCreate -> %08lx\n", Status );

    TimerStop(Dbg,"NwFsdCreate");

    return Status;

    UNREFERENCED_PARAMETER(DeviceObject);
}


NTSTATUS
NwCommonCreate (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file called by
    both the fsd and fsp threads.

Arguments:

    IrpContext - Supplies the context information for the IRP to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    ACCESS_MASK DesiredAccess;
    USHORT ShareAccess;
    ULONG Options;
    BOOLEAN CreateTreeConnection;
    BOOLEAN DeleteOnClose;
    BOOLEAN DeferredLogon;
    BOOLEAN DereferenceCodeSection = FALSE;
    BOOLEAN OpenedTreeHandle = FALSE;

    BOOLEAN fNDSLookupFirst = FALSE;
    USHORT  iBufferIndex = 0;
    DWORD   dwSlashCount = 0;

    UNICODE_STRING CreateFileName;
    UNICODE_STRING Drive;
    UNICODE_STRING Server;
    UNICODE_STRING Volume;
    UNICODE_STRING Path;
    UNICODE_STRING FileName;
    UNICODE_STRING UserName, Password;
    ULONG ShareType;
    WCHAR DriveLetter;
    DWORD dwExtendedCreate = FALSE;

    PSCB Scb = NULL;
    PICB Icb;
    UNICODE_STRING DefaultServer;
    SECURITY_SUBJECT_CONTEXT SubjectContext;


    PAGED_CODE();

    //
    //  Get the current IRP stack location
    //

    Irp = IrpContext->pOriginalIrp;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // tommye - MS bug 30091 / MCS 262 - added some safety nets around those pointers
    // containing pointers so we don't bugcheck in the debug code.
    //

    DebugTrace(+1, Dbg, "NwCommonCreate\n", 0 );
    DebugTrace( 0, Dbg, "Irp                       = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "->Flags                   = %08lx\n", Irp->Flags );
    DebugTrace( 0, Dbg, "->FileObject              = %08lx\n", IrpSp->FileObject );
    if (IrpSp->FileObject) {
        DebugTrace( 0, Dbg, " ->RelatedFileObject      = %08lx\n", IrpSp->FileObject->RelatedFileObject );
        DebugTrace( 0, Dbg, " ->FileName               = \"%wZ\"\n",    &IrpSp->FileObject->FileName );
    }
    DebugTrace( 0, Dbg, "->AllocationSize.LowPart  = %08lx\n", Irp->Overlay.AllocationSize.LowPart );
    DebugTrace( 0, Dbg, "->AllocationSize.HighPart = %08lx\n", Irp->Overlay.AllocationSize.HighPart );
    DebugTrace( 0, Dbg, "->SystemBuffer            = %08lx\n", Irp->AssociatedIrp.SystemBuffer );
    DebugTrace( 0, Dbg, "->IrpSp->Flags            = %08lx\n", IrpSp->Flags );
    if (IrpSp->Parameters.Create.SecurityContext) {
        DebugTrace( 0, Dbg, "->DesiredAccess           = %08lx\n", IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
    }
    DebugTrace( 0, Dbg, "->Options                 = %08lx\n", IrpSp->Parameters.Create.Options );
    DebugTrace( 0, Dbg, "->Disposition             = %08lx\n", (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff);
    DebugTrace( 0, Dbg, "->FileAttributes          = %04x\n",  IrpSp->Parameters.Create.FileAttributes );
    DebugTrace( 0, Dbg, "->ShareAccess             = %04x\n",  IrpSp->Parameters.Create.ShareAccess );
    DebugTrace( 0, Dbg, "->EaLength                = %08lx\n", IrpSp->Parameters.Create.EaLength );

    CreateFileName    = IrpSp->FileObject->FileName;
    Options           = IrpSp->Parameters.Create.Options;
    DesiredAccess     = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;
    ShareAccess       = IrpSp->Parameters.Create.ShareAccess;

    CreateTreeConnection    = BooleanFlagOn( Options, FILE_CREATE_TREE_CONNECTION );
    DeleteOnClose           = BooleanFlagOn( Options, FILE_DELETE_ON_CLOSE );

    DefaultServer.Buffer = NULL;

    //
    //  Make sure the input large integer is valid
    //

    if (Irp->Overlay.AllocationSize.HighPart != 0) {

        DebugTrace(-1, Dbg, "NwCommonCreate -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Fail requests that don't have the proper impersonation level.
    //

    if ( IrpSp->Parameters.Create.SecurityContext ) {

        if ( IrpSp->Parameters.Create.SecurityContext->SecurityQos ) {

            if ( IrpSp->Parameters.Create.SecurityContext->SecurityQos->ImpersonationLevel <
                 SecurityImpersonation ) {

                DebugTrace(-1, Dbg, "NwCommonCreate -> Insufficient impersation level.\n", 0);
                return STATUS_ACCESS_DENIED;
            }
        }
    }

    Iosb.Status = STATUS_SUCCESS;

    FileObject        = IrpSp->FileObject;
    IrpContext->pNpScb = NULL;

    IrpContext->Specific.Create.UserUid =
        GetUid(&IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext);

    try {

        if ( IrpSp->FileObject->RelatedFileObject != NULL ) {

            //
            //  If we open a handle then the DereferenceCodeSection flag
            //  will be set to false. The dereference will eventually
            //  happen when the file is closed.
            //

            NwReferenceUnlockableCodeSection();
            DereferenceCodeSection = TRUE;

            //
            // Record the relative file name for this open.
            //

            IrpContext->Specific.Create.FullPathName = CreateFileName;

            Iosb = CreateRemoteFile( IrpContext, NULL );

            //
            // If we succeeded, we want to keep the code section
            // referenced because we have opened a handle.
            //

            if ( NT_SUCCESS( Iosb.Status ) ) {
                DereferenceCodeSection = FALSE;
            }

            try_return( Iosb.Status );
        }

        Iosb.Status = CrackPath (
                          &CreateFileName,
                          &Drive,
                          &DriveLetter,
                          &Server,
                          &Volume,
                          &Path,
                          &FileName,
                          NULL );

        if ( !NT_SUCCESS(Iosb.Status)) {
            try_return(Iosb.Status);
        }

        //
        //  Remember this good info.
        //

        IrpContext->Specific.Create.VolumeName = Volume;
        IrpContext->Specific.Create.PathName = Path;
        IrpContext->Specific.Create.DriveLetter = DriveLetter;
        IrpContext->Specific.Create.FileName = FileName;
        IrpContext->Specific.Create.FullPathName = CreateFileName;

        RtlInitUnicodeString( &IrpContext->Specific.Create.UidConnectName, NULL );


        //
        //  For now assume default username and password
        //

        ShareType = RESOURCETYPE_ANY;
        RtlInitUnicodeString( &UserName, NULL );
        RtlInitUnicodeString( &Password, NULL );

        if ( Server.Length == 0) {

            //
            //  Opened the redirector itself
            //

            Iosb = OpenRedirector(
                       IrpContext,
                       DesiredAccess,
                       ShareAccess,
                       FileObject );

        } else if ( Server.Length == Volume.Length - sizeof( WCHAR ) ) {

            if (IpxHandle == 0 ) {

                //
                //  We're not bound to the transport and the user is not
                //  opening the redirector to tell us to bind so return failed.
                //

                try_return( Iosb.Status = STATUS_REDIRECTOR_NOT_STARTED );
            }

            NwReferenceUnlockableCodeSection();
            DereferenceCodeSection = TRUE;

            //
            //  If the only requested access is FILE_LIST_DIRECTORY,
            //  defer the logon.  This will allow all CreateScb to
            //  succeed with when the user or password is invalid, so
            //  that the user can see volumes, or enumerate servers
            //  on the server.
            //

            if ( (DesiredAccess & ~( FILE_LIST_DIRECTORY | SYNCHRONIZE ) ) == 0 ) {
                DeferredLogon = TRUE;
            } else {
                DeferredLogon = FALSE;
            }

            //
            //  Server = "Server", Volume = "\Server"
            //

            if ( Server.Length == sizeof(WCHAR) && Server.Buffer[0] == L'*') {

                //
                //  Attempt to open \\*, open a handle to the preferred
                //  server
                //

                PLOGON Logon;

                NwAcquireExclusiveRcb( &NwRcb, TRUE );

                Logon = FindUser( &IrpContext->Specific.Create.UserUid, FALSE);
                ASSERT( Logon != NULL );

                //
                //  Capture the name to avoid holding Rcb or referencing
                //  the logon structure.
                //

                Iosb.Status = DuplicateUnicodeStringWithString (
                                    &DefaultServer,
                                    &Logon->ServerName,
                                    PagedPool);

                NwReleaseRcb( &NwRcb );

                if (!NT_SUCCESS(Iosb.Status)) {
                    try_return( Iosb.Status );
                }

                //
                //  If the user specified a preferred server and we managed
                //  to capture the name, try and connect to it.
                //

                if (DefaultServer.Length != 0) {

                    Iosb.Status = CreateScb(
                                    &Scb,
                                    IrpContext,
                                    &DefaultServer,
                                    NULL,
                                    NULL,
                                    NULL,
                                    DeferredLogon,
                                    FALSE );


                } else {

                    //
                    //  Record that we could not get to the server specified
                    //  in the login structure and that we should attempt to
                    //  use the nearest server.
                    //

                    Iosb.Status = STATUS_BAD_NETWORK_PATH;
                }

                if ( !NT_SUCCESS(Iosb.Status)) {

                    PNONPAGED_SCB NpScb;

                    //
                    //  First dequeue the IRP context, in case it was left
                    //  on an SCB queue.
                    //

                    NwDequeueIrpContext( IrpContext, FALSE );

                    //
                    //  Cannot get to the Preferred server so use any
                    //  server we have a connection to.
                    //


                    NpScb = SelectConnection( NULL );

                    if (NpScb != NULL ) {

                        Scb = NpScb->pScb;

                        Iosb.Status = CreateScb(
                                          &Scb,
                                          IrpContext,
                                          &NpScb->ServerName,
                                          NULL,
                                          NULL,
                                          NULL,
                                          DeferredLogon,
                                          FALSE );

                        //
                        //  Release the SCB reference we obtained from
                        //  SelectConnection().
                        //

                        NwDereferenceScb( NpScb );
                    }
                }

                if ( !NT_SUCCESS(Iosb.Status)) {

                    //
                    //  First dequeue the IRP context, in case it was left
                    //  on an SCB queue.
                    //

                    NwDequeueIrpContext( IrpContext, FALSE );

                    //
                    //  Let CreateScb try and find a nearest server to talk
                    //  to.
                    //

                    Iosb.Status = CreateScb(
                                      &Scb,
                                      IrpContext,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      DeferredLogon,
                                      FALSE );
                }

                if ( !NT_SUCCESS(Iosb.Status)) {
                    try_return( Iosb.Status );
                }

            } else {

                //
                // On handle opens to a server or tree we support the concept
                // of an open with supplemental credentials.  In this case, we return
                // a handle to the server or a dir server using the provided
                // credentials regardless of whether or not there are existing
                // connections to the resource.  This is primarily for admin
                // tools like OleDs.
                //

                ReadAttachEas( Irp, &UserName, &Password, &ShareType, &dwExtendedCreate );

                if ( dwExtendedCreate ) {

                    ASSERT( UserName.Length > 0 );

                    IrpContext->Specific.Create.fExCredentialCreate = TRUE;
                    IrpContext->Specific.Create.puCredentialName = &UserName;

                    //
                    // Reference the credentials before doing the create so
                    // we are guaranteed not to lose them.  This call will
                    // create a credential shell if none exists.  This keeps
                    // our reference counting consistent.  We track the
                    // credentials pointer in the irp context specific data.
                    //

                    Iosb.Status = ExCreateReferenceCredentials( IrpContext, &Server );

                    if ( !NT_SUCCESS( Iosb.Status ) ) {
                        try_return( Iosb.Status );
                    }

                }
				
                if (PreferNDSBrowsing) {

                    //
                    //   Attempt to open \\TREE
                    //
				   
                    Iosb.Status = NdsCreateTreeScb( IrpContext,
                                                    &Scb,           // dest scb
                                                    &Server,        // tree we want
                                                    &UserName,
                                                    &Password,
                                                    DeferredLogon,
                                                    DeleteOnClose );
				
                    if ( NT_SUCCESS( Iosb.Status ) ) {
                        OpenedTreeHandle = TRUE;
                    }
				    
                    if ( ( Iosb.Status == STATUS_REMOTE_NOT_LISTENING ) ||
                         ( Iosb.Status == STATUS_BAD_NETWORK_PATH ) ||
                         ( Iosb.Status == STATUS_UNSUCCESSFUL ) ) {
					
                        //
                        // If we couldn't find the server or something
                        // inexplicable occurred, attempt to open \\server
                        //
					
                        Iosb.Status = CreateScb(
                                                &Scb,
                                                IrpContext,
                                                &Server,
                                                NULL,
                                                &UserName,
                                                &Password,
                                                DeferredLogon,
                                                DeleteOnClose );
                        }
				
                    }else{
					
                    //
                    //  Attempt to open \\server
                    //

                    Iosb.Status = CreateScb(
                                            &Scb,
                                            IrpContext,
                                            &Server,
                                            NULL,
                                            &UserName,
                                            &Password,
                                            DeferredLogon,
                                            DeleteOnClose );

                    if ( ( Iosb.Status == STATUS_REMOTE_NOT_LISTENING ) ||
                         ( Iosb.Status == STATUS_BAD_NETWORK_PATH ) ||
                         ( Iosb.Status == STATUS_UNSUCCESSFUL ) ) {

                        //
                        // If we couldn't find the server or something
                        // inexplicable occurred, attempt to open \\tree.
                        //

                        Iosb.Status = NdsCreateTreeScb( IrpContext,
                                                        &Scb,           // dest scb
                                                        &Server,        // tree we want
                                                        &UserName,
                                                        &Password,
                                                        DeferredLogon,
                                                        DeleteOnClose );

                        if ( NT_SUCCESS( Iosb.Status ) ) {
                            OpenedTreeHandle = TRUE;
                        }
                    }
                }

                //  if( IsTerminalServer() ) clause below has been shifted down as we are more
                //  likely to be opening a tree or server than a pserver.
                //  so we need to check there first.

				if (IsTerminalServer()) {
            
                    /*
                     * This is an attempt to get GUEST to work for printman.
                     * I.E. If you have no connection, try the guest 
                     * connection.
                     */
                    if ( ( !NT_SUCCESS(Iosb.Status) ) &&
                         ( Iosb.Status == STATUS_NO_SUCH_USER ) &&
                         ( !CreateTreeConnection ) &&
                         ( !DeferredLogon ) ) {

                        DebugTrace( -1, Dbg, " Attempting default GUEST logon for %wZ\n", &Server );

                        Iosb.Status = CreateScb(
                                               &Scb,
                                               IrpContext,
                                               &Server,
                                               NULL,
                                               &Guest.UserName,
                                               &Guest.PassWord,
                                               DeferredLogon,
                                               DeleteOnClose );
                    }
				}

                if ( !NT_SUCCESS( Iosb.Status ) ) {

                    //
                    // If we failed to get the bindery server for
                    // some legitimate reason, bail out now.
                    //
                    try_return( Iosb.Status );
                }

                //
                // We must have a connection at this point.  We don't tree
                // connect the dir server since it's virtual.
                //

                if ( !OpenedTreeHandle && CreateTreeConnection && !DeleteOnClose ) {
                        TreeConnectScb( Scb );
                }

            }

            //
            //  Now create the ICB.
            //

            ASSERT( Iosb.Status == STATUS_SUCCESS );
            ASSERT( Scb != NULL );

            Icb = NwCreateIcb( NW_NTC_ICB_SCB, Scb );
            Icb->FileObject = FileObject;
            NwSetFileObject( FileObject, NULL, Icb );

            //
            // Indicate that the SCB was opened.
            //

            Icb->State = ICB_STATE_OPENED;

            //
            // Is this a tree handle?
            //

            Icb->IsTreeHandle = OpenedTreeHandle;

            //
            // If this was an extended create, associate this handle
            // with its extended credentials so that we can cleanup
            // when all the handles are closed.
            //

            if ( IrpContext->Specific.Create.fExCredentialCreate ) {

                ASSERT( IrpContext->Specific.Create.pExCredentials != NULL );
                Icb->pContext = IrpContext->Specific.Create.pExCredentials;
                Icb->IsExCredentialHandle = TRUE;

            }

        } else {

            NwReferenceUnlockableCodeSection();
            DereferenceCodeSection = TRUE;

            DeferredLogon = FALSE;

            if ( CreateTreeConnection ) {

                //
                // We ignore the extended create attribute here because
                // we DO NOT support extended credential creates to random
                // files and directories!
                //

                ReadAttachEas( Irp, &UserName, &Password, &ShareType, NULL );

                if ( DeleteOnClose ) {

                    //
                    //  Opening a directory to delete a volume.  Do not
                    //  force logon.
                    //

                    DeferredLogon = TRUE;
                }
            }
						
            IrpContext->Specific.Create.ShareType = ShareType;
            IrpContext->Specific.Create.NdsCreate = FALSE;
			
            //
            //  Check to see if this is an NDS object, if so set the flag to check NDS first.
            //  The only way a DOT can be in the Volume name is if it is an NDS Object, 
            //  between the third and fourth slashes.
            //

            fNDSLookupFirst = FALSE;

            for (iBufferIndex=0; iBufferIndex < (USHORT)(Volume.Length/sizeof(WCHAR)); iBufferIndex++ ) {
                if  (Volume.Buffer[iBufferIndex] == L'\\')                  
                    dwSlashCount++;
			
                if (dwSlashCount > 3) {
                    fNDSLookupFirst = FALSE;
                    break;   
                }
                if (Volume.Buffer[iBufferIndex] == L'.') {
                    fNDSLookupFirst = TRUE;
                    break;
                }
            }

			if (fNDSLookupFirst) {  

				IrpContext->Specific.Create.NdsCreate = TRUE;
				IrpContext->Specific.Create.NeedNdsData = TRUE;
	 
				Iosb.Status = NdsCreateTreeScb( IrpContext,
                                                &Scb,
                                                &Server,
                                                &UserName,
                                                &Password,
                                                DeferredLogon,
                                                DeleteOnClose );


				
                if ( Iosb.Status == STATUS_REMOTE_NOT_LISTENING ||
                     Iosb.Status == STATUS_BAD_NETWORK_PATH ||
                     Iosb.Status == STATUS_UNSUCCESSFUL ) {
					
                    //
                    //  Not found, do a bindery lookup
                    //
					
                    IrpContext->Specific.Create.NdsCreate = FALSE;
                    IrpContext->Specific.Create.NeedNdsData = FALSE;
					
                    Iosb.Status = CreateScb(
                                            &Scb,
                                            IrpContext,
                                            &Server,
                                            NULL,
                                            &UserName,
                                            &Password,
                                            DeferredLogon,
                                            DeleteOnClose );				
                }
			
			
            }else {
				
                //
                //  Object appears to be bindery, check there first.
                //

				Iosb.Status = CreateScb(
                                        &Scb,
                                        IrpContext,
                                        &Server,
                                        NULL,
                                        &UserName,
                                        &Password,
                                        DeferredLogon,
                                        DeleteOnClose );
				

		        if ( Iosb.Status == STATUS_REMOTE_NOT_LISTENING ||
	                 Iosb.Status == STATUS_BAD_NETWORK_PATH ||
					 Iosb.Status == STATUS_UNSUCCESSFUL ) {

	                //
		            // If we couldn't find the server or something
			        // inexplicable occurred, attempt to open \\tree.
				    //

					IrpContext->Specific.Create.NdsCreate = TRUE;
					IrpContext->Specific.Create.NeedNdsData = TRUE;

					Iosb.Status = NdsCreateTreeScb( IrpContext,
                                                    &Scb,
                                                    &Server,
                                                    &UserName,
                                                    &Password,
                                                    DeferredLogon,
                                                    DeleteOnClose );
					
	            }
			}

            //
            // If we have success, then there's a volume to connect.
            //

            if ( NT_SUCCESS( Iosb.Status ) ) {

                NTSTATUS CreateScbStatus;

                ASSERT( Scb != NULL );

                //
                //  Remember the status from create SCB, since it might
                //  be an interesting warning.
                //

                CreateScbStatus = Iosb.Status;

                //
                // We catch this exception in case we have to retry the
                // create on the NDS path.  This is horrable, as does the
                // exception structure in this code right now, but it's
                // legacy and now is not the time to change it.
                //

                try {

                    Iosb = CreateRemoteFile(
                               IrpContext,
                               &Drive );

                } except ( EXCEPTION_EXECUTE_HANDLER ) {

                    Iosb.Status = GetExceptionCode();
                }

                //
                // If this is a server whose name is the same as the tree
                // that it is a member of, and the create was marked as
                // non-nds and it failed, retry an nds create.
                //

                if ( ( !NT_SUCCESS( Iosb.Status) ) &&
                     ( !(IrpContext->Specific.Create.NdsCreate) ) &&
                     ( RtlEqualUnicodeString( &(Scb->pNpScb->ServerName),
                                              &(Scb->NdsTreeName),
                                              TRUE ) ) ) {

                    IrpContext->Specific.Create.NdsCreate = TRUE;
                    IrpContext->Specific.Create.NeedNdsData = TRUE;

                    Iosb = CreateRemoteFile(
                               IrpContext,
                               &Drive );

                    //
                    // If this fails, it will raise status before setting IOSB
                    // and we'll return the status from the original create,
                    // which is the more interesting one.
                    //

                }

                //
                //  If we successfully open the remote file, return the
                //  CreateScb status instead.
                //

                if ( NT_SUCCESS( Iosb.Status ) ) {
                    Iosb.Status = CreateScbStatus;
                }

            }
        }

        //
        // If we succeeded, we want to keep the code section
        // referenced because we have opened a handle.
        //

        if ( NT_SUCCESS( Iosb.Status ) ) {
            DereferenceCodeSection = FALSE;
        }

    try_exit: NOTHING;
    } finally {

        //
        // Track the Scb in the IrpContext, not in the local Scb
        // variable since we may have been routed to another server
        // in process.
        //

        if (( Scb != NULL ) && ( IrpContext->pNpScb != NULL )) {
            NwDereferenceScb( IrpContext->pNpScb );
        }

        if ( DefaultServer.Buffer != NULL ) {
            FREE_POOL( DefaultServer.Buffer );
        }

        if ( ( IrpContext->Specific.Create.fExCredentialCreate ) &&
             ( IrpContext->Specific.Create.pExCredentials ) &&
             ( !NT_SUCCESS( Iosb.Status ) ) ) {

            ExCreateDereferenceCredentials( 
                IrpContext,
                IrpContext->Specific.Create.pExCredentials
            );
        }

        DebugTrace(-1, Dbg, "NwCommonCreate -> %08lx\n", Iosb.Status);

        if ( DereferenceCodeSection ) {
            NwDereferenceUnlockableCodeSection ();
        }

    }

    //
    //  Map a timeout error to server not found, so that MPR will
    //  try to connect on the next network provider instead of giving up,
    //  which is wrong wrong wrong.
    //

    if ( Iosb.Status == STATUS_REMOTE_NOT_LISTENING ) {
        Iosb.Status = STATUS_BAD_NETWORK_PATH;
    }

    //
    // Map an unbound transport error to server not found, so that MPR
    // will try to connect on the next provider.
    //

    if ( Iosb.Status == STATUS_NETWORK_UNREACHABLE ) {
        Iosb.Status = STATUS_BAD_NETWORK_PATH;
    }

    return Iosb.Status;
}


NTSTATUS
ReadAttachEas(
    IN PIRP Irp,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING Password,
    OUT PULONG ShareType,
    OUT PDWORD CredentialExtension
    )

/*++

Routine Description:

    This routine processes the EAs provided when the caller attempts
    to attach to a remote server.

    Note: This routine does not create additional storage for the names.
    It is the callers responsibility to save them if required.

Arguments:

    Irp - Supplies all the information

    UserName - Returns the value of the User name EA

    Password - Returns the value of the password EA

    ShareType -  Returns the value of the share type EA

    CredentialExtension - Returns whether or not this create
        should use the provided credentials for an credential
        extended connection.  This is primarily for OleDs
        accessing the ds in multiple security contexts.

Return Value:

    NTSTATUS - Status of operation

--*/
{

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_FULL_EA_INFORMATION EaBuffer = Irp->AssociatedIrp.SystemBuffer;

    PAGED_CODE();

    RtlInitUnicodeString( UserName, NULL );
    RtlInitUnicodeString( Password, NULL );
    *ShareType = RESOURCETYPE_ANY;
    if ( CredentialExtension ) {
        *CredentialExtension = FALSE;
    }

    DebugTrace(+1, Dbg, "ReadAttachEas....\n", 0);

    if ( EaBuffer != NULL) {

        while (TRUE) {
            ULONG EaNameLength = EaBuffer->EaNameLength;

            if (strcmp(EaBuffer->EaName, EA_NAME_USERNAME) == 0) {

                UserName->Length = EaBuffer->EaValueLength;
                UserName->MaximumLength = EaBuffer->EaValueLength;
                UserName->Buffer = (PWSTR)(EaBuffer->EaName+EaNameLength+1);

            } else if (strcmp(EaBuffer->EaName, EA_NAME_PASSWORD) == 0) {

                Password->Length = EaBuffer->EaValueLength;
                Password->MaximumLength = EaBuffer->EaValueLength;
                Password->Buffer = (PWSTR)(EaBuffer->EaName+EaNameLength+1);

            } else if ((strcmp(EaBuffer->EaName, EA_NAME_TYPE) == 0) &&
                       (EaBuffer->EaValueLength >= sizeof(ULONG))) {

                *ShareType = *(ULONG UNALIGNED *)(EaBuffer->EaName+EaNameLength+1);

            } else if (strcmp(EaBuffer->EaName, EA_NAME_CREDENTIAL_EX) == 0)  {

                if ( CredentialExtension ) {
                    *CredentialExtension = TRUE;
                    DebugTrace(0, Dbg, "ReadAttachEas signals a credential extension.\n", 0 );
                }

            } else {
                DebugTrace(0, Dbg, "ReadAttachEas Unknown EA -> %s\n", EaBuffer->EaName);
            }

            if (EaBuffer->NextEntryOffset == 0) {
                break;
            } else {
                EaBuffer = (PFILE_FULL_EA_INFORMATION) ((PCHAR) EaBuffer+EaBuffer->NextEntryOffset);
            }
        }
    }

    DebugTrace(-1, Dbg, "ReadAttachEas -> %08lx\n", STATUS_SUCCESS);

    return STATUS_SUCCESS;

}


IO_STATUS_BLOCK
OpenRedirector(
    IN PIRP_CONTEXT IrpContext,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routines opens a handle to the redirector device.

Arguments:

    IrpContext - Supplies all the information

    DesiredAccess - The requested access to the redirector.

    ShareAccess - The requested share access to the redirector.

    FileObject - A pointer to the caller file object.

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/

{
    IO_STATUS_BLOCK iosb;

    PAGED_CODE();

    //
    //  Note that the object manager will only allow an administrator
    //  to open the redir itself.   This is good.
    //

    DebugTrace(+1, Dbg, "NwOpenRedirector\n", 0);

    NwAcquireExclusiveRcb( &NwRcb, TRUE );

    try {

        //
        //  Set the new share access
        //

        if (!NT_SUCCESS(iosb.Status = IoCheckShareAccess( DesiredAccess,
                                                       ShareAccess,
                                                       FileObject,
                                                       &NwRcb.ShareAccess,
                                                       TRUE ))) {

            DebugTrace(0, Dbg, "bad share access\n", 0);

            try_return( NOTHING );
        }

        NwSetFileObject( FileObject, NULL,  &NwRcb );
        ++NwRcb.OpenCount;

        //
        // Set the return status.
        //

        iosb.Status = STATUS_SUCCESS;
        iosb.Information = FILE_OPENED;

    try_exit: NOTHING;
    } finally {

        NwReleaseRcb( &NwRcb );
        DebugTrace(-1, Dbg, "NwOpenRedirector -> Iosb.Status = %08lx\n", iosb.Status);

    }

    //
    // Return to the caller.
    //

    return iosb;
}


IO_STATUS_BLOCK
CreateRemoteFile(
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING DriveName
    )
/*++

Routine Description:

    This routines opens a remote file or directory.

Arguments:

    IrpContext - Supplies all the information

    DriveName - The drive name.  One of three forms X:, LPTx, or NULL.

Return Value:

    IO_STATUS_BLOCK - Status of operation

--*/
{
    IO_STATUS_BLOCK Iosb;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    ULONG DesiredAccess;
    ULONG ShareAccess;
    PFILE_OBJECT FileObject;

    UNICODE_STRING FileName;
    P