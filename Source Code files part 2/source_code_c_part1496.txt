-----------------------------
// CCommandData::~CCommandData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::~CCommandData"

CCommandData::~CCommandData()
{
	DNASSERT( m_State == COMMAND_STATE_UNKNOWN );
	DNASSERT( m_dwDescriptor == NULL_DESCRIPTOR );
	DNASSERT( m_Type == COMMAND_TYPE_UNKNOWN );
	DNASSERT( m_pEndpoint == NULL );
	DNASSERT( m_pUserContext == NULL );
	DNASSERT( m_pOwningPool == NULL );
	DNASSERT( m_CommandListLinkage.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::Reset - reset this command
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::Reset"

void	CCommandData::Reset( void )
{
	m_State = COMMAND_STATE_UNKNOWN;
	m_dwDescriptor = NULL_DESCRIPTOR;
	m_Type = COMMAND_TYPE_UNKNOWN;
	m_pEndpoint = NULL;
	m_pUserContext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolAllocFunction - function called when item is created in pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolAllocFunction"

BOOL	CCommandData::PoolAllocFunction( void )
{
	BOOL	fReturn;

	
	fReturn = TRUE;
	
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolInitFunction - function called when item is created in pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolInitFunction"

BOOL	CCommandData::PoolInitFunction( void )
{
	DNASSERT( GetState() == COMMAND_STATE_UNKNOWN );
	DNASSERT( GetType() == COMMAND_TYPE_UNKNOWN );
	DNASSERT( GetEndpoint() == NULL );
	DNASSERT( GetUserContext() == NULL );

	m_dwDescriptor = m_dwNextDescriptor;
	m_dwNextDescriptor++;
	if ( m_dwNextDescriptor == NULL_DESCRIPTOR )
	{
		m_dwNextDescriptor++;
	}

	return	TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolReleaseFunction - function called when returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolReleaseFunction"

void	CCommandData::PoolReleaseFunction( void )
{
	SetState( COMMAND_STATE_UNKNOWN );
	SetType( COMMAND_TYPE_UNKNOWN );
	SetEndpoint( NULL );
	SetUserContext( NULL );
	m_dwDescriptor = NULL_DESCRIPTOR;

	DNASSERT( m_CommandListLinkage.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolDeallocFunction - function called when deleted from pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolDeallocFunction"

void	CCommandData::PoolDeallocFunction( void )
{
	DNDeleteCriticalSection( &m_Lock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::ReturnSelfToPool"

void	CCommandData::ReturnSelfToPool( void )
{
	DNASSERT( m_pOwningPool != NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\comendpoint.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   ComEndpoint.cpp
 *  Content:	DNSerial com port communications endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::CComEndpoint - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::CComEndpoint"

CComEndpoint::CComEndpoint():
	m_pOwningPool( NULL )
{
	m_Sig[0] = 'C';
	m_Sig[1] = 'O';
	m_Sig[2] = 'E';
	m_Sig[3] = 'P';
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::~CComEndpoint - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::~CComEndpoint"

CComEndpoint::~CComEndpoint()
{
	DNASSERT( m_pOwningPool == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::ReturnSelfToPool"

void	CComEndpoint::ReturnSelfToPool( void )
{
	if ( m_Flags.fCommandPending != FALSE )
	{
		CompletePendingCommand( PendingCommandResult() );
	}

	if ( m_Flags.fConnectIndicated != FALSE )
	{
		SignalDisconnect( GetDisconnectIndicationHandle() );
	}
	
	DNASSERT( m_Flags.fConnectIndicated == FALSE );

	SetUserEndpointContext( NULL );
	
	DNASSERT( m_pOwningPool != NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::PoolAllocFunction - function called when item is created in pool
//
// Entry:		Pointer to pool context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::PoolAllocFunction"

BOOL	CComEndpoint::PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pPoolContext )
{
	BOOL	fReturn;
	HRESULT	hTempResult;


	DNASSERT( pPoolContext != NULL );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );

	fReturn = TRUE;

	//
	// initialize base objet
	//
	hTempResult = CEndpoint::Initialize( pPoolContext->pSPData );
	if ( hTempResult != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to initialize base endpoint class!" );
		DisplayDNError( 0, hTempResult );
		fReturn = FALSE;
	}
	
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::PoolInitFunction - function called when item is created in pool
//
// Entry:		Pointer to pool context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::PoolInitFunction"

BOOL	CComEndpoint::PoolInitFunction( ENDPOINT_POOL_CONTEXT *pPoolContext )
{
	BOOL	fReturn;


	DNASSERT( pPoolContext != NULL );
	DNASSERT( m_pSPData == NULL );
	DNASSERT( GetState() == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( GetType() == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );

	//
	// initialize
	//
	fReturn = TRUE;
	
	m_pSPData = pPoolContext->pSPData;
	m_pSPData->ObjectAddRef();

	//
	// set reasonable defaults
	//
	m_ComPortData.SetBaudRate( CBR_57600 );
	m_ComPortData.SetStopBits( ONESTOPBIT );
	m_ComPortData.SetParity( NOPARITY );
	m_ComPortData.SetFlowControl( FLOW_RTSDTR );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::PoolReleaseFunction - function called when returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::PoolReleaseFunction"

void	CComEndpoint::PoolReleaseFunction( void )
{
	CSPData	*pSPData;


	//
	// deinitialize base object
	//
	DNASSERT( m_pSPData != NULL );
	pSPData = m_pSPData;
	m_pSPData = NULL;

	m_ComPortData.Reset();
	SetType( ENDPOINT_TYPE_UNKNOWN );
	SetState( ENDPOINT_STATE_UNINITIALIZED );

	DNASSERT( m_Flags.fConnectIndicated == FALSE );
	DNASSERT( m_Flags.fCommandPending == FALSE );
	DNASSERT( m_Flags.fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( m_pCommandHandle == NULL );
	DNASSERT( m_hActiveDialogHandle == NULL );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	
	pSPData->ObjectDecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::PoolDeallocFunction - function called when deleted from pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::PoolDeallocFunction"

void	CComEndpoint::PoolDeallocFunction( void )
{
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	
	CEndpoint::Deinitialize();
	DNASSERT( m_pSPData == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::Open - open communications with endpoint
//
// Entry:		Pointer to host address
//				Pointer to adapter address
//				Link direction
//				Endpoint type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::Open"

HRESULT	CComEndpoint::Open( IDirectPlay8Address *const pHostAddress,
							IDirectPlay8Address *const pAdapterAddress,
							const LINK_DIRECTION LinkDirection,
							const ENDPOINT_TYPE EndpointType )
{
	HRESULT		hr;


	DNASSERT( pAdapterAddress != NULL );

	DNASSERT( ( LinkDirection == LINK_DIRECTION_INCOMING ) ||
			  ( LinkDirection == LINK_DIRECTION_OUTGOING ) );
	DNASSERT( ( EndpointType == ENDPOINT_TYPE_CONNECT ) ||
			  ( EndpointType == ENDPOINT_TYPE_ENUM ) ||
			  ( EndpointType == ENDPOINT_TYPE_LISTEN ) ||
			  ( EndpointType == ENDPOINT_TYPE_CONNECT_ON_LISTEN ) );
	DNASSERT( ( ( pHostAddress != NULL ) && ( LinkDirection == LINK_DIRECTION_OUTGOING ) ) ||
			  ( ( pHostAddress == NULL ) && ( LinkDirection == LINK_DIRECTION_INCOMING ) ) );

	//
	// initialize
	//
	hr = DPN_OK;

	hr = m_ComPortData.ComPortDataFromDP8Addresses( pHostAddress, pAdapterAddress );

	SetType( EndpointType );

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CComEndpoint::Open" );
		DisplayDNError( 0, hr );
	}

	return	hr;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CComEndpoint::OpenOnListen - open communications with endpoint based on an
//		active listening endpoint
//
// Entry:		Pointer to listening endpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::OpenOnListen"

HRESULT	CComEndpoint::OpenOnListen( const CEndpoint *const pListenEndpoint )
{
	HRESULT			hr;
	const CComEndpoint	*pListenComEndpoint;

	
	DNASSERT( pListenEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pListenComEndpoint = static_cast<const CComEndpoint*>( pListenEndpoint );

	m_ComPortData.Copy( pListenComEndpoint->GetComPortData() );
	SetType( ENDPOINT_TYPE_CONNECT_ON_LISTEN );
	SetState( ENDPOINT_STATE_ATTEMPTING_CONNECT );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::Close - close down endpoint
//
// Entry:		Error code used for any active commands
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::Close"

void	CComEndpoint::Close( const HRESULT hActiveCommandResult )
{
	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%lx)", this, hActiveCommandResult);

	
	//
	// Set the command result so it can be returned when the endpoint reference
	// count is zero.
	//
	SetCommandResult( hActiveCommandResult );


	DPFX(DPFPREP, 6, "(0x%p) Leaving", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::GetLinkSpeed - get speed of link
//
// Entry:		Nothing
//
// Exit:		Link speed
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::GetLinkSpeed"

DWORD	CComEndpoint::GetLinkSpeed( void )
{
	return	GetBaudRate();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::EnumComplete - enum has completed
//
// Entry:		Command completion code
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::EnumComplete"

void	CComEndpoint::EnumComplete( const HRESULT hResult )
{
	Close( hResult );
	m_pSPData->CloseEndpointHandle( this );
	
	m_dwEnumSendIndex = 0;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::GetDeviceContext - get device context to initialize data port
//
// Entry:		Nothing
//
// Exit:		Device context
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::GetDeviceContext"

const void	*CComEndpoint::GetDeviceContext( void ) const
{
	return	&m_ComPortData;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::GetRemoteHostDP8Address - get address of remote host
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::GetRemoteHostDP8Address"

IDirectPlay8Address	*CComEndpoint::GetRemoteHostDP8Address( void ) const
{
	//
	// since the remote host is just the local COM port settings without the
	// adapter spec, hand off to the other function.
	//
	return	GetLocalAdapterDP8Address( ADDRESS_TYPE_REMOTE_HOST );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::GetLocalAdapterDP8Address - get address from local adapter
//
// Entry:		Adadpter address format
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::GetLocalAdapterDP8Address"

IDirectPlay8Address	*CComEndpoint::GetLocalAdapterDP8Address( const ADDRESS_TYPE AddressType ) const
{
	CComPort	*pComPort;


	DNASSERT( GetDataPort() != NULL );
	pComPort = static_cast<CComPort*>( GetDataPort() );
	return	pComPort->ComPortData()->DP8AddressFromComPortData( AddressType );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::ShowSettingsDialog - show dialog for settings
//
// Entry:		Pointer to thread pool
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::ShowSettingsDialog"

HRESULT	CComEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
{
	HRESULT	hr;


	DNASSERT( pThreadPool != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	AddRef();
	hr = pThreadPool->SpawnDialogThread( DisplayComPortSettingsDialog, this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to start comport dialog!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:	
	return	hr;

Failure:	
	DecRef();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComEndpoint::StopSettingsDialog - stop the settings dialog
//
// Entry:		Dialog handle
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComEndpoint::StopSettingsDialog"

void	CComEndpoint::StopSettingsDialog( const HWND hDialog )
{
	StopComPortSettingsDialog( hDialog );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\comportdata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   ComPortData.cpp
 *  Content:	Serial communications port data management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 *	04/25/2000	jtk		Derived from ComPort class
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

////
//// number of BITS in a serial BYTE
////
//#define	BITS_PER_BYTE	8
//
////
//// maximum size of baud rate string
////
//#define	MAX_BAUD_STRING_SIZE	7
//
////
//// default size of buffers when parsing
////
//#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000
//
////
//// device ID assigned to 'all adapters'
////
//#define	ALL_ADAPTERS_DEVICE_ID	0
//
////
//// NULL token
////
//#define	NULL_TOKEN	'\0'

//**********************************************************************
// Macro definitions
//**********************************************************************

#define DPNA_BAUD_RATE_9600_W				L"9600"
#define DPNA_BAUD_RATE_14400_W				L"14400"
#define DPNA_BAUD_RATE_19200_W				L"19200"
#define DPNA_BAUD_RATE_38400_W				L"38400"
#define DPNA_BAUD_RATE_56000_W				L"56000"
#define DPNA_BAUD_RATE_57600_W				L"57600"
#define DPNA_BAUD_RATE_115200_W				L"115200"

// values for baud rate
#define DPNA_BAUD_RATE_9600_A				"9600"
#define DPNA_BAUD_RATE_14400_A				"14400"
#define DPNA_BAUD_RATE_19200_A				"19200"
#define DPNA_BAUD_RATE_38400_A				"38400"
#define DPNA_BAUD_RATE_56000_A				"56000"
#define DPNA_BAUD_RATE_57600_A				"57600"
#define DPNA_BAUD_RATE_115200_A				"115200"

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// list of baud rates
//
STRING_BLOCK	g_BaudRate[] =
{
	{ CBR_9600,		DPNA_BAUD_RATE_9600_W,		( LENGTHOF( DPNA_BAUD_RATE_9600_W ) - 1 ),		DPNA_BAUD_RATE_9600_A,		( LENGTHOF( DPNA_BAUD_RATE_9600_A ) - 1 )	},
	{ CBR_14400,	DPNA_BAUD_RATE_14400_W, 	( LENGTHOF( DPNA_BAUD_RATE_14400_W ) - 1 ),		DPNA_BAUD_RATE_14400_A, 	( LENGTHOF( DPNA_BAUD_RATE_14400_A ) - 1 )	},
	{ CBR_19200,	DPNA_BAUD_RATE_19200_W, 	( LENGTHOF( DPNA_BAUD_RATE_19200_W ) - 1 ),		DPNA_BAUD_RATE_19200_A, 	( LENGTHOF( DPNA_BAUD_RATE_19200_A ) - 1 )	},
	{ CBR_38400,	DPNA_BAUD_RATE_38400_W, 	( LENGTHOF( DPNA_BAUD_RATE_38400_W ) - 1 ),		DPNA_BAUD_RATE_38400_A, 	( LENGTHOF( DPNA_BAUD_RATE_38400_A ) - 1 )	},
	{ CBR_56000,	DPNA_BAUD_RATE_56000_W,		( LENGTHOF( DPNA_BAUD_RATE_56000_W ) - 1 ),		DPNA_BAUD_RATE_56000_A,		( LENGTHOF( DPNA_BAUD_RATE_56000_A ) - 1 )	},
	{ CBR_57600,	DPNA_BAUD_RATE_57600_W,		( LENGTHOF( DPNA_BAUD_RATE_57600_W ) - 1 ),		DPNA_BAUD_RATE_57600_A,		( LENGTHOF( DPNA_BAUD_RATE_57600_A ) - 1 )	},
	{ CBR_115200,	DPNA_BAUD_RATE_115200_W,	( LENGTHOF( DPNA_BAUD_RATE_115200_W ) - 1 ),	DPNA_BAUD_RATE_115200_A,	( LENGTHOF( DPNA_BAUD_RATE_115200_A ) - 1 )	},
};
const DWORD	g_dwBaudRateCount = LENGTHOF( g_BaudRate );

//
// list of stop bit types
//
STRING_BLOCK	g_StopBits[] =
{
	{ ONESTOPBIT,	DPNA_STOP_BITS_ONE,			( LENGTHOF( DPNA_STOP_BITS_ONE ) - 1 ),			DPNA_STOP_BITS_ONE_A,		( LENGTHOF( DPNA_STOP_BITS_ONE_A ) - 1 )		},
	{ ONE5STOPBITS,	DPNA_STOP_BITS_ONE_FIVE,	( LENGTHOF( DPNA_STOP_BITS_ONE_FIVE ) - 1 ),	DPNA_STOP_BITS_ONE_FIVE_A,	( LENGTHOF( DPNA_STOP_BITS_ONE_FIVE_A ) - 1 )	},
	{ TWOSTOPBITS,	DPNA_STOP_BITS_TWO, 		( LENGTHOF( DPNA_STOP_BITS_TWO ) - 1 ),			DPNA_STOP_BITS_TWO_A, 		( LENGTHOF( DPNA_STOP_BITS_TWO_A ) - 1 )		}
};
const DWORD	g_dwStopBitsCount = LENGTHOF( g_StopBits );

//
// list of parity types
//
STRING_BLOCK	g_Parity[] =
{	
	{ EVENPARITY,	DPNA_PARITY_EVEN,	( LENGTHOF( DPNA_PARITY_EVEN ) - 1 ),	DPNA_PARITY_EVEN_A,		( LENGTHOF( DPNA_PARITY_EVEN_A ) - 1 )		},
	{ MARKPARITY,	DPNA_PARITY_MARK,	( LENGTHOF( DPNA_PARITY_MARK ) - 1 ),	DPNA_PARITY_MARK_A,		( LENGTHOF( DPNA_PARITY_MARK_A ) - 1 )		},
	{ NOPARITY, 	DPNA_PARITY_NONE,	( LENGTHOF( DPNA_PARITY_NONE ) - 1 ),	DPNA_PARITY_NONE_A,		( LENGTHOF( DPNA_PARITY_NONE_A ) - 1 )		},
	{ ODDPARITY,	DPNA_PARITY_ODD,	( LENGTHOF( DPNA_PARITY_ODD ) - 1 ),	DPNA_PARITY_ODD_A,		( LENGTHOF( DPNA_PARITY_ODD_A ) - 1 )		},
	{ SPACEPARITY,	DPNA_PARITY_SPACE,	( LENGTHOF( DPNA_PARITY_SPACE ) - 1 ),	DPNA_PARITY_SPACE_A,	( LENGTHOF( DPNA_PARITY_SPACE_A ) - 1 )		}
};
const DWORD	g_dwParityCount = LENGTHOF( g_Parity );

//
// list of flow control types
//
STRING_BLOCK	g_FlowControl[] =
{
	{ FLOW_NONE,	DPNA_FLOW_CONTROL_NONE,		( LENGTHOF( DPNA_FLOW_CONTROL_NONE ) - 1 ),		DPNA_FLOW_CONTROL_NONE_A,		( LENGTHOF( DPNA_FLOW_CONTROL_NONE_A ) - 1 )	},
	{ FLOW_XONXOFF,	DPNA_FLOW_CONTROL_XONXOFF,	( LENGTHOF( DPNA_FLOW_CONTROL_XONXOFF ) - 1 ),	DPNA_FLOW_CONTROL_XONXOFF_A,	( LENGTHOF( DPNA_FLOW_CONTROL_XONXOFF_A ) - 1 )	},
	{ FLOW_RTS,		DPNA_FLOW_CONTROL_RTS,		( LENGTHOF( DPNA_FLOW_CONTROL_RTS ) - 1 ),		DPNA_FLOW_CONTROL_RTS_A,		( LENGTHOF( DPNA_FLOW_CONTROL_RTS_A ) - 1 )		},
	{ FLOW_DTR,		DPNA_FLOW_CONTROL_DTR,		( LENGTHOF( DPNA_FLOW_CONTROL_DTR ) - 1 ),		DPNA_FLOW_CONTROL_DTR_A,		( LENGTHOF( DPNA_FLOW_CONTROL_DTR_A ) - 1 )		},
	{ FLOW_RTSDTR,	DPNA_FLOW_CONTROL_RTSDTR,	( LENGTHOF( DPNA_FLOW_CONTROL_RTSDTR ) - 1 ),	DPNA_FLOW_CONTROL_RTSDTR_A,		( LENGTHOF( DPNA_FLOW_CONTROL_RTSDTR_A ) - 1 )	}
};
const DWORD	g_dwFlowControlCount = LENGTHOF( g_FlowControl );

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::CComPortData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::CComPortData"

CComPortData::CComPortData():
	m_dwDeviceID( INVALID_DEVICE_ID ),
    m_BaudRate( CBR_57600 ),
    m_StopBits( ONESTOPBIT ),
    m_Parity( NOPARITY ),
    m_FlowControl( FLOW_NONE )
{
	//
	// verify that the DPlay8 address baud rate #defines match those in Windows
	//
	DBG_CASSERT( CBR_9600 == DPNA_BAUD_RATE_9600 );
	DBG_CASSERT( CBR_14400 == DPNA_BAUD_RATE_14400 );
	DBG_CASSERT( CBR_19200 == DPNA_BAUD_RATE_19200 );
	DBG_CASSERT( CBR_38400 == DPNA_BAUD_RATE_38400 );
	DBG_CASSERT( CBR_56000 == DPNA_BAUD_RATE_56000 );
	DBG_CASSERT( CBR_57600 == DPNA_BAUD_RATE_57600 );
	DBG_CASSERT( CBR_115200 == DPNA_BAUD_RATE_115200 );

    memset( m_ComPortName, 0x00, sizeof( m_ComPortName ));
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::~CComPortData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::~CComPortData"

CComPortData::~CComPortData()
{
    DNASSERT( m_dwDeviceID == INVALID_DEVICE_ID );
	DNASSERT( m_BaudRate == CBR_57600 );
    DNASSERT( m_StopBits == ONESTOPBIT );
    DNASSERT( m_Parity == NOPARITY );
    DNASSERT( m_FlowControl == FLOW_NONE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ComPortDataFromDP8Addresses - initialize ComPortData from a DirectPlay8 address
//
// Entry:		Pointer to host address (may be NULL)
//				Pointer to device address
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ComPortDataFromDP8Addresses"

HRESULT	CComPortData::ComPortDataFromDP8Addresses( IDirectPlay8Address *const pHostAddress,
												   IDirectPlay8Address *const pDeviceAddress )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	CParseClass	ParseClass;
	const PARSE_KEY	ParseKeyList[] =
	{
		{ DPNA_KEY_DEVICE, LENGTHOF( DPNA_KEY_DEVICE ) - 1, this, ParseDevice },
		{ DPNA_KEY_BAUD, LENGTHOF( DPNA_KEY_BAUD) - 1, this, ParseBaud },
		{ DPNA_KEY_STOPBITS, LENGTHOF( DPNA_KEY_STOPBITS ) - 1, this, ParseStopBits },
		{ DPNA_KEY_PARITY, LENGTHOF( DPNA_KEY_PARITY ) - 1, this, ParseParity },
		{ DPNA_KEY_FLOWCONTROL, LENGTHOF( DPNA_KEY_FLOWCONTROL ) - 1, this, ParseFlowControl }
	};


	DNASSERT( pDeviceAddress != NULL );

	//		
	// initialize
	//
	hr = DPN_OK;

	//
	// reset parsing flags and parse
	//
	uIndex = LENGTHOF( m_ComponentInitializationState );
	while ( uIndex > 0 )
	{
		uIndex--;
		m_ComponentInitializationState[ uIndex ] = SP_ADDRESS_COMPONENT_UNINITIALIZED;
	}
	
	hr = ParseClass.ParseDP8Address( pDeviceAddress,
									 &CLSID_DP8SP_SERIAL,
									 ParseKeyList,
									 LENGTHOF( ParseKeyList )
									 );
	//
	// There are two addresses to parse for a comport.  The device address will
	// be present for all commands, so do it first.  The host address will be
	// parsed if it's available.
	//
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed address parse!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	if ( pHostAddress != NULL )
	{
		hr = ParseClass.ParseDP8Address( pHostAddress,
										 &CLSID_DP8SP_SERIAL,
										 ParseKeyList,
										 LENGTHOF( ParseKeyList )
										 );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed parse of host address!" );
			DisplayDNError( 0, hr );
			goto Exit;
		}
	}

	//
	// check for all parameters being initialized, or fail if one of the
	// parameters failed to initialize.
	//
	DNASSERT( hr == DPN_OK );
	uIndex = COMPORT_PARSE_KEY_MAX;
	while ( uIndex > 0 )
	{
		uIndex--;
		switch ( m_ComponentInitializationState[ uIndex ] )
		{
			//
			// This component was initialized properly.  Continue checking
			// for other problems.
			//
			case SP_ADDRESS_COMPONENT_INITIALIZED:
			{
				break;
			}

			//
			// This component was not initialized, note that the address was
			// incomplete and that the user will need to be queried.  Keep
			// checking components for other problems.
			//
			case SP_ADDRESS_COMPONENT_UNINITIALIZED:
			{
				hr = DPNERR_INCOMPLETEADDRESS;
				break;
			}

			//
			// initialization of this component failed, fail the parse.
			//
			case SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED:
			{
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP,  8, "DataPortFromDNAddress: parse failure!" );
				goto Failure;

				break;
			}
		}
	}

	//
	// do we indicate an attempt at initialization?
	//
	DNASSERT( ( hr == DPN_OK ) || ( hr == DPNERR_INCOMPLETEADDRESS ) );

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CComPortData::ComPortDataFromDNAddress()" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::DP8AddressFromComPortData - convert a ComPortData to a DirectPlay8 address
//
// Entry:		Address type
//
// Exit:		Pointer to DirecctPlayAddress
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::DP8AddressFromComPortData"

IDirectPlay8Address	*CComPortData::DP8AddressFromComPortData( const ADDRESS_TYPE AddressType ) const
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	GUID		DeviceGuid;
	const WCHAR	*pComponentString;
	DWORD		dwComponentStringSize;
	IDirectPlay8Address	*pAddress;


	DNASSERT( ( AddressType == ADDRESS_TYPE_REMOTE_HOST ) ||
			  ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER ) ||
			  ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER_HOST_FORMAT ) );

	//
	// initialize
	//
	pAddress = NULL;

	uIndex = COMPORT_PARSE_KEY_MAX;
	while ( uIndex > 0 )
	{
		uIndex--;
		if ( m_ComponentInitializationState[ uIndex ] != SP_ADDRESS_COMPONENT_INITIALIZED )
		{
			DPFX(DPFPREP,  0, "Attempt made to extract partial ComPortData information!" );
			DNASSERT( FALSE );
			goto Failure;
		}
	}

	//
	// create output address
	//
	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address,
						   NULL,
						   CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Address,
						   reinterpret_cast<void**>( &pAddress ) );
	if ( hr != S_OK )
	{
		DNASSERT( pAddress == NULL );
		DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to create Address when converting data port to address!" );
		goto Failure;
	}


	//
	// set the SP guid
	//
	hr = IDirectPlay8Address_SetSP( pAddress, &CLSID_DP8SP_SERIAL );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to set service provider GUID!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// All serial settings are part of the local adapter.  Host settings return
	// just the SP type.
	//
	if ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER )
	{
		DeviceIDToGuid( &DeviceGuid, GetDeviceID(), &g_SerialSPEncryptionGuid );
		hr = IDirectPlay8Address_SetDevice( pAddress, &DeviceGuid );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to add device GUID!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
		
		//
		// set baud rate
		//
		DBG_CASSERT( sizeof( SP_BAUD_RATE ) == sizeof( DWORD ) );
		hr = IDirectPlay8Address_AddComponent( pAddress,
											   DPNA_KEY_BAUD,
											   &m_BaudRate,
											   sizeof( SP_BAUD_RATE ),
											   DPNA_DATATYPE_DWORD );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to add baud rate!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}


		//
		// set stop bits
		//
		if ( ValueToString( &pComponentString,			// pointer to value string
							&dwComponentStringSize,		// pointer to length of value string
							GetStopBits(),				// enum value
							g_StopBits,					// pointer to enum-string array
							g_dwStopBitsCount			// length of enum-string array
							) == FALSE )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to convert baud rate!" );
			DNASSERT( FALSE );
			goto Failure;
		}

		hr = IDirectPlay8Address_AddComponent( pAddress,
											   DPNA_KEY_STOPBITS,
											   pComponentString,
											   ( ( dwComponentStringSize + 1 ) * sizeof( WCHAR ) ),
											   DPNA_DATATYPE_STRING );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to add stop bits!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}


		//
		// set parity
		//
		if ( ValueToString( &pComponentString,			// pointer to value string
							&dwComponentStringSize,		// pointer to length of value string
							GetParity(),				// enum value
							g_Parity,					// pointer to enum-string array
							g_dwParityCount				// length of enum-string array
							) == FALSE )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to convert parity!" );
			DNASSERT( FALSE );
			goto Failure;
		}

		hr = IDirectPlay8Address_AddComponent( pAddress,
											   DPNA_KEY_PARITY,
											   pComponentString,
											   ( ( dwComponentStringSize + 1 ) * sizeof( WCHAR ) ),
											   DPNA_DATATYPE_STRING );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to add parity!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}


		//
		// set flow control
		//
		if ( ValueToString( &pComponentString,			// pointer to value string
							&dwComponentStringSize,		// pointer to length of value string
							GetFlowControl(),			// enum value
							g_FlowControl,				// pointer to enum-string array
							g_dwFlowControlCount		// length of enum-string array
							) == FALSE )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to convert flow control!" );
			DNASSERT( FALSE );
			goto Failure;
		}

		hr = IDirectPlay8Address_AddComponent( pAddress,
											   DPNA_KEY_FLOWCONTROL,
											   pComponentString,
											   ( ( dwComponentStringSize + 1 ) * sizeof( WCHAR ) ),
											   DPNA_DATATYPE_STRING );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "DP8AddressFromComPortData: Failed to add flow control!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}

Exit:
	return	pAddress;

Failure:
	if ( pAddress != NULL )
	{
		IDirectPlay8Address_Release( pAddress );
		pAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::SetDeviceID - set device ID
//
// Entry:		Device ID
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::SetDeviceID"

HRESULT	CComPortData::SetDeviceID( const DWORD dwDeviceID )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

	if ( ( dwDeviceID > MAX_DATA_PORTS ) ||
		 ( dwDeviceID == 0 ) )
	{
		if ( dwDeviceID != INVALID_DEVICE_ID )
		{
			hr = DPNERR_ADDRESSING;
		}
		else
		{
			m_dwDeviceID = INVALID_DEVICE_ID;
			DNASSERT( hr == DPN_OK );
		}

		goto Exit;
	}

	m_dwDeviceID = dwDeviceID;
	ClearComPortName();
	ComDeviceIDToString( ComPortName(), m_dwDeviceID );
	m_ComponentInitializationState[ COMPORT_PARSE_KEY_DEVICE ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::SetBaudRate - set baud rate
//
// Entry:		Baud rate
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::SetBaudRate"

HRESULT	CComPortData::SetBaudRate( const SP_BAUD_RATE BaudRate )
{
    HRESULT	hr;


	hr = DPN_OK;
    switch ( BaudRate )
    {
    	//
    	// valid rates
    	//
    	case CBR_110:
    	case CBR_300:
    	case CBR_600:
    	case CBR_1200:
    	case CBR_2400:
    	case CBR_4800:
    	case CBR_9600:
    	case CBR_14400:
    	case CBR_19200:
    	case CBR_38400:
    	case CBR_56000:
    	case CBR_57600:
    	case CBR_115200:
    	case CBR_128000:
    	case CBR_256000:
    	{
    		m_BaudRate = BaudRate;
			m_ComponentInitializationState[ COMPORT_PARSE_KEY_BAUDRATE ] = SP_ADDRESS_COMPONENT_INITIALIZED;
    		break;
    	}

    	//
    	// other
    	//
    	default:
    	{
    		hr = DPNERR_ADDRESSING;
    		DPFX(DPFPREP,  0, "Invalid baud rate (%d)!", BaudRate );
    		DNASSERT( FALSE );

    		break;
    	}
    }

    return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::SetStopBits - set stop bits
//
// Entry:		Stop bits
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::SetStopBits"

HRESULT	CComPortData::SetStopBits( const SP_STOP_BITS StopBits )
{
    HRESULT	hr;


	hr = DPN_OK;
    switch ( StopBits )
    {
    	//
    	// valid settings
    	//
    	case ONESTOPBIT:
    	case ONE5STOPBITS:
    	case TWOSTOPBITS:
    	{
    		m_StopBits = StopBits;
			m_ComponentInitializationState[ COMPORT_PARSE_KEY_STOPBITS ] = SP_ADDRESS_COMPONENT_INITIALIZED;
    		break;
    	}

    	//
    	// other
    	//
    	default:
    	{
    		hr = DPNERR_ADDRESSING;
    		DPFX(DPFPREP,  0, "Ivalid stop bit setting (0x%x)!", StopBits );
    		DNASSERT( FALSE );

    		break;
    	}
    }

    return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::SetParity - set parity
//
// Entry:		Parity
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::SetParity"

HRESULT	CComPortData::SetParity( const SP_PARITY_TYPE Parity )
{
    HRESULT	hr;


	hr = DPN_OK;
    switch ( Parity )
    {
    	//
    	// valid settings
    	//
    	case NOPARITY:
    	case EVENPARITY:
    	case ODDPARITY:
    	case MARKPARITY:
    	case SPACEPARITY:
    	{
    		m_Parity = Parity;
			m_ComponentInitializationState[ COMPORT_PARSE_KEY_PARITY ] = SP_ADDRESS_COMPONENT_INITIALIZED;
    		break;
    	}

    	//
    	// other
    	//
    	default:
    	{
    		hr = DPNERR_ADDRESSING;
    		DPFX(DPFPREP,  0, "Invalid parity (0x%x)!", Parity );
    		DNASSERT( FALSE );

    		break;
    	}
    }

    return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::SetFlowControl - set flow control
//
// Entry:		Flow control
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::SetFlowControl"

HRESULT	CComPortData::SetFlowControl( const SP_FLOW_CONTROL FlowControl )
{
    HRESULT	hr;


	hr = DPN_OK;
    switch ( FlowControl )
    {
    	//
    	// valid settings
    	//
    	case FLOW_NONE:
    	case FLOW_XONXOFF:
    	case FLOW_RTS:
    	case FLOW_DTR:
    	case FLOW_RTSDTR:
    	{
    		m_FlowControl = FlowControl;
			m_ComponentInitializationState[ COMPORT_PARSE_KEY_FLOWCONTROL ] = SP_ADDRESS_COMPONENT_INITIALIZED;
    		break;
    	}

    	//
    	// other
    	//
    	default:
    	{
    		hr = DPNERR_ADDRESSING;
    		DPFX(DPFPREP,  0, "Invalid flow control (0x%x)!", FlowControl );
    		DNASSERT( FALSE );

    		break;
    	}
    }

    return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::IsEqual - is this comport data block equal to another?
//
// Entry:		Pointer to other data block
//
// Exit:		Boolean indicating equality
//				TRUE = is equal
//				FALSE = is not equal
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::IsEqual"

BOOL	CComPortData::IsEqual( const CComPortData *const pOtherPort )
{
	BOOL	fReturn;


	fReturn = TRUE;

	if ( ( GetDeviceID() != pOtherPort->GetDeviceID() ) ||
		 ( GetBaudRate() != pOtherPort->GetBaudRate() ) ||
		 ( GetStopBits() != pOtherPort->GetStopBits() ) ||
		 ( GetParity() != pOtherPort->GetParity() ) ||
		 ( GetFlowControl() != pOtherPort->GetFlowControl() ) )
	{
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::Copy - copy from another data block
//
// Entry:		Pointer to other data block
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::Copy"

void	CComPortData::Copy( const CComPortData *const pOtherPort )
{
	HRESULT	hr;


	DNASSERT( pOtherPort != NULL );

// 	DBG_CASSERT( sizeof( m_ComPortName ) == sizeof( pOtherPort->m_ComPortName ) );
//	memcpy( m_ComPortName, pOtherPort->m_ComPortName, sizeof( m_ComPortName ) );
	
	hr = SetDeviceID( pOtherPort->GetDeviceID() );
	DNASSERT( hr == DPN_OK );

	hr = SetBaudRate( pOtherPort->GetBaudRate() );
	DNASSERT( hr == DPN_OK );
	
	hr = SetStopBits( pOtherPort->GetStopBits() );
	DNASSERT( hr == DPN_OK );
	
	hr = SetParity( pOtherPort->GetParity() );
	DNASSERT( hr == DPN_OK );
	
	hr = SetFlowControl( pOtherPort->GetFlowControl() );
	DNASSERT( hr == DPN_OK );

	//
	// no need to copy comport name because it was set with the device ID
	//
//	DBG_CASSERT( sizeof( m_ComPortName ) == sizeof( pOtherPort->m_ComPortName ) );
//	memcpy( m_ComPortName, pOtherPort->m_ComPortName, sizeof( m_ComPortName ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ParseDevice - get comport device from string
//
// Entry:		Pointer to address component
//				Size of address component
//				Component type
//				Pointer to context (this obejct)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ParseDevice"

HRESULT	CComPortData::ParseDevice( const void *const pAddressComponent,
								   const DWORD dwComponentSize,
								   const DWORD dwComponentType,
								   void *const pContext )
{
	HRESULT		hr;
	CComPortData	*pThisComPortData;
	const GUID	*pDeviceGuid;


	DNASSERT( pAddressComponent != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThisComPortData = static_cast<CComPortData*>( pContext );

	//
	// is this a COM port, and is the name small enough?
	//
	if ( dwComponentSize != sizeof( *pDeviceGuid ) )
	{
		DNASSERT( FALSE );
		hr = DPNERR_ADDRESSING;
		goto Exit;
	}

	pDeviceGuid = reinterpret_cast<const GUID*>( pAddressComponent );

	hr = pThisComPortData->SetDeviceID( GuidToDeviceID( pDeviceGuid, &g_SerialSPEncryptionGuid ) );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  8, "ParseDevice: couldn't set device ID." );
		DisplayDNError( 8, hr );
		goto Exit;
	}

	DNASSERT( hr == DPN_OK );
	pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_DEVICE ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	//
	// note initialization failures
	//
	if ( hr != DPN_OK )
	{
		pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_DEVICE ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ParseBaud - get baud rate from string
//
// Entry:		Pointer to address component
//				Size of component
//				Component type
//				Pointer to context (this object)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ParseBaud"

HRESULT CComPortData::ParseBaud( const void *const pAddressComponent,
								 const DWORD dwComponentSize,
								 const DWORD dwComponentType,
								 void *const pContext )
{
	HRESULT		hr;
	CComPortData	*pThisComPortData;
	const SP_BAUD_RATE	*pBaudRate;


	DNASSERT( pAddressComponent != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThisComPortData = static_cast<CComPortData*>( pContext );
	DNASSERT( sizeof( *pBaudRate ) == dwComponentSize );
	pBaudRate = static_cast<const SP_BAUD_RATE*>( pAddressComponent );

	hr = pThisComPortData->SetBaudRate( *pBaudRate );
	if ( hr != DPN_OK )
	{
	    hr = DPNERR_ADDRESSING;
	    pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_BAUDRATE ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;
	    goto Exit;
	}

	pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_BAUDRATE ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ParseStopBits - get stop bits from string
//
// Entry:		Pointer to address component
//				Component size
//				Component type
//				Pointer to context (this object)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ParseStopBits"

HRESULT CComPortData::ParseStopBits( const void *const pAddressComponent,
									 const DWORD dwComponentSize,
									 const DWORD dwComponentType,
									 void *const pContext )
{
	HRESULT		hr;
	CComPortData	*pThisComPortData;


	DNASSERT( pAddressComponent != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThisComPortData = static_cast<CComPortData*>( pContext );

	//
	// convert string to value
	//
	if ( StringToValue( static_cast<const WCHAR*>( pAddressComponent ),		// pointer to string
						( ( dwComponentSize / sizeof( WCHAR ) ) - 1 ),		// length of string
						&pThisComPortData->m_StopBits,						// pointer to destination
						g_StopBits,											// pointer to string/enum pairs
						g_dwStopBitsCount									// number of string/enum pairs
						) == FALSE )
	{
		hr = DPNERR_ADDRESSING;
		pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_STOPBITS ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;
		goto Exit;
	}

	pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_STOPBITS ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ParseParity - get parity from string
//
// Entry:		Pointer to address component
//				Component size
//				Component type
//				Pointer to context (this object)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ParseParity"

HRESULT CComPortData::ParseParity( const void *const pAddressComponent,
								   const DWORD dwComponentSize,
								   const DWORD dwComponentType,
								   void *const pContext )
{
	HRESULT		hr;
	CComPortData	*pThisComPortData;


	DNASSERT( pAddressComponent != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThisComPortData = static_cast<CComPortData*>( pContext );

	//
	// convert string to value
	//
	if ( StringToValue( static_cast<const WCHAR*>( pAddressComponent ),		// pointer to string
						( ( dwComponentSize / sizeof( WCHAR ) ) - 1 ),		// length of string
						&pThisComPortData->m_Parity,						// pointer to destination
						g_Parity,											// pointer to string/enum pairs
						g_dwParityCount										// number of string/enum pairs
						) == FALSE )
	{
		hr = DPNERR_ADDRESSING;
		pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_PARITY ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;
		goto Exit;
	}

	pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_PARITY ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CComPortData::ParseFlowControl - get flow control from string
//
// Entry:		Pointer to address component
//				Component size
//				Component type
//				Pointer to context (this object)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CComPortData::ParseFlowControl"

HRESULT CComPortData::ParseFlowControl( const void *const pAddressComponent,
										const DWORD dwComponentSize,
										const DWORD dwComponentType,
										void *const pContext )
{
	HRESULT		hr;
	CComPortData	*pThisComPortData;


	DNASSERT( pAddressComponent != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThisComPortData = static_cast<CComPortData*>( pContext );

	//
	// convert string to value
	//
	DBG_CASSERT( sizeof( pThisComPortData->m_FlowControl ) == sizeof( VALUE_ENUM_TYPE ) );
	if ( StringToValue( static_cast<const WCHAR*>( pAddressComponent ),		// pointer to string
						( ( dwComponentSize / sizeof( WCHAR ) ) - 1 ),		// length of string
						reinterpret_cast<VALUE_ENUM_TYPE*>( &pThisComPortData->m_FlowControl ),	// pointer to destination
						g_FlowControl,										// pointer to string/enum pairs
						g_dwFlowControlCount								// number of string/enum pairs
						) == FALSE )
	{
		hr = DPNERR_ADDRESSING;
		pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_FLOWCONTROL ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;
		goto Exit;
	}

	pThisComPortData->m_ComponentInitializationState[ COMPORT_PARSE_KEY_FLOWCONTROL ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\comport.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ComPort.h
 *  Content:	Serial communications port management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 ***************************************************************************/

#ifndef __COM_PORT_H__
#define __COM_PORT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CComPort : public CDataPort
{
	public:
		CComPort();
		~CComPort();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CComPort::SetOwningPool"
		void	SetOwningPool( CLockedContextFixedPool< CComPort, DATA_PORT_POOL_CONTEXT* > *pOwningPool )
		{
			DEBUG_ONLY( DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) ) );
			m_pOwningPool = pOwningPool;
		}
		void	ReturnSelfToPool( void );

		HRESULT	EnumAdapters( SPENUMADAPTERSDATA *const pEnumAdaptersData ) const;

		HRESULT	BindToNetwork( const DWORD dwDeviceID, const void *const pDeviceContext );
		void	UnbindFromNetwork( void );
		HRESULT	BindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType );
		void	UnbindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType );

		//
		// port settings
		//
		DWORD	GetDeviceID( void ) const { return m_ComPortData.GetDeviceID(); }
		HRESULT	SetDeviceID( const DWORD dwDeviceID )
		{
			DNASSERT( ( GetDeviceID() == INVALID_DEVICE_ID ) ||
					  ( dwDeviceID == INVALID_DEVICE_ID ) );

			return m_ComPortData.SetDeviceID( dwDeviceID );
		}
		
		const CComPortData	*ComPortData( void ) const { return &m_ComPortData; }
		const SP_BAUD_RATE	GetBaudRate( void ) const { return m_ComPortData.GetBaudRate(); }
		HRESULT	SetBaudRate( const SP_BAUD_RATE BaudRate ) { return m_ComPortData.SetBaudRate( BaudRate ); }

		const SP_STOP_BITS	GetStopBits( void ) const { return m_ComPortData.GetStopBits(); }
		HRESULT	SetStopBits( const SP_STOP_BITS StopBits ) { return m_ComPortData.SetStopBits( StopBits ); }

		const SP_PARITY_TYPE	GetParity( void ) const  { return m_ComPortData.GetParity(); }
		HRESULT	SetParity( const SP_PARITY_TYPE Parity ) { return m_ComPortData.SetParity( Parity ); }

		const SP_FLOW_CONTROL	GetFlowControl( void ) const { return m_ComPortData.GetFlowControl(); }
		HRESULT	SetFlowControl( const SP_FLOW_CONTROL FlowControl ) { return m_ComPortData.SetFlowControl( FlowControl ); }

		//
		// pool functions
		//
		BOOL	PoolAllocFunction( DATA_PORT_POOL_CONTEXT *pContext );
		BOOL	PoolInitFunction( DATA_PORT_POOL_CONTEXT *pContext );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );

	protected:

	private:
		CLockedContextFixedPool< CComPort, DATA_PORT_POOL_CONTEXT* >	*m_pOwningPool;
		CComPortData	m_ComPortData;
		
		HRESULT	SetPortState( void );

		// prevent unwarranted copies
		CComPort( const CComPort & );
		CComPort& operator=( const CComPort & );
};

#endif	// __COM_PORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\comportdata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ComPortData.h
 *  Content:	Serial communications port data management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/1998	jtk		Created
 *	04/25/2000	jtk		Derived from ComPort class
 ***************************************************************************/

#ifndef __COM_PORT_DATA_H__
#define __COM_PORT_DATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// maximum length of comport string
//
#define	MAX_COMPORT_LENGTH	10

//
// enumerated values for noting which components have been initialized
//
typedef enum	_COMPORT_PARSE_KEY_INDEX
{
	COMPORT_PARSE_KEY_DEVICE = 0,
	COMPORT_PARSE_KEY_BAUDRATE,
	COMPORT_PARSE_KEY_STOPBITS,
	COMPORT_PARSE_KEY_PARITY,
	COMPORT_PARSE_KEY_FLOWCONTROL,

	// this must be the last item
	COMPORT_PARSE_KEY_MAX
} COMPORT_PARSE_KEY_INDEX;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// string blocks for parsing com port parameters
//
typedef	enum	_ADDRESS_TYPE	ADDRESS_TYPE;
typedef	struct	_STRING_BLOCK	STRING_BLOCK;

extern STRING_BLOCK			g_BaudRate[];
extern const DWORD			g_dwBaudRateCount;
extern STRING_BLOCK			g_StopBits[];
extern const DWORD			g_dwStopBitsCount;
extern STRING_BLOCK			g_Parity[];
extern const DWORD			g_dwParityCount;
extern STRING_BLOCK			g_FlowControl[];
extern const DWORD			g_dwFlowControlCount;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CComPortData
{
	public:
		CComPortData();
		~CComPortData();

		HRESULT	CComPortData::ComPortDataFromDP8Addresses( IDirectPlay8Address *const pHostAddress,
														   IDirectPlay8Address *const pDeviceAddress );
		IDirectPlay8Address	*CComPortData::DP8AddressFromComPortData( const ADDRESS_TYPE AddressType ) const;
		
		DWORD	GetDeviceID( void ) const { return m_dwDeviceID; }
		HRESULT	SetDeviceID( const DWORD dwDeviceID );

		SP_BAUD_RATE	GetBaudRate( void ) const { return m_BaudRate; }
		HRESULT	SetBaudRate( const SP_BAUD_RATE BaudRate );

		SP_STOP_BITS	GetStopBits( void ) const { return m_StopBits; }
		HRESULT	SetStopBits( const SP_STOP_BITS StopBits );

		SP_PARITY_TYPE	GetParity( void ) const  { return m_Parity; }
		HRESULT	SetParity( const SP_PARITY_TYPE Parity );

		SP_FLOW_CONTROL	GetFlowControl( void ) const { return m_FlowControl; }
		HRESULT	SetFlowControl( const SP_FLOW_CONTROL FlowControl );

		void	ClearComPortName( void ) { memset( &m_ComPortName, 0x00, sizeof( m_ComPortName ) ); }
		TCHAR	*ComPortName( void ) { return m_ComPortName; }
		
		BOOL	IsEqual( const CComPortData *const pOtherData );
		void	Copy( const CComPortData *const pOtherData );

		void	Reset( void )
		{
			SetDeviceID( INVALID_DEVICE_ID );
			SetBaudRate( CBR_57600 );
			SetStopBits( ONESTOPBIT );
			SetParity( NOPARITY );
			SetFlowControl( FLOW_NONE );
			memset( &m_ComponentInitializationState, 0x00, sizeof( m_ComponentInitializationState ) );
		}

	protected:

	private:
		DWORD	m_dwDeviceID;

		//
		// com port information
		//
		TCHAR	m_ComPortName[ MAX_COMPORT_LENGTH ];	// name of com port

		//
		// communications parameters
		//
		SP_BAUD_RATE	    m_BaudRate;			// baud rate
		SP_STOP_BITS	    m_StopBits;			// stop bits
		SP_PARITY_TYPE	    m_Parity;			// parity
		SP_FLOW_CONTROL	    m_FlowControl;		// flow control

		//
		// values indicating which components have been initialized
		//
		SP_ADDRESS_COMPONENT_STATE	m_ComponentInitializationState[ COMPORT_PARSE_KEY_MAX ];
		
		static HRESULT	ParseDevice( const void *const pAddressComponent,
									 const DWORD dwComponentSize,
									 const DWORD dwComponentType,
									 void *const pContext );
		
		static HRESULT	ParseBaud( const void *const pAddressComponent,
								   const DWORD dwComponentSize,
								   const DWORD dwComponentType,
								   void *const pContext );
		
		static HRESULT	ParseStopBits( const void *const pAddressComponent,
									   const DWORD dwComponentSize,
									   const DWORD dwComponentType,
									   void *const pContext );
		
		static HRESULT	ParseParity( const void *const pAddressComponent,
									 const DWORD dwComponentSize,
									 const DWORD dwComponentType,
									 void *const pContext );
		
		static HRESULT	ParseFlowControl( const void *const pAddressComponent,
										  const DWORD dwComponentSize,
										  const DWORD dwComponentType,
										  void *const pContext );

		// prevent unwarranted copies
		CComPortData( const CComPortData & );
		CComPortData& operator=( const CComPortData & );
};

#endif	// __COM_PORT_DATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\comportui.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ComPortUI.h
 *  Content:	Serial service provider comport UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/25/99	jtk		Created
 ***************************************************************************/

#ifndef __COM_PORT_UI_H__
#define __COM_PORT_UI_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CComEndpoint;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
//HRESULT	DisplayComPortSettingsDialog( const DATA_PORT_DIALOG_THREAD_PARAM *const pDialogData, HWND *const phDialog );
//HRESULT	DisplayComPortSettingsDialog( CComEndpoint *const pComEndpoint );
void	DisplayComPortSettingsDialog( void *const pContext );
void	StopComPortSettingsDialog( const HWND hDlg );

#endif	// __COM_PORT_UI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\comportui.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ComPortUI.cpp
 *  Content:	Serial service provider UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/24/99	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// default size of temp strings used to add stuff to dialog
//
#define	DEFAULT_DIALOG_STRING_SIZE	100

#define	DEFAULT_DEVICE_SELECTION_INDEX			0
#define	DEFAULT_BAUD_RATE_SELECTION_INDEX		11
#define	DEFAULT_STOP_BITS_SELECTION_INDEX		0
#define	DEFAULT_PARITY_SELECTION_INDEX			0
#define	DEFAULT_FLOW_CONTROL_SELECTION_INDEX	0

//
// expected return from comport dialog
//
static const INT_PTR	g_iExpectedComPortDialogReturn = 0x12345678;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
static INT_PTR CALLBACK	SettingsDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
static HRESULT	SetDialogDevice( const HWND hDlg, const CComEndpoint *const pComEndpoint );
static HRESULT	SetDialogBaudRate( const HWND hDlg, const CComEndpoint *const pComEndpoint );
static HRESULT	SetDialogStopBits( const HWND hDlg, const CComEndpoint *const pComEndpoint );
static HRESULT	SetDialogParity( const HWND hDlg, const CComEndpoint *const pComEndpoint );
static HRESULT	SetDialogFlowControl( const HWND hDlg, const CComEndpoint *const pComEndpoint );
static HRESULT	GetDialogData( const HWND hDlg, CComEndpoint *const pComEndpoint );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DisplayComPortDialog - dialog for comport settings
//
// Entry:		Pointer to CComEndpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayComPortSettingsDialog"

void	DisplayComPortSettingsDialog( void *const pContext )
{
	INT_PTR			iDlgReturn;
	CComEndpoint	*pComEndpoint;


	DNASSERT( pContext != NULL );

	//	
	// intialize
	//
	pComEndpoint = static_cast<CComEndpoint*>( pContext );

	DBG_CASSERT( sizeof( pComEndpoint ) == sizeof( LPARAM ) );
	SetLastError( ERROR_SUCCESS );
	iDlgReturn = DialogBoxParam( g_hDLLInstance,							// handle of module for resources
								 MAKEINTRESOURCE( IDD_SERIAL_SETTINGS ),	// resource for dialog
								 NULL,										// parent (none)
								 SettingsDialogProc,						// dialog message proc
								 reinterpret_cast<LPARAM>( pComEndpoint )	// startup parameter
								 );
	if ( iDlgReturn != g_iExpectedComPortDialogReturn )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to start comport settings dialog!" );
		DisplayErrorCode( 0, dwError );
	
		pComEndpoint->SettingsDialogComplete( DPNERR_OUTOFMEMORY );
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// StopComPortSettingsDialog - stop dialog dialog for serial settings
//
// Entry:		Handle of dialog
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "StopComPortSettingsDialog"

void	StopComPortSettingsDialog( const HWND hDlg )
{
	DNASSERT( hDlg != NULL );
	if ( PostMessage( hDlg, WM_COMMAND, MAKEWPARAM( IDCANCEL, NULL ), NULL ) == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to stop dialog!" );
		DisplayErrorCode( 0, dwError );
		DNASSERT( FALSE );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SettingsDialogProc - dialog proc serial settings
//
// Entry:		Window handle
//				Message
//				Message LPARAM
//				Message WPARAM
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SettingsDialogProc"

static	INT_PTR CALLBACK	SettingsDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	HRESULT			hr;
	CComEndpoint	*pComEndpoint;


	//
	// initialize
	//
	hr = DPN_OK;
	pComEndpoint = NULL;

	//
	// note the active comport pointer
	//
	DBG_CASSERT( sizeof( pComEndpoint ) == sizeof( ULONG_PTR ) );
	pComEndpoint = reinterpret_cast<CComEndpoint*>( GetWindowLongPtr( hDlg, GWLP_USERDATA ) );

	switch ( uMsg )
	{
		// initialize dialog
		case WM_INITDIALOG:
		{
			//
			// since this is the first dialog message, the default code to set
			// pComEndpoint didn't get valid data so we need to update the pointer
			//
			DBG_CASSERT( sizeof( pComEndpoint ) == sizeof( lParam ) );
			pComEndpoint = reinterpret_cast<CComEndpoint*>( lParam );
			pComEndpoint->SetActiveDialogHandle( hDlg );

			//
			// SetWindowLong() returns NULL in case of error.  It's possible that
			// the old value from SetWindowLong() was really NULL in which case it's not
			// an error.  To be safe, clear any residual error code before calling
			// SetWindowLong().
			//
			SetLastError( 0 );
			if ( SetWindowLongPtr( hDlg, GWLP_USERDATA, lParam ) == NULL )
			{
				DWORD	dwError;


				dwError = GetLastError();
				if ( dwError != ERROR_SUCCESS )
				{
					DPFX(DPFPREP,  0, "Problem setting user data for window!" );
					DisplayErrorCode( 0, dwError );
					hr = DPNERR_GENERIC;
					goto Failure;
				}
			}

			//
			// set dialog parameters
			//
			hr = SetDialogDevice( hDlg, pComEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting device in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			hr = SetDialogBaudRate( hDlg, pComEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting baud rate in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			hr = SetDialogStopBits( hDlg, pComEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting stop bits in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			hr = SetDialogParity( hDlg, pComEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting parity in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			hr = SetDialogFlowControl( hDlg, pComEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting flow control in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			return	TRUE;

			break;
		}

		// a control did something
		case WM_COMMAND:
		{
			// what was the control?
			switch ( LOWORD( wParam ) )
			{
				case IDOK:
				{
					hr = GetDialogData( hDlg, pComEndpoint );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Problem getting UI data!" );
						DisplayDNError( 0, hr );
						goto Failure;
					}

					// pass any error code on to 'DialogComplete'
					pComEndpoint->SettingsDialogComplete( hr );
					EndDialog( hDlg, g_iExpectedComPortDialogReturn );

					break;
				}

				case IDCANCEL:
				{
					pComEndpoint->SettingsDialogComplete( DPNERR_USERCANCEL );
					EndDialog( hDlg, g_iExpectedComPortDialogReturn );

					break;
				}

				default:
				{
					break;
				}
			}

			break;
		}

		// window is closing
		case WM_CLOSE:
		{
			break;
		}
	}

Exit:
	return	FALSE;

Failure:
	DNASSERT( pComEndpoint != NULL );
	DNASSERT( hr != DPN_OK );
	pComEndpoint->SettingsDialogComplete( hr );
	EndDialog( hDlg, g_iExpectedComPortDialogReturn );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetDialogDevice - set serial device field
//
// Entry:		Window handle
//				Pointer to ComEndpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetDialogDevice"

static	HRESULT	SetDialogDevice( const HWND hDlg, const CComEndpoint *const pComEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	BOOL		fPortAvailable[ MAX_DATA_PORTS ];
	DWORD		dwPortCount;
	TCHAR		TempBuffer[ DEFAULT_DIALOG_STRING_SIZE ];
	BOOL		fSelectionSet;
	HWND		hSerialDeviceComboBox;


	//
	// initialize
	//
	hr = DPN_OK;
	fSelectionSet = FALSE;
	hSerialDeviceComboBox = GetDlgItem( hDlg, IDC_COMBO_SERIAL_DEVICE );
	if ( hSerialDeviceComboBox == NULL )
	{
		DWORD	dwError;


		hr = DPNERR_GENERIC;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem getting handle of serial device combo box!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

	//
	// get list of available com ports
	//
	hr = GenerateAvailableComPortList( fPortAvailable, ( LENGTHOF( fPortAvailable ) - 1 ), &dwPortCount );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem generating vaild port list!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// add all strings to dialog
	//
	uIndex = LENGTHOF( fPortAvailable );
	while ( uIndex > 0 )
	{
		LRESULT	lSendReturn;


		uIndex--;

		//
		// only output all adapters on incoming settings
		//
		if ( fPortAvailable[ uIndex ] != FALSE )
		{
			DNASSERT( uIndex != 0 );	// ALL_ADAPTERS is not valid!
			ComDeviceIDToString( TempBuffer, uIndex );

			DBG_CASSERT( sizeof( &TempBuffer[ 0 ] ) == sizeof( LPARAM ) );
			lSendReturn = SendMessage( hSerialDeviceComboBox, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>( TempBuffer ) );
			switch ( lSendReturn )
			{
				case CB_ERR:
				{
					hr = DPNERR_GENERIC;
					DPFX(DPFPREP,  0, "Problem adding serial device to combo box!" );
					goto Failure;

					break;
				}

				case CB_ERRSPACE:
				{
					hr = DPNERR_OUTOFMEMORY;
					DPFX(DPFPREP,  0, "Out of memory when ading serial device to combo box!" );
					goto Failure;


					break;
				}

				//
				// we added the string OK, set the associated device id and check
				// to see if this is the current value to set selection
				//
				default:
				{	
					LRESULT	lTempReturn;


					lTempReturn = SendMessage ( hSerialDeviceComboBox, CB_SETITEMDATA, lSendReturn, uIndex );
					if ( lTempReturn == CB_ERR )
					{
						DWORD	dwError;


						hr = DPNERR_OUTOFMEMORY;
						dwError = GetLastError();
						DPFX(DPFPREP,  0, "Problem setting device info!" );
						DisplayErrorCode( 0, dwError );
						goto Failure;
					}

					if ( pComEndpoint->GetDeviceID() == uIndex )
					{
						lTempReturn = SendMessage( hSerialDeviceComboBox, CB_SETCURSEL, lSendReturn, 0 );
						switch ( lTempReturn )
						{
							case CB_ERR:
							{
								DWORD	dwError;


								hr = DPNERR_GENERIC;
								dwError = GetLastError();
								DPFX(DPFPREP,  0, "Problem setting default serial device selection!" );
								DisplayErrorCode( 0, dwError );
								DNASSERT( FALSE );
								goto Failure;

								break;
							}

							default:
							{
								fSelectionSet = TRUE;
								break;
							}
						}
					}

					break;
				}
			}
		}
	}

	//
	// was a selection set?  If not, set default
	//
	if ( fSelectionSet == FALSE )
	{
		LRESULT	lSendReturn;


		DPFX(DPFPREP,  8, "Serial device not set, using default!" );

		lSendReturn = SendMessage( hSerialDeviceComboBox, CB_SETCURSEL, DEFAULT_DEVICE_SELECTION_INDEX, 0 );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Cannot set default serial device selection!" );
				DisplayErrorCode( 0, GetLastError() );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}

			default:
			{
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetDialogBaudRate - set serial baud rate fields
//
// Entry:		Window handle
//				Pointer to com port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetDialogBaudRate"

static	HRESULT	SetDialogBaudRate( const HWND hDlg, const CComEndpoint *const pComEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	BOOL		fSelectionSet;
	HWND		hBaudRateComboBox;


	//
	// initialize
	//
	hr = DPN_OK;
	uIndex = g_dwBaudRateCount;
	fSelectionSet = FALSE;
	hBaudRateComboBox = GetDlgItem( hDlg, IDC_COMBO_SERIAL_BAUDRATE );
	if ( hBaudRateComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of serial baud rate combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	//
	// add all strings to dialog
	//
	while ( uIndex > 0 )
	{
		LRESULT	lSendReturn;


		uIndex--;

		DBG_CASSERT( sizeof( g_BaudRate[ uIndex ].pASCIIKey ) == sizeof( LPARAM ) );
		lSendReturn = SendMessage( hBaudRateComboBox, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>( g_BaudRate[ uIndex ].szLocalizedKey ) );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem adding baud rate to combo box!" );
				goto Failure;

				break;
			}

			case CB_ERRSPACE:
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "Out of memory adding baud rate to combo box!" );
				goto Failure;

				break;
			}

			default:
			{
				LRESULT	lTempReturn;


				//
				// we added the string OK, attemt to set the item data and
				// check to see if this is the current value
				//
				lTempReturn = SendMessage( hBaudRateComboBox, CB_SETITEMDATA, lSendReturn, g_BaudRate[ uIndex ].dwEnumValue );
				if ( lTempReturn == CB_ERR )
				{
					hr = DPNERR_OUTOFMEMORY;
					DPFX(DPFPREP,  0, "Failed to set baud rate item data!" );
					goto Failure;
				}

				if ( pComEndpoint->GetBaudRate() == g_BaudRate[ uIndex ].dwEnumValue )
				{
					// set current selection to this item
					lTempReturn = SendMessage( hBaudRateComboBox, CB_SETCURSEL, lSendReturn, 0 );
					switch ( lTempReturn )
					{
						case CB_ERR:
						{
							hr = DPNERR_GENERIC;
							DPFX(DPFPREP,  0, "Problem setting default serial baud rate selection!" );
							DisplayErrorCode( 0, GetLastError() );
							DNASSERT( FALSE );
							goto Failure;

							break;
						}

						default:
						{
							fSelectionSet = TRUE;
							break;
						}
					}
				}

				break;
			}
		}
	}

	//
	// was a selection set?  If not, set default
	//
	if ( fSelectionSet == FALSE )
	{
		LRESULT	lSendReturn;


		DPFX(DPFPREP,  8, "Serial baud rate not set, using default!" );

		lSendReturn = SendMessage( hBaudRateComboBox, CB_SETCURSEL, DEFAULT_BAUD_RATE_SELECTION_INDEX, 0 );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Cannot set default serial baud rate selection!" );
				DisplayErrorCode( 0, GetLastError() );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}

			default:
			{
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetDialogStopBits - set serial stop bits fields
//
// Entry:		Window handle
//				Pointer to ComEndpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetDialogStopBits"

static	HRESULT	SetDialogStopBits( const HWND hDlg, const CComEndpoint *const pComEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	BOOL		fSelectionSet;
	HWND		hStopBitsComboBox;


	//
	// initialize
	//
	hr = DPN_OK;
	uIndex = g_dwStopBitsCount;
	fSelectionSet = FALSE;
	hStopBitsComboBox = GetDlgItem( hDlg, IDC_COMBO_SERIAL_STOPBITS );
	if ( hStopBitsComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of serial stop bits combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	//
	// add all strings to dialog
	//
	while ( uIndex > 0 )
	{
		LRESULT	lSendReturn;


		uIndex--;

		DBG_CASSERT( sizeof( g_StopBits[ uIndex ].pASCIIKey ) == sizeof( LPARAM ) );
		lSendReturn = SendMessage( hStopBitsComboBox, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>( g_StopBits[ uIndex ].szLocalizedKey ) );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem adding stop bits to combo box!" );
				goto Failure;

				break;
			}

			case CB_ERRSPACE:
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "Out of memory adding stop bits to combo box!" );
				goto Failure;

				break;
			}

			default:
			{
				LRESULT	lTempReturn;


				//
				// we added the string OK attempt to set the associated data and
				// check to see if this is the current value
				//
				lTempReturn = SendMessage( hStopBitsComboBox, CB_SETITEMDATA, lSendReturn, g_StopBits[ uIndex ].dwEnumValue);
				if ( lTempReturn == CB_ERR )
				{
					hr = DPNERR_OUTOFMEMORY;
					DPFX(DPFPREP,  0, "Failed to set associated data for stop bits!" );
					goto Failure;
				}

				if ( pComEndpoint->GetStopBits() == g_StopBits[ uIndex ].dwEnumValue )
				{
					// set current selection to this item
					lTempReturn = SendMessage( hStopBitsComboBox, CB_SETCURSEL, lSendReturn, 0 );
					switch ( lTempReturn )
					{
						case CB_ERR:
						{
							hr = DPNERR_GENERIC;
							DPFX(DPFPREP,  0, "Problem setting default serial stop bits selection!" );
							DisplayErrorCode( 0, GetLastError() );
							DNASSERT( FALSE );
							goto Failure;

							break;
						}

						default:
						{
							fSelectionSet = TRUE;
							break;
						}
					}
				}

				break;
			}
		}
	}

	//
	// was a selection set?  If not, set default
	//
	if ( fSelectionSet == FALSE )
	{
		LRESULT	lSendReturn;


		DPFX(DPFPREP,  8, "Serial stop bits not set, using default!" );

		lSendReturn = SendMessage( hStopBitsComboBox, CB_SETCURSEL, DEFAULT_STOP_BITS_SELECTION_INDEX, 0 );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Cannot set default serial stop bits selection!" );
				DisplayErrorCode( 0, GetLastError() );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}

			default:
			{
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetDialogParity - set serial parity fields
//
// Entry:		Window handle
//				Pointer to ComEndpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetDialogParity"

static	HRESULT	SetDialogParity( const HWND hDlg, const CComEndpoint *const pComEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	BOOL		fSelectionSet;
	HWND		hParityComboBox;


	//
	// initialize
	//
	hr = DPN_OK;
	uIndex = g_dwParityCount;
	fSelectionSet = FALSE;
	hParityComboBox = GetDlgItem( hDlg, IDC_COMBO_SERIAL_PARITY );
	if ( hParityComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of serial parity combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	//
	// add all strings to dialog
	//
	while ( uIndex > 0 )
	{
		LRESULT	lSendReturn;


		uIndex--;

		DBG_CASSERT( sizeof( g_Parity[ uIndex ].pASCIIKey ) == sizeof( LPARAM ) );
		lSendReturn = SendMessage( hParityComboBox, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>( g_Parity[ uIndex ].szLocalizedKey ) );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem adding parity to combo box!" );
				goto Failure;

				break;
			}

			case CB_ERRSPACE:
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "Out of memory adding parity to combo box!" );
				goto Failure;

				break;
			}

			default:
			{
				LRESULT	lTempReturn;


				//
				// we added the string OK, attempt to set the associated data and
				// check to see if this is the current value
				//
				lTempReturn = SendMessage( hParityComboBox, CB_SETITEMDATA, lSendReturn, g_Parity[ uIndex ].dwEnumValue );
				if ( lTempReturn == CB_ERR )
				{
					hr = DPNERR_OUTOFMEMORY;
					DPFX(DPFPREP,  0, "Failed to set associated data for parity." );
					goto Failure;
				}

				if ( pComEndpoint->GetParity() == g_Parity[ uIndex ].dwEnumValue )
				{
					//
					// set current selection to this item
					//
					lTempReturn = SendMessage( hParityComboBox, CB_SETCURSEL, lSendReturn, 0 );
					switch ( lTempReturn )
					{
						case CB_ERR:
						{
							hr = DPNERR_GENERIC;
							DPFX(DPFPREP,  0, "Problem setting default serial parity selection!" );
							DisplayErrorCode( 0, GetLastError() );
							DNASSERT( FALSE );
							goto Failure;

							break;
						}

						default:
						{
							fSelectionSet = TRUE;
							break;
						}
					}
				}

				break;
			}
		}
	}

	//
	// was a selection set?  If not, set default
	//
	if ( fSelectionSet == FALSE )
	{
		LRESULT	lSendReturn;


		DPFX(DPFPREP,  8, "Serial parity not set, using default!" );

		lSendReturn = SendMessage( hParityComboBox, CB_SETCURSEL, DEFAULT_PARITY_SELECTION_INDEX, 0 );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Cannot set default serial parity selection!" );
				DisplayErrorCode( 0, GetLastError() );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}

			default:
			{
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetDialogFlowControl - set serial flow control
//
// Entry:		Window handle
//				Pointer to ComEndpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetDialogFlowControl"

static	HRESULT	SetDialogFlowControl( const HWND hDlg, const CComEndpoint *const pComEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	BOOL		fSelectionSet;
	HWND		hFlowControlComboBox;


	//
	// initialize
	//
	hr = DPN_OK;
	uIndex = g_dwFlowControlCount;
	fSelectionSet = FALSE;
	hFlowControlComboBox = GetDlgItem( hDlg, IDC_COMBO_SERIAL_FLOWCONTROL );
	if ( hFlowControlComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of serial flow control combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	//
	// add all strings to dialog
	//
	while ( uIndex > 0 )
	{
		LRESULT	lSendReturn;


		uIndex--;

		DBG_CASSERT( sizeof( g_FlowControl[ uIndex ].pASCIIKey ) == sizeof( LPARAM ) );
		lSendReturn = SendMessage( hFlowControlComboBox, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>( g_FlowControl[ uIndex ].szLocalizedKey ) );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem adding flow control to combo box!" );
				goto Failure;

				break;
			}

			case CB_ERRSPACE:
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "Out of memory adding flow control to combo box!" );
				goto Failure;

				break;
			}

			default:
			{
				LRESULT	lTempReturn;


				//
				// we added the string OK, attempt to set the associated data and
				// check to see if this is the current value
				//
				lTempReturn = SendMessage( hFlowControlComboBox, CB_SETITEMDATA, lSendReturn, g_FlowControl[ uIndex ].dwEnumValue );
				if ( lTempReturn == CB_ERR )
				{
					hr = DPNERR_OUTOFMEMORY;
					DPFX(DPFPREP,  0, "Failed to set associated data for flow control!" );
					goto Failure;
				}

				if ( pComEndpoint->GetFlowControl() == static_cast<SP_FLOW_CONTROL>( g_FlowControl[ uIndex ].dwEnumValue ) )
				{
					// set current selection to this item
					lTempReturn = SendMessage( hFlowControlComboBox, CB_SETCURSEL, lSendReturn, 0 );
					switch ( lTempReturn )
					{
						case CB_ERR:
						{
							hr = DPNERR_GENERIC;
							DPFX(DPFPREP,  0, "Problem setting default flow control selection!" );
							DisplayErrorCode( 0, GetLastError() );
							DNASSERT( FALSE );
							goto Failure;

							break;
						}

						default:
						{
							fSelectionSet = TRUE;
							break;
						}
					}
				}

				break;
			}
		}
	}

	//
	// was a selection set?  If not, set default
	//
	if ( fSelectionSet == FALSE )
	{
		LRESULT	lSendReturn;


		DPFX(DPFPREP,  8, "Serial flow control not set, using default!" );

		lSendReturn = SendMessage( hFlowControlComboBox, CB_SETCURSEL, DEFAULT_FLOW_CONTROL_SELECTION_INDEX, 0 );
		switch ( lSendReturn )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Cannot set default serial flow control selection!" );
				DisplayErrorCode( 0, GetLastError() );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}

			default:
			{
				break;
			}
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetDialogData - set ComEndpoint data from serial dialog
//
// Entry:		Window handle
//				Pointer to ComEndpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetDialogData"

static	HRESULT	GetDialogData( const HWND hDlg, CComEndpoint *const pComEndpoint )
{
	HRESULT	hr;
	LRESULT	lSelection;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// get comm device
	//
	lSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_DEVICE ), CB_GETCURSEL, 0, 0 );
	switch ( lSelection )
	{
		case CB_ERR:
		{
			hr = DPNERR_GENERIC;
			DPFX(DPFPREP,  0, "Failed to determine serial device selection!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		default:
		{
			LRESULT	lItemData;
			HRESULT	hTempResult;


			lItemData = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_DEVICE ), CB_GETITEMDATA, lSelection, 0 );
			if ( lItemData == CB_ERR )
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Failed to get associated device data!" );
				DNASSERT( FALSE );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			DNASSERT( lItemData != 0 );
			
			DNASSERT( lItemData <= UINT32_MAX );
			hTempResult = pComEndpoint->SetDeviceID( static_cast<DWORD>( lItemData ) );
			DNASSERT( hTempResult == DPN_OK );

			break;
		}
	}

	//
	// get baud rate
	//
	lSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_BAUDRATE ), CB_GETCURSEL, 0, 0 );
	switch ( lSelection )
	{
		case CB_ERR:
		{
			hr = DPNERR_GENERIC;
			DPFX(DPFPREP,  0, "Failed to determine serial baud rate selection!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		default:
		{
			LRESULT	lItemData;
			HRESULT	hTempResult;


			DNASSERT( hr == DPN_OK );
			lItemData = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_BAUDRATE ), CB_GETITEMDATA, lSelection, 0 );
			if ( lItemData == CB_ERR )
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Failed to get associated baudrate data!" );
				DNASSERT( FALSE );
				goto Failure;
			}
			
			DNASSERT( lItemData <= UINT32_MAX );
			hTempResult = pComEndpoint->SetBaudRate( static_cast<DWORD>( lItemData ) );
			DNASSERT( hTempResult == DPN_OK );

			break;
		}
	}

	//
	// get stop bits
	//
	lSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_STOPBITS ), CB_GETCURSEL, 0, 0 );
	switch ( lSelection )
	{
		case CB_ERR:
		{
			hr = DPNERR_GENERIC;
			DPFX(DPFPREP,  0, "Failed to determine serial stop bits selection!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		default:
		{
			LRESULT	lItemData;
			HRESULT	hTempResult;


			lItemData = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_STOPBITS ), CB_GETITEMDATA, lSelection, 0 );
			if ( lItemData == CB_ERR )
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Failed to get associated stop bits data!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			DNASSERT( lItemData <= UINT32_MAX );
			hTempResult = pComEndpoint->SetStopBits( static_cast<DWORD>( lItemData ) );
			DNASSERT( hTempResult == DPN_OK );

			break;
		}
	}

	//
	// get parity
	//
	lSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_PARITY ), CB_GETCURSEL, 0, 0 );
	switch ( lSelection )
	{
		case CB_ERR:
		{
			hr = DPNERR_GENERIC;
			DPFX(DPFPREP,  0, "Failed to determine serial parity selection!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		default:
		{
			LRESULT	lItemData;
			HRESULT	hTempResult;


			lItemData = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_PARITY ), CB_GETITEMDATA, lSelection, 0 );
			if ( lItemData == CB_ERR )
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Failed to get associated parity data!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			DNASSERT( lItemData <= UINT32_MAX );
			hTempResult = pComEndpoint->SetParity( static_cast<DWORD>( lItemData ) );
			DNASSERT( hTempResult == DPN_OK );

			break;
		}
	}

	//
	// get flow control
	//
	lSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_FLOWCONTROL ), CB_GETCURSEL, 0, 0 );
	switch ( lSelection )
	{
		case CB_ERR:
		{
			hr = DPNERR_GENERIC;
			DPFX(DPFPREP,  0, "Failed to determine serial flow control selection!" );
			DNASSERT( FALSE );
			goto Failure;

			break;
		}

		default:
		{
			LRESULT	lItemData;
			HRESULT	hTempResult;


			lItemData = SendMessage( GetDlgItem( hDlg, IDC_COMBO_SERIAL_FLOWCONTROL ), CB_GETITEMDATA, lSelection, 0 );
			if ( lItemData == CB_ERR )
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Failed to get associated flow control data!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			hTempResult = pComEndpoint->SetFlowControl( static_cast<SP_FLOW_CONTROL>( lItemData ) );
			DNASSERT( hTempResult == DPN_OK );

			break;
		}
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\crc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CRC.h
 *  Content:	CRC Routines for COM port I/O
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/18/98	johnkan	Copied from DPlay 6.x and fixed up
 *@@END_MSINTERNAL
 ***************************************************************************/

#ifndef	__CRC_H__
#define	__CRC_H__


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************
//void	GenerateCRCTable( void );
DWORD	GenerateCRC( const BYTE *const pBuffer, const DWORD dwBufferSize );
DWORD	GenerateMultiBufferCRC( const BUFFERDESC *const pBuffers, const DWORD dwBufferCount );

#ifdef	_DEBUG
void	ValidateCRCTable( void );
#endif	// _DEBUG

#endif	// __CRC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\crc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1996-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CRC.cpp
 *  Content:	CRC Routines for COM port I/O
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/18/98	johnkan	Copied from DPlay 6.x and fixed up
 *@@END_MSINTERNAL
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

// uncomment the following to validate CRC table each time a CRC function is called
//#define	VALIDATE_CRC_TABLE

// defines for 32-bit CRC
///*
//  Name   : "CRC-32"
//   Width  : 32
//   Poly   : 04C11DB7
//   Init   : FFFFFFFF
//   RefIn  : True
//   RefOut : True
//   XorOut : FFFFFFFF
//   Check  : CBF43926
//
//  This is supposedly what Ethernet uses
//*/
//
//#define WIDTH		32
//#define POLY		0x04C11DB7
//#define INITVALUE	0xFFFFFFFF
//#define REFIN		TRUE
//#define XOROUT		0xFFFFFFFF
//#define CHECK		0xCBF43926
//#define WIDMASK		0xFFFFFFFF		// value is (2^WIDTH)-1


/*
  Name   : "CRC-16"
   Width  : 16
   Poly   : 8005
   Init   : 0000
   RefIn  : True
   RefOut : True
   XorOut : 0000
   Check  : BB3D
*/
#define WIDTH		16
#define POLY		0x8005
#define INITVALUE	0
#define REFIN		TRUE
#define XOROUT		0
#define CHECK		0xBB3D
#define WIDMASK		0x0000FFFF		// value is (2^WIDTH)-1

//**********************************************************************
// Macro definitions
//**********************************************************************

#define BITMASK(X) (1L << (X))

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

// precomputed CRC table values from GenerateCRC()
static	DWORD	g_CRCTable[ 256 ] =
{
	0x0, 0xc0c1, 0xc181, 0x140, 0xc301, 0x3c0, 0x280, 0xc241,
	0xc601, 0x6c0, 0x780, 0xc741, 0x500, 0xc5c1, 0xc481, 0x440,
	0xcc01, 0xcc0, 0xd80, 0xcd41, 0xf00, 0xcfc1, 0xce81, 0xe40,
	0xa00, 0xcac1, 0xcb81, 0xb40, 0xc901, 0x9c0, 0x880, 0xc841,
	0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40,
	0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41,
	0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641,
	0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040,
	0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240,
	0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441,
	0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41,
	0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840,
	0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41,
	0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40,
	0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640,
	0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041,
	0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240,
	0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441,
	0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41,
	0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840,
	0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41,
	0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40,
	0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640,
	0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041,
	0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241,
	0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440,
	0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40,
	0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841,
	0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40,
	0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41,
	0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641,
	0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040
};

// since the talbe is static, no reason for this variable
//static	BOOL	g_fTableCreated = FALSE;

//**********************************************************************
// Function prototypes
//**********************************************************************
static	DWORD	crc_reflected( LPBYTE blk_adr, DWORD blk_len, DWORD *crctable );

#ifdef	_DEBUG
static	DWORD	reflect( DWORD v, int b );
static	DWORD	cm_tab( int index );
#endif	// _DEBUG

//**********************************************************************
// Function definitions
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// crc_normal - generate a normal CRC
////
//// Entry:		Pointer to input data block
////				Size of data block
////				Pointer to CRC table
////
//// Exit:		32-bit CRC
//// ------------------------------
//static	DWORD	crc_normal( LPBYTE blk_adr, DWORD blk_len, DWORD crctable[] )
//{
//	DWORD	crc = INITVALUE;
//
//	while (blk_len--)
//		crc = crctable[((crc>>24) ^ *blk_adr++) & 0xFFL] ^ (crc << 8);
//
//	return (crc ^ XOROUT);
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// crc_reflected - generate a reflected CRC
//
// Entry:		Pointer to input data block
//				Size of data block
//				Pointer to CRC table
//
// Exit:		32-bit CRC
// ------------------------------
static	DWORD	crc_reflected( BYTE *blk_adr, DWORD blk_len, DWORD *crctable )
{
	DWORD	crc = INITVALUE;
	DEBUG_ONLY( DWORD	dwOffset = 0 );


//	DPFX(DPFPREP,  9, "Enter crc_reflected" );

	while (blk_len--)
	{
		crc = crctable[(crc ^ *blk_adr) & 0xFFL] ^ (crc >> 8);
//		DPFX(DPFPREP,  8, "TempCRC: 0x%x\tOffset: %d\tChar 0x%x", crc, dwOffset, *blk_adr );
		blk_adr++;
		DEBUG_ONLY( dwOffset++ );
	}

	crc ^= XOROUT;
//	DPFX(DPFPREP,  8, "Computed CRC: 0x%x", crc );

//	DPFX(DPFPREP,  9, "Leave crc_reflected" );

	return crc;
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// GenerateCRCTable - create CRC table
////
//// Entry:		Nothing
////
//// Exit:		Nothing
//// ------------------------------
//void	GenerateCRCTable( void )
//{
//	DWORD	i;
//
//
//	// had the table been built?
//	if ( g_fTableCreated == FALSE )
//	{
//		for (i = 0; i < 256; i++)
//		{
//			g_CRCTable[i] = cm_tab(i);
//		}
//
//		// note that the table has been built
//		g_fTableCreated = TRUE;
//	}
//
//	// code to pregenerate CRC table
//	DPFX(DPFPREP,  0, "\nHexDump:\n" );
//	for( i = 0; i < 256; i+=8 )
//	{
//		DPFX(DPFPREP,  3, "0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x,", g_CRCTable[ i ],
//																   g_CRCTable[ i + 1 ],
//																   g_CRCTable[ i + 2 ],
//																   g_CRCTable[ i + 3 ],
//																   g_CRCTable[ i + 4 ],
//																   g_CRCTable[ i + 5 ],
//																   g_CRCTable[ i + 6 ],
//																   g_CRCTable[ i + 7 ] );
//
//	}
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// GenerateCRC - generate a CRC
//
// Entry:		Pointer to data
//				Size of data
//
// Exit:		CRC
// ------------------------------
DWORD	GenerateCRC( const BYTE *const pBuffer, const DWORD dwBufferSize )
{
//	DNASSERT( g_fTableCreated != FALSE );

#ifdef	VALIDATE_CRC_TABLE
	ValidateCRCTable();
#endif

	return ( crc_reflected( const_cast<BYTE*>( pBuffer ), dwBufferSize, g_CRCTable ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GenerateMultiBufferCRC - generate a CRC from multiple buffers
//
// Entry:		Pointer to buffer descriptions
//				Count of buffers
//
// Exit:		CRC
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GenerateMultiBufferCRC"

DWORD GenerateMultiBufferCRC( const BUFFERDESC *const pBuffer, const DWORD dwBufferCount )
{
	DWORD	TempCRC;
//	DWORD	crc = INITVALUE;
	DWORD	Count;
//	DNASSERT( g_fTableCreated != FALSE );


//	DPFX(DPFPREP,  9, "Entering GenerateMultiBufferCRC" );

	// initialize
	TempCRC = INITVALUE;

	// generate CRC
	for ( Count = 0; Count < dwBufferCount; Count++ )
	{
		LPBYTE	pWorkingByte;
		DWORD	dwBufferSize;

		// initialize
		dwBufferSize = pBuffer[ Count ].dwBufferSize;
		pWorkingByte = static_cast<BYTE*>( pBuffer[ Count ].pBufferData );

		// CRC this block
		while ( dwBufferSize > 0 )
		{
			TempCRC = g_CRCTable[ ( TempCRC ^ (*pWorkingByte) ) & 0xFFL ] ^ ( TempCRC >> 8 );

//			DPFX(DPFPREP,  8, "TempCRC: 0x%x\tOffset: %d\tChar: 0x%x",
//					TempCRC,
//					( pWorkingByte - static_cast<BYTE*>( pBuffer[ Count ].lpBufferData ) ),
//					*pWorkingByte
//					);

			pWorkingByte++;
			dwBufferSize--;
		}
	}

	TempCRC ^= XOROUT;
//	DPFX(DPFPREP,  8, "Computed CRC: 0x%x", TempCRC );

//	DPFX(DPFPREP,  9, "Leaving GenerateMultiBufferCRC" );

	return TempCRC;
}
//**********************************************************************


#ifdef	_DEBUG
//**********************************************************************
// ------------------------------
// reflect - reflect the bottom N bits of a DWORD
//
// Entry:		Input DWORD
//				Number of bits to reflect
//
// Exit:		Reflected value
//
// Returns the value v with the bottom b [0,32] bits reflected.
// Example: reflect(0x3e23L,3) == 0x3e26
// -----------------------------
static	DWORD	reflect( DWORD v, int b )
{
	int		i;
	DWORD	t = v;

	for (i = 0; i < b; i++)
	{
		if (t & 1L)
			v |=  BITMASK((b-1)-i);
		else
			v &= ~BITMASK((b-1)-i);
		t >>= 1;
	}
	return v;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// cm_tab - do something
//
// Entry:		Index
//
// Exit:		DWORD
// ------------------------------
static	DWORD	cm_tab( int index )
{
	int   i;
	DWORD r;
	DWORD topbit = (DWORD) BITMASK(WIDTH-1);
	DWORD inbyte = (DWORD) index;

	if (REFIN)
		inbyte = reflect(inbyte, 8);

	r = inbyte << (WIDTH-8);
	for (i = 0; i < 8; i++)
	{
		if (r & topbit)
			r = (r << 1) ^ POLY;
		else
			r <<= 1;
	}

	if (REFIN)
		r = reflect(r, WIDTH);

	return (r & WIDMASK);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ValidateCRCTable - validate that the CRC table is correct
//
// Entry:		Nothing
//				Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ValidateCRCTable"

void	ValidateCRCTable( void )
{
	DWORD	i;

	for (i = 0; i < LENGTHOF( g_CRCTable ); i++)
	{
		DNASSERT( g_CRCTable[ i ] == cm_tab(i) );
	}
}
//**********************************************************************
#endif	// _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\contextfixedpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       FixedPool.h
 *  Content:	Pool manager for classes
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-18-97	aarono		Original
 *	11-06-98	ejs			Add custom handler for Release function
 *	04-12-99	johnkan		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	johnkan		Added code to check for items already being in the pool on Release().
 *	02-08-2000	johnkan		Derived from ClassFPM.h
 *	03-26-2000	johnkan		Renamed to avoid collisions with other classes
 *	04-06-2000	johnkan		Modified to have a base class to derive pool items from
 *	04-26-2000	johnkan		Modified to not have a base class or reference counts
***************************************************************************/

#ifndef __FIXED_POOL__
#define __FIXED_POOL__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CHECK_FOR_DUPLICATE_CONTEXT_FIXED_POOL_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward reference
//
template< class T, class S > class CContextPoolNode;
template< class T, class S > class CContextPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class to act as a link in the pool
//
template< class T, class S >
class	CContextPoolNode
{
	public:
		CContextPoolNode() { m_pNext = NULL; }
		~CContextPoolNode() {};

		CContextPoolNode< T, S >	*GetNext( void ) const { return m_pNext; }
		void	InvalidateNext( void ) { m_pNext = NULL; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CContextPoolNode::LinkToPool"
		void	LinkToPool( CContextPoolNode< T, S > *volatile *const ppPoolNodes )
		{
			DNASSERT( ppPoolNodes != NULL );
			m_pNext = *ppPoolNodes;
			*ppPoolNodes = this;
		}

		T*	GetItem( void ) { return &m_Item; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CContextPoolNode::PoolNodeFromItem"
		static CContextPoolNode< T, S >	*PoolNodeFromItem( T *const pItem )
		{
			DNASSERT( pItem != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
			DBG_CASSERT( sizeof( CContextPoolNode< T, S >* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CContextPoolNode< T, S >*>( &reinterpret_cast<BYTE*>( pItem )[ -( (INT_PTR) &(((CContextPoolNode< T, S > *)0)->m_Item) ) ] );
//			return	reinterpret_cast<CContextPoolNode< T, S >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CContextPoolNode< T, S >, m_Item ) ] );
		}

//		//
//		// The following functions need to be supplied by this pool item
//		//
//		BOOL	PoolAllocFunction( S Context ){ return TRUE; }
//		BOOL	PoolInitFunction( S Context ){ return TRUE; }
//		void	PoolReleaseFunction( void ){};
//		void	PoolDeallocFunction( void ){};

	protected:
	
	private:
		//
		// pointer used to link this item to the rest of the pool
		//
		CContextPoolNode< T, S >	*m_pNext;
		T		m_Item;

		//
		// prevent unwarranted copies
		//
		CContextPoolNode< T, S >( const CContextPoolNode< T, S > & );
		CContextPoolNode< T, S >& operator=( const CContextPoolNode< T, S > & );
};


//
// class to manage the pool
//
template< class T, class S >
class	CContextPool
{
	public:
		CContextPool();
		~CContextPool();

		T		*Get( S Context );
		void	Release( T *const pItem );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;

		CContextPoolNode< T, S >	*volatile m_pPool;		// pointer to list of available elements

		DEBUG_ONLY( volatile LONG	m_lOutstandingItemCount );

		CContextPoolNode< T, S >	*RemoveNode( void )
		{
			CContextPoolNode< T, S >	*pReturn;


			if ( m_pPool != NULL )
			{
				pReturn = m_pPool;
				m_pPool = m_pPool->GetNext();
				DEBUG_ONLY( pReturn->InvalidateNext() );
			}
			else
			{
				pReturn = NULL;
			}

			return	pReturn;
		}
		
		//
		// prevent unwarranted copies
		//
		CContextPool< T, S >( const CContextPool< T, S > & );
		CContextPool< T, S >& operator=( const CContextPool< T, S > & );
};


//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextPool::CContextPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
template< class T, class S >
CContextPool< T, S >::CContextPool():
	m_pPool( NULL )
{
	DEBUG_ONLY( m_lOutstandingItemCount = 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextPool::~CContextPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextPool::~CContextPool"

template< class T, class S >
CContextPool< T, S >::~CContextPool()
{
	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CContextPoolNode< T, S >	*pNode;

		
		pNode = RemoveNode();
		pNode->GetItem()->PoolDeallocFunction();
		delete	pNode;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextPool::Get - get an item from the pool
//
// Entry:		Nothing
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextPool::Get"

template< class T, class S >
T	*CContextPool< T, S >::Get( S Context )
{
	CContextPoolNode< T, S >	*pNode;
	T	*pReturn;


	//
	// initialize
	//
	pNode = NULL;
	pReturn = NULL;

	//
	// if the pool is empty, try to allocate a new entry, otherwise grab
	// the first item from the pool
	//
	if ( m_pPool == NULL )
	{
		pNode = new CContextPoolNode< T, S >;
		if ( pNode != NULL )
		{
			if ( pNode->GetItem()->PoolAllocFunction( Context ) == FALSE )
			{
				delete pNode;
				pNode = NULL;
			}
		}
	}
	else
	{
		pNode = RemoveNode();
	}

	//
	// if we have an entry (it was freshly created, or removed from the pool),
	// attempt to initialize it before passing it to the user
	//
	if ( pNode != NULL )
	{
		if ( pNode->GetItem()->PoolInitFunction( Context ) == FALSE )
		{
			pNode->LinkToPool( &m_pPool );
			DNASSERT( pReturn == NULL );
		}
		else
		{
			DEBUG_ONLY( DNInterlockedIncrement( const_cast<LONG*>( &m_lOutstandingItemCount ) ) );
			pReturn = pNode->GetItem();
		}
	}

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextPool::Release"

template< class T, class S >
void	CContextPool< T, S >::Release( T *const pItem )
{
	CContextPoolNode< T, S >	*pPoolNode;


	DNASSERT( pItem != NULL );
	pPoolNode = CContextPoolNode< T, S >::PoolNodeFromItem( pItem );
	
#if defined(CHECK_FOR_DUPLICATE_CONTEXT_FIXED_POOL_RELEASE) && defined(DEBUG)
	{
		CContextPoolNode< T, S >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pPoolNode );
			pTemp = pTemp->GetNext();
		}
	}
#endif	// CHECK_FOR_DUPLICATE_CONTEXT_FIXED_POOL_RELEASE

	pItem->PoolReleaseFunction();
	
	DEBUG_ONLY( DNASSERT( pPoolNode->GetNext() == NULL ) );
	pPoolNode->LinkToPool( &m_pPool );
	
	DEBUG_ONLY( DNInterlockedDecrement( const_cast<LONG*>( &m_lOutstandingItemCount ) ) );
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_MODNAME

#endif	// __FIXED_POOL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dataport.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   DataPort.cpp
 *  Content:	Serial communications port management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 *	09/14/99	jtk		Derived from ComPort.cpp
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// number of milliseconds in one day
//
#define	ONE_DAY		86400000

//
// number of BITS in a serial BYTE
//
#define	BITS_PER_BYTE	8

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::CDataPort - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
CDataPort::CDataPort():
	m_EndpointRefCount( 0 ),
	m_State( DATA_PORT_STATE_UNKNOWN ),
	m_Handle( INVALID_HANDLE_VALUE ),
	m_pSPData( NULL ),
	m_pActiveRead( NULL ),
	m_LinkDirection( LINK_DIRECTION_UNKNOWN ),
	m_hFile( INVALID_HANDLE_VALUE ),
	m_hListenEndpoint( INVALID_HANDLE_VALUE ),
	m_hConnectEndpoint( INVALID_HANDLE_VALUE ),
	m_hEnumEndpoint( INVALID_HANDLE_VALUE )
{
	m_ActiveListLinkage.Initialize();
	
	DEBUG_ONLY( m_fInitialized = FALSE );
//	DEBUG_ONLY( m_fDeviceParametersInitialized = FALSE );
//	DEBUG_ONLY( m_fFileParametersInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::~CDataPort - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::~CDataPort"

CDataPort::~CDataPort()
{
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );

	DNASSERT( m_EndpointRefCount == 0 );
	DNASSERT( GetState() == DATA_PORT_STATE_UNKNOWN );
	DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetSPData() == NULL );
	DNASSERT( m_pActiveRead == NULL );

	DNASSERT( m_ActiveListLinkage.IsEmpty() != FALSE );

	DNASSERT( m_LinkDirection == LINK_DIRECTION_UNKNOWN );
	DNASSERT( m_hFile == INVALID_HANDLE_VALUE );

	DNASSERT( m_hListenEndpoint == INVALID_HANDLE_VALUE );
	DNASSERT( m_hConnectEndpoint == INVALID_HANDLE_VALUE );
	DNASSERT( m_hEnumEndpoint == INVALID_HANDLE_VALUE );

//	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
//	DEBUG_ONLY( DNASSERT( m_fDeviceParametersInitialized == FALSE ) );
//	DEBUG_ONLY( DNASSERT( m_fFileParametersInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::Initialize - initialize data port for use
//
// Entry:		Pointer to SPData
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::Initialize"

HRESULT	CDataPort::Initialize( CSPData *const pSPData )
{
	HRESULT	hr;


	DNASSERT( pSPData != NULL );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );

	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( m_pSPData == NULL );
	m_pSPData = pSPData;

	DNASSERT( m_ActiveListLinkage.IsEmpty() != FALSE );
	
	DNASSERT( m_hListenEndpoint == INVALID_HANDLE_VALUE );
	DNASSERT( m_hConnectEndpoint == INVALID_HANDLE_VALUE );
	DNASSERT( m_hEnumEndpoint == INVALID_HANDLE_VALUE );

	//
	// Attempt to create critical section, recursion count needs to be non-zero
	// to handle endpoint cleanup when a modem operation fails.
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to initialized critical section on DataPort!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 1 );

//	//
//	// initialize send queue
//	//
//	hr = m_SendQueue.Initialize();
//	if ( hr != DPN_OK )
//	{
//	    DPFX(DPFPREP,  0, "Failed to initialize send queue!" );
//	    DisplayDNError( 0, hr );
//	    goto Failure;
//	}


	SetState( DATA_PORT_STATE_INITIALIZED );
	DEBUG_ONLY( m_fInitialized = TRUE );

Exit:
	return	hr;

Failure:
	Deinitialize();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::Deinitialize - deinitialize this data port
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::Deinitialize"

void	CDataPort::Deinitialize( void )
{
	m_pSPData = NULL;

	DNASSERT( m_ActiveListLinkage.IsEmpty() != FALSE );

	DNASSERT( m_hFile == INVALID_HANDLE_VALUE );

	DNASSERT( m_hListenEndpoint == INVALID_HANDLE_VALUE );
	DNASSERT( m_hConnectEndpoint == INVALID_HANDLE_VALUE );
	DNASSERT( m_hEnumEndpoint == INVALID_HANDLE_VALUE );

//	m_SendQueue.Deinitialize();

	DNDeleteCriticalSection( &m_Lock );

	SetState( DATA_PORT_STATE_UNKNOWN );
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::EndpointAddRef - increment endpoint reference count
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::EndpointAddRef"

void	CDataPort::EndpointAddRef( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	Lock();

	DNASSERT( m_EndpointRefCount != -1 );
	m_EndpointRefCount++;
	
	AddRef();

	Unlock();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::EndpointDecRef - decrement endpoint reference count
//
// Entry:		Nothing
//
// Exit:		Endpoint reference count
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::EndpointDecRef"

DWORD	CDataPort::EndpointDecRef( void )
{
	DWORD	dwReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	DNASSERT( m_EndpointRefCount != 0 );
	DNASSERT( ( GetState() == DATA_PORT_STATE_RECEIVING ) ||
			  ( GetState() == DATA_PORT_STATE_INITIALIZED ) );
//			  ( GetState() == DATA_PORT_STATE_CLOSING ) );


	Lock();

	DNASSERT( m_EndpointRefCount != 0 );
	m_EndpointRefCount--;
	dwReturn = m_EndpointRefCount;
	if ( m_EndpointRefCount == 0 )
	{
		SetState( DATA_PORT_STATE_UNBOUND );
		UnbindFromNetwork();
	}

	Unlock();
	
	DecRef();

	return	dwReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::SetPortCommunicationParameters - set generate communication parameters
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::SetPortCommunicationParameters"

HRESULT	CDataPort::SetPortCommunicationParameters( void )
{
	HRESULT	hr;
	COMMTIMEOUTS	CommTimeouts;


	//
	// set timeout values for serial port
	//
	hr = DPN_OK;
	memset( &CommTimeouts, 0x00, sizeof( CommTimeouts ) );
//	CommTimeouts.ReadIntervalTimeout = 1;						// wait 1ms before timing out on input
	CommTimeouts.ReadIntervalTimeout = ONE_DAY;					// read timeout interval (none)
	CommTimeouts.ReadTotalTimeoutMultiplier = ONE_DAY;			// return immediately
	CommTimeouts.ReadTotalTimeoutConstant = 0;					// return immediately
//	CommTimeouts.ReadIntervalTimeout = 0;						// read timeout interval (none)
//	CommTimeouts.ReadTotalTimeoutMultiplier = 0;				// return immediately
//	CommTimeouts.ReadTotalTimeoutConstant = 0;					// return immediately
	CommTimeouts.WriteTotalTimeoutMultiplier = 0;				// no multiplier
	CommTimeouts.WriteTotalTimeoutConstant = WRITE_TIMEOUT_MS;	// write timeout interval

	if ( SetCommTimeouts( m_hFile, &CommTimeouts ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_GENERIC;
		dwError = GetLastError();
		// report error (there's no cleanup)
		DPFX(DPFPREP,  0, "Unable to set comm timeouts!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

	//
	// clear any outstanding communication data
	//
	if ( PurgeComm( m_hFile, ( PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR ) ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem with PurgeComm() when opening com port!" );
		DisplayErrorCode( 0, dwError );
	}

	//
	// set communication mask to listen for character receive
	//
	if ( SetCommMask( m_hFile, EV_RXCHAR ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_GENERIC;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Error setting communication mask!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;

	}

Exit:	
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::StartReceiving - start receiving
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::StartReceiving"

HRESULT	CDataPort::StartReceiving( void )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;
	Lock();

	switch ( GetState() )
	{
		//
		// port is initialized, but not receiving yet, start receiving
		//
		case DATA_PORT_STATE_INITIALIZED:
		{
			hr = Receive();
			if ( ( hr == DPNERR_PENDING ) ||
				 ( hr == DPN_OK ) )
			{
				SetState( DATA_PORT_STATE_RECEIVING );

				//
				// the receive was successful, return success for this function
				//
				hr = DPN_OK;
			}
			else
			{
				DPFX(DPFPREP,  0, "Failed initial read!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			break;
		}

		//
		// data port is already receiving, nothing to do
		//
		case DATA_PORT_STATE_RECEIVING:
		{
			break;
		}

		//
		// data port is closing, we shouldn't be here!
		//
		case DATA_PORT_STATE_UNBOUND:
		{
			DNASSERT( FALSE );
			break;
		}

		//
		// bad state
		//
		case DATA_PORT_STATE_UNKNOWN:
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	Unlock();

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::Receive - read from file
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::Receive"

HRESULT	CDataPort::Receive( void )
{
	HRESULT	hr;
	BOOL	fReadReturn;


	//
	// initialize
	//
	hr = DPN_OK;
	AddRef();
	
Reread:
	//
	// if there is no pending read, get one from the pool
	//
	if ( m_pActiveRead == NULL )
	{
		m_pActiveRead = m_pSPData->GetThreadPool()->CreateReadIOData();
		if ( m_pActiveRead == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP,  0, "Failed to get buffer for read!" );
			goto Failure;
		}

		m_pActiveRead->SetDataPort( this );
	}

	//
	// check the state of the read and perform the appropriate action
	//
	DNASSERT( m_pActiveRead != NULL );
	switch ( m_pActiveRead->m_ReadState )
	{
		//
		// Initialize read state.  This involves setting up to read a header
		// and then reentering the loop.
		//
		case READ_STATE_UNKNOWN:
		{
			m_pActiveRead->SetReadState( READ_STATE_READ_HEADER );
			m_pActiveRead->m_dwBytesToRead = sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader );
			m_pActiveRead->m_dwReadOffset = 0;
			goto Reread;
		
			break;
		}

		//
		// issue a read for a header or user data
		//
		case READ_STATE_READ_HEADER:
		case READ_STATE_READ_DATA:
		{
			//
			// don't change m_dwReadOffset because it might have been set
			// elsewhere to recover a partially received message
			//
//			DNASSERT( m_pActiveReceiveBuffer != NULL );
//			m_dwBytesReceived = 0;
//			m_pActiveRead->m_dwBytesReceived = 0;
			break;
		}

		//
		// unknown state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

		
	//
	// lock the active read list for Win9x only to prevent reads from completing
	// early
	//
#ifdef WIN95
	m_pSPData->GetThreadPool()->LockReadData();
	DNASSERT( m_pActiveRead->Win9xOperationPending() == FALSE );
	m_pActiveRead->SetWin9xOperationPending( TRUE );
#endif

	DNASSERT( m_pActiveRead->jkm_dwOverlappedBytesReceived == 0 );


	DPFX(DPFPREP, 8, "Submitting read 0x%p (socketport 0x%p, file 0x%p).",
		m_pActiveRead, this, m_hFile);


	//
	// perform read
	//
	fReadReturn = ReadFile( m_hFile,																		// file handle
							&m_pActiveRead->m_ReceiveBuffer.ReceivedData[ m_pActiveRead->m_dwReadOffset ],	// pointer to destination
							m_pActiveRead->m_dwBytesToRead,													// number of bytes to read
							&m_pActiveRead->jkm_dwImmediateBytesReceived,									// pointer to number of bytes received
							m_pActiveRead->Overlap()														// pointer to overlap structure
							);
	if ( fReadReturn == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		switch ( dwError )
		{
			//
			// I/O is pending, wait for completion notification
			//
			case ERROR_IO_PENDING:
			{
				hr = DPNERR_PENDING;
				break;
			}

			//
			// comport was closed, nothing else to do
			//
			case ERROR_INVALID_HANDLE:
			{
				hr = DPNERR_NOCONNECTION;
				goto Failure;

				break;
			}

			//
			// other
			//
			default:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Unknown error from ReadFile!" );
				DisplayErrorCode( 0, dwError );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}
		}
	}
	else
	{
		//
		// read succeeded immediately, we'll handle it on the async notification
		//
		DNASSERT( hr == DPN_OK );
	}

Exit:
#ifdef WIN95
		m_pSPData->GetThreadPool()->UnlockReadData();
#endif
	return	hr;

Failure:

	if ( m_pActiveRead != NULL )
	{
#ifdef WIN95
		m_pActiveRead->SetWin9xOperationPending( FALSE );
#endif
		m_pActiveRead->DecRef();
		m_pActiveRead = NULL;
	}

	DecRef();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CDataPort::SendData - send data
//
// Entry:		Pointer to write buffer
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::SendData"

void	CDataPort::SendData( CWriteIOData *const pWriteIOData )
{
//	CWriteIOData	*pActiveSend;
	UINT_PTR		uIndex;
	DWORD			dwByteCount;
	BOOL			fWriteFileReturn;


	DNASSERT( m_EndpointRefCount != 0 );
	DNASSERT( pWriteIOData->m_DataBuffer.MessageHeader.SerialSignature == SERIAL_HEADER_START  );
	DNASSERT( ( pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken == SERIAL_DATA_USER_DATA ) ||
			  ( ( pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken & ~( ENUM_RTT_MASK ) ) == SERIAL_DATA_ENUM_QUERY ) ||
			  ( ( pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken & ~( ENUM_RTT_MASK ) )== SERIAL_DATA_ENUM_RESPONSE ) );

	//
	// check for command cancellation
	//
	if ( pWriteIOData->m_pCommand != NULL )
	{
		pWriteIOData->m_pCommand->Lock();
		switch ( pWriteIOData->m_pCommand->GetState() )
		{
			//
			// command pending, mark as uninterruptable and exit
			//
			case COMMAND_STATE_PENDING:
			{
				pWriteIOData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
				pWriteIOData->m_pCommand->Unlock();
				break;
			}

			//
			// command is being cancelled, indicate command failure
			//
			case COMMAND_STATE_CANCELLING:
			{
				DNASSERT( FALSE );
				break;
			}

			//
			// other
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	//
	// flatten the buffer so it will send faster (no thread transitions from
	// send complete to sending the next chunk).
	//
	dwByteCount = sizeof( pWriteIOData->m_DataBuffer.MessageHeader );
	for ( uIndex = 0; uIndex < pWriteIOData->m_uBufferCount; uIndex++ )
	{
		memcpy( &pWriteIOData->m_DataBuffer.Data[ dwByteCount ],
				pWriteIOData->m_pBuffers[ uIndex ].pBufferData,
				pWriteIOData->m_pBuffers[ uIndex ].dwBufferSize );
		dwByteCount += pWriteIOData->m_pBuffers[ uIndex ].dwBufferSize;
	}

	DNASSERT( dwByteCount <= MAX_MESSAGE_SIZE );

	DNASSERT( dwByteCount < 65536 );
	DBG_CASSERT( sizeof( pWriteIOData->m_DataBuffer.MessageHeader.wMessageSize ) == sizeof( WORD ) );
	pWriteIOData->m_DataBuffer.MessageHeader.wMessageSize = static_cast<WORD>( dwByteCount - sizeof( pWriteIOData->m_DataBuffer.MessageHeader ) );

	DBG_CASSERT( sizeof( pWriteIOData->m_DataBuffer.MessageHeader.wMessageCRC ) == sizeof( WORD ) );
	pWriteIOData->m_DataBuffer.MessageHeader.wMessageCRC = static_cast<WORD>( GenerateCRC( &pWriteIOData->m_DataBuffer.Data[ sizeof( pWriteIOData->m_DataBuffer.MessageHeader ) ], pWriteIOData->m_DataBuffer.MessageHeader.wMessageSize ) );

	DBG_CASSERT( sizeof( pWriteIOData->m_DataBuffer.MessageHeader.wHeaderCRC ) == sizeof( WORD ) );
	DBG_CASSERT( sizeof( &pWriteIOData->m_DataBuffer.MessageHeader ) == sizeof( BYTE* ) );
	pWriteIOData->m_DataBuffer.MessageHeader.wHeaderCRC = static_cast<WORD>( GenerateCRC( reinterpret_cast<BYTE*>( &pWriteIOData->m_DataBuffer.MessageHeader ),
																						  ( sizeof( pWriteIOData->m_DataBuffer.MessageHeader) - sizeof( pWriteIOData->m_DataBuffer.MessageHeader.wHeaderCRC ) ) ) );


	DPFX(DPFPREP, 7, "(0x%p) Writing %u bytes (WriteData 0x%p, command = 0x%p, buffer = 0x%p).",
		this, dwByteCount, pWriteIOData, pWriteIOData->m_pCommand, &(pWriteIOData->m_DataBuffer) );


	AddRef();

#ifdef WIN95
	m_pSPData->GetThreadPool()->LockWriteData();
	DNASSERT( pWriteIOData->Win9xOperationPending() == FALSE );
	pWriteIOData->SetWin9xOperationPending( TRUE );
#endif
	DNASSERT( pWriteIOData->jkm_dwOverlappedBytesSent == 0 );
	pWriteIOData->SetDataPort( this );

	fWriteFileReturn = WriteFile( m_hFile,									// file handle
								  &pWriteIOData->m_DataBuffer,				// buffer to send
								  dwByteCount,								// bytes to send
								  &pWriteIOData->jkm_dwImmediateBytesSent,	// pointer to bytes written
								  pWriteIOData->Overlap() );				// pointer to overlapped structure
	if ( fWriteFileReturn == FALSE )
	{
		DWORD	dwError;


		//
		// send didn't complete immediately, find out why
		//
		dwError = GetLastError();
		switch ( dwError )
		{
			//
			// Write is queued, no problem.  Wait for asynchronous notification.
			//
			case ERROR_IO_PENDING:
			{
				break;
			}

			//
			// Other problem, stop if not 'known' to see if there's a better
			// error return.
			//
			default:
			{
				DPFX(DPFPREP,  0, "Problem with WriteFile!" );
				DisplayErrorCode( 0, dwError );
				pWriteIOData->jkm_hSendResult = DPNERR_NOCONNECTION;
				
				switch ( dwError )
				{
					case ERROR_INVALID_HANDLE:
					{
						break;
					}

					default:
					{
						DNASSERT( FALSE );
						break;
					}
				}

				//
				// fail the write
				//
				pWriteIOData->DataPort()->SendComplete( pWriteIOData, pWriteIOData->jkm_hSendResult );
					
				break;
			}
		}
	}
	else
	{
		//
		// Send completed immediately.  Wait for the asynchronous notification.
		//
	}

//Exit:
#ifdef WIN95
	m_pSPData->GetThreadPool()->UnlockWriteData();
#endif
//	SendData( NULL );

	return;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CDataPort::SendComplete - send has completed
//
// Entry:		Pointer to write data
//				Send result
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::SendComplete"

void	CDataPort::SendComplete( CWriteIOData *const pWriteIOData, const HRESULT hSendResult )
{
	HRESULT		hr;

	
	DNASSERT( pWriteIOData != NULL );
#ifdef WIN95
	DNASSERT( pWriteIOData->Win9xOperationPending() == FALSE );
#endif

	switch ( pWriteIOData->m_SendCompleteAction )
	{
		case SEND_COMPLETE_ACTION_COMPLETE_COMMAND:
		{
			DPFX(DPFPREP, 8, "Data port 0x%p completing send command 0x%p, hr = 0x%lx, context = 0x%p to interface 0x%p.",
				this, pWriteIOData->m_pCommand, hSendResult,
				pWriteIOData->m_pCommand->GetUserContext(),
				m_pSPData->DP8SPCallbackInterface());
			
			hr = IDP8SPCallback_CommandComplete( m_pSPData->DP8SPCallbackInterface(),			// pointer to callback interface
													pWriteIOData->m_pCommand,						// command handle
													hSendResult,									// error code
													pWriteIOData->m_pCommand->GetUserContext()		// user context
													);

			DPFX(DPFPREP, 8, "Data port 0x%p returning from command complete [0x%lx].", this, hr);
		
			break;
		}

		case SEND_COMPLETE_ACTION_NONE:
		{
			if (pWriteIOData->m_pCommand != NULL)
			{
				DPFX(DPFPREP, 8, "Data port 0x%p not completing send command 0x%p, hr = 0x%lx, context = 0x%p.",
					this, pWriteIOData->m_pCommand, hSendResult, pWriteIOData->m_pCommand->GetUserContext() );
			}
			else
			{
				DPFX(DPFPREP, 8, "Data port 0x%p not completing NULL send command, hr = 0x%lx",
					this, hSendResult );
			}
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	m_pSPData->GetThreadPool()->ReturnWriteIOData( pWriteIOData );
	DecRef();
}
//**********************************************************************




//**********************************************************************
// ------------------------------
// CDataPort::ProcessReceivedData - process received data
//
// Entry:		Count of bytes received
//				Error code
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDataPort::ProcessReceivedData"

void	CDataPort::ProcessReceivedData( const DWORD dwBytesReceived, const DWORD dwError )
{
	DNASSERT( m_pActiveRead != NULL );
	DNASSERT( dwBytesReceived <= m_pActiveRead->m_dwBytesToRead );

	//
	// If this data port is not actively receiving, returnt the active read to
	// the pool.  This happens on shutdown and when the modem disconnects.
	//
	if ( GetState() != DATA_PORT_STATE_RECEIVING )
	{
		DPFX(DPFPREP, 7, "Data port 0x%p not receiving, ignoring %u bytes received and err %u.",
			this, dwBytesReceived, dwError );
		
		if ( m_pActiveRead != NULL )
		{
#ifdef WIN95
			m_pActiveRead->SetWin9xOperationPending( FALSE );
#endif
			m_pActiveRead->DecRef();
			m_pActiveRead = NULL;
		}
		goto Exit;
	}

	switch ( dwError )
	{
		//
		// ERROR_OPERATION_ABORTED = something stopped operation, stop and look.
		//
		case ERROR_OPERATION_ABORTED:
		{
			DPFX(DPFPREP, 8, "Operation aborted, data port 0x%p, bytes received = %u.",
				this, dwBytesReceived );
			break;
		}
		
		//
		// ERROR_SUCCESS = data was received (may be 0 bytes from a timeout)
		//
		case ERROR_SUCCESS:
		{
			break;
		}

		//
		// other
		//
		default:
		{
			DNASSERT( FALSE );
			DPFX(DPFPREP,  0, "Failed read!" );
			DisplayErrorCode( 0, dwError );
			break;
		}
	}

	m_pActiveRead->m_dwBytesToRead -= dwBytesReceived;
	if ( m_pActiveRead->m_dwBytesToRead != 0 )
	{
		DPFX(DPFPREP, 7, "Data port 0x%p got %u bytes but there are %u bytes remaining to be read.",
			this, dwBytesReceived, m_pActiveRead->m_dwBytesToRead );
		
		m_pSPData->GetThreadPool()->ReinsertInReadList( m_pActiveRead );
		Receive();
	}
	else
	{
		//
		// all data has been read, attempt to process it
		//
		switch ( m_pActiveRead->m_ReadState )
		{
			//
			// Header.  Check header integrity before proceeding.  If the header
			// is bad, attempt to find another header signature and reread.
			//
			case READ_STATE_READ_HEADER:
			{
				WORD	wCRC;
				DWORD	dwCRCSize;


				DPFX(DPFPREP, 9, "Reading header.");

				DBG_CASSERT( OFFSETOF( MESSAGE_HEADER, SerialSignature ) == 0 );
				dwCRCSize = sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader ) - sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader.wHeaderCRC );
				wCRC = static_cast<WORD>( GenerateCRC( reinterpret_cast<BYTE*>( &m_pActiveRead->m_ReceiveBuffer.MessageHeader ), dwCRCSize ) );
				if ( ( m_pActiveRead->m_ReceiveBuffer.MessageHeader.SerialSignature != SERIAL_HEADER_START ) ||
					 ( wCRC != m_pActiveRead->m_ReceiveBuffer.MessageHeader.wHeaderCRC ) )
				{
					DWORD	dwIndex;


					DPFX(DPFPREP, 1, "Header failed signature or CRC check (%u != %u or %u != %u), searching for next header.",
						m_pActiveRead->m_ReceiveBuffer.MessageHeader.SerialSignature,
						SERIAL_HEADER_START, wCRC,
						m_pActiveRead->m_ReceiveBuffer.MessageHeader.wHeaderCRC);


					dwIndex = sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader.SerialSignature );
					while ( ( dwIndex < sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader ) ) &&
							( m_pActiveRead->m_ReceiveBuffer.ReceivedData[ dwIndex ] != SERIAL_HEADER_START ) )
					{
						dwIndex++;
					}

					m_pActiveRead->m_dwBytesToRead = dwIndex;
					m_pActiveRead->m_dwReadOffset = sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader ) - dwIndex;
					memcpy( &m_pActiveRead->m_ReceiveBuffer.ReceivedData,
							&m_pActiveRead->m_ReceiveBuffer.ReceivedData[ dwIndex ],
							sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader ) - dwIndex );
				}
				else
				{
					m_pActiveRead->SetReadState( READ_STATE_READ_DATA );
					m_pActiveRead->m_dwBytesToRead = m_pActiveRead->m_ReceiveBuffer.MessageHeader.wMessageSize;
					m_pActiveRead->m_dwReadOffset = sizeof( m_pActiveRead->m_ReceiveBuffer.MessageHeader );
				}
				
#ifdef WIN95
				m_pActiveRead->SetWin9xOperationPending( FALSE );
#endif
				m_pActiveRead->jkm_dwOverlappedBytesReceived = 0;
				m_pSPData->GetThreadPool()->ReinsertInReadList( m_pActiveRead );
				Receive();
				break;
			}

			//
			// Reading data.  Regardless of the validity of the data, start reading
			// another frame before processing the current data.  If the data is
			// valid, send it to a higher layer.
			//
			case READ_STATE_READ_DATA:
			{
				WORD		wCRC;
				CReadIOData	*pTempRead;


				pTempRead = m_pActiveRead;
				m_pActiveRead = NULL;
				Receive();


				DPFX(DPFPREP, 7, "Reading regular data.");

				DNASSERT( pTempRead->m_SPReceivedBuffer.BufferDesc.pBufferData == &pTempRead->m_ReceiveBuffer.ReceivedData[ sizeof( pTempRead->m_ReceiveBuffer.MessageHeader ) ] );
				wCRC = static_cast<WORD>( GenerateCRC( &pTempRead->m_ReceiveBuffer.ReceivedData[ sizeof( pTempRead->m_ReceiveBuffer.MessageHeader ) ],
													   pTempRead->m_ReceiveBuffer.MessageHeader.wMessageSize ) );
				if ( wCRC == pTempRead->m_ReceiveBuffer.MessageHeader.wMessageCRC )
				{
					pTempRead->m_SPReceivedBuffer.BufferDesc.dwBufferSize = pTempRead->m_ReceiveBuffer.MessageHeader.wMessageSize;
					
					Lock();
					switch ( pTempRead->m_ReceiveBuffer.MessageHeader.MessageTypeToken & ~( ENUM_RTT_MASK ) )
					{
						//
						// User data.  Send the data up the connection if there is
						// one, otherwise pass it up the listen.
						//
						case SERIAL_DATA_USER_DATA:
						{
							if ( m_hConnectEndpoint != INVALID_HANDLE_VALUE )
							{
								CEndpoint	*pEndpoint;


								pEndpoint = m_pSPData->EndpointFromHandle( m_hConnectEndpoint );
								Unlock();

								if ( pEndpoint != NULL )
								{
									pEndpoint->ProcessUserData( pTempRead );
									pEndpoint->DecCommandRef();
								}
							}
							else
							{
								if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
								{
									CEndpoint	*pEndpoint;


									pEndpoint = m_pSPData->EndpointFromHandle( m_hListenEndpoint );
									Unlock();

									if ( pEndpoint != NULL )
									{
										pEndpoint->ProcessUserDataOnListen( pTempRead );
										pEndpoint->DecCommandRef();
									}
								}
								else
								{
									//
									// no endpoint to handle data, drop it
									//
									Unlock();
								}
							}

							break;
						}

						//
						// Enum query.  Send it up the listen.
						//
						case SERIAL_DATA_ENUM_QUERY:
						{
							if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
							{
								CEndpoint	*pEndpoint;


								pEndpoint = m_pSPData->EndpointFromHandle( m_hListenEndpoint );
								Unlock();

								if ( pEndpoint != NULL )
								{
									pEndpoint->ProcessEnumData( &pTempRead->m_SPReceivedBuffer,
																pTempRead->m_ReceiveBuffer.MessageHeader.MessageTypeToken & ENUM_RTT_MASK );
									pEndpoint->DecCommandRef();
								}
							}
							else
							{
								//
								// no endpoint to handle data, drop it
								//
								Unlock();
							}

							break;
						}

						//
						// Enum response. Send it up the enum.
						//
						case SERIAL_DATA_ENUM_RESPONSE:
						{
							if ( m_hEnumEndpoint != INVALID_HANDLE_VALUE )
							{
								CEndpoint	*pEndpoint;


								pEndpoint = m_pSPData->EndpointFromHandle( m_hEnumEndpoint );
								Unlock();

								if ( pEndpoint != NULL )
								{
									pEndpoint->ProcessEnumResponseData( &pTempRead->m_SPReceivedBuffer,
																		pTempRead->m_ReceiveBuffer.MessageHeader.MessageTypeToken & ENUM_RTT_MASK );

									pEndpoint->DecCommandRef();
								}
							}
							else
							{
								//
								// no endpoint to handle data, drop it
								//
								Unlock();
							}
							
							break;
						}

						//
						// way busted message!
						//
						default:
						{
							Unlock();
							DNASSERT( FALSE );
							break;
						}
					}
				}
				else
				{
					DPFX(DPFPREP, 1, "Data failed CRC check (%u != %u).",
						wCRC, pTempRead->m_ReceiveBuffer.MessageHeader.wMessageCRC);
				}

				pTempRead->DecRef();

				break;
			}

			//
			// other state
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

Exit:
	DecRef();
	return;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dataport.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DataPort.h
 *  Content:	Serial communications port management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 *	09/14/99	jtk		Derived from ComPort.h
 ***************************************************************************/

#ifndef __DATA_PORT_H__
#define __DATA_PORT_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated values for state of data port
//
typedef	enum	_DATA_PORT_STATE
{
	DATA_PORT_STATE_UNKNOWN,		// unknown state
	DATA_PORT_STATE_INITIALIZED,	// initialized
	DATA_PORT_STATE_RECEIVING,		// data port is receiving data
	DATA_PORT_STATE_UNBOUND			// data port is unboind (closing)
} DATA_PORT_STATE;


//typedef	enum	_SEND_COMPLETION_CODE
//{
//	SEND_UNKNOWN,			// send is unknown
//	SEND_FAILED,			// send failed
//	SEND_IN_PROGRESS		// send is in progress
//} SEND_COMPLETION_CODE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CEndpoint;
class	CDataPort;
class	CReadIOData;
class	CWriteIOData;
typedef	enum	_ENDPOINT_TYPE	ENDPOINT_TYPE;
typedef	struct	_DATA_PORT_DIALOG_THREAD_PARAM	DATA_PORT_DIALOG_THREAD_PARAM;


//
// structure used to get date from the data port pool
//
typedef	struct	_DATA_PORT_POOL_CONTEXT
{
	CSPData	*pSPData;
} DATA_PORT_POOL_CONTEXT;

////
//// dialog function to call
////
//typedef	HRESULT	(*PDIALOG_SERVICE_FUNCTION)( const DATA_PORT_DIALOG_THREAD_PARAM *const pDialogData, HWND *const phDialog );
//
////
//// structure used to pass data to/from the data port dialog thread
////
//typedef	struct	_DATA_PORT_DIALOG_THREAD_PARAM
//{
//	CDataPort					*pDataPort;
//	BOOL						*pfDialogRunning;
//	PDIALOG_SERVICE_FUNCTION	pDialogFunction;
//} DATA_PORT_DIALOG_THREAD_PARAM;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CDataPort : public CLockedContextFixedPoolItem< DATA_PORT_POOL_CONTEXT* >
{
	public:
		CDataPort();
		virtual ~CDataPort();

		void	EndpointAddRef( void );
		DWORD	EndpointDecRef( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::Lock"
		void	Lock( void )
		{
		    DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
		    DNEnterCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::Unlock"
		void	Unlock( void )
		{
		    DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
		    DNLeaveCriticalSection( &m_Lock );
		}

		HANDLE	GetHandle( void ) const { return m_Handle; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetHandle"
		void	SetHandle( const HANDLE Handle )
		{
			DNASSERT( ( m_Handle == INVALID_HANDLE_VALUE ) || ( Handle == INVALID_HANDLE_VALUE ) );
			m_Handle = Handle;
		}
		
		DATA_PORT_STATE	GetState( void ) const { return m_State; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SetState"
		void	SetState( const DATA_PORT_STATE State )
		{
			//
			// Validate state transitions
			//
			DNASSERT( ( m_State == DATA_PORT_STATE_UNKNOWN ) ||
					  ( State == DATA_PORT_STATE_UNKNOWN ) ||
					  ( ( m_State == DATA_PORT_STATE_INITIALIZED ) && ( State == DATA_PORT_STATE_UNBOUND ) ) ||
					  ( ( m_State == DATA_PORT_STATE_INITIALIZED ) && ( State == DATA_PORT_STATE_RECEIVING ) ) ||
					  ( ( m_State == DATA_PORT_STATE_RECEIVING ) && ( State == DATA_PORT_STATE_UNBOUND ) ) ||
					  ( ( m_State == DATA_PORT_STATE_RECEIVING ) && ( State == DATA_PORT_STATE_INITIALIZED ) ) ||
					  ( ( m_State == DATA_PORT_STATE_INITIALIZED ) && ( State == DATA_PORT_STATE_INITIALIZED ) ) );		// modem failed to answer a call
			m_State = State;
		}

		CSPData	*GetSPData( void ) const { return m_pSPData; }

//		void	AddToActiveDataPortList( CBilink &List ) { m_ActiveListLinkage.InsertAfter( &List ); }
//		void	RemoveFromAciveDataPortList( void ) { m_ActiveListLinkage.RemoveFromList(); }
//		BOOL	ValidateCleanLinkage( void ) const { return m_ActiveListLinkage.IsEmpty(); }

//		virtual	HRESULT	DataPortFromDP8Address( IDirectPlay8Address *const pDP8Address, const LINK_DIRECTION LinkDirection ) = 0;
//		virtual	IDirectPlay8Address	*DP8AddressFromDataPort( void ) const = 0;
		LINK_DIRECTION	GetLinkDirection( void ) const { return m_LinkDirection; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SetLinkDirection"
		void	SetLinkDirection( const LINK_DIRECTION LinkDirection )
		{
			DNASSERT( ( m_LinkDirection == LINK_DIRECTION_UNKNOWN ) || ( LinkDirection == LINK_DIRECTION_UNKNOWN ) );
			m_LinkDirection = LinkDirection;
		}

		virtual	HRESULT	EnumAdapters( SPENUMADAPTERSDATA *const pEnumAdaptersData ) const = 0;
//		virtual	HRESULT	Open( void ) = 0;
//		virtual	HRESULT	Close( void ) = 0;

		virtual	HRESULT	BindToNetwork( const DWORD dwDeviceID, const void *const pDeviceContext ) = 0;
		virtual	void	UnbindFromNetwork( void ) = 0;

		virtual HRESULT	BindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType ) = 0;
		virtual void	UnbindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType ) = 0;
		HRESULT	SetPortCommunicationParameters( void );

		virtual	DWORD	GetDeviceID( void ) const = 0;
		virtual HRESULT	SetDeviceID( const DWORD dwDeviceID ) = 0;
		HANDLE	GetFileHandle( void ) const { return m_hFile; }

		//
		// send functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SendUserData"
		void	SendUserData( CWriteIOData *const pWriteIOData )
		{
			DNASSERT( pWriteIOData != NULL );
			DNASSERT( pWriteIOData->m_DataBuffer.MessageHeader.SerialSignature == SERIAL_HEADER_START );
			pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken = SERIAL_DATA_USER_DATA;
			SendData( pWriteIOData );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SendEnumQueryData"
		void	SendEnumQueryData( CWriteIOData *const pWriteIOData, const UINT_PTR uRTTIndex )
		{
			DNASSERT( pWriteIOData != NULL );
			DNASSERT( pWriteIOData->m_DataBuffer.MessageHeader.SerialSignature == SERIAL_HEADER_START );
			pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken = SERIAL_DATA_ENUM_QUERY | static_cast<BYTE>( uRTTIndex );
			SendData( pWriteIOData );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CDataPort::SendEnumResponseData"
		void	SendEnumResponseData( CWriteIOData *const pWriteIOData, const UINT_PTR uRTTIndex )
		{
			DNASSERT( pWriteIOData != NULL );
			DNASSERT( pWriteIOData->m_DataBuffer.MessageHeader.SerialSignature == SERIAL_HEADER_START );
			pWriteIOData->m_DataBuffer.MessageHeader.MessageTypeToken = SERIAL_DATA_ENUM_RESPONSE | static_cast<BYTE>( uRTTIndex );
			SendData( pWriteIOData );
		}

		//
		// UI functions
		//
//		virtual	HRESULT	ShowOutgoingSettingsDialog( void ) = 0;
//		virtual	HRESULT	ShowIncomingSettingsDialog( void ) = 0;
//		void	SetActiveDialogHandle( const HWND hDialog )
//		{
//		    DNASSERT( ( m_hActiveSettingsDialog == NULL ) || ( hDialog == NULL ) );
//		    m_hActiveSettingsDialog = hDialog;
//		}
		
//		void	WinNTReceiveComplete( CIOData *const pIOData, const DWORD dwBytesReceived, const BOOL fSuccess );
//		void	WinNTSendComplete( CIOData *const pIOData, const DWORD dwBytesSent, const BOOL fSuccess );
//		void	ProcessReceivedData( CReadIOData *const pReadIOData );
		void	ProcessReceivedData( const DWORD dwBytesReceived, const DWORD dwError );
//		void	SendFromWriteQueue( void );
		void	SendComplete( CWriteIOData *const pWriteIOData, const HRESULT hSendResult );

	protected:
		HRESULT	Initialize( CSPData *const pSPData );
		void	Deinitialize( void );
		CReadIOData	*GetActiveRead( void ) const { return m_pActiveRead; }

		CBilink				m_ActiveListLinkage;	// link to active data port list

    	//
    	// file I/O management parameters
    	//
    	LINK_DIRECTION	m_LinkDirection;	// direction of link

    	HANDLE			m_hFile;			// file handle for reading/writing data

		//
		// bound endpoints
		//
		HANDLE	m_hListenEndpoint;		// endpoint for active listen
		HANDLE	m_hConnectEndpoint;		// endpoint for active connect
		HANDLE	m_hEnumEndpoint;		// endpoint for active enum

		HRESULT	StartReceiving( void );
		HRESULT	Receive( void );

		//
		// private I/O functions
		//
		void	SendData( CWriteIOData *const pWriteIOData );

		//
		// debug only items
		//
		DEBUG_ONLY( BOOL	m_fInitialized );

	private:
		//
		// reference count and state
		//
		volatile LONG		m_EndpointRefCount;		// endpoint reference count
		volatile DATA_PORT_STATE	m_State;		// state of data port
		volatile HANDLE		m_Handle;				// handle

		DNCRITICAL_SECTION	m_Lock;					// critical section lock
		CSPData				*m_pSPData;				// pointer to SP data

		CReadIOData		*m_pActiveRead;				// pointer to current read

		//
		// prevent unwarranted copies
		//
		CDataPort( const CDataPort & );
		CDataPort& operator=( const CDataPort & );
};

#undef DPF_MODNAME

#endif	// __DATA_PORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dnmdmi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnmdmi.h
 *  Content:    DirectPlay Modem SP master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNMODEMI_H__
#define __DNMODEMI_H__

// 
// Public includes
//
#include <windows.h>
//#include <tapi.h>
//#define INCL_WINSOCK_API_TYPEDEFS 1
//#include <Winsock2.h>
//#include <WSIPX.h>
//#include <IPHlpApi.h>
//#include <WS2TCPIP.h>
#include <mmsystem.h>

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#include "dpsp8.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "classbilink.h"
#include "fpm.h"
#include "dneterrors.h"
#include "comutil.h"
#include "creg.h"
#include "LockedContextFixedPool.h"
#include "LockedPool.h"
#include "strutils.h"
#include "createin.h"

// 
// Modem private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

#include "SerialSP.h"

#include "dpnmodemlocals.h"

#include "CommandData.h"
#include "dpnmodemhandletable.h"
#include "dpnmodemiodata.h"
#include "dpnmodemjobqueue.h"
#include "dpnmodempools.h"
#include "dpnmodemsendqueue.h"
#include "dpnmodemspdata.h"
#include "dpnmodemutils.h"

#include "DataPort.h"

#include "dpnmodemendpoint.h"

#include "ComPortData.h"
#include "ComPort.h"
#include "ComEndpoint.h"
#include "ComPortUI.h"

#include "ContextFixedPool.h"
#include "dpnmodemthreadpool.h"

#include "ParseClass.h"

#include "ModemEndpoint.h"
#include "ModemPort.h"
#include "ModemUI.h"
#include "Crc.h"


#include "Resource.h"

#endif // __DNMODEMI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemendpoint.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Endpoint.cpp
 *  Content:	DNSerial communications endpoint base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CEndpoint - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CEndpoint"

CEndpoint::CEndpoint():
	m_pSPData( NULL ),	
	m_pCommandHandle( NULL ),
	m_Handle( INVALID_HANDLE_VALUE ),
	m_State( ENDPOINT_STATE_UNINITIALIZED ),
	m_lCommandRefCount( 0 ),
	m_EndpointType( ENDPOINT_TYPE_UNKNOWN ),
	m_pDataPort( NULL ),
	m_hPendingCommandResult( DPNERR_GENERIC ),
	m_hDisconnectIndicationHandle( INVALID_HANDLE_VALUE ),
	m_pUserEndpointContext( NULL ),
	m_hActiveDialogHandle( NULL ),
	m_dwEnumSendIndex( 0 )
{
	memset( &m_CurrentCommandParameters, 0x00, sizeof( m_CurrentCommandParameters ) );
	memset( &m_Flags, 0x00, sizeof( m_Flags ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::~CEndpoint - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::~CEndpoint"

CEndpoint::~CEndpoint()
{
	DNASSERT( m_pSPData == NULL );
	DNASSERT( m_Flags.fInitialized == FALSE );
	DNASSERT( m_Flags.fConnectIndicated == FALSE );
	DNASSERT( m_Flags.fCommandPending == FALSE );
	DNASSERT( m_Flags.fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( m_pCommandHandle == NULL );
	DNASSERT( m_Handle == INVALID_HANDLE_VALUE );
	DNASSERT( m_State == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( m_lCommandRefCount == 0 );
	DNASSERT( m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( m_pDataPort == NULL );
//	DNASSERT( m_hPendingCommandResult == DPNERR_GENERIC );	NOTE: PreFAST caught a bug here because == was =, but it now asserts.  Check intent.
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( m_pUserEndpointContext == NULL );
	DNASSERT( m_hActiveDialogHandle == NULL );
	DNASSERT( m_dwEnumSendIndex == 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Initialize - initialize
//
// Entry:		Pointer to SP data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Initialize"

HRESULT	CEndpoint::Initialize( CSPData *const pSPData )
{
	HRESULT	hr;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to initialize endpoint lock!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

	DNASSERT( m_pSPData == NULL );
	DNASSERT( m_pCommandHandle == NULL );
	DNASSERT( m_Flags.fCommandPending == FALSE );

	DNASSERT( GetType() == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( GetDataPort() == NULL );
	DNASSERT( CommandResult() == DPNERR_GENERIC );

	m_Flags.fInitialized = TRUE;

Exit:
	return	hr;

Failure:
	Deinitialize();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Deninitialize - deinitialize
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Deinitialize"

void	CEndpoint::Deinitialize( void )
{
	DNASSERT( m_Flags.fInitialized != FALSE );
	DNDeleteCriticalSection( &m_Lock );
	m_pSPData = NULL;
	
	DNASSERT( m_pCommandHandle == NULL );
	DNASSERT( m_Flags.fCommandPending == FALSE );

	SetState( ENDPOINT_STATE_UNINITIALIZED );
	SetType( ENDPOINT_TYPE_UNKNOWN );
	
	DNASSERT( GetDataPort() == NULL );
	m_Flags.fInitialized = FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CopyConnectData - copy data for connect command
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
//
// Note:	Since we've already initialized the local adapter, and we've either
//			completely parsed the host address (or are about to display a dialog
//			asking for more information), the address information doesn't need
//			to be copied.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyConnectData"

void	CEndpoint::CopyConnectData( const SPCONNECTDATA *const pConnectData )
{
	DNASSERT( GetType() == ENDPOINT_TYPE_CONNECT );
	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->hCommand != NULL );
	DNASSERT( pConnectData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_Flags.fCommandPending == FALSE );
	DNASSERT( m_pCommandHandle == NULL );

	DBG_CASSERT( sizeof( m_CurrentCommandParameters.ConnectData ) == sizeof( *pConnectData ) );
	memcpy( &m_CurrentCommandParameters.ConnectData, pConnectData, sizeof( m_CurrentCommandParameters.ConnectData ) );
	m_CurrentCommandParameters.ConnectData.pAddressHost = NULL;
	m_CurrentCommandParameters.ConnectData.pAddressDeviceInfo = NULL;

	m_Flags.fCommandPending = TRUE;
	m_pCommandHandle = static_cast<CCommandData*>( m_CurrentCommandParameters.ConnectData.hCommand );
	m_pCommandHandle->SetUserContext( pConnectData->pvContext );
	SetState( ENDPOINT_STATE_ATTEMPTING_CONNECT );
};
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ConnectJobCallback - asynchronous callback wrapper from work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ConnectJobCallback"

void	CEndpoint::ConnectJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->m_Flags.fCommandPending != FALSE );
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.ConnectData.hCommand == pThisEndpoint->m_pCommandHandle );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );

	hr = pThisEndpoint->CompleteConnect();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem completing connect in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	//
	// Don't do anything here because it's possible that this object was returned
	// to the pool!!!
	//

Exit:
	pThisEndpoint->DecRef();
	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CancelConnectJobCallback - cancel for connect job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CancelConnectJobCallback"

void	CEndpoint::CancelConnectJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_CONNECT );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	pThisEndpoint->m_pCommandHandle->Lock();
	DNASSERT( ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_PENDING ) ||
			  ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pCommandHandle->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pCommandHandle->Unlock();
	
	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->GetSPData()->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompleteConnect - complete connection
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
HRESULT	CEndpoint::CompleteConnect( void )
{
	HRESULT			hr;
	HRESULT			hTempResult;


	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( GetState() == ENDPOINT_STATE_ATTEMPTING_CONNECT );
	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );
	DNASSERT( m_CurrentCommandParameters.ConnectData.hCommand == m_pCommandHandle );
	DNASSERT( m_CurrentCommandParameters.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );

	
	//
	// check for user cancelling command
	//
	m_pCommandHandle->Lock();

	DNASSERT( m_pCommandHandle->GetType() == COMMAND_TYPE_CONNECT );
	switch ( m_pCommandHandle->GetState() )
	{
		//
		// Command is still pending, don't mark it as uninterruptable because
		// it might be cancelled before indicating the final connect.
		//
		case COMMAND_STATE_PENDING:
		{
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP,  0, "User cancelled connect!" );

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	m_pCommandHandle->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// find a dataport to bind with
	//
	hr = m_pSPData->BindEndpoint( this, GetDeviceID(), GetDeviceContext() );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to bind to data port in connect!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// The connect sequence will complete when the CDataPort indicates that the
	// outbound connection has been established.
	//

Exit:
	return	hr;

Failure:
	Close( hr );
	m_pSPData->CloseEndpointHandle( this );	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Disconnect - disconnect this endpoint
//
// Entry:		Old handle value
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Disconnect"

HRESULT	CEndpoint::Disconnect( const HANDLE hOldEndpointHandle )
{
	HRESULT	hr;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p)", this, hOldEndpointHandle );

	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();
	switch ( GetState() )
	{
		//
		// connected endpoint
		//
		case ENDPOINT_STATE_CONNECT_CONNECTED:
		{
			HRESULT	hTempResult;


			DNASSERT( m_Flags.fCommandPending == FALSE );
			DNASSERT( m_pCommandHandle == NULL );

			SetState( ENDPOINT_STATE_DISCONNECTING );
			AddRef();

			//
			// Unlock this endpoint before calling to a higher level.  The endpoint
			// has already been labeled as DISCONNECTING so nothing will happen to it.
			//
			Unlock();
				
			//
			// Note the old endpoint handle so it can be used in the disconnect
			// indication that will be given just before this endpoint is returned
			// to the pool.  Need to release the reference that was added for the
			// connection at this point or the endpoint will never be returned to
			// the pool.
			//
			SetDisconnectIndicationHandle( hOldEndpointHandle );
			DecRef();

			Close( DPN_OK );
			
			//
			// close outstanding reference for this command
			//
			DecCommandRef();
			DecRef();

			break;
		}

		//
		// endpoint waiting for the modem to pick up on the other end
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		{
			SetState( ENDPOINT_STATE_DISCONNECTING );
			AddRef();
			Unlock();
			
			Close( DPNERR_NOCONNECTION );
			
			//
			// close outstanding reference for this command
			//
			DecCommandRef();
			DecRef();
			
			break;
		}

		//
		// some other endpoint state
		//
		default:
		{
			hr = DPNERR_INVALIDENDPOINT;
			DPFX(DPFPREP,  0, "Attempted to disconnect endpoint that's not connected!" );
			switch ( m_State )
			{
				case ENDPOINT_STATE_UNINITIALIZED:
				{
					DPFX(DPFPREP,  0, "ENDPOINT_STATE_UNINITIALIZED" );
					break;
				}

				case ENDPOINT_STATE_ATTEMPTING_LISTEN:
				{
					DPFX(DPFPREP,  0, "ENDPOINT_STATE_ATTEMPTING_LISTEN" );
					break;
				}

				case ENDPOINT_STATE_ENUM:
				{
					DPFX(DPFPREP,  0, "ENDPOINT_STATE_ENUM" );
					break;
				}

				case ENDPOINT_STATE_DISCONNECTING:
				{
					DPFX(DPFPREP,  0, "ENDPOINT_STATE_DISCONNECTING" );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}
			
			Unlock();
			DNASSERT( FALSE );
			goto Failure;

			break;
		}
	}

Exit:
	
	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr );
	
	return	hr;

Failure:
	// nothing to do
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::StopEnumCommand - stop an enum job
//
// Entry:		Error code for completing command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::StopEnumCommand"

void	CEndpoint::StopEnumCommand( const HRESULT hCommandResult )
{
	Lock();
	DNASSERT( GetState() == ENDPOINT_STATE_DISCONNECTING );
	if ( m_hActiveDialogHandle != NULL )
	{
		StopSettingsDialog( m_hActiveDialogHandle );
		Unlock();
	}
	else
	{
		BOOL	fStoppedJob;

		
		Unlock();
		fStoppedJob = m_pSPData->GetThreadPool()->StopTimerJob( m_pCommandHandle, hCommandResult );
		if ( ! fStoppedJob )
		{
			DPFX(DPFPREP, 1, "Unable to stop timer job (context 0x%p) manually setting result to 0x%lx.",
				m_pCommandHandle, hCommandResult);
			
			//
			// Set the command result so it can be returned when the endpoint
			// reference count is zero.
			//
			SetCommandResult( hCommandResult );
		}
	}
	
	m_pSPData->CloseEndpointHandle( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SetState - set state of this endpoint
//
// Entry:		New state
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::SetState"

void	CEndpoint::SetState( const ENDPOINT_STATE EndpointState )
{
	DNASSERT( ( GetState() == ENDPOINT_STATE_UNINITIALIZED ) ||
			  ( EndpointState == ENDPOINT_STATE_UNINITIALIZED ) ||
			  ( ( m_State== ENDPOINT_STATE_ATTEMPTING_LISTEN ) && ( EndpointState == ENDPOINT_STATE_LISTENING ) ) ||
			  ( ( m_State == ENDPOINT_STATE_LISTENING ) && ( EndpointState == ENDPOINT_STATE_DISCONNECTING ) ) ||
			  ( ( m_State == ENDPOINT_STATE_ATTEMPTING_ENUM ) && ( EndpointState == ENDPOINT_STATE_ENUM ) ) ||
			  ( ( m_State == ENDPOINT_STATE_ENUM ) && ( EndpointState == ENDPOINT_STATE_DISCONNECTING ) ) ||
			  ( ( m_State == ENDPOINT_STATE_ATTEMPTING_ENUM ) && ( EndpointState == ENDPOINT_STATE_DISCONNECTING ) ) ||
			  ( ( m_State == ENDPOINT_STATE_ATTEMPTING_CONNECT ) && ( EndpointState == ENDPOINT_STATE_DISCONNECTING ) ) ||
			  ( ( m_State == ENDPOINT_STATE_CONNECT_CONNECTED ) && ( EndpointState == ENDPOINT_STATE_DISCONNECTING ) ) );
	m_State = EndpointState;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CopyListenData - copy data for listen command
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
//
// Note:	Since we've already initialized the local adapter, and we've either
//			completely parsed the host address (or are about to display a dialog
//			asking for more information), the address information doesn't need
//			to be copied.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyListenData"

void	CEndpoint::CopyListenData( const SPLISTENDATA *const pListenData )
{
	DNASSERT( GetType() == ENDPOINT_TYPE_LISTEN );
	DNASSERT( pListenData != NULL );
	DNASSERT( pListenData->hCommand != NULL );
	DNASSERT( pListenData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_Flags.fCommandPending == FALSE );
	DNASSERT( m_pCommandHandle == NULL );
	DNASSERT( m_Flags.fListenStatusNeedsToBeIndicated == FALSE );

	DBG_CASSERT( sizeof( m_CurrentCommandParameters.ListenData ) == sizeof( *pListenData ) );
	memcpy( &m_CurrentCommandParameters.ListenData, pListenData, sizeof( m_CurrentCommandParameters.ListenData ) );
	DEBUG_ONLY( m_CurrentCommandParameters.ListenData.pAddressDeviceInfo = NULL );

	m_Flags.fCommandPending = TRUE;
	m_Flags.fListenStatusNeedsToBeIndicated = TRUE;
	m_pCommandHandle = static_cast<CCommandData*>( m_CurrentCommandParameters.ListenData.hCommand );
	m_pCommandHandle->SetUserContext( pListenData->pvContext );
	
	SetState( ENDPOINT_STATE_ATTEMPTING_LISTEN );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ListenJobCallback - asynchronous callback wrapper for work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ListenJobCallback"

void	CEndpoint::ListenJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	// initialize
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->GetState() == ENDPOINT_STATE_ATTEMPTING_LISTEN );
	DNASSERT( pThisEndpoint->m_Flags.fCommandPending != NULL );
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.ListenData.hCommand == pThisEndpoint->m_pCommandHandle );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );

	hr = pThisEndpoint->CompleteListen();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem completing listen in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

Exit:
	pThisEndpoint->DecRef();

	//
	// Don't do anything here because it's possible that this object was returned
	// to the pool!!!!
	//

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CancelListenJobCallback - cancel for listen job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CancelListenJobCallback"

void	CEndpoint::CancelListenJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_LISTEN );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	pThisEndpoint->m_pCommandHandle->Lock();
	DNASSERT( ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_PENDING ) ||
			  ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pCommandHandle->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pCommandHandle->Unlock();

	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->GetSPData()->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompleteListen - complete listen process
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
HRESULT	CEndpoint::CompleteListen( void )
{
	HRESULT					hr;
	BOOL					fEndpointLocked;
	SPIE_LISTENSTATUS		ListenStatus;
	HRESULT					hTempResult;


	DNASSERT( GetState() == ENDPOINT_STATE_ATTEMPTING_LISTEN );

	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointLocked = FALSE;

	DNASSERT( GetState() == ENDPOINT_STATE_ATTEMPTING_LISTEN );
	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );
	DNASSERT( m_pCommandHandle->GetEndpoint() == this );
	DNASSERT( m_CurrentCommandParameters.ListenData.hCommand == m_pCommandHandle );
	DNASSERT( m_CurrentCommandParameters.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );
	
	
	//
	// check for user cancelling command
	//
	Lock();
	fEndpointLocked = TRUE;
	m_pCommandHandle->Lock();

	DNASSERT( m_pCommandHandle->GetType() == COMMAND_TYPE_LISTEN );
	switch ( m_pCommandHandle->GetState() )
	{
		//
		// command is pending, mark as in-progress and cancellable
		//
		case COMMAND_STATE_PENDING:
		{
			m_pCommandHandle->SetState( COMMAND_STATE_INPROGRESS );
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP,  0, "User cancelled listen!" );

			Unlock();
			fEndpointLocked = FALSE;
			
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			Unlock();
			fEndpointLocked = FALSE;
			
			break;
		}
	}
	m_pCommandHandle->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// find a dataport to bind with
	//
	hr = m_pSPData->BindEndpoint( this, GetDeviceID(), GetDeviceContext() );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to bind endpoint for serial listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// We're done and everyone's happy.  Listen commands never
	// complete until cancelled by the user.  Don't complete
	// the command at this point.
	//
	SetState( ENDPOINT_STATE_LISTENING );
	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );

Exit:
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}
	
	if ( m_Flags.fListenStatusNeedsToBeIndicated != FALSE )
	{
		m_Flags.fListenStatusNeedsToBeIndicated = FALSE;
		memset( &ListenStatus, 0x00, sizeof( ListenStatus ) );
		ListenStatus.hResult = hr;
		DNASSERT( m_pCommandHandle == m_CurrentCommandParameters.ListenData.hCommand );
		ListenStatus.hCommand = m_CurrentCommandParameters.ListenData.hCommand;
		ListenStatus.pUserContext = m_CurrentCommandParameters.ListenData.pvContext;
		ListenStatus.hEndpoint = GetHandle();
		DeviceIDToGuid( &ListenStatus.ListenAdapter, GetDeviceID(), GetEncryptionGuid() );

		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to DPlay callbacks
													SPEV_LISTENSTATUS,						// data type
													&ListenStatus							// pointer to data
													);
		DNASSERT( hTempResult == DPN_OK );
	}
	
	return	hr;

Failure:
	//
	// we've failed to complete the listen, clean up and return this
	// endpoint to the pool
	//
	Close( hr );
	
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CopyEnumQueryData - copy data for enum query command
//
// Entry:		Pointer to command data
//
// Exit:		Nothing
//
// Note:	Since we've already initialized the local adapter, and we've either
//			completely parsed the host address (or are about to display a dialog
//			asking for more information), the address information doesn't need
//			to be copied.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyEnumQueryData"

void	CEndpoint::CopyEnumQueryData( const SPENUMQUERYDATA *const pEnumQueryData )
{
	DNASSERT( GetType() == ENDPOINT_TYPE_ENUM );
	DNASSERT( pEnumQueryData != NULL );
	DNASSERT( pEnumQueryData->hCommand != NULL );
	DNASSERT( pEnumQueryData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_Flags.fCommandPending == FALSE );
	DNASSERT( m_pCommandHandle == NULL );

	DBG_CASSERT( sizeof( m_CurrentCommandParameters.EnumQueryData ) == sizeof( *pEnumQueryData ) );
	memcpy( &m_CurrentCommandParameters.EnumQueryData, pEnumQueryData, sizeof( m_CurrentCommandParameters.EnumQueryData ) );
	m_CurrentCommandParameters.EnumQueryData.pAddressHost = NULL;
	m_CurrentCommandParameters.EnumQueryData.pAddressDeviceInfo = NULL;

	m_Flags.fCommandPending = TRUE;
	m_pCommandHandle = static_cast<CCommandData*>( m_CurrentCommandParameters.EnumQueryData.hCommand );
	m_pCommandHandle->SetUserContext( pEnumQueryData->pvContext );
	SetState( ENDPOINT_STATE_ATTEMPTING_ENUM );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumQueryJobCallback - asynchronous callback wrapper for work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumQueryJobCallback"

void	CEndpoint::EnumQueryJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->m_Flags.fCommandPending != FALSE );
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.EnumQueryData.hCommand == pThisEndpoint->m_pCommandHandle );
	DNASSERT( pThisEndpoint->m_CurrentCommandParameters.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );

	hr = pThisEndpoint->CompleteEnumQuery();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem completing enum query in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	//
	// Don't do anything here because it's possible that this object was returned to the pool!!!!
	//
Exit:
	pThisEndpoint->DecRef();

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CancelEnumQueryJobCallback - cancel for enum query job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CancelEnumQueryJobCallback"

void	CEndpoint::CancelEnumQueryJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_ENUM );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pCommandHandle != NULL );
	pThisEndpoint->m_pCommandHandle->Lock();
	DNASSERT( ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_INPROGRESS ) ||
			  ( pThisEndpoint->m_pCommandHandle->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pCommandHandle->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pCommandHandle->Unlock();

	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->GetSPData()->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompleteEnumQuery - complete enum query process
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
HRESULT	CEndpoint::CompleteEnumQuery( void )
{
	HRESULT		hr;
	HRESULT		hTempResult;
	BOOL		fEndpointLocked;
	BOOL		fEndpointBound;
	CDataPort	*pDataPort;


	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointLocked = FALSE;
	fEndpointBound = FALSE;
	pDataPort = NULL;

	DNASSERT( GetState() == ENDPOINT_STATE_ATTEMPTING_ENUM );
	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );
	DNASSERT( m_pCommandHandle->GetEndpoint() == this );
	DNASSERT( m_CurrentCommandParameters.EnumQueryData.hCommand == m_pCommandHandle );
	DNASSERT( m_CurrentCommandParameters.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );

	//
	// check for user cancelling command
	//
	Lock();
	fEndpointLocked = TRUE;
	m_pCommandHandle->Lock();

	DNASSERT( m_pCommandHandle->GetType() == COMMAND_TYPE_ENUM_QUERY );
	switch ( m_pCommandHandle->GetState() )
	{
		//
		// command is still in progress
		//
		case COMMAND_STATE_INPROGRESS:
		{
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP,  0, "User cancelled enum query!" );
			Unlock();
			fEndpointLocked = FALSE;
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			Unlock();
			fEndpointLocked = FALSE;
			break;
		}
	}
	m_pCommandHandle->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// find a dataport to bind with
	//
	hr = m_pSPData->BindEndpoint( this, GetDeviceID(), GetDeviceContext() );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to bind to data port for EnumQuery!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	fEndpointBound = TRUE;

	SetState( ENDPOINT_STATE_ENUM );

Exit:
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}
	
	if ( pDataPort != NULL )
	{
		pDataPort->EndpointDecRef();
		pDataPort = NULL;
	}

	return	hr;

Failure:
	if ( fEndpointBound != FALSE )
	{
		DNASSERT( GetDataPort() != NULL );
		m_pSPData->UnbindEndpoint( this, GetType() );
		fEndpointBound = FALSE;
	}

	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

	Close( hr );
	m_pSPData->CloseEndpointHandle( this );
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::OutgoingConnectionEstablished - an outgoing connection was established
//
// Entry:		Command result (DPN_OK == connection succeeded)
//
// Exit:		Nothing
// ------------------------------
void	CEndpoint::OutgoingConnectionEstablished( const HRESULT hCommandResult )
{
	HRESULT			hr;
	CCommandData	*pCommandData;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%lx)", this, hCommandResult);

	pCommandData = GetCommandData();
	DNASSERT( pCommandData != NULL );
	
	//
	// check for successful connection
	//
	if ( hCommandResult != DPN_OK )
	{
		DNASSERT( FALSE );
		hr = hCommandResult;
		goto Failure;
	}
		
	//
	// determine which type of outgoing connection this is and complete it
	//
	switch ( GetType() )
	{
		case ENDPOINT_TYPE_CONNECT:
		{
			BOOL	fProceed;
			
			
			fProceed = TRUE;
			pCommandData->Lock();
			switch ( pCommandData->GetState() )
			{
				case COMMAND_STATE_PENDING:
				{
					pCommandData->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
					DNASSERT( fProceed != FALSE );
					break;
				}

				case COMMAND_STATE_CANCELLING:
				{
					fProceed = FALSE;
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}
			pCommandData->Unlock();

			if ( fProceed != FALSE )
			{
				SPIE_CONNECT	ConnectIndicationData;


				//
				// Inform user of connection.  Assume that the user will accept
				// and everything will succeed so we can set the user context
				// for the endpoint.  If the connection fails, clear the user
				// endpoint context.
				//
				memset( &ConnectIndicationData, 0x00, sizeof( ConnectIndicationData ) );
				DBG_CASSERT( sizeof( ConnectIndicationData.hEndpoint ) == sizeof( HANDLE ) );
				ConnectIndicationData.hEndpoint = GetHandle();
				ConnectIndicationData.pCommandContext = m_CurrentCommandParameters.ConnectData.pvContext;
				SetUserEndpointContext( ConnectIndicationData.pEndpointContext );

				hr = SignalConnect( &ConnectIndicationData );
				if ( hr != DPN_OK )
				{
					DNASSERT( hr == DPNERR_ABORTED );
					DPFX(DPFPREP,  0, "User refused connect in CompleteConnect!" );
					DisplayDNError( 0, hr );
					SetUserEndpointContext( NULL );
					goto Failure;
				}

				//
				// we're done and everyone's happy, complete the command, this
				// will clear all of our internal command data
				//
				CompletePendingCommand( hr );
				DNASSERT( m_Flags.fCommandPending == FALSE );
				DNASSERT( m_pCommandHandle == NULL );
			}

			break;
		}

		case ENDPOINT_TYPE_ENUM:
		{
			UINT_PTR	uRetryCount;
			BOOL		fRetryForever;
			DN_TIME		RetryInterval;
			BOOL		fWaitForever;
			DN_TIME		IdleTimeout;
			
			

			//
			// check retry to determine if we're enumerating forever
			//
			switch ( m_CurrentCommandParameters.EnumQueryData.dwRetryCount )
			{
				//
				// let SP determine retry count
				//
				case 0:
				{
					uRetryCount = DEFAULT_ENUM_RETRY_COUNT;
					fRetryForever = FALSE;
					break;
				}

				//
				// retry forever
				//
				case INFINITE:
				{
					uRetryCount = 1;
					fRetryForever = TRUE;
					break;
				}

				//
				// other
				//
				default:
				{
					uRetryCount = m_CurrentCommandParameters.EnumQueryData.dwRetryCount;
					fRetryForever = FALSE;
					break;
				}
			}

			//
			// check interval for default
			//
			RetryInterval.Time32.TimeHigh = 0;
			if ( m_CurrentCommandParameters.EnumQueryData.dwRetryInterval == 0 )
			{
				RetryInterval.Time32.TimeLow = DEFAULT_ENUM_RETRY_INTERVAL;
			}
			else
			{
				RetryInterval.Time32.TimeLow = m_CurrentCommandParameters.EnumQueryData.dwRetryInterval;
			}

			//
			// check timeout to see if we're waiting forever
			//
			switch ( m_CurrentCommandParameters.EnumQueryData.dwTimeout )
			{
				//
				// wait forever
				//
				case INFINITE:
				{
					fWaitForever = TRUE;
					IdleTimeout.Time32.TimeHigh = -1;
					IdleTimeout.Time32.TimeLow = -1;
					break;
				}

				//
				// possible default
				//
				case 0:
				{
					fWaitForever = FALSE;
					IdleTimeout.Time32.TimeHigh = 0;
					IdleTimeout.Time32.TimeLow = DEFAULT_ENUM_TIMEOUT;	
					break;
				}

				//
				// other
				//
				default:
				{
					fWaitForever = FALSE;
					IdleTimeout.Time32.TimeHigh = 0;
					IdleTimeout.Time32.TimeLow = m_CurrentCommandParameters.EnumQueryData.dwTimeout;
					break;
				}
			}

			m_dwEnumSendIndex = 0;
			memset( m_dwEnumSendTimes, 0, sizeof( m_dwEnumSendTimes ) );

			pCommandData->Lock();
			if ( pCommandData->GetState() == COMMAND_STATE_INPROGRESS )
			{
				//
				// add a reference for the timer job, must be cleaned on failure
				//
				AddRef();
				
				hr = m_pSPData->GetThreadPool()->SubmitTimerJob( uRetryCount,						// number of times to retry command
																 fRetryForever,						// retry forever
																 RetryInterval,						// retry interval
																 fWaitForever,						// wait forever after all enums sent
																 IdleTimeout,						// timeout to wait after command complete
																 CEndpoint::EnumTimerCallback,		// function called when timer event fires
																 CEndpoint::EnumCompleteWrapper,	// function called when timer event expires
																 m_pCommandHandle );				// context
				if ( hr != DPN_OK )
				{
					pCommandData->Unlock();
					DPFX(DPFPREP,  0, "Failed to spool enum job on work thread!" );
					DisplayDNError( 0, hr );
					DecRef();

					goto Failure;
				}

				//
				// if everything is a success, we should still have an active command
				//
				DNASSERT( m_Flags.fCommandPending != FALSE );
				DNASSERT( m_pCommandHandle != NULL );
			}
			
			pCommandData->Unlock();
			
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:

	DPFX(DPFPREP, 6, "(0x%p) Returning", this);
	
	return;

Failure:
	DNASSERT( FALSE );
	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumCompleteWrapper - this enum has expired
//
// Entry:		Error code
//				Context (command pointer)
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumCompleteWrapper"

void	CEndpoint::EnumCompleteWrapper( const HRESULT hResult, void *const pContext )
{
	CCommandData	*pCommandData;


	DNASSERT( pContext != NULL );
	pCommandData = static_cast<CCommandData*>( pContext );
	pCommandData->GetEndpoint()->EnumComplete( hResult );
	pCommandData->GetEndpoint()->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumTimerCallback - timed callback to send enum data
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumTimerCallback"

void	CEndpoint::EnumTimerCallback( void *const pContext )
{
	CCommandData	*pCommandData;
	CEndpoint		*pThisObject;
	CWriteIOData	*pWriteData;


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	pCommandData = static_cast<CCommandData*>( pContext );
	pThisObject = pCommandData->GetEndpoint();
	pWriteData = NULL;

	pThisObject->Lock();

	switch ( pThisObject->m_State )
	{
		//
		// we're enumerating (as expected)
		//
		case ENDPOINT_STATE_ENUM:
		{
			break;
		}

		//
		// this endpoint is disconnecting, bail!
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			pThisObject->Unlock();
			goto Exit;

			break;
		}

		//
		// there's a problem
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	pThisObject->Unlock();

	//
	// attempt to get a new IO buffer for this endpoint
	//
	pWriteData = pThisObject->m_pSPData->GetThreadPool()->CreateWriteIOData();
	if ( pWriteData == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to get write data for an enum!" );
		goto Failure;
	}

	//
	// Set all data for the write.  Since this is an enum and we
	// don't care about the outgoing data so don't send an indication
	// when it completes.
	//
	DNASSERT( pThisObject->m_Flags.fCommandPending != FALSE );
	DNASSERT( pThisObject->m_pCommandHandle != NULL );
	DNASSERT( pThisObject->GetState() == ENDPOINT_STATE_ENUM );
	pWriteData->m_pBuffers = pThisObject->m_CurrentCommandParameters.EnumQueryData.pBuffers;
	pWriteData->m_uBufferCount = pThisObject->m_CurrentCommandParameters.EnumQueryData.dwBufferCount;
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_NONE;

	DNASSERT( pWriteData->m_pCommand != NULL );
	DNASSERT( pWriteData->m_pCommand->GetUserContext() == NULL );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );

	DNASSERT( pThisObject->GetDataPort() != NULL );
	pThisObject->m_dwEnumSendIndex++;
	pThisObject->m_dwEnumSendTimes[ pThisObject->m_dwEnumSendIndex & ENUM_RTT_MASK ] = GETTIMESTAMP();
	pThisObject->m_pDataPort->SendEnumQueryData( pWriteData,
												 ( pThisObject->m_dwEnumSendIndex & ENUM_RTT_MASK ) );

Exit:
	return;

Failure:
	// nothing to clean up at this time

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SignalConnect - note connection
//
// Entry:		Pointer to connect data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::SignalConnect"

HRESULT	CEndpoint::SignalConnect( SPIE_CONNECT *const pConnectData )
{
	HRESULT	hr;


	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->hEndpoint == GetHandle() );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// initialize
	//
	hr = DPN_OK;

	switch ( m_State )
	{
		//
		// disconnecting, nothing to do
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			goto Exit;
			break;
		}

		//
		// we're attempting to connect
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		{
			DNASSERT( m_Flags.fConnectIndicated == FALSE );
			hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// interface
											   SPEV_CONNECT,							// event type
											   pConnectData								// pointer to data
											   );
			switch ( hr )
			{
				//
				// connection accepted
				//
				case DPN_OK:
				{
					//
					// note that we're connected
					//
					SetUserEndpointContext( pConnectData->pEndpointContext );
					m_Flags.fConnectIndicated = TRUE;
					m_State = ENDPOINT_STATE_CONNECT_CONNECTED;
					AddRef();

					break;
				}

				//
				// user aborted connection attempt, nothing to do, just pass
				// the result on
				//
				case DPNERR_ABORTED:
				{
					DNASSERT( GetUserEndpointContext() == NULL );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// states where we shouldn't be getting called
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SignalDisconnect - note disconnection
//
// Entry:		Old endpoint handle
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::SignalDisconnect"

void	CEndpoint::SignalDisconnect( const HANDLE hOldEndpointHandle )
{
	HRESULT	hr;
	SPIE_DISCONNECT	DisconnectData;


	// tell user that we're disconnecting
	DNASSERT( m_Flags.fConnectIndicated != FALSE );
	DBG_CASSERT( sizeof( DisconnectData.hEndpoint ) == sizeof( this ) );
	DisconnectData.hEndpoint = this;
	DisconnectData.pEndpointContext = GetUserEndpointContext();
	m_Flags.fConnectIndicated = FALSE;
	DNASSERT( m_pSPData != NULL );
	hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// callback interface
									   SPEV_DISCONNECT,					    	// event type
									   &DisconnectData					    	// pointer to data
									   );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with SignalDisconnect!" );
		DisplayDNError( 0, hr );
		DNASSERT( FALSE );
	}

	SetDisconnectIndicationHandle( INVALID_HANDLE_VALUE );

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CleanUpCommand - perform cleanup now that the command on this
//		endpoint is essentially complete.  There may be outstanding references,
//		but nobody will be asking the endpoint to do anything else.
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void	CEndpoint::CleanUpCommand( void )
{
	DPFX(DPFPREP, 6, "(0x%p) Enter", this );

	
	if ( GetDataPort() != NULL )
	{
		DNASSERT( m_pSPData != NULL );
		m_pSPData->UnbindEndpoint( this, GetType() );
	}

	//
	// If we're bailing here it's because the UI didn't complete.  There is no
	// adapter guid to return because one may have not been specified.  Return
	// a bogus endpoint handle so it can't be queried for addressing data.
	//
	if ( m_Flags.fListenStatusNeedsToBeIndicated != FALSE )
	{
		HRESULT				hTempResult;
		SPIE_LISTENSTATUS	ListenStatus;
		

		memset( &ListenStatus, 0x00, sizeof( ListenStatus ) );
		ListenStatus.hCommand = m_pCommandHandle;
		ListenStatus.hEndpoint = INVALID_HANDLE_VALUE;
		ListenStatus.hResult = CommandResult();
		memset( &ListenStatus.ListenAdapter, 0x00, sizeof( ListenStatus.ListenAdapter ) );
		ListenStatus.pUserContext = m_pCommandHandle->GetUserContext();

		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to DPlay callbacks
													SPEV_LISTENSTATUS,						// data type
													&ListenStatus							// pointer to data
													);
		DNASSERT( hTempResult == DPN_OK );

		m_Flags.fListenStatusNeedsToBeIndicated = FALSE;
	}

	SetHandle( INVALID_HANDLE_VALUE );
	SetState( ENDPOINT_STATE_UNINITIALIZED );

	
	DPFX(DPFPREP, 6, "(0x%p) Leave", this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessEnumData - process received enum data
//
// Entry:		Pointer to received data
//				Enum RTT index
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessEnumData"

void	CEndpoint::ProcessEnumData( SPRECEIVEDBUFFER *const pReceivedBuffer, const UINT_PTR uEnumRTTIndex )
{
	DNASSERT( pReceivedBuffer != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// find out what state the endpoint is in before processing data
	//
	switch ( m_State )
	{
		//
		// we're listening, this is the only way to detect enums
		//
		case ENDPOINT_STATE_LISTENING:
		{
			ENDPOINT_ENUM_QUERY_CONTEXT	QueryContext;
			HRESULT		hr;


			DNASSERT( m_pCommandHandle != NULL );
			DEBUG_ONLY( memset( &QueryContext, 0x00, sizeof( QueryContext ) ) );

			QueryContext.hEndpoint = GetHandle();
			QueryContext.uEnumRTTIndex = uEnumRTTIndex;
			QueryContext.EnumQueryData.pReceivedData = pReceivedBuffer;
			QueryContext.EnumQueryData.pUserContext = m_pCommandHandle->GetUserContext();
	
			QueryContext.EnumQueryData.pAddressSender = GetRemoteHostDP8Address();
			QueryContext.EnumQueryData.pAddressDevice = GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );

			//
			// attempt to build a DNAddress for the user, if we can't allocate
			// the memory ignore this enum
			//
			if ( ( QueryContext.EnumQueryData.pAddressSender != NULL ) &&
				 ( QueryContext.EnumQueryData.pAddressDevice != NULL ) )
			{
				hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet interface
												   SPEV_ENUMQUERY,							// data type
												   &QueryContext.EnumQueryData				// pointer to data
												   );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP,  0, "User returned unexpected error from enum query indication!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );
				}
			}

			if ( QueryContext.EnumQueryData.pAddressSender != NULL )
			{
				IDirectPlay8Address_Release( QueryContext.EnumQueryData.pAddressSender );
				QueryContext.EnumQueryData.pAddressSender = NULL;
			}

			if ( QueryContext.EnumQueryData.pAddressDevice )
			{
				IDirectPlay8Address_Release( QueryContext.EnumQueryData.pAddressDevice );
				QueryContext.EnumQueryData.pAddressDevice = NULL;
			}

			break;
		}

		//
		// we're disconnecting, ignore this message
		//
		case ENDPOINT_STATE_ATTEMPTING_LISTEN:
		case ENDPOINT_STATE_DISCONNECTING:
		{
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessEnumResponseData - process received enum response data
//
// Entry:		Pointer to received data
//				Pointer to address of sender
//
// Exit:		Nothing
//
// Note:	This function assumes that the endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessEnumResponseData"

void	CEndpoint::ProcessEnumResponseData( SPRECEIVEDBUFFER *const pReceivedBuffer, const UINT_PTR uRTTIndex )
{
	DNASSERT( pReceivedBuffer != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// find out what state the endpoint is in before processing data
	//
	switch ( m_State )
	{
		//
		// endpoint is enuming, it can handle enum responses
		//
		case ENDPOINT_STATE_ENUM:
		{
			SPIE_QUERYRESPONSE	QueryResponseData;
			HRESULT	hr;


			DNASSERT( m_pCommandHandle != NULL );
			DEBUG_ONLY( memset( &QueryResponseData, 0x00, sizeof( QueryResponseData ) ) );
			QueryResponseData.pReceivedData = pReceivedBuffer;
			QueryResponseData.dwRoundTripTime = GETTIMESTAMP() - m_dwEnumSendTimes[ uRTTIndex ];
			QueryResponseData.pUserContext = m_pCommandHandle->GetUserContext();

			//
			// attempt to build a DNAddress for the user, if we can't allocate
			// the memory ignore this enum
			//
			QueryResponseData.pAddressSender = GetRemoteHostDP8Address();
			QueryResponseData.pAddressDevice = GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );
			if ( ( QueryResponseData.pAddressSender != NULL ) &&
				 ( QueryResponseData.pAddressDevice != NULL ) )
			{
				hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet interface
												   SPEV_QUERYRESPONSE,						// data type
												   &QueryResponseData						// pointer to data
												   );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP,  0, "User returned unknown error when indicating query response!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );
				}

			}

			if ( QueryResponseData.pAddressSender != NULL )
			{
				IDirectPlay8Address_Release( QueryResponseData.pAddressSender );
				QueryResponseData.pAddressSender = NULL;
			}
			
			if ( QueryResponseData.pAddressDevice != NULL )
			{
				IDirectPlay8Address_Release( QueryResponseData.pAddressDevice );
				QueryResponseData.pAddressDevice = NULL;
			}

			break;
		}

		//
		// endpoint is disconnecting, ignore data
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessUserData - process received user data
//
// Entry:		Pointer to received data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessUserData"

void	CEndpoint::ProcessUserData( CReadIOData *const pReadData )
{
	DNASSERT( pReadData != NULL );

	switch ( m_State )
	{
		//
		// endpoint is connected
		//
		case ENDPOINT_STATE_CONNECT_CONNECTED:
		{
			HRESULT		hr;
			SPIE_DATA	UserData;


			//
			// it's possible that the user wants to keep the data, add a
			// reference to keep it from going away
			//
			pReadData->AddRef();

			//
			// we're connected, report the user data
			//
			DEBUG_ONLY( memset( &UserData, 0x00, sizeof( UserData ) ) );
			DBG_CASSERT( sizeof( this ) == sizeof( HANDLE ) );
			UserData.hEndpoint = GetHandle();
			UserData.pEndpointContext = GetUserEndpointContext();
			UserData.pReceivedData = &pReadData->m_SPReceivedBuffer;

			DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_DATA 0x%p to interface 0x%p.",
				this, &UserData, m_pSPData->DP8SPCallbackInterface());
			
			hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to interface
											   SPEV_DATA,								// user data was received
											   &UserData								// pointer to data
											   );
			
			DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_DATA [0x%lx].", this, hr);
			
			switch ( hr )
			{
				//
				// user didn't keep the data, remove the reference added above
				//
				case DPN_OK:
				{
					DNASSERT( pReadData != NULL );
					pReadData->DecRef();
					break;
				}

				//
				// The user kept the data buffer, they will return it later.
				// Leave the reference to prevent this buffer from being returned
				// to the pool.
				//
				case DPNERR_PENDING:
				{
					break;
				}


				//
				// Unknown return.  Remove the reference added above.
				//
				default:
				{
					DNASSERT( pReadData != NULL );
					pReadData->DecRef();

					DPFX(DPFPREP,  0, "User returned unknown error when indicating user data!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );

					break;
				}
			}

			break;
		}

		//
		// Endpoint disconnecting, or we haven't finished acknowledging a connect,
		// ignore data.
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		case ENDPOINT_STATE_DISCONNECTING:
		{
			DPFX(DPFPREP, 3, "Endpoint 0x%p ignoring data, state = %u.", this, m_State );
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessUserDataOnListen - process received user data on a listen
//		port that may result in a new connection
//
// Entry:		Pointer to received data
//
// Exit:		Nothing
//
// Note:	This function assumes that this endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessUserDataOnListen"

void	CEndpoint::ProcessUserDataOnListen( CReadIOData *const pReadData )
{
	HRESULT			hr;
	CEndpoint		*pNewEndpoint;
	SPIE_CONNECT	ConnectData;
	BOOL			fEndpointBound;


	DNASSERT( pReadData != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	DPFX(DPFPREP,  8, "Reporting connect on a listen!" );

	//
	// initialize
	//
	pNewEndpoint = NULL;
	fEndpointBound = FALSE;

	switch ( m_State )
	{
		//
		// this endpoint is still listening
		//
		case ENDPOINT_STATE_LISTENING:
		{
			break;
		}

		//
		// we're unable to process this user data, exti
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			goto Exit;

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// get a new endpoint from the pool
	//
	pNewEndpoint = m_pSPData->GetNewEndpoint();
	if ( pNewEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Could not create new endpoint for new connection on listen!" );
		goto Failure;
	}


	//
	// We are adding this endpoint to the hash table and indicating it up
	// to the user, so it's possible that it could be disconnected (and thus
 	// removed from the table) while we're still in here.  We need to
 	// hold an additional reference for the duration of this function to
  	// prevent it from disappearing while we're still indicating data.
	//
	pNewEndpoint->AddCommandRef();


	//
	// open this endpoint as a new connection, since the new endpoint
	// is related to 'this' endpoint, copy local information
	//
	hr = pNewEndpoint->OpenOnListen( this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem initializing new endpoint when indicating connect on listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// Attempt to bind this endpoint to the socket port.  This will reserve our
	// slot before we notify the user.  If another message is attempting this same
	// procedure we won't be able to add this endpoint and we'll bail on the message.
	//
	DNASSERT( hr == DPN_OK );
	hr = m_pSPData->BindEndpoint( pNewEndpoint, pNewEndpoint->GetDeviceID(), pNewEndpoint->GetDeviceContext() );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to bind endpoint to dataport on new connect from listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	fEndpointBound = TRUE;

	//
	// Indicate connect on this endpoint.
	//
	DEBUG_ONLY( memset( &ConnectData, 0x00, sizeof( ConnectData ) ) );
	DBG_CASSERT( sizeof( ConnectData.hEndpoint ) == sizeof( pNewEndpoint ) );
	ConnectData.hEndpoint = pNewEndpoint->GetHandle();

	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );
	ConnectData.pCommandContext = m_CurrentCommandParameters.ListenData.pvContext;

	DNASSERT( pNewEndpoint->GetUserEndpointContext() == NULL );
	hr = pNewEndpoint->SignalConnect( &ConnectData );
	switch ( hr )
	{
		//
		// user accepted new connection
		//
		case DPN_OK:
		{
			//
			// fall through to code below
			//

			break;
		}

		//
		// user refused new connection
		//
		case DPNERR_ABORTED:
		{
			DNASSERT( pNewEndpoint->GetUserEndpointContext() == NULL );
			DPFX(DPFPREP,  8, "User refused new connection!" );
			goto Failure;

			break;
		}

		//
		// other
		//
		default:
		{
			DPFX(DPFPREP,  0, "Unknown return when indicating connect event on new connect from listen!" );
			DisplayDNError( 0, hr );
			DNASSERT( FALSE );

			break;
		}
	}

	//
	// note that a connection has been establised and send the data received
	// through this new endpoint
	//
	pNewEndpoint->ProcessUserData( pReadData );


	//
	// Remove the reference we added just after creating the endpoint.
	//
	pNewEndpoint->DecCommandRef();
	pNewEndpoint = NULL;

Exit:
	return;

Failure:
	if ( pNewEndpoint != NULL )
	{
		if ( fEndpointBound != FALSE )
		{
			m_pSPData->UnbindEndpoint( pNewEndpoint, ENDPOINT_TYPE_CONNECT );
			fEndpointBound = FALSE;
		}

		//
		// closing endpoint decrements reference count and may return it to the pool
		//
		pNewEndpoint->Close( hr );
		m_pSPData->CloseEndpointHandle( pNewEndpoint );
		pNewEndpoint->DecCommandRef();	// remove reference added just after creating endpoint
		pNewEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SettingsDialogComplete - dialog has completed
//
// Entry:		Error code for dialog
//
// Exit:		Nothing
// ------------------------------
void	CEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
{
	HRESULT					hr;


	//
	// initialize
	//
	hr = hDialogResult;

	//
	// since the dialog is exiting, clear our handle to the dialog
	//
	m_hActiveDialogHandle = NULL;

	//
	// dialog failed, fail the user's command
	//
	if ( hr != DPN_OK )
	{
		if ( hr != DPNERR_USERCANCEL)
		{
			DPFX(DPFPREP,  0, "Failing dialog!" );
			DisplayErrorCode( 0, hr );
		}

		goto Failure;
	}

	AddRef();

	//
	// the remote machine address has been adjusted, finish the command
	//
	switch ( GetType() )
	{
	    case ENDPOINT_TYPE_ENUM:
	    {
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( EnumQueryJobCallback,
																   CancelEnumQueryJobCallback,
																   this );
			if ( hr != DPN_OK )
			{
				DecRef();
				DPFX(DPFPREP,  0, "Failed to set delayed enum query!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

	    	break;
	    }

	    case ENDPOINT_TYPE_CONNECT:
	    {
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( ConnectJobCallback,
																   CancelConnectJobCallback,
																   this );
			if ( hr != DPN_OK )
			{
				DecRef();
				DPFX(DPFPREP,  0, "Failed to set delayed connect!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

	    	break;
	    }

		case ENDPOINT_TYPE_LISTEN:
		{
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( ListenJobCallback,
																   CancelListenJobCallback,
																   this );
			if ( hr != DPN_OK )
			{
				DecRef();
				DPFX(DPFPREP,  0, "Failed to set delayed listen!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			break;
		}

	    //
	    // unknown!
	    //
	    default:
	    {
	    	DNASSERT( FALSE );
	    	hr = DPNERR_GENERIC;
	    	goto Failure;

	    	break;
	    }
	}

Exit:
	DecRef();

	return;

Failure:
	//
	// close this endpoint
	//
	Close( hr );
	m_pSPData->CloseEndpointHandle( this );
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompletePendingCommand - complete an internal commad
//
// Entry:		Error code returned for command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompletePendingCommand"

void	CEndpoint::CompletePendingCommand( const HRESULT hr )
{
	DNASSERT( m_Flags.fCommandPending != FALSE );
	DNASSERT( m_pCommandHandle != NULL );

	DNASSERT( m_pSPData != NULL );

	
	DPFX(DPFPREP, 5, "Endpoint 0x%p completing command handle 0x%p (result = 0x%lx, user context 0x%p) to interface 0x%p.",
		this, m_pCommandHandle, hr,
		m_pCommandHandle->GetUserContext(),
		m_pSPData->DP8SPCallbackInterface());

	IDP8SPCallback_CommandComplete( m_pSPData->DP8SPCallbackInterface(),	// pointer to SP callbacks
									m_pCommandHandle,			    		// command handle
									hr,								    	// return
									m_pCommandHandle->GetUserContext()		// user cookie
									);

	DPFX(DPFPREP, 5, "Endpoint 0x%p returning from command complete [0x%lx].", this, hr);


	m_Flags.fCommandPending = FALSE;
	m_pCommandHandle->DecRef();
	m_pCommandHandle = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::GetLinkDirection - get link direction for this endpoint
//
// Entry:		Nothing
//
// Exit:		Link direction
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::GetLinkDirection"

LINK_DIRECTION	CEndpoint::GetLinkDirection( void ) const
{
	LINK_DIRECTION	LinkDirection;


	LinkDirection = LINK_DIRECTION_OUTGOING;
	
	switch ( GetType() )
	{
		case ENDPOINT_TYPE_LISTEN:
		{
			LinkDirection = LINK_DIRECTION_INCOMING;			
			break;
		}

		//
		// connect and enum are outgoing
		//
		case ENDPOINT_TYPE_CONNECT:
		case ENDPOINT_TYPE_ENUM:
		{
			DNASSERT( LinkDirection == LINK_DIRECTION_OUTGOING );
			break;
		}

		//
		// shouldn't be here
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return	LinkDirection;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemhandletable.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		HandleTable.h
 *  Content:	DNSerial communications handle table
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/15/2000	jtk		Created
 ***************************************************************************/

#ifndef __HANDLE_TABLE_H__
#define __HANDLE_TABLE_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward srtucture references
//
typedef	struct	_HANDLE_TABLE_ENTRY	HANDLE_TABLE_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CHandleTable
{
	public:
		CHandleTable();
		virtual	~CHandleTable();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CHandleTable::Lock"
		void	Lock( void )
		{
			DNASSERT( m_fInitialized != FALSE );
			DNEnterCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CHandleTable::Unlock"
		void	Unlock( void )
		{
			DNASSERT( m_fInitialized != FALSE );
			DNLeaveCriticalSection( &m_Lock );
		}

		HRESULT	Initialize( void );
		void	Deinitialize( void );

		HRESULT	CreateHandle( HANDLE *const pHandle, void *const pContext );
		BOOL	InvalidateHandle( const HANDLE Handle );
		void	*GetAssociatedData( const HANDLE Handle ) const;

	private:
		DNCRITICAL_SECTION	m_Lock;	   		// critical section
		
		DWORD_PTR	m_AllocatedEntries;
		DWORD_PTR	m_EntriesInUse;
		DWORD_PTR	m_FreeIndex;
		HANDLE_TABLE_ENTRY	*m_pEntries;

		//
		// initialization state booleans
		//
		BOOL	m_fLockInitialized;
		
		HRESULT	Grow( void );
		
		
		DEBUG_ONLY(	BOOL	m_fInitialized );
		
		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CHandleTable( const CHandleTable & );
		CHandleTable& operator=( const CHandleTable & );
};

#undef DPF_MODNAME

#endif	// __HANDLE_TABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemiodata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IOData.cpp
 *  Content:	Functions for IO structures
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 *	02/11/2000	jtk		Derived from IODAta.h
 ***************************************************************************/

#include "dnmdmi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// ------------------------------
// CIOData::CIOData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIOData::CIOData"

CIOData::CIOData():
#ifdef WINNT
	m_NTIOOperationType( NT_IO_OPERATION_UNKNOWN ),
#endif
#ifdef WIN95
	m_fWin9xOperationPending( FALSE ),
#endif
	m_pDataPort( NULL )
{
	memset( &m_Overlap, 0x00, sizeof( m_Overlap ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIOData::~CIOData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIOData::~CIOData"

CIOData::~CIOData()
{
	DNASSERT( DataPort() == NULL );
#ifdef WIN95
	DNASSERT( OverlapEvent() == NULL );
	DNASSERT( Win9xOperationPending() == FALSE );
#endif
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::CReadIOData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CReadIOData::CReadIOData"

CReadIOData::CReadIOData():
	m_dwWin9xReceiveErrorReturn( ERROR_SUCCESS ),
	jkm_dwOverlappedBytesReceived( 0 ),
	jkm_dwImmediateBytesReceived( 0 ),
	m_ReadState( READ_STATE_UNKNOWN ),
	m_dwBytesToRead( 0 ),
	m_dwReadOffset( 0 ),
	m_lRefCount( 0 ),
	m_pThreadPool( NULL )
{
	m_Sig[0] = 'R';
	m_Sig[1] = 'I';
	m_Sig[2] = 'O';
	m_Sig[3] = 'D';
	
	m_OutstandingReadListLinkage.Initialize();
	memset( &m_ReceiveBuffer, 0x00, sizeof( m_ReceiveBuffer ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::~CReadIOData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CReadIOData::~CReadIOData"

CReadIOData::~CReadIOData()
{
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );

	DNASSERT( m_ReadState == READ_STATE_UNKNOWN );
	DNASSERT( m_dwBytesToRead == 0 );
	DNASSERT( m_dwReadOffset == 0 );
	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_pThreadPool == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::PoolAllocFunction - called when new CReadIOData is allocated
//
// Entry:		Context (handle of read complete event)
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CReadIOData::PoolAllocFunction"

BOOL	CReadIOData::PoolAllocFunction( HANDLE Context )
{
	BOOL	fReturn;
	
	
	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );

	DNASSERT( m_ReadState == READ_STATE_UNKNOWN );
	DNASSERT( m_dwBytesToRead == 0 );
	DNASSERT( m_dwReadOffset == 0 );
	DNASSERT( jkm_dwOverlappedBytesReceived == 0 );
	
#ifdef WIN95
	DNASSERT( Win9xOperationPending() == FALSE );
#endif
	memset( &m_SPReceivedBuffer, 0x00, sizeof( m_SPReceivedBuffer ) );
	m_SPReceivedBuffer.BufferDesc.pBufferData = &m_ReceiveBuffer.ReceivedData[ sizeof( m_ReceiveBuffer.MessageHeader ) ];

	//
	// set the appropriate callback
	//
#ifdef WINNT
	//
	// WinNT, always use IO completion ports
	//
	DNASSERT( Context == NULL );
	DNASSERT( NTIOOperationType() == NT_IO_OPERATION_UNKNOWN );
	SetNTIOOperationType( NT_IO_OPERATION_RECEIVE );
#else // WIN95
	//
	// Win9x
	//
	DNASSERT( Context != NULL );
	DNASSERT( OverlapEvent() == NULL );
#endif

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::PoolInitFunction - called when new item is grabbed from the pool
//
// Entry:		Context (read complete event)
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CReadIOData::PoolInitFunction"

BOOL	CReadIOData::PoolInitFunction( HANDLE Context )
{
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );

	DNASSERT( m_dwBytesToRead == 0 );
//	DNASSERT( m_dwBytesReceived == 0 );
	DNASSERT( m_dwReadOffset == 0 );
	DNASSERT( jkm_dwOverlappedBytesReceived == 0 );

	DNASSERT( m_SPReceivedBuffer.BufferDesc.pBufferData == &m_ReceiveBuffer.ReceivedData[ sizeof( m_ReceiveBuffer.MessageHeader ) ] );

	DNASSERT( DataPort() == NULL );
#ifdef WIN95
	DNASSERT( Win9xOperationPending() == FALSE );
	SetOverlapEvent( Context );
#endif

	return	TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::PoolReleaseFunction - called when CReadIOData is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CReadIOData::PoolReleaseFunction"

void	CReadIOData::PoolReleaseFunction( void )
{
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );

	m_ReadState = READ_STATE_UNKNOWN;
	m_dwBytesToRead = 0;
	m_dwReadOffset = 0;
	jkm_dwOverlappedBytesReceived = 0;
#ifdef WIN95
	DNASSERT( Win9xOperationPending() == FALSE );
	SetOverlapEvent( NULL );
#endif

	SetDataPort( NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::PoolDeallocFunction - called when CReadIOData is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CReadIOData::PoolDeallocFunction"

void	CReadIOData::PoolDeallocFunction( void )
{
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_dwBytesToRead == 0 );
	DNASSERT( m_dwReadOffset == 0 );
	
#ifdef WIN95
	DNASSERT( Win9xOperationPending() == FALSE );
#endif
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CRedaIOData::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CReadIOData::ReturnSelfToPool"

void	CReadIOData::ReturnSelfToPool( void )
{
	CThreadPool	*pThreadPool;
	

	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_pThreadPool != NULL );
	pThreadPool = m_pThreadPool;
	SetThreadPool( NULL );
	pThreadPool->ReturnReadIOData( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::CWriteIOData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CWriteIOData::CWriteIOData"

CWriteIOData::CWriteIOData():
	m_pNext( NULL ),
	m_pBuffers( NULL ),
	m_uBufferCount( 0 ),
	m_pCommand( NULL ),
	m_SendCompleteAction( SEND_COMPLETE_ACTION_UNKNOWN ),
	jkm_hSendResult( DPN_OK ),
	jkm_dwOverlappedBytesSent( 0 ),
	jkm_dwImmediateBytesSent( 0 )
{
	m_Sig[0] = 'W';
	m_Sig[1] = 'I';
	m_Sig[2] = 'O';
	m_Sig[3] = 'D';
	
	m_OutstandingWriteListLinkage.Initialize();
	memset( &m_DataBuffer, 0x00, sizeof( m_DataBuffer ) );
	m_DataBuffer.MessageHeader.SerialSignature = SERIAL_HEADER_START;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::~CWriteIOData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CWriteIOData::~CWriteIOData"

CWriteIOData::~CWriteIOData()
{
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );
	DNASSERT( m_pCommand == NULL );
	DNASSERT( m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
//	//
//	// don't bother checking the send hResult or the count of byes sent
//	//

	DNASSERT( m_DataBuffer.MessageHeader.SerialSignature == SERIAL_HEADER_START );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::PoolAllocFunction - called when new CWriteIOData is allocated
//
// Entry:		Context (handle of write completion event)
//
// Exit:		Boolean indicating success
//				TRUE = allocation succeeded
//				FALSE = allocation failed
//
// Note:	We always want a command structure associated with CWriteIOData
//			so we don't need to grab a new command from the command pool each
//			time a CWriteIOData entry is removed from its pool.  This is done
//			for speed.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CWriteIOData::PoolAllocFunction"

BOOL	CWriteIOData::PoolAllocFunction( HANDLE Context )
{
	BOOL	fReturn;
	CCommandData	*pCommand;


#ifdef WIN95
	DNASSERT( Context != NULL );
#endif
	DNASSERT( m_pNext == NULL );
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );
	DNASSERT( jkm_dwOverlappedBytesSent == 0 );
	DNASSERT( m_pCommand == NULL );
	DNASSERT( m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );

	//
	// initialize
	//
	fReturn = TRUE;

	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		DPFX(DPFPREP,  0, "Could not get command when allocating new CWriteIOData!" );
		fReturn = FALSE;
		goto Exit;
	}

	//
	// associate this command with the WriteData, clear the command descriptor
	// because the command isn't really being used yet, and it'll
	// cause an ASSERT when it's removed from the WriteIOData pool.
	//
	m_pCommand = pCommand;

	//
	// set the appropriate IO function
	//
#ifdef WINNT
	//
	// WinNT, we'll always use completion ports
	//
	DNASSERT( NTIOOperationType() == NT_IO_OPERATION_UNKNOWN );
	SetNTIOOperationType( NT_IO_OPERATION_SEND );
#else // WIN95
	//
	// Win9x
	//
	DNASSERT( OverlapEvent() == NULL );
#endif

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::PoolInitFunction - called when new CWriteIOData is removed from pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CWriteIOData::PoolInitFunction"

BOOL	CWriteIOData::PoolInitFunction( HANDLE Context )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_pNext == NULL );
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );
	DNASSERT( jkm_dwOverlappedBytesSent == 0 );

	DNASSERT( m_pCommand != NULL );
	m_pCommand->SetDescriptor();

	DNASSERT( m_pCommand->GetDescriptor() != NULL_DESCRIPTOR );
	DNASSERT( m_pCommand->GetUserContext() == NULL );

	DNASSERT( m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
	DNASSERT( DataPort() == NULL );
#ifdef WIN95
	DNASSERT( Win9xOperationPending() == FALSE );
	SetOverlapEvent( Context );
#endif

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::PoolReleaseFunction - called when CWriteIOData is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CWriteIOData::PoolReleaseFunction"

void	CWriteIOData::PoolReleaseFunction( void )
{
	DNASSERT( m_pCommand != NULL );
	m_pCommand->Reset();

	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
#ifdef WIN95
	DNASSERT( Win9xOperationPending() == FALSE );
	SetOverlapEvent( NULL );
#endif

	m_pBuffers = NULL;
	m_uBufferCount = 0;
	jkm_dwOverlappedBytesSent = 0;
	m_pNext = NULL;
	m_SendCompleteAction = SEND_COMPLETE_ACTION_UNKNOWN;
	SetDataPort( NULL );

	DEBUG_ONLY( memset( &m_DataBuffer.Data[ 1 ], 0x00, sizeof( m_DataBuffer.Data ) - 1 ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::PoolDeallocFunction - called when new CWriteIOData is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CWriteIOData::PoolDeallocFunction"

void	CWriteIOData::PoolDeallocFunction( void )
{
	DNASSERT( m_pCommand != NULL );
	m_pCommand->DecRef();
	m_pCommand = NULL;

	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );

	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );
	DNASSERT( m_pCommand == NULL );
#ifdef WIN95
	DNASSERT( OverlapEvent() == NULL );
#endif
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemclassfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Classfac.cpp
 *  Content:	a generic class factory
 *
 *
 *	This is a generic C class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instace of
 *	your object.
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 ***************************************************************************/

#include "dnmdmi.h"


#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// class factory class definition
//
typedef struct GPCLASSFACTORY
{
   IClassFactoryVtbl 		*lpVtbl;
   DWORD					dwRefCnt;
   CLSID					clsid;
} GPCLASSFACTORY, *LPGPCLASSFACTORY;

//
// function prototype for CoLockPbjectExternal()
//
typedef	HRESULT (WINAPI * PCOLOCKOBJECTEXTERNAL)(LPUNKNOWN, BOOL, BOOL );

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************




/*
 * GP_QueryInterface
 */
STDMETHODIMP GP_QueryInterface(
                LPCLASSFACTORY This,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
	HRESULT hr;

    pcf = (LPGPCLASSFACTORY)This;
    *ppvObj = NULL;


    if( IsEqualIID(riid, IID_IClassFactory) ||
                    IsEqualIID(riid, IID_IUnknown))
    {
        pcf->dwRefCnt++;
        *ppvObj = This;
		hr = S_OK;
    }
    else
    {
		hr = E_NOINTERFACE;
    }


	return hr;

} /* GP_QueryInterface */


/*
 * GP_AddRef
 */
STDMETHODIMP_(ULONG) GP_AddRef( LPCLASSFACTORY This )
{
    LPGPCLASSFACTORY pcf;

    pcf = (LPGPCLASSFACTORY)This;
    pcf->dwRefCnt++;
    return pcf->dwRefCnt;
} /* GP_AddRef */



/*
 * GP_Release
 */
STDMETHODIMP_(ULONG) GP_Release( LPCLASSFACTORY This )
{
    LPGPCLASSFACTORY	pcf;

    pcf = (LPGPCLASSFACTORY)This;
    pcf->dwRefCnt--;

    if( pcf->dwRefCnt != 0 )
    {
        return pcf->dwRefCnt;
    }

    DNFree( pcf );
    return 0;

} /* GP_Release */




/*
 * GP_CreateInstance
 *
 * Creates an instance of a DNServiceProvider object
 */
STDMETHODIMP GP_CreateInstance(
                LPCLASSFACTORY This,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT					hr = S_OK;
    LPGPCLASSFACTORY		pcf;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	pcf = (LPGPCLASSFACTORY) This;
	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = DoCreateInstance(This, pUnkOuter, pcf->clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* GP_CreateInstance */



/*
 * GP_LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP GP_LockServer(
                LPCLASSFACTORY This,
                BOOL fLock
				)
{
    HRESULT		hr;
    HINSTANCE	hdll;
    LPGPCLASSFACTORY	pcf;


    pcf = (LPGPCLASSFACTORY) This;

    /*
     * call CoLockObjectExternal
     */
    hr = E_UNEXPECTED;
    hdll = LoadLibraryA( "OLE32.DLL" );
    if( hdll != NULL )
    {
        PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;


		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
        if( lpCoLockObjectExternal != NULL )
        {
            hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
        }
        else
        {
        }
    }
    else
    {
    }

	return hr;

} /* GP_LockServer */

static IClassFactoryVtbl GPClassFactoryVtbl =
{
        GP_QueryInterface,
        GP_AddRef,
        GP_Release,
        GP_CreateInstance,
        GP_LockServer
};


/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
EXP STDAPI  DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
    HRESULT		hr;

    *ppvObj = NULL;

    /*
     * is this our class id?
     */
//	you must implement GetClassID() for your specific COM object
	if (!IsClassImplemented(rclsid))
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, IID_IUnknown ) &&
	    !IsEqualIID( riid, IID_IClassFactory ) )
    {
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = static_cast<GPCLASSFACTORY*>( DNMalloc( sizeof( *pcf ) ) );
    if( NULL == pcf)
    {
        return E_OUTOFMEMORY;
    }

	pcf->lpVtbl = &GPClassFactoryVtbl;
    pcf->dwRefCnt = 0;
	pcf->clsid = rclsid;

    hr = GP_QueryInterface( (LPCLASSFACTORY) pcf, riid, ppvObj );
    if( FAILED( hr ) )
    {
        DNFree ( pcf );
        *ppvObj = NULL;
    }
    else
    {
    }

    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
EXP STDAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

	
	if ( g_lOutstandingInterfaceCount == 0 )
	{
		hr = S_OK;
	}

    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemendpoint.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Endpoint.h
 *  Content:	DNSerial communications endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 ***************************************************************************/

#ifndef __ENDPOINT_H__
#define __ENDPOINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumeration of endpoint types
//
typedef	enum	_ENDPOINT_TYPE
{
	ENDPOINT_TYPE_UNKNOWN = 0,			// unknown endpoint type
	ENDPOINT_TYPE_LISTEN,				// 'Listen' endpoint
	ENDPOINT_TYPE_CONNECT,				// 'Conenct' endpoint
	ENDPOINT_TYPE_ENUM,					// 'Enum' endpoint
	ENDPOINT_TYPE_CONNECT_ON_LISTEN		// endpoint connected from a 'listen'
} ENDPOINT_TYPE;

//
// enumeration of the states an endpoint can be in
//
typedef	enum
{
	ENDPOINT_STATE_UNINITIALIZED = 0,		// uninitialized state
	ENDPOINT_STATE_ATTEMPTING_ENUM,			// attempting to enum
	ENDPOINT_STATE_ENUM,					// endpoint is supposed to enum connections
	ENDPOINT_STATE_ATTEMPTING_CONNECT,		// attempting to connect
	ENDPOINT_STATE_CONNECT_CONNECTED,		// endpoint is supposed to connect and is connected
	ENDPOINT_STATE_ATTEMPTING_LISTEN,		// attempting to listen
	ENDPOINT_STATE_LISTENING,				// endpoint is supposed to listen and is listening
	ENDPOINT_STATE_DISCONNECTING,			// endpoint is disconnecting

	ENDPOINT_STATE_MAX
} ENDPOINT_STATE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
typedef	struct	_JOB_HEADER			JOB_HEADER;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;
class	CCommandData;
class	CDataPort;
class	CReadIOData;
class	CThreadPool;
class	CWriteIOData;

//
// structure used to get data from the endpoint port pool
//
typedef	struct	_ENDPOINT_POOL_CONTEXT
{
	CSPData *pSPData;
} ENDPOINT_POOL_CONTEXT;

//
// structure to bind extra information to an enum query to be used on enum reponse
//
typedef	struct	_ENDPOINT_ENUM_QUERY_CONTEXT
{
	SPIE_QUERY	EnumQueryData;
	HANDLE		hEndpoint;
	UINT_PTR	uEnumRTTIndex;
} ENDPOINT_ENUM_QUERY_CONTEXT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CEndpoint : public CLockedContextFixedPoolItem< ENDPOINT_POOL_CONTEXT* >
{
	public:
		//
		// a virtual destructor is required to guarantee we call destructors in
		// base classes
		//
		CEndpoint();
		virtual	~CEndpoint();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::Lock"
		void	Lock( void )
		{
			DNASSERT( m_Flags.fInitialized != FALSE );
			DNEnterCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::Unlock"
		void	Unlock( void )
		{
			DNASSERT( m_Flags.fInitialized != FALSE );
			DNLeaveCriticalSection( &m_Lock );
		}

		void	AddCommandRef( void )
		{
			DNInterlockedIncrement( &m_lCommandRefCount );
			AddRef();
		}

		void	DecCommandRef( void )
		{
			if ( DNInterlockedDecrement( &m_lCommandRefCount ) == 0 )
			{
				CleanUpCommand();
			}
			DecRef();
		}
		
		HANDLE	GetHandle( void ) const { return m_Handle; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetHandle"
		void	SetHandle( const HANDLE Handle )
		{
			DNASSERT( ( m_Handle == INVALID_HANDLE_VALUE ) || ( Handle == INVALID_HANDLE_VALUE ) );
			m_Handle = Handle;
		}
		
		CDataPort	*GetDataPort( void ) const { return m_pDataPort; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetDataPort"
		void	SetDataPort( CDataPort *const pDataPort )
		{
			DNASSERT( ( m_pDataPort == NULL ) || ( pDataPort == NULL ) );
			m_pDataPort = pDataPort;
		}

		ENDPOINT_TYPE	GetType( void ) const { return m_EndpointType; }

		void	*GetUserEndpointContext( void ) const { return m_pUserEndpointContext; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetUserEndpointContext"
		void	SetUserEndpointContext( void *const pContext )
		{
			DNASSERT( ( m_pUserEndpointContext == NULL ) || ( pContext == NULL ) );
			m_pUserEndpointContext = pContext;
		}

		ENDPOINT_STATE	GetState( void ) const { return m_State; }
		void	SetState( const ENDPOINT_STATE EndpointState );
		CSPData	*GetSPData( void ) const { return m_pSPData; }

		CCommandData	*GetCommandData( void ) const { return m_pCommandHandle; }
		HANDLE	GetDisconnectIndicationHandle( void ) const { return this->m_hDisconnectIndicationHandle; }
		void	SetDisconnectIndicationHandle( const HANDLE hDisconnectIndicationHandle )
		{
			DNASSERT( ( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE ) ||
					  ( hDisconnectIndicationHandle == INVALID_HANDLE_VALUE ) );
			m_hDisconnectIndicationHandle = hDisconnectIndicationHandle;
		}

		void	CopyConnectData( const SPCONNECTDATA *const pConnectData );
		static	void	ConnectJobCallback( THREAD_POOL_JOB *const pJobHeader );
		static	void	CancelConnectJobCallback( THREAD_POOL_JOB *const pJobHeader );
		HRESULT	CompleteConnect( void );

		void	CopyListenData( const SPLISTENDATA *const pListenData );
		static	void	ListenJobCallback( THREAD_POOL_JOB *const pJobHeader );
		static	void	CancelListenJobCallback( THREAD_POOL_JOB *const pJobHeader );
		HRESULT	CompleteListen( void );

		void	CopyEnumQueryData( const SPENUMQUERYDATA *const pEnumQueryData );
		static	void	EnumQueryJobCallback( THREAD_POOL_JOB *const pJobHeader );
		static	void	CancelEnumQueryJobCallback( THREAD_POOL_JOB *const pJobHeader );
		HRESULT	CompleteEnumQuery( void );
		void	OutgoingConnectionEstablished( const HRESULT hCommandResult );

		virtual	HRESULT	Open( IDirectPlay8Address *const pHostAddress,
							  IDirectPlay8Address *const pAdapterAddress,
							  const LINK_DIRECTION LinkDirection,
							  const ENDPOINT_TYPE EndpointType ) = 0;
		virtual	HRESULT	OpenOnListen( const CEndpoint *const pListenEndpoint ) = 0;

		virtual	void	Close( const HRESULT hActiveCommandResult ) = 0;
		HRESULT	Disconnect( const HANDLE hOldEndpointHandle );
		void	SignalDisconnect( const HANDLE hOldEndpointHandle );
		virtual DWORD	GetLinkSpeed( void ) = 0;

		//
		// send functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SendUserData"
		void	SendUserData( CWriteIOData *const pWriteBuffer )
		{
			DNASSERT( pWriteBuffer != NULL );
			DNASSERT( m_pDataPort != NULL );
			m_pDataPort->SendUserData( pWriteBuffer );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SendEnumResponseData"
		void	SendEnumResponseData( CWriteIOData *const pWriteBuffer, const UINT_PTR uRTTIndex )
		{
			DNASSERT( pWriteBuffer != NULL );
			DNASSERT( m_pDataPort != NULL );
			m_pDataPort->SendEnumResponseData( pWriteBuffer, uRTTIndex );
		}

		void	StopEnumCommand( const HRESULT hCommandResult );

		LINK_DIRECTION	GetLinkDirection( void ) const;

		virtual IDirectPlay8Address	*GetRemoteHostDP8Address( void ) const = 0;
		virtual	IDirectPlay8Address	*GetLocalAdapterDP8Address( const ADDRESS_TYPE AdapterAddressType ) const = 0;

		//
		// data processing functions
		//
		void	ProcessEnumData( SPRECEIVEDBUFFER *const pReceivedBuffer, const UINT_PTR uRTTIndex );
		void	ProcessEnumResponseData( SPRECEIVEDBUFFER *const pReceivedBuffer, const UINT_PTR uRTTIndex );
		void	ProcessUserData( CReadIOData *const pReadData );
		void	ProcessUserDataOnListen( CReadIOData *const pReadData );

		//
		// dialog settings
		//
		virtual HRESULT	ShowOutgoingSettingsDialog( CThreadPool *const pThreadPool ) = 0;
		virtual HRESULT	ShowIncomingSettingsDialog( CThreadPool *const pThreadPool ) = 0;
		void	SettingsDialogComplete( const HRESULT hDialogReturnCode );
		virtual	void	StopSettingsDialog( const HWND hDialog ) = 0;	

		virtual	DWORD	GetDeviceID( void ) const = 0;
		virtual HRESULT	SetDeviceID( const DWORD dwDeviceID ) = 0;

		HWND	ActiveDialogHandle( void ) const { return m_hActiveDialogHandle; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetActiveDialogHandle"
		void	SetActiveDialogHandle( const HWND hDialog )
		{
			DNASSERT( ( ActiveDialogHandle() == NULL ) || ( hDialog == NULL ) );
			m_hActiveDialogHandle = hDialog;
		}

	protected:
		CSPData		*m_pSPData;					// pointer to SP data

		struct
		{
			BOOL	fInitialized : 1;
			BOOL	fConnectIndicated : 1;
			BOOL	fCommandPending : 1;
			BOOL	fListenStatusNeedsToBeIndicated : 1;
		} m_Flags;
		
		DWORD		m_dwEnumSendIndex;			// enum send index
		DWORD		m_dwEnumSendTimes[ 4 ];		// enum send times

		union									// Local copy of the pending command paramters.
		{										// This data contains the pointers to the active
			SPCONNECTDATA	ConnectData;		// command, and the user context.
			SPLISTENDATA	ListenData;			//
			SPENUMQUERYDATA	EnumQueryData;		//
		} m_CurrentCommandParameters;			//

		CCommandData	*m_pCommandHandle;		// pointer to active command (this is kept to
												// avoid a switch to go through the m_ActveCommandData
												// to find the command handle)

		HWND			m_hActiveDialogHandle;	// handle of active dialog

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetType"
		void	SetType( const ENDPOINT_TYPE EndpointType )
		{
			DNASSERT( ( m_EndpointType == ENDPOINT_TYPE_UNKNOWN ) || ( EndpointType == ENDPOINT_TYPE_UNKNOWN ) );
			m_EndpointType = EndpointType;
		}

		HRESULT	Initialize( CSPData *const pSPData );
		void	Deinitialize( void );

		CCommandData	*CommandHandle( void ) const;

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetCommandHandle"
		void	SetCommandHandle( CCommandData *const pCommandHandle )
		{
			DNASSERT( ( m_pCommandHandle == NULL ) || ( pCommandHandle == NULL ) );
			m_pCommandHandle = pCommandHandle;
		}

		HRESULT	CommandResult( void ) const { return m_hPendingCommandResult; }
		void	SetCommandResult( const HRESULT hCommandResult ) { m_hPendingCommandResult = hCommandResult; }

		void	CompletePendingCommand( const HRESULT hResult );
		HRESULT	PendingCommandResult( void ) const { return m_hPendingCommandResult; }

		static void		EnumCompleteWrapper( const HRESULT hCompletionCode, void *const pContext );	
		static void		EnumTimerCallback( void *const pContext );
		virtual void	EnumComplete( const HRESULT hCompletionCode ) = 0;
		
		HRESULT	SignalConnect( SPIE_CONNECT *const pConnectData );
		virtual const void	*GetDeviceContext( void ) const = 0;
		void	CleanUpCommand( void );

		virtual const GUID	*GetEncryptionGuid( void ) const = 0;

	private:
		DNCRITICAL_SECTION	m_Lock;	   					// critical section
		HANDLE				m_Handle;					// active handle for this endpoint
		volatile ENDPOINT_STATE	m_State;				// endpoint state
		
		volatile LONG			m_lCommandRefCount;		// Command ref count.  When this
														// goes to zero, the endpoint unbinds
														// from the network

		ENDPOINT_TYPE	m_EndpointType;					// type of endpoint
		CDataPort		*m_pDataPort;					// pointer to associated data port

		HRESULT			m_hPendingCommandResult;		// command result returned when endpoint RefCount == 0
		HANDLE			m_hDisconnectIndicationHandle;	// handle to be indicated with disconnect notification.

		void			*m_pUserEndpointContext;		// user context associated with this endpoint

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CEndpoint( const CEndpoint & );
		CEndpoint& operator=( const CEndpoint & );
};

#undef DPF_MODNAME

#endif	// __ENDPOINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemhandletable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		HandleTable.cpp
 *  Content:	Handle table
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/28/2000	jtk		Copied from Modem service provider
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	HANDLE_GROW_COUNT		32
#define	INVALID_HANDLE_INDEX	WORD_MAX

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	struct	_HANDLE_TABLE_ENTRY
{
	DWORD_PTR	dwHandleIndex;
	void		*pContext;
} HANDLE_TABLE_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::CHandleTable - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::CHandleTable"

CHandleTable::CHandleTable():
	m_AllocatedEntries( 0 ),
	m_EntriesInUse( 0 ),
	m_FreeIndex( INVALID_HANDLE_INDEX ),
	m_pEntries( NULL ),
	m_fLockInitialized( FALSE )
{
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::~CHandleTable - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::~CHandleTable"

CHandleTable::~CHandleTable()
{
	DNASSERT( m_AllocatedEntries == 0 );
	DNASSERT( m_EntriesInUse == 0 );
	DNASSERT( m_FreeIndex == INVALID_HANDLE_INDEX );
	DNASSERT( m_pEntries == NULL );
	DNASSERT( m_fLockInitialized == FALSE );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::Initialize - initialization function
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Initialize"

HRESULT	CHandleTable::Initialize( void )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );

	DNASSERT( m_fLockInitialized == FALSE );
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to initialize handle table lock!" );
		goto Failure;
	}
	m_fLockInitialized = TRUE;

	DEBUG_ONLY( m_fInitialized = TRUE );

Exit:
	return hr;

Failure:
	Deinitialize();	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::Deinitialize - deinitialization function
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Deinitialize"

void	CHandleTable::Deinitialize( void )
{
	DNASSERT( m_EntriesInUse == 0 );

	if ( m_fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		m_fLockInitialized = FALSE;
	}

	if ( m_pEntries != NULL )
	{
		DNFree( m_pEntries );
		m_pEntries = NULL;
	}
	
	m_AllocatedEntries = 0;
	m_FreeIndex = WORD_MAX;

	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::CreateHandle - create a handle
//
// Entry:		Pointer to handle destination
//				Pointer to handle context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::CreateHandle"

HRESULT	CHandleTable::CreateHandle( HANDLE *const pHandle, void *const pContext )
{
	HRESULT		hr;
	HANDLE		hReturn;
	DWORD_PTR	Index;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	DNASSERT( pHandle != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	hReturn = INVALID_HANDLE_VALUE;

	//
	// grow table if applicable
	//
	if ( m_EntriesInUse == m_AllocatedEntries )
	{
		hr = Grow();
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed to grow handle table!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}

	//
	// build a handle
	//
	DNASSERT( m_FreeIndex < INVALID_HANDLE_INDEX );
	DBG_CASSERT( sizeof( hReturn ) == sizeof( m_FreeIndex ) );
	hReturn = reinterpret_cast<HANDLE>( m_FreeIndex );
	
	DBG_CASSERT( sizeof( hReturn ) == sizeof( DWORD_PTR ) );
	hReturn = reinterpret_cast<HANDLE>( reinterpret_cast<DWORD_PTR>( hReturn ) | ( ( m_pEntries[ m_FreeIndex ].dwHandleIndex & WORD_MAX ) << 16 ) );
	
	//
	// adjust free handle list before setting handle context
	//
	DBG_CASSERT( sizeof( m_FreeIndex ) == sizeof( m_pEntries[ m_FreeIndex ].pContext ) );
	Index = m_FreeIndex;
	m_FreeIndex = reinterpret_cast<DWORD_PTR>( m_pEntries[ m_FreeIndex ].pContext );
	DNASSERT( m_FreeIndex <= INVALID_HANDLE_INDEX );
	
	m_pEntries[ Index ].pContext = pContext;

	m_EntriesInUse++;

	DNASSERT( hReturn != INVALID_HANDLE_VALUE );
	DNASSERT( hReturn != reinterpret_cast<HANDLE>( INVALID_HANDLE_INDEX ) );
	
	*pHandle = hReturn;
	DNASSERT( hr == DPN_OK );

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::InvalidateHandle - invalidate a handle
//
// Entry:		Handle
//
// Exit:		Boolean indicating whether the handle was invalidated in this
//				operation
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::InvalidateHandle"

BOOL	CHandleTable::InvalidateHandle( const HANDLE Handle )
{
	BOOL		fReturn;
	DWORD_PTR	Index;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	DBG_CASSERT( sizeof( Index ) == sizeof( Handle ) );
	DBG_CASSERT( sizeof( Handle ) == sizeof( DWORD_PTR ) );
	Index = reinterpret_cast<DWORD_PTR>( Handle ) & WORD_MAX;

	DBG_CASSERT( sizeof( Handle ) == sizeof( DWORD_PTR ) );
	if ( ( Index < m_AllocatedEntries ) &&
		 ( ( m_pEntries[ Index ].dwHandleIndex & WORD_MAX ) == ( ( reinterpret_cast<DWORD_PTR>( Handle ) >> 16 ) & WORD_MAX ) ) )
	{
		m_pEntries[ Index ].dwHandleIndex++;
		DBG_CASSERT( sizeof( void* ) == sizeof( m_FreeIndex ) );
		m_pEntries[ Index ].pContext = reinterpret_cast<void*>( m_FreeIndex );
		m_EntriesInUse--;
		m_FreeIndex = Index;
		fReturn = TRUE;
	}
	else
	{
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::GetAssociatedData - get data associated with the handle
//
// Entry:		Handle
//
// Exit:		Associated data
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::GetAssociatedData"

void	*CHandleTable::GetAssociatedData( const HANDLE Handle ) const
{
	void		*pReturn;
	DWORD_PTR	Index;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	pReturn = NULL;
	DBG_CASSERT( sizeof( Handle ) == sizeof( DWORD_PTR ) );
	Index = reinterpret_cast<DWORD_PTR>( Handle ) & WORD_MAX;
	if ( ( Index < m_AllocatedEntries ) &&
		 ( ( m_pEntries[ Index ].dwHandleIndex & WORD_MAX ) == ( ( reinterpret_cast<DWORD_PTR>( Handle ) >> 16 ) & WORD_MAX ) ) )
	{
		pReturn = m_pEntries[ Index ].pContext;
	}

	DNASSERT( pReturn != INVALID_HANDLE_VALUE );
	DNASSERT( pReturn != reinterpret_cast<HANDLE>( INVALID_HANDLE_INDEX ) );
	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::Grow - grow handle table
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Grow"

HRESULT	CHandleTable::Grow( void )
{
	HRESULT	hr;
	void	*pTemp;


	hr = DPN_OK;
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	DNASSERT( m_FreeIndex == WORD_MAX );
	
	if ( m_pEntries == NULL )
	{
		pTemp = DNMalloc( sizeof( *m_pEntries ) * ( m_AllocatedEntries + HANDLE_GROW_COUNT ) );
	}
	else
	{
		pTemp = DNRealloc( m_pEntries, sizeof( *m_pEntries ) * ( m_AllocatedEntries + HANDLE_GROW_COUNT ) );
	}
	
	if ( pTemp == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to grow handle table!" );
	}
	else
	{
		DWORD_PTR	Index;


		//
		// Table was enlarged, link all of the entires at the end of the list
		// into the free list.  Make sure the free list is properly terminated.
		//
		m_pEntries = static_cast<HANDLE_TABLE_ENTRY*>( pTemp );
		Index = m_AllocatedEntries;
		m_FreeIndex = m_AllocatedEntries;
		
		m_AllocatedEntries += HANDLE_GROW_COUNT;
		while ( Index < m_AllocatedEntries )
		{
			DBG_CASSERT( sizeof( Index ) == sizeof( void* ) );
			m_pEntries[ Index ].dwHandleIndex = 0;
			m_pEntries[ Index ].pContext = reinterpret_cast<void*>( Index + 1 );
			Index++;
		}
		
		m_pEntries[ m_AllocatedEntries - 1 ].pContext = reinterpret_cast<void*>( WORD_MAX );
	}

	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemjobqueue.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		JobQueue.cpp
 *  Content:	Job queue for use in the thread pool
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/21/2000	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::CJobQueue - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::CJobQueue"

CJobQueue::CJobQueue():
	m_pQueueHead( NULL ),
	m_pQueueTail( NULL ),
	m_hPendingJob( NULL )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::~CJobQueue - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::~CJobQueue"

CJobQueue::~CJobQueue()
{
	DNASSERT( m_pQueueHead == NULL );
	DNASSERT( m_pQueueTail == NULL );
	DNASSERT( m_hPendingJob == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::Initialize - initialize
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::Initialize"

BOOL	CJobQueue::Initialize( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize critical section on job queue!" );
		goto Failure;
	}

	m_hPendingJob = CreateEvent( NULL,		// pointer to security attributes (none)
								 TRUE,		// manual reset
								 FALSE,		// start unsignalled
								 NULL );	// pointer to name (none)
	if ( m_hPendingJob == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to create event for pending job!" );
		goto Failure;
	}

Exit:
	return	fReturn;

Failure:
	fReturn = FALSE;
	Deinitialize();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::Deinitialize - deinitialize
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::Deinitialize"

void	CJobQueue::Deinitialize( void )
{
	DNASSERT( m_pQueueHead == NULL );
	DNASSERT( m_pQueueTail == NULL );
	DNDeleteCriticalSection( &m_Lock );

	if ( m_hPendingJob != NULL )
	{
		if ( CloseHandle( m_hPendingJob ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing job queue handle" );
			DisplayErrorCode( 0, dwError );
		}

		m_hPendingJob = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::SignalPendingJob - set flag to signal a pending job
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::SignalPendingJob"

BOOL	CJobQueue::SignalPendingJob( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	if ( SetEvent( GetPendingJobHandle() ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Cannot set event for pending job!" );
		DisplayErrorCode( 0, dwError );
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::EnqueueJob - add a job to the job list
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::EnqueueJob"

void	CJobQueue::EnqueueJob( THREAD_POOL_JOB *const pJob )
{
	DNASSERT( pJob != NULL );

	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	if ( m_pQueueTail != NULL )
	{
		DNASSERT( m_pQueueHead != NULL );
		DNASSERT( m_pQueueTail->pNext == NULL );
		m_pQueueTail->pNext = pJob;
	}
	else
	{
		m_pQueueHead = pJob;
	}

	m_pQueueTail = pJob;
	pJob->pNext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::DequeueJob - remove job from job queue
//
// Entry:		Nothing
//
// Exit:		Pointer to job
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::DequeueJob"

THREAD_POOL_JOB	*CJobQueue::DequeueJob( void )
{
	THREAD_POOL_JOB	*pJob;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	
	pJob = NULL;
	
	if ( m_pQueueHead != NULL )
	{
		pJob = m_pQueueHead;
		m_pQueueHead = pJob->pNext;
		if ( m_pQueueHead == NULL )
		{
			DNASSERT( m_pQueueTail == pJob );
			m_pQueueTail = NULL;
		}

		DEBUG_ONLY( pJob->pNext = NULL );
	}

	return	pJob;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemiodata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IOData.h
 *  Content:	Structure definitions for IOData for the DNSerial service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 *	09/14/99	jtk		Dereived from Locals.h
 ***************************************************************************/

#ifndef __IODDATA_H__
#define __IODDATA_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated types for what action to take when a send completes
//
typedef	enum	_SEND_COMPLETE_ACTION
{
	SEND_COMPLETE_ACTION_UNKNOWN = 0,				// unknown value
	SEND_COMPLETE_ACTION_NONE,						// no action
	SEND_COMPLETE_ACTION_COMPLETE_COMMAND			// complete command
} SEND_COMPLETE_ACTION;

//
// enumerated values for state of reads
//
typedef	enum	_READ_STATE
{
	READ_STATE_UNKNOWN,			// unknown state
//	READ_STATE_INITIALIZE,		// initialize state machine
	READ_STATE_READ_HEADER,		// read header information
	READ_STATE_READ_DATA		// read message data
} READ_STATE;

typedef	enum	_NT_IO_OPERATION_TYPE
{
	NT_IO_OPERATION_UNKNOWN,
	NT_IO_OPERATION_RECEIVE,
	NT_IO_OPERATION_SEND
} NT_IO_OPERATION_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
//typedef	struct	_RECEIVE_BUFFER	RECEIVE_BUFFER;
class	CCommandData;
class	CDataPort;
class	CIOData;
//class	CEndpoint;
//class	CReceiveBuffer;
class	CThreadPool;

//
// structure used to prefix a message on the wire for framing
//
#pragma pack( push, 1 )
typedef	struct _MESSAGE_HEADER
{
	BYTE	SerialSignature;	// serial signature
	BYTE	MessageTypeToken;	// token to indicate message type
	WORD	wMessageSize;		// message data size
	WORD	wMessageCRC;		// CRC of message data
	WORD	wHeaderCRC;			// CRC of header

} MESSAGE_HEADER;
#pragma pack( pop )


//
// class containing all data for I/O completion
//
class	CIOData
{
	public:
		CIOData();
		virtual ~CIOData();

		CDataPort	*DataPort( void ) const { return m_pDataPort; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::SetDataPort"
		void	SetDataPort( CDataPort *const pDataPort )
		{
			DNASSERT( ( m_pDataPort == NULL ) || ( pDataPort == NULL ) );
			m_pDataPort = pDataPort;
		}

#ifdef WIN95
		BOOL	Win9xOperationPending( void ) const { return m_fWin9xOperationPending; }
		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_fWin9xOperationPending = fOperationPending; }
#endif

#ifdef WINNT
		NT_IO_OPERATION_TYPE	NTIOOperationType( void ) const { return m_NTIOOperationType; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::SetNTIOOperationType"
		void	SetNTIOOperationType( const NT_IO_OPERATION_TYPE OperationType )
		{
			DNASSERT( ( OperationType == NT_IO_OPERATION_UNKNOWN ) ||
					  ( m_NTIOOperationType == NT_IO_OPERATION_UNKNOWN ) );
			m_NTIOOperationType = OperationType;
		}
#endif

		OVERLAPPED	*Overlap( void ) { return &m_Overlap; }
#ifdef WIN95
		HANDLE	OverlapEvent( void ) const { return m_Overlap.hEvent; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::SetOverlapEvent"
		void	SetOverlapEvent( const HANDLE hEvent )
		{
			DNASSERT( ( m_Overlap.hEvent == NULL ) || ( hEvent == NULL ) );
			m_Overlap.hEvent = hEvent;
		}
#endif
		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::IODataFromOverlap"
		static	CIOData	*IODataFromOverlap( OVERLAPPED *const pOverlap )
		{
			DNASSERT( pOverlap != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pOverlap ) );
			DBG_CASSERT( sizeof( CIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CIOData*>( &reinterpret_cast<BYTE*>( pOverlap )[ -OFFSETOF( CIOData, m_Overlap ) ] );
		}

	protected:

	private:
		OVERLAPPED	m_Overlap;		// overlapped I/O structure

#ifdef WINNT
		NT_IO_OPERATION_TYPE	m_NTIOOperationType;
#endif

		CDataPort		*m_pDataPort;   						// pointer to data port associated with this IO request
#ifdef WIN95
		BOOL			m_fWin9xOperationPending;				// this structure has been initialized and the operation is pending on Win9x
#endif


		//
		// prevent unwarranted copies
		//
		CIOData( const CIOData & );
		CIOData& operator=( const CIOData & );
};


//
// all data for a read operation
//
class	CReadIOData : public CIOData
{
	public:
		CReadIOData();
		~CReadIOData();

		void	AddRef( void ) { DNInterlockedIncrement( &m_lRefCount ); }
		void	DecRef( void )
		{
			if ( DNInterlockedDecrement( &m_lRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		CBilink				m_OutstandingReadListLinkage;	// links to the unbound list

		//
		// I/O variables
		//
		DWORD	m_dwWin9xReceiveErrorReturn;		// Win9x error return
		DWORD	jkm_dwOverlappedBytesReceived;		// used in GetOverlappedResult()
		DWORD	jkm_dwImmediateBytesReceived;		// used as an immediate for ReadFile()

		//
		// read state
		//
		READ_STATE	m_ReadState;				// state of READ
		DWORD		m_dwBytesToRead;			// bytes to read
		DWORD		m_dwReadOffset;				// destination offset into read buffer

		//
		// read buffers
		//
		SPRECEIVEDBUFFER	m_SPReceivedBuffer;				// received buffer data that is handed to the application
		union
		{
			MESSAGE_HEADER	MessageHeader;							// template for message header
			BYTE			ReceivedData[ MAX_MESSAGE_SIZE ];		// full buffer for received data
		} m_ReceiveBuffer;


		READ_STATE	ReadState( void ) const { return m_ReadState; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::SetReadState"
		void	SetReadState( const READ_STATE ReadState )
		{
			DNASSERT( ( m_ReadState == READ_STATE_UNKNOWN ) ||
					  ( ReadState == READ_STATE_UNKNOWN ) ||
					  ( ( m_ReadState == READ_STATE_READ_HEADER ) && ( ReadState == READ_STATE_READ_DATA ) ) );		// valid header read, start reading data
			m_ReadState = ReadState;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::SetThreadPool"
		void	SetThreadPool( CThreadPool *const pThreadPool )
		{
			DNASSERT( ( m_pThreadPool == NULL ) || ( pThreadPool == NULL ) );
			m_pThreadPool = pThreadPool;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::ReadDataFromBilink"
		static CReadIOData	*ReadDataFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CReadIOData*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CReadIOData, m_OutstandingReadListLinkage ) ] );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::ReadDataFromSPReceivedBuffer"
		static CReadIOData	*ReadDataFromSPReceivedBuffer( SPRECEIVEDBUFFER *const pSPReceivedBuffer )
		{
			DNASSERT( pSPReceivedBuffer != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pSPReceivedBuffer ) );
			DBG_CASSERT( sizeof( CReadIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CReadIOData*>( &reinterpret_cast<BYTE*>( pSPReceivedBuffer )[ -OFFSETOF( CReadIOData, m_SPReceivedBuffer ) ] );
		}

		//
		// functions for managing read IO data pool
		//
		BOOL	PoolAllocFunction( HANDLE Context );
		BOOL	PoolInitFunction( HANDLE Context );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );

	private:
		void	ReturnSelfToPool( void );

		BYTE			m_Sig[4];	// debugging signature ('RIOD')
		
		volatile LONG	m_lRefCount;
		CThreadPool		*m_pThreadPool;
		
		//
		// prevent unwarranted copies
		//
		CReadIOData( const CReadIOData & );
		CReadIOData& operator=( const CReadIOData & );
};

//
// all data for a write operation
//
class	CWriteIOData : public CIOData
{
	public:
		CWriteIOData();
		~CWriteIOData();

		CWriteIOData			*m_pNext;							// link to next write in the send queue (see CSendQueue)

		CBilink					m_OutstandingWriteListLinkage;		// links to the outstanding write list
		BUFFERDESC				*m_pBuffers;						// pointer to outgoing buffers
		UINT_PTR				m_uBufferCount;						// count of outgoing buffers
		CCommandData			*m_pCommand;						// associated command

		SEND_COMPLETE_ACTION	m_SendCompleteAction;				// enumerated value indicating the action to take
									    							// when a send completes

		//
		// I/O variables
		//
		HRESULT		jkm_hSendResult;
		DWORD		jkm_dwOverlappedBytesSent;		// used in GetOverlappedResult()
		DWORD		jkm_dwImmediateBytesSent;		// used as an immediate for WriteFile()

		//
		// Since the following is a packed structure, put it at the end
		// to preserve as much alignment as possible with the
		// above fields
		//
		union
		{
			MESSAGE_HEADER	MessageHeader;					// data prepended on a write
			BYTE			Data[ MAX_MESSAGE_SIZE ];		// data buffer to flatten outgoing data
		} m_DataBuffer;

		static CWriteIOData	*WriteDataFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CWriteIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CWriteIOData*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CWriteIOData, m_OutstandingWriteListLinkage ) ] );
		}

		//
		// functions for managing write IO data pool
		//
		BOOL	PoolAllocFunction( HANDLE Context );
		BOOL	PoolInitFunction( HANDLE Context );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );

	private:
		BYTE			m_Sig[4];	// debugging signature ('WIOD')
		
		//
		// prevent unwarranted copies
		//
		CWriteIOData( const CWriteIOData & );
		CWriteIOData& operator=( const CWriteIOData & );
};

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME

#endif	// __IODDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemsendqueue.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SendQueue.cpp
 *  Content:	Queue to manage outgoing sends
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/14/99	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


#undef DPF_MODNAME
#define	DPF_MODNAME	"SendQueue"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::CSendQueue - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
CSendQueue::CSendQueue():
	m_pHead( NULL ),
	m_pTail( NULL )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::~CSendQueue - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
CSendQueue::~CSendQueue()
{
	DNASSERT( m_pHead == NULL );
	DNASSERT( m_pTail == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::Initialize - initialize this send queue
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
HRESULT	CSendQueue::Initialize( void )
{
	HRESULT	hr;


	hr = DPN_OK;
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Could not initialize critical section for SendQueue!" );
	}
	else
	{
		DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::FindNextByEndpoint - find next entry in send queue given an endpoint
//
// Entry:		Pointer to handle (initialized to NULL to start scanning)
//				Pointer to endpoint to find
//
// Exit:		Pointer to next item referring to given endpoint
//				NULL = no item found
// ------------------------------
CWriteIOData	*CSendQueue::FindNextByEndpoint( HANDLE *const pHandle, const CEndpoint *const pEndpoint )
{
	CWriteIOData	*pReturn;


	DNASSERT( pEndpoint != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );

	//
	// initialize
	//
	pReturn = NULL;
	if ( *pHandle == NULL )
	{
		pReturn = m_pHead;
	}

	DNASSERT( FALSE );

	return	pReturn;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodempools.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.h
 *  Content:	Pool functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/2000	jtk		Derived from utils.h
 ***************************************************************************/

#ifndef __POOLS_H__
#define __POOLS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CCommandData;
class	CDataPort;
class	CEndpoint;
class	CThreadPool;
typedef	struct	_DATA_PORT_POOL_CONTEXT	DATA_PORT_POOL_CONTEXT;
typedef	struct	_ENDPOINT_POOL_CONTEXT	ENDPOINT_POOL_CONTEXT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	InitializePools( void );
void	DeinitializePools( void );

CCommandData	*CreateCommand( void );
CDataPort		*CreateDataPort( DATA_PORT_POOL_CONTEXT *pContext );
CEndpoint		*CreateEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
CThreadPool		*CreateThreadPool( void );

#endif	// __POOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemlocals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Locals.cpp
 *  Content:	Global variables for the DNSerial service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


#define	DPF_MODNAME	"Locals"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

// DLL instance
HINSTANCE	g_hDLLInstance = NULL;

//
// count of outstanding COM interfaces
//
volatile LONG	g_lOutstandingInterfaceCount = 0;

//
// Note: all of these constants MUST be in the same order as their numbering in
//		the dialog resource file!
//

//
// NULL characters token
//
const TCHAR	g_NullToken = TEXT('\0');

//
// thread count
//
INT			g_iThreadCount = 0;

//
// GUIDs for munging deivce IDs
//
// {735D5A43-8249-4628-BE0C-F4DC6836ACDD}
GUID	g_ModemSPEncryptionGuid = { 0x735d5a43, 0x8249, 0x4628, { 0xbe, 0xc, 0xf4, 0xdc, 0x68, 0x36, 0xac, 0xdd } };
// {66AFD073-206B-416c-A0B6-09B216FE007B}
GUID	g_SerialSPEncryptionGuid = { 0x66afd073, 0x206b, 0x416c, { 0xa0, 0xb6, 0x9, 0xb2, 0x16, 0xfe, 0x0, 0x7b } };

//**********************************************************************
// Function prototypes
//**********************************************************************

TAPI_lineAnswer					*p_lineAnswer = NULL;
TAPI_lineClose					*p_lineClose = NULL;
TAPI_lineConfigDialog			*p_lineConfigDialog = NULL;
TAPI_lineDeallocateCall			*p_lineDeallocateCall = NULL;
TAPI_lineDrop					*p_lineDrop = NULL;
TAPI_lineGetDevCaps				*p_lineGetDevCaps = NULL;
TAPI_lineGetID					*p_lineGetID = NULL;
TAPI_lineGetMessage				*p_lineGetMessage = NULL;
TAPI_lineInitializeEx			*p_lineInitializeEx = NULL;
TAPI_lineMakeCall				*p_lineMakeCall = NULL;
TAPI_lineNegotiateAPIVersion	*p_lineNegotiateAPIVersion = NULL;
TAPI_lineOpen					*p_lineOpen = NULL;
TAPI_lineShutdown				*p_lineShutdown = NULL;

//**********************************************************************
// Function definitions
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemlocals.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Locals.h
 *  Content:	Global information for the DNSerial service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __LOCALS_H__
#define __LOCALS_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// max 32-bit value
//
#define	UINT32_MAX	((DWORD) 0xFFFFFFFF)
#define	WORD_MAX	((WORD) 0xFFFF)

//
// invalid port ID
//
#define	INVALID_DEVICE_ID		-1

//
// string for name of a com port
//
#define	COM_PORT_STRING			"COM"
#define	COM_PORT_TEMPLATE		"COM%d"
#define	COM_PORT_STRING_LENGTH	7

//
// no error code from TAPI
//
#define	LINEERR_NONE	0

//
// event indicies for all threads
//
#define	SP_CLOSING_EVENT_INDEX	0
#define	USER_CANCEL_EVENT_INDEX	1

#define	MAX_ACTIVE_WIN9X_ENDPOINTS	25

#define	MAX_PHONE_NUMBER_LENGTH		200

//
// enumeration of flow control
//
typedef	enum
{
	FLOW_NONE,			// no flow control
	FLOW_XONXOFF,		// XON/XOFF flow control
	FLOW_RTS,			// RTS
	FLOW_DTR,			// DTR
	FLOW_RTSDTR			// RTS/DTR
} SP_FLOW_CONTROL;

// definitions of communication types
typedef	DWORD	SP_BAUD_RATE;
typedef	DWORD	SP_STOP_BITS;
typedef	DWORD	SP_PARITY_TYPE;   			// SP_PARITY is reserved in WINBASE.H

// buffer limits for XON/XOFF flow control
#define	XON_LIMIT	100
#define	XOFF_LIMIT	100

// XON/XOFF flow control characters
#define	ASCII_XON	0x11
#define	ASCII_XOFF	0x13

// timeout intervals (milliseconds)
#define	WRITE_TIMEOUT_MS	5000
#define	READ_TIMEOUT_MS		500

// maximum user data allowed in a message
#define	MAX_MESSAGE_SIZE	1500
#define	MAX_USER_PAYLOAD	( MAX_MESSAGE_SIZE - sizeof( _MESSAGE_HEADER ) )

//
// Message start tokens (make non-ascii to reduce chance of being user data)
// The tokens need to be arranged such that all messages start with the INITIAL_DATA_SUB_TOKEN
// Note that enums use the bottom 2 bits of the 'command' token for RTT.
// The high-bit of the 'command' token is reserved.
//
#define	SERIAL_HEADER_START			0xCC
#define	SERIAL_DATA_USER_DATA		0x40
#define	SERIAL_DATA_ENUM_QUERY		0x60
#define	SERIAL_DATA_ENUM_RESPONSE	0x20
#define	ENUM_RTT_MASK	0x03

//
// enumerated constants for IO completion returns
//
typedef	enum	_IO_COMPLETION_KEY
{
	IO_COMPLETION_KEY_UNKNONW = 0,		// invalid value
	IO_COMPLETION_KEY_SP_CLOSE,			// SP is closing, bail on completion threads
	IO_COMPLETION_KEY_TAPI_MESSAGE,		// TAPI sent a message
	IO_COMPLETION_KEY_IO_COMPLETE,		// IO operation complete
	IO_COMPLETION_KEY_NEW_JOB,			// new job notification
} IO_COMPLETION_KEY;

//
// enumerated values indicating how to open provider
//
typedef	enum	_LINK_DIRECTION
{
	LINK_DIRECTION_UNKNOWN = 0,		// unknown state
	LINK_DIRECTION_INCOMING,		// incoming state
	LINK_DIRECTION_OUTGOING			// outgoing state
} LINK_DIRECTION;

//
// initialization states of address components
//
typedef	enum	_SP_ADDRESS_COMPONENT_STATE
{
	SP_ADDRESS_COMPONENT_UNINITIALIZED = 0,
	SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED,
	SP_ADDRESS_COMPONENT_INITIALIZED
} SP_ADDRESS_COMPONENT_STATE;

typedef	enum	_ADDRESS_TYPE
{
	ADDRESS_TYPE_UNKNOWN = 0,
	ADDRESS_TYPE_REMOTE_HOST,
	ADDRESS_TYPE_LOCAL_ADAPTER,
	ADDRESS_TYPE_LOCAL_ADAPTER_HOST_FORMAT
} ADDRESS_TYPE;

//
// default enum retries for serial SP and retry time (milliseconds)
//
#define	DEFAULT_ENUM_RETRY_COUNT		5
#define	DEFAULT_ENUM_RETRY_INTERVAL		1500
#define	DEFAULT_ENUM_TIMEOUT			1500

//**********************************************************************
// Macro definitions
//**********************************************************************

//
// macro for length of array
//
#define	LENGTHOF( arg )		( sizeof( arg ) / sizeof( arg[ 0 ] ) )

//
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
//
#define OFFSETOF(s,m)	(INT_PTR)((PVOID)&(((s *)0)->m))

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// structure for all TAPI information
//
typedef	struct	_TAPI_INFO
{
	HLINEAPP	hApplicationInstance;		// from lineInitializeEx()
	DWORD		dwVersion;					// negotiated version
	DWORD		dwLinesAvailable;			// number of TAPI lines available
} TAPI_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

// DLL instance
extern HINSTANCE	g_hDLLInstance;

//
// count of outstanding COM interfaces
//
extern volatile LONG	g_lOutstandingInterfaceCount;

extern const TCHAR	g_NullToken;

//
// thread count
//
extern	INT			g_iThreadCount;

//
// GUIDs for munging deivce IDs
//
extern	GUID	g_ModemSPEncryptionGuid;
extern	GUID	g_SerialSPEncryptionGuid;

//**********************************************************************
// TAPI Function prototypes
//**********************************************************************

//
// TAPI interface functions
//
#ifdef UNICODE
#define TAPI_APPEND_LETTER "W"
#else
#define TAPI_APPEND_LETTER "A"
#endif

// UNICODE and ANSI versions same
typedef	LONG WINAPI	TAPI_lineClose( HLINE hLine );

typedef	LONG WINAPI	TAPI_lineDeallocateCall( HCALL hCall );

typedef	LONG WINAPI	TAPI_lineGetMessage( HLINEAPP hLineApp,
										 LPLINEMESSAGE lpMessage,
										 DWORD dwTimeout );

typedef	LONG WINAPI TAPI_lineShutdown( HLINEAPP hLineApp );

typedef	LONG WINAPI	TAPI_lineAnswer( HCALL hCall,
									 LPCSTR lpsUserUserInfo,
									 DWORD dwSize );

typedef	LONG WINAPI	TAPI_lineDrop( HCALL hCall,
								   LPCSTR lpsUserUserInfo,
								   DWORD dwSize );

typedef LONG WINAPI TAPI_lineNegotiateAPIVersion( HLINEAPP hLineApp,
												  DWORD dwDeviceID,
												  DWORD dwAPILowVersion,
												  DWORD dwAPIHighVersion,
												  LPDWORD lpdwAPIVersion,
												  LPLINEEXTENSIONID lpExtensionID );


// Unicode vs. ANSI

typedef	LONG WINAPI	TAPI_lineConfigDialog( DWORD dwDeviceID,
										   HWND hwndOwner,
										   LPCTSTR lpszDeviceClass );

typedef LONG WINAPI TAPI_lineGetDevCaps( HLINEAPP hLineApp,
										 DWORD dwDeviceID,
										 DWORD dwAPIVersion,
										 DWORD dwExtVersion,
										 LPLINEDEVCAPS lpLineDevCaps );

typedef	LONG WINAPI	TAPI_lineGetID( HLINE hLine,
									DWORD dwAddressID,
									HCALL hCall,
									DWORD dwSelect,
									LPVARSTRING lpDeviceID,
									LPCTSTR lpszDeviceClass );

typedef LONG WINAPI TAPI_lineInitializeEx( LPHLINEAPP lphLineApp,
										   HINSTANCE hInstance,
										   LINECALLBACK lpfnCallback,
										   LPCTSTR lpszFriendlyAppName,
										   LPDWORD lpdwNumDevs,
										   LPDWORD lpdwAPIVersion,
										   LPLINEINITIALIZEEXPARAMS lpLineInitializeExParams );

typedef	LONG WINAPI	TAPI_lineMakeCall( HLINEAPP hLineApp,
									   LPHCALL lphCall,
									   LPCTSTR lpszDestAddress,
									   DWORD dwCountryCode,
									   LPLINECALLPARAMS const lpCallParams );

typedef	LONG WINAPI	TAPI_lineOpen( HLINEAPP hLineApp,
								   DWORD dwDeviceID,
								   LPHLINE lphLine,
								   DWORD dwAPIVersion,
								   DWORD dwExtVersion,
								   DWORD_PTR dwCallbackInstance,
								   DWORD dwPrivileges,
								   DWORD dwMediaModes,
								   LPLINECALLPARAMS const lpCallParams );

extern	TAPI_lineAnswer*				p_lineAnswer;
extern	TAPI_lineClose*					p_lineClose;
extern	TAPI_lineConfigDialog*			p_lineConfigDialog;
extern	TAPI_lineDeallocateCall*		p_lineDeallocateCall;
extern	TAPI_lineDrop*					p_lineDrop;
extern	TAPI_lineGetDevCaps*			p_lineGetDevCaps;
extern	TAPI_lineGetID*					p_lineGetID;
extern	TAPI_lineGetMessage*			p_lineGetMessage;
extern	TAPI_lineInitializeEx*			p_lineInitializeEx;
extern	TAPI_lineMakeCall*				p_lineMakeCall;
extern	TAPI_lineNegotiateAPIVersion*	p_lineNegotiateAPIVersion;
extern	TAPI_lineOpen*					p_lineOpen;
extern	TAPI_lineShutdown*				p_lineShutdown;

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// DNInterlockedIncrement - Interlocked increment
//
// Entry:		Pointer to value to increment
//
// Exit:		New value
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNInterlockedIncrement"

inline LONG	DNInterlockedIncrement( volatile LONG *const pValue )
{
	DNASSERT( pValue != NULL );
	DNASSERT( *pValue != -1 );
	return	InterlockedIncrement( const_cast<LONG*>( pValue ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNInterlockedDecrement - interlocked decrement wrapper
//
// Entry:		Pointer to value to increment
//
// Exit:		New value
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNInterlockedDecrement"

inline LONG	DNInterlockedDecrement( volatile LONG *const pValue )
{
	DNASSERT( pValue != NULL );
	DNASSERT( *pValue != 0 );
	return	InterlockedDecrement( const_cast<LONG*>( pValue ) );
}
//**********************************************************************

#undef DPF_MODNAME

#endif	// __LOCALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemjobqueue.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       JobQueue.h
 *  Content:	Job queue for thread pool
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/24/2000	jtk		Created
 ***************************************************************************/

#ifndef __JOB_QUEUE_H__
#define __JOB_QUEUE_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CSocketPort;
typedef	enum	_JOB_TYPE	JOB_TYPE;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;
typedef	void	JOB_FUNCTION( THREAD_POOL_JOB *const pJobInfo );

//
// structure for job to start monitoring a socket in Win9x
//
typedef	struct
{
	CSocketPort	*pSocketPort;	// pointer to associated socket port

} DATA_ADD_SOCKET;

//
// structure for job to stop monitoring a socket in Win9x
//
typedef	struct
{
	CSocketPort	*pSocketPort;		// pointer to associated socket port

} DATA_REMOVE_SOCKET;

//
// structure for job to connect
//
typedef struct
{
	JOB_FUNCTION	*pCommandFunction;	// pointer to function for the command
	void			*pContext;			// user context (i.e. CEndpoint pointer)
	UINT_PTR		uData;				// user data
} DATA_DELAYED_COMMAND;

//
// structure for job to refresh enums
//
typedef	struct
{
	UINT_PTR	uDummy;			// dummy variable to prevent compiler from whining
} DATA_REFRESH_TIMED_JOBS;

//
// structure encompassing information for a job for the workhorse thread
//
typedef struct	_THREAD_POOL_JOB
{
	THREAD_POOL_JOB		*pNext;					// pointer to next job
	JOB_TYPE			JobType;				// type of job
	JOB_FUNCTION		*pCancelFunction;		// function for cancelling job

//	DWORD		dwCommandID;			// unique ID used to identify this command
//	FUNCTION	*pProcessFunction;		// function for performing job

	union
	{
		DATA_DELAYED_COMMAND	JobDelayedCommand;
		DATA_REMOVE_SOCKET		JobRemoveSocket;
		DATA_ADD_SOCKET			JobAddSocket;
		DATA_REFRESH_TIMED_JOBS	JobRefreshTimedJobs;
	} JobData;

} THREAD_POOL_JOB;


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	void	(CSocketPort::*PSOCKET_SERVICE_FUNCTION)( void );


//**********************************************************************
// Class prototypes
//**********************************************************************


//
// class to encapsultate a job queue
//
class	CJobQueue
{
	public:
		CJobQueue();
		~CJobQueue();

		BOOL	Initialize( void );
		void	Deinitialize( void );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CJobQueue::GetPendingJobHandle"
		HANDLE	GetPendingJobHandle( void ) const
		{
			DNASSERT( m_hPendingJob != NULL );
			return	m_hPendingJob;
		}

		BOOL	SignalPendingJob( void );

		BOOL	IsEmpty( void ) const { return ( m_pQueueHead == NULL ); }

		void	EnqueueJob( THREAD_POOL_JOB *const pJob );
		THREAD_POOL_JOB	*DequeueJob( void );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;			// lock
		THREAD_POOL_JOB		*m_pQueueHead;	// head of job queue
		THREAD_POOL_JOB		*m_pQueueTail;	// tail of job queue
		HANDLE				m_hPendingJob;	// event indicating a pending job

		//
		// prevent unwarranted copies
		//
		CJobQueue( const CJobQueue & );
		CJobQueue& operator=( const CJobQueue & );
};

#undef DPF_MODNAME

#endif	// __JOB_QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodempools.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.cpp
 *  Content:	Pool utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/2000	jtk		Derived from Utils.h
 ***************************************************************************/

#include "dnmdmi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

////
//// Pools for endpoints and addresses.  Since these pools don't
//// see a lot of action, they share one lock
////
//static	DNCRITICAL_SECTION	g_EndpointLock;
//static	CFixedPool< CComEndpoint >		*g_pComEndpointPool = NULL;
//static	CFixedPool< CModemXEndpoint >	*g_pModemEndpointPool = NULL;
//
////
//// pool for receive buffers
////
//static	CLockedContextFixedPool< CReceiveBuffer >	*g_pReceiveBufferPool = NULL;

//
// pool for com endpoints
//
static	CLockedContextFixedPool< CComEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pComEndpointPool = NULL;

//
// pool for command data
//
static	CLockedPool< CCommandData >		*g_pCommandDataPool = NULL;

//
// pool for com ports
//
static	CLockedContextFixedPool< CComPort, DATA_PORT_POOL_CONTEXT* >		*g_pComPortPool = NULL;

//
// pool for modem endpoints
//
static	CLockedContextFixedPool< CModemEndpoint, ENDPOINT_POOL_CONTEXT*>	*g_pModemEndpointPool = NULL;

//
// pool for com ports
//
static	CLockedContextFixedPool< CModemPort, DATA_PORT_POOL_CONTEXT* >		*g_pModemPortPool = NULL;

//
// pool for thread pools
//
static	CLockedPool< CThreadPool >		*g_pThreadPoolPool = NULL;


//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitializePools - initialize pools
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "InitializePools"

BOOL	InitializePools( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	//
	// CComEndpoint pool
	//
	DNASSERT( g_pComEndpointPool == NULL );
	g_pComEndpointPool = new CLockedContextFixedPool< CComEndpoint, ENDPOINT_POOL_CONTEXT* >;
	if ( g_pComEndpointPool != NULL )
	{
		if ( g_pComEndpointPool->Initialize() == FALSE )
		{
			delete	g_pComEndpointPool;
			g_pComEndpointPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}
	
	//
	// CCommandData pool
	//
	DNASSERT( g_pCommandDataPool == NULL );
	g_pCommandDataPool = new CLockedPool< CCommandData >;
	if ( g_pCommandDataPool != NULL )
	{
		if ( g_pCommandDataPool->Initialize() == FALSE )
		{
			delete	g_pCommandDataPool;
			g_pCommandDataPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}

	//
	// CComPort pool
	//
	DNASSERT( g_pComPortPool == NULL );
	g_pComPortPool = new CLockedContextFixedPool< CComPort, DATA_PORT_POOL_CONTEXT* >;
	if ( g_pComPortPool != NULL )
	{
		if ( g_pComPortPool->Initialize() == FALSE )
		{
			delete	g_pComPortPool;
			g_pComPortPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


	//
	// CModemEndpoint pool
	//
	DNASSERT( g_pModemEndpointPool == NULL );
	g_pModemEndpointPool = new CLockedContextFixedPool< CModemEndpoint, ENDPOINT_POOL_CONTEXT* >;
	if ( g_pModemEndpointPool != NULL )
	{
		if ( g_pModemEndpointPool->Initialize() == FALSE )
		{
			delete	g_pModemEndpointPool;
			g_pModemEndpointPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}
	
	//
	// CModemPort pool
	//
	DNASSERT( g_pModemPortPool == NULL );
	g_pModemPortPool = new CLockedContextFixedPool< CModemPort, DATA_PORT_POOL_CONTEXT* >;
	if ( g_pModemPortPool != NULL )
	{
		if ( g_pModemPortPool->Initialize() == FALSE )
		{
			delete	g_pModemPortPool;
			g_pModemPortPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}
	
	//
	// CThreadPool pool
	//
	DNASSERT( g_pThreadPoolPool == NULL );
	g_pThreadPoolPool = new CLockedPool< CThreadPool >;
	if ( g_pThreadPoolPool != NULL )
	{
		if ( g_pThreadPoolPool->Initialize() == FALSE )
		{
			delete	g_pThreadPoolPool;
			g_pThreadPoolPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


Exit:
	return	fReturn;

Failure:
	fReturn = FALSE;
	DeinitializePools();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitializePools - deinitialize the pools
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DeinitializePools"

void	DeinitializePools( void )
{
	//
	// CThreadPool pool
	//
	if ( g_pThreadPoolPool != NULL )
	{
	    g_pThreadPoolPool->Deinitialize();
	    delete	g_pThreadPoolPool;
	    g_pThreadPoolPool = NULL;
	}

	//
	// CModemPort pool
	//
	if ( g_pModemPortPool != NULL )
	{
		g_pModemPortPool->Deinitialize();
		delete	g_pModemPortPool;
		g_pModemPortPool = NULL;
	}
	
	//
	// CModemEndpoint pool
	//
	if ( g_pModemEndpointPool != NULL )
	{
		g_pModemEndpointPool->Deinitialize();
		delete	g_pModemEndpointPool;
		g_pModemEndpointPool = NULL;
	}

	//
	// CComPort pool
	//
	if ( g_pComPortPool != NULL )
	{
		g_pComPortPool->Deinitialize();
		delete	g_pComPortPool;
		g_pComPortPool = NULL;
	}

	//
	// CCommandData
	//
	if ( g_pCommandDataPool != NULL )
	{
		g_pCommandDataPool->Deinitialize();
		delete	g_pCommandDataPool;
		g_pCommandDataPool = NULL;
	}

	//
	// CComEndpoint pool
	//
	if ( g_pComEndpointPool != NULL )
	{
		g_pComEndpointPool->Deinitialize();
		delete	g_pComEndpointPool;
		g_pComEndpointPool = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateCommand - create command
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateCommand"

CCommandData	*CreateCommand( void )
{
	DNASSERT( g_pCommandDataPool != NULL );
	return	g_pCommandDataPool->Get();
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// ReturnCommand - return a command
////
//// Entry:		Pointer to command
////
//// Exit:		Nothing
//// ------------------------------
//void	ReturnCommand( CCommandData *const pCommand )
//{
//    DNASSERT( pCommand != NULL );
//    DNASSERT( g_pCommandDataPool != NULL );
//    g_pCommandDataPool->Release( pCommand );
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// CreateDataPort - create a data port
//
// Entry:		Nothing
//
// Exit:		Pointer to DataPort
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateDataPort"

CDataPort	*CreateDataPort( DATA_PORT_POOL_CONTEXT *pPoolContext )
{
	CDataPort	*pReturn;


	pReturn = NULL;
	switch ( pPoolContext->pSPData->GetType() )
	{
		case TYPE_SERIAL:
		{
			pReturn = g_pComPortPool->Get( pPoolContext );
			break;
		}

		case TYPE_MODEM:
		{
			pReturn = g_pModemPortPool->Get( pPoolContext );
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateEndpoint - create an endpoint
//
// Entry:		Nothing
//
// Exit:		Pointer to Endpoint
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateEndpoint"

CEndpoint	*CreateEndpoint( ENDPOINT_POOL_CONTEXT *const pPoolContext )
{
	CEndpoint	*pReturn;


	pReturn = NULL;
	switch ( pPoolContext->pSPData->GetType() )
	{
		case TYPE_SERIAL:
		{
			pReturn = g_pComEndpointPool->Get( pPoolContext );
			break;
		}

		case TYPE_MODEM:
		{
			pReturn = g_pModemEndpointPool->Get( pPoolContext );
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return	pReturn;
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// CreateComEndpoint - create Com endpoint
////
//// Entry:		Nothing
////
//// Exit:		Pointer to Com endpoint
//// ------------------------------
//CComEndpoint	*CreateComEndpoint( void )
//{
//    DNASSERT( g_pComEndpointPool != NULL );
//    return	g_pComEndpointPool->Get();
//}
////**********************************************************************
//
//
////**********************************************************************
//// ------------------------------
//// ReturnComEndpoint - return an Com endpoint
////
//// Entry:		Pointer to Com endpoint
////
//// Exit:		Nothing
//// ------------------------------
//void	ReturnComEndpoint( CComEndpoint *const pComEndpoint )
//{
//    DNASSERT( pComEndpoint != NULL );
//    DNASSERT( g_pComAddressPool != NULL );
//    g_pComEndpointPool->Release( pComEndpoint );
//}
////**********************************************************************
//
//
////**********************************************************************
//// ------------------------------
//// CreateModemEndpoint - create modem endpoint
////
//// Entry:		Nothing
////
//// Exit:		Pointer to modem endpoint
//// ------------------------------
//CModemEndpoint	*CreateModemEndpoint( void )
//{
//    DNASSERT( g_pModemEndpointPool != NULL );
//    return	g_pModemEndpointPool->Get();
//}
////**********************************************************************
//
//
////**********************************************************************
//// ------------------------------
//// ReturnModemEndpoint - return an modem endpoint
////
//// Entry:		Pointer to modem endpoint
////
//// Exit:		Nothing
//// ------------------------------
//void	ReturnModemEndpoint( CModemEndpoint *const pModemEndpoint )
//{
//    DNASSERT( pModemEndpoint != NULL );
//    DNASSERT( g_pModemAddressPool != NULL );
//    g_pModemEndpointPool->Release( pModemEndpoint );
//}
////**********************************************************************
//
//
////**********************************************************************
//// ------------------------------
//// CreateReceiveBuffer - create a new receive buffer
////
//// Entry:		Nothing
////
//// Exit:		Pointer to receive buffer
//// ------------------------------
//CReceiveBuffer	*CreateReceiveBuffer( void )
//{
//    DNASSERT( g_pReceiveBufferPool != NULL );
//    return g_pReceiveBufferPool->Get( NULL );
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// CreateThreadPool - create a thread pool
//
// Entry:		Nothing
//
// Exit:		Pointer to thread pool
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateThreadPool"

CThreadPool	*CreateThreadPool( void )
{
    DNASSERT( g_pThreadPoolPool != NULL );
    return	g_pThreadPoolPool->Get();
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemsendqueue.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CSendQueue.h
 *  Content:	Queue to manage outgoing sends
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/14/99	jtk		Created
 ***************************************************************************/

#ifndef __SEND_QUEUE_H__
#define __SEND_QUEUE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

//
// forward structure references
//
class	CEndpoint;
class	CWriteIOData;

//
// main class definition
//
class	CSendQueue
{
	public:
		CSendQueue();
		~CSendQueue();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		HRESULT	Initialize( void );
		void	Deinitialize( void ) { DNDeleteCriticalSection( &m_Lock ); }

		//
		// add item to end of queue
		//
		void	Enqueue( CWriteIOData *const pWriteData )
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pTail == NULL )
			{
				m_pHead = pWriteData;
			}
			else
			{
				m_pTail->m_pNext = pWriteData;
			}

			m_pTail = pWriteData;
			pWriteData->m_pNext = NULL;
		}

		//
		// add item to front of queue
		//
		void	AddToFront( CWriteIOData *const pWriteData )
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pHead != NULL )
			{
				pWriteData->m_pNext = m_pHead;
			}
			else
			{
				m_pTail = pWriteData;
				pWriteData->m_pNext = NULL;
			}

			m_pHead = pWriteData;
		}

		//
		// remove item from queue
		//
		CWriteIOData	*Dequeue( void )
		{
			CWriteIOData	*pReturn;


			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			pReturn = m_pHead;
			if ( m_pHead != NULL )
			{
				m_pHead = m_pHead->m_pNext;
				if ( m_pHead == NULL )
				{
					m_pTail = NULL;
				}

				DEBUG_ONLY( pReturn->m_pNext = NULL );
			}

			return	pReturn;
		};

		//
		// determine if queue is empty
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSendQueue::IsEmpty"
		BOOL	IsEmpty( void )	const
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pHead == NULL )
			{
				DNASSERT( m_pTail == NULL );
				return	TRUE;
			}
			else
			{
				return	FALSE;
			}
		}

		CWriteIOData	*FindNextByEndpoint( HANDLE *const pHandle, const CEndpoint *const pEndpoint );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;		// critical section
		CWriteIOData		*m_pHead;	// pointer to queue head
		CWriteIOData		*m_pTail;	// pointer to queue tail
};

#endif	// __SEND_QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemspdata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   SPData.h
 *  Content:	Global information for the DNSerial service provider in class
 *				format.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/15/99	jtk		Derived from Locals.h
 ***************************************************************************/

#ifndef __SPDATA_H__
#define __SPDATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumeration of the states the SP can be in
//
typedef enum
{
	SPSTATE_UNINITIALIZED = 0,	// uninitialized state
	SPSTATE_INITIALIZED,		// service provider has been initialized
	SPSTATE_CLOSING				// service provider is closing
} SPSTATE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CComPortData;
class	CDataPort;
class	CEndpoint;
class	CThreadPool;
typedef	enum	_ENDPOINT_TYPE	ENDPOINT_TYPE;

//
// class for information used by the provider
//
class	CSPData
{	
	public:
		CSPData();
		~CSPData();
		
		DWORD	AddRef( void ) { return DNInterlockedIncrement( &m_lRefCount ); }

		DWORD	DecRef( void )
		{
			DWORD	dwReturn;


			dwReturn = DNInterlockedDecrement( &m_lRefCount );
			if ( dwReturn == 0 )
			{
				//
				// WARNING, the following function deletes this object!!!
				//
				DestroyThisObject();
			}

			return	dwReturn;
		}

		#undef DPF_MODNAME
		#define	DPF_MODNAME "CSPData::ObjectAddRef"
		void	ObjectAddRef( void )
		{
			AddRef();
			
			Lock();
			if ( DNInterlockedIncrement( &m_lObjectRefCount ) == 1 )
			{
				DNASSERT( m_hShutdownEvent != NULL );
				if ( ResetEvent( m_hShutdownEvent ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPFX(DPFPREP,  0, "Failed to reset shutdown event!" );
					DisplayErrorCode( 0, dwError );
				}
			}

			Unlock();
		}

		#undef DPF_MODNAME
		#define	DPF_MODNAME "CSPData::ObjectDecRef"
		void	ObjectDecRef( void )
		{
			Lock();

			if ( DNInterlockedDecrement( &m_lObjectRefCount ) == 0 )
			{
				if ( SetEvent( m_hShutdownEvent ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPFX(DPFPREP,  0, "Failed to set shutdown event!" );
					DisplayErrorCode( 0, dwError );
				}
			}
			
			Unlock();
			
			DecRef();
		}
		
		
		HRESULT	Initialize( const CLSID *const pClassID,
							const SP_TYPE SPType,
							IDP8ServiceProviderVtbl *const pVtbl );
		void	Shutdown( void );
		void	Deinitialize( void );

		void	SetCallbackData( const SPINITIALIZEDATA *const pInitData );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		SPSTATE	GetState( void ) const { return m_State; }
		void	SetState( const SPSTATE NewState ) { m_State = NewState; }

		CThreadPool	*GetThreadPool( void ) const { return m_pThreadPool; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SetThreadPool"
		void	SetThreadPool( CThreadPool *const pThreadPool )
		{
			DNASSERT( ( m_pThreadPool == NULL ) || ( pThreadPool == NULL ) );
			m_pThreadPool = pThreadPool;
		}

		HRESULT BindEndpoint( CEndpoint *const pEndpoint,
							  const DWORD dwDeviceID,
							  const void *const pDeviceContext );
		
		void	UnbindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType );

		void	LockDataPortData( void ) { DNEnterCriticalSection( &m_DataPortDataLock ); }
		void 	UnlockDataPortData( void ) { DNLeaveCriticalSection( &m_DataPortDataLock ); }

		//
		// endpoint and data port pool management
		//
		CEndpoint	*GetNewEndpoint( void );
		CEndpoint	*EndpointFromHandle( const HANDLE hEndpoint );
		void		CloseEndpointHandle( CEndpoint *const pEndpoint );
		CEndpoint	*GetEndpointAndCloseHandle( const HANDLE hEndpoint );

		//
		// COM functions
		//
		const GUID	*GetServiceProviderGuid( void ) const { return &m_ClassID; }
		SP_TYPE	GetType( void ) const { return m_SPType; }
		IDP8SPCallback	*DP8SPCallbackInterface( void ) { return reinterpret_cast<IDP8SPCallback*>( m_InitData.pIDP ); }
		IDP8ServiceProvider	*COMInterface( void ) { return reinterpret_cast<IDP8ServiceProvider*>( &m_COMInterface ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SPDataFromCOMInterface"
		static	CSPData	*SPDataFromCOMInterface( IDP8ServiceProvider *const pCOMInterface )
		{
			DNASSERT( pCOMInterface != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pCOMInterface ) );
			DBG_CASSERT( sizeof( CSPData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CSPData*>( &reinterpret_cast<BYTE*>( pCOMInterface )[ -OFFSETOF( CSPData, m_COMInterface ) ] );
		}

	private:
		BYTE				m_Sig[4];			// debugging signature ('SPDT')
		DNCRITICAL_SECTION	m_Lock;				// lock
		volatile LONG		m_lRefCount;		// reference count
		volatile LONG		m_lObjectRefCount;	// reference count ofo objects (CModemPort, CModemEndpoint, etc.)
		HANDLE				m_hShutdownEvent;	// event signalled when all objects are gone
		CLSID				m_ClassID;			// class ID
		SP_TYPE				m_SPType;			// SP type
		SPSTATE				m_State;			// status of the service provider
		SPINITIALIZEDATA	m_InitData;			// initialization data
		CThreadPool			*m_pThreadPool;		// thread pool for jobs

		CHandleTable		m_HandleTable;		// handle table

		DNCRITICAL_SECTION	m_DataPortDataLock;
		CDataPort		*m_DataPortList[ MAX_DATA_PORTS ];

		BOOL	m_fLockInitialized;
		BOOL	m_fHandleTableInitialized;
		BOOL	m_fDataPortDataLockInitialized;
		BOOL	m_fInterfaceGlobalsInitialized;

		struct
		{
			IDP8ServiceProviderVtbl	*m_pCOMVtbl;
		} m_COMInterface;

		void	DestroyThisObject( void );

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent unwarranted copies
		//
		CSPData( const CSPData & );
		CSPData& operator=( const CSPData & );
};

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME

#endif	// __SPDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemspdata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   SPData.cpp
 *  Content:	Global variables for the DNSerial service provider in class
 *				format.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/15/99	jtk		Dereived from Locals.cpp
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

// default number of command descriptors to create
#define	DEFAULT_COMMAND_POOL_SIZE	20
#define	COMMAND_POOL_GROW_SIZE		5

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CSPData::CSPData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::CSPData"

CSPData::CSPData():
	m_lRefCount( 0 ),
	m_lObjectRefCount( 0 ),
	m_hShutdownEvent( NULL ),
	m_SPType( TYPE_UNKNOWN ),
	m_State( SPSTATE_UNINITIALIZED ),
	m_pThreadPool( NULL ),
	m_fLockInitialized( FALSE ),
	m_fHandleTableInitialized( FALSE ),
	m_fDataPortDataLockInitialized( FALSE ),
	m_fInterfaceGlobalsInitialized( FALSE )
{
	m_Sig[0] = 'S';
	m_Sig[1] = 'P';
	m_Sig[2] = 'D';
	m_Sig[3] = 'T';
	
	memset( &m_ClassID, 0x00, sizeof( m_ClassID ) );
	memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	memset( &m_DataPortList, 0x00, sizeof( m_DataPortList ) );
	memset( &m_COMInterface, 0x00, sizeof( m_COMInterface ) );
	DNInterlockedIncrement( &g_lOutstandingInterfaceCount );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::~CSPData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::~CSPData"

CSPData::~CSPData()
{
	UINT_PTR	uIndex;


	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_lObjectRefCount == 0 );
	DNASSERT( m_hShutdownEvent == NULL );
	DNASSERT( m_SPType == TYPE_UNKNOWN );
	DNASSERT( m_State == SPSTATE_UNINITIALIZED );
	DNASSERT( m_pThreadPool == NULL );

	uIndex = LENGTHOF( m_DataPortList );
	while ( uIndex > 0 )
	{
		uIndex--;
		DNASSERT( m_DataPortList[ uIndex ] == NULL );
	}

	DNASSERT( m_fLockInitialized == FALSE );
	DNASSERT( m_fHandleTableInitialized == FALSE );
	DNASSERT( m_fDataPortDataLockInitialized == FALSE );
	DNASSERT( m_fInterfaceGlobalsInitialized == FALSE );
	DNInterlockedDecrement( &g_lOutstandingInterfaceCount );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Initialize - intialize
//
// Entry:		Pointer to DirectNet
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::Initialize"

HRESULT	CSPData::Initialize( const CLSID *const pClassID,
							 const SP_TYPE SPType,
							 IDP8ServiceProviderVtbl *const pVtbl )
{
	HRESULT		hr;


	DNASSERT( pClassID != NULL );
	DNASSERT( pVtbl != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( m_lRefCount == 1 );
	DNASSERT( m_lObjectRefCount == 0 );
	DNASSERT( GetType() == TYPE_UNKNOWN );

	DBG_CASSERT( sizeof( m_ClassID ) == sizeof( *pClassID ) );
	memcpy( &m_ClassID, pClassID, sizeof( m_ClassID ) );

	DNASSERT( GetType() == TYPE_UNKNOWN );
	m_SPType = SPType;

	DNASSERT( m_COMInterface.m_pCOMVtbl == NULL );
	m_COMInterface.m_pCOMVtbl = pVtbl;

	DNASSERT( m_fLockInitialized == FALSE );
	DNASSERT( m_fDataPortDataLockInitialized == FALSE );
	DNASSERT( m_fInterfaceGlobalsInitialized == FALSE );

	//
	// attempt to initialize shutdown event
	//
	DNASSERT( m_hShutdownEvent == NULL );
	m_hShutdownEvent = CreateEvent( NULL,		// pointer to security (none)
									TRUE,		// manual reset
									TRUE,		// start signalled (so close can be called without any endpoints being created)
									NULL		// pointer to name (none)
									);
	if ( m_hShutdownEvent == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create event for shutting down spdata!" );
		DisplayErrorCode( 0, dwError );
	}

	//
	// initialize critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to initialize SP lock!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	m_fLockInitialized = TRUE;


	hr = m_HandleTable.Initialize();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to initialize handle table!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	m_fHandleTableInitialized = TRUE;

	if ( DNInitializeCriticalSection( &m_DataPortDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to initialize data port data lock!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_DataPortDataLock, 0 );
	m_fDataPortDataLockInitialized = TRUE;

	//
	// get a thread pool
	//
	DNASSERT( m_pThreadPool == NULL );
	hr = InitializeInterfaceGlobals( this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to create thread pool!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	m_fInterfaceGlobalsInitialized = TRUE;

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CSPData::Initialize" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	Deinitialize();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Shutdown - shut down this set of SP data
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::Shutdown"

void	CSPData::Shutdown( void )
{
	BOOL	fLooping;


	//
	// Unbind this interface from the globals.  This will cause a closure of all
	// of the I/O which will release endpoints, socket ports and then this data.
	//
	if ( m_fInterfaceGlobalsInitialized != FALSE )
	{
		DeinitializeInterfaceGlobals( this );
		DNASSERT( GetThreadPool() != NULL );
		m_fInterfaceGlobalsInitialized = FALSE;
	}

	SetState( SPSTATE_CLOSING );
	
	DNASSERT( m_hShutdownEvent != NULL );
	
	fLooping = TRUE;
	while ( fLooping != FALSE )
	{
		switch ( WaitForSingleObjectEx( m_hShutdownEvent, INFINITE, TRUE ) )
		{
			case WAIT_OBJECT_0:
			{
				fLooping = FALSE;
				break;
			}

			case WAIT_IO_COMPLETION:
			{
				break;
			}

			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	if ( CloseHandle( m_hShutdownEvent ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to close shutdown event!" );
		DisplayErrorCode( 0, dwError );
	}
	m_hShutdownEvent = NULL;

	if ( DP8SPCallbackInterface() != NULL)
	{
		IDP8SPCallback_Release( DP8SPCallbackInterface() );
		memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Deinitialize - deinitialize
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::Deinitialize"

void	CSPData::Deinitialize( void )
{
	HRESULT	hTempResult;


	DPFX(DPFPREP,  9, "Entering CSPData::Deinitialize" );

	//
	// deinitialize interface globals
	//
	if ( m_fInterfaceGlobalsInitialized != FALSE )
	{
		DeinitializeInterfaceGlobals( this );
		DNASSERT( GetThreadPool() != NULL );
		m_fInterfaceGlobalsInitialized = FALSE;
	}

	if ( m_fDataPortDataLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_DataPortDataLock );
		m_fDataPortDataLockInitialized = FALSE;
	}
	
	if ( m_fHandleTableInitialized != FALSE )
	{
		m_HandleTable.Deinitialize();
		m_fHandleTableInitialized = FALSE;
	}

	if ( m_fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		m_fLockInitialized = FALSE;
	}

	m_COMInterface.m_pCOMVtbl = NULL;

	SetState( SPSTATE_UNINITIALIZED );
	m_SPType = TYPE_UNKNOWN;
	memset( &m_ClassID, 0x00, sizeof( m_ClassID ) );

	if ( GetThreadPool() != NULL )
	{
		GetThreadPool()->DecRef();
		SetThreadPool( NULL );
	}
	
	if ( m_hShutdownEvent != NULL )
	{
		if ( CloseHandle( m_hShutdownEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to close shutdown handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hShutdownEvent = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::SetCallbackData - set data for SP callbacks to application
//
// Entry:		Pointer to initialization data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::SetCallbackData"

void	CSPData::SetCallbackData( const SPINITIALIZEDATA *const pInitData )
{
	DNASSERT( pInitData != NULL );

	DNASSERT( pInitData->dwFlags == 0 );
	m_InitData.dwFlags = pInitData->dwFlags;

	DNASSERT( pInitData->pIDP != NULL );
	m_InitData.pIDP = pInitData->pIDP;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::BindEndpoint - bind endpoint to a data port
//
// Entry:		Pointer to endpoint
//				DeviceID
//				Device context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::BindEndpoint"

HRESULT	CSPData::BindEndpoint( CEndpoint *const pEndpoint,
							   const DWORD dwDeviceID,
							   const void *const pDeviceContext )
{
	HRESULT	hr;
	CDataPort	*pDataPort;
	BOOL	fDataPortDataLocked;
	BOOL	fDataPortCreated;
	BOOL	fDataPortBoundToNetwork;

	
 	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p, %u, 0x%p)",
 		this, pEndpoint, dwDeviceID, pDeviceContext);
 	
	//
	// intialize
	//
	hr = DPN_OK;
	pDataPort = NULL;
	fDataPortDataLocked = FALSE;
	fDataPortCreated = FALSE;
	fDataPortBoundToNetwork = FALSE;

	LockDataPortData();
	fDataPortDataLocked = TRUE;
	
	if ( m_DataPortList[ dwDeviceID ] != NULL )
	{
		pDataPort = m_DataPortList[ dwDeviceID ];
	}
	else
	{
		DATA_PORT_POOL_CONTEXT	DataPortPoolContext;


		memset( &DataPortPoolContext, 0x00, sizeof( DataPortPoolContext ) );
		DataPortPoolContext.pSPData = this;

		pDataPort = CreateDataPort( &DataPortPoolContext );
		if ( pDataPort == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP,  0, "Failed to create new data port!" );
			goto Failure;
		}
		fDataPortCreated = TRUE;

		hr = GetThreadPool()->CreateDataPortHandle( pDataPort );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed to create handle for data port!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}

		hr = pDataPort->BindToNetwork( dwDeviceID, pDeviceContext );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed to bind data port to network!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
		fDataPortBoundToNetwork = TRUE;

		//
		// update the list, keep the reference added by 'CreateDataPort' as it
		// will be cleaned when the data port is removed from the active list.
		//
		m_DataPortList[ dwDeviceID ] = pDataPort;
	}
	

	DNASSERT( pDataPort != NULL );
	pDataPort->EndpointAddRef();

	hr = pDataPort->BindEndpoint( pEndpoint, pEndpoint->GetType() );
	if ( hr != DPN_OK )
	{
		pDataPort->EndpointDecRef();
		DPFX(DPFPREP,  0, "Failed to bind endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( fDataPortDataLocked != FALSE )
	{
		UnlockDataPortData();
		fDataPortDataLocked = FALSE;
	}

	DPFX(DPFPREP, 9, "(0x%p) Returning [0x%lx]", this, hr);
	
	return	hr;

Failure:
	if ( pDataPort != NULL )
	{
		if ( fDataPortBoundToNetwork != FALSE )
		{
			pDataPort->UnbindFromNetwork();
			fDataPortBoundToNetwork = FALSE;
		}

		if ( fDataPortCreated != FALSE )
		{
			if ( pDataPort->GetHandle() != INVALID_HANDLE_VALUE )
			{
				GetThreadPool()->CloseDataPortHandle( pDataPort );
				DNASSERT( pDataPort->GetHandle() == INVALID_HANDLE_VALUE );
			}

			pDataPort->DecRef();
			fDataPortCreated = FALSE;
		}
		
		pDataPort = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::UnbindEndpoint - unbind an endpoint from a dataport
//
// Entry:		Pointer to endpoint
//				Endpoint type
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::UnbindEndpoint"

void	CSPData::UnbindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType )
{
	CDataPort	*pDataPort;
	DWORD		dwDeviceID;
	BOOL		fCleanUpDataPort;


 	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p, %u)", this, pEndpoint, EndpointType);

 	
	DNASSERT( pEndpoint != NULL );

	//
	// initialize
	//
	pDataPort = NULL;
	fCleanUpDataPort = FALSE;

	pDataPort = pEndpoint->GetDataPort();
	dwDeviceID = pDataPort->GetDeviceID();
	
	LockDataPortData();

	pDataPort->UnbindEndpoint( pEndpoint, EndpointType );
	if ( pDataPort->EndpointDecRef() == 0 )
	{
		DNASSERT( m_DataPortList[ dwDeviceID ] == pDataPort );
		m_DataPortList[ dwDeviceID ] = NULL;
		fCleanUpDataPort = TRUE;
	}

	UnlockDataPortData();

	if ( fCleanUpDataPort != FALSE )
	{
		pDataPort->DecRef();
		fCleanUpDataPort = FALSE;
	}
	
	
	DPFX(DPFPREP, 9, "(0x%p) Leave", this);
}
//**********************************************************************




//**********************************************************************
// ------------------------------
// CSPData::GetNewEndpoint - get a new endpoint
//
// Entry:		Nothing
//
// Exit:		Pointer to new endpoint
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::GetNewEndpoint"

CEndpoint	*CSPData::GetNewEndpoint( void )
{
	HRESULT		hTempResult;
	CEndpoint	*pEndpoint;
	HANDLE		hEndpoint;
	ENDPOINT_POOL_CONTEXT	PoolContext;

	
 	DPFX(DPFPREP, 9, "(0x%p) Enter", this);
 	
	//
	// initialize
	//
	pEndpoint = NULL;
	hEndpoint = INVALID_HANDLE_VALUE;
	memset( &PoolContext, 0x00, sizeof( PoolContext ) );

	PoolContext.pSPData = this;
	pEndpoint = CreateEndpoint( &PoolContext );
	if ( pEndpoint == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to create endpoint!" );
		goto Failure;
	}
	
	m_HandleTable.Lock();
	hTempResult = m_HandleTable.CreateHandle( &hEndpoint, pEndpoint );
	m_HandleTable.Unlock();
	
	if ( hTempResult != DPN_OK )
	{
		DNASSERT( hEndpoint == INVALID_HANDLE_VALUE );
		DPFX(DPFPREP,  0, "Failed to create endpoint handle!" );
		DisplayErrorCode( 0, hTempResult );
		goto Failure;
	}

	pEndpoint->SetHandle( hEndpoint );
	pEndpoint->AddCommandRef();
	pEndpoint->DecRef();

Exit:
	
	DPFX(DPFPREP, 9, "(0x%p) Returning [0x%p]", this, pEndpoint);
	
	return	pEndpoint;

Failure:
	if ( hEndpoint != INVALID_HANDLE_VALUE )
	{
		m_HandleTable.Lock();
		m_HandleTable.InvalidateHandle( hEndpoint );
		m_HandleTable.Unlock();
	
		hEndpoint = INVALID_HANDLE_VALUE;
	}

	if ( pEndpoint != NULL )
	{
		pEndpoint->DecRef();
		pEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::EndpointFromHandle - get endpoint from handle
//
// Entry:		Handle
//
// Exit:		Pointer to endpoint
//				NULL = invalid handle
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::EndpointFromHandle"

CEndpoint	*CSPData::EndpointFromHandle( const HANDLE hEndpoint )
{
	CEndpoint	*pEndpoint;


 	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p)", this, hEndpoint);
 	
	pEndpoint = NULL;
	m_HandleTable.Lock();
	
	pEndpoint = static_cast<CEndpoint*>( m_HandleTable.GetAssociatedData( hEndpoint ) );
	if ( pEndpoint != NULL )
	{
		pEndpoint->AddCommandRef();
	}
	
	m_HandleTable.Unlock();

	DPFX(DPFPREP, 9, "(0x%p) Returning [0x%p]", this, pEndpoint);

	return	pEndpoint;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::CloseEndpointHandle - close endpoint handle
//
// Entry:		Poiner to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::CloseEndpointHandle"

void	CSPData::CloseEndpointHandle( CEndpoint *const pEndpoint )
{
	HANDLE	Handle;
	BOOL	fCloseReturn;

	DNASSERT( pEndpoint != NULL );
	Handle = pEndpoint->GetHandle();


	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p {handle = 0x%p})",
		this, pEndpoint, Handle);
	
	m_HandleTable.Lock();
	fCloseReturn = m_HandleTable.InvalidateHandle( Handle );
	m_HandleTable.Unlock();

	if ( fCloseReturn != FALSE )
	{
		pEndpoint->DecCommandRef();
	}

	DPFX(DPFPREP, 9, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::GetEndpointAndCloseHandle - get endpoint from handle and close the
//		handle
//
// Entry:		Handle
//
// Exit:		Pointer to endpoint (it needs a call to 'DecCommandRef' when done)
//				NULL = invalid handle
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSPData::GetEndpointAndCloseHandle"

CEndpoint	*CSPData::GetEndpointAndCloseHandle( const HANDLE hEndpoint )
{
	CEndpoint	*pEndpoint;
	BOOL	fCloseReturn;


 	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p)", this, hEndpoint);


	//
	// initialize
	//
	pEndpoint = NULL;
	fCloseReturn = FALSE;
	m_HandleTable.Lock();
	
	pEndpoint = static_cast<CEndpoint*>( m_HandleTable.GetAssociatedData( hEndpoint ) );
	if ( pEndpoint != NULL )
	{
		pEndpoint->AddRef();
		pEndpoint->AddCommandRef();
		fCloseReturn = m_HandleTable.InvalidateHandle( hEndpoint );
		DNASSERT( fCloseReturn != FALSE );
	}
	
	m_HandleTable.Unlock();

	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
	}


	DPFX(DPFPREP, 9, "(0x%p) Returning [0x%p]", this, pEndpoint);
	
	return	pEndpoint;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::DestroyThisObject - destroy this object
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::DestroyThisObject"
void	CSPData::DestroyThisObject( void )
{
	Deinitialize();
	delete	this;		// maybe a little too extreme......
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemthreadpool.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		ThreadPool.cpp
 *  Content:	main job thread pool
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// events for threads
//
enum
{
	EVENT_INDEX_STOP_ALL_THREADS = 0,
	EVENT_INDEX_PENDING_JOB = 1,
	EVENT_INDEX_WAKE_NT_TIMER_THREAD = 1,
	EVENT_INDEX_SEND_COMPLETE = 2,
	EVENT_INDEX_RECEIVE_COMPLETE = 3,
	EVENT_INDEX_TAPI_MESSAGE = 4,

	EVENT_INDEX_MAX
};

//
// times to wait in milliseconds when polling for work thread shutdown
//
#define	WORK_THREAD_CLOSE_WAIT_TIME		3000
#define	WORK_THREAD_CLOSE_SLEEP_TIME	100

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct	_TIMER_OPERATION_ENTRY
{
	CBilink		Linkage;			// list links
	void		*pContext;			// user context passed back in timer events

	//
	// timer information
	//
	UINT_PTR	uRetryCount;		// number of times to retry this event
	BOOL		fRetryForever;		// Boolean for retrying forever
	DN_TIME		RetryInterval;		// time between enums (milliseconds)
	DN_TIME		IdleTimeout;		// time at which the command sits idle after all retrys are complete
	BOOL		fIdleWaitForever;	// Boolean for waiting forever in idle state
	DN_TIME		NextRetryTime;		// time at which this event will fire next (milliseconds)

	TIMER_EVENT_CALLBACK	*pTimerCallback;	// callback for when this event fires
	TIMER_EVENT_COMPLETE	*pTimerComplete;	// callback for when this event is complete

	#undef DPF_MODNAME
	#define DPF_MODNAME "_TIMER_OPERATION_ENTRY::TimerOperationFromLinkage"
	static TIMER_OPERATION_ENTRY	*TimerOperationFromLinkage( CBilink *const pLinkage )
	{
		DNASSERT( pLinkage != NULL );
		DBG_CASSERT( OFFSETOF( _TIMER_OPERATION_ENTRY, Linkage ) == 0 );
		return	reinterpret_cast<_TIMER_OPERATION_ENTRY*>( pLinkage );
	}

} TIMER_OPERATION_ENTRY;

//
// structure for common data in Win9x thread
//
typedef	struct	_WIN9X_CORE_DATA
{
	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
	DWORD		dwWaitHandleCount;					// count of handles to wait on
	DWORD		dwTimeToNextJob;					// time to next job
	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
	BOOL		fLooping;							// Boolean indicating that this thread is still active

} WIN9X_CORE_DATA;

//
// information passed to the Win9x workhorse thread
//
typedef struct	_WIN9X_THREAD_DATA
{
	CThreadPool		*pThisThreadPool;	// pointer to this object
} WIN9X_THREAD_DATA;

//
// information passed to the IOCompletion thread
//
typedef struct	_IOCOMPLETION_THREAD_DATA
{
	CThreadPool		*pThisThreadPool;	// pointer to this object
} IOCOMPLETION_THREAD_DATA;

//
// structure passed to dialog threads
//
typedef	struct	_DIALOG_THREAD_PARAM
{
	DIALOG_FUNCTION	*pDialogFunction;
	void			*pContext;
	CThreadPool		*pThisThreadPool;
} DIALOG_THREAD_PARAM;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CThreadPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::CThreadPool"

CThreadPool::CThreadPool():
	m_pOwningPool( NULL ),
	m_iTotalThreadCount( 0 ),
#ifdef WINNT
	m_iNTCompletionThreadCount( 0 ),
	m_fNTTimerThreadRunning( FALSE ),
	m_hIOCompletionPort( NULL ),
#endif
	m_fAllowThreadCountReduction( FALSE ),
	m_iIntendedThreadCount( 0 ),
	m_hStopAllThreads( NULL ),
#ifdef WIN95
	m_hSendComplete( NULL ),
	m_hReceiveComplete( NULL ),
	m_hTAPIEvent( NULL ),
	m_hFakeTAPIEvent( NULL ),
#endif
	m_fTAPIAvailable( FALSE )
{
	m_Sig[0] = 'T';
	m_Sig[1] = 'H';
	m_Sig[2] = 'P';
	m_Sig[3] = 'L';
	
	m_OutstandingReadList.Initialize();
	m_OutstandingWriteList.Initialize();
	memset( &m_InitFlags, 0x00, sizeof( m_InitFlags ) );
	memset( &m_TAPIInfo, 0x00, sizeof( m_TAPIInfo ) );
	m_TimerJobList.Initialize();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::~CThreadPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::~CThreadPool"

CThreadPool::~CThreadPool()
{
	DNASSERT( m_pOwningPool == NULL );
	DNASSERT( m_iTotalThreadCount == 0 );
#ifdef WINNT
	DNASSERT( m_iNTCompletionThreadCount == 0 );
	DNASSERT( m_fNTTimerThreadRunning == FALSE );
	DNASSERT( m_hIOCompletionPort == NULL );
#endif
	DNASSERT( m_fAllowThreadCountReduction == FALSE );
	DNASSERT( m_iIntendedThreadCount == 0 );
	DNASSERT( m_hStopAllThreads == NULL );
#ifdef WIN95
	DNASSERT( m_hSendComplete == NULL );
	DNASSERT( m_hReceiveComplete == NULL );
	DNASSERT( m_hTAPIEvent == NULL );
	DNASSERT( m_hFakeTAPIEvent == NULL );
#endif
	DNASSERT( m_fTAPIAvailable == FALSE );

	DNASSERT( m_OutstandingReadList.IsEmpty() != FALSE );
	DNASSERT( m_OutstandingReadList.IsEmpty() != FALSE );
	DNASSERT( m_TimerJobList.IsEmpty() != FALSE );

	DNASSERT( m_InitFlags.fTAPILoaded == FALSE );
	DNASSERT( m_InitFlags.fLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fIODataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobDataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fTimerDataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobQueueInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobPoolInitialized == FALSE );
	DNASSERT( m_InitFlags.fTimerEntryPoolInitialized == FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::Initialize - initialize work threads
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::Initialize"

BOOL	CThreadPool::Initialize( void )
{
	HRESULT	hTempResult;
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;
	DNASSERT( m_InitFlags.fTAPILoaded == FALSE );
	DNASSERT( m_InitFlags.fLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fIODataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobDataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fTimerDataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fDataPortHandleTableInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobQueueInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobPoolInitialized == FALSE );
	DNASSERT( m_InitFlags.fTimerEntryPoolInitialized == FALSE );

	//
	// try to load TAPI before anything else
	//
	hTempResult = LoadTAPILibrary();
	if ( hTempResult == DPN_OK )
	{
		m_InitFlags.fTAPILoaded = TRUE;
	}
	else
	{
		DPFX(DPFPREP,  0, "Failed to load TAPI!" );
		DisplayDNError( 0, hTempResult );
	}

	//
	// initialize critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	m_InitFlags.fLockInitialized = TRUE;

	//
	// Win9x has poor APC support and as part of the workaround, the read and
	// write data locks need to be taken twice.  Adjust the recursion counts
	// accordingly.
	//
	if ( DNInitializeCriticalSection( &m_IODataLock ) == FALSE )
	{
	    goto Failure;
	}
#ifdef DEBUG
	DebugSetCriticalSectionRecursionCount( &m_IODataLock, 1 );
#endif
	m_InitFlags.fIODataLockInitialized = TRUE;

	if ( DNInitializeCriticalSection( &m_JobDataLock ) == FALSE )
	{
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_JobDataLock, 0 );
	m_InitFlags.fJobDataLockInitialized = TRUE;

	if ( DNInitializeCriticalSection( &m_TimerDataLock ) == FALSE )
	{
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_TimerDataLock, 0 );
	m_InitFlags.fTimerDataLockInitialized = TRUE;

	//
	// handle table
	//
	if ( m_DataPortHandleTable.Initialize() != DPN_OK )
	{
		goto Failure;
	}
	m_InitFlags.fDataPortHandleTableInitialized = TRUE;

	//
	// initialize job queue
	//
	if ( m_JobQueue.Initialize() == FALSE )
	{
		goto Failure;
	}
	m_InitFlags.fJobQueueInitialized = TRUE;

	//
	// job pool
	//
	if ( FPM_Initialize( &m_JobPool,					// pointer to pool
			    		 sizeof( THREAD_POOL_JOB ),		// size of pool entry
			    		 ThreadPoolJob_Alloc,			// function called on pool entry initial allocation
			    		 ThreadPoolJob_Get,				// function called on entry extraction from pool
			    		 ThreadPoolJob_Release,			// function called on entry return to pool
			    		 ThreadPoolJob_Dealloc			// function called on entry free
			    		 ) == FALSE )
	{
		goto Failure;
	}
	m_InitFlags.fJobPoolInitialized = TRUE;

	//
	// enum entry pool
	//
	if ( FPM_Initialize( &m_TimerEntryPool,					// pointer to pool
			    		 sizeof( TIMER_OPERATION_ENTRY ),	// size of pool entry
			    		 TimerEntry_Alloc,					// function called on pool entry initial allocation
			    		 TimerEntry_Get,					// function called on entry extraction from pool
			    		 TimerEntry_Release,				// function called on entry return to pool
			    		 TimerEntry_Dealloc					// function called on entry free
			    		 ) == FALSE )
	{
		goto Failure;
	}
	m_InitFlags.fTimerEntryPoolInitialized = TRUE;

	//
	// Create event to stop all threads.  Win9x needs this to stop processing
	// and the NT enum thread uses this to stop processing
	//
	DNASSERT( m_hStopAllThreads == NULL );
	m_hStopAllThreads = CreateEvent( NULL,		// pointer to security (none)
			    					 TRUE,		// manual reset
			    					 FALSE,		// start unsignalled
			    					 NULL );	// pointer to name (none)
	if ( m_hStopAllThreads == NULL )
	{
		DWORD   dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create event to stop all threads!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

	DNASSERT( m_fAllowThreadCountReduction == FALSE );
	m_fAllowThreadCountReduction = TRUE;

	//
	// OS-specific initialization
	//
#ifdef WINNT
	//
	// WinNT
	//
	if (FAILED(WinNTInit()))
	{
		goto Failure;
	}
#else // WIN95
	//
	// Windows 9x
	//
	if (FAILED(Win9xInit()))
	{
		goto Failure;
	}
#endif

	//
	// Verify all internal flags.  It's possible that TAPI didn't load
	// so don't check it (it's not a fatal condition).
	//
	DNASSERT( m_InitFlags.fLockInitialized != FALSE );
	DNASSERT( m_InitFlags.fIODataLockInitialized != FALSE );
	DNASSERT( m_InitFlags.fJobDataLockInitialized != FALSE );
	DNASSERT( m_InitFlags.fTimerDataLockInitialized != FALSE );
	DNASSERT( m_InitFlags.fJobQueueInitialized != FALSE );
	DNASSERT( m_InitFlags.fJobPoolInitialized != FALSE );
	DNASSERT( m_InitFlags.fTimerEntryPoolInitialized != FALSE );

Exit:
	return	fReturn;

Failure:
	fReturn = FALSE;
	StopAllThreads();
	Deinitialize();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::Deinitialize - destroy work threads
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::Deinitialize"

void	CThreadPool::Deinitialize( void )
{
	DNASSERT( m_JobQueue.IsEmpty() != FALSE );

	//
	// request that all threads stop and then cycle our timeslice to
	// allow the threads a chance for cleanup
	//
	m_fAllowThreadCountReduction = FALSE;
	DPFX(DPFPREP, 9, "SetIntendedThreadCount 0");
	SetIntendedThreadCount( 0 );
	StopAllThreads();
	SleepEx( 0, TRUE );

#ifdef WINNT
	if ( m_hIOCompletionPort != NULL )
	{
		if ( CloseHandle( m_hIOCompletionPort ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing handle to I/O completion port!" );
			DisplayErrorCode( 0, dwError );
		}
		m_hIOCompletionPort = NULL;
	}
#endif

	//
	// close StopAllThreads handle
	//
	if ( m_hStopAllThreads != NULL )
	{
		if ( CloseHandle( m_hStopAllThreads ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to close StopAllThreads handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hStopAllThreads = NULL;
	}

#ifdef WIN95
	//
	// close handles for I/O events
	//
	if ( m_hSendComplete != NULL )
	{
		if ( CloseHandle( m_hSendComplete ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing SendComplete handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hSendComplete = NULL;
	}

	if ( m_hReceiveComplete != NULL )
	{
		if ( CloseHandle( m_hReceiveComplete ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing ReceiveComplete handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hReceiveComplete = NULL;
	}
#endif // WIN95
	//
	// Now that all of the threads are stopped, clean up any outstanding I/O.
	// this can be done without taking any locks
	//
	CancelOutstandingIO();	

	//
	// deinitialize pools
	//

	// timer entry pool
	if ( m_InitFlags.fTimerEntryPoolInitialized != FALSE )
	{
		FPM_Deinitialize( &m_TimerEntryPool );
		m_InitFlags.fTimerEntryPoolInitialized = FALSE;
	}

	// job pool
	if ( m_InitFlags.fJobPoolInitialized != FALSE )
	{
		FPM_Deinitialize( &m_JobPool );
		m_InitFlags.fJobPoolInitialized = FALSE;
	}

	//
	// double-check empty IO lists
	//
	DNASSERT( m_OutstandingWriteList.IsEmpty() != FALSE );
	DNASSERT( m_OutstandingReadList.IsEmpty() != FALSE );

	//
	// deinitialize handle table
	//
	if ( m_InitFlags.fDataPortHandleTableInitialized != FALSE )
	{
		m_DataPortHandleTable.Deinitialize();
		m_InitFlags.fDataPortHandleTableInitialized = FALSE;
	}

	//
	// deinitialize job queue
	//
	if ( m_InitFlags.fJobQueueInitialized != FALSE )
	{
		m_JobQueue.Deinitialize();
		m_InitFlags.fJobQueueInitialized = FALSE;
	}

	if ( m_InitFlags.fTimerDataLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_TimerDataLock );
		m_InitFlags.fTimerDataLockInitialized = FALSE;
	}

	if ( m_InitFlags.fJobDataLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_JobDataLock );
		m_InitFlags.fJobDataLockInitialized = FALSE;
	}

	if ( m_InitFlags.fIODataLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_IODataLock );
		m_InitFlags.fIODataLockInitialized = FALSE;
	}

	if ( m_InitFlags.fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		m_InitFlags.fLockInitialized = FALSE;
	}

	//
	// unload TAPI
	//
	if ( m_TAPIInfo.hApplicationInstance != NULL )
	{
		DNASSERT( p_lineShutdown != NULL );
		p_lineShutdown( m_TAPIInfo.hApplicationInstance );
		m_TAPIInfo.hApplicationInstance = NULL;
	}
	m_fTAPIAvailable = FALSE;
	memset( &m_TAPIInfo, 0x00, sizeof( m_TAPIInfo ) );

#ifdef WIN95
	m_hTAPIEvent = NULL;

	if ( m_hFakeTAPIEvent != NULL )
	{
		if ( CloseHandle( m_hFakeTAPIEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing fake TAPI event!" );
			DisplayErrorCode( 0, GetLastError() );
		}

		m_hFakeTAPIEvent = NULL;
	}
#endif
	//
	// close TAPI
	//
	if ( m_InitFlags.fTAPILoaded != FALSE )
	{
		UnloadTAPILibrary();
		m_InitFlags.fTAPILoaded = FALSE;
	}

	DNASSERT( m_InitFlags.fTAPILoaded == FALSE );
	DNASSERT( m_InitFlags.fLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fIODataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobDataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fTimerDataLockInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobQueueInitialized == FALSE );
	DNASSERT( m_InitFlags.fJobPoolInitialized == FALSE );
	DNASSERT( m_InitFlags.fTimerEntryPoolInitialized == FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CreateReadIOData - create read IO data
//
// Entry:		Nothing
//
// Exit:		Pointer to Read IO Data
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::CreateReadIOData"

CReadIOData	*CThreadPool::CreateReadIOData( void )
{
	CReadIOData	*pReadData;


	LockReadData();
#ifdef WIN95
	pReadData = m_ReadIODataPool.Get( GetReceiveCompleteEvent() );
#else
	pReadData = m_ReadIODataPool.Get( NULL );
#endif
	if ( pReadData != NULL )
	{
		pReadData->SetThreadPool( this );
		pReadData->m_OutstandingReadListLinkage.InsertBefore( &m_OutstandingReadList );
		pReadData->AddRef();
	}

	UnlockReadData();
	return	pReadData;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ReturnReadIOData - return read data to pool
//
// Entry:		Pointer to read data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ReturnReadIOData"

void	CThreadPool::ReturnReadIOData( CReadIOData *const pReadIOData )
{
	DNASSERT( pReadIOData != NULL );

	LockReadData();

	pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
	DNASSERT( pReadIOData->m_OutstandingReadListLinkage.IsEmpty() != FALSE );

	m_ReadIODataPool.Release( pReadIOData );

	UnlockReadData();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CreateWriteIOData - create Write IO data
//
// Entry:		Nothing
//
// Exit:		Pointer to Write IO Data
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::CreateWriteIOData"

CWriteIOData	*CThreadPool::CreateWriteIOData( void )
{
	CWriteIOData	*pWriteData;


	LockWriteData();
#ifdef WIN95
	pWriteData = m_WriteIODataPool.Get( GetSendCompleteEvent() );
#else // WINNT
	pWriteData = m_WriteIODataPool.Get( NULL );
#endif
	if ( pWriteData != NULL )
	{
		pWriteData->m_OutstandingWriteListLinkage.InsertBefore( &m_OutstandingWriteList );
	}

	UnlockWriteData();
	return	pWriteData;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ReturnWriteIOData - return write data to pool
//
// Entry:		Pointer to Write data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ReturnWriteIOData"

void	CThreadPool::ReturnWriteIOData( CWriteIOData *const pWriteIOData )
{
	DNASSERT( pWriteIOData != NULL );

	LockWriteData();

	pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();

	m_WriteIODataPool.Release( pWriteIOData );

	UnlockWriteData();
}
//**********************************************************************

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::WinNTInit - initialize WinNT components
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::WinNTInit"

HRESULT	CThreadPool::WinNTInit( void )
{
	HRESULT			hr;
	UINT_PTR		uDesiredThreads;
	LINEINITIALIZEEXPARAMS	LineInitializeExParams;
	LONG			lReturn;


	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( m_hIOCompletionPort == NULL );
	m_hIOCompletionPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE,	    // don't associate a file handle yet
												  NULL,					    // handle of existing completion port (none)
												  NULL,					    // completion key for callback (none)
												  0						    // number of concurent threads (0 = use number of processors)
												  );
	if ( m_hIOCompletionPort == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Could not create NT IOCompletionPort!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	//
	// Initialize TAPI.  If TAPI doesn't start, it's not a problem, but note
	// the failure.
	//
	DNASSERT( m_fTAPIAvailable == FALSE );
	memset( &m_TAPIInfo, 0x00, sizeof( m_TAPIInfo ) );
	memset( &LineInitializeExParams, 0x00, sizeof( LineInitializeExParams ) );
	m_TAPIInfo.dwVersion = TAPI_CURRENT_VERSION;
	LineInitializeExParams.dwTotalSize = sizeof( LineInitializeExParams );
	LineInitializeExParams.dwOptions = LINEINITIALIZEEXOPTION_USECOMPLETIONPORT;
	LineInitializeExParams.dwCompletionKey = IO_COMPLETION_KEY_TAPI_MESSAGE;
	DNASSERT( GetIOCompletionPort() != NULL );
	LineInitializeExParams.Handles.hCompletionPort = GetIOCompletionPort();

	lReturn = LINEERR_UNINITIALIZED;

	if ( p_lineInitializeEx != NULL )
	{
		lReturn = p_lineInitializeEx( &m_TAPIInfo.hApplicationInstance,		// pointer to application TAPI instance handle
									  DNGetApplicationInstance(),			// instance handle of .DLL
									  NULL,									// callback function (not used)
									  NULL,									// friendly application name (none)
									  &m_TAPIInfo.dwLinesAvailable,			// pointer to number of devices available to TAPI
									  &m_TAPIInfo.dwVersion,				// pointer to input/output TAPI version
									  &LineInitializeExParams );			// pointer to extra params
	}

	if ( lReturn == LINEERR_NONE )
	{
		m_fTAPIAvailable = TRUE;
	}
	else
	{
		DPFX(DPFPREP,  0, "Failed to initialize TAPI for NT!" );
	}


	//
	// Prepare to spin up IOCompletionPort threads
	//
	DNASSERT( ThreadCount() == 0 );
	DNASSERT( NTCompletionThreadCount() == 0 );

	DPFX(DPFPREP, 9, "SetIntendedThreadCount %i", g_iThreadCount);
	SetIntendedThreadCount( g_iThreadCount );

Exit:
	return	hr;

Failure:
	DPFX(DPFPREP,  0, "Failed WinNT initialization!" );
	DisplayDNError( 0, hr );

	goto Exit;
}
//**********************************************************************
#endif // WINNT

#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::Win9xInit - initialize Win9x components
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::Win9xInit"

HRESULT	CThreadPool::Win9xInit( void )
{
	HRESULT		hr;
	HANDLE		hPrimaryThread;
	DWORD		dwPrimaryThreadID;
	WIN9X_THREAD_DATA	*pPrimaryThreadInput;
	LINEINITIALIZEEXPARAMS	LineInitializeExParams;
	LONG		lReturn;


	//
	// initialize
	//
	hr = DPN_OK;
	hPrimaryThread = NULL;
	pPrimaryThreadInput = NULL;

	//
	// Initialize TAPI.  If this succeeds, it will give us an event to use for
	// TAPI messages.  If not, create a fake event that will take the place of
	// the TAPI event for the Win9x threads.
	//
	DNASSERT( m_fTAPIAvailable == FALSE );
	memset( &m_TAPIInfo, 0x00, sizeof( m_TAPIInfo ) );
	memset( &LineInitializeExParams, 0x00, sizeof( LineInitializeExParams ) );
	m_TAPIInfo.dwVersion = TAPI_CURRENT_VERSION;
	LineInitializeExParams.dwTotalSize = sizeof( LineInitializeExParams );
	LineInitializeExParams.dwOptions = LINEINITIALIZEEXOPTION_USEEVENT;

	lReturn = LINEERR_UNINITIALIZED;
	if ( p_lineInitializeEx != NULL )
	{
		lReturn = p_lineInitializeEx( &m_TAPIInfo.hApplicationInstance,		// pointer to application TAPI instance handle
									  DNGetApplicationInstance(),			// instance handle of .DLL
									  NULL,									// callback function (not used)
									  NULL,									// friendly application name (none)
									  &m_TAPIInfo.dwLinesAvailable,			// pointer to number of devices available to TAPI
									  &m_TAPIInfo.dwVersion,				// pointer to input/output TAPI version
									  &LineInitializeExParams );			// pointer to extra params
	}

	if ( lReturn == LINEERR_NONE )
	{
		m_hTAPIEvent = LineInitializeExParams.Handles.hEvent;
		m_fTAPIAvailable = TRUE;
	}
	else
	{
		DPFX(DPFPREP,  0, "Failed to initialize TAPI for Win9x!" );
		DNASSERT( m_hTAPIEvent == NULL );
		DNASSERT( m_hFakeTAPIEvent == NULL );
		m_hFakeTAPIEvent = CreateEvent( NULL,		// pointer to security (none)
										TRUE,		// manual reset
										FALSE,		// start unsignalled
										NULL );		// pointer to name (none)
		if ( m_hFakeTAPIEvent == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to create fake TAPI event!" );
			DisplayErrorCode( 0, hr );
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		m_hTAPIEvent = m_hFakeTAPIEvent;
		DNASSERT( m_fTAPIAvailable == FALSE );
	}

	//
	// create send complete event
	//
	DNASSERT( m_hSendComplete == NULL );
	m_hSendComplete = CreateEvent( NULL,	// pointer to security (none)
								   TRUE,	// manual reset
								   FALSE,	// start unsignalled
								   NULL		// pointer to name (none)
								   );
	if ( m_hSendComplete == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create event for Send!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// create receive complete event
	//
	DNASSERT( m_hReceiveComplete == NULL );
	m_hReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
									  TRUE,		// manual reset
									  FALSE,	// start unsignalled
									  NULL		// pointer to name (none)
									  );
	if ( m_hReceiveComplete == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create event for Receive!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// create parameters to worker threads
	//
	pPrimaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pPrimaryThreadInput ) ) );
	if ( pPrimaryThreadInput == NULL )
	{
		DPFX(DPFPREP,  0, "Problem allocating memory for primary Win9x thread!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	memset( pPrimaryThreadInput, 0x00, sizeof( *pPrimaryThreadInput ) );
	pPrimaryThreadInput->pThisThreadPool = this;

	//
	// Create one worker thread and boost its priority.  If the primary thread
	// can be created and boosted, create a secondary thread.  Do not create a
	// secondary thread if the primary could not be boosted because the system
	// is probably low on resources.
	//
	IncrementActiveThreadCount();
	hPrimaryThread = CreateThread( NULL,					// pointer to security attributes (none)
								   0,						// stack size (default)
								   PrimaryWin9xThread,		// pointer to thread function
								   pPrimaryThreadInput,		// pointer to input parameter
								   0,						// let it run
								   &dwPrimaryThreadID		// pointer to destination of thread ID
								   );
	if ( hPrimaryThread == NULL )
	{
		DWORD	dwError;


		//
		// Failed to create thread, decrement active thread count and report
		// error.
		//
		DecrementActiveThreadCount();

		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem creating Win9x thread!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;

		goto Failure;
	}
	pPrimaryThreadInput = NULL;


	DPFX(DPFPREP,  8, "Created primary Win9x thread: 0x%x\tTotal Thread Count: %d", dwPrimaryThreadID, ThreadCount() );
	DNASSERT( hPrimaryThread != NULL );

#if ADJUST_THREAD_PRIORITY
	if ( SetThreadPriority( hPrimaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to boost priority of primary Win9x read thread!  Not starting secondary thread" );
		DisplayErrorCode( 0, dwError );
	}
#endif // ADJUST_THREAD_PRIORITY

	//
	// Disallow thread reduction right off the bat.
	// We give them these two threads and that's what they're stuck with.
	//
	m_fAllowThreadCountReduction = FALSE;


Exit:
	if ( pPrimaryThreadInput != NULL )
	{
		DNFree( pPrimaryThreadInput );
		pPrimaryThreadInput = NULL;
	}

	if ( hPrimaryThread != NULL )
	{
		if ( CloseHandle( hPrimaryThread ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing Win9x thread hanle!" );
			DisplayErrorCode( 0, dwError );
		}

		hPrimaryThread = NULL;
	}

	return	hr;

Failure:
	DPFX(DPFPREP,  0, "Failed Win9x Initialization!" );
	DisplayDNError( 0, hr );
	goto Exit;
}
//**********************************************************************
#endif // WIN95

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::StartNTCompletionThread - start a WinNT completion thread
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::StartNTCompletionThread"

void	CThreadPool::StartNTCompletionThread( void )
{
	HANDLE	hThread;
	DWORD	dwThreadID;
	IOCOMPLETION_THREAD_DATA	*pIOCompletionThreadData;


	pIOCompletionThreadData = static_cast<IOCOMPLETION_THREAD_DATA*>( DNMalloc( sizeof( *pIOCompletionThreadData ) ) );
	if ( pIOCompletionThreadData != NULL )
	{
		pIOCompletionThreadData->pThisThreadPool = this;
		hThread = NULL;
		hThread = CreateThread( NULL,						// pointer to security attributes (none)
								0,							// stack size (default)
								WinNTIOCompletionThread,	// thread function
								pIOCompletionThreadData,	// thread parameter
								0,							// start thread immediately
								&dwThreadID					// pointer to thread ID destination
								);
		if ( hThread != NULL )
		{
			//
			// note that a thread was created, and close the handle
			// to the thread because it's no longer needed.
			//
			IncrementActiveNTCompletionThreadCount();

			DPFX(DPFPREP,  8, "Creating I/O completion thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, ThreadCount(), NTCompletionThreadCount() );
			if ( CloseHandle( hThread ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Problem creating thread for I/O completion port" );
				DisplayErrorCode( 0, dwError );
			}
		}
		else
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to create I/O completion thread!" );
			DisplayErrorCode( 0, dwError );

			DNFree( pIOCompletionThreadData );
		}
	}
}
//**********************************************************************
#endif

//**********************************************************************
// ------------------------------
// CThreadPool::StopAllThreads - stop all work threads
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::StopAllThreads"

void	CThreadPool::StopAllThreads( void )
{
	//
	// stop all non-I/O completion threads
	//
	if ( m_hStopAllThreads != NULL )
	{
		if ( SetEvent( m_hStopAllThreads ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to set event to stop all threads!" );
			DisplayErrorCode( 0, dwError );
		}
	}

	//
	// If we're running on NT submit enough jobs to stop all threads.
	//
#ifdef WINNT
	UINT_PTR	uIndex;


	uIndex = NTCompletionThreadCount();
	while ( uIndex > 0 )
	{
		uIndex--;
		if ( PostQueuedCompletionStatus( m_hIOCompletionPort,		    // handle of completion port
										 0,							    // number of bytes transferred
										 IO_COMPLETION_KEY_SP_CLOSE,    // completion key
										 NULL						    // pointer to overlapped structure (none)
										 ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem submitting Stop job to IO completion port!" );
			DisplayErrorCode( 0, dwError );
		}
	}
#endif
	//
	// check for outstanding threads (no need to lock thread pool count)
	//
	DPFX(DPFPREP,  8, "Number of outstanding threads: %d", ThreadCount() );
	while ( ThreadCount() != 0 )
	{
		DPFX(DPFPREP,  8, "Waiting for %d threads to quit.", ThreadCount() );
		SleepEx( WORK_THREAD_CLOSE_SLEEP_TIME, TRUE );
	}

	DNASSERT( ThreadCount() == 0 );
	m_iTotalThreadCount = 0;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CancelOutstandingIO - cancel outstanding IO
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::CancelOutstandingIO"

void	CThreadPool::CancelOutstandingIO( void )
{
	CBilink	*pTemp;


	DNASSERT( ThreadCount() == 0 );

	//
	// stop any receives with the notification that they were cancelled
	//
	pTemp = m_OutstandingReadList.GetNext();
	while ( pTemp != &m_OutstandingReadList )
	{
		CReadIOData	*pReadData;


		pReadData = CReadIOData::ReadDataFromBilink( pTemp );
		pTemp = pTemp->GetNext();
		pReadData->m_OutstandingReadListLinkage.RemoveFromList();

		DPFX(DPFPREP, 1, "Forcing read data 0x%p to be cancelled.", pReadData);

#ifdef WIN95
		DNASSERT( pReadData->Win9xOperationPending() != FALSE );
		pReadData->SetWin9xOperationPending( FALSE );
#endif
		pReadData->DataPort()->ProcessReceivedData( 0, ERROR_OPERATION_ABORTED );
	}

	//
	// stop any pending writes with the notification that the user cancelled it.
	//
	pTemp = m_OutstandingWriteList.GetNext();
	while ( pTemp != &m_OutstandingWriteList )
	{
		CWriteIOData	*pWriteData;
		CDataPort		*pDataPort;


		pWriteData = CWriteIOData::WriteDataFromBilink( pTemp );
		pTemp = pTemp->GetNext();
		pWriteData->m_OutstandingWriteListLinkage.RemoveFromList();

		DPFX(DPFPREP, 1, "Forcing write data 0x%p to be cancelled.", pWriteData);

#ifdef WIN95
		DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
		pWriteData->SetWin9xOperationPending( FALSE );
#endif
		pWriteData->DataPort()->SendComplete( pWriteData, DPNERR_USERCANCEL );
	}

	while ( m_JobQueue.IsEmpty() == FALSE )
	{
		THREAD_POOL_JOB	*pJob;


		pJob = m_JobQueue.DequeueJob();
		DNASSERT( pJob != NULL );
		DNASSERT( pJob->pCancelFunction != NULL );
		pJob->pCancelFunction( pJob );
		pJob->JobType = JOB_UNINITIALIZED;

		m_JobPool.Release( &m_JobPool, pJob );
	};
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ReturnSelfToPool - return this object to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ReturnSelfToPool"

void	CThreadPool::ReturnSelfToPool( void )
{
	DNASSERT( m_pOwningPool != NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CThreadPool::ProcessTimerJobs - process timed jobs
//
// Entry:		Pointer to job list
//				Pointer to destination for time of next job
//
// Exit:		Boolean indicating active jobs exist
//				TRUE = there are active jobs
//				FALSE = there are no active jobs
//
// Notes:	The input job queue is expected to be locked for the duration
//			of this function call!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ProcessTimerJobs"

BOOL	CThreadPool::ProcessTimerJobs( const CBilink *const pJobList, DN_TIME *const pNextJobTime )
{
	BOOL		fReturn;
	CBilink		*pWorkingEntry;
	INT_PTR		iActiveTimerJobCount;
	DN_TIME		CurrentTime;


	DNASSERT( pJobList != NULL );
	DNASSERT( pNextJobTime != NULL );

	//
	// Initialize.  Set the next job time to be infinitely far in the future
	// so this thread will wake up for any jobs that need to completed before
	// then.
	//
	fReturn = FALSE;
	DBG_CASSERT( OFFSETOF( TIMER_OPERATION_ENTRY, Linkage ) == 0 );
	pWorkingEntry = pJobList->GetNext();
	iActiveTimerJobCount = 0;
	memset( pNextJobTime, 0xFF, sizeof( *pNextJobTime ) );
	DNTimeGet( &CurrentTime );

	//
	// loop through all timer items
	//
	while ( pWorkingEntry != pJobList )
	{
		TIMER_OPERATION_ENTRY	*pTimerEntry;
		BOOL	fJobActive;


		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pWorkingEntry );
		pWorkingEntry = pWorkingEntry->GetNext();

		fJobActive = ProcessTimedOperation( pTimerEntry, &CurrentTime, pNextJobTime );
		DNASSERT( ( fJobActive == FALSE ) || ( fJobActive == TRUE ) );

		fReturn |= fJobActive;

		if ( fJobActive == FALSE )
		{
			RemoveTimerOperationEntry( pTimerEntry, DPN_OK );
		}
	}

	DNASSERT( ( fReturn == FALSE ) || ( fReturn == TRUE ) );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ProcessTimedOperation - process a timed operation
//
// Entry:		Pointer to job information
//				Pointer to current time
//				Pointer to time to be updated
//
// Exit:		Boolean indicating that the job is still active
//				TRUE = operation active
//				FALSE = operation not active
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ProcessTimedOperation"

BOOL	CThreadPool::ProcessTimedOperation( TIMER_OPERATION_ENTRY *const pTimedJob,
											const DN_TIME *const pCurrentTime,
											DN_TIME *const pNextJobTime )
{
	BOOL	fEnumActive;


	DNASSERT( pTimedJob != NULL );
	DNASSERT( pCurrentTime != NULL );
	DNASSERT( pNextJobTime != NULL );


	DPFX(DPFPREP, 9, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p)",
		this, pTimedJob, pCurrentTime, pNextJobTime);

	//
	// Assume that this enum will remain active.  If we retire this enum, this
	// value will be reset.
	//
	fEnumActive = TRUE;

	//
	// If this enum has completed sending enums and is waiting only
	// for responses, decrement the wait time (assuming it's not infinite)
	// and remove the enum if the we've exceed its wait time.
	//
	if ( pTimedJob->uRetryCount == 0 )
	{
		if ( DNTimeCompare( &pTimedJob->IdleTimeout, pCurrentTime ) <= 0 )
		{
			fEnumActive = FALSE;
		}
		else
		{
			//
			// This enum isn't complete, check to see if it's the next enum
			// to need service.
			//
			if ( DNTimeCompare( &pTimedJob->IdleTimeout, pNextJobTime ) < 0 )
			{
				DBG_CASSERT( sizeof( *pNextJobTime ) == sizeof( pTimedJob->IdleTimeout ) );
				memcpy( pNextJobTime, &pTimedJob->IdleTimeout, sizeof( *pNextJobTime ) );
			}
		}
	}
	else
	{
		//
		// This enum is still sending.  Determine if it's time to send a new enum
		// and adjust the wakeup time if appropriate.
		//
		if ( DNTimeCompare( &pTimedJob->NextRetryTime, pCurrentTime ) <= 0 )
		{
			HRESULT	hTempResult;


			//
			// Timeout, execute this timed item
			//
			pTimedJob->pTimerCallback( pTimedJob->pContext );

			//
			// If this job isn't running forever, decrement the retry count.
			// If there are no more retries, set up wait time.  If the job
			// is waiting forever, set max wait timeout.
			//
			if ( pTimedJob->fRetryForever == FALSE )
			{
				pTimedJob->uRetryCount--;
				if ( pTimedJob->uRetryCount == 0 )
				{
					if ( pTimedJob->fIdleWaitForever == FALSE )
					{
						//
						// Compute stopping time for this job's 'Timeout' phase and
						// see if this will be the next job to need service.  ASSERT
						// if the math wraps.
						//
						DNTimeAdd( &pTimedJob->IdleTimeout, pCurrentTime, &pTimedJob->IdleTimeout );
						DNASSERT( pTimedJob->IdleTimeout.Time32.TimeHigh >= pCurrentTime->Time32.TimeHigh );
						if ( DNTimeCompare( &pTimedJob->IdleTimeout, pNextJobTime ) < 0 )
						{
							DBG_CASSERT( sizeof( *pNextJobTime ) == sizeof( pTimedJob->IdleTimeout ) );
							memcpy( pNextJobTime, &pTimedJob->IdleTimeout, sizeof( *pNextJobTime ) );
						}
					}
					else
					{
						//
						// We're waiting forever for enum returns.  ASSERT that we
						// have the maximum timeout and don't bother checking to see
						// if this will be the next enum to need service (it'll never
						// need service).  The following code needs to be revisited for
						// 64-bits.
						//
						DNASSERT( pTimedJob->IdleTimeout.Time32.TimeLow == -1 );
						DNASSERT( pTimedJob->IdleTimeout.Time32.TimeHigh == -1 );
					}

					goto SkipNextRetryTimeComputation;
				}
			}

			DNTimeAdd( pCurrentTime, &pTimedJob->RetryInterval, &pTimedJob->NextRetryTime );
		}

		//
		// is this the next enum to fire?
		//
		if ( DNTimeCompare( &pTimedJob->NextRetryTime, pNextJobTime ) < 0 )
		{
			DBG_CASSERT( sizeof( *pNextJobTime ) == sizeof( pTimedJob->NextRetryTime ) );
			memcpy( pNextJobTime, &pTimedJob->NextRetryTime, sizeof( *pNextJobTime ) );
		}

SkipNextRetryTimeComputation:
		//
		// the following blank line is there to shut up the compiler
		//
		;
	}


	DPFX(DPFPREP, 9, "(0x%p) Returning [%i]",
		this, fEnumActive);

	return	fEnumActive;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitWorkItem - submit a work item for processing and inform
//		work thread that another job is available
//
// Entry:		Pointer to job information
//
// Exit:		Error code
//
// Note:	This function assumes that the job data is locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::SubmitWorkItem"

HRESULT	CThreadPool::SubmitWorkItem( THREAD_POOL_JOB *const pJobInfo )
{
	HRESULT	hr;


	DNASSERT( pJobInfo != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_JobDataLock, TRUE );
	DNASSERT( pJobInfo->pCancelFunction != NULL );


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// add job to queue and tell someone that there's a job available
	//
	m_JobQueue.Lock();
	m_JobQueue.EnqueueJob( pJobInfo );
	m_JobQueue.Unlock();

#ifdef WINNT
	//
	// WinNT, submit new I/O completion item
	//
	DNASSERT( m_hIOCompletionPort != NULL );
	if ( PostQueuedCompletionStatus( m_hIOCompletionPort,			// completion port
									 0,								// number of bytes written (unused)
									 IO_COMPLETION_KEY_NEW_JOB,		// completion key
									 NULL							// pointer to overlapped structure (unused)
									 ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem posting completion item for new job!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}
#else // WIN95
	//
	// Win9x, set event that the work thread will listen for
	//
	DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
	if ( m_JobQueue.SignalPendingJob() == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to signal pending job!" );
		goto Failure;
	}
#endif

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with SubmitWorkItem!" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::GetWorkItem - get a work item from the job queue
//
// Entry:		Nothing
//
// Exit:		Pointer to job information (may be NULL)
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::GetWorkItem"

THREAD_POOL_JOB	*CThreadPool::GetWorkItem( void )
{
	THREAD_POOL_JOB	*pReturn;


	//
	// initialize
	//
	pReturn = NULL;

	m_JobQueue.Lock();
	pReturn = m_JobQueue.DequeueJob();

	//
	// if we're under Win9x (we have a 'pending job' handle),
	// see if the handle needs to be reset
	//
	if ( m_JobQueue.IsEmpty() != FALSE )
	{
		DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
		if ( ResetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem resetting event for pending Win9x jobs!" );
			DisplayErrorCode( 0, dwError );
		}
	}

	m_JobQueue.Unlock();

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitTimerJob - add a timer job to the timer list
//
// Entry:		Retry count
//				Boolean indicating that we retry forever
//				Retry interval
//				Boolean indicating that we wait forever
//				Idle wait interval
//				Pointer to callback when event fires
//				Pointer to callback when event complete
//				User context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::SubmitTimerJob"

HRESULT	CThreadPool::SubmitTimerJob( const UINT_PTR uRetryCount,
									 const BOOL fRetryForever,
									 const DN_TIME RetryInterval,
									 const BOOL fIdleWaitForever,
									 const DN_TIME IdleTimeout,
									 TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
									 TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
									 void *const pContext )
{
	HRESULT					hr;
	TIMER_OPERATION_ENTRY	*pEntry;
	THREAD_POOL_JOB			*pJob;
	BOOL					fTimerJobListLocked;


	DNASSERT( uRetryCount != 0 );
	DNASSERT( pTimerCallbackFunction != NULL );
	DNASSERT( pTimerCompleteFunction != NULL );
	DNASSERT( pContext != NULL );				// must be non-NULL because it's the lookup key to remove job

	//
	// initialize
	//
	hr = DPN_OK;
	pEntry = NULL;
	pJob = NULL;
	fTimerJobListLocked = FALSE;

	LockJobData();

	//
	// If we're on NT, attempt to start the enum thread here so we can return
	// an error if it fails to start.  If it does start, it'll sit until it's
	// informed that an enum job has been added.
	//
#ifdef WINNT
	hr = StartNTTimerThread();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Cannot spin up NT timer thread!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
#endif
	//
	// allocate new enum entry
	//
	pEntry = static_cast<TIMER_OPERATION_ENTRY*>( m_TimerEntryPool.Get( &m_TimerEntryPool ) );
	if ( pEntry == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot allocate memory to add to timer list!" );
		goto Failure;
	}
	DNASSERT( pEntry->pContext == NULL );

	//
	// build timer entry block
	//
	pEntry->pContext = pContext;
	pEntry->uRetryCount = uRetryCount;
	pEntry->fRetryForever = fRetryForever;
	pEntry->RetryInterval = RetryInterval;
	pEntry->IdleTimeout = IdleTimeout;
	pEntry->fIdleWaitForever = fIdleWaitForever;
	pEntry->pTimerCallback = pTimerCallbackFunction;
	pEntry->pTimerComplete = pTimerCompleteFunction;

	//
	// set this enum to fire as soon as it gets a chance
	//
	memset( &pEntry->NextRetryTime, 0x00, sizeof( pEntry->NextRetryTime ) );

	pJob = static_cast<THREAD_POOL_JOB*>( m_JobPool.Get( &m_JobPool ) );
	if ( pJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot allocate memory for enum job!" );
		goto Failure;
	}

	//
	// Create job for work thread.
	//
	pJob->pCancelFunction = CancelRefreshTimerJobs;
	pJob->JobType = JOB_REFRESH_TIMER_JOBS;

	// set our dummy paramter to simulate passing data
	DEBUG_ONLY( pJob->JobData.JobRefreshTimedJobs.uDummy = 0 );

	LockTimerData();
	fTimerJobListLocked = TRUE;

	//
	// we can submit the 'ENUM_REFRESH' job before inserting the enum entry
	// into the active enum list because nobody will be able to pull the
	// 'ENUM_REFRESH' job from the queue since we have the queue locked
	//
	hr = SubmitWorkItem( pJob );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem submitting enum work item" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// debug block to check for duplicate contexts
	//
	DEBUG_ONLY(
				{
					CBilink	*pTempLink;


					pTempLink = m_TimerJobList.GetNext();
					while ( pTempLink != &m_TimerJobList )
					{
						TIMER_OPERATION_ENTRY	*pTempTimerEntry;


						pTempTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempLink );
						DNASSERT( pTempTimerEntry->pContext != pContext );
						pTempLink = pTempLink->GetNext();
					}
				}
			);

	//
	// link to rest of list
	//
	pEntry->Linkage.InsertAfter( &m_TimerJobList );

Exit:
	if ( fTimerJobListLocked != FALSE )
	{
		UnlockTimerData();
		fTimerJobListLocked = FALSE;
	}

	UnlockJobData();

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with SubmitEnumJob" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	if ( pEntry != NULL )
	{
		m_TimerEntryPool.Release( &m_TimerEntryPool, pEntry );
		DEBUG_ONLY( pEntry = NULL );
	}

	if ( pJob != NULL )
	{
		m_JobPool.Release( &m_JobPool, pJob );
		DEBUG_ONLY( pJob = NULL );
	}

	//
	// It's possible that the enum thread has been started for this enum.
	// Since there's no way to stop it without completing the enums or
	// closing the SP, leave it running.
	//

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CancelRefreshTimerJobs - cancel job to refresh enums
//
// Entry:		Job data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::CancelRefreshTimerJobs"

void	CThreadPool::CancelRefreshTimerJobs( THREAD_POOL_JOB *const pJob )
{
	DNASSERT( pJob != NULL );

	//
	// this function doesn't need to do anything
	//
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::StopTimerJob - remove timer job from list
//
// Entry:		Pointer to job context (these MUST be uniquie for jobs)
//				Command result
//
// Exit:		Boolean indicating whether a job was stopped or not
//
// Note:	This function is for the forced removal of a job from the timed job
//			list.  It is assumed that the caller of this function will clean
//			up any messes.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::StopTimerJob"

BOOL	CThreadPool::StopTimerJob( void *const pContext, const HRESULT hCommandResult )
{
	BOOL						fComplete = FALSE;
	CBilink *					pTempEntry;
	TIMER_OPERATION_ENTRY *		pTimerEntry;


	DNASSERT( pContext != NULL );

	DPFX(DPFPREP, 9, "Parameters (0x%p, 0x%lx)", pContext, hCommandResult);
	
	//
	// initialize
	//
	LockTimerData();

	pTempEntry = m_TimerJobList.GetNext();
	while ( pTempEntry != &m_TimerJobList )
	{
		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempEntry );
		if ( pTimerEntry->pContext == pContext )
		{
			//
			// remove this link from the list
			//
			pTimerEntry->Linkage.RemoveFromList();

			fComplete = TRUE;

			//
			// terminate loop
			//
			break;
		}

		pTempEntry = pTempEntry->GetNext();
	}

	UnlockTimerData();

	//
 	// tell owner that the job is complete and return the job to the pool
 	// outside of the lock
 	//
	if (fComplete)
	{
		pTimerEntry->pTimerComplete( hCommandResult, pTimerEntry->pContext );
		m_TimerEntryPool.Release( &m_TimerEntryPool, pTimerEntry );
	}


	DPFX(DPFPREP, 9, "Returning [%i]", fComplete);

	return fComplete;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SpawnDialogThread - start a secondary thread to display service
//		provider UI.
//
// Entry:		Pointer to dialog function
//				Dialog context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::SpawnDialogThread"

HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, void *const pDialogContext )
{
	HRESULT	hr;
	HANDLE	hDialogThread;
	DIALOG_THREAD_PARAM		*pThreadParam;
	DWORD	dwThreadID;


	DNASSERT( pDialogFunction != NULL );
	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??


	//
	// initialize
	//
	hr = DPN_OK;
	pThreadParam = NULL;

	//
	// create and initialize thread param
	//
	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
	if ( pThreadParam == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to allocate memory for dialog thread!" );
		goto Failure;
	}

	pThreadParam->pDialogFunction = pDialogFunction;
	pThreadParam->pContext = pDialogContext;
	pThreadParam->pThisThreadPool = this;

	//
	// assume that a thread will be created
	//
	IncrementActiveThreadCount();

	//
	// create thread
	//
	hDialogThread = CreateThread( NULL,					// pointer to security (none)
								  0,					// stack size (default)
								  DialogThreadProc,		// thread procedure
								  pThreadParam,			// thread param
								  0,					// creation flags (none)
								  &dwThreadID );		// pointer to thread ID
	if ( hDialogThread == NULL )
	{
		DWORD	dwError;


		//
		// decrement active thread count and report error
		//
		DecrementActiveThreadCount();

		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to start dialog thread!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

	if ( CloseHandle( hDialogThread ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem closing handle from create dialog thread!" );
		DisplayErrorCode( 0, dwError );
	}

Exit:	
	return	hr;

Failure:
	if ( pThreadParam != NULL )
	{
		DNFree( pThreadParam );
		pThreadParam = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::GetIOThreadCount - get I/O thread count
//
// Entry:		Pointer to variable to fill
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::GetIOThreadCount"

HRESULT	CThreadPool::GetIOThreadCount( LONG *const piThreadCount )
{
	HRESULT	hr;


	DNASSERT( piThreadCount != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();

	if ( IsThreadCountReductionAllowed() )
	{
		*piThreadCount = GetIntendedThreadCount();
	}
	else
	{
#ifdef WIN95
		*piThreadCount = ThreadCount();
#else // WINNT
		DNASSERT( NTCompletionThreadCount() != 0 );
		*piThreadCount = NTCompletionThreadCount();
#endif
	}

	
	Unlock();

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SetIOThreadCount - set I/O thread count
//
// Entry:		New thread count
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SetIOThreadCount"

HRESULT	CThreadPool::SetIOThreadCount( const LONG iThreadCount )
{
	HRESULT	hr;


	DNASSERT( iThreadCount > 0 );

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();

	if ( IsThreadCountReductionAllowed() )
	{
		DPFX(DPFPREP, 4, "Thread pool not locked down, setting intended thread count to %i.", iThreadCount );
		SetIntendedThreadCount( iThreadCount );
	}
	else
	{
#ifdef WIN95
		//
		// Win9x can not adjust thread count.
		//
		DPFX(DPFPREP, 4, "Thread pool locked down and already has %i 9x threads, not adjusting to %i.",
			ThreadCount(), iThreadCount );
#else // WINNT
		//
		// WinNT can have many threads.  If the user wants more threads, attempt
		// to boost the thread pool to the requested amount (if we fail to
		// start a new thread, too bad).  If the user wants fewer threads, check
		// to see if the thread pool has been locked out of changes.  If not,
		// start killing off the threads.
		//
		if ( iThreadCount > NTCompletionThreadCount() )
		{
			INT_PTR	iDeltaThreads;


			iDeltaThreads = iThreadCount - NTCompletionThreadCount();

			DPFX(DPFPREP, 4, "Thread pool locked down, spawning %i new NT threads (for a total of %i).",
				iDeltaThreads, iThreadCount );
			
			while ( iDeltaThreads > 0 )
			{
				iDeltaThreads--;
				StartNTCompletionThread();
			}
		}
		else
		{
			DPFX(DPFPREP, 4, "Thread pool locked down and already has %i NT threads, not adjusting to %i.",
				NTCompletionThreadCount(), iThreadCount );
		}
#endif
	}

	Unlock();

	return	hr;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CThreadPool::PreventThreadPoolReduction - prevents the thread pool size from being reduced
//
// Entry:		None
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::PreventThreadPoolReduction"

HRESULT CThreadPool::PreventThreadPoolReduction( void )
{
	HRESULT				hr = DPN_OK;
	LONG				iDesiredThreads;
#ifdef DEBUG
	DWORD				dwStartTime;
#endif // DEBUG


	Lock();

	//
	// If we haven't already clamped down, do so, and spin up the threads.
	//
	if ( IsThreadCountReductionAllowed() )
	{
		m_fAllowThreadCountReduction = FALSE;

		DNASSERT( GetIntendedThreadCount() > 0 );
		DNASSERT( ThreadCount() == 0 );

		iDesiredThreads = GetIntendedThreadCount();
		SetIntendedThreadCount( 0 );
		

		DPFX(DPFPREP, 3, "Locking down thread count at %i.", iDesiredThreads );

#ifdef DEBUG
		dwStartTime = GETTIMESTAMP();
#endif // DEBUG
		

		//
		// OS-specific thread starting.
		//
#ifdef WINNT
		//
		// WinNT
		//
		DNASSERT( NTCompletionThreadCount() == 0 );
		
		while ( iDesiredThreads > 0 )
		{
			iDesiredThreads--;
			StartNTCompletionThread();
		}

		//
		// If at least one thread was created, the SP will perform in a
		// non-optimal fashion, but we will still function.  If no threads
		// were created, fail.
		//
		if ( ThreadCount() == 0 )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP, 0, "Unable to create any threads to service NT I/O completion port!" );
			goto Failure;
		}
#else // WIN95
		//
		// Windows 9x
		//
		//
		// We should never get here because there will always only
		// be 1 thread.
		//
		DNASSERT( FALSE );
#endif
		
#ifdef DEBUG
		DPFX(DPFPREP, 8, "Spent %u ms starting %i threads.", (GETTIMESTAMP() - dwStartTime), ThreadCount());
#endif // DEBUG
	}
	else
	{
		DPFX(DPFPREP, 3, "Thread count already locked down (at %i).", ThreadCount() );
	}

#ifdef WINNT
Exit:
#endif
	
	Unlock();

	return	hr;

#ifdef WINNT
Failure:

	goto Exit;
#endif
}
//**********************************************************************





//**********************************************************************
// ------------------------------
// CThreadPool::CreateDataPortHandle - create a new handle and assign a CDataPort
//		to it
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
HRESULT	CThreadPool::CreateDataPortHandle( CDataPort *const pDataPort )
{
	HRESULT	hr;
	HANDLE	hDataPort;


	DNASSERT( pDataPort != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	hDataPort = INVALID_HANDLE_VALUE;

	m_DataPortHandleTable.Lock();
	hr = m_DataPortHandleTable.CreateHandle( &hDataPort, pDataPort );
	m_DataPortHandleTable.Unlock();

	if ( hr != DPN_OK )
	{
		DNASSERT( hDataPort == INVALID_HANDLE_VALUE );
		DPFX(DPFPREP,  0, "Failed to create handle!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	pDataPort->SetHandle( hDataPort );
	pDataPort->AddRef();

Exit:
	return	hr;

Failure:
	DNASSERT( hDataPort == INVALID_HANDLE_VALUE );
	DNASSERT( pDataPort->GetHandle() == INVALID_HANDLE_VALUE );
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CloseDataPortHandle - invalidate a handle for a CDataPort
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void	CThreadPool::CloseDataPortHandle( CDataPort *const pDataPort )
{
	BOOL	fCloseReturn;
	HANDLE	hDataPort;


	DNASSERT( pDataPort != NULL );

	hDataPort = pDataPort->GetHandle();

	m_DataPortHandleTable.Lock();
	fCloseReturn = m_DataPortHandleTable.InvalidateHandle( hDataPort );
	m_DataPortHandleTable.Unlock();

	if ( fCloseReturn != FALSE )
	{
		pDataPort->SetHandle( INVALID_HANDLE_VALUE );
		pDataPort->DecRef();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::DataPortFromHandle - convert a handle to a CDataPort
//
// Entry:		Handle
//
// Exit:		Pointer to CDataPort (may be NULL for invalid handle)
// ------------------------------
CDataPort	*CThreadPool::DataPortFromHandle( const HANDLE hDataPort )
{
	CDataPort	*pDataPort;


	DNASSERT( hDataPort != INVALID_HANDLE_VALUE );

	pDataPort = NULL;

	m_DataPortHandleTable.Lock();

	pDataPort = static_cast<CDataPort*>( m_DataPortHandleTable.GetAssociatedData( hDataPort ) );
	if ( pDataPort != NULL )
	{
		pDataPort->AddRef();
	}

	m_DataPortHandleTable.Unlock();

	return	pDataPort;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::PoolAllocFunction - called when new pool item is allocated
//
// Entry:		Nothing
//
// Exit:		Boolean inidcating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::PoolAllocFunction"

BOOL	CThreadPool::PoolAllocFunction( void )
{
	BOOL	fReturn;


	fReturn = TRUE;

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::PoolInitFunction - called when new pool item is removed from pool
//
// Entry:		Nothing
//
// Exit:		Boolean inidcating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::PoolInitFunction"

BOOL	CThreadPool::PoolInitFunction( void )
{
	BOOL	fReturn;


	fReturn = Initialize();

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::PoolDeinitFunction - called when new pool item is returned to  pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::PoolDeinitFunction"

void	CThreadPool::PoolDeinitFunction( void )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::PoolDeallocFunction - called when new pool item is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::PoolDeallocFunction"

void	CThreadPool::PoolDeallocFunction( void )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitDelayedCommand - submit request to enum query to remote session
//
// Entry:		Pointer to callback function
//				Pointer to cancel function
//				Pointer to callback context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::SubmitDelayedCommand"

HRESULT	CThreadPool::SubmitDelayedCommand( JOB_FUNCTION *const pFunction, JOB_FUNCTION *const pCancelFunction, void *const pContext )
{
	HRESULT			hr;
	THREAD_POOL_JOB	*pJob;
	BOOL			fJobDataLocked;


	DNASSERT( pFunction != NULL );
	DNASSERT( pCancelFunction != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pJob = NULL;
	fJobDataLocked = FALSE;

	pJob = static_cast<THREAD_POOL_JOB*>( m_JobPool.Get( &m_JobPool ) );
	if ( pJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot allocate job for DelayedCommand!" );
		goto Failure;
	}

	pJob->JobType = JOB_DELAYED_COMMAND;
	pJob->pCancelFunction = pCancelFunction;
	pJob->JobData.JobDelayedCommand.pCommandFunction = pFunction;
	pJob->JobData.JobDelayedCommand.pContext = pContext;

	LockJobData();
	fJobDataLocked = TRUE;

	hr = SubmitWorkItem( pJob );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem submitting DelayedCommand job!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( fJobDataLocked != FALSE )
	{
		UnlockJobData();
		fJobDataLocked = FALSE;
	}

	return	hr;

Failure:
	if ( pJob != NULL )
	{
		m_JobPool.Release( &m_JobPool, pJob );
	}

	goto Exit;
}
//**********************************************************************

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::StartNTTimerThread - start the timer thread for NT
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	This function assumes that the enum data is locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::StartNTTimerThread"

HRESULT	CThreadPool::StartNTTimerThread( void )
{
	HRESULT	hr;
	HANDLE	hThread;
	DWORD	dwThreadID;


	//
	// initialize
	//
	hr = DPN_OK;
	DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );

	if ( m_fNTTimerThreadRunning != FALSE )
	{
		//
		// the enum thread is already running, poke it to note new enums
		//
		if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
		{
			DWORD	dwError;


			hr = DPNERR_OUTOFMEMORY;
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem setting event to wake NTTimerThread!" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		goto Exit;
	}

//	DNASSERT( m_hWakeNTEnumThread != NULL );
//	m_NTEnumThreadData.hEventList[ EVENT_INDEX_ENUM_WAKEUP ] = m_hWakeNTEnumThread;

	IncrementActiveThreadCount();
	hThread = CreateThread( NULL,				// pointer to security attributes (none)
							0,					// stack size (default)
							WinNTTimerThread,	// thread function
							this,				// thread parameter
							0,					// creation flags (none, start running now)
							&dwThreadID			// pointer to thread ID
							);
	if ( hThread == NULL )
	{
		DWORD	dwError;


		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create NT timer thread!" );
		DisplayErrorCode( 0, dwError );
		DecrementActiveThreadCount();

		goto Failure;
	}

	//
	// note that the thread is running and close the handle to the thread
	//
	m_fNTTimerThreadRunning = TRUE;
	DPFX(DPFPREP,  8, "Creating NT-Timer thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, ThreadCount(), NTCompletionThreadCount() );

	if ( CloseHandle( hThread ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem closing handle after starting NTTimerThread!" );
		DisplayErrorCode( 0, dwError );
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::WakeNTTimerThread - wake the timer thread because a timed event
//		has been added
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::WakeNTTimerThread"

void	CThreadPool::WakeNTTimerThread( void )
{
	LockJobData();
	DNASSERT( m_JobQueue.GetPendingJobHandle() != FALSE );
	if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem setting event to wake up NT timer thread!" );
		DisplayErrorCode( 0, dwError );
	}
	UnlockJobData();
}
//**********************************************************************
#endif // WINNT

//**********************************************************************
// ------------------------------
// CThreadPool::RemoveTimerOperationEntry - remove timer operation job	from list
//
// Entry:		Pointer to timer operation
//				Result code to return
//
// Exit:		Nothing
//
// Note:	This function assumes that the list is appropriately locked
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::RemoveTimerOperationEntry"

void	CThreadPool::RemoveTimerOperationEntry( TIMER_OPERATION_ENTRY *const pTimerEntry, const HRESULT hJobResult )
{
	DNASSERT( pTimerEntry != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_TimerDataLock, TRUE );

	//
	// remove this link from the list, tell owner that the job is complete and
	// return the job to the pool
	//
	pTimerEntry->Linkage.RemoveFromList();
	pTimerEntry->pTimerComplete( hJobResult, pTimerEntry->pContext );
	m_TimerEntryPool.Release( &m_TimerEntryPool, pTimerEntry );
}
//**********************************************************************


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::CompleteOutstandingSends - check for completed sends and
//		indicate send completion for them.
//
// Entry:		Send complete event
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::CompleteOutstandingSends"

void	CThreadPool::CompleteOutstandingSends( const HANDLE hSendCompleteEvent )
{
	CBilink		*pCurrentOutstandingWrite;
	CBilink		WritesToBeProcessed;


	DNASSERT( hSendCompleteEvent != NULL );
	WritesToBeProcessed.Initialize();

	//
	// Loop through the list out outstanding sends.  Any completed sends are
	// removed from the list and processed after we release the write data lock.
	//
	LockWriteData();
	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
	{
		CDataPort		*pDataPort;
		CWriteIOData	*pWriteIOData;
		DWORD			dwFlags;
		DWORD			dwBytesSent;


		//
		// note this send and advance pointer to the next pending send
		//
		pWriteIOData = CWriteIOData::WriteDataFromBilink( pCurrentOutstandingWrite );
		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();

		if ( pWriteIOData->Win9xOperationPending() != FALSE )
		{
			if ( GetOverlappedResult( pWriteIOData->DataPort()->GetFileHandle(),		// file handle
									  pWriteIOData->Overlap(),							// pointer to overlap structure
									  &dwBytesSent,										// pointer to bytes sent
									  FALSE												// wait for completion (don't wait)
									  ) != FALSE )
			{
				pWriteIOData->jkm_hSendResult = DPN_OK;
			}
			else
			{
				DWORD	dwError;


				dwError = GetLastError();
				switch( dwError )
				{
					//
					// ERROR_IO_PENDING = operation pending
					//
					case ERROR_IO_PENDING:
					{
						goto SkipSendCompletion;
						break;
					}

					//
					// ERROR_IO_INCOMPLETE = overlapped I/O is not in a signalled state
					// 						 this is expected since the event is always
					//						 cleared before checking I/O.  Assume complete.
					//
					case ERROR_IO_INCOMPLETE:
					{
						pWriteIOData->jkm_hSendResult = DPN_OK;
						break;
					}

					//
					// ERROR_OPERATION_ABORTED = operation complete because of cancel or
					//							 a thread quit.  (Com port was closed)
					//
					case ERROR_OPERATION_ABORTED:
					{
						pWriteIOData->jkm_hSendResult = DPNERR_USERCANCEL;
						break;
					}		

					//
					// ERROR_INVALID_HANDLE = the serial port is gone.  This is
					//						  possible when a modem hangs up.
					//
					case ERROR_INVALID_HANDLE:
					{
						pWriteIOData->jkm_hSendResult = DPNERR_NOCONNECTION;
						break;
					}

					//
					// other error, stop and take a look
					//
					default:
					{
						pWriteIOData->jkm_hSendResult = DPNERR_GENERIC;
						DisplayErrorCode( 0, dwError );

						DNASSERT( FALSE );
						break;
					}
				}
			}

			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
			pWriteIOData->SetWin9xOperationPending( FALSE );

			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( &WritesToBeProcessed );
		}

SkipSendCompletion:
		//
		// the following line is present to prevent the compiler from whining
		// about a blank line
		//
		;
	}

	//
	// If there are no more outstanding reads, reset the write complete event.
	// It will be signalled when the next posted write completes.  No other read
	// can be posted at this time because the write data lock is held.
	//
	if ( m_OutstandingWriteList.IsEmpty() != FALSE )
	{
		if ( ResetEvent( hSendCompleteEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to reset send event!" );
			DisplayErrorCode( 0, dwError );
		}
	}
	UnlockWriteData();

	//
	// process all writes that have been pulled to the side.
	//
	while ( WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
	{
		CWriteIOData	*pTempWrite;
		CDataPort		*pDataPort;


		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
		pDataPort = pTempWrite->DataPort();
		DNASSERT( pDataPort != NULL );

		pDataPort->SendComplete( pTempWrite, pTempWrite->jkm_hSendResult );
//		pDataPort->SendFromWriteQueue();
//		pDataPort->DecRef();
	}
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::CompleteOutstandingReceives - check for completed receives and
//		indicate completion for them.
//
// Entry:		Receive complete event
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::CompleteOutstandingReceives"

void	CThreadPool::CompleteOutstandingReceives( const HANDLE hReceiveCompleteEvent )
{
	CBilink		*pCurrentOutstandingRead;
	CBilink		ReadsToBeProcessed;


	DNASSERT( hReceiveCompleteEvent != NULL );
	ReadsToBeProcessed.Initialize();
	LockReadData();

	//
	// Loop through the list of outstanding reads and pull out the ones that need
	// to be serviced.  We don't want to service them while the read data lock
	// is taken.
	//
	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
	{
		CDataPort		*pDataPort;
		CReadIOData		*pReadIOData;
		DWORD			dwFlags;


		pReadIOData = CReadIOData::ReadDataFromBilink( pCurrentOutstandingRead );
		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();

		//
		// Make sure this operation is really pending before attempting to check
		// for completion.  It's possible that the read was added to the list, but
		// we haven't actually called Winsock yet.
		//
		if ( pReadIOData->Win9xOperationPending() != FALSE )
		{
			if ( GetOverlappedResult( pReadIOData->DataPort()->GetFileHandle(),
									  pReadIOData->Overlap(),
									  &pReadIOData->jkm_dwOverlappedBytesReceived,
									  FALSE
									  ) != FALSE )
			{
				DBG_CASSERT( ERROR_SUCCESS == 0 );
//				pReadIOData->jkm_hReceiveReturn = DPN_OK;
				pReadIOData->m_dwWin9xReceiveErrorReturn = ERROR_SUCCESS;
			}
			else
			{
				DWORD	dwError;


				dwError = GetLastError();
				switch( dwError )
				{
					//
					// ERROR_IO_INCOMPLETE = treat as I/O complete.  Event isn't
					//						 signalled, but that's expected because
					//						 it's cleared before checking for I/O
					//
					case ERROR_IO_INCOMPLETE:
					{
						pReadIOData->jkm_dwOverlappedBytesReceived = pReadIOData->m_dwBytesToRead;
						pReadIOData->m_dwWin9xReceiveErrorReturn = ERROR_SUCCESS;
					    break;
					}

					//
					// ERROR_IO_PENDING = io still pending
					//
					case ERROR_IO_PENDING:
					{
						DNASSERT( FALSE );
						goto SkipReceiveCompletion;
						break;
					}

					//
					// other error, stop if not 'known'
					//
					default:
					{
						switch ( dwError )
						{
							//
							// ERROR_OPERATION_ABORTED = operation was cancelled (COM port closed)
							// ERROR_INVALID_HANDLE = operation was cancelled (COM port closed)
							//
							case ERROR_OPERATION_ABORTED:
							case ERROR_INVALID_HANDLE:
							{
								break;
							}

							default:
							{
								DisplayErrorCode( 0, dwError );
								DNASSERT( FALSE );
								break;
							}
						}

						pReadIOData->m_dwWin9xReceiveErrorReturn = dwError;

						break;
					}
				}
			}

			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
			pReadIOData->SetWin9xOperationPending( FALSE );

			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( &ReadsToBeProcessed );
		}

SkipReceiveCompletion:
		//
		// the following line is present to prevent the compiler from whining
		// about a blank line
		//
		;
	}

	//
	// If there are no more outstanding reads, reset the read complete event.
	// It will be signalled when the next posted read completes.  No other read
	// can be posted at this time because the read data lock is held.
	//
	if ( m_OutstandingReadList.IsEmpty() != FALSE )
	{
		if ( ResetEvent( hReceiveCompleteEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to reset receive event!" );
			DisplayErrorCode( 0, dwError );
		}
	}

	UnlockReadData();

	//
	// loop through the list of reads that have completed and dispatch them
	//
	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
	{
		CReadIOData		*pTempRead;
		CDataPort		*pDataPort;


		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();

		pDataPort = pTempRead->DataPort();
		DNASSERT( pDataPort != NULL );
		pDataPort->ProcessReceivedData( pTempRead->jkm_dwOverlappedBytesReceived, pTempRead->m_dwWin9xReceiveErrorReturn );
	}
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::PrimaryWin9xThread - main thread to do everything that the SP is
//		supposed to do under Win9x.
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is allocated for this thread and must be
//			deallocated by this thread when it exits
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::PrimaryWin9xThread"

DWORD	WINAPI	CThreadPool::PrimaryWin9xThread( void *pParam )
{
	WIN9X_CORE_DATA		CoreData;
	DN_TIME	    		CurrentTime;
	DWORD	    		dwMaxWaitTime;
	DN_TIME	    		DeltaT;
	BOOL				fComInitialized;


	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;


	DNASSERT( pParam != NULL );
	DNASSERT( pThisThreadPool != NULL );

	//
	// initialize
	//
	memset( &CoreData, 0x00, sizeof CoreData );
	fComInitialized = FALSE;

	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DPFX(DPFPREP,  0, "Primary Win9x thread failed to initialize COM!" );
			DNASSERT( FALSE );
			break;
		}
	}

	DNASSERT( CoreData.fTimerJobsActive == FALSE );

	//
	// set enums to happen infinitely in the future
	//
	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );

	//
	// set wait handles
	//
	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
	CoreData.hWaitHandles[ EVENT_INDEX_SEND_COMPLETE ] = pThisThreadPool->GetSendCompleteEvent();
	CoreData.hWaitHandles[ EVENT_INDEX_RECEIVE_COMPLETE ] = pThisThreadPool->GetReceiveCompleteEvent();
	CoreData.hWaitHandles[ EVENT_INDEX_TAPI_MESSAGE ] = pThisThreadPool->GetTAPIMessageEvent();

	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_SEND_COMPLETE ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_RECEIVE_COMPLETE ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_TAPI_MESSAGE ] );

	//
	// go until we're told to stop
	//
	CoreData.fLooping = TRUE;
	while ( CoreData.fLooping != FALSE )
	{
		DWORD   dwWaitReturn;


		//
		// Update the job time so we know how long to wait.  We can
		// only get here if a socket was just added to the socket list, or
		// we've been servicing sockets.
		//
		DNTimeGet( &CurrentTime );
		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
		{
			pThisThreadPool->LockTimerData();
			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
			    														   &CoreData.NextTimerJobTime );
			if ( CoreData.fTimerJobsActive != FALSE )
			{
			    DPFX(DPFPREP,  8, "There are active jobs left with Winsock1 sockets active!" );
			}
			pThisThreadPool->UnlockTimerData();
		}

		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );
		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );

		//
		// Check for I/O
		//
		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
			    								 CoreData.hWaitHandles,					// handles to wait on
			    								 FALSE,									// don't wait for all to be signalled
			    								 dwMaxWaitTime,							// wait timeout
			    								 TRUE									// we're alertable for APCs
			    								 );
		switch ( dwWaitReturn )
		{
			//
			// timeout, don't do anything, we'll probably process timer jobs on
			// the next loop
			//
			case WAIT_TIMEOUT:
			{
			    break;
			}

			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_SEND_COMPLETE ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_RECEIVE_COMPLETE ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_TAPI_MESSAGE ):
			{
				pThisThreadPool->ProcessWin9xEvents( &CoreData );
				break;
			}


			//
			// There are I/O completion routines scheduled on this thread.
			// This is not a good thing!
			//
			case WAIT_IO_COMPLETION:
			{
			    DPFX(DPFPREP,  1, "WARNING: APC was serviced on the primary Win9x IO service thread!  What is the application doing??" );
			    break;
			}

			//
			// wait failed
			//
			case WAIT_FAILED:
			{
			    DWORD	dwError;


			    dwError = GetLastError();
			    DPFX(DPFPREP,  0, "Primary Win9x thread wait failed!" );
			    DisplayDNError( 0, dwError );
			    break;
			}

			//
			// problem
			//
			default:
			{
			    DWORD	dwError;


			    dwError = GetLastError();
			    DPFX(DPFPREP,  0, "Primary Win9x thread unknown problem in wait!" );
			    DisplayDNError( 0, dwError );
			    DNASSERT( FALSE );
			    break;
			}
		}
	}

	pThisThreadPool->DecrementActiveThreadCount();

	DNFree( pParam );

	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
//**********************************************************************
#endif // WIN95


#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::WinNTIOCompletionThread - thread to service I/O completion port
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is allocated for this thread and must be
//			deallocated by this thread when it exits
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::WinNTIOCompletionThread"

DWORD	WINAPI	CThreadPool::WinNTIOCompletionThread( void *pParam )
{
	IOCOMPLETION_THREAD_DATA	*pInput;
	BOOL	fLooping;
	HANDLE	hIOCompletionPort;
	BOOL	fComInitialized;


	DNASSERT( pParam != NULL );

	//
	// initialize
	//
	pInput = static_cast<IOCOMPLETION_THREAD_DATA*>( pParam );
	DNASSERT( pInput->pThisThreadPool != NULL );
	fLooping = TRUE;
	hIOCompletionPort = pInput->pThisThreadPool->m_hIOCompletionPort;
	DNASSERT( hIOCompletionPort != NULL );
	fComInitialized = FALSE;

	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DNASSERT( FALSE );
			DPFX(DPFPREP,  0, "Failed to initialize COM!" );
			break;
		}
	}

	//
	// go until we're told to stop
	//
	while ( fLooping != FALSE )
	{
		BOOL		fStatusReturn;
		DWORD		dwBytesTransferred;
		ULONG_PTR	uCompletionKey;
		OVERLAPPED	*pOverlapped;


		DNASSERT( hIOCompletionPort != NULL );
		fStatusReturn = GetQueuedCompletionStatus( hIOCompletionPort,		// handle of completion port
												   &dwBytesTransferred,		// pointer to number of bytes read
												   &uCompletionKey,			// pointer to completion key
												   &pOverlapped,			// pointer to overlapped structure
												   INFINITE					// wait forever
												   );
		if ( ( fStatusReturn == FALSE ) && ( pOverlapped == FALSE ) )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem getting item from completion port!" );
			DisplayErrorCode( 0, dwError );
		}
		else
		{
			switch ( uCompletionKey )
			{
				//
				// ReadFile or WriteFile completed.  Check error status and
				// complete the appropriate operation.
				//
				case IO_COMPLETION_KEY_IO_COMPLETE:
				{
					CIOData		*pIOData;
					DWORD		dwError;


					DNASSERT( pOverlapped != NULL );
					if ( fStatusReturn != FALSE )
					{
						dwError = ERROR_SUCCESS;
					}
					else
					{
						dwError = GetLastError();
					}

					pIOData = CIOData::IODataFromOverlap( pOverlapped );
					if ( pIOData->NTIOOperationType() == NT_IO_OPERATION_RECEIVE )
					{
						DNASSERT( ( dwError == ERROR_SUCCESS ) || ( dwBytesTransferred == 0 ) );
						pIOData->DataPort()->ProcessReceivedData( dwBytesTransferred, dwError );
					}
					else
					{
						HRESULT		hOperationResult;


						DNASSERT( pIOData->NTIOOperationType() == NT_IO_OPERATION_SEND );
						switch ( dwError )
						{
							//
							// no problem
							//
							case ERROR_SUCCESS:
							{
								hOperationResult = DPN_OK;
								break;
							}

							//
							// ERROR_OPERATION_ABORTED = operation was stopped, most likely
							//		because of a user cancel
							//
							case ERROR_OPERATION_ABORTED:
							{
								hOperationResult = DPNERR_USERCANCEL;
								break;
							}

							default:
							{
								DNASSERT( FALSE );
								DPFX(DPFPREP,  0, "Failed on I/O completion send!" );
								DisplayErrorCode( 0, dwError );
								hOperationResult = DPNERR_GENERIC;
								break;
							}
						}

						pIOData->DataPort()->SendComplete( static_cast<CWriteIOData*>( pIOData ), hOperationResult );
					}

					break;
				}

				//
				// SP is closing, stop all threads
				//
				case IO_COMPLETION_KEY_SP_CLOSE:
				{
					DNASSERT( WaitForSingleObjectEx( pInput->pThisThreadPool->m_hStopAllThreads, 0, TRUE ) == WAIT_OBJECT_0 );
					fLooping = FALSE;
					break;
				}

				//
				// a new job was submitted to the job queue, or the SP is closing from above
				//
				case IO_COMPLETION_KEY_NEW_JOB:
				{
					THREAD_POOL_JOB	*pJobInfo;


					//
					// SP is still running, process our job
					//
					pJobInfo = pInput->pThisThreadPool->GetWorkItem();
					if ( pJobInfo != NULL )
					{
						switch ( pJobInfo->JobType )
						{
							//
							// enum refresh
							//
							case JOB_REFRESH_TIMER_JOBS:
							{
								DPFX(DPFPREP,  8, "IOCompletion job REFRESH_TIMER_JOBS" );
								DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );

								pInput->pThisThreadPool->WakeNTTimerThread();

								break;
							}

							//
							// issue callback for this job
							//
							case JOB_DELAYED_COMMAND:
							{
								DPFX(DPFPREP,  8, "IOCompletion job DELAYED_COMMAND" );
								DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );

								pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
								break;
							}

							//
							// other job
							//
							default:
							{
								DPFX(DPFPREP,  0, "IOCompletion job unknown!" );
								DNASSERT( FALSE );
								break;
							}
						}

						pJobInfo->JobType = JOB_UNINITIALIZED;
						pInput->pThisThreadPool->m_JobPool.Release( &pInput->pThisThreadPool->m_JobPool, pJobInfo );
					}

					break;
				}

				//
				// TAPI message, pointer to line message is in pOverlapped and
				// we are responsible for freeing it via LocalFree()
				//
				case IO_COMPLETION_KEY_TAPI_MESSAGE:
				{
					LINEMESSAGE	*pLineMessage;
					CModemPort	*pModemPort;
					HANDLE		hModemPort;


					DNASSERT( pOverlapped != NULL );
					DBG_CASSERT( sizeof( pLineMessage ) == sizeof( pOverlapped ) );
					pLineMessage = reinterpret_cast<LINEMESSAGE*>( pOverlapped );

					DBG_CASSERT( sizeof( pModemPort ) == sizeof( pLineMessage->dwCallbackInstance ) );
					hModemPort = reinterpret_cast<HANDLE>( pLineMessage->dwCallbackInstance );

					pModemPort = static_cast<CModemPort*>( pInput->pThisThreadPool->DataPortFromHandle( hModemPort ) );
					if ( pModemPort != NULL )
					{
						pModemPort->ProcessTAPIMessage( pLineMessage );

						if ( LocalFree( pOverlapped ) != NULL )
						{
							DWORD	dwError;


							dwError = GetLastError();
							DPFX(DPFPREP,  0, "Problem with LocalFree in NTProcessTAPIMessage" );
							DisplayErrorCode( 0, dwError );
						}

						pModemPort->DecRef();
					}
					else
					{
						DPFX(DPFPREP,  5, "Dropping TAPI message on closed modem port!" );
						DisplayTAPIMessage( 5, pLineMessage );
					}

					break;
				}

				//
				// unknown I/O completion message type
				//
				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}
		}
	}

	pInput->pThisThreadPool->DecrementActiveNTCompletionThreadCount();
	DNFree( pInput );

	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
//**********************************************************************
#endif // WINNT

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::WinNTTimerThread - timer thread for NT
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is a static memory chunk and cannot be freed.
//			Cleanup of this memory is the responsibility of this thread.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::WinNTTimerThread"

DWORD	WINAPI	CThreadPool::WinNTTimerThread( void *pParam )
{
	CThreadPool	*pThisThreadPool;
	BOOL	fLooping;
	DWORD	dwWaitReturn;
	DN_TIME	NextEnumTime;
	HANDLE	hEvents[ 2 ];
	BOOL	fComInitialized;


	DNASSERT( pParam != NULL );

	//
	// initialize
	//
	DNASSERT( pParam != NULL );
	pThisThreadPool = static_cast<CThreadPool*>( pParam );
	DNASSERT( pThisThreadPool->m_JobQueue.GetPendingJobHandle() != NULL );

	memset( &NextEnumTime, 0xFF, sizeof( NextEnumTime ) );

	hEvents[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
	hEvents[ EVENT_INDEX_WAKE_NT_TIMER_THREAD ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();

	fComInitialized = FALSE;


	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			fComInitialized = TRUE;
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DNASSERT( FALSE );
			DPFX(DPFPREP, 0, "Failed to initialize COM!" );
			break;
		}
	}



	//
	// there were no active enums so we want to wait forever for something to
	// happen
	//
	fLooping = TRUE;

	//
	// go until we're told to stop
	//
	while ( fLooping != FALSE )
	{
		DN_TIME		CurrentTime;
		DN_TIME		DeltaT;
		DWORD		dwMaxWaitTime;


		DNTimeGet( &CurrentTime );

		if ( DNTimeCompare( &NextEnumTime, &CurrentTime ) <= 0 )
		{

			//
			// acknowledge that we've handled this event and then process the
			// enums
			//
			pThisThreadPool->LockTimerData();

			if ( ResetEvent( hEvents[ EVENT_INDEX_WAKE_NT_TIMER_THREAD ] ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Problem resetting event to wake NT timer thread!" );
				DisplayErrorCode( 0, dwError );
			}

			pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList, &NextEnumTime );
			pThisThreadPool->UnlockTimerData();
		}

		DNTimeSubtract( &NextEnumTime, &CurrentTime, &DeltaT );

		//
		// Note that data is lost on 64 bit machines.
		//
		dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );

		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( hEvents ),	// number of events
												 hEvents,				// event list
												 FALSE,					// wait for any one event to be signalled
												 dwMaxWaitTime,			// timeout
												 TRUE					// be nice and allow APCs
												 );
		switch ( dwWaitReturn )
		{
			//
			// SP closing
			//
			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
			{
				DPFX(DPFPREP,  8, "NT timer thread thread detected SPClose!" );
				fLooping = FALSE;
				break;
			}

			//
			// Enum wakeup event, someone added an enum to the list.  Clear
			// our enum time and go back to the top of the loop where we
			// will process enums.
			//
			case ( WAIT_OBJECT_0 + EVENT_INDEX_WAKE_NT_TIMER_THREAD ):
			{
				memset( &NextEnumTime, 0x00, sizeof( NextEnumTime ) );
				break;
			}

			//
			// Wait timeout.  We're probably going to process enums, go back
			// to the top of the loop.
			//
			case WAIT_TIMEOUT:
			{
				break;
			}

			//
			// wait failed
			//
			case WAIT_FAILED:
			{
				DPFX(DPFPREP,  0, "NT timer thread WaitForMultipleObjects failed: 0x%x", dwWaitReturn );
				DNASSERT( FALSE );
				break;
			}

			//
			// problem
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	DPFX(DPFPREP,  8, "NT timer thread is exiting!" );
	pThisThreadPool->LockTimerData();

	pThisThreadPool->m_fNTTimerThreadRunning = FALSE;
	pThisThreadPool->DecrementActiveThreadCount();

	pThisThreadPool->UnlockTimerData();


	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
//**********************************************************************
#endif // WINNT

//**********************************************************************
// ------------------------------
// CThreadPool::DialogThreadProc - thread proc for spawning dialogs
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::DialogThreadProc"

DWORD WINAPI	CThreadPool::DialogThreadProc( void *pParam )
{
	const DIALOG_THREAD_PARAM	*pThreadParam;
	BOOL	fComInitialized;


	//
	// Initialize COM.  If this fails, we'll have problems later.
	//
	fComInitialized = FALSE;
	switch ( COM_CoInitialize( NULL ) )
	{
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		case S_FALSE:
		{
			DNASSERT( FALSE );
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DPFX(DPFPREP,  0, "Failed to initialize COM!" );
			DNASSERT( FALSE );
			break;
		}
	}

	DNASSERT( pParam != NULL );
	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );

	pThreadParam->pDialogFunction( pThreadParam->pContext );

	pThreadParam->pThisThreadPool->DecrementActiveThreadCount();
	DNFree( pParam );

	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
//**********************************************************************

#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::ProcessWin9xEvents - process a Win9x events
//
// Entry:		Pointer core data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ProcessWin9xEvents"

void	CThreadPool::ProcessWin9xEvents( WIN9X_CORE_DATA *const pCoreData )
{
	BOOL	fAllIOComplete;
	DNASSERT( pCoreData != NULL );


	//
	// this funciton checks each of the handles to see if they're signalled
	// to prevent I/O from starving the rest of the handles
	//
	fAllIOComplete = TRUE;

	//
	// New job.  Account for the time spent in the wait.  Don't
	// account for time after the job is complete because it's
	// possible that the job was an job submission which will want
	// to reset the wait time.
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_PENDING_JOB ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			DPFX(DPFPREP,  8, "Primary Win9x thread has a pending job!" );
			ProcessWin9xJob( pCoreData );
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}


	//
	// TAPI message
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_TAPI_MESSAGE ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			DPFX(DPFPREP,  8, "Processing TAPI event!" );
			ProcessTapiEvent();
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}


	//
	// send complete
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_SEND_COMPLETE ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
//		    DPFX(DPFPREP,  0, "\n\n\nPrimary Win9x thread servicing sends!\n\n\n" );
			CompleteOutstandingSends( pCoreData->hWaitHandles[ EVENT_INDEX_SEND_COMPLETE ] );
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// receive complete
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_RECEIVE_COMPLETE ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
//		    DPFX(DPFPREP,  0, "\n\n\nPrimary Win9x thread servicing receives!\n\n\n" );
			CompleteOutstandingReceives( pCoreData->hWaitHandles[ EVENT_INDEX_RECEIVE_COMPLETE ] );
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// SP closing
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			DPFX(DPFPREP,  8, "Primary Win9x thread exit because SP closing!" );
			pCoreData->fLooping = FALSE;
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}



	//
	// If there is I/O pending the Read/Write handles are probably still signalled.
	// Wait 5 milliseconds to process it before running through the handles again.
	//
	LockReadData();
	LockWriteData();

	if ( ( m_OutstandingReadList.IsEmpty() == FALSE ) ||
		 ( m_OutstandingWriteList.IsEmpty() == FALSE ) )
	{
		fAllIOComplete = FALSE;
	}

	UnlockReadData();
	UnlockWriteData();

	if ( fAllIOComplete == FALSE )
	{
		SleepEx( 5, TRUE );
	}
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::ProcessWin9xJob - process a Win9x job
//
// Entry:		Pointer core data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ProcessWin9xJob"

void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
{
	THREAD_POOL_JOB	*pJobInfo;


	//
	// remove and process a single job from the list
	//
	pJobInfo = GetWorkItem();
	if ( pJobInfo != NULL )
	{
		switch ( pJobInfo->JobType )
		{
			//
			// enum refresh
			//
			case JOB_REFRESH_TIMER_JOBS:
			{
				DPFX(DPFPREP,  8, "WorkThread job REFRESH_ENUM" );
				DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
				LockTimerData();
				pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
				UnlockTimerData();

				if ( pCoreData->fTimerJobsActive != FALSE )
				{
					DPFX(DPFPREP,  8, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS" );
				}

				break;
			}

			//
			// issue callback for this job
			//
			case JOB_DELAYED_COMMAND:
			{
				DPFX(DPFPREP,  8, "WorkThread job DELAYED_COMMAND" );
				DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
				pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
				break;
			}

			//
			// other job
			//
			default:
			{
				DPFX(DPFPREP,  0, "WorkThread Win9x job unknown!" );
				DNASSERT( FALSE );
				break;
			}
		}

		pJobInfo->JobType = JOB_UNINITIALIZED;
		m_JobPool.Release( &m_JobPool, pJobInfo );
	}
}
//**********************************************************************
#endif // WIN95


//**********************************************************************
// ------------------------------
// CThreadPool::ProcessTapiEvent - process TAPI event
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void	CThreadPool::ProcessTapiEvent( void )
{
	LONG		lTapiReturn;
	LINEMESSAGE	LineMessage;


	lTapiReturn = p_lineGetMessage( GetTAPIInfo()->hApplicationInstance, &LineMessage, 0 );
	if ( lTapiReturn != LINEERR_NONE )
	{
		DPFX(DPFPREP,  0, "Failed to process Win9x TAPI message!" );
		DisplayTAPIError( 0, lTapiReturn );
	}
	else
	{
		CModemPort	*pModemPort;
		HANDLE		hModemPort;


		DNASSERT( sizeof( hModemPort ) == sizeof( LineMessage.dwCallbackInstance ) );
		hModemPort = reinterpret_cast<HANDLE>( LineMessage.dwCallbackInstance );

		pModemPort = static_cast<CModemPort*>( DataPortFromHandle( hModemPort ) );
		if ( pModemPort != NULL )
		{
			pModemPort->ProcessTAPIMessage( &LineMessage );
			pModemPort->DecRef();
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ThreadPoolJob_Alloc - allocate a new job
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ThreadPoolJob_Alloc"

BOOL	CThreadPool::ThreadPoolJob_Alloc( void *pItem )
{
	BOOL			fReturn;
	THREAD_POOL_JOB	*pJob;


	//
	// initialize
	//
	fReturn = TRUE;
	pJob = static_cast<THREAD_POOL_JOB*>( pItem );

	memset( pJob, 0x00, sizeof( *pJob ) );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ThreadPoolJob_Get - a job is being removed from the pool
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ThreadPoolJob_Get"

void	CThreadPool::ThreadPoolJob_Get( void *pItem )
{
	THREAD_POOL_JOB	*pJob;


	//
	// initialize
	//
	pJob = static_cast<THREAD_POOL_JOB*>( pItem );
	DNASSERT( pJob->JobType == JOB_UNINITIALIZED );

	//
	// cannot ASSERT the the following because the pool manager uses that memory
	//
//	DNASSERT( pJob->pNext == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ThreadPoolJob_Release - a job is being returned to the pool
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ThreadPoolJob_Release"

void	CThreadPool::ThreadPoolJob_Release( void *pItem )
{
	THREAD_POOL_JOB	*pJob;


	DNASSERT( pItem != NULL );
	pJob = static_cast<THREAD_POOL_JOB*>( pItem );

	DNASSERT( pJob->JobType == JOB_UNINITIALIZED );
	pJob->pNext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ThreadPoolJob_Dealloc - return job to memory manager
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::ThreadPoolJob_Dealloc"

void	CThreadPool::ThreadPoolJob_Dealloc( void *pItem )
{
	// don't do anything
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Alloc - allocate a new timer job entry
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::TimerEntry_Alloc"

BOOL	CThreadPool::TimerEntry_Alloc( void *pItem )
{
	BOOL					fReturn;
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	//
	// initialize
	//
	fReturn = TRUE;
	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );
	memset( pTimerEntry, 0x00, sizeof( *pTimerEntry ) );
	pTimerEntry->pContext = NULL;
	pTimerEntry->Linkage.Initialize();

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Get - get new timer job entry from pool
//
// Entry:		Pointer to new entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::TimerEntry_Get"

void	CThreadPool::TimerEntry_Get( void *pItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );

	pTimerEntry->Linkage.Initialize();
	DNASSERT( pTimerEntry->pContext == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Release - return timer job entry to pool
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::TimerEntry_Release"

void	CThreadPool::TimerEntry_Release( void *pItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );
	pTimerEntry->pContext= NULL;

	DNASSERT( pTimerEntry->Linkage.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Dealloc - deallocate a timer job entry
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CThreadPool::TimerEntry_Dealloc"

void	CThreadPool::TimerEntry_Dealloc( void *pItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	//
	// initialize
	//
	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );

	//
	// return associated poiner to write data
	//
// can't DNASSERT on Linkage because pool manager stomped on it
//	DNASSERT( pEnumEntry->Linkage.IsEmpty() != FALSE );
	DNASSERT( pTimerEntry->pContext == NULL );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemunk.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Unk.cpp
 *  Content:	IUnknown implementation
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Copied from winsock provider
 *	11/30/98	jtk		Initial checkin into SLM
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif

#define DPN_REG_LOCAL_MODEM_SERIAL_ROOT		L"\\DPNSPModemSerial"
#define DPN_REG_LOCAL_MODEM_MODEM_ROOT		L"\\DPNSPModemModem"

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
static	STDMETHODIMP DNSP_QueryInterface( IDP8ServiceProvider* lpDNSP, REFIID riid, LPVOID * ppvObj );

#define NOTSUPPORTED(parm)	(HRESULT (__stdcall *) (struct IDP8ServiceProvider *, parm)) DNSP_NotSupported


//**********************************************************************
// Function pointers
//**********************************************************************
// these are the vtables for serial and modem.  One or the other is used depending on
//	what is passed to DoCreateInstance
static	IDP8ServiceProviderVtbl	g_SerialInterface =
{
	DNSP_QueryInterface,
	DNSP_AddRef,
	DNSP_Release,
	DNSP_Initialize,
	DNSP_Close,
	DNSP_Connect,
	DNSP_Disconnect,
	DNSP_Listen,
	DNSP_SendData,
	DNSP_EnumQuery,
	DNSP_EnumRespond,
	DNSP_CancelCommand,
	NOTSUPPORTED(PSPCREATEGROUPDATA),		// CreateGroup
	NOTSUPPORTED(PSPDELETEGROUPDATA),		// DeleteGroup
	NOTSUPPORTED(PSPADDTOGROUPDATA),		// AddToGroup
	NOTSUPPORTED(PSPREMOVEFROMGROUPDATA),	// RemoveFromGroup
	DNSP_GetCaps,
	DNSP_SetCaps,
	DNSP_ReturnReceiveBuffers,
	DNSP_GetAddressInfo,
	DNSP_IsApplicationSupported,
	DNSP_EnumAdapters,
	NOTSUPPORTED(PSPPROXYENUMQUERYDATA)		// ProxyEnumQuery
};

static	IDP8ServiceProviderVtbl	g_ModemInterface =
{
	DNSP_QueryInterface,
	DNSP_AddRef,
	DNSP_Release,
	DNSP_Initialize,
	DNSP_Close,
	DNSP_Connect,
	DNSP_Disconnect,
	DNSP_Listen,
	DNSP_SendData,
	DNSP_EnumQuery,
	DNSP_EnumRespond,
	DNSP_CancelCommand,
	NOTSUPPORTED(PSPCREATEGROUPDATA),		// CreateGroup
	NOTSUPPORTED(PSPDELETEGROUPDATA),		// DeleteGroup
	NOTSUPPORTED(PSPADDTOGROUPDATA),		// AddToGroup
	NOTSUPPORTED(PSPREMOVEFROMGROUPDATA),	// RemoveFromGroup
	DNSP_GetCaps,
	DNSP_SetCaps,
	DNSP_ReturnReceiveBuffers,
	DNSP_GetAddressInfo,
	DNSP_IsApplicationSupported,
	DNSP_EnumAdapters,
	NOTSUPPORTED(PSPPROXYENUMQUERYDATA)		// ProxyEnumQuery
};


//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_QueryInterface - query for a particular interface
//
// Entry:		Pointer to current interface
//				Desired interface ID
//				Pointer to pointer to new interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_QueryInterface"

static	STDMETHODIMP DNSP_QueryInterface( IDP8ServiceProvider *lpDNSP, REFIID riid, LPVOID * ppvObj )
{
    HRESULT hr = S_OK;


	// assume no interface
	*ppvObj=NULL;

	 // hmmm, switch would be cleaner...
    if( IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IDP8ServiceProvider) )
    {
		*ppvObj = lpDNSP;
		DNSP_AddRef( lpDNSP );
    }
	else
	{
		hr =  E_NOINTERFACE;		
	}

    return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DoCreateInstance - create in instance of an interface
//
// Entry:		Pointer to class factory
//				Pointer to Unkown interface
//				Class reference
//				Desired interface ID
//				Pointer to pointer to interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateInstance"

HRESULT DoCreateInstance(LPCLASSFACTORY This, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid,
    						LPVOID *ppvObj )
{
    HRESULT hr;
	CSPData	*pSPData;


	//
	// intialize
	//
	hr = DPN_OK;
	pSPData = NULL;

	// we can either create an modem instance or a serial instance
    if ( IsEqualCLSID( rclsid, CLSID_DP8SP_MODEM ) )
    {
		//
		// finish interface intialization
		//
		hr = CreateSPData( &pSPData, &CLSID_DP8SP_MODEM, TYPE_MODEM, &g_ModemInterface );
		if ( hr != DPN_OK )
		{
			DNASSERT( pSPData == NULL );
			DPFX(DPFPREP,  0, "Problem creating modem interface!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
    else
    {
		// is it a serial GUID?
		if ( IsEqualCLSID( rclsid, CLSID_DP8SP_SERIAL ) )
		{
			//			
			// finish interface intialization
			//
			hr = CreateSPData( &pSPData, &CLSID_DP8SP_SERIAL, TYPE_SERIAL, &g_SerialInterface );
			if ( hr != DPN_OK )
			{
				DNASSERT( pSPData == NULL );
				DPFX(DPFPREP,  0, "Problem creating serial interface!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}
		}
		else
		{
			DPFX(DPFPREP,  0, "Invalid interface requested!" );
			// this shouldn't happen if they called IClassFactory::CreateObject correctly
			hr = E_UNEXPECTED;
			DNASSERT( FALSE );
			goto Failure;
		}
    }

    if (hr == S_OK)
    {
    	// get the right interface and bump the refcount
    	DNASSERT( pSPData != NULL );
		*ppvObj = pSPData->COMInterface();

		hr = DNSP_QueryInterface( static_cast<IDP8ServiceProvider*>( *ppvObj ), riid, ppvObj);
		DNASSERT( hr == S_OK );
    }

	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with DoCreateInstance!" );
		DisplayDNError( 0, hr );
	}

	return hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// IsClassImplemented - tells asked if this DLL implements a given class.
//		DLLs may implement multiple classes and multiple interfaces on those classes
//
// Entry:		Class reference
//
// Exit:		Boolean indicating whether the class is implemented
//				TRUE = class implemented
//				FALSE = class not implemented
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "IsClassImplemented"

BOOL IsClassImplemented( REFCLSID rclsid )
{
	return IsSerialGUID( &rclsid );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DllMain - main entry point for .DLL
//
// Entry:		Pointer to the service provider to initialize
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

EXP BOOL WINAPI DllMain( HINSTANCE hDllInst,
						 DWORD fdwReason,
						 LPVOID lpvReserved
						 )
{
    BOOL bResult = TRUE;
	switch( fdwReason )
    {
		case DLL_PROCESS_ATTACH:
		{
			DPFX(DPFPREP,  2, "====> ENTER: DLLMAIN(%p): Process Attach: %08lx, tid=%08lx", DllMain,
				 GetCurrentProcessId(), GetCurrentThreadId() );

			DNASSERT( g_hDLLInstance == NULL );
			g_hDLLInstance = hDllInst;

			//
			// attempt to initialize the OS abstraction layer
			//
			if ( DNOSIndirectionInit() != FALSE )
			{
#ifdef UNICODE
				// Make sure no one is trying to run the UNICODE version on Win9x
				DNASSERT(IsUnicodePlatform);
#endif
				if (SUCCEEDED(COM_Init()))
				{
					//
					// attempt to initialize process-global items
					//
					if ( InitProcessGlobals() == FALSE )
					{
						COM_Free();

						DNOSIndirectionDeinit();

						DPFX(DPFPREP,  0, "Failed to initialize globals!" );
						bResult = FALSE;
					}
				}
				else
				{
					DPFX(DPFPREP,  0, "Failed to initialize COM indirection layer!" );
					bResult = FALSE;
	
					DNOSIndirectionDeinit();
				}
			}
			else
			{
				DPFX(DPFPREP,  0, "Failed to initialize OS indirection layer!" );
				bResult = FALSE;
			}

			break;
		}

		case DLL_PROCESS_DETACH:
		{
			DPFX(DPFPREP,  2, "====> EXIT: DLLMAIN(%p): Process Detach %08lx, tid=%08lx",
					DllMain, GetCurrentProcessId(), GetCurrentThreadId() );

			DNASSERT( g_hDLLInstance != NULL );
			g_hDLLInstance = NULL;

			DeinitProcessGlobals();

			COM_Free();

			DNOSIndirectionDeinit();

			break;

		}

		default:
		{
			break;
		}
    }

    return bResult;
}
//**********************************************************************

#define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH

#undef DPF_MODNAME
#define DPF_MODNAME "LoadAndAllocString"

HRESULT LoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString )
{
	int length;
	HRESULT hr;

#ifdef WINNT
	wchar_t wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
	
	length = LoadStringW( g_hDLLInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );

	if( length == 0 )
	{
		hr = GetLastError();		
		
		DPFX(DPFPREP,  0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
		*lpswzString = NULL;

		return hr;
	}
	else
	{
		*lpswzString = new wchar_t[length+1];

		if( *lpswzString == NULL )
		{
			DPFX(DPFPREP,  0, "Alloc failure" );
			return DPNERR_OUTOFMEMORY;
		}

		wcscpy( *lpswzString, wszTmpBuffer );

		return DPN_OK;
	}

#else // WIN95
	
	char szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
		
	length = LoadStringA( g_hDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );

	if( length == 0 )
	{
		hr = GetLastError();		
		
		DPFX(DPFPREP,  0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
		*lpswzString = NULL;

		return hr;
	}
	else
	{
		*lpswzString = new wchar_t[length+1];

		if( *lpswzString == NULL )
		{
			DPFX(DPFPREP,  0, "Alloc failure" );
			return DPNERR_OUTOFMEMORY;
		}

		if( STR_jkAnsiToWide( *lpswzString, szTmpBuffer, length+1 ) != DPN_OK )
		{
			hr = GetLastError();
			
			DPFX(DPFPREP,  0, "Unable to upconvert from ansi to unicode hr=0x%x", hr );
			return hr;
		}

		return DPN_OK;
	}
#endif
}

#undef DPF_MODNAME
#define DPF_MODNAME "RegisterDefaultSettings"
//
// RegisterDefaultSettings
//
// This function registers the default settings for this module.
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT RegisterDefaultSettings()
{
	CRegistry creg;
	WCHAR *wszFriendlyName = NULL;
	HRESULT hr;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY DPN_REG_LOCAL_MODEM_MODEM_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot create Modem sub-area" );
		return DPNERR_GENERIC;
	}

	hr = LoadAndAllocString( IDS_FRIENDLYNAME_MODEM, &wszFriendlyName );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Could not load Modem name hr=0x%x", hr );
		return hr;
	}

	// Load from resource file
	creg.WriteString( DPN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );

	delete [] wszFriendlyName;

	creg.WriteGUID( DPN_REG_KEYNAME_GUID, CLSID_DP8SP_MODEM );

	creg.Close();

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY DPN_REG_LOCAL_MODEM_SERIAL_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot create Serial sub-aread" );
		return DPNERR_GENERIC;
	}

	hr = LoadAndAllocString( IDS_FRIENDLYNAME_SERIAL, &wszFriendlyName );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Could not load Serial name hr=0x%x", hr );
		return hr;
	}

	// Load from resource file
	creg.WriteString( DPN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );

	delete [] wszFriendlyName;

	creg.WriteGUID( DPN_REG_KEYNAME_GUID, CLSID_DP8SP_SERIAL );

	creg.Close();

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "UnRegisterDefaultSettings"
//
// UnRegisterDefaultSettings
//
// This function registers the default settings for this module.
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT UnRegisterDefaultSettings()
{
	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY, FALSE, TRUE ) )
	{
		DPFERR( "Cannot remove app, does not exist" );
	}
	else
	{
		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_MODEM_MODEM_ROOT)[1] ) )
		{
			DPFERR( "Cannot remove Modem sub-key, could have elements" );
		}

		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_MODEM_SERIAL_ROOT)[1] ) )
		{
			DPFERR( "Cannot remove Serial sub-key, could have elements" );
		}

	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
HRESULT WINAPI DllRegisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::Register( L"DirectPlay8SPModem.Modem.1", L"DirectPlay8 Modem Provider Object",
							  L"dpnmodem.dll", CLSID_DP8SP_MODEM, L"DirectPlay8SPModem.Modem") )
	{
		DPFERR( "Could not register dp8 Modem object" );
		fFailed = TRUE;
	}

	if( !CRegistry::Register( L"DirectPlay8SPModem.Serial.1", L"DirectPlay8 Serial Provider Object",
							  L"dpnmodem.dll", CLSID_DP8SP_SERIAL, L"DirectPlay8SPModem.Serial") )
	{
		DPFERR( "Could not register dp8 Serial object" );
		fFailed = TRUE;
	}

	if( FAILED( hr = RegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP,  0, "Could not register default settings hr = 0x%x", hr );
		fFailed = TRUE;
	}
	
	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
STDAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::UnRegister(CLSID_DP8SP_MODEM) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister Modem object" );
		fFailed = TRUE;
	}

	if( !CRegistry::UnRegister(CLSID_DP8SP_SERIAL) )
	{
		DPFX(DPFPREP,  0, "Failed to unregister Serial object" );
		fFailed = TRUE;
	}

	if( FAILED( hr = UnRegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP,  0, "Failed to remove default settings hr=0x%x", hr );
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemthreadpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ThreadPool.h
 *  Content:	Functions to manage a thread pool
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/01/99	jtk		Derived from Utils.h
 ***************************************************************************/

#ifndef __THREAD_POOL_H__
#define __THREAD_POOL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// max handles that can be waited on for Win9x
//
#define	MAX_WIN9X_HANDLE_COUNT	64

//
// job definitions
//
typedef enum	_JOB_TYPE
{
	JOB_UNINITIALIZED,			// uninitialized value
	JOB_DELAYED_COMMAND,		// callback provided
	JOB_REFRESH_TIMER_JOBS,		// revisit timer jobs
} JOB_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
class	CDataPort;
class	CThreadPool;
typedef struct	_THREAD_POOL_JOB		THREAD_POOL_JOB;
typedef	struct	_TIMER_OPERATION_ENTRY	TIMER_OPERATION_ENTRY;
typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	void	JOB_FUNCTION( THREAD_POOL_JOB *const pJobInfo );
typedef	void	TIMER_EVENT_CALLBACK( void *const pContext );
typedef	void	TIMER_EVENT_COMPLETE( const HRESULT hCompletionCode, void *const pContext );
typedef	void	DIALOG_FUNCTION( void *const pDialogContext );

//**********************************************************************
// Class prototypes
//**********************************************************************

//
// class for thread pool
//
class	CThreadPool : public CLockedPoolItem
{
	public:
		CThreadPool();
		~CThreadPool();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }
		void	LockReadData( void ) { DNEnterCriticalSection( &m_IODataLock ); }
		void	UnlockReadData( void ) { DNLeaveCriticalSection( &m_IODataLock ); }
		void	LockWriteData( void ) { DNEnterCriticalSection( &m_IODataLock ); }
		void	UnlockWriteData( void ) { DNLeaveCriticalSection( &m_IODataLock ); }


		BOOL	Initialize( void );
		void	Deinitialize( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::SetOwningPool"
		void	SetOwningPool( CLockedPool< CThreadPool > *pOwningPool )
		{
			DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) );
			m_pOwningPool = pOwningPool;
		}

#ifdef WINNT
		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetIOCompletionPort"
		HANDLE	GetIOCompletionPort( void ) const
		{
			DNASSERT( m_hIOCompletionPort != NULL );
			return	m_hIOCompletionPort;
		}
#endif

		//
		// functions for handling I/O data
		//
		CReadIOData	*CreateReadIOData( void );
		void	ReturnReadIOData( CReadIOData *const pReadIOData );
		CWriteIOData	*CreateWriteIOData( void );
		void	ReturnWriteIOData( CWriteIOData *const pWriteData );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::ReinsertInReadList"
		void	ReinsertInReadList( CReadIOData *const pReadIOData )
		{
			//
			// Win9x operations are removed from the active list when they
			// complete and need to be readded if they're going to be reattempted.
			// WinNT doesn't remove items from the list until they're processed.
			//
#ifdef WIN95
			DNASSERT( pReadIOData != NULL );
			DNASSERT( pReadIOData->m_OutstandingReadListLinkage.IsEmpty() != FALSE );
			LockReadData();
			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( &m_OutstandingReadList );
			UnlockReadData();
#endif
		}

		//
		// TAPI functions
		//
		const TAPI_INFO	*GetTAPIInfo( void ) const { return &m_TAPIInfo; }
		BOOL	TAPIAvailable( void ) const { return m_fTAPIAvailable; }

		HRESULT	SubmitDelayedCommand( JOB_FUNCTION *const pFunction,
									  JOB_FUNCTION *const pCancelFunction,
									  void *const pContext );

		HRESULT	SubmitTimerJob( const UINT_PTR uRetryCount,
								const BOOL fRetryForever,
								const DN_TIME RetryInterval,
								const BOOL fIdleWaitForever,
								const DN_TIME IdleTimeout,
								TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
								TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
								void *const pContext );
		
		BOOL	StopTimerJob( void *const pContext, const HRESULT hCommandResult );

		//
		// thread functions
		//
		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, void *const pDialogContext );
		
		LONG	GetIntendedThreadCount( void ) const { return m_iIntendedThreadCount; }
		void	SetIntendedThreadCount( const LONG iIntendedThreadCount ) { m_iIntendedThreadCount = iIntendedThreadCount; }
		LONG	ThreadCount( void ) const { return m_iTotalThreadCount; }
#ifdef WINNT
		LONG	NTCompletionThreadCount( void ) const { return m_iNTCompletionThreadCount; }
#endif
		
		void	IncrementActiveThreadCount( void ) { DNInterlockedIncrement( const_cast<LONG*>( &m_iTotalThreadCount ) ); }
		void	DecrementActiveThreadCount( void ) { DNInterlockedDecrement( const_cast<LONG*>( &m_iTotalThreadCount ) ); }

#ifdef WINNT
		void	IncrementActiveNTCompletionThreadCount( void )
		{
			IncrementActiveThreadCount();
			DNInterlockedIncrement( const_cast<LONG*>( &m_iNTCompletionThreadCount ) );
		}

		void	DecrementActiveNTCompletionThreadCount( void )
		{
			DNInterlockedDecrement( const_cast<LONG*>( &m_iNTCompletionThreadCount ) );
			DecrementActiveThreadCount();
		}
#endif
		
		HRESULT	GetIOThreadCount( LONG *const piThreadCount );
		HRESULT	SetIOThreadCount( const LONG iMaxThreadCount );
		BOOL IsThreadCountReductionAllowed( void ) const { return m_fAllowThreadCountReduction; }
		HRESULT PreventThreadPoolReduction( void );

		//
		// data port handle functions
		//
		HRESULT	CreateDataPortHandle( CDataPort *const pDataPort );
		void	CloseDataPortHandle( CDataPort *const pDataPort );
		CDataPort	*DataPortFromHandle( const HANDLE hDataPort );

		//
		// pool functions
		//
		BOOL	PoolAllocFunction( void );
		BOOL	PoolInitFunction( void );
		void	PoolDeinitFunction( void );
		void	PoolDeallocFunction( void );

	protected:

	private:
		BYTE				m_Sig[4];	// debugging signature ('THPL')
		
		DNCRITICAL_SECTION	m_Lock;		// local lock

		CLockedPool< CThreadPool >	*m_pOwningPool;

		volatile LONG	m_iTotalThreadCount;			// number of active threads
#ifdef WINNT
		volatile LONG	m_iNTCompletionThreadCount;		// count of NT I/O completion threads
		HANDLE	m_hIOCompletionPort;	// I/O completion port for NT
#endif
		
		BOOL	m_fAllowThreadCountReduction;	// Boolean indicating that the thread count is locked from being reduced
		LONG	m_iIntendedThreadCount;			// how many threads will be started

		HANDLE	m_hStopAllThreads;		// handle used to stop all non-I/O completion threads
#ifdef WIN95
		HANDLE	m_hSendComplete;		// send complete on a data port
		HANDLE	m_hReceiveComplete;		// receive complete on a data port
		HANDLE	m_hTAPIEvent;			// handle to be used for TAPI messages, this handle is not closed on exit
		HANDLE	m_hFakeTAPIEvent;		// Fake TAPI event so the Win9x threads can always wait on a fixed
										// number of events.  If TAPI cannot be initialzed, this event needs to be
										// created and copied to m_hTAPIEvent (though it will never be signalled)
#endif
		//
		// Handle table to prevent TAPI messages from going to CModemPorts when
		// they're no longer in use.
		//
		CHandleTable	m_DataPortHandleTable;

		//
		// list of pending network operations, it doesn't really matter if they're
		// reads or writes, they're just pending.  Since serial isn't under extreme
		// loads, share one lock for all of the data
		//
		DNCRITICAL_SECTION	m_IODataLock;								// lock for all read data
		CContextPool< CReadIOData, HANDLE >		m_ReadIODataPool;		// pool for read data
		CBilink		m_OutstandingReadList;								// list of outstanding reads

		CContextPool< CWriteIOData, HANDLE >	m_WriteIODataPool;	// pool for write data
		CBilink		m_OutstandingWriteList;							// list of outstanding writes

		//
		// The Job data lock covers all items through and including m_fNTTimerThreadRunning
		//
		DNCRITICAL_SECTION	m_JobDataLock;		// lock for job queue/pool

		FPOOL		m_TimerEntryPool;			// pool for timed entries
		FPOOL		m_JobPool;					// pool of jobs for work threads

		CJobQueue	m_JobQueue;					// job queue

		//
		// Data used by the the timer thread.  This data is protected by m_TimerDataLock.
		// This data is cleaned by the timer thread.  Since only one timer thread
		// is allowed to run at any given time, the status of the NT timer thread
		// can be determined by m_fNTEnumThreadRunning.  Win9x doesn't have a timer
		// thread, the main thread loop is timed.
		//
		DNCRITICAL_SECTION	m_TimerDataLock;
		CBilink				m_TimerJobList;
#ifdef WINNT
		BOOL				m_fNTTimerThreadRunning;
#endif

		//
		// TAPI information.  This is required to be in the thread pool because
		// it's needed for thread initialzation.
		//
		BOOL		m_fTAPIAvailable;
		TAPI_INFO	m_TAPIInfo;

		struct
		{
			BOOL	fTAPILoaded : 1;
			BOOL	fLockInitialized : 1;
			BOOL	fIODataLockInitialized : 1;
			BOOL	fJobDataLockInitialized : 1;
			BOOL	fTimerDataLockInitialized : 1;
			BOOL	fDataPortHandleTableInitialized :1 ;
			BOOL	fJobQueueInitialized : 1;
			BOOL	fJobPoolInitialized : 1;
			BOOL	fTimerEntryPoolInitialized : 1;
		} m_InitFlags;

		void	LockJobData( void ) { DNEnterCriticalSection( &m_JobDataLock ); }
		void	UnlockJobData( void ) { DNLeaveCriticalSection( &m_JobDataLock ); }

		void	LockTimerData( void ) { DNEnterCriticalSection( &m_TimerDataLock ); }
		void	UnlockTimerData( void ) { DNLeaveCriticalSection( &m_TimerDataLock ); }

#ifdef WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetSendCompleteEvent"
		HANDLE	GetSendCompleteEvent( void ) const
		{
			DNASSERT( m_hSendComplete != NULL );
			return m_hSendComplete;
		}
#endif

#ifdef WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetReceiveCompleteEvent"
		HANDLE	GetReceiveCompleteEvent( void ) const
		{
			DNASSERT( m_hReceiveComplete != NULL );
			return m_hReceiveComplete;
		}
#endif

#ifdef WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetTAPIMessageEvent"
		HANDLE	GetTAPIMessageEvent( void ) const
		{
			DNASSERT( m_hTAPIEvent != NULL );
			return	m_hTAPIEvent;
		}
#endif

		static	UINT_PTR	SaturatedWaitTime( const DN_TIME &Time )
		{
				UINT_PTR	uReturn;

				if ( Time.Time32.TimeHigh != 0 )
				{
					uReturn = -1;
				}
				else
				{
					uReturn = Time.Time32.TimeLow;
				}

				return	uReturn;
		}

#ifdef WINNT
		HRESULT	WinNTInit( void );
#else
		HRESULT	Win9xInit( void );
#endif

		BOOL	ProcessTimerJobs( const CBilink *const pJobList, DN_TIME *const pNextJobTime);

		BOOL	ProcessTimedOperation( TIMER_OPERATION_ENTRY *const pJob,
									   const DN_TIME *const pCurrentTime,
									   DN_TIME *const pNextJobTime );

#ifdef WINNT
		HRESULT	StartNTTimerThread( void );
		void	WakeNTTimerThread( void );
#endif
		void	RemoveTimerOperationEntry( TIMER_OPERATION_ENTRY *const pTimerOperationData, const HRESULT hReturnCode );

#ifdef WIN95
		void	CompleteOutstandingSends( const HANDLE hSendCompleteEvent );
		void	CompleteOutstandingReceives( const HANDLE hReceiveCompleteEvent );

		static	DWORD WINAPI	PrimaryWin9xThread( void *pParam );
#endif

#ifdef WINNT
		static	DWORD WINAPI	WinNTIOCompletionThread( void *pParam );
		static	DWORD WINAPI	WinNTTimerThread( void *pParam );
#endif
		static	DWORD WINAPI	DialogThreadProc( void *pParam );

		HRESULT	SubmitWorkItem( THREAD_POOL_JOB *const pJob );
		THREAD_POOL_JOB	*GetWorkItem( void );

		static	void	CancelRefreshTimerJobs( THREAD_POOL_JOB *const pJobData );
#ifdef WIN95
		void	ProcessWin9xEvents( WIN9X_CORE_DATA *const pCoreData );
		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );
#endif
		void	ProcessTapiEvent( void );

#ifdef WINNT
		void	StartNTCompletionThread( void );
#endif
		void	StopAllThreads( void );
//		void	CancelOutstandingJobs( void );
		void	CancelOutstandingIO( void );
		void	ReturnSelfToPool( void );

		//
		// functions for managing the job pool
		//
		static	BOOL	ThreadPoolJob_Alloc( void *pItem );
		static	void	ThreadPoolJob_Get( void *pItem );
		static	void	ThreadPoolJob_Release( void *pItem );
		static	void	ThreadPoolJob_Dealloc( void *pItem );

		//
		// functions for managing the timer data pool
		//
		static	BOOL	TimerEntry_Alloc( void *pItem );
		static	void	TimerEntry_Get( void *pItem );
		static	void	TimerEntry_Release( void *pItem );
		static	void	TimerEntry_Dealloc( void *pItem );

		//
		// prevent unwarranted copies
		//
		CThreadPool( const CThreadPool & );
		CThreadPool& operator=( const CThreadPool & );
};

#undef DPF_MODNAME

#endif	// __THREAD_POOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   Utils.cpp
 *  Content:	Serial service provider utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DEFAULT_WIN9X_THREADS	1

static const WCHAR	g_RegistryBase[] = L"SOFTWARE\\Microsoft\\DirectPlay8";
static const WCHAR	g_RegistryKeyThreadCount[] = L"ThreadCount";

//
// default buffer size for getting TAPI device caps
//
static const DWORD	g_dwDefaultTAPIDevCapsSize = 512;

//
// TAPI module name
//
static const TCHAR	g_TAPIModuleName[] = TEXT("TAPI32.DLL");

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// global variables that are unique for the process
//
static	DNCRITICAL_SECTION	g_InterfaceGlobalsLock;

static volatile	LONG	g_iThreadPoolRefCount = 0;
static	CThreadPool		*g_pThreadPool = NULL;

static volatile LONG	g_iTAPIRefCount = 0;
static	HMODULE			g_hTAPIModule = NULL;

//**********************************************************************
// Function prototypes
//**********************************************************************
static	void	ReadSettingsFromRegistry( void );
static	BYTE	GetAddressEncryptionKey( void );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitProcessGlobals - initialize the global items needed for the SP to operate
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "InitProcessGlobals"

BOOL	InitProcessGlobals( void )
{
	BOOL	fReturn;
	BOOL	fCriticalSectionInitialized;
	DWORD	iIndex;


	//
	// initialize
	//
	fReturn = TRUE;
	fCriticalSectionInitialized = FALSE;

	ReadSettingsFromRegistry();

	if ( DNInitializeCriticalSection( &g_InterfaceGlobalsLock ) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}

	fCriticalSectionInitialized = TRUE;


	if ( InitializePools() == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}

	// Load localized string from resources //////////////////////////////////////////////////////////////
	for (iIndex = 0; iIndex < g_dwBaudRateCount; iIndex++)
	{
		if (!LoadString(g_hDLLInstance, IDS_BAUD_9600 + iIndex, g_BaudRate[iIndex].szLocalizedKey, 256))
		{
			fReturn = FALSE;
			goto Failure;
		}
	}

	for (iIndex = 0; iIndex < g_dwStopBitsCount; iIndex++)
	{
		if (!LoadString(g_hDLLInstance, IDS_STOPBITS_ONE + iIndex, g_StopBits[iIndex].szLocalizedKey, 256))
		{
			fReturn = FALSE;
			goto Failure;
		}
	}

	for (iIndex = 0; iIndex < g_dwParityCount; iIndex++)
	{
		if (!LoadString(g_hDLLInstance, IDS_PARITY_EVEN + iIndex, g_Parity[iIndex].szLocalizedKey, 256))
		{
			fReturn = FALSE;
			goto Failure;
		}
	}

	for (iIndex = 0; iIndex < g_dwFlowControlCount; iIndex++)
	{
		if (!LoadString(g_hDLLInstance, IDS_FLOW_NONE + iIndex, g_FlowControl[iIndex].szLocalizedKey, 256))
		{
			fReturn = FALSE;
			goto Failure;
		}
	}

	DNASSERT( g_pThreadPool == NULL );

Exit:
	return	fReturn;

Failure:

	if ( fCriticalSectionInitialized != FALSE )
	{
		DNDeleteCriticalSection( &g_InterfaceGlobalsLock );
		fCriticalSectionInitialized = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitProcessGlobals - deinitialize the global items
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DeinitProcessGlobals"

void	DeinitProcessGlobals( void )
{
	BOOL	fFreeReturn;


	DNASSERT( g_pThreadPool == NULL );
	DNASSERT( g_iThreadPoolRefCount == 0 );

	DeinitializePools();
	DNDeleteCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitializeInterfaceGlobals - perform global initialization for an interface.
//		This entails starting the thread pool and RSIP (if applicable).
//
// Entry:		Pointer to SPData
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "InitializeInterfaceGlobals"

HRESULT	InitializeInterfaceGlobals( CSPData *const pSPData )
{
	HRESULT	hr;
	INT_PTR iWinsockVersion;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	if ( g_pThreadPool == NULL )
	{
		DNASSERT( g_iThreadPoolRefCount == 0 );
		g_pThreadPool = CreateThreadPool();
		if ( g_pThreadPool == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		else
		{
			g_iThreadPoolRefCount++;
		}
	}
	else
	{
		DNASSERT( g_iThreadPoolRefCount != 0 );
		g_iThreadPoolRefCount++;
		g_pThreadPool->AddRef();
	}

Exit:
	pSPData->SetThreadPool( g_pThreadPool );
	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitializeInterfaceGlobals - deinitialize thread pool and Rsip
//
// Entry:		Pointer to service provider
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DeinitializeInterfaceGlobals"

void	DeinitializeInterfaceGlobals( CSPData *const pSPData )
{
	CThreadPool		*pThreadPool;
	BOOL			fCleanUp;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	pThreadPool = NULL;
	fCleanUp = FALSE;

	//
	// Process as little as possible inside the lock.  If any of the items
	// need to be released, pointers to them will be set.
	//
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	DNASSERT( g_pThreadPool != NULL );
	DNASSERT( g_iThreadPoolRefCount != 0 );
	DNASSERT( g_pThreadPool == pSPData->GetThreadPool() );

	pThreadPool = pSPData->GetThreadPool();

	//
	// remove thread pool reference
	//
	g_iThreadPoolRefCount--;
	if ( g_iThreadPoolRefCount == 0 )
	{
		g_pThreadPool = NULL;
		fCleanUp = TRUE;
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );

	//
	// now that we're outside of the lock, clean up the thread pool if this
	// was the last reference to it
	//
	DNASSERT( pThreadPool != NULL );
	if ( fCleanUp != FALSE )
	{
		pThreadPool->Deinitialize();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// LoadTAPILibrary - load TAPI library
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "LoadTAPILibrary"

HRESULT	LoadTAPILibrary( void )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

	DNEnterCriticalSection( &g_InterfaceGlobalsLock );
	if ( g_iTAPIRefCount != 0 )
	{
		DNASSERT( p_lineAnswer != NULL );
		DNASSERT( p_lineClose != NULL );
		DNASSERT( p_lineConfigDialog != NULL );
		DNASSERT( p_lineDeallocateCall != NULL );
		DNASSERT( p_lineDrop != NULL );
		DNASSERT( p_lineGetDevCaps != NULL );
		DNASSERT( p_lineGetID != NULL );
		DNASSERT( p_lineGetMessage != NULL );
		DNASSERT( p_lineInitializeEx != NULL );
		DNASSERT( p_lineMakeCall != NULL );
		DNASSERT( p_lineNegotiateAPIVersion != NULL );
		DNASSERT( p_lineOpen != NULL );
		DNASSERT( p_lineShutdown != NULL );
	}
	else
	{
		DNASSERT( g_hTAPIModule == NULL );
		DNASSERT( p_lineAnswer == NULL );
		DNASSERT( p_lineClose == NULL );
		DNASSERT( p_lineConfigDialog == NULL );
		DNASSERT( p_lineDeallocateCall == NULL );
		DNASSERT( p_lineDrop == NULL );
		DNASSERT( p_lineGetDevCaps == NULL );
		DNASSERT( p_lineGetID == NULL );
		DNASSERT( p_lineGetMessage == NULL );
		DNASSERT( p_lineInitializeEx == NULL );
		DNASSERT( p_lineMakeCall == NULL );
		DNASSERT( p_lineNegotiateAPIVersion == NULL );
		DNASSERT( p_lineOpen == NULL );
		DNASSERT( p_lineShutdown == NULL );

		g_hTAPIModule = LoadLibrary( g_TAPIModuleName );
		if ( g_hTAPIModule == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to load TAPI!" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		p_lineAnswer = reinterpret_cast<TAPI_lineAnswer*>( GetProcAddress( g_hTAPIModule, "lineAnswer" ) );
		if ( p_lineAnswer == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineAnswer" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineClose = reinterpret_cast<TAPI_lineClose*>( GetProcAddress( g_hTAPIModule, "lineClose"  ) );
		if ( p_lineClose == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineClose" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		p_lineConfigDialog = reinterpret_cast<TAPI_lineConfigDialog*>( GetProcAddress( g_hTAPIModule, "lineConfigDialog" TAPI_APPEND_LETTER ) );
		if ( p_lineConfigDialog == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineConfigDialog" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		p_lineDeallocateCall = reinterpret_cast<TAPI_lineDeallocateCall*>( GetProcAddress( g_hTAPIModule, "lineDeallocateCall" ) );
		if ( p_lineDeallocateCall == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineDeallocateCall" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineDrop = reinterpret_cast<TAPI_lineDrop*>( GetProcAddress( g_hTAPIModule, "lineDrop" ) );
		if ( p_lineDrop == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineDrop" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineGetDevCaps = reinterpret_cast<TAPI_lineGetDevCaps*>( GetProcAddress( g_hTAPIModule, "lineGetDevCaps" TAPI_APPEND_LETTER ) );
		if ( p_lineGetDevCaps == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineGetDevCaps" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineGetID = reinterpret_cast<TAPI_lineGetID*>( GetProcAddress( g_hTAPIModule, "lineGetID" TAPI_APPEND_LETTER ) );
		if ( p_lineGetID == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineGetID" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineGetMessage = reinterpret_cast<TAPI_lineGetMessage*>( GetProcAddress( g_hTAPIModule, "lineGetMessage" ) );
		if ( p_lineGetMessage == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineGetMessage" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineInitializeEx = reinterpret_cast<TAPI_lineInitializeEx*>( GetProcAddress( g_hTAPIModule, "lineInitializeEx" TAPI_APPEND_LETTER ) );
		if ( p_lineInitializeEx == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineInitializeEx" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		p_lineMakeCall = reinterpret_cast<TAPI_lineMakeCall*>( GetProcAddress( g_hTAPIModule, "lineMakeCall" TAPI_APPEND_LETTER ) );
		if ( p_lineMakeCall == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineMakeCall" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineNegotiateAPIVersion = reinterpret_cast<TAPI_lineNegotiateAPIVersion*>( GetProcAddress( g_hTAPIModule, "lineNegotiateAPIVersion" ) );
		if ( p_lineNegotiateAPIVersion == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineNegotiateAPIVersion" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
		
		p_lineOpen = reinterpret_cast<TAPI_lineOpen*>( GetProcAddress( g_hTAPIModule, "lineOpen" TAPI_APPEND_LETTER ) );
		if ( p_lineOpen == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineOpen" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		p_lineShutdown = reinterpret_cast<TAPI_lineShutdown*>( GetProcAddress( g_hTAPIModule, "lineShutdown" ) );
		if ( p_lineShutdown == NULL )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to GetProcAddress for lineShutdown" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}
	}
	
	DNASSERT( g_iTAPIRefCount != -1 );
	g_iTAPIRefCount++;

Exit:	
	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
	return	hr;

Failure:
	hr = DPNERR_OUTOFMEMORY;

	p_lineAnswer = NULL;
	p_lineClose = NULL;
	p_lineConfigDialog = NULL;
	p_lineDeallocateCall = NULL;
	p_lineDrop = NULL;
	p_lineGetDevCaps = NULL;
	p_lineGetID = NULL;
	p_lineGetMessage = NULL;
	p_lineInitializeEx = NULL;
	p_lineMakeCall = NULL;
	p_lineNegotiateAPIVersion = NULL;
	p_lineOpen = NULL;
	p_lineShutdown = NULL;
	
	if ( g_hTAPIModule != NULL )
	{
		if ( FreeLibrary( g_hTAPIModule ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem unloading TAPI module on failed load!" );
			DisplayErrorCode( 0, dwError );
		}
	
		g_hTAPIModule = NULL;
	}
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// UnloadTAPILibrary - unload TAPI library
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "UnloadTAPILibrary"

void	UnloadTAPILibrary( void )
{
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	DNASSERT( g_iTAPIRefCount != 0 );
	g_iTAPIRefCount--;
	if ( g_iTAPIRefCount == 0 )
	{
		DNASSERT( g_hTAPIModule != NULL );
		DNASSERT( p_lineAnswer != NULL );
		DNASSERT( p_lineClose != NULL );
		DNASSERT( p_lineConfigDialog != NULL );
		DNASSERT( p_lineDeallocateCall != NULL );
		DNASSERT( p_lineDrop != NULL );
		DNASSERT( p_lineGetDevCaps != NULL );
		DNASSERT( p_lineGetID != NULL );
		DNASSERT( p_lineGetMessage != NULL );
		DNASSERT( p_lineInitializeEx != NULL );
		DNASSERT( p_lineMakeCall != NULL );
		DNASSERT( p_lineNegotiateAPIVersion != NULL );
		DNASSERT( p_lineOpen != NULL );
		DNASSERT( p_lineShutdown != NULL );

		if ( FreeLibrary( g_hTAPIModule ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem unloading TAPI module on failed load!" );
			DisplayErrorCode( 0, dwError );
		}
	
		g_hTAPIModule = NULL;
		p_lineAnswer = NULL;
		p_lineClose = NULL;
		p_lineConfigDialog = NULL;
		p_lineDeallocateCall = NULL;
		p_lineDrop = NULL;
		p_lineGetDevCaps = NULL;
		p_lineGetID = NULL;
		p_lineGetMessage = NULL;
		p_lineInitializeEx = NULL;
		p_lineMakeCall = NULL;
		p_lineNegotiateAPIVersion = NULL;
		p_lineOpen = NULL;
		p_lineShutdown = NULL;
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// IsSerialGUID - is a GUID a serial GUID?
//
// Entry:		Pointer to GUID
//
// Exit:		Boolean inficating whether the GUID is a serial GUID
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "IsSerialGUID"

BOOL	IsSerialGUID( const GUID *const pGuid )
{
	BOOL	fReturn;


	DNASSERT( pGuid != NULL );

	//
	// assume guid is serial
	//
	fReturn = TRUE;

	//
	// is this modem or serial?
	//
	if ( IsEqualCLSID( *pGuid, CLSID_DP8SP_MODEM ) == FALSE )
	{
		if ( IsEqualCLSID( *pGuid, CLSID_DP8SP_SERIAL ) == FALSE )
		{
			// not a known GUID
			fReturn = FALSE;
		}
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// StringToValue - convert a string to an enumerated value
//
// Entry:		Pointer to string
//				Length of string
//				Pointer to destination enum
//				Pointer to string/enum pairs
//				Count of string/enum pairs
//
// Exit:		Boolean indicating success
//				TRUE = value found
//				FALSE = value not found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "StringToValue"

BOOL	StringToValue( const WCHAR *const pString,
					   const DWORD dwStringLength,
					   VALUE_ENUM_TYPE *const pEnum,
					   const STRING_BLOCK *const pStringBlock,
					   const DWORD dwPairCount )
{
	BOOL	fFound;
	DWORD	dwCount;


	// initialize
	fFound = FALSE;
	dwCount = dwPairCount;

	// loop through list
	while ( ( dwCount > 0 ) && ( fFound == FALSE ) )
	{
		// make array index
		dwCount--;

		// are the strings the same length?
		if ( pStringBlock[ dwCount ].dwWCHARKeyLength == dwStringLength )
		{
			// is this what we were looking for?
			if ( memcmp( pString, pStringBlock[ dwCount ].pWCHARKey, dwStringLength ) == 0 )
			{
				// found it
				fFound = TRUE;
				*pEnum = pStringBlock[ dwCount ].dwEnumValue;
			}
		}
	}

	return	fFound;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ValueToString - split extra info into components
//
// Entry:		Pointer to pointer to string
//				Length of string
//				Enumerated value
//				Pointer to string-enum pairs
//				Count of string-enum pairs
//
// Exit:		Boolean indicating success
//				TRUE = value was converted
//				FALSE = value was not converted
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ValueToString"

BOOL	ValueToString( const WCHAR **const ppString,
					   DWORD *const pdwStringLength,
					   const DWORD Enum,
					   const STRING_BLOCK *const pStringBlock,
					   const DWORD dwPairCount )
{
	BOOL	fFound;
	DWORD	dwCount;


	// initialize
	fFound = FALSE;
	dwCount = dwPairCount;

	// loop through strings
	while ( ( dwCount > 0 ) && ( fFound == FALSE ))
	{
		// make array index
		dwCount--;

		// is this the enum?
		if ( pStringBlock[ dwCount ].dwEnumValue == Enum )
		{
			// note that we found the value
			*ppString = pStringBlock[ dwCount ].pWCHARKey;
			*pdwStringLength = pStringBlock[ dwCount ].dwWCHARKeyLength;
			fFound = TRUE;
		}
	}

	return	fFound;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReadSettingsFromRegistry - read custom registry keys
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReadSettingsFromRegistry"

static void	ReadSettingsFromRegistry( void )
{
	CRegistry	RegObject;


	if ( RegObject.Open( HKEY_LOCAL_MACHINE, g_RegistryBase ) != FALSE )
	{
		DWORD	dwRegValue;

		//
		// read default threads
		//
		if ( RegObject.ReadDWORD( g_RegistryKeyThreadCount, dwRegValue ) != FALSE )
		{
			g_iThreadCount = dwRegValue;	
		}
	
		//
		// if thread count is zero, use the 'default' for the system
		//
		if ( g_iThreadCount == 0 )
		{
#ifdef WIN95
			g_iThreadCount = DEFAULT_WIN9X_THREADS;
#else // WINNT
			SYSTEM_INFO		SystemInfo;

			//
			// as suggested by 'Multithreading Applications in Win32' book:
			// dwNTThreadCount = ( ( processors * 2 ) + 2 )
			//
			memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
			GetSystemInfo( &SystemInfo );
			
			g_iThreadCount = ( ( 2 * SystemInfo.dwNumberOfProcessors ) + 2 );
#endif
		}
		
		RegObject.Close();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetAddressEncryptionKey - get a key used to encrypt device GUIDs
//
// Entry:		Nothing
//
// Exit:		Byte key
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetAddressEncryptionKey"

static	BYTE	GetAddressEncryptionKey( void )
{
	BYTE		bReturn;
	UINT_PTR	ProcessID;

	bReturn = 0;
	ProcessID = GetCurrentProcessId();
	while ( ProcessID > 0 )
	{
		bReturn ^= ProcessID;
		ProcessID >>= ( sizeof( bReturn ) * 8 );
	}

	return	bReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeviceIDToGuid - convert a device ID to an adapter GUID
//
// Entry:		Reference of Guid to fill
//				Device ID
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DeviceIDToGuid"

void	DeviceIDToGuid( GUID *const pGuid, const UINT_PTR DeviceID, const GUID *const pEncryptionGuid )
{
	DNASSERT( DeviceID < MAX_DATA_PORTS );

	DNASSERT( sizeof( *pGuid ) == sizeof( *pEncryptionGuid ) );
	memset( pGuid, 0x00, sizeof( *pGuid ) );
	reinterpret_cast<BYTE*>( pGuid )[ 0 ] = static_cast<BYTE>( DeviceID );

	EncryptGuid( pGuid, pGuid, pEncryptionGuid );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GuidToDeviceID - convert an adapter GUID to a device ID
//
// Entry:		Reference of Guid
//				
//
// Exit:		Device ID
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GuidToDeviceID"

DWORD	GuidToDeviceID( const GUID *const pGuid, const GUID *const pEncryptionGuid )
{
	GUID	DecryptedGuid;


	DNASSERT( pGuid != NULL );
	DNASSERT( pEncryptionGuid != NULL );

	DecryptGuid( pGuid, &DecryptedGuid, pEncryptionGuid );
	return	reinterpret_cast<const BYTE*>( &DecryptedGuid )[ 0 ];
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ComDeviceIDToString - convert a COM device ID to a string
//
// Entry:		Pointer to destination string (assumed to be large enough)
//				Device ID
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ComDeviceIDToString"

void	ComDeviceIDToString( TCHAR *const pString, const UINT_PTR uDeviceID )
{
	UINT_PTR	uTemp;


	DNASSERT( uDeviceID < MAX_DATA_PORTS );

	uTemp = uDeviceID;
	memcpy( pString, TEXT("COM000"), COM_PORT_STRING_LENGTH * sizeof(TCHAR) );
	pString[ 5 ] = ( static_cast<char>( uTemp % 10 ) ) + TEXT('0');
	uTemp /= 10;
	pString[ 4 ] = ( static_cast<char>( uTemp % 10 ) ) + TEXT('0');
	uTemp /= 10;
	pString[ 3 ] = ( static_cast<char>( uTemp % 10 ) ) + TEXT('0');
	DNASSERT( uTemp < 10 );

	if ( uDeviceID < 100 )
	{
		if ( uDeviceID < 10 )
		{
			DNASSERT( pString[ 3 ] == TEXT('0') );
			DNASSERT( pString[ 4 ] == TEXT('0') );
			pString[ 3 ] = pString[ 5 ];
			pString[ 4 ] = TEXT('\0');
			pString[ 5 ] = TEXT('\0');
		}
		else
		{
			DNASSERT( pString[ 3 ] == TEXT('0') );
			pString[ 3 ] = pString[ 4 ];
			pString[ 4 ] = pString[ 5 ];
			pString[ 5 ] = TEXT('\0');
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// WideToANSI - convert a wide string to an ANSI string
//
// Entry:		Pointer to source wide string
//				Size of source string (in WCHAR units, -1 implies NULL-terminated)
//				Pointer to ANSI string destination
//				Pointer to size of ANSI destination
//
// Exit:		Error code:
//				DPNERR_GENERIC = operation failed
//				DPN_OK = operation succeded
//				DPNERR_BUFFERTOOSMALL = destination buffer too small
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "WideToAnsi"

HRESULT	WideToAnsi( const WCHAR *const pWCHARString, const DWORD dwWCHARStringLength, char *const pString, DWORD *const pdwStringLength )
{
	HRESULT	hr;
	int		iReturn;
	BOOL	fDefault;


	DNASSERT( pWCHARString != NULL );
	DNASSERT( pdwStringLength != NULL );
	DNASSERT( ( pString != NULL ) || ( &pdwStringLength == 0 ) );

	hr = DPN_OK;

	fDefault = FALSE;
	iReturn = WideCharToMultiByte( CP_ACP,				// code page (default ANSI)
								   0,					// flags (none)
								   pWCHARString,		// pointer to WCHAR string
								   dwWCHARStringLength,	// size of WCHAR string
								   pString,				// pointer to destination ANSI string
								   *pdwStringLength,	// size of destination string
								   NULL,				// pointer to default for unmappable characters (none)
								   &fDefault			// pointer to flag indicating that default was used
								   );
	if ( iReturn == 0 )
	{
		hr = DPNERR_GENERIC;
	}
	else
	{
		if ( *pdwStringLength == 0 )
		{
			hr = DPNERR_BUFFERTOOSMALL;
		}
		else
		{
			DNASSERT( hr == DPN_OK );
		}

		*pdwStringLength = iReturn;
	}

	//
	// if you hit this ASSERT it's because you've probably got ASCII text as your
	// input WCHAR string.  Double-check your input!!
	//
	DNASSERT( fDefault == FALSE );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ANSIToWide - convert an ANSI string to a wide string
//
// Entry:		Pointer to source multi-byte (ANSI) string
//				Size of source string (-1 imples NULL-terminated)
//				Pointer to multi-byte string destination
//				Pointer to size of multi-byte destination (in WCHAR units)
//
// Exit:		Error code:
//				ERR_FAIL - operation failed
//				ERR_NONE - operation succeded
//				ERR_BUFFER_TOO_SMALL - destination buffer too small
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "AnsiToWide"

HRESULT	AnsiToWide( const char *const pString, const DWORD dwStringLength, WCHAR *const pWCHARString, DWORD *const pdwWCHARStringLength )
{
	HRESULT	hr;
	int		iReturn;


	DNASSERT( pdwWCHARStringLength != 0 );
	DNASSERT( ( pWCHARString != NULL ) || ( pdwWCHARStringLength == 0 ) );
	DNASSERT( pString != NULL );

	hr = DPN_OK;
	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
								   0,						// flags (none)
								   pString,					// pointer to multi-byte string			
								   dwStringLength,			// size of string (assume null-terminated)
								   pWCHARString,			// pointer to destination wide-char string
								   *pdwWCHARStringLength	// size of destination in WCHARs
								   );
	if ( iReturn == 0 )
	{
		hr = DPNERR_GENERIC;
	}
	else
	{
		if ( *pdwWCHARStringLength == 0 )
		{
			hr = DPNERR_BUFFERTOOSMALL;
		}
		else
		{
			DNASSERT( hr == DPN_OK );
		}

		*pdwWCHARStringLength = iReturn;
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateSPData - create instance data for SP
//
// Entry:		Pointer to pointer to SPData
//				Pionter to class GUID
//				Interface type
//				Pointer to COM interface vtable
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateSPData"

HRESULT	CreateSPData( CSPData **const ppSPData,
					  const CLSID *const pClassID,
					  const SP_TYPE SPType,
					  IDP8ServiceProviderVtbl *const pVtbl )
{
	HRESULT	hr;
	CSPData	*pSPData;


	DNASSERT( ppSPData != NULL );
	DNASSERT( pClassID != NULL );
	DNASSERT( pVtbl != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	*ppSPData = NULL;
	pSPData = NULL;

	//
	// create data
	//
	pSPData = new CSPData;
	if ( pSPData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot create data for interface!" );
		goto Failure;
	}
	pSPData->AddRef();

	hr = pSPData->Initialize( pClassID, SPType, pVtbl );
	if ( hr != DPN_OK  )
	{
		DPFX(DPFPREP,  0, "Failed to intialize SP data!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CreateSPData!" );
		DisplayDNError( 0, hr );
	}

	*ppSPData = pSPData;
	
	return	hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GenerateAvailableComPortList - generate a list of available com ports
//
// Entry:		Pointer to list of Booleans to indicate availablility
//				Maximum index of comport to enumerate
//				Pointer to number of com ports found
//
// Exit:		Error code
//
// Note:	This function will fill in indicies 1 through uMaxDeviceIndex.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GenerateAvailableComPortList"

HRESULT	GenerateAvailableComPortList( BOOL *const pfPortAvailable,
									  const UINT_PTR uMaxDeviceIndex,
									  DWORD *const pdwPortCount )
{
	HRESULT		hr;
	UINT_PTR	uIndex;
	UINT_PTR	uPortCount;


	DNASSERT( pfPortAvailable != NULL );
	DNASSERT( uMaxDeviceIndex != 0 );
	DNASSERT( pdwPortCount != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	uPortCount = 0;
	memset( pfPortAvailable, 0x00, ( sizeof( *pfPortAvailable ) * ( uMaxDeviceIndex + 1 ) ) );
	*pdwPortCount = 0;

	//
	// attempt to open all COM ports in the specified range
	//
	uIndex = uMaxDeviceIndex;
	while ( uIndex != 0 )
	{
		HANDLE	hComFile;
		TCHAR	ComTemplate[ (COM_PORT_STRING_LENGTH+1) ];
		DWORD	dwError;


		ComDeviceIDToString( ComTemplate, uIndex );
		hComFile = CreateFile( ComTemplate,						// comm port name
							   GENERIC_READ | GENERIC_WRITE,	// read/write access
							   0,								// don't share file with others
							   NULL,							// default sercurity descriptor
							   OPEN_EXISTING,					// comm port must exist to be opened
							   FILE_FLAG_OVERLAPPED,			// use overlapped I/O
							   NULL								// no handle for template file
							   );
		if ( hComFile == INVALID_HANDLE_VALUE )
		{
			dwError = GetLastError();
			if ( dwError != ERROR_ACCESS_DENIED )
			{
				//
				// Don't bother displaying ERROR_FILE_NOT_FOUND, that's the usual
				// error when you try to open a bogus COM port.
				//
				if ( dwError != ERROR_FILE_NOT_FOUND )
				{
					DPFX(DPFPREP, 9, "Couldn't open COM%u while enumerating com port adapters, err = %u.", uIndex, dwError );
					DisplayErrorCode( 9, dwError );
				}
				
				goto SkipComPort;
			}

			DPFX(DPFPREP, 1, "Couldn't open COM%u, it is probably already in use.", uIndex );

			//
			// Consider the port as possibly available, continue.
			//
		}

		//
		// We found a valid COM port (it may be in use), note which COM port
		// this is and then close our handle
		//
		pfPortAvailable[ uIndex ] = TRUE;
		uPortCount++;

		if ( hComFile != INVALID_HANDLE_VALUE )
		{
			if ( CloseHandle( hComFile ) == FALSE )
			{
				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Problem closing COM%u while enumerating com port adapters, err = %u!",
					uIndex, dwError );
				DisplayErrorCode( 0, dwError );
			}
		}

SkipComPort:
		uIndex--;
	}

	DNASSERT( uPortCount <= UINT32_MAX );
	DBG_CASSERT( sizeof( *pdwPortCount ) == sizeof( DWORD ) );
	*pdwPortCount = static_cast<DWORD>( uPortCount );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::GenerateAvailableModemList - generate list of available modems
//
// Entry:		Pointer to TAPI data
//				Pointer to modem count
//				Pointer to data block
//				Pointer to size of data block
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GenerateAvailableModemList"

HRESULT	GenerateAvailableModemList( const TAPI_INFO *const pTAPIInfo,
									DWORD *const pdwModemCount,
									MODEM_NAME_DATA *const pModemNameData,
									DWORD *const pdwModemNameDataSize )
{
	HRESULT				hr;
	LONG				lLineReturn;
	DWORD				dwDeviceID;
	DWORD				dwDevCapsSize;
	DWORD				dwAPIVersion;
	LINEDEVCAPS			*pDevCaps;
	LINEEXTENSIONID		LineExtensionID;
	DWORD				dwRequiredBufferSize;
	TCHAR				*pOutputModemName;


	DNASSERT( pdwModemCount != NULL );
	DNASSERT( pdwModemNameDataSize != NULL );
	DNASSERT( ( pModemNameData != NULL ) || ( *pdwModemNameDataSize == 0 ) );

	//
	// initialize
	//
	hr = DPN_OK;
	dwRequiredBufferSize = 0;
	*pdwModemCount = 0;
	pDevCaps = NULL;

	if ( pModemNameData != NULL )
	{
		pOutputModemName = &(reinterpret_cast<TCHAR*>( pModemNameData )[ *pdwModemNameDataSize / sizeof(TCHAR) ]);
		memset( pModemNameData, 0x00, *pdwModemNameDataSize );
	}
	else
	{
		pOutputModemName = NULL;
	}

	dwDevCapsSize = g_dwDefaultTAPIDevCapsSize;
	pDevCaps = static_cast<LINEDEVCAPS*>( DNMalloc( dwDevCapsSize ) );
	if ( pDevCaps == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	dwDeviceID = pTAPIInfo->dwLinesAvailable;
	if ( dwDeviceID > ( MAX_DATA_PORTS - 2 ) )
	{
		dwDeviceID = MAX_DATA_PORTS - 2;
		DPFX(DPFPREP,  0, "Truncating to %d devices!", dwDeviceID );
	}

Reloop:
	while ( dwDeviceID != 0 )
	{
		dwDeviceID--;

		memset( &LineExtensionID, 0x00, sizeof( LineExtensionID ) );
		DNASSERT( p_lineNegotiateAPIVersion != NULL );
		lLineReturn = p_lineNegotiateAPIVersion( pTAPIInfo->hApplicationInstance,	// handle to TAPI instance
												 dwDeviceID,						// device ID
												 0,
												 pTAPIInfo->dwVersion,				// maximum TAPI version
												 &dwAPIVersion,						// pointer to negotiated line version
												 &LineExtensionID					// pointer to line extension infromation (none)
												 );
		if ( lLineReturn != LINEERR_NONE )
		{
			//
			// let this slide, just return no name string
			//
			switch ( lLineReturn )
			{
				//
				// this TAPI device isn't up to our standards, ignore it
				//
				case LINEERR_INCOMPATIBLEAPIVERSION:
				{
					DPFX(DPFPREP,  0, "Rejecting TAPI device 0x%x because of API version!", dwDeviceID );
					goto Reloop;

					break;
				}

				//
				// Device is not present.  I don't know what causes
				// this, but I saw it on one of my dev machines after
				// I switched the modem from COM2 to COM1.
				//
				case LINEERR_NODEVICE:
				{
					DPFX(DPFPREP,  0, "Rejecting TAPI device 0x%x because it's not there!", dwDeviceID );
					goto Reloop;
					break;
				}

				//
				// other, stop and see what happened
				//
				default:
				{
					DPFX(DPFPREP,  0, "Problem getting line API version for device: %d", dwDeviceID );
					DisplayTAPIError( 0, lLineReturn );
					DNASSERT( FALSE );
					goto Reloop;

					break;
				}
			}
		}

		//
		// ask for device caps
		//
		pDevCaps->dwTotalSize = dwDevCapsSize;
		pDevCaps->dwNeededSize = dwDevCapsSize;
		lLineReturn = LINEERR_STRUCTURETOOSMALL;

		while ( lLineReturn == LINEERR_STRUCTURETOOSMALL )
		{
			void	*pTemp;


			dwDevCapsSize = pDevCaps->dwNeededSize;
			pTemp = DNRealloc( pDevCaps, dwDevCapsSize );
			if ( pTemp == NULL )
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "GetAvailableModemList: Failed to realloc memory on device %d!", dwDeviceID );
				goto Failure;
			}

			pDevCaps = static_cast<LINEDEVCAPS*>( pTemp );
			pDevCaps->dwTotalSize = dwDevCapsSize;
			pDevCaps->dwNeededSize = 0;

			DNASSERT( p_lineGetDevCaps != NULL );
			lLineReturn = p_lineGetDevCaps( pTAPIInfo->hApplicationInstance,	// TAPI instance handle
											dwDeviceID,							// TAPI device ID
											dwAPIVersion,						// negotiated API version
											0,									// extended data version (none)
											pDevCaps							// pointer to device caps data
											);
			//
			// TAPI lies about structures being too small!
			// Double check the structure size ourselves.
			//
			if ( pDevCaps->dwNeededSize > dwDevCapsSize )
			{
				lLineReturn = LINEERR_STRUCTURETOOSMALL;
			}
		}

		//
		// If caps have been gotten, process them.  Otherwise skip this device.
		//
		if ( lLineReturn == LINEERR_NONE )
		{
			//
			// is this really a modem?
			//
			if ( ( pDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM ) != 0 )
			{
				//
				// is this the modem name information accerptable?
				//
				if ( ( pDevCaps->dwLineNameSize != 0 ) &&
					 ( pDevCaps->dwLineNameOffset != 0 ) )
				{
					//
					// get the name of the device
					//
					DBG_CASSERT( sizeof( pDevCaps ) == sizeof( char* ) );
					DWORD dwSize;
					switch (pDevCaps->dwStringFormat)
					{
						case STRINGFORMAT_ASCII:
						{
							char* pLineName;
							pLineName = &( reinterpret_cast<char*>( pDevCaps )[ pDevCaps->dwLineNameOffset ] );
							//
							// Note the required storage size and only copy it to the output
							// if there's enough room.  TAPI drivers are inconsistent.  Some
							// drivers return NULL terminated strings and others return strings
							// with no NULL termination.  Be paranoid and reserve space for an
							// extra NULL for termination so we can always guarantee termination.
							// This may waste a byte or two, but the user will never notice.
							//
							dwRequiredBufferSize += sizeof( *pModemNameData ) + (pDevCaps->dwLineNameSize * sizeof(TCHAR)) + sizeof( g_NullToken );
							if ( dwRequiredBufferSize <= *pdwModemNameDataSize )
							{
								pModemNameData[ *pdwModemCount ].dwModemID = ModemIDFromTAPIID( dwDeviceID );
								pModemNameData[ *pdwModemCount ].dwModemNameSize = pDevCaps->dwLineNameSize * sizeof(TCHAR);

								pOutputModemName = &pOutputModemName[ - (static_cast<INT_PTR>( ((pDevCaps->dwLineNameSize * sizeof(TCHAR)) + sizeof( g_NullToken ) ) / sizeof(TCHAR))) ];
#ifndef UNICODE
								memcpy( pOutputModemName, pLineName, pDevCaps->dwLineNameSize );
#else
								dwSize = pDevCaps->dwLineNameSize * sizeof(TCHAR);
								AnsiToWide(pLineName, pDevCaps->dwLineNameSize, pOutputModemName, &dwSize);
#endif
								pModemNameData[ *pdwModemCount ].pModemName = pOutputModemName;

								//
								// Be paranoid about NULL termination.  We've accounted for enough
								// space to add a terminating NULL to the TAPI device name if one
								// wasn't provided.
								//
								if ( pOutputModemName[ ((pDevCaps->dwLineNameSize * sizeof(TCHAR)) - sizeof( g_NullToken )) / sizeof(TCHAR) ] != g_NullToken )
								{
									pOutputModemName[ pDevCaps->dwLineNameSize ] = g_NullToken;
									pModemNameData[ *pdwModemCount ].dwModemNameSize += sizeof( g_NullToken );
								}
							}
							else
							{
								//
								// Note that the output buffer is too small, but still keep
								// processing modem names.
								//
								hr = DPNERR_BUFFERTOOSMALL;
							}

							(*pdwModemCount)++;
							DPFX(DPFPREP,  2, "Accepting modem device: 0x%x (ASCII)", dwDeviceID );
						}
						break;
						
						case STRINGFORMAT_UNICODE:
						{
							WCHAR* pLineName;
							pLineName = &( reinterpret_cast<WCHAR*>( pDevCaps )[ pDevCaps->dwLineNameOffset / sizeof(WCHAR)] );
							//
							// Note the required storage size and only copy it to the output
							// if there's enough room.  TAPI drivers are inconsistent.  Some
							// drivers return NULL terminated strings and others return strings
							// with no NULL termination.  Be paranoid and reserve space for an
							// extra NULL for termination so we can always guarantee termination.
							// This may waste a byte or two, but the user will never notice.
							//
							dwRequiredBufferSize += sizeof( *pModemNameData ) + ((pDevCaps->dwLineNameSize * sizeof(TCHAR)) / sizeof(WCHAR)) + sizeof( g_NullToken );
							if ( dwRequiredBufferSize <= *pdwModemNameDataSize )
							{
								pModemNameData[ *pdwModemCount ].dwModemID = ModemIDFromTAPIID( dwDeviceID );
								pModemNameData[ *pdwModemCount ].dwModemNameSize = pDevCaps->dwLineNameSize * (sizeof(TCHAR) / sizeof(WCHAR));

								pOutputModemName = &pOutputModemName[ - (static_cast<INT_PTR>( (((pDevCaps->dwLineNameSize * sizeof(TCHAR)) / sizeof(WCHAR)) + sizeof( g_NullToken ) ) / sizeof(TCHAR))) ];
#ifdef UNICODE
								memcpy( pOutputModemName, pLineName, pDevCaps->dwLineNameSize );
#else
								dwSize = pDevCaps->dwLineNameSize / sizeof(TCHAR);
								WideToAnsi(pLineName, pDevCaps->dwLineNameSize / sizeof(WCHAR), pOutputModemName, &dwSize);
#endif
								pModemNameData[ *pdwModemCount ].pModemName = pOutputModemName;

								//
								// Be paranoid about NULL termination.  We've accounted for enough
								// space to add a terminating NULL to the TAPI device name if one
								// wasn't provided.
								//
								if ( pOutputModemName[ (((pDevCaps->dwLineNameSize*sizeof(TCHAR))/sizeof(WCHAR)) - sizeof( g_NullToken )) / sizeof(TCHAR) ] != g_NullToken )
								{
									pOutputModemName[ pDevCaps->dwLineNameSize / sizeof(WCHAR) ] = g_NullToken;
									pModemNameData[ *pdwModemCount ].dwModemNameSize += sizeof( g_NullToken );
								}
							}
							else
							{
								//
								// Note that the output buffer is too small, but still keep
								// processing modem names.
								//
								hr = DPNERR_BUFFERTOOSMALL;
							}

							(*pdwModemCount)++;
							DPFX(DPFPREP,  2, "Accepting modem device: 0x%x (Unicode)", dwDeviceID );
						}
						break;

						default:
						{
							hr = DPNERR_GENERIC;
							DPFX(DPFPREP,  0, "Problem with modem name for device: 0x%x!", dwDeviceID );
							DNASSERT( FALSE );
						}
					}
				}
				else
				{
					hr = DPNERR_GENERIC;
					DPFX(DPFPREP,  0, "Problem with modem name for device: 0x%x!", dwDeviceID );
					DNASSERT( FALSE );
				}
			}
			else
			{
				DPFX(DPFPREP,  1, "Ignoring non-datamodem device: 0x%x", dwDeviceID );
			}
		}
		else
		{
			DPFX(DPFPREP,  0, "Failed to get device caps.  Ignoring device: 0x%x", dwDeviceID );
		}
	}

	*pdwModemNameDataSize = dwRequiredBufferSize;

Exit:
	if ( pDevCaps != NULL )
	{
		DNFree( pDevCaps );
		pDevCaps = NULL;
	}

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// PhoneNumberToWCHAR - convert a phone number to WCHAR
//
// Entry:		Pointer to phone number
//				Pointer to WCHAR destination
//				Pointer to size of WCHAR destintion
//
// Exit:		Error code
// ------------------------------
#ifndef UNICODE
HRESULT	PhoneNumberToWCHAR( const char *const pPhoneNumber,
							WCHAR *const pWCHARPhoneNumber,
							DWORD *const pdwWCHARPhoneNumberSize )
{
	HRESULT		hr;
	char		*pOutput;
	DWORD		dwInputIndex;	
	DWORD		dwOutputIndex;

	
	DNASSERT( pPhoneNumber != NULL );
	DNASSERT( pWCHARPhoneNumber != NULL );
	DNASSERT( pdwWCHARPhoneNumberSize != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pOutput = reinterpret_cast<char*>( pWCHARPhoneNumber );
	dwInputIndex = 0;
	dwOutputIndex = 0;
	memset( pWCHARPhoneNumber, 0, ( (*pdwWCHARPhoneNumberSize) * sizeof( *pWCHARPhoneNumber ) ) );

	while ( pPhoneNumber[ dwInputIndex ] != '\0' )
	{
		if ( dwInputIndex < ( *pdwWCHARPhoneNumberSize ) )
		{
			pOutput[ dwOutputIndex ] = pPhoneNumber[ dwInputIndex ];
		}
	
		dwOutputIndex += sizeof( *pWCHARPhoneNumber );
		dwInputIndex += sizeof( *pPhoneNumber );
	}
	
	*pdwWCHARPhoneNumberSize = dwInputIndex + 1;

	return	hr;
}
#endif
//**********************************************************************


//**********************************************************************
// ------------------------------
// PhoneNumberFromWCHAR - convert a phone number from WCHAR
//
// Entry:		Pointer to WCHAR phone number
//				Pointer to phone number destination
//				Pointer to phone destination size
//
// Exit:		Error code
// ------------------------------
#ifndef UNICODE
HRESULT	PhoneNumberFromWCHAR( const WCHAR *const pWCHARPhoneNumber,
							  char *const pPhoneNumber,
							  DWORD *const pdwPhoneNumberSize )
{
	HRESULT	hr;
	const char	*pInput;
	DWORD		dwInputIndex;
	DWORD		dwOutputIndex;

	
	DNASSERT( pWCHARPhoneNumber != NULL );
	DNASSERT( pPhoneNumber != NULL );
	DNASSERT( pdwPhoneNumberSize != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pInput = reinterpret_cast<const char*>( pWCHARPhoneNumber );
	dwInputIndex = 0;
	dwOutputIndex = 0;
	memset( pPhoneNumber, 0x00, *pdwPhoneNumberSize );

	while ( pInput[ dwInputIndex ] != '\0' )
	{
		if ( dwOutputIndex < *pdwPhoneNumberSize )
		{
			pPhoneNumber[ dwOutputIndex ] = pInput[ dwInputIndex ];
		}
		
		dwInputIndex += sizeof( *pWCHARPhoneNumber );
		dwOutputIndex += sizeof( *pPhoneNumber );
	}

	*pdwPhoneNumberSize = dwOutputIndex + 1;
	
	return	hr;
}
#endif
//**********************************************************************


//**********************************************************************
// ------------------------------
// EncryptGuid - encrypt a guid
//
// Entry:		Pointer to source guid
//				Pointer to destination guid
//				Pointer to encryption key
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "EncryptGuid"

void	EncryptGuid( const GUID *const pSourceGuid,
					 GUID *const pDestinationGuid,
					 const GUID *const pEncryptionKey )
{
	const char	*pSourceBytes;
	char		*pDestinationBytes;
	const char	*pEncryptionBytes;
	DWORD_PTR	dwIndex;


	DNASSERT( pSourceGuid != NULL );
	DNASSERT( pDestinationGuid != NULL );
	DNASSERT( pEncryptionKey != NULL );

	DBG_CASSERT( sizeof( pSourceBytes ) == sizeof( pSourceGuid ) );
	pSourceBytes = reinterpret_cast<const char*>( pSourceGuid );
	
	DBG_CASSERT( sizeof( pDestinationBytes ) == sizeof( pDestinationGuid ) );
	pDestinationBytes = reinterpret_cast<char*>( pDestinationGuid );
	
	DBG_CASSERT( sizeof( pEncryptionBytes ) == sizeof( pEncryptionKey ) );
	pEncryptionBytes = reinterpret_cast<const char*>( pEncryptionKey );
	
	DBG_CASSERT( ( sizeof( *pSourceGuid ) == sizeof( *pEncryptionKey ) ) &&
				 ( sizeof( *pDestinationGuid ) == sizeof( *pEncryptionKey ) ) );
	dwIndex = sizeof( *pSourceGuid );
	while ( dwIndex != 0 )
	{
		dwIndex--;
		pDestinationBytes[ dwIndex ] = pSourceBytes[ dwIndex ] ^ pEncryptionBytes[ dwIndex ];
	}
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\modemendpoint.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ModemEndpoint.cpp
 *  Content:	DNSerial communications endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DEFAULT_TAPI_DEV_CAPS_SIZE	1024

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::CModemEndpoint - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::CModemEndpoint"

CModemEndpoint::CModemEndpoint():
	m_pOwningPool( NULL ),
	m_dwDeviceID( INVALID_DEVICE_ID )
{
	m_Sig[0] = 'M';
	m_Sig[1] = 'O';
	m_Sig[2] = 'E';
	m_Sig[3] = 'P';
	
	memset( &m_PhoneNumber, 0x00, sizeof( m_PhoneNumber ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::~CModemEndpoint - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::~CModemEndpoint"

CModemEndpoint::~CModemEndpoint()
{
	DNASSERT( m_pOwningPool == NULL );
	DNASSERT( m_dwDeviceID == INVALID_DEVICE_ID );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ReturnSelfToPool"

void	CModemEndpoint::ReturnSelfToPool( void )
{
	if ( m_Flags.fCommandPending != FALSE )
	{
		CompletePendingCommand( PendingCommandResult() );
	}

	if ( m_Flags.fConnectIndicated != FALSE )
	{
		SignalDisconnect( GetDisconnectIndicationHandle() );
	}
	
	DNASSERT( m_Flags.fConnectIndicated == FALSE );

	memset( m_PhoneNumber, 0x00, sizeof( m_PhoneNumber ) );
	
	SetUserEndpointContext( NULL );
	
	DNASSERT( m_pOwningPool != NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::Open - open communications with endpoint
//
// Entry:		Pointer to host address
//				Pointer to adapter address
//				Link direction
//				Endpoint type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::Open"

HRESULT CModemEndpoint::Open( IDirectPlay8Address *const pHostAddress,
							  IDirectPlay8Address *const pAdapterAddress,
							  const LINK_DIRECTION LinkDirection,
							  const ENDPOINT_TYPE EndpointType )
{
	HRESULT		hr;
	HRESULT		hDeviceResult;
	GUID		ModemDeviceGuid;


	DNASSERT( pAdapterAddress != NULL );

	DNASSERT( ( LinkDirection == LINK_DIRECTION_INCOMING ) ||
			  ( LinkDirection == LINK_DIRECTION_OUTGOING ) );
	DNASSERT( ( EndpointType == ENDPOINT_TYPE_CONNECT ) ||
			  ( EndpointType == ENDPOINT_TYPE_ENUM ) ||
			  ( EndpointType == ENDPOINT_TYPE_LISTEN ) ||
			  ( EndpointType == ENDPOINT_TYPE_CONNECT_ON_LISTEN ) );
	DNASSERT( ( ( pHostAddress != NULL ) && ( LinkDirection == LINK_DIRECTION_OUTGOING ) ) ||
			  ( ( pHostAddress == NULL ) && ( LinkDirection == LINK_DIRECTION_INCOMING ) ) );

	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( lstrlen( m_PhoneNumber ) == 0 );
	DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );

	hDeviceResult = IDirectPlay8Address_GetDevice( pAdapterAddress, &ModemDeviceGuid );
	switch ( hDeviceResult )
	{
		case DPN_OK:
		{
			SetDeviceID( GuidToDeviceID( &ModemDeviceGuid, &g_ModemSPEncryptionGuid ) );
			break;
		}

		case DPNERR_DOESNOTEXIST:
		{
			DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );
			break;
		}

		default:
		{
			hr = hDeviceResult;
			DPFX(DPFPREP,  0, "Failed to get modem device!" );
			DisplayDNError( 0, hr);
			goto Failure;
		}
	}

	if ( LinkDirection == LINK_DIRECTION_OUTGOING )
	{
		HRESULT		hPhoneNumberResult;
		DWORD		dwWCHARPhoneNumberSize;
		DWORD		dwDataType;
		WCHAR		PhoneNumber[ sizeof( m_PhoneNumber ) ];


		dwWCHARPhoneNumberSize = LENGTHOF( PhoneNumber );
		hPhoneNumberResult = IDirectPlay8Address_GetComponentByName( pHostAddress,
																	 DPNA_KEY_PHONENUMBER,
																	 PhoneNumber,
																	 &dwWCHARPhoneNumberSize,
																	 &dwDataType );
		switch ( hPhoneNumberResult )
		{
			case DPN_OK:
			{
#ifdef UNICODE
				lstrcpy(m_PhoneNumber, PhoneNumber);
#else
				DWORD	dwASCIIPhoneNumberSize;

				//
				// can't use the STR_ functions to convert ANSI to WIDE phone
				// numbers because phone numbers with symbols: "9,", "*70" are
				// interpreted as already being WCHAR when they're not!
				//
				dwASCIIPhoneNumberSize = sizeof( m_PhoneNumber );
				DNASSERT( dwDataType == DPNA_DATATYPE_STRING );
				hr = PhoneNumberFromWCHAR( PhoneNumber, m_PhoneNumber, &dwASCIIPhoneNumberSize );
				DNASSERT( hr == DPN_OK );
#endif

				break;
			}

			case DPNERR_DOESNOTEXIST:
			{
				break;
			}

			default:
			{
				hr = hPhoneNumberResult;
				DPFX(DPFPREP,  0, "Failed to process phone number!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}
		}
	}

	if ( ( GetDeviceID() == INVALID_DEVICE_ID ) ||
		 ( ( LinkDirection == LINK_DIRECTION_OUTGOING ) && ( lstrlen( m_PhoneNumber ) == 0 ) ) )
	{
		hr = DPNERR_INCOMPLETEADDRESS;
		goto Failure;
	}


Exit:
	SetType( EndpointType );

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CModemEndpoint::Open" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::OpenOnListen - open this endpoint when data is received on a listen
//
// Entry:		Nothing
//
// Exit:		Noting
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::OpenOnListen"

HRESULT	CModemEndpoint::OpenOnListen( const CEndpoint *const pListenEndpoint )
{
	HRESULT	hr;


	DNASSERT( pListenEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	SetDeviceID( pListenEndpoint->GetDeviceID() );
	SetType( ENDPOINT_TYPE_CONNECT_ON_LISTEN );
	SetState( ENDPOINT_STATE_ATTEMPTING_CONNECT );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::Close - close this endpoint
//
// Entry:		Nothing
//
// Exit:		Noting
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::Close"

void	CModemEndpoint::Close( const HRESULT hActiveCommandResult )
{
	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%lx)", this, hActiveCommandResult);

	
	//
	// Set the command result so it can be returned when the endpoint reference
	// count is zero.
	//
	SetCommandResult( hActiveCommandResult );


	DPFX(DPFPREP, 6, "(0x%p) Leaving", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::EnumComplete - enumeration has completed
//
// Entry:		Command completion code
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::EnumComplete"

void	CModemEndpoint::EnumComplete( const HRESULT hCommandResult )
{
	Close( hCommandResult );
	m_pSPData->CloseEndpointHandle( this );
	m_dwEnumSendIndex = 0;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::GetDeviceContext - get device context to initialize data port
//
// Entry:		Nothing
//
// Exit:		Device context
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::GetDeviceContext"

const void	*CModemEndpoint::GetDeviceContext( void ) const
{
	return	NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::GetRemoteHostDP8Address - get address of remote host
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::GetRemoteHostDP8Address"

IDirectPlay8Address	*CModemEndpoint::GetRemoteHostDP8Address( void ) const
{
	IDirectPlay8Address	*pAddress;
	HRESULT	hr;


	//
	// initialize
	//
	pAddress = NULL;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_IDirectPlay8Address,
							   reinterpret_cast<void**>( &pAddress ) );
	if ( hr != DPN_OK )
	{
		DNASSERT( pAddress == NULL );
		DPFX(DPFPREP,  0, "GetRemoteHostDP8Address: Failed to create Address when converting data port to address!" );
		goto Failure;
	}

	//
	// set the SP guid
	//
	hr = IDirectPlay8Address_SetSP( pAddress, &CLSID_DP8SP_MODEM );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "GetRemoteHostDP8Address: Failed to set service provider GUID!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// Host names can only be returned for connect and enum endpoints.  Host
	// names are the phone numbers that were called and will be unknown on a
	// 'listen' endpoint.
	//
	switch ( GetType() )
	{
		case ENDPOINT_TYPE_ENUM:
		case ENDPOINT_TYPE_CONNECT:
		{
			DWORD	dwPhoneNumberLength;


			dwPhoneNumberLength = lstrlen( m_PhoneNumber );
			if ( dwPhoneNumberLength != 0 )
			{
#ifdef UNICODE
				hr = IDirectPlay8Address_AddComponent( pAddress,
													   DPNA_KEY_PHONENUMBER,
													   m_PhoneNumber,
													   (dwPhoneNumberLength + 1) * sizeof( *m_PhoneNumber ),
													   DPNA_DATATYPE_STRING );
#else
				WCHAR	WCHARPhoneNumber[ sizeof( m_PhoneNumber ) ];
				DWORD	dwWCHARPhoneNumberLength;

				//
				// can't use the STR_ functions to convert ANSI to WIDE phone
				// numbers because phone numbers with symbols: "9,", "*70" are
				// interpreted as already being WCHAR when they're not!
				//
				dwWCHARPhoneNumberLength = LENGTHOF( WCHARPhoneNumber );
				hr = PhoneNumberToWCHAR( m_PhoneNumber, WCHARPhoneNumber, &dwWCHARPhoneNumberLength );
				DNASSERT( hr == DPN_OK );

				hr = IDirectPlay8Address_AddComponent( pAddress,
													   DPNA_KEY_PHONENUMBER,
													   WCHARPhoneNumber,
													   dwWCHARPhoneNumberLength * sizeof( *WCHARPhoneNumber ),
													   DPNA_DATATYPE_STRING );
#endif
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP,  0, "GetRemoteHostDP8Address: Failed to add phone number to hostname!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}
			}
			
			break;
		}

		case ENDPOINT_TYPE_LISTEN:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}

	}

Exit:
	return	pAddress;

Failure:
	if ( pAddress != NULL )
	{
		IDirectPlay8Address_Release( pAddress );
		pAddress = NULL;
	}
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::GetLocalAdapterDP8Address - get address from local adapter
//
// Entry:		Adadpter address format
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::GetLocalAdapterDP8Address"

IDirectPlay8Address	*CModemEndpoint::GetLocalAdapterDP8Address( const ADDRESS_TYPE AddressType ) const
{
	CModemPort	*pModemPort;

	
	DNASSERT( GetDataPort() != NULL );
	pModemPort = static_cast<CModemPort*>( GetDataPort() );
	return	pModemPort->GetLocalAdapterDP8Address( AddressType );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::ShowIncomingSettingsDialog - show dialog for incoming modem settings
//
// Entry:		Pointer to thread pool
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ShowIncomingSettingsDialog"

HRESULT	CModemEndpoint::ShowIncomingSettingsDialog( CThreadPool *const pThreadPool )
{
	HRESULT	hr;


	DNASSERT( pThreadPool != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	AddRef();
	hr = pThreadPool->SpawnDialogThread( DisplayIncomingModemSettingsDialog, this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to start incoming modem dialog!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:	
	return	hr;

Failure:	
	DecRef();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::ShowOutgoingSettingsDialog - show settings dialog for outgoing
//		modem connection
//
// Entry:		Pointer to thread pool
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::ShowOutgoingSettingsDialog"

HRESULT	CModemEndpoint::ShowOutgoingSettingsDialog( CThreadPool *const pThreadPool )
{
	HRESULT	hr;


	DNASSERT( pThreadPool != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	AddRef();
	hr = pThreadPool->SpawnDialogThread( DisplayOutgoingModemSettingsDialog, this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to start incoming modem dialog!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:	
	return	hr;

Failure:	
	DecRef();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::StopSettingsDialog - stop a settings dialog
//
// Entry:		Dialog handle
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::StopSettingsDialog"

void	CModemEndpoint::StopSettingsDialog( const HWND hDialog )
{
	StopModemSettingsDialog( hDialog );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::PoolAllocFunction - function called when item is created in pool
//
// Entry:		Pointer to pool context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::PoolAllocFunction"

BOOL	CModemEndpoint::PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pPoolContext )
{
	BOOL	fReturn;
	HRESULT	hTempResult;


	DNASSERT( pPoolContext != NULL );
	DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	
	fReturn = TRUE;

	//
	// initialize base objet
	//
	hTempResult = CEndpoint::Initialize( pPoolContext->pSPData );
	if ( hTempResult != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to initialize base endpoint class!" );
		DisplayDNError( 0, hTempResult );
		fReturn = FALSE;
	}
	
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::PoolInitFunction - function called when item is created in pool
//
// Entry:		Pointer to pool context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::PoolInitFunction"

BOOL	CModemEndpoint::PoolInitFunction( ENDPOINT_POOL_CONTEXT *pPoolContext )
{
	BOOL	fReturn;


	DNASSERT( pPoolContext != NULL );
	DNASSERT( m_pSPData == NULL );
	DNASSERT( GetState() == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( GetType() == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );

	//
	// initialize
	//
	fReturn = TRUE;
	
	m_pSPData = pPoolContext->pSPData;
	m_pSPData->ObjectAddRef();

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::PoolReleaseFunction - function called when returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::PoolReleaseFunction"

void	CModemEndpoint::PoolReleaseFunction( void )
{
	CSPData	*pSPData;


	//
	// deinitialize base object
	//
	DNASSERT( m_pSPData != NULL );
	pSPData = m_pSPData;
	m_pSPData = NULL;

	SetType( ENDPOINT_TYPE_UNKNOWN );
	SetState( ENDPOINT_STATE_UNINITIALIZED );
	SetDeviceID( INVALID_DEVICE_ID );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );

	DNASSERT( m_Flags.fConnectIndicated == FALSE );
	DNASSERT( m_Flags.fCommandPending == FALSE );
	DNASSERT( m_Flags.fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( m_pCommandHandle == NULL );
	DNASSERT( m_hActiveDialogHandle == NULL );

	pSPData->ObjectDecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemEndpoint::PoolDeallocFunction - function called when deleted from pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemEndpoint::PoolDeallocFunction"

void	CModemEndpoint::PoolDeallocFunction( void )
{
	CEndpoint::Deinitialize();
	DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( m_pSPData == NULL );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\modemport.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ModemPort.cpp
 *  Content:	Serial communications modem management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// modem state flags
//
#define	STATE_FLAG_CONNECTED					0x00000001
#define	STATE_FLAG_OUTGOING_CALL_DIALING		0x00000002
#define	STATE_FLAG_OUTGOING_CALL_PROCEEDING		0x00000004
#define	STATE_FLAG_INCOMING_CALL_NOTIFICATION	0x00000008
#define	STATE_FLAG_INCOMING_CALL_OFFERED		0x00000010
#define	STATE_FLAG_INCOMING_CALL_ACCEPTED		0x00000020

//
// default size of buffers when parsing
//
#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::CModemPort - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::CModemPort"

CModemPort::CModemPort():
	m_pOwningPool( NULL ),
	m_ModemState( MODEM_STATE_UNKNOWN ),
	m_dwDeviceID( INVALID_DEVICE_ID ),
	m_dwNegotiatedAPIVersion( 0 ),
	m_hLine( NULL ),
	m_hCall( NULL ),
	m_lActiveLineCommand( INVALID_TAPI_COMMAND )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::~CModemPort - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::~CModemPort"

CModemPort::~CModemPort()
{
	DNASSERT( m_pOwningPool == NULL );
	DNASSERT( GetState() == MODEM_STATE_UNKNOWN );
	DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( GetNegotiatedAPIVersion() == 0 );
	DNASSERT( GetLineHandle() == NULL );
	DNASSERT( GetCallHandle() == NULL );
	DNASSERT( GetActiveLineCommand() == INVALID_TAPI_COMMAND );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::ReturnSelfToPool"

void	CModemPort::ReturnSelfToPool( void )
{
	DNASSERT( m_pOwningPool != NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::EnumAdapters - enumerate adapters
//
// Entry:		Pointer to enum adapters data
//				
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::EnumAdapters"

HRESULT	CModemPort::EnumAdapters( SPENUMADAPTERSDATA *const pEnumAdaptersData ) const
{
	HRESULT			hr;
	HRESULT			hTempResult;
	DWORD			dwRequiredSize;
	DWORD			dwDetectedTAPIDeviceCount;
	DWORD			dwModemNameDataSize;
	MODEM_NAME_DATA	*pModemNameData;
	UINT_PTR		uIndex;
	WCHAR			*pOutputName;
	DWORD			dwRemainingStringSize;
	DWORD			dwConvertedStringSize;


	DNASSERT( pEnumAdaptersData != NULL );
	DNASSERT( ( pEnumAdaptersData->pAdapterData != NULL ) || ( pEnumAdaptersData->dwAdapterDataSize == 0 ) );

	//
	// initialize
	//
	hr = DPN_OK;
	dwRequiredSize = 0;
	dwModemNameDataSize = 0;
	pModemNameData = NULL;
	pEnumAdaptersData->dwAdapterCount = 0;

	hr = GenerateAvailableModemList( GetSPData()->GetThreadPool()->GetTAPIInfo(),
									 &dwDetectedTAPIDeviceCount,
									 pModemNameData,
									 &dwModemNameDataSize );
	switch ( hr )
	{
		//
		// there are no modems!
		//
		case DPN_OK:
		{
			goto Exit;
			break;
		}

		//
		// buffer was too small (expected return), keep processing
		//
		case DPNERR_BUFFERTOOSMALL:
		{
			break;
		}

		//
		// other
		//
		default:
		{
			DPFX(DPFPREP,  0, "EnumAdapters: Failed to enumerate modems!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

	pModemNameData = static_cast<MODEM_NAME_DATA*>( DNMalloc( dwModemNameDataSize ) );
	if ( pModemNameData == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to allocate temp buffer to enumerate modems!" );
		DisplayDNError( 0, hr );
	}

	hr = GenerateAvailableModemList( GetSPData()->GetThreadPool()->GetTAPIInfo(),
									 &dwDetectedTAPIDeviceCount,
									 pModemNameData,
									 &dwModemNameDataSize );
	DNASSERT( hr == DPN_OK );

	//
	// compute required size, check for the need to add 'all adapters'
	//
	dwRequiredSize += sizeof( *pEnumAdaptersData->pAdapterData ) * dwDetectedTAPIDeviceCount;

	uIndex = dwDetectedTAPIDeviceCount;
	while ( uIndex != 0 )
	{
		uIndex--;

		//
		// account for unicode conversion
		//
		dwRequiredSize += pModemNameData[ uIndex ].dwModemNameSize * ( sizeof( *pEnumAdaptersData->pAdapterData->pwszName ) / sizeof( *pModemNameData[ uIndex ].pModemName ) );
	}

	//
	// check required size
	//
	if ( pEnumAdaptersData->dwAdapterDataSize < dwRequiredSize )
	{
		pEnumAdaptersData->dwAdapterDataSize = dwRequiredSize;
		hr = DPNERR_BUFFERTOOSMALL;
		DPFX(DPFPREP,  0, "EnumAdapters: Insufficient buffer to enumerate adapters!" );
		goto Failure;
	}

	//
	// copy information into user buffer
	//
	DEBUG_ONLY( memset( pEnumAdaptersData->pAdapterData, 0xAA, dwRequiredSize ) );
	DBG_CASSERT( sizeof( pOutputName ) == sizeof( &pEnumAdaptersData->pAdapterData[ dwDetectedTAPIDeviceCount ] ) );
	pOutputName = reinterpret_cast<WCHAR*>( &pEnumAdaptersData->pAdapterData[ dwDetectedTAPIDeviceCount ] );

	//
	// compute number of WCHAR characters we have remaining in the buffer to output
	// devices names into
	//
	dwRemainingStringSize = dwRequiredSize;
	dwRemainingStringSize -= ( sizeof( *pEnumAdaptersData->pAdapterData ) * dwDetectedTAPIDeviceCount );
	dwRemainingStringSize /= sizeof( *pEnumAdaptersData->pAdapterData->pwszName );

	uIndex = dwDetectedTAPIDeviceCount;
	while ( uIndex > 0 )
	{
		uIndex--;

		pEnumAdaptersData->pAdapterData[ uIndex ].dwFlags = 0;
		pEnumAdaptersData->pAdapterData[ uIndex ].pwszName = pOutputName;
		pEnumAdaptersData->pAdapterData[ uIndex ].dwReserved = 0;
		pEnumAdaptersData->pAdapterData[ uIndex ].pvReserved = NULL;

		DeviceIDToGuid( &pEnumAdaptersData->pAdapterData[ uIndex ].guid,
						pModemNameData[ uIndex ].dwModemID,
						&g_ModemSPEncryptionGuid );

		dwConvertedStringSize = dwRemainingStringSize;
#ifdef UNICODE
		wcscpy(pOutputName, pModemNameData[ uIndex ].pModemName);
		dwConvertedStringSize = wcslen(pOutputName) + 1;
#else
		hTempResult = AnsiToWide( pModemNameData[ uIndex ].pModemName, -1, pOutputName, &dwConvertedStringSize );
		DNASSERT( hTempResult == DPN_OK );
		DNASSERT( dwConvertedStringSize <= dwRemainingStringSize );
#endif
		dwRemainingStringSize -= dwConvertedStringSize;
		pOutputName = &pOutputName[ dwConvertedStringSize ];
	}

	pEnumAdaptersData->dwAdapterCount = dwDetectedTAPIDeviceCount;
	pEnumAdaptersData->dwAdapterDataSize = dwRequiredSize;

Exit:
	if ( pModemNameData != NULL )
	{
		DNFree( pModemNameData );
		pModemNameData = NULL;
	}
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::GetLocalAdapterDP8Address - get the IDirectPlay8 address for this
//		adapter
//
// Entry:		Adapter type
//				
// Exit:		Pointer to address (may be null)
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::GetLocalAdapterDP8Address"

IDirectPlay8Address	*CModemPort::GetLocalAdapterDP8Address( const ADDRESS_TYPE AddressType ) const
{
	IDirectPlay8Address	*pAddress;
	HRESULT	hr;


	DNASSERT ( ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER ) ||
			   ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER_HOST_FORMAT ) );


	//
	// initialize
	//
	pAddress = NULL;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_IDirectPlay8Address,
							   reinterpret_cast<void**>( &pAddress ) );
	if ( hr != DPN_OK )
	{
		DNASSERT( pAddress == NULL );
		DPFX(DPFPREP,  0, "GetLocalAdapterDP8Address: Failed to create Address when converting data port to address!" );
		goto Failure;
	}

	//
	// set the SP guid
	//
	hr = IDirectPlay8Address_SetSP( pAddress, &CLSID_DP8SP_MODEM );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "GetLocalAdapterDP8Address: Failed to set service provider GUID!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// If this machine is in host form, return nothing because there isn't a
	// local phone number associated with this modem.  Otherwise returnt the
	// device GUID.
	//
	if ( AddressType == ADDRESS_TYPE_LOCAL_ADAPTER )
	{
		GUID	DeviceGuid;


		DeviceIDToGuid( &DeviceGuid, GetDeviceID(), &g_ModemSPEncryptionGuid );
		hr = IDirectPlay8Address_SetDevice( pAddress, &DeviceGuid );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "GetLocalAdapterDP8Address: Failed to add device GUID!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}

Exit:
	return	pAddress;

Failure:
	if ( pAddress != NULL )
	{
		IDirectPlay8Address_Release( pAddress );
		pAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::BindToNetwork - bind this data port to the network
//
// Entry:		Device ID
//				Pointer to device context
//				
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::BindToNetwork"

HRESULT	CModemPort::BindToNetwork( const DWORD dwDeviceID, const void *const pDeviceContext )
{
	HRESULT			hr;
	LONG			lTapiReturn;
	const TAPI_INFO	*pTapiInfo;
	LINEEXTENSIONID	LineExtensionID;


	DNASSERT( pDeviceContext == NULL );
	DNASSERT( GetModemState() == MODEM_STATE_UNKNOWN );

	//
	// initialize
	//
	hr = DPN_OK;
	hr = SetDeviceID( dwDeviceID );
	DNASSERT( hr == DPN_OK );
	pTapiInfo = GetSPData()->GetThreadPool()->GetTAPIInfo();
	DNASSERT( pTapiInfo != NULL );
	memset( &LineExtensionID, 0x00, sizeof( LineExtensionID ) );

	//
	// grab the modem
	//
	DNASSERT( GetNegotiatedAPIVersion() == 0 );
	DPFX(DPFPREP,  5, "lineNegotiateAPIVersion" );
	lTapiReturn = p_lineNegotiateAPIVersion( pTapiInfo->hApplicationInstance,		// TAPI application instance
											 TAPIIDFromModemID( GetDeviceID() ),	// TAPI ID for modem
											 0,
											 pTapiInfo->dwVersion,					// min API version
											 &m_dwNegotiatedAPIVersion,				// negotiated version
											 &LineExtensionID						// line extension ID
											 );
	if ( lTapiReturn != LINEERR_NONE )
	{
		DPFX(DPFPREP,  0, "Failed to negotiate modem version!" );
		DisplayTAPIError( 0, lTapiReturn );
		hr = DPNERR_NOCONNECTION;
		goto Failure;
	}
	DNASSERT( GetNegotiatedAPIVersion() != 0 );

	DNASSERT( GetLineHandle() == NULL );
	DBG_CASSERT( sizeof( HANDLE ) == sizeof( DWORD_PTR ) );
	DPFX(DPFPREP,  5, "lineOpen %d", TAPIIDFromModemID( GetDeviceID() ) );
	lTapiReturn = p_lineOpen( pTapiInfo->hApplicationInstance,				// TAPI application instance
							  TAPIIDFromModemID( GetDeviceID() ),			// TAPI ID for modem
							  &m_hLine,										// pointer to line handle
							  GetNegotiatedAPIVersion(),					// API version
							  0,											// extension version (none)
							  reinterpret_cast<DWORD_PTR>( GetHandle() ),	// callback context
							  LINECALLPRIVILEGE_OWNER,						// priveleges (full ownership)
							  LINEMEDIAMODE_DATAMODEM,						// media mode
							  NULL											// call parameters (none)
							  );
	if ( lTapiReturn != LINEERR_NONE )
	{
		DPFX(DPFPREP,  0, "Failed to open modem!" );
		DisplayTAPIError( 0, lTapiReturn );

		if ( lTapiReturn == LINEERR_RESOURCEUNAVAIL )
		{
			hr = DPNERR_OUTOFMEMORY;
		}
		else
		{
			hr = DPNERR_NOCONNECTION;
		}

		goto Failure;
	}

	DPFX(DPFPREP,  5, "\nTAPI line opened: 0x%x", GetLineHandle() );

	SetModemState( MODEM_STATE_INITIALIZED );

Exit:
	return	hr;

Failure:
	SetDeviceID( INVALID_DEVICE_ID );
	SetNegotiatedAPIVersion( 0 );
	DNASSERT( GetLineHandle() == NULL );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::UnbindFromNetwork - unbind this data port from the network
//
// Entry:		Nothing
//				
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::UnbindFromNetwork"

void	CModemPort::UnbindFromNetwork( void )
{
	DPFX(DPFPREP, 6, "(0x%p) Enter", this);


	if ( GetHandle() != INVALID_HANDLE_VALUE )
	{
		GetSPData()->GetThreadPool()->CloseDataPortHandle( this );
		DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );
	}

	if ( GetCallHandle() != NULL )
	{
		LONG	lTapiResult;


		DPFX(DPFPREP,  5, "lineDrop: 0x%x", GetCallHandle() );
		lTapiResult = p_lineDrop( GetCallHandle(), NULL, 0 );
		if ( lTapiResult < 0 )
		{
		    DPFX(DPFPREP,  0, "Problem dropping line!" );
		    DisplayTAPIError( 0, lTapiResult );
		}

		DPFX(DPFPREP,  5, "lineDeallocateCall (call handle=0x%x)", GetCallHandle() );
		lTapiResult = p_lineDeallocateCall( GetCallHandle() );
		if ( lTapiResult != LINEERR_NONE )
		{
			DPFX(DPFPREP,  0, "Problem deallocating call!" );
			DisplayTAPIError( 0, lTapiResult );
		}
	}

	if ( GetLineHandle() != NULL )
	{
		LONG	lTapiResult;


		DPFX(DPFPREP,  5, "lineClose: 0x%x", GetLineHandle() );
		lTapiResult = p_lineClose( GetLineHandle() );
		if ( lTapiResult != LINEERR_NONE )
		{
			DPFX(DPFPREP,  0, "Problem closing line!" );
			DisplayTAPIError( 0, lTapiResult );
		}
	}

	SetCallHandle( NULL );

	if ( GetFileHandle() != INVALID_HANDLE_VALUE )
	{
		DPFX(DPFPREP,  5, "Closing file handle when unbinding from network!" );
		if ( CloseHandle( m_hFile ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Failed to close file handle!" );
			DisplayErrorCode( 0, dwError );

		}

		m_hFile = INVALID_HANDLE_VALUE;
	}

	SetActiveLineCommand( INVALID_TAPI_COMMAND );
	SetDeviceID( INVALID_DEVICE_ID );
	SetNegotiatedAPIVersion( 0 );
	SetLineHandle( NULL );
	SetModemState( MODEM_STATE_UNKNOWN );


	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::BindEndpoint - bind endpoint to this data port
//
// Entry:		Pointer to endpoint
//				Endpoint type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::BindEndpoint"

HRESULT	CModemPort::BindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType )
{
	HRESULT	hr;
	IDirectPlay8Address	*pDeviceAddress;
	IDirectPlay8Address	*pHostAddress;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p, %u)", this, pEndpoint, EndpointType);
	
	DNASSERT( pEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pDeviceAddress = NULL;
	pHostAddress = NULL;

	Lock();

	//
	// we're only allowed one endpoint of any given type so determine which
	// type and then bind the endpoint
	//
	switch ( EndpointType )
	{
		case ENDPOINT_TYPE_ENUM:
		case ENDPOINT_TYPE_CONNECT:
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
		{
			CModemEndpoint	*pModemEndpoint;
			LONG			lTapiReturn;
			LINECALLPARAMS	LineCallParams;


			pModemEndpoint = static_cast<CModemEndpoint*>( pEndpoint );

			switch ( EndpointType )
			{
				//
				// reject for duplicated endpoints
				//
				case ENDPOINT_TYPE_CONNECT:
				case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
				{
					if ( m_hConnectEndpoint != INVALID_HANDLE_VALUE )
					{
						hr = DPNERR_ALREADYINITIALIZED;
						DPFX(DPFPREP,  0, "Attempted to bind connect endpoint when one already exists.!" );
						goto Failure;
					}

					m_hConnectEndpoint = pEndpoint->GetHandle();

					if ( EndpointType == ENDPOINT_TYPE_CONNECT )
					{
						SPIE_CONNECTADDRESSINFO	ConnectAddressInfo;
						HRESULT	hTempResult;


						//
						// set addresses in addressing information
						//
						pDeviceAddress = GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );
						pHostAddress = pEndpoint->GetRemoteHostDP8Address();

						memset( &ConnectAddressInfo, 0x00, sizeof( ConnectAddressInfo ) );
						ConnectAddressInfo.pDeviceAddress = pDeviceAddress;
						ConnectAddressInfo.pHostAddress = pHostAddress;
						ConnectAddressInfo.hCommandStatus = DPN_OK;
						ConnectAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();	

						if ( ( ConnectAddressInfo.pDeviceAddress == NULL ) ||
							 ( ConnectAddressInfo.pHostAddress == NULL ) )
						{
							DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial connect addressing!" );
							hr = DPNERR_OUTOFMEMORY;
							goto Failure;
						}

						hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),	// interface
																	SPEV_CONNECTADDRESSINFO,				// event type
																	&ConnectAddressInfo						// pointer to data
																	);
						DNASSERT( hTempResult == DPN_OK );
					}

					break;
				}

				case ENDPOINT_TYPE_ENUM:
				{
					SPIE_ENUMADDRESSINFO	EnumAddressInfo;
					HRESULT	hTempResult;


					if ( m_hEnumEndpoint != INVALID_HANDLE_VALUE )
					{
						hr = DPNERR_ALREADYINITIALIZED;
						DPFX(DPFPREP,  0, "Attempted to bind enum endpoint when one already exists!" );
						goto Failure;
					}

					m_hEnumEndpoint = pEndpoint->GetHandle();

					//
					// indicate addressing to a higher layer
					//
					pDeviceAddress = GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );
					pHostAddress = pEndpoint->GetRemoteHostDP8Address();

					memset( &EnumAddressInfo, 0x00, sizeof( EnumAddressInfo ) );
					EnumAddressInfo.pDeviceAddress = pDeviceAddress;
					EnumAddressInfo.pHostAddress = pHostAddress;
					EnumAddressInfo.hCommandStatus = DPN_OK;
					EnumAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();

					if ( ( EnumAddressInfo.pDeviceAddress == NULL ) ||
						 ( EnumAddressInfo.pHostAddress == NULL ) )
					{
						DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial enum addressing!" );
						hr = DPNERR_OUTOFMEMORY;
						goto Failure;
					}

					hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),
																SPEV_ENUMADDRESSINFO,
																&EnumAddressInfo
																);
					DNASSERT( hTempResult == DPN_OK );

					break;
				}

				//
				// shouldn't be here
				//
				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			//
			// an outgoing endpoint was bound, attempt the outgoing
			// connection.  If it fails make sure that the above binding is
			// undone.
			//
			switch ( GetModemState() )
			{
				case MODEM_STATE_OUTGOING_CONNECTED:
				case MODEM_STATE_INCOMING_CONNECTED:
				{
					break;
				}

				case MODEM_STATE_INITIALIZED:
				{
					DNASSERT( GetCallHandle() == NULL );
					memset( &LineCallParams, 0x00, sizeof( LineCallParams ) );
					LineCallParams.dwTotalSize = sizeof( LineCallParams );
					LineCallParams.dwBearerMode = LINEBEARERMODE_VOICE;
					LineCallParams.dwMediaMode = LINEMEDIAMODE_DATAMODEM;

					DNASSERT( GetActiveLineCommand() == INVALID_TAPI_COMMAND );
					DPFX(DPFPREP,  5, "lineMakeCall" );
					lTapiReturn = p_lineMakeCall( GetLineHandle(),						// line handle
												  &m_hCall,								// pointer to call destination
												  pModemEndpoint->GetPhoneNumber(),		// destination address (phone number)
												  0,									// country code (default)
												  &LineCallParams						// pointer to call params
												  );
					if ( lTapiReturn > 0 )
					{
						DPFX(DPFPREP,  5, "TAPI making call (handle=0x%x), command ID: %d", GetCallHandle(), lTapiReturn );
						SetModemState( MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT );
						SetActiveLineCommand( lTapiReturn );
					}
					else
					{
						DPFX(DPFPREP,  0, "Problem with lineMakeCall" );
						DisplayTAPIError( 0, lTapiReturn );
						hr = DPNERR_NOCONNECTION;

						switch ( EndpointType )
						{
							case ENDPOINT_TYPE_CONNECT:
							case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
							{
								DNASSERT( m_hConnectEndpoint != INVALID_HANDLE_VALUE );
								m_hConnectEndpoint = INVALID_HANDLE_VALUE;
								break;
							}

							case ENDPOINT_TYPE_ENUM:
							{
								DNASSERT( m_hEnumEndpoint != INVALID_HANDLE_VALUE );
								m_hEnumEndpoint = INVALID_HANDLE_VALUE;
								break;
							}

							default:
							{
								DNASSERT( FALSE );
								break;
							}
						}

						goto Failure;
					}

					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		case ENDPOINT_TYPE_LISTEN:
		{
			SPIE_LISTENADDRESSINFO	ListenAddressInfo;
			HRESULT	hTempResult;


			if ( ( GetModemState() == MODEM_STATE_CLOSING_INCOMING_CONNECTION ) ||
				 ( m_hListenEndpoint != INVALID_HANDLE_VALUE ) )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPFX(DPFPREP,  0, "Attempted to bind listen endpoint when one already exists!" );
				goto Failure;
			}

			m_hListenEndpoint = pEndpoint->GetHandle();
			//
			// set addressing information
			//
			pDeviceAddress = GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );
			DNASSERT( pHostAddress == NULL );

			memset( &ListenAddressInfo, 0x00, sizeof( ListenAddressInfo ) );
			ListenAddressInfo.pDeviceAddress = pDeviceAddress;
			ListenAddressInfo.hCommandStatus = DPN_OK;
			ListenAddressInfo.pCommandContext = pEndpoint->GetCommandData()->GetUserContext();

			if ( ListenAddressInfo.pDeviceAddress == NULL )
			{
				DPFX(DPFPREP,  0, "Failed to build addresses to indicate serial listen addressing!" );
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}

			hTempResult = IDP8SPCallback_IndicateEvent( GetSPData()->DP8SPCallbackInterface(),	// interface
														SPEV_LISTENADDRESSINFO,					// event type
														&ListenAddressInfo						// pointer to data
														);
			DNASSERT( hTempResult == DPN_OK );

			break;
		}

		//
		// invalid case, we should never be here
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// add these references before the lock is released to prevent them from
	// being immediately cleaned
	//
	pEndpoint->SetDataPort( this );
	pEndpoint->AddRef();

	if ( ( GetModemState() == MODEM_STATE_OUTGOING_CONNECTED ) &&
		 ( ( EndpointType == ENDPOINT_TYPE_CONNECT ) ||
		   ( EndpointType == ENDPOINT_TYPE_ENUM ) ) )
	{
		pEndpoint->OutgoingConnectionEstablished( DPN_OK );
	}

	Unlock();

Exit:
	if ( pHostAddress != NULL )
	{
		IDirectPlay8Address_Release( pHostAddress );
		pHostAddress = NULL;
	}

	if ( pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( pDeviceAddress );
		pDeviceAddress = NULL;
	}


	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);

	return	hr;

Failure:
	Unlock();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::UnbindEndpoint - unbind endpoint from this data port
//
// Entry:		Pointer to endpoint
//				Endpoint type
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::UnbindEndpoint"

void	CModemPort::UnbindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType )
{
	DNASSERT( pEndpoint != NULL );

	Lock();

	DNASSERT( pEndpoint->GetDataPort() == this );
	switch ( EndpointType )
	{
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
		case ENDPOINT_TYPE_CONNECT:
		{
			DNASSERT( m_hConnectEndpoint != INVALID_HANDLE_VALUE );
			m_hConnectEndpoint = INVALID_HANDLE_VALUE;
			break;
		}

		case ENDPOINT_TYPE_LISTEN:
		{
			DNASSERT( m_hListenEndpoint != INVALID_HANDLE_VALUE );
			m_hListenEndpoint = INVALID_HANDLE_VALUE;
			break;
		}

		case ENDPOINT_TYPE_ENUM:
		{
			DNASSERT( m_hEnumEndpoint != INVALID_HANDLE_VALUE );
			m_hEnumEndpoint = INVALID_HANDLE_VALUE;
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	Unlock();

	pEndpoint->SetDataPort( NULL );
	pEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::BindComPort - bind com port to network
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::BindComPort"

HRESULT	CModemPort::BindComPort( void )
{
	HRESULT		hr;
	VARSTRING	*pTempInfo;
	LONG		lTapiError;


	//
	// In the case of host migration, there is an outstanding read pending that
	// needs to be cleaned up.  Unfortunately, there is no mechanism in Win32
	// to cancel just this little I/O operation.  Release the read ref count on
	// this CDataPort and reissue the read.....
	//
	if ( GetActiveRead() != NULL )
	{
#ifdef WIN95
		GetActiveRead()->SetWin9xOperationPending( FALSE );
#endif
		DecRef();
	}

	//
	// initialize
	//
	hr = DPN_OK;
	pTempInfo = NULL;

	//
	// get file handle for modem device
	//
	pTempInfo = static_cast<VARSTRING*>( DNMalloc( sizeof( *pTempInfo ) ) );
	if ( pTempInfo == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Out of memory allocating for lineGetID!" );
		goto Failure;
	}

	pTempInfo->dwTotalSize = sizeof( *pTempInfo );
	pTempInfo->dwNeededSize = pTempInfo->dwTotalSize;
	pTempInfo->dwStringFormat = STRINGFORMAT_BINARY;
	lTapiError = LINEERR_STRUCTURETOOSMALL;
	while ( lTapiError == LINEERR_STRUCTURETOOSMALL )
	{
		VARSTRING *pTemp;


		pTemp = static_cast<VARSTRING*>( DNRealloc( pTempInfo, pTempInfo->dwNeededSize ) );
		if ( pTemp == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP,  0, "Out of memory reallocating for lineGetID!" );
			goto Failure;
		}
		pTempInfo = pTemp;
		pTempInfo->dwTotalSize = pTempInfo->dwNeededSize;

		DPFX(DPFPREP,  5, "lineGetID (call handle=0x%x)", GetCallHandle() );
		lTapiError = p_lineGetID( NULL,						// line handle
								  0,						// address ID
								  m_hCall,					// call handle
								  LINECALLSELECT_CALL,		// use call handle
								  pTempInfo,				// pointer to variable information
								  TEXT("comm/datamodem")	// request comm/modem ID information
								  );

		if ( ( lTapiError == LINEERR_NONE ) &&
			 ( pTempInfo->dwTotalSize < pTempInfo->dwNeededSize ) )
		{
			lTapiError = LINEERR_STRUCTURETOOSMALL;
		}
	}

	if ( lTapiError != LINEERR_NONE )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem with lineGetID" );
		DisplayTAPIError( 0, lTapiError );
		goto Failure;
	}

	DNASSERT( pTempInfo->dwStringSize != 0 );
	DNASSERT( pTempInfo->dwStringFormat == STRINGFORMAT_BINARY );
	m_hFile = *( (HANDLE*) ( ( (BYTE*) pTempInfo ) + pTempInfo->dwStringOffset ) );
	if ( m_hFile == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "problem getting Com file handle!" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = SetPortCommunicationParameters();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to set communication parameters!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// bind to completion port for NT
	//
#ifdef WINNT
	HANDLE	hCompletionPort;


	hCompletionPort = CreateIoCompletionPort( m_hFile,				    							// current file handle
											  GetSPData()->GetThreadPool()->GetIOCompletionPort(),	// handle of completion port
											  IO_COMPLETION_KEY_IO_COMPLETE,						// completion key
											  0					    								// number of concurrent threads (default to number of processors)
											  );
	if ( hCompletionPort == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot bind comport to completion port!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}
#endif

	hr = StartReceiving();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to start receiving!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( pTempInfo != NULL )
	{
		DNFree( pTempInfo );
		pTempInfo = NULL;
	}

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::SetDeviceID - set device ID
//
// Entry:		Device ID
//				
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::SetDeviceID"

HRESULT	CModemPort::SetDeviceID( const DWORD dwDeviceID )
{
	DNASSERT( ( GetDeviceID() == INVALID_DEVICE_ID ) ||
			  ( dwDeviceID == INVALID_DEVICE_ID ) );

	m_dwDeviceID = dwDeviceID;

	return	DPN_OK;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::ProcessTAPIMessage - process a TAPI message
//
// Entry:		Pointer to message information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::ProcessTAPIMessage"

void	CModemPort::ProcessTAPIMessage( const LINEMESSAGE *const pLineMessage )
{
	DPFX(DPFPREP, 1, "(0x%p) Processing TAPI message %u:", this, pLineMessage->dwMessageID );
	DisplayTAPIMessage( 1, pLineMessage );

	Lock();

	switch ( pLineMessage->dwMessageID )
	{
		//
		// call information about the specified call has changed
		//
		case LINE_CALLINFO:
		{
			DPFX(DPFPREP, 3, "Call info type 0x%lx changed, ignoring.",
				pLineMessage->dwParam1);
			break;
		}
		
		//
		// command reply
		//
		case LINE_REPLY:
		{
			DNASSERT( pLineMessage->hDevice == 0 );
			SetActiveLineCommand( INVALID_TAPI_COMMAND );

			//
			// Can't ASSERT that there's a call handle because the command
			// may have failed and been cleaned up from the NT completion
			// port, just ASSERT our state.  Can't ASSERT modem state because
			// TAPI events may race off the completion port on NT.  Can't ASSERT
			// command because it may have already been cleaned.
			//

			break;
		}

		//
		// new call, make sure we're listening for a call and that there's an
		// active 'listen' before accepting.
		//	
		case LINE_APPNEWCALL:
		{
			DNASSERT( GetCallHandle() == NULL );

			DBG_CASSERT( sizeof( m_hLine ) == sizeof( pLineMessage->hDevice ) );
			DNASSERT( GetLineHandle() == pLineMessage->hDevice );
			DNASSERT( pLineMessage->dwParam3 == LINECALLPRIVILEGE_OWNER );

			if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
			{
				LONG	lTapiReturn;


				DPFX(DPFPREP,  5, "lineAnswer (call handle=0x%x)", pLineMessage->dwParam2 );
				lTapiReturn = p_lineAnswer( static_cast<HCALL>( pLineMessage->dwParam2 ),		// call to be answered
											NULL,						// user information to be sent to remote party (none)
											0							// size of user data to send
											);
				if ( lTapiReturn > 0 )
				{
					DPFX(DPFPREP,  8, "Accepted call, id: %d", lTapiReturn );
					SetCallHandle( static_cast<HCALL>( pLineMessage->dwParam2 ) );
					SetModemState( MODEM_STATE_WAITING_FOR_INCOMING_CONNECT );
					SetActiveLineCommand( lTapiReturn );
				}
				else
				{
					DPFX(DPFPREP,  0, "Failed to answer call!" );
					DisplayTAPIError( 0, lTapiReturn );
				}
			}

			break;
		}

		//
		// call state
		//
		case LINE_CALLSTATE:
		{
			//
			// if there's state information, make sure we own the call
			//
			DNASSERT( ( pLineMessage->dwParam3 == 0 ) ||
					  ( pLineMessage->dwParam3 == LINECALLPRIVILEGE_OWNER ) );

			//
			// validate input, but note that  it's possible that TAPI messages got processed
			// out of order so we might not have seen a call handle yet
			//
			DBG_CASSERT( sizeof( m_hCall ) == sizeof( pLineMessage->hDevice ) );
			DNASSERT( ( m_hCall == pLineMessage->hDevice ) || ( m_hCall == NULL ) );

			//
			// what's the sub-state?
			//
			switch ( pLineMessage->dwParam1 )
			{
				//
				// modem has connected
				//	
				case LINECALLSTATE_CONNECTED:
				{
					DNASSERT( ( pLineMessage->dwParam2 == 0 ) ||
							  ( pLineMessage->dwParam2 == LINECONNECTEDMODE_ACTIVE ) );

					DNASSERT( ( GetModemState() == MODEM_STATE_WAITING_FOR_INCOMING_CONNECT ) ||
							  ( GetModemState() == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT ) );

					if ( GetModemState() == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT )
					{
						HRESULT	hr;


						hr = BindComPort();
						if ( hr != DPN_OK )
						{
							DPFX(DPFPREP,  0, "Failed to bind modem communication port!" );
							DisplayDNError( 0, hr );
							DNASSERT( FALSE );
						}

						SetModemState( MODEM_STATE_OUTGOING_CONNECTED );

						if ( m_hConnectEndpoint != INVALID_HANDLE_VALUE )
						{
							CEndpoint	*pEndpoint;


							pEndpoint = GetSPData()->EndpointFromHandle( m_hConnectEndpoint );
							if ( pEndpoint != NULL )
							{
								pEndpoint->OutgoingConnectionEstablished( DPN_OK );
								pEndpoint->DecCommandRef();
							}
						}

						if ( m_hEnumEndpoint != INVALID_HANDLE_VALUE )
						{
							CEndpoint	*pEndpoint;


							pEndpoint = GetSPData()->EndpointFromHandle( m_hEnumEndpoint );
							if ( pEndpoint != NULL )
							{
								pEndpoint->OutgoingConnectionEstablished( DPN_OK );
								pEndpoint->DecCommandRef();
							}
						}
					}
					else
					{
						HRESULT	hr;


						hr = BindComPort();
						if ( hr != DPN_OK )
						{
							DPFX(DPFPREP,  0, "Failed to bind modem communication port!" );
							DisplayDNError( 0, hr );
							DNASSERT( FALSE );
						}

						SetModemState( MODEM_STATE_INCOMING_CONNECTED );
					}

					break;
				}

				//
				// modems disconnected
				//
				case LINECALLSTATE_DISCONNECTED:
				{
					LONG	lTapiReturn;


					switch( pLineMessage->dwParam2 )
					{
						case LINEDISCONNECTMODE_NORMAL:
						case LINEDISCONNECTMODE_BUSY:
						case LINEDISCONNECTMODE_NOANSWER:
						case LINEDISCONNECTMODE_NODIALTONE:
						case LINEDISCONNECTMODE_UNAVAIL:
						{
							break;
						}

						//
						// stop and look
						//
						default:
						{
							DNASSERT( FALSE );
							break;
						}
					}

					CancelOutgoingConnections();

					//
					// reset modem port to initialized state and indicate that
					// it is no longer receiving data
					//
					SetModemState( MODEM_STATE_INITIALIZED );

					DPFX(DPFPREP,  5, "Closing file handle on DISCONNECT notification." );
					if ( CloseHandle( GetFileHandle() ) == FALSE )
					{
						DWORD	dwError;


						dwError = GetLastError();
						DPFX(DPFPREP,  0, "Problem closing file handle when restarting modem on host!" );
						DisplayErrorCode( 0, dwError );
					}
					m_hFile = INVALID_HANDLE_VALUE;
					SetActiveLineCommand( INVALID_TAPI_COMMAND );

					//
					// if there is an active listen, release this call so TAPI
					// can indicate future incoming calls.
					//
					if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
    				{
						SetState( DATA_PORT_STATE_INITIALIZED );

						DPFX(DPFPREP,  5, "lineDeallocateCall listen (call handle=0x%x)", GetCallHandle() );
						lTapiReturn = p_lineDeallocateCall( GetCallHandle() );
						if ( lTapiReturn != LINEERR_NONE )
						{
							DPFX(DPFPREP,  0, "Failed to release call (listen)!" );
							DisplayTAPIError( 0, lTapiReturn );
							DNASSERT( FALSE );
						}
						SetCallHandle( NULL );

						DNASSERT( GetFileHandle() == INVALID_HANDLE_VALUE );
					}
					else
					{
						//
						// Deallocate the call if there is one..
						//
						if (GetCallHandle() != NULL)
						{
							DNASSERT(( m_hEnumEndpoint != INVALID_HANDLE_VALUE ) || ( m_hConnectEndpoint != INVALID_HANDLE_VALUE ));
							
							DPFX(DPFPREP,  5, "lineDeallocateCall non-listen (call handle=0x%x)", GetCallHandle() );
							lTapiReturn = p_lineDeallocateCall( GetCallHandle() );
							if ( lTapiReturn != LINEERR_NONE )
							{
								DPFX(DPFPREP,  0, "Failed to release call (non-listen)!" );
								DisplayTAPIError( 0, lTapiReturn );
								DNASSERT( FALSE );
							}
							SetCallHandle( NULL );
						}
						else
						{
							DPFX(DPFPREP,  5, "No call handle." );
							DNASSERT( m_hEnumEndpoint == INVALID_HANDLE_VALUE );
							DNASSERT( m_hConnectEndpoint == INVALID_HANDLE_VALUE );
						}
						SetModemState( MODEM_STATE_UNKNOWN );
					}

					break;
				}

				//
				// call is officially ours.  Can't ASSERT any state here because
				// messages might have been reversed by the NT completion threads
				// so LINE_APPNEWCALL may not yet have been processed.  It's also
				// possible that we're in disconnect cleanup as someone is calling
				// and LINECALLSTATE_OFFERING is coming in before LINE_APPNEWCALL.
				//
				case LINECALLSTATE_OFFERING:
				{
					break;
				}

				//
				// call has been accepted, waiting for modems to connect
				//
				case LINECALLSTATE_ACCEPTED:
				{
					DNASSERT( GetModemState() == MODEM_STATE_WAITING_FOR_INCOMING_CONNECT );
					break;
				}

				//
				// we're dialing
				//
				case LINECALLSTATE_DIALING:
				case LINECALLSTATE_DIALTONE:
				{
					DNASSERT( GetModemState() == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT );
					break;
				}

				//
				// we're done dialing, waiting for modems to connect
				//
				case LINECALLSTATE_PROCEEDING:
				{
					DNASSERT( GetModemState() == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT );
					break;
				}

				//
				// line is idle, most likely from a modem hanging up during negotiation
				//
				case LINECALLSTATE_IDLE:
				{
					break;
				}

				//
				// other state, stop and look
				//
				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// TAPI line was closed
		//
		case LINE_CLOSE:
		{
			CancelOutgoingConnections();
			break;
		}

		//
		// unhandled message
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	Unlock();

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::CancelOutgoingConnections - cancel any outgoing connection attempts
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::CancelOutgoingConnections"

void	CModemPort::CancelOutgoingConnections( void )
{
	DPFX(DPFPREP, 6, "(0x%p) Enter", this );

	
	//
	// if there is an outstanding enum, stop it
	//
	if ( m_hEnumEndpoint != INVALID_HANDLE_VALUE )
	{
		CEndpoint	*pEndpoint;


		pEndpoint = GetSPData()->EndpointFromHandle( m_hEnumEndpoint );
		if ( pEndpoint != NULL )
		{
			CCommandData	*pCommandData;


			pCommandData = pEndpoint->GetCommandData();
			pCommandData->Lock();
			if ( pCommandData->GetState() != COMMAND_STATE_INPROGRESS )
			{
				DNASSERT( pCommandData->GetState() == COMMAND_STATE_CANCELLING );
				pCommandData->Unlock();
			}
			else
			{
				pCommandData->SetState( COMMAND_STATE_CANCELLING );
				pCommandData->Unlock();

				pEndpoint->Lock();
				pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
				pEndpoint->Unlock();

				pEndpoint->StopEnumCommand( DPNERR_NOCONNECTION );
			}

			pEndpoint->DecCommandRef();
		}
	}

	//
	// if there is an outstanding connect, disconnect it
	//
	if ( m_hConnectEndpoint != INVALID_HANDLE_VALUE )
	{
		CEndpoint	*pEndpoint;
		HANDLE		hOldHandleValue;


		hOldHandleValue = m_hConnectEndpoint;
		pEndpoint = GetSPData()->GetEndpointAndCloseHandle( hOldHandleValue );
		if ( pEndpoint != NULL )
		{
			HRESULT	hTempResult;


			hTempResult = pEndpoint->Disconnect( hOldHandleValue );
			pEndpoint->DecRef();
		}
	}

	
	DPFX(DPFPREP, 6, "(0x%p) Leave", this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::PoolAllocFunction - called when new pool item is allocated
//
// Entry:		Pointer to context
//
// Exit:		Boolean inidcating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::PoolAllocFunction"

BOOL	CModemPort::PoolAllocFunction( DATA_PORT_POOL_CONTEXT *pContext )
{
	DNASSERT( pContext != NULL );
	DNASSERT( pContext->pSPData->GetType() == TYPE_MODEM );
	DNASSERT( GetActiveRead() == NULL );
	DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetModemState() == MODEM_STATE_UNKNOWN );
	DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( GetNegotiatedAPIVersion() == 0 );
	DNASSERT( GetLineHandle() == NULL );
	DNASSERT( GetCallHandle() == NULL );
	DNASSERT( GetActiveLineCommand() == INVALID_TAPI_COMMAND );

	return TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::PoolInitFunction - called when new pool item is removed from pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean inidcating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::PoolInitFunction"

BOOL	CModemPort::PoolInitFunction( DATA_PORT_POOL_CONTEXT *pContext )
{
	BOOL	fReturn;
	HRESULT	hTempResult;


	DNASSERT( pContext != NULL );
	DNASSERT( pContext->pSPData->GetType() == TYPE_MODEM );
	DNASSERT( GetActiveRead() == NULL );
	DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetModemState() == MODEM_STATE_UNKNOWN );
	DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( GetNegotiatedAPIVersion() == 0 );
	DNASSERT( GetLineHandle() == NULL );
	DNASSERT( GetCallHandle() == NULL );
	DNASSERT( GetActiveLineCommand() == INVALID_TAPI_COMMAND );

	fReturn = TRUE;

	hTempResult = CDataPort::Initialize( pContext->pSPData );
	if ( hTempResult != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Failed to initalize DataPort base class!" );
		DisplayDNError( 0, hTempResult );
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::PoolReleaseFunction - called when new pool item is returned to  pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::PoolReleaseFunction"

void	CModemPort::PoolReleaseFunction( void )
{
	CDataPort::Deinitialize();
	DNASSERT( GetActiveRead() == NULL );
	DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetModemState() == MODEM_STATE_UNKNOWN );
	DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( GetNegotiatedAPIVersion() == 0 );
	DNASSERT( GetLineHandle() == NULL );
	DNASSERT( GetCallHandle() == NULL );
	DNASSERT( GetActiveLineCommand() == INVALID_TAPI_COMMAND );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CModemPort::PoolDeallocFunction - called when new pool item is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CModemPort::PoolDeallocFunction"

void	CModemPort::PoolDeallocFunction( void )
{
	DNASSERT( GetActiveRead() == NULL );
	DNASSERT( GetHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetModemState() == MODEM_STATE_UNKNOWN );
	DNASSERT( GetDeviceID() == INVALID_DEVICE_ID );
	DNASSERT( GetNegotiatedAPIVersion() == 0 );
	DNASSERT( GetLineHandle() == NULL );
	DNASSERT( GetCallHandle() == NULL );
	DNASSERT( GetActiveLineCommand() == INVALID_TAPI_COMMAND );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\dpnmodemutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Utils.h
 *  Content:	serial service provider utilitiy functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __UTILS_H__
#define __UTILS_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// type definition for values in StringToValue and ValueToString
//
#define	VALUE_ENUM_TYPE	DWORD

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward strucutre references
//
class	CSPData;
typedef	struct	_BUFFERDESC			BUFFERDESC;
typedef	struct	_MESSAGE_HEADER		MESSAGE_HEADER;

//
// structure for relating a string to an enum value
//
typedef	struct	_STRING_BLOCK
{
	DWORD		dwEnumValue;
	const WCHAR	*pWCHARKey;
	DWORD		dwWCHARKeyLength;
	const char	*pASCIIKey;
	DWORD		dwASCIIKeyLength;
	TCHAR		szLocalizedKey[256];		
} STRING_BLOCK;

//
// structure to generate list of modems
//
typedef	struct	_MODEM_NAME_DATA
{
	DWORD		dwModemID;			// modem ID
	DWORD		dwModemNameSize;	// size of name (including NULL)
	const TCHAR	*pModemName;		// modem name
} MODEM_NAME_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	InitProcessGlobals( void );
void	DeinitProcessGlobals( void );

HRESULT	InitializeInterfaceGlobals( CSPData *const pSPData );
void	DeinitializeInterfaceGlobals( CSPData *const pSPData );

HRESULT	LoadTAPILibrary( void );
void	UnloadTAPILibrary( void );

BOOL	IsSerialGUID( const GUID *const pGuid );

BOOL	StringToValue( const WCHAR *const pString,
					   const DWORD dwStringLength,
					   VALUE_ENUM_TYPE *const pEnum,
					   const STRING_BLOCK *const pPairs,
					   const DWORD dwPairCount );

BOOL	ValueToString( const WCHAR **const ppString,
					   DWORD *const pdwStringLength,
					   const DWORD Enum,
					   const STRING_BLOCK *const pPairs,
					   const DWORD dwPairCount );

void	DeviceIDToGuid( GUID *const pGuid, const UINT_PTR DeviceID, const GUID *const pEncryptionGuid );
DWORD	GuidToDeviceID( const GUID *const pGuid, const GUID *const pEncryptionGuid );

void	ComDeviceIDToString( TCHAR *const pString, const UINT_PTR DeviceID );

HRESULT	WideToAnsi( const WCHAR *const pWCHARString,
					const DWORD dwWCHARStringLength,
					char *const pString,
					DWORD *const pdwStringLength );

HRESULT	AnsiToWide( const char *const pString,
					const DWORD dwStringLength,
					WCHAR *const pWCHARString,
					DWORD *const pdwWCHARStringLength );

HRESULT	CreateSPData( CSPData **const ppSPData,
					  const CLSID *const pClassID,
					  const SP_TYPE SPType,
					  IDP8ServiceProviderVtbl *const pVtbl );

HRESULT	InitializeInterfaceGlobals( CSPData *const pSPData );
void	DeinitializeInterfaceGlobals( CSPData *const pSPData );

HRESULT	GenerateAvailableComPortList( BOOL *const pfPortAvailable,
									  const UINT_PTR uMaxDeviceIndex,
									  DWORD *const pdwPortCount );

HRESULT	GenerateAvailableModemList( const TAPI_INFO *const pTAPIInfo,
									DWORD *const pdwModemCount,
									MODEM_NAME_DATA *const pModemNameData,
									DWORD *const pdwModemNameDataSize );

_inline DWORD	ModemIDFromTAPIID( const DWORD dwTAPIID ) { return	( dwTAPIID + 1 ); }

#undef DPF_MODNAME
#define DPF_MODNAME "TAPIIDFromModemID"
_inline DWORD	TAPIIDFromModemID( const DWORD dwModemID )
{
	DNASSERT( dwModemID != 0 );
	return	( dwModemID - 1 );
}

#undef DPF_MODNAME


#ifndef UNICODE
HRESULT	PhoneNumberToWCHAR( const char *const pPhoneNumber,
							WCHAR *const pWCHARPhoneNumber,
							DWORD *const pdwWCHARPhoneNumberSize );

HRESULT	PhoneNumberFromWCHAR( const WCHAR *const pWCHARPhoneNumber,
							  char *const pPhoneNumber,
							  DWORD *const pdwPhoneNumberSize );
#endif
//
// GUID encryption/decription code.  Note that it's presently an XOR function
// so map the decryption code to the encryption function.
//
void	EncryptGuid( const GUID *const pSourceGuid,
					 GUID *const pDestinationGuid,
					 const GUID *const pEncrpytionKey );

inline void	DecryptGuid( const GUID *const pSourceGuid,
						 GUID *const pDestinationGuid,
						 const GUID *const pEncryptionKey ) { EncryptGuid( pSourceGuid, pDestinationGuid, pEncryptionKey ); }


#endif	// __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\modemport.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ModemPort.h
 *  Content:	Serial communications modem management class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 ***************************************************************************/

#ifndef __MODEM_PORT_H__
#define __MODEM_PORT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumeration of phone state
//
typedef enum
{
	MODEM_STATE_UNKNOWN = 0,

	MODEM_STATE_INITIALIZED,
	MODEM_STATE_INCOMING_CONNECTED,
	MODEM_STATE_OUTGOING_CONNECTED,

	MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT,
	MODEM_STATE_WAITING_FOR_INCOMING_CONNECT,
	MODEM_STATE_CLOSING_OUTGOING_CONNECTION,
	MODEM_STATE_CLOSING_INCOMING_CONNECTION

} MODEM_STATE;

//
// invalid TAPI command ID
//
#define	INVALID_TAPI_COMMAND	-1

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CModemPort : public CDataPort
{
	public:
		CModemPort();
		~CModemPort();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemPort::SetOwningPool"
		void	SetOwningPool( CLockedContextFixedPool< CModemPort, DATA_PORT_POOL_CONTEXT* > *pOwningPool )
		{
			DEBUG_ONLY( DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) ) );
			m_pOwningPool = pOwningPool;
		}
		void	ReturnSelfToPool( void );

		MODEM_STATE	GetModemState( void ) const { return m_ModemState; }
		void	SetModemState( const MODEM_STATE NewState )
		{
			DNASSERT( ( GetModemState() == MODEM_STATE_UNKNOWN ) ||
					  ( NewState == MODEM_STATE_UNKNOWN ) ||
					  ( ( GetModemState() == MODEM_STATE_INITIALIZED ) && ( NewState == MODEM_STATE_WAITING_FOR_INCOMING_CONNECT ) ) ||
					  ( ( GetModemState() == MODEM_STATE_INITIALIZED ) && ( NewState == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT ) ) ||
					  ( ( GetModemState() == MODEM_STATE_WAITING_FOR_INCOMING_CONNECT ) && ( NewState == MODEM_STATE_INCOMING_CONNECTED ) ) ||
					  ( ( GetModemState() == MODEM_STATE_WAITING_FOR_INCOMING_CONNECT ) && ( NewState == MODEM_STATE_INITIALIZED ) ) ||
					  ( ( GetModemState() == MODEM_STATE_WAITING_FOR_OUTGOING_CONNECT ) && ( NewState == MODEM_STATE_OUTGOING_CONNECTED ) ) ||
					  ( ( GetModemState() == MODEM_STATE_INCOMING_CONNECTED ) && ( NewState == MODEM_STATE_INITIALIZED ) ) ||
					  ( ( GetModemState() == MODEM_STATE_OUTGOING_CONNECTED ) && ( NewState == MODEM_STATE_INITIALIZED ) ) );
			m_ModemState = NewState;
		}

		HRESULT	EnumAdapters( SPENUMADAPTERSDATA *const pEnumAdaptersData ) const;
		IDirectPlay8Address	*GetLocalAdapterDP8Address( const ADDRESS_TYPE AddressType ) const;

		HRESULT	BindToNetwork( const DWORD dwDeviceID, const void *const pDeviceContext );
		void	UnbindFromNetwork( void );
		HRESULT	BindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType );
		void	UnbindEndpoint( CEndpoint *const pEndpoint, const ENDPOINT_TYPE EndpointType );
		HRESULT	BindComPort( void );

		//
		// port settings
		//
		DWORD	GetDeviceID( void ) const { return m_dwDeviceID; }
		HRESULT	SetDeviceID( const DWORD dwDeviceID );

		void	ProcessTAPIMessage( const LINEMESSAGE *const pLineMessage );


		//
		// pool functions
		//
		BOOL	PoolAllocFunction( DATA_PORT_POOL_CONTEXT *pContext );
		BOOL	PoolInitFunction( DATA_PORT_POOL_CONTEXT *pContext );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );
		
	protected:

	private:
		CLockedContextFixedPool< CModemPort, DATA_PORT_POOL_CONTEXT* >	*m_pOwningPool;
		volatile MODEM_STATE	m_ModemState;

		DWORD	m_dwDeviceID;
		DWORD	m_dwNegotiatedAPIVersion;
		HLINE	m_hLine;
		HCALL	m_hCall;
		LONG	m_lActiveLineCommand;

		DWORD	GetNegotiatedAPIVersion( void ) const { return m_dwNegotiatedAPIVersion; }
		void	SetNegotiatedAPIVersion( const DWORD dwVersion )
		{
			DNASSERT( ( GetNegotiatedAPIVersion() == 0 ) || ( dwVersion == 0 ) );
			m_dwNegotiatedAPIVersion = dwVersion;
		}

		HLINE	GetLineHandle( void ) const { return m_hLine; }
		void	SetLineHandle( const HLINE hLine )
		{
			DNASSERT( ( GetLineHandle() == NULL ) || ( hLine == NULL ) );
			m_hLine = hLine;
		}

		HCALL	GetCallHandle( void ) const { return m_hCall; }
		void	SetCallHandle( const HCALL hCall )
		{
			DNASSERT( ( GetCallHandle() == NULL ) ||
					  ( hCall == NULL ) );
			m_hCall = hCall;
		}

		LONG	GetActiveLineCommand( void ) const { return m_lActiveLineCommand; }
		void	SetActiveLineCommand( const LONG lLineCommand )
		{
			DNASSERT( ( GetActiveLineCommand() == INVALID_TAPI_COMMAND ) ||
					  ( lLineCommand == INVALID_TAPI_COMMAND ) );
			m_lActiveLineCommand = lLineCommand;
		}

		void	CancelOutgoingConnections( void );
		
		//
		// prevent unwarranted copies
		//
		CModemPort( const CModemPort & );
		CModemPort& operator=( const CModemPort & );
};

#undef DPF_MODNAME

#endif	// __MODEM_PORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\modemui.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ModemUI.cpp
 *  Content:	Modem service provider UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/24/99	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

// default size of temp strings used to add stuff to dialog
#define	DEFAULT_DIALOG_STRING_SIZE	100

#define	DEFAULT_DEVICE_SELECTION_INDEX			0

#define	MAX_MODEM_NAME_LENGTH	255

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

static const INT_PTR	g_iExpectedIncomingModemSettingsReturn = 0x23456789;
static const INT_PTR	g_iExpectedOutgoingModemSettingsReturn = 0x3456789A;

//**********************************************************************
// Function prototypes
//**********************************************************************
static	INT_PTR CALLBACK	IncomingSettingsDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam );
static	HRESULT	SetAddressParametersFromIncomingDialogData( const HWND hDialog, CModemEndpoint *const pModemEndpoint );

static	INT_PTR CALLBACK	OutgoingSettingsDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam );
static	HRESULT	SetOutgoingPhoneNumber( const HWND hDialog, const CModemEndpoint *const pModemEndpoint );
static	HRESULT	SetAddressParametersFromOutgoingDialogData( const HWND hDialog, CModemEndpoint *const pModemEndpoint );

static	HRESULT	DisplayModemConfigDialog( const HWND hDialog, const HWND hDeviceComboBox, CModemEndpoint *const pModemEndpoint );

static	HRESULT	SetModemDataInDialog( const HWND hComboBox, const CModemEndpoint *const pModemEndpoint );
static	HRESULT	GetModemSelectionFromDialog( const HWND hComboBox, CModemEndpoint *const pModemEndpoint );
static	INT_PTR CALLBACK	ModemStatusDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DisplayIncomingModemSettingsDialog - dialog for incoming modem connection
//
// Entry:		Pointer to startup param
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayIncomingModemSettingsDialog"

void	DisplayIncomingModemSettingsDialog( void *const pContext )
{
	INT_PTR			iDlgReturn;
	CModemEndpoint	*pModemEndpoint;


	DNASSERT( pContext != NULL );

	//	
	// intialize
	//
	pModemEndpoint = static_cast<CModemEndpoint*>( pContext );

	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LPARAM ) );
	SetLastError( ERROR_SUCCESS );
	iDlgReturn = DialogBoxParam( g_hDLLInstance,									// handle of module for resources
								 MAKEINTRESOURCE( IDD_INCOMING_MODEM_SETTINGS ),	// resource for dialog
								 NULL,												// no parent
								 IncomingSettingsDialogProc,						// dialog message proc
								 reinterpret_cast<LPARAM>( pModemEndpoint )			// startup parameter
								 );
	if ( iDlgReturn != g_iExpectedIncomingModemSettingsReturn )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to start incoming modem settings dialog!" );
		DisplayErrorCode( 0, dwError );
	
		pModemEndpoint->SettingsDialogComplete( DPNERR_OUTOFMEMORY );
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DisplayOutgoingModemSettingsDialog - dialog for Outgoing modem connection
//
// Entry:		Pointer to startup param
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayOutgoingModemSettingsDialog"

void	DisplayOutgoingModemSettingsDialog( void *const pContext )
{
	INT_PTR			iDlgReturn;
	CModemEndpoint	*pModemEndpoint;


	DNASSERT( pContext != NULL );

	//	
	// intialize
	//
	pModemEndpoint = static_cast<CModemEndpoint*>( pContext );

	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LPARAM ) );
	SetLastError( ERROR_SUCCESS );
	iDlgReturn = DialogBoxParam( g_hDLLInstance,									// handle of module for resources
								 MAKEINTRESOURCE( IDD_OUTGOING_MODEM_SETTINGS ),	// resource for dialog
								 NULL,												//
								 OutgoingSettingsDialogProc,						// dialog message proc
								 reinterpret_cast<LPARAM>( pModemEndpoint )			// startup parameter
								 );
	if ( iDlgReturn != g_iExpectedOutgoingModemSettingsReturn )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to start outgoing modem settings dialog!" );
		DisplayErrorCode( 0, dwError );
	
		pModemEndpoint->SettingsDialogComplete( DPNERR_OUTOFMEMORY );
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// StopModemSettingsDialog - stop dialog dialog for modem settings
//
// Entry:		Handle of dialog
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "StopModemSettingsDialog"

void	StopModemSettingsDialog( const HWND hDlg )
{
	DNASSERT( hDlg != NULL );
	if ( PostMessage( hDlg, WM_COMMAND, MAKEWPARAM( IDCANCEL, NULL ), NULL ) == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to stop dialog!" );
		DisplayErrorCode( 0, dwError );
		DNASSERT( FALSE );
	}
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// DisplayModemStatusDialog - dialog for modem status
////
//// Entry:		Pointer to destination for dialog handle
////				Pointer to startup param
////
//// Exit:		Error code
//// ------------------------------
//HRESULT	DisplayModemStatusDialog( HWND *const phDialog, CModemEndpoint *const pEndpoint )
//{
//	HRESULT	hr;
//	HWND	hDialog;
//
//
//	// intialize
//	hr = DPN_OK;
//
//	DBG_CASSERT( sizeof( pEndpoint ) == sizeof( LPARAM ) );
//	hDialog = CreateDialogParam( g_hDLLInstance,							// handle of module for resources
//							  MAKEINTRESOURCE( IDD_MODEM_STATUS ),		// resource for dialog
//							  GetForegroundWindow(),					// parent window (whatever is on top)
//							  ModemStatusDialogProc,					// dialog message proc
//							  reinterpret_cast<LPARAM>( pEndpoint )		// startup parameter
//							  );
//	if ( hDialog == NULL )
//	{
//		DPFX(DPFPREP,  0, "Could not create modem status dialog!" );
//		DisplayErrorCode( 0, GetLastError() );
//		goto Failure;
//	}
//
//	*phDialog = hDialog;
//	ShowWindow( hDialog, SW_SHOW );
//	UpdateWindow( hDialog );
//
//Exit:
//	return	hr;
//
//Failure:
//	goto Exit;
//}
////**********************************************************************
//
//
////**********************************************************************
//// ------------------------------
//// StopModemStatusDialog - stop dialog for modem connection status
////
//// Entry:		Handle of dialog
////
//// Exit:		Nothing
//// ------------------------------
//void	StopModemStatusDialog( const HWND hDialog )
//{
//	DNASSERT( hDialog != NULL );
//
//	if ( SendMessage( hDialog, WM_COMMAND, MAKEWPARAM( IDCANCEL, NULL ), NULL ) != 0 )
//	{
//		// we didn't handle the message
//		DNASSERT( FALSE );
//	}
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// OutgoingSettingsDialogProc - dialog proc for outgoing modem connection
//
// Entry:		Window handle
//				Message LPARAM
//				Message WPARAM
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "OutgoingSettingsDialogProc"

static	INT_PTR CALLBACK OutgoingSettingsDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	CModemEndpoint	*pModemEndpoint;
	HRESULT	hr;

	
	//
	// initialize
	//
	hr = DPN_OK;

	// note the active endpoint pointer
	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LONG_PTR ) );
	pModemEndpoint = reinterpret_cast<CModemEndpoint*>( GetWindowLongPtr( hDialog, GWLP_USERDATA ) );

	switch ( uMsg )
	{
	    // initialize dialog
	    case WM_INITDIALOG:
	    {
	    	// since this is the first dialog message, the default code to set
	    	// pModemEndpoint isn't getting valid data
	    	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( lParam ) );
			pModemEndpoint = reinterpret_cast<CModemEndpoint*>( lParam );
			pModemEndpoint->SetActiveDialogHandle( hDialog );

	    	//
	    	// SetWindowLongPtr() returns NULL in case of error.  It's possible
			// that the old value from SetWindowLongPtr() was really NULL in
			// which case it's not an error.  To be safe, clear any residual
			// error code before calling SetWindowLongPtr().
	    	//
	    	SetLastError( 0 );
	    	if ( SetWindowLongPtr( hDialog, GWLP_USERDATA, lParam ) == NULL )
	    	{
	    		DWORD	dwError;

	    		dwError = GetLastError();
	    		if ( dwError != ERROR_SUCCESS )
	    		{
	    			DPFX(DPFPREP,  0, "Problem setting user data for window!" );
	    			DisplayErrorCode( 0, dwError );
	    			goto Failure;
	    		}
	    	}

	    	//
			// set dialog information
	    	//
			hr = SetModemDataInDialog( GetDlgItem( hDialog, IDC_COMBO_OUTGOING_MODEM_DEVICE ), pModemEndpoint );
			if ( hr != DPN_OK )
	    	{
	    		DPFX(DPFPREP,  0, "Problem setting modem device!" );
	    		DisplayDNError( 0, hr );
	    		goto Failure;
	    	}

	    	hr = SetOutgoingPhoneNumber( hDialog, pModemEndpoint );
			if ( hr != DPN_OK )
	    	{
	    		DPFX(DPFPREP,  0, "Problem setting phone number!" );
	    		DisplayDNError( 0, hr );
	    		goto Failure;
	    	}

	    	return	TRUE;

	    	break;
	    }

	    // a control did something
	    case WM_COMMAND:
	    {
	    	// what was the control?
	    	switch ( LOWORD( wParam ) )
	    	{
	    		case IDOK:
	    		{
	    			hr = SetAddressParametersFromOutgoingDialogData( hDialog, pModemEndpoint );
					if ( hr != DPN_OK )
	    			{
	    				DPFX(DPFPREP,  0, "Problem getting dialog data!" );
	    				DisplayDNError( 0, hr );
	    				goto Failure;
	    			}

	    			// pass any error code on to 'DialogComplete'
	    			pModemEndpoint->SettingsDialogComplete( hr );
	    			EndDialog( hDialog, g_iExpectedOutgoingModemSettingsReturn );

	    			break;
	    		}

	    		case IDCANCEL:
	    		{
	    			pModemEndpoint->SettingsDialogComplete( DPNERR_USERCANCEL );
	    			EndDialog( hDialog, g_iExpectedOutgoingModemSettingsReturn );

	    			break;
	    		}

	    		case IDC_BUTTON_MODEM_CONFIGURE:
	    		{
	    			hr = DisplayModemConfigDialog( hDialog, GetDlgItem( hDialog, IDC_COMBO_OUTGOING_MODEM_DEVICE ), pModemEndpoint );
					if ( hr != DPN_OK )
	    			{
	    				DPFX(DPFPREP,  0, "Problem with DisplayModemConfigDialog in outgoing dialog!" );
	    				DisplayDNError( 0, hr );
	    			}

	    			break;
	    		}
	    	}

	    	break;
	    }

	    // window is closing
	    case WM_CLOSE:
	    {
	    	break;
	    }
	}

Exit:
	return	FALSE;

Failure:
	DNASSERT( pModemEndpoint != NULL );
	DNASSERT( hr != DPN_OK );
	pModemEndpoint->SettingsDialogComplete( hr );
	EndDialog( hDialog, g_iExpectedOutgoingModemSettingsReturn );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// IncomingSettingsDialogProc - dialog proc for incoming modem connection
//
// Entry:		Window handle
//				Message LPARAM
//				Message WPARAM
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "IncomingSettingsDialogProc"

static	INT_PTR CALLBACK IncomingSettingsDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	CModemEndpoint	*pModemEndpoint;
	HRESULT			hr;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// note the modem port pointer
	//
	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LONG_PTR ) );
	pModemEndpoint = reinterpret_cast<CModemEndpoint*>( GetWindowLongPtr( hDialog, GWLP_USERDATA ) );

	switch ( uMsg )
	{
		//
		// initialize dialog
		//
		case WM_INITDIALOG:
		{
			//
			// since this is the first dialog message, the default code to set
			// pModemEndpoint isn't getting valid data
			//
			DBG_CASSERT( sizeof( pModemEndpoint) == sizeof( lParam ) );
			pModemEndpoint = reinterpret_cast<CModemEndpoint*>( lParam );
			pModemEndpoint->SetActiveDialogHandle( hDialog );

			//
			// SetWindowLongPtr() returns NULL in case of error.  It's possible
			// that the old value from SetWindowLongPtr() was really NULL in
			// which case it's not an error.  To be safe, clear any residual
			// error code before calling SetWindowLongPtr().
			//
			SetLastError( 0 );
			if ( SetWindowLongPtr( hDialog, GWLP_USERDATA, lParam ) == NULL )
			{
				DWORD	dwError;


				dwError = GetLastError();
				if ( dwError != ERROR_SUCCESS )
				{
					DPFX(DPFPREP,  0, "Problem setting user data for window!" );
					DisplayErrorCode( 0, dwError );
					goto Failure;
				}
			}

			//
			// set dialog information
			//
			hr = SetModemDataInDialog( GetDlgItem( hDialog, IDC_COMBO_INCOMING_MODEM_DEVICE ), pModemEndpoint );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0, "Problem setting modem device!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			return	TRUE;

			break;
		}

		//
		// a control did something
		//
		case WM_COMMAND:
		{
			// what was the control?
			switch ( LOWORD( wParam ) )
			{
				case IDOK:
				{
					hr = SetAddressParametersFromIncomingDialogData( hDialog, pModemEndpoint );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Problem getting dialog data!" );
						DisplayDNError( 0, hr );
						goto Failure;
					}

					//
					// pass any error code on to 'DialogComplete'
					//
					pModemEndpoint->SettingsDialogComplete( hr );
					EndDialog( hDialog, g_iExpectedIncomingModemSettingsReturn );

					break;
				}

				case IDCANCEL:
				{
					pModemEndpoint->SettingsDialogComplete( DPNERR_USERCANCEL );
					EndDialog( hDialog, g_iExpectedIncomingModemSettingsReturn );

					break;
				}

				case IDC_BUTTON_MODEM_CONFIGURE:
				{
					hr = DisplayModemConfigDialog( hDialog,
												   GetDlgItem( hDialog, IDC_COMBO_INCOMING_MODEM_DEVICE ),
												   pModemEndpoint );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Problem with DisplayModemConfigDialog in incoming dialog!" );
						DisplayDNError( 0, hr );
					}

					break;
				}
			}

			break;
		}

		//
		// window is closing
		//
		case WM_CLOSE:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	return	FALSE;

Failure:
	DNASSERT( pModemEndpoint != NULL );
	DNASSERT( hr != DPN_OK );
	pModemEndpoint->SettingsDialogComplete( hr );
	EndDialog( hDialog, g_iExpectedIncomingModemSettingsReturn );

	goto Exit;
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// ModemStatusDialogProc - dialog proc for modem status
////
//// Entry:		Window handle
////				Message LPARAM
////				Message WPARAM
////
//// Exit:		Error code
//// ------------------------------
//static	INT_PTR CALLBACK ModemStatusDialogProc( HWND hDialog, UINT uMsg, WPARAM wParam, LPARAM lParam )
//{
//	CModemEndpoint	*pModemEndpoint;
//	HRESULT	hr;
//
//	// initialize
//	hr = DPN_OK;
//
//	// note the active endpoint pointer
//	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LONG_PTR ) );
//	pModemEndpoint = reinterpret_cast<CModemEndpoint*>( GetWindowLongPtr( hDialog, GWLP_USERDATA ) );
//
//	switch ( uMsg )
//	{
//		// initialize dialog
//		case WM_INITDIALOG:
//		{
//			// since this is the first dialog message, the default code to set
//			// pModemEndpoint isn't getting valid data
//			DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( lParam ) );
//			pModemEndpoint = reinterpret_cast<CModemEndpoint*>( lParam );
//
//			//
//			// SetWindowLongPtr() returns NULL in case of error.  It's possible
//			// that the old value from SetWindowLongPtr() was really NULL in
//			// which case it's not an error.  To be safe, clear any residual
//			// error code before calling SetWindowLongPtr().
//			//
//			SetLastError( 0 );
//			if ( SetWindowLongPtr( hDialog, GWLP_USERDATA, lParam ) == NULL )
//			{
//				DWORD	dwError;
//
//				dwError = GetLastError();
//				if ( dwError != ERROR_SUCCESS )
//				{
//					DPFX(DPFPREP,  0, "Problem setting user data for window!" );
//					DisplayErrorCode( 0, dwError );
//					goto Failure;
//				}
//			}
//
//			// set dialog information
//
//			return	TRUE;
//
//			break;
//		}
//
//		// a control did something
//		case WM_COMMAND:
//		{
//			// what was the control?
//			switch ( LOWORD( wParam ) )
//			{
//				case IDOK:
//				{
////					HRESULT	hr;
//
//
////					if ( ( hr = GetDialogData( hDialog, pModemEndpoint ) ) != DPN_OK )
////					{
////					    DPFX(DPFPREP,  0, "Problem getting dialog data!" );
////					    DisplayDNError( 0, hr );
////					    goto Failure;
////					}
//
////					// pass any error code on to 'DialogComplete'
////					pModemEndpoint->DialogComplete( hr );
//					DestroyWindow( hDialog );
//
//					break;
//				}
//
////				case IDCANCEL:
////				{
////				    pModemEndpoint->DialogComplete( DPNERR_USERCANCEL );
////				    DestroyWindow( hDialog );
////
////				    break;
////				}
//			}
//
//			break;
//		}
//
//		// window is closing
//		case WM_CLOSE:
//		{
//			break;
//		}
//	}
//
//Exit:
//	return	FALSE;
//
//Failure:
//	DNASSERT( pModemEndpoint != NULL );
//	DNASSERT( hr != DPN_OK );
////	pModemEndpoint->StatusDialogComplete( hr );
//	DestroyWindow( hDialog );
//
//	goto Exit;
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// SetModemDataInDialog - set device for modem dialog
//
// Entry:		Window handle of modem combo box
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetModemDataInDialog"

HRESULT	SetModemDataInDialog( const HWND hComboBox, const CModemEndpoint *const pModemEndpoint )
{
	HRESULT			hr;
	LRESULT			lResult;
	DWORD			dwModemCount;
	MODEM_NAME_DATA	*pModemNameData;
	DWORD			dwModemNameDataSize;
	BOOL			fSelectionSet;
	UINT_PTR		uIndex;


	DNASSERT( hComboBox != NULL );
	DNASSERT( pModemEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pModemNameData = NULL;
	dwModemNameDataSize = 0;
	fSelectionSet = FALSE;

	lResult = SendMessage( hComboBox, CB_RESETCONTENT, 0, 0 );
//	DNASSERT( lResult == CB_OKAY );		// <-- Win2K is busted!!!!

	hr = GenerateAvailableModemList( pModemEndpoint->GetSPData()->GetThreadPool()->GetTAPIInfo(),
									 &dwModemCount,
									 pModemNameData,
									 &dwModemNameDataSize );
	switch ( hr )
	{
		//
		// no modems to list, no more processing to be done
		//
		case DPN_OK:
		{
			goto Exit;
		}

		//
		// expected return
		//
		case DPNERR_BUFFERTOOSMALL:
		{
			break;
		}

		//
		// error
		//
		default:
		{
			DPFX(DPFPREP,  0, "SetModemDataInDialog: Failed to get size of modem list!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

	pModemNameData = static_cast<MODEM_NAME_DATA*>( DNMalloc( dwModemNameDataSize ) );
	if ( pModemNameData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "SetModemDataInDialog: Failed to allocate memory to fill modem dialog list!" );
		goto Failure;
	}

	hr = GenerateAvailableModemList( pModemEndpoint->GetSPData()->GetThreadPool()->GetTAPIInfo(),
									 &dwModemCount,
									 pModemNameData,
									 &dwModemNameDataSize );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "SetModemDataInDialog: Failed to get size of modem list!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	for ( uIndex = 0; uIndex < dwModemCount; uIndex++ )
	{
		LRESULT	AddResult;


		DBG_CASSERT( sizeof( pModemNameData[ uIndex ].pModemName ) == sizeof( LPARAM ) );
		AddResult = SendMessage( hComboBox, CB_INSERTSTRING, 0, reinterpret_cast<const LPARAM>( pModemNameData[ uIndex ].pModemName ) );
		switch ( AddResult )
		{
			case CB_ERR:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem adding serial device to combo box!" );
				goto Failure;

				break;
			}

			case CB_ERRSPACE:
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP,  0, "Out of memory when ading serial device to combo box!" );
				goto Failure;


				break;
			}

			//
			// we added the string OK, set the associated device id and check
			// to see if this is the current value to set selection
			//
			default:
			{	
				LRESULT	SetResult;


				SetResult = SendMessage ( hComboBox, CB_SETITEMDATA, AddResult, pModemNameData[ uIndex ].dwModemID );
				if ( SetResult == CB_ERR )
				{
					DWORD	dwError;


					hr = DPNERR_OUTOFMEMORY;
					dwError = GetLastError();
					DPFX(DPFPREP,  0, "Problem setting modem device info!" );
					DisplayErrorCode( 0, dwError );
					goto Failure;
				}

				if ( pModemEndpoint->GetDeviceID() == uIndex )
				{
					LRESULT	SetSelectionResult;


					SetSelectionResult = SendMessage( hComboBox, CB_SETCURSEL, AddResult, 0 );
					if ( SetSelectionResult == CB_ERR )
					{
						DWORD	dwError;


						hr = DPNERR_GENERIC;
						dwError = GetLastError();
						DPFX(DPFPREP,  0, "Problem setting default modem device selection!" );
						DisplayErrorCode( 0, dwError );
						DNASSERT( FALSE );
						goto Failure;
					}

					fSelectionSet = TRUE;
				}

				break;
			}

		}
	}

	if ( fSelectionSet == FALSE )
	{
		LRESULT	SetSelectionResult;


		SetSelectionResult = SendMessage( hComboBox, CB_SETCURSEL, 0, 0 );
		if ( SetSelectionResult == CB_ERR )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem setting default modem selection!" );
			DisplayErrorCode( 0, dwError );
		}
	}

Exit:
	if ( pModemNameData != NULL )
	{
		DNFree( pModemNameData );
		pModemNameData = NULL;
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetModemSelectionFromDialog - get modem selection from dialog
//
// Entry:		Window handle of modem combo box
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetModemSelectionFromDialog"

static HRESULT	GetModemSelectionFromDialog( const HWND hComboBox, CModemEndpoint *const pModemEndpoint )
{
	HRESULT	hr;
	LRESULT	Selection;
	LRESULT	DeviceID;


	//
	// initialize
	//
	hr = DPN_OK;

	if ( hComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Invalid control handle passed to GetModemSelectionFromDialog!" );
		goto Failure;
	}

	//
	// get modem selection
	//
	Selection = SendMessage( hComboBox, CB_GETCURSEL, 0, 0 );
	if ( Selection == CB_ERR )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Could not get current modem selection!" );
		DNASSERT( FALSE );
		goto Failure;
	}

	//
	// get device ID
	//
	DeviceID = SendMessage( hComboBox, CB_GETITEMDATA, Selection, 0 );
	if ( DeviceID == CB_ERR )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Could not get selection item data!" );
		DNASSERT( FALSE );
		goto Failure;
	}

	//
	// Now that we finally have the device ID, set it.  Make sure
	// we clear any existing ID first, or the ID setting code will
	// complain.  I like paranoid code, so work around the ASSERT.
	//
	DNASSERT( DeviceID <= UINT32_MAX );
	hr = pModemEndpoint->SetDeviceID( INVALID_DEVICE_ID );
	DNASSERT( hr == DPN_OK );

	hr = pModemEndpoint->SetDeviceID( static_cast<DWORD>( DeviceID ) );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem setting modem device ID!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetOutgoingPhoneNumber - set phone number for modem dialog
//
// Entry:		Window handle
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetOutgoingPhoneNumber"

HRESULT	SetOutgoingPhoneNumber( const HWND hDialog, const CModemEndpoint *const pModemEndpoint )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

	if ( SetWindowText( GetDlgItem( hDialog, IDC_EDIT_MODEM_PHONE_NUMBER ), pModemEndpoint->GetPhoneNumber() ) == FALSE )
	{
	    DPFX(DPFPREP,  0, "Problem setting default phone number!" );
	    DisplayErrorCode( 0, GetLastError() );
	    goto Exit;
	}

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetAddressParamtersFromIncomingDialogData - set address data from incoming modem settings dialog
//
// Entry:		Window handle
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetAddressParametersFromIncomingDialogData"

static	HRESULT	SetAddressParametersFromIncomingDialogData( const HWND hDialog, CModemEndpoint *const pModemEndpoint )
{
	HRESULT	hr;
	HWND	hControl;


	//
	// initialize
	//
	hr = DPN_OK;
	hControl = GetDlgItem( hDialog, IDC_COMBO_INCOMING_MODEM_DEVICE );
	if ( hControl == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	hr = GetModemSelectionFromDialog( hControl, pModemEndpoint );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem getting modem device!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Failure:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetAddressParamtersFromOutgoingDialogData - set endpoint data from outgoing modem settings dialog
//
// Entry:		Window handle
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetAddressParametersFromOutgoingDialogData"

static	HRESULT	SetAddressParametersFromOutgoingDialogData( const HWND hDialog, CModemEndpoint *const pModemEndpoint )
{
	HRESULT	hr;
	HWND	hControl;
	DWORD	dwPhoneNumberLength;
	TCHAR	TempBuffer[ MAX_PHONE_NUMBER_LENGTH + 1 ];


	DNASSERT( hDialog != NULL );
	DNASSERT( pModemEndpoint != NULL );

	// initialize
	hr = DPN_OK;
	hControl = GetDlgItem( hDialog, IDC_COMBO_OUTGOING_MODEM_DEVICE );
	if ( hControl == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of combo box!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	hr = GetModemSelectionFromDialog( hControl, pModemEndpoint );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem getting modem device!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	// get phone number from dialog
	hControl = GetDlgItem( hDialog, IDC_EDIT_MODEM_PHONE_NUMBER );
	if ( hControl == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting handle of phone number edit field!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}

	dwPhoneNumberLength = GetWindowText( hControl, TempBuffer, (sizeof(TempBuffer)/sizeof(TCHAR)) - 1 );
	if ( dwPhoneNumberLength == 0 )
	{
		DWORD	dwErrorReturn;


		dwErrorReturn = GetLastError();
		switch ( dwErrorReturn )
		{
			//
			// the user didn't enter a full phone number
			//
			case S_OK:
			{
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP,  0, "User entered a blank phone number in dialog!" );
				goto Failure;

				break;
			}

			default:
			{
				hr = DPNERR_GENERIC;
				DPFX(DPFPREP,  0, "Problem getting phone number from dialog!" );
				DNASSERT( FALSE );
				goto Failure;

				break;
			}
		}
	}
	else
	{
		hr = pModemEndpoint->SetPhoneNumber( TempBuffer );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Problem setting new phone number!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}

Failure:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DisplayModemConfigDialog - display dialog to configure modem
//
// Entry:		Window handle
//				Pointer to modem port
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayModemConfigDialog"

static	HRESULT	DisplayModemConfigDialog( const HWND hDialog, const HWND hDeviceComboBox, CModemEndpoint *const pModemEndpoint )
{
	HRESULT	hr;
	LRESULT	lSelection;
	LRESULT	lDeviceID;
	LONG	lTAPIReturn;


	DNASSERT( hDialog != NULL );
	DNASSERT( pModemEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	if ( hDeviceComboBox == NULL )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Invalid device combo box handle!" );
		goto Exit;
	}

	//
	// ask for current selection in combo box
	//
	lSelection = SendMessage( hDeviceComboBox, CB_GETCURSEL, 0, 0 );
	if ( lSelection == CB_ERR )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Failed to get current modem selection when configuring modem!" );
		DNASSERT( FALSE );
		goto Exit;
	}

	//
	// ask for the device ID for this selection, note that the device IDs are
	//
	lDeviceID = SendMessage( hDeviceComboBox, CB_GETITEMDATA, lSelection, 0 );
	if ( lDeviceID == CB_ERR )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem getting device ID from selected modem when calling for config dialog!" );
		goto Exit;
	}

	// display dialog
	DNASSERT( lDeviceID <= UINT32_MAX );
	lTAPIReturn = p_lineConfigDialog( TAPIIDFromModemID( static_cast<DWORD>( lDeviceID ) ),
									  hDialog,
									  TEXT("comm/datamodem") );
	if ( lTAPIReturn != LINEERR_NONE )
	{
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP,  0, "Problem with modem config dialog!" );
		DisplayTAPIError( 0, lTAPIReturn );
		goto Exit;
	}

Exit:
	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\modemui.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ModemUI.h
 *  Content:	Modem service provider UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/25/99	jtk		Created
 ***************************************************************************/

#ifndef __MODEM_UI_H__
#define __MODEM_UI_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
void	DisplayIncomingModemSettingsDialog( void *const pContext );
void	DisplayOutgoingModemSettingsDialog( void *const pContext );
void	StopModemSettingsDialog( const HWND hDialog );

HRESULT	DisplayModemStatusDialog( void *const pContext );
void	StopModemStatusDialog( const HWND hDialog );

#endif	// __MODEM_UI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\modemendpoint.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ModemEndpoint.h
 *  Content:	DNSerial communications modem endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/98	jtk		Created
 ***************************************************************************/

#ifndef __MODEM_ENDPOINT_H__
#define __MODEM_ENDPOINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	MAX_PHONE_NUMBER_SIZE	200

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CModemEndpoint : public CEndpoint
{
	public:
		CModemEndpoint();
		~CModemEndpoint();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetOwningPool"
		void	SetOwningPool( CLockedContextFixedPool< CModemEndpoint, ENDPOINT_POOL_CONTEXT* > *pOwningPool )
		{
			DEBUG_ONLY( DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) ) );
			m_pOwningPool = pOwningPool;
		}
		void	ReturnSelfToPool( void );
		
		IDirectPlay8Address	*GetRemoteHostDP8Address( void ) const;
		IDirectPlay8Address	*GetLocalAdapterDP8Address( const ADDRESS_TYPE AddressType ) const;
		
		
		//
		// UI functions
		//
		HRESULT	ShowOutgoingSettingsDialog( CThreadPool *const pThreadPool );
		HRESULT	ShowIncomingSettingsDialog( CThreadPool *const pThreadPool );
		void	StopSettingsDialog( const HWND hDialog );

		//
		// port settings
		//
		DWORD	GetDeviceID( void ) const { return m_dwDeviceID; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetDeviceID"
		HRESULT	SetDeviceID( const DWORD dwDeviceID )
		{
			DNASSERT( ( m_dwDeviceID == INVALID_DEVICE_ID ) || ( dwDeviceID == INVALID_DEVICE_ID ) );
			m_dwDeviceID = dwDeviceID;
			return	DPN_OK;
		}

		const TCHAR	*GetPhoneNumber( void ) const { return m_PhoneNumber; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CModemEndpoint::SetPhoneNumber"
		HRESULT	SetPhoneNumber( const TCHAR *const pPhoneNumber )
		{
			DNASSERT( pPhoneNumber != NULL );
			DNASSERT( lstrlen( pPhoneNumber ) < sizeof( m_PhoneNumber ) );
			lstrcpy( m_PhoneNumber, pPhoneNumber );
			return	DPN_OK;
		}

		//
		// pool functions
		//
		BOOL	PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pContext );
		BOOL	PoolInitFunction( ENDPOINT_POOL_CONTEXT *pContext );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );

	protected:

		const GUID	*GetEncryptionGuid( void ) const { return &g_ModemSPEncryptionGuid; }

	private:
		BYTE			m_Sig[4];	// debugging signature ('MOEP')
		
		CLockedContextFixedPool< CModemEndpoint, ENDPOINT_POOL_CONTEXT* >	*m_pOwningPool;
		DWORD	m_dwDeviceID;
		TCHAR	m_PhoneNumber[ MAX_PHONE_NUMBER_SIZE ];

		HRESULT	Open( IDirectPlay8Address *const pHostAddress,
					  IDirectPlay8Address *const pAdapterAddress,
					  const LINK_DIRECTION LinkDirection,
					  const ENDPOINT_TYPE EndpointType );
		HRESULT	OpenOnListen( const CEndpoint *const pListenEndpoint );
		void	Close( const HRESULT hActiveCommandResult );
		DWORD	GetLinkSpeed( void ) { DNASSERT( FALSE ); return 0; }

		void	*DeviceBindContext( void ) { return &m_dwDeviceID; }
		void	EnumComplete( const HRESULT hCompletionCode );
		const void	*GetDeviceContext( void ) const;

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CModemEndpoint( const CModemEndpoint & );
		CModemEndpoint& operator=( const CModemEndpoint & );
};

#undef DPF_MODNAME

#endif	// __MODEM_ENDPOINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\modemutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ModemUtils.cpp
 *  Content:	Service provider modem utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/03/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


#define	DPF_MODNAME	"ModemUtils"

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	TAPI_MESSAGE_EVENT_INDEX	1
#define	ENDPOINT_DISCONNECTED_EVENT_INDEX	2

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// ProcessWin9xTAPIMessage - process a TAPI message
//
// Entry:		Pointer to DNSP interface
//
// Exit:		Nothing
// ------------------------------
void	ProcessWin9xTAPIMessage( DNSPI_DNSP_INT *pThis )
{
	DWORD	dwLineReturn;
	LINEMESSAGE	LineMessage;


	DNASSERT( pThis != NULL );

	// get message
	dwLineReturn = lineGetMessage( pThis->pSPData->GetTAPIInstance(), &LineMessage, 0 );
	if ( dwLineReturn == LINEERR_NONE )
	{
		CModemEndpoint	*pModemEndpoint;


		// tell endpoint
		DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( LineMessage.dwCallbackInstance ) );
		pModemEndpoint = reinterpret_cast<CModemEndpoint*>( LineMessage.dwCallbackInstance );
		DNASSERT( pModemEndpoint != NULL );
		DisplayTAPIMessage( 8, &LineMessage );
DNASSERT( FALSE );
//		pModemEndpoint->ProcessTAPIMessage( &LineMessage );
	}
	else
	{
		DNASSERT( ( (INT) dwLineReturn ) < 0 );
		DisplayTAPIError( 0, dwLineReturn );

		// an invalid application handle will happen on SP close
		if ( dwLineReturn != LINEERR_INVALAPPHANDLE )
		{
			DNASSERT( FALSE );
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ProcessWinNTTAPIMessage - process a TAPI message
//
// Entry:		Pointer to DNSP interface
//				Pointer to line message
//
// Exit:		Nothing
// ------------------------------
void	ProcessWinNTTAPIMessage( DNSPI_DNSP_INT *pThis, LINEMESSAGE *pLineMessage )
{
	CModemEndpoint	*pModemEndpoint;


	DNASSERT( pThis != NULL );
	DNASSERT( pLineMessage != NULL );

	//
	// tell endpoint about message
	//
	DBG_CASSERT( sizeof( pModemEndpoint ) == sizeof( pLineMessage->dwCallbackInstance ) );
	pModemEndpoint = reinterpret_cast<CModemEndpoint*>( pLineMessage->dwCallbackInstance );
	DNASSERT( pModemEndpoint != NULL );
	DisplayTAPIMessage( 8, pLineMessage );
DNASSERT( FALSE );
	//	pModemEndpoint->ProcessTAPIMessage( pLineMessage );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\modemutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ModemUtils.h
 *  Content:	Service provider modem utilitiy functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/03/98	jtk		Created
 ***************************************************************************/

#ifndef __MODEM_UTILS_H__
#define __MODEM_UTILS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

void	ProcessWin9xTAPIMessage( DNSPI_DNSP_INT *pThis );
void	ProcessWinNTTAPIMessage( DNSPI_DNSP_INT *pThis, LINEMESSAGE *pMessage );

#endif	// __MODEM_UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dnserial.rc
//
#define IDS_BAUD_9600                   7
#define IDS_BAUD_14400                  8
#define IDS_BAUD_19200                  9
#define IDS_BAUD_38400                  10
#define IDS_BAUD_56000                  11
#define IDS_BAUD_57600                  12
#define IDS_BAUD_115200                 13

#define IDS_STOPBITS_ONE                16
#define IDS_STOPBITS_ONE5               17
#define IDS_STOPBITS_TWO                18

#define IDS_PARITY_EVEN                 19
#define IDS_PARITY_MARK                 20
#define IDS_PARITY_NONE                 21
#define IDS_PARITY_ODD                  22
#define IDS_PARITY_SPACE                23

#define IDS_FLOW_NONE                   24
#define IDS_FLOW_XONXOFF                25
#define IDS_FLOW_RTS                    26
#define IDS_FLOW_DTR                    27
#define IDS_FLOW_RTSDTR                 28

#define IDS_FRIENDLYNAME_MODEM          29
#define IDS_FRIENDLYNAME_SERIAL         30
#define IDD_SERIAL_SETTINGS             101
#define IDD_OUTGOING_MODEM_SETTINGS     102
#define IDD_INCOMING_MODEM_SETTINGS     103
#define IDD_MODEM_STATUS                105
#define IDC_STATIC_SERIAL_DEVICE        1000
#define IDC_STATIC_SERIAL_BAUD          1001
#define IDC_STATIC_SERIAL_STOPBITS      1002
#define IDC_STATIC_SERIAL_PARITY        1003
#define IDC_STATIC_SERIAL_FLOWCONTROL   1004
#define IDC_COMBO_SERIAL_DEVICE         1005
#define IDC_COMBO_SERIAL_BAUDRATE       1006
#define IDC_STATIC_OUTGOING_MODEM_DEVICE 1006
#define IDC_COMBO_SERIAL_STOPBITS       1007
#define IDC_STATIC_MODEM_PHONE_NUMBER   1007
#define IDC_COMBO_SERIAL_PARITY         1008
#define IDC_EDIT_MODEM_PHONE_NUMBER     1008
#define IDC_COMBO_SERIAL_FLOWCONTROL    1009
#define IDC_COMBO_OUTGOING_MODEM_DEVICE 1009
#define IDC_BUTTON_MODEM_CONFIGURE      1010
#define IDC_STATIC_SERIAL_PORT_SETTINGS 1011
#define IDC_STATIC_INCOMING_MODEM_DEVICE 1012
#define IDC_COMBO_INCOMING_MODEM_DEVICE 1013
#define IDC_STATIC_MODEM_STATUS         1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\parseclass.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ParseClass.cpp
 *  Content:	Parsing class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	121/02/99	jtk		Derived from IPXAddress.cpp
 *  01/10/20000	rmt		Updated to build with Millenium build process
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************
//
// default buffer size to use when parsing address components
//
#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CParseClass::ParseDP8Address - parse a DirectPlay8 address
//
// Entry:		Pointer to DP8Address
//				Pointer to expected SP guid
//				Pointer to parse keys
//				Count of parse keys
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CParseClass::ParseDP8Address"

HRESULT	CParseClass::ParseDP8Address( IDirectPlay8Address *const pDP8Address,
									  const GUID *const pSPGuid,
									  const PARSE_KEY *const pParseKeys,
									  const UINT_PTR uParseKeyCount )
{
	HRESULT		hr;
	BOOL		fParsing;
	GUID		Guid;
	void		*pAddressComponent;
	DWORD		dwComponentSize;
	DWORD		dwAllocatedComponentSize;
	UINT_PTR	uIndex;


	DNASSERT( pDP8Address != NULL );
	DNASSERT( pSPGuid != NULL );
	DNASSERT( pParseKeys != NULL );
	DNASSERT( uParseKeyCount != 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	fParsing = TRUE;
	dwAllocatedComponentSize = DEFAULT_COMPONENT_BUFFER_SIZE;
	uIndex = uParseKeyCount;

	pAddressComponent = DNMalloc( dwAllocatedComponentSize );
	if ( pAddressComponent == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "ParseClass: failed to allocate temp buffer for parsing" );
		goto Exit;
	}

	//
	// verify SPType
	//
	hr = IDirectPlay8Address_GetSP( pDP8Address, &Guid );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "ParseClass: failed to verify service provider type!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	if ( IsEqualCLSID( *pSPGuid, Guid ) == FALSE )
	{
		hr = DPNERR_ADDRESSING;
		DPFX(DPFPREP,  0, "Service provider guid mismatch during parse!" );
		goto Exit;
	}

	//
	// parse
	//
	while ( uIndex != 0 )
	{
		HRESULT		hTempResult;
		DWORD		dwDataType;


		uIndex--;
		DNASSERT( pAddressComponent != NULL );
		dwComponentSize = dwAllocatedComponentSize;

Reparse:
		hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address,					// pointer to address
															  pParseKeys[ uIndex ].pKey,	// pointer to key to search for
															  pAddressComponent,			// pointer to value destination
															  &dwComponentSize,				// pointer to value destination size
															  &dwDataType );				// pointer to data type
		switch ( hTempResult )
		{
			//
			// component parsed successfully, figure out what it is by checking
			// key length and then comparing key strings
			//
			case DPN_OK:
			{
				hr = pParseKeys[ uIndex ].pParseFunc( pAddressComponent,
													  dwComponentSize,
													  dwDataType,
													  pParseKeys[ uIndex ].pContext
													  );
				if ( hr != DPN_OK )
				{
					goto Exit;
				}

				break;
			}

			//
			// buffer too small, reallocate and try again
			//
			case DPNERR_BUFFERTOOSMALL:
			{
				void	*pTemp;


				DNASSERT( dwComponentSize > dwAllocatedComponentSize );
				pTemp = DNRealloc( pAddressComponent, dwComponentSize );
				if ( pTemp == NULL )
				{
					hr = DPNERR_OUTOFMEMORY;
					goto Exit;
				}
					
				dwAllocatedComponentSize = dwComponentSize;
				pAddressComponent = pTemp;

				goto Reparse;

				break;
			}

			//
			// Missing component.  Skip this component and
			// look for other parsing errors.
			//
			case DPNERR_DOESNOTEXIST:
			{
				break;
			}

			//
			// error
			//
			default:
			{
				hr = hTempResult;
				DPFX(DPFPREP,  0, "ParseClass: Problem parsing address!" );
				DisplayDNError( 0, hr );
				DNASSERT( FALSE );
				goto Exit;

				break;
			}
		}
	}

Exit:
	if ( pAddressComponent != NULL )
	{
		DNFree( pAddressComponent );
		pAddressComponent = NULL;
	}

	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\parseclass.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ParseClass.h
 *  Content:	Class to perform parsing
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/02/99	jtk		Derived from IPXEndpt.h
 ***************************************************************************/

#ifndef __PARSE_CLASS_H__
#define __PARSE_CLASS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// function prototype for parse callback
//
typedef	HRESULT	(*PPARSE_CALLBACK)( const void *const pAddressComponent,
									const DWORD dwComponentLength,
									const DWORD dwComponentType,
									void *const pContext );

//
// structure for parse key
//
typedef	struct	_PARSE_KEY
{
	const WCHAR	*pKey;			// key name
	UINT_PTR	uKeyLength;		// length of key (without NULL!)
	void 		*pContext;		// pointer to callback context
	PPARSE_CALLBACK	pParseFunc;	// callback when this key is encountered
} PARSE_KEY, *PPARSE_KEY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for command data
//
class	CParseClass
{
	public:
		CParseClass(){}
		~CParseClass(){}

		HRESULT	ParseDP8Address( IDirectPlay8Address *const pDNAddress,
								 const GUID *const pSPGuid,
								 const PARSE_KEY *const pParseKeys,
								 const UINT_PTR uParseKeyCount );
	protected:

	private:
		//
		// prevent unwarranted copies
		//
		CParseClass( const CParseClass & );
		CParseClass& operator=( const CParseClass & );
};


#endif	// __PARSE_CLASS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\serialsp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SerialSP.h
 *  Content:	Service provider interface functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/09/98	jtk		Derived from SerialUtil.h
 *	09/23/99	jtk		Derived from SerialCore.h
 ***************************************************************************/

#ifndef __SERIAL_SP_H__
#define __SERIAL_SP_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_MODEM

//
// including a header file in another header isn't that good, but it's the easiest thing
// to do right now since #defines need to be set first.
//
#define		MAX_TAPI_VERSION	0x00020000
#define		TAPI_CURRENT_VERSION	MAX_TAPI_VERSION
#include	<tapi.h>

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// maximum number of data ports
//
#define	MAX_DATA_PORTS	128

//
// enumeration of types of SP
//
typedef enum
{
	TYPE_UNKNOWN,		// unknown type
	TYPE_MODEM,			// modem type
	TYPE_SERIAL			// serial type

} SP_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CSPData;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

STDAPI DNSP_Initialize(IDP8ServiceProvider*, PSPINITIALIZEDATA);
STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8ServiceProvider* lpDNSP );
STDMETHODIMP_(ULONG) DNSP_Release(IDP8ServiceProvider* lpDNSP);
STDMETHODIMP DNSP_Connect(IDP8ServiceProvider*, PSPCONNECTDATA);
STDMETHODIMP DNSP_Disconnect(IDP8ServiceProvider*, PSPDISCONNECTDATA);
STDMETHODIMP DNSP_Listen(IDP8ServiceProvider*, PSPLISTENDATA);
STDMETHODIMP DNSP_EnumQuery(IDP8ServiceProvider*, PSPENUMQUERYDATA);
STDMETHODIMP DNSP_EnumRespond(IDP8ServiceProvider*, PSPENUMRESPONDDATA);
STDMETHODIMP DNSP_SendData(IDP8ServiceProvider*, PSPSENDDATA);
STDMETHODIMP DNSP_CancelCommand(IDP8ServiceProvider*, HANDLE, DWORD);
STDMETHODIMP DNSP_Close(IDP8ServiceProvider*);
STDMETHODIMP DNSP_GetCaps(IDP8ServiceProvider*, PSPGETCAPSDATA);
STDMETHODIMP DNSP_SetCaps(IDP8ServiceProvider*, PSPSETCAPSDATA);
STDMETHODIMP DNSP_ReturnReceiveBuffers(IDP8ServiceProvider*, SPRECEIVEDBUFFER* );
STDMETHODIMP DNSP_GetAddressInfo(IDP8ServiceProvider*, SPGETADDRESSINFODATA* );
STDMETHODIMP DNSP_IsApplicationSupported(IDP8ServiceProvider*, SPISAPPLICATIONSUPPORTEDDATA* );
STDMETHODIMP DNSP_EnumAdapters(IDP8ServiceProvider*, SPENUMADAPTERSDATA* );

STDMETHODIMP DNSP_NotSupported( IDP8ServiceProvider*, PVOID );

#endif	// __SERIAL_SP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dpnmodem
DLLDEF=..\dpnmodem.def
UMTYPE=windows

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnmdmi.h
PRECOMPILED_PCH=dnmdmi.pch
PRECOMPILED_OBJ=dnmdmi.obj
!endif

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           ..\..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
           ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=$(DXROOT)\inc;..\..\..\inc;..\..\..\common;..\


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\DNSerial.rc \
	 ..\dpnmodemclassfac.cpp \
	 ..\ComEndpoint.cpp \
	 ..\CommandData.cpp \
	 ..\ComPort.cpp \
	 ..\ComPortData.cpp \
	 ..\ComportUI.cpp \
	 ..\CRC.cpp \
	 ..\DataPort.cpp \
	 ..\dpnmodemendpoint.cpp \
  	 ..\dpnmodemhandletable.cpp \
	 ..\dpnmodemiodata.cpp \
	 ..\dpnmodemjobqueue.cpp \
	 ..\dpnmodemlocals.cpp \
         ..\ModemEndpoint.cpp \
	 ..\ModemPort.cpp \
	 ..\ModemUI.cpp \
	 ..\ParseClass.cpp \
	 ..\dpnmodempools.cpp \
	 ..\dpnmodemsendqueue.cpp \
	 ..\SerialSP.cpp \
	 ..\dpnmodemspdata.cpp \
	 ..\dpnmodemthreadpool.cpp \
	 ..\dpnmodemunk.cpp \
	 ..\dpnmodemutils.cpp \

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL /DCINTERFACE

USE_NOLIBS=1

DLLENTRY=_DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\serialsp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   SerialSP.cpp
 *  Content:	Service provider serial interface functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/03/98	jtk		Created
 *	09/23/99	jtk		Derived from ComCore.cpp
 ***************************************************************************/

#include "dnmdmi.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

static	GUID	g_InvalidAdapterGuid = { 0 };

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_AddRef - increment interface reference cound
//
// Entry:		Pointer to interface
//
// Exit:		Current interface reference count
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_AddRef"

STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8ServiceProvider *pThis )
{
	CSPData *	pSPData;
	ULONG		ulResult;


	DPFX(DPFPREP, 2, "Parameters: (0x%p)", pThis);

	DNASSERT( pThis != NULL );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	
	ulResult = pSPData->AddRef();

	
	DPFX(DPFPREP, 2, "Returning: [0x%u]", ulResult);
	
	return ulResult;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_Release - release an interface
//
// Entry:		Pointer to current interface
//				Desired interface ID
//				Pointer to pointer to new interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_Release"

STDMETHODIMP_(ULONG) DNSP_Release( IDP8ServiceProvider *pThis )
{
	CSPData *	pSPData;
	ULONG		ulResult;

	
	DNASSERT( pThis != NULL );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	
	ulResult = pSPData->DecRef();

	
	DPFX(DPFPREP, 2, "Returning: [0x%u]", ulResult);
	
	return ulResult;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_Initialize - initialize SP interface
//
// Entry:	Pointer to interface
//			Pointer to initialization data
//
// Exit:	Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_Initialize"

STDMETHODIMP	DNSP_Initialize( IDP8ServiceProvider *pThis, SPINITIALIZEDATA *pData )
{
	HRESULT				hr;
	CSPData				*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pData);

	DNASSERT( pThis != NULL );
	DNASSERT( pData != NULL );

	
	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	DNASSERT( IsSerialGUID( pSPData->GetServiceProviderGuid() ) != FALSE );

	//
	// prevent anyone else from messing with this interface and bump up the reference
	// count
	//
	pSPData->Lock();

	//
	// check interface state
	//
	switch ( pSPData->GetState() )
	{
		//
		// uninitialized interface, we can initialize it
		//
		case SPSTATE_UNINITIALIZED:
		{
			break;
		}

		//
		// other state
		//
		case SPSTATE_INITIALIZED:
		case SPSTATE_CLOSING:
		default:
		{
			hr = DPNERR_ALREADYINITIALIZED;
			DPFX(DPFPREP,  0, "Attempted to reinitialize interface!" );
			DNASSERT( FALSE );

			goto Exit;
		}
	}

	//
	// before we get too far, check for the availablility of serial ports or
	// modems
	//
	switch ( pSPData->GetType() )
	{
		case TYPE_SERIAL:
		{
			BOOL	fPortAvailable[ MAX_DATA_PORTS ];
			DWORD	dwPortCount;


			hr = GenerateAvailableComPortList( fPortAvailable, ( LENGTHOF( fPortAvailable ) - 1 ), &dwPortCount );
			if ( ( hr != DPN_OK ) || ( dwPortCount == 0 ) )
			{
				hr = DPNERR_UNSUPPORTED;
				goto Failure;
			}

			break;
		}

		case TYPE_MODEM:
		{
			if ( pSPData->GetThreadPool()->TAPIAvailable() != FALSE )
			{
				DWORD	dwModemCount;
				DWORD	dwModemNameDataSize;
				HRESULT	hTempResult;


				//
				// Get count of available modems.  If this call succeeds but there
				// are no modems returned, fail.
				//
				dwModemCount = 0;
				dwModemNameDataSize = 0;
				hTempResult = GenerateAvailableModemList( pSPData->GetThreadPool()->GetTAPIInfo(),
														  &dwModemCount,
														  NULL,
														  &dwModemNameDataSize );
				if ( ( hTempResult != DPNERR_BUFFERTOOSMALL ) && ( hTempResult != DPN_OK ) )
				{
					hr = hTempResult;
					DPFX(DPFPREP,  0, "Failed to detect available modems!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}

				if ( dwModemCount == 0 )
				{
					DPFX(DPFPREP,  1, "No modems detected!" );
					hr = DPNERR_UNSUPPORTED;
					goto Failure;
				}

				DNASSERT( hr == DPN_OK );
			}
			else
			{
				DPFX(DPFPREP,  0, "TAPI not available!" );
				hr = DPNERR_UNSUPPORTED;
				goto Failure;
			}

			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// remember the init data
	//
	pSPData->SetCallbackData( pData );
		
	//
	// Success from here on in
	//
	IDP8SPCallback_AddRef( pSPData->DP8SPCallbackInterface() );
	pSPData->SetState( SPSTATE_INITIALIZED );
	pSPData->Unlock();
	
	IDP8ServiceProvider_AddRef( pThis );

Exit:
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	pSPData->Unlock();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_Close - close this instance of the service provier
//
// Entry:		Pointer to the service provider to close
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_Close"

STDMETHODIMP	DNSP_Close( IDP8ServiceProvider *pThis )
{
	HRESULT		hr;
	CSPData		*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p)", pThis);

	DNASSERT( pThis != NULL );
	
	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	switch ( pSPData->GetType() )
	{
		case TYPE_SERIAL:
		case TYPE_MODEM:
		{
			//
			// release our ref to the DPlay callbacks
			//
			pSPData->Shutdown();
			IDP8ServiceProvider_Release( pThis );
			
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_Connect - start process to establish comport connection to a remote host
//
// Entry:		Pointer to the service provider interface
//				Pointer to connection data
//
// Exit:		Error Code
//
// Note:	Any command handle allocated by this function is closed by the
//			endpoint.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_Connect"

STDMETHODIMP	DNSP_Connect( IDP8ServiceProvider *pThis, SPCONNECTDATA *pConnectData )
{
	HRESULT			hr;
	HRESULT			hTempResult;
	CSPData			*pSPData;
	CEndpoint   	*pEndpoint;
	CCommandData	*pCommand;
	BOOL			fEndpointOpen;
	GUID			DeviceGUID;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pConnectData);

	DNASSERT( pThis != NULL );
	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->pAddressHost != NULL );
	DNASSERT( pConnectData->pAddressDeviceInfo != NULL );
	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOQUERY ) ) == 0 );


	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	pEndpoint = NULL;
	pCommand = NULL;
	fEndpointOpen = FALSE;
	pConnectData->hCommand = NULL;
	pConnectData->dwCommandDescriptor = NULL_DESCRIPTOR;


	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.
	//
	hTempResult = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}

	
	//
	// validate state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "DNSP_Connect called on uninitialized SP!" );
			goto Failure;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "DNSP_Connect called while SP closing!" );
			goto Failure;

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		DNASSERT( hr != DPN_OK );
		goto Failure;
	}

	//
	// check for invalid device ID
	//
	hTempResult = IDirectPlay8Address_GetDevice( pConnectData->pAddressDeviceInfo, &DeviceGUID );
	switch ( hTempResult )
	{
	    //
	    // there was a device ID, check against g_InvalidAdapterGuid
	    //
	    case DPN_OK:
	    {
	    	if ( IsEqualCLSID( DeviceGUID, g_InvalidAdapterGuid ) != FALSE )
	    	{
	    		hr = DPNERR_ADDRESSING;
	    		DPFX(DPFPREP,  0, "GUID_NULL was apecified as a serial/modem device!" );
	    		goto Failure;
	    	}
	    	break;
	    }

	    //
	    // no device address specified, not a problem
	    //
	    case DPNERR_DOESNOTEXIST:
	    {
	    	break;
	    }

	    //
	    // other, stop and figure out why we're here
	    //
	    default:
	    {
			DNASSERT( FALSE );
	    	hr = hTempResult;
	    	DPFX(DPFPREP,  0, "Failed to validate device address!" );
	    	DisplayDNError( 0, hTempResult );
	    	break;
	    }
	}

	//
	// get endpoint for this connection
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNSP_Connect: Cannot create new endpoint!" );
		goto Failure;
	}

	//
	// get new command
	//
	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNSP_Connect: Cannot get command handle!" );
		goto Failure;
	}

	//
	// initialize command
	//
	pConnectData->hCommand = pCommand;
	pConnectData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_CONNECT );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open this endpoint
	//
	hTempResult = pEndpoint->Open( pConnectData->pAddressHost,
								   pConnectData->pAddressDeviceInfo,
								   LINK_DIRECTION_OUTGOING,
								   ENDPOINT_TYPE_CONNECT );
	switch ( hTempResult )
	{
		//
		// endpoint opened, no problem
		//
		case DPN_OK:
		{
			//
			// copy connect data and the submit background job
			//
			fEndpointOpen = TRUE;
			pEndpoint->CopyConnectData( pConnectData );
			pEndpoint->AddRef();

			hTempResult = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->ConnectJobCallback,
																		  pEndpoint->CancelConnectJobCallback,
																		  pEndpoint );
			if ( hTempResult != DPN_OK )
			{
				pEndpoint->DecRef();
				hr = hTempResult;
				DPFX(DPFPREP,  0, "Failed to set delayed listen!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		//
		// not all of the addressing information was specifed, need to query user
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
			{
				//
				// copy connect data for future reference and then start the dialog
				//
				fEndpointOpen = TRUE;
				pEndpoint->CopyConnectData( pConnectData );

				hTempResult = pEndpoint->ShowOutgoingSettingsDialog( pSPData->GetThreadPool() );
				if ( hTempResult != DPN_OK )
				 {
					hr = hTempResult;
					DPFX(DPFPREP,  0, "DNSP_Connect: Problem showing settings dialog!" );
					DisplayDNError( 0, hTempResult );

					goto Failure;
				 }

				//
				// this endpoint has been handed off, remove our reference to it
				//
				pEndpoint = NULL;
				DNASSERT( hr == DPNERR_PENDING );

				goto Exit;
			}
			else
			{
				hr = hTempResult;
				goto Failure;
			}

			break;
		}

		default:
		{
			hr = hTempResult;
			DPFX(DPFPREP,  0, "DNSP_Connect: Problem opening endpoint with host address!" );
			DisplayDNError( 0, hTempResult );
			goto Failure;

			break;
		}
	}
Exit:
	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPFX(DPFPREP,  0, "Problem with DNSP_Connect()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	//
	// return any outstanding endpoint
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			DNASSERT( ( hr != DPN_OK ) && ( hr != DPNERR_PENDING ) );
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	//
	// return any outstanding command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;
		pConnectData->hCommand = NULL;
		pConnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_Disconnect - disconnect from a remote host
//
// Entry:		Pointer to the service provider interface
//				Pointer to connection data
//
// Exit:		Error Code
//
// Note:	This command is considered final, there's no chance to cancel a
//			disconnect.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_Disconnect"

STDMETHODIMP	DNSP_Disconnect( IDP8ServiceProvider *pThis, SPDISCONNECTDATA *pDisconnectData )
{
	HRESULT			hr;
	HRESULT			hTempResult;
	CEndpoint   	*pEndpoint;
	CSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pDisconnectData);

	DNASSERT( pThis != NULL );
	DNASSERT( pDisconnectData != NULL );
	DNASSERT( pDisconnectData->hEndpoint != INVALID_HANDLE_VALUE );
	DNASSERT( pDisconnectData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	pEndpoint = NULL;
	pDisconnectData->hCommand = NULL;
	pDisconnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// check service provider state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "Disconnect called on uninitialized SP!" );
			goto Failure;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "Disconnect called on closing SP!" );
			goto Failure;

			break;
		}

		//
		// unknown
		//
		default:
		{
			hr = DPNERR_GENERIC;
			DNASSERT( FALSE );
			goto Failure;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// look up the endpoint and if it's found, close its handle
	//
	pEndpoint = pSPData->GetEndpointAndCloseHandle( pDisconnectData->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDENDPOINT;
		goto Failure;
	}
	
	hTempResult = pEndpoint->Disconnect( pDisconnectData->hEndpoint );
	switch ( hTempResult )
	{
		//
		// endpoint disconnected immediately
		//
		case DPN_OK:
		{
			break;
		}

		//
		// Other return.  Since the disconnect didn't complete, we need
		// to unlock the endpoint.
		//
		default:
		{
			DPFX(DPFPREP,  0, "Error reported when attempting to disconnect endpoint in DNSP_Disconnect!" );
			DisplayDNError( 0, hTempResult );

			break;
		}
	}

Exit:
	//
	// remove oustanding reference from GetEndpointHandleAndClose()
	//
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecRef();
		pEndpoint = NULL;
	}

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with DNSP_Disconnect()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_Listen - start process to listen for comport connections
//
// Entry:		Pointer to the service provider interface
//				Pointer to listen data
//
// Exit:		Error Code
//
// Note:	Any command handle allocated by this function is closed by the
//			endpoint.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_Listen"

STDMETHODIMP	DNSP_Listen( IDP8ServiceProvider *pThis, SPLISTENDATA *pListenData )
{
	HRESULT			hr;
	HRESULT			hTempResult;
	CSPData			*pSPData;
	CEndpoint   	*pEndpoint;
	CCommandData	*pCommand;
	BOOL			fEndpointOpen;
	BOOL			fInterfaceReferenceAdded;
	DATA_PORT_POOL_CONTEXT	DataPortPoolContext;
	GUID			DeviceGUID;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pListenData);

	DNASSERT( pThis != NULL );
	DNASSERT( pListenData != NULL );
	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOQUERY | DPNSPF_BINDLISTENTOGATEWAY ) ) == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	pEndpoint = NULL;
	pCommand = NULL;
	fEndpointOpen = FALSE;
	pListenData->hCommand = NULL;
	pListenData->dwCommandDescriptor = NULL_DESCRIPTOR;
	fInterfaceReferenceAdded = FALSE;


	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.
	//
	hTempResult = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}


	//
	// validate state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPNERR_PENDING );
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;

			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "DNSP_Listen called on uninitialized SP!" );
			goto Failure;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "DNSP_Listen called while SP closing!" );
			goto Failure;

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		DNASSERT( hr != DPN_OK );
		goto Failure;
	}

	//
	// check for invalid device ID
	//
	hTempResult = IDirectPlay8Address_GetDevice( pListenData->pAddressDeviceInfo, &DeviceGUID );
	switch ( hTempResult )
	{
		//
		// there was a device ID, check against g_InvalidAdapterGuid
		//
		case DPN_OK:
		{
			if ( IsEqualCLSID( DeviceGUID, g_InvalidAdapterGuid ) != FALSE )
			{
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP,  0, "GUID_NULL guid was apecified as a serial/modem device!" );
				goto Failure;
			}
			break;
		}

		//
		// no device address specified, not a problem
		//
		case DPNERR_DOESNOTEXIST:
		{
			break;
		}

		//
		// other, stop and figure out why we're here
		//
		default:
		{
			DNASSERT( FALSE );
			hr = hTempResult;
			DPFX(DPFPREP,  0, "Failed to validate device address!" );
			DisplayDNError( 0, hTempResult );
			break;
		}
	}

	//
	// get endpoint for this connection
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNSP_Listen: Cannot create new endpoint!" );
		goto Failure;
	}

	//
	// get new command
	//
	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNSP_Listen: Cannot get command handle!" );
		goto Failure;
	}

	//
	// initialize command
	//
	pListenData->hCommand = pCommand;
	pListenData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_LISTEN );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open this endpoint
	//
	hTempResult = pEndpoint->Open( NULL,
								   pListenData->pAddressDeviceInfo,
								   LINK_DIRECTION_INCOMING,
								   ENDPOINT_TYPE_LISTEN );
	switch ( hTempResult )
	{
		//
		// address conversion was fine, complete this command in the background
		//
		case DPN_OK:
		{
			//
			// copy connect data and the submit background job
			//
			fEndpointOpen = TRUE;
			pEndpoint->CopyListenData( pListenData );
			pEndpoint->AddRef();

			hTempResult = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->ListenJobCallback,
																		  pEndpoint->CancelListenJobCallback,
																		  pEndpoint );
			if ( hTempResult != DPN_OK )
			{
				pEndpoint->DecRef();
				hr = hTempResult;
				DPFX(DPFPREP,  0, "DNSP_Listen: Failed to submit delayed listen!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		//
		// address was incomplete, display a dialog if we can, otherwise fail the command
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
			{
				//
				// copy connect data for future reference and then start the dialog
				//
				fEndpointOpen = TRUE;
				pEndpoint->CopyListenData( pListenData );

				hTempResult = pEndpoint->ShowIncomingSettingsDialog( pSPData->GetThreadPool() );
				if ( hTempResult != DPN_OK )
				{
					hr = hTempResult;
					DPFX(DPFPREP,  0, "Problem showing settings dialog in DNSP_Listen!" );
					DisplayDNError( 0, hTempResult );

					goto Failure;
				 }

				//
				// This endpoint has been handed off, clear the pointer to it.
				// There is no reference to remove because the command is
				// still pending.
				//
				pEndpoint = NULL;
				DNASSERT( hr == DPNERR_PENDING );

				goto Exit;
			}
			else
			{
				hr = hTempResult;
				goto Failure;
			}

			break;
		}

		default:
		{
			hr = hTempResult;
			DPFX(DPFPREP,  0, "Problem initializing endpoint in DNSP_Listen!" );
			DisplayDNError( 0, hTempResult );
			goto Failure;

			break;
		}
	}

Exit:
	DNASSERT( pEndpoint == NULL );	
	
	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPFX(DPFPREP,  0, "Problem with DNSP_Listen()" );
		DisplayDNError( 0, hr );
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	//
	// return any outstanding endpoint
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			DNASSERT( ( hr != DPN_OK ) && ( hr != DPNERR_PENDING ) );
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	//
	// return any outstanding command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pListenData->hCommand = NULL;
		pListenData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_EnumQuery - start process to enum comport connections
//
// Entry:		Pointer to the service provider interface
//				Pointer to enum data
//
// Exit:		Error Code
//
// Note:	Any command handle allocated by this function is closed by the
//			endpoint.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_EnumQuery"

STDMETHODIMP	DNSP_EnumQuery( IDP8ServiceProvider *pThis, SPENUMQUERYDATA *pEnumQueryData )
{
	HRESULT			hr;
	HRESULT			hTempResult;
	CSPData			*pSPData;
	CEndpoint   	*pEndpoint;
	CCommandData	*pCommand;
	BOOL			fEndpointOpen;
	GUID			DeviceGUID;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumQueryData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumQueryData != NULL );
	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOQUERY ) ) == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	pEndpoint = NULL;
	pCommand = NULL;
	fEndpointOpen = FALSE;
	pEnumQueryData->hCommand = NULL;
	pEnumQueryData->dwCommandDescriptor = NULL_DESCRIPTOR;


	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.
	//
	hTempResult = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}


	//
	// validate state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "DNSP_EnumQuery called on uninitialized SP!" );
			goto Failure;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "DNSP_EnumQuery called while SP closing!" );
			goto Failure;

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		DNASSERT( hr != DPN_OK );
		goto Failure;
	}

	//
	// check for invalid device ID
	//
	hTempResult = IDirectPlay8Address_GetDevice( pEnumQueryData->pAddressDeviceInfo, &DeviceGUID );
	switch ( hTempResult )
	{
		//
		// there was a device ID, check against g_InvalidAdapterGuid
		//
		case DPN_OK:
		{
			if ( IsEqualCLSID( DeviceGUID, g_InvalidAdapterGuid ) != FALSE )
			{
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP,  0, "GUID_NULL guid was apecified as a serial/modem device!" );
				goto Failure;
			}
			break;
		}

		//
		// no device address specified, not a problem
		//
		case DPNERR_DOESNOTEXIST:
		{
			break;
		}

		//
		// other, stop and figure out why we're here
		//
		default:
		{
			DNASSERT( FALSE );
			hr = hTempResult;
			DPFX(DPFPREP,  0, "Failed to validate device address!" );
			DisplayDNError( 0, hTempResult );
			break;
		}
	}

	//
	// get endpoint for this connection
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNSP_EnumQuery: Cannot create new endpoint!" );
		goto Failure;
	}

	//
	// get new command
	//
	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "DNSP_EnumQuery: Cannot get command handle!" );
		goto Failure;
	}

	//
	// initialize command
	//
	pEnumQueryData->hCommand = pCommand;
	pEnumQueryData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_ENUM_QUERY );
	pCommand->SetState( COMMAND_STATE_INPROGRESS );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open this endpoint
	//
	hTempResult = pEndpoint->Open( pEnumQueryData->pAddressHost,
								   pEnumQueryData->pAddressDeviceInfo,
								   LINK_DIRECTION_OUTGOING,
								   ENDPOINT_TYPE_ENUM );
	switch ( hTempResult )
	{
		//
		// address was incomplete, display a dialog if we can, otherwise fail the command
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
			if ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
			{
				//
				// copy connect data for future reference and then start the dialog
				//
				fEndpointOpen = TRUE;
				pEndpoint->CopyEnumQueryData( pEnumQueryData );
	
				hTempResult = pEndpoint->ShowOutgoingSettingsDialog( pSPData->GetThreadPool() );
				if ( hTempResult != DPN_OK )
				 {
					hr = hTempResult;
					DPFX(DPFPREP,  0, "DNSP_EnumQuery: Problem showing settings dialog!" );
					DisplayDNError( 0, hTempResult );
	
					goto Failure;
				 }
	
				//
				// this endpoint has been handed off, remove our reference to it
				//
				pEndpoint = NULL;
				DNASSERT( hr == DPNERR_PENDING );
	
				goto Exit;
			}
			else
			{
				hr = hTempResult;
				goto Failure;
			}
	
			break;
		}
	
		//
		// address conversion was fine, complete this command in the background
		//
		case DPN_OK:
		{
			//
			// copy connect data and the submit background job
			//
			fEndpointOpen = TRUE;
			pEndpoint->CopyEnumQueryData( pEnumQueryData );
			pEndpoint->AddRef();

			hTempResult = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->EnumQueryJobCallback,
																		  pEndpoint->CancelEnumQueryJobCallback,
																		  pEndpoint );
			if ( hTempResult != DPN_OK )
			{
				pEndpoint->DecRef();
				hr = hTempResult;
				DPFX(DPFPREP,  0, "DNSP_EnumQuery: Failed to submit delayed connect!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		default:
		{
			hr = hTempResult;
			DPFX(DPFPREP,  0, "DNSP_EnumQuery: Problem initializing endpoint!" );
			DisplayDNError( 0, hTempResult );
			goto Failure;

			break;
		}
	}

Exit:
	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		DNASSERT( hr != DPN_OK );
		DPFX(DPFPREP,  0, "Problem with DNSP_EnumQuery" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			DNASSERT( ( hr != DPN_OK ) && ( hr != DPNERR_PENDING ) );
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		DNASSERT( FALSE );
		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	//
	// return any outstanding command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pEnumQueryData->hCommand = NULL;
		pEnumQueryData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_SendData sends data to the specified "player"
 *
 *	This call MUST BE HIGHLY OPTIMIZED
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_SendData"

STDMETHODIMP DNSP_SendData( IDP8ServiceProvider *pThis, SPSENDDATA *pSendData )
{
	HRESULT			hr;
	CEndpoint		*pEndpoint;
	CWriteIOData	*pWriteData;
	CSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pSendData);

	DNASSERT( pThis != NULL );
	DNASSERT( pSendData != NULL );
	DNASSERT( pSendData->pBuffers != NULL );
	DNASSERT( pSendData->dwBufferCount != 0 );
	DNASSERT( pSendData->hEndpoint != INVALID_HANDLE_VALUE );
	DNASSERT( pSendData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pSendData->hCommand = NULL;
	pSendData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pWriteData = NULL;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// No need to lock down the thread counts here because the user already has
	// a connect or something running or they wouldn't be calling this function.
	// That outstanding connect would have locked down the thread pool.
	//

	//
	// Attempt to grab the endpoint from the handle.  If this succeeds, the
	// endpoint can send.
	//
	pEndpoint = pSPData->EndpointFromHandle( pSendData->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDHANDLE;
		DPFX(DPFPREP,  0, "Invalid endpoint handle on send!" );
		goto Failure;
	}
	
	//
	// send data from pool
	//
	pWriteData = pSPData->GetThreadPool()->CreateWriteIOData();
	if ( pWriteData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot get new write data from pool in SendData!" );
		goto Failure;
	}
	DNASSERT( pWriteData->m_pCommand != NULL );
	DNASSERT( pWriteData->DataPort() == NULL );

	//
	// set the command state and fill in the message information
	//
	pWriteData->m_pCommand->SetType( COMMAND_TYPE_SEND );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );
	pWriteData->m_pCommand->SetEndpoint( pEndpoint );
	pWriteData->m_pCommand->SetUserContext( pSendData->pvContext );
	DNASSERT( pWriteData->m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_COMPLETE_COMMAND;

	DNASSERT( pSendData->dwBufferCount != 0 );
	pWriteData->m_uBufferCount = pSendData->dwBufferCount;
	pWriteData->m_pBuffers = pSendData->pBuffers;

	pSendData->hCommand = pWriteData->m_pCommand;
	pSendData->dwCommandDescriptor = pWriteData->m_pCommand->GetDescriptor();

	//
	// send data through the endpoint
	//
	pEndpoint->SendUserData( pWriteData );

Exit:
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	if ( pWriteData != NULL )
	{
		pSPData->GetThreadPool()->ReturnWriteIOData( pWriteData );
		DEBUG_ONLY( pWriteData = NULL );
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_CancelCommand - cancels a command in progress
//
// Entry:		Pointer to the service provider interface
//				Handle of command
//				Command descriptor
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_CancelCommand"

STDMETHODIMP DNSP_CancelCommand( IDP8ServiceProvider *pThis, HANDLE hCommand, DWORD dwCommandDescriptor )
{
	HRESULT			hr;
	CSPData			*pSPData;
	CCommandData	*pCommandData;
	BOOL			fReferenceAdded;
	BOOL			fCommandLocked;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p, %ld)", pThis, hCommand, dwCommandDescriptor);

	DNASSERT( pThis != NULL );
	DNASSERT( hCommand != NULL );
	DNASSERT( dwCommandDescriptor != NULL_DESCRIPTOR );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	pCommandData = NULL;
	fReferenceAdded = FALSE;
	fCommandLocked = FALSE;
	
	//
	// vlidate state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPN_OK );
			IDP8ServiceProvider_AddRef( pThis );
			fReferenceAdded = TRUE;
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "Disconnect called on uninitialized SP!" );
			DNASSERT( FALSE );
			goto Exit;

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "Disconnect called on closing SP!" );
			DNASSERT( FALSE );
			goto Exit;

			break;
		}

		//
		// unknown
		//
		default:
		{
			hr = DPNERR_GENERIC;
			DNASSERT( FALSE );
			goto Exit;
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Exit;
	}

	pCommandData = static_cast<CCommandData*>( hCommand );
	pCommandData->Lock();
	fCommandLocked = TRUE;

	//
	// this should never happen
	//
	if ( pCommandData->GetDescriptor() != dwCommandDescriptor )
	{
		hr = DPNERR_INVALIDCOMMAND;
		DPFX(DPFPREP,  0, "Attempt to cancel command with mismatched command descriptor!" );
		goto Exit;
	}

	switch ( pCommandData->GetState() )
	{
		//
		// unknown command state
		//
		case COMMAND_STATE_UNKNOWN:
		{
			hr = DPNERR_INVALIDCOMMAND;
			DNASSERT( FALSE );
			break;
		}

		//
		// command is waiting to be processed, set command state to be cancelling
		// and wait for someone to pick it up
		//
		case COMMAND_STATE_PENDING:
		{
			pCommandData->SetState( COMMAND_STATE_CANCELLING );
			break;
		}

		//
		// command in progress, and can't be cancelled
		//
		case COMMAND_STATE_INPROGRESS_CANNOT_CANCEL:
		{
			hr = DPNERR_CANNOTCANCEL;
			break;
		}

		//
		// Command is already being cancelled.  This is not a problem, but shouldn't
		// be happening.
		//
		case COMMAND_STATE_CANCELLING:
		{
			DNASSERT( hr == DPN_OK );
			DNASSERT( FALSE );
			break;
		}

		//
		// command is in progress, find out what type of command it is
		//
		case COMMAND_STATE_INPROGRESS:
		{
			switch ( pCommandData->GetType() )
			{
				case COMMAND_TYPE_UNKNOWN:
				{
					// we should never be in this state!
					DNASSERT( FALSE );
					break;
				}

				case COMMAND_TYPE_CONNECT:
				{
					// we should never be in this state!
					DNASSERT( FALSE );
					break;
				}

				case COMMAND_TYPE_LISTEN:
				{
					HRESULT		hTempResult;
					CDataPort	*pDataPort;
					CEndpoint	*pEndpoint;


					//
					// set this command to the cancel state before we shut down
					// this endpoint
					//
					pCommandData->SetState( COMMAND_STATE_CANCELLING );
					pCommandData->Unlock();
					fCommandLocked = FALSE;

					pEndpoint = pCommandData->GetEndpoint();
					pEndpoint->Lock();
					switch ( pEndpoint->GetState() )
					{
						//
						// endpoint is already disconnecting, no action needs to be taken
						//
						case ENDPOINT_STATE_DISCONNECTING:
						{
							pEndpoint->Unlock();
							goto Exit;
							break;
						}

						//
						// Endpoint is listening.  Flag it as Disconnecting and
						// add a reference so it doesn't disappear on us
						//
						case ENDPOINT_STATE_LISTENING:
						{
							pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
							pEndpoint->AddRef();
							break;
						}

						//
						// other state
						//
						default:
						{
							DNASSERT( FALSE );
							break;
						}
					}

					pEndpoint->Unlock();
					
					pEndpoint->Close( DPNERR_USERCANCEL );
					pSPData->CloseEndpointHandle( pEndpoint );
					
					pEndpoint->DecRef();

					break;
				}

				//
				// Note: this code is duplicated in CModemEndpoint::ProcessTAPIMessage
				//
				case COMMAND_TYPE_ENUM_QUERY:
				{
					CEndpoint	 *pEndpoint;


					pEndpoint = pCommandData->GetEndpoint();
					DNASSERT( pEndpoint != NULL );

					pEndpoint->AddRef();
					pCommandData->SetState( COMMAND_STATE_CANCELLING );
					pCommandData->Unlock();
					
					fCommandLocked = FALSE;

					pEndpoint->Lock();
					pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
					pEndpoint->Unlock();

					pEndpoint->StopEnumCommand( DPNERR_USERCANCEL );
					pEndpoint->DecRef();
					
					break;
				}

				case COMMAND_TYPE_SEND:
				{
					// we should never be here
					DNASSERT( FALSE );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// other command state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	if ( fCommandLocked != FALSE )
	{
		DNASSERT( pCommandData != NULL );
		pCommandData->Unlock();
		fCommandLocked = FALSE;
	}

	if ( fReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fReferenceAdded = FALSE;
	}

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with DNSP_CancelCommand!" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_EnumRespond - send response to enumeration data
//
// Entry:		Pointer to the service provider interface
//				Pointer to enum response data
//
// Exit:		Error Code
//
// Note:	This command is supposed to be fast.  All initial error checking
//			will be ASSERTs so they go away in the retail build.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_EnumRespond"

STDMETHODIMP DNSP_EnumRespond( IDP8ServiceProvider *pThis, SPENUMRESPONDDATA *pEnumRespondData )
{
	HRESULT			hr;
	CEndpoint		*pEndpoint;
	CWriteIOData	*pWriteData;
	CSPData			*pSPData;
	const ENDPOINT_ENUM_QUERY_CONTEXT	*pEnumQueryContext;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumRespondData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumRespondData != NULL );
	DNASSERT( pEnumRespondData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pWriteData = NULL;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );	
	DBG_CASSERT( OFFSETOF( ENDPOINT_ENUM_QUERY_CONTEXT, EnumQueryData ) == 0 );
	pEnumQueryContext = reinterpret_cast<ENDPOINT_ENUM_QUERY_CONTEXT*>( pEnumRespondData->pQuery );

	pEnumRespondData->hCommand = NULL;
	pEnumRespondData->dwCommandDescriptor = NULL_DESCRIPTOR;
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );
	IDP8ServiceProvider_AddRef( pThis );

	//
	// check for valid endpoint
	//
	pEndpoint = pSPData->EndpointFromHandle( pEnumQueryContext->hEndpoint );
	if ( pEndpoint == NULL )
	{
		DNASSERT( FALSE );
		hr = DPNERR_INVALIDENDPOINT;
		DPFX(DPFPREP,  8, "Invalid endpoint handle in DNSP_EnumRespond" );
		goto Failure;
	}
	
	//
	// no need to poke at the thread pool here to lock down threads because we
	// can only really be here if there's an enum and that enum locked down the
	// thread pool.
	//
	pWriteData = pSPData->GetThreadPool()->CreateWriteIOData();
	if ( pWriteData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot get new WRITE_IO_DATA for enum response!" );
		goto Failure;
	}

	pWriteData->m_pCommand->SetType( COMMAND_TYPE_SEND );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );
	pWriteData->m_pCommand->SetEndpoint( pEndpoint );
	pWriteData->m_pCommand->SetUserContext( pEnumRespondData->pvContext );
	DNASSERT( pWriteData->m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_COMPLETE_COMMAND;

	pWriteData->m_uBufferCount = pEnumRespondData->dwBufferCount;
	pWriteData->m_pBuffers = pEnumRespondData->pBuffers;

	pEnumRespondData->hCommand = pWriteData->m_pCommand;
	pEnumRespondData->dwCommandDescriptor = pWriteData->m_pCommand->GetDescriptor();

	//
	// send data
	//
	pEndpoint->SendEnumResponseData( pWriteData, pEnumQueryContext->uEnumRTTIndex );

Exit:
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}
	
	IDP8ServiceProvider_Release( pThis );
	
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	if ( pWriteData != NULL )
	{
		DNASSERT( pSPData != NULL );
		pSPData->GetThreadPool()->ReturnWriteIOData( pWriteData );

		pEnumRespondData->hCommand = NULL;
		pEnumRespondData->dwCommandDescriptor = NULL_DESCRIPTOR;

		pWriteData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_IsApplicationSupported - determine if this application is supported by this
//		SP.
//
// Entry:		Pointer to DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_IsApplicationSupported"

STDMETHODIMP	DNSP_IsApplicationSupported( IDP8ServiceProvider *pThis, SPISAPPLICATIONSUPPORTEDDATA *pIsApplicationSupportedData )
{
	HRESULT			hr;
	BOOL			fInterfaceReferenceAdded;
	CSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pIsApplicationSupportedData);

	DNASSERT( pThis != NULL );
	DNASSERT( pIsApplicationSupportedData != NULL );
	DNASSERT( pIsApplicationSupportedData->pApplicationGuid != NULL );
	DNASSERT( pIsApplicationSupportedData->dwFlags == 0 );

	//
	// initialize, we support all applications with this SP
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP,  0, "IsApplicationSupported called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP,  0, "IsApplicationSupported called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_GetCaps - get SP or endpoint capabilities
//
// Entry:		Pointer to DirectPlay
//				Pointer to caps data to fill
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_GetCaps"

STDMETHODIMP	DNSP_GetCaps( IDP8ServiceProvider *pThis, SPGETCAPSDATA *pCapsData )
{
	HRESULT		hr;
	LONG		iIOThreadCount;
	CSPData		*pSPData = NULL;

	
	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pCapsData);

	DNASSERT( pThis != NULL );
	DNASSERT( pCapsData != NULL );
	DNASSERT( pCapsData->dwSize == sizeof( *pCapsData ) );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// there are no flags for this SP
	//
	pCapsData->dwFlags = 0;
	
	//
	// set frame sizes
	//
	pCapsData->dwUserFrameSize = MAX_USER_PAYLOAD;
	pCapsData->dwEnumFrameSize = 1000;

	//
	// get link speed
	//
	if ( pCapsData->hEndpoint != INVALID_HANDLE_VALUE )
	{
		CEndpoint	*pEndpoint;


		pEndpoint = pSPData->EndpointFromHandle( pCapsData->hEndpoint );
		if ( pEndpoint != NULL )
		{
			pCapsData->dwLocalLinkSpeed = pEndpoint->GetLinkSpeed();
			pEndpoint->DecCommandRef();
		}
		else
		{
			hr = DPNERR_INVALIDENDPOINT;
			DPFX(DPFPREP,  0, "Invalid endpoint specified to GetCaps()" );
			goto Failure;
		}
	}
	else
	{
		pCapsData->dwLocalLinkSpeed = CBR_256000;
	}

	//
	// get IO thread count
	//
	hr = pSPData->GetThreadPool()->GetIOThreadCount( &iIOThreadCount );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "DNSP_GetCaps: Failed to get thread pool count!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	pCapsData->dwIOThreadCount = iIOThreadCount;

	//
	// set enumeration defaults
	//
	pCapsData->dwDefaultEnumRetryCount = DEFAULT_ENUM_RETRY_COUNT;
	pCapsData->dwDefaultEnumRetryInterval = DEFAULT_ENUM_RETRY_INTERVAL;
	pCapsData->dwDefaultEnumTimeout = DEFAULT_ENUM_TIMEOUT;

	pCapsData->dwBuffersPerThread = 1;
	pCapsData->dwSystemBufferSize = 0;

Exit:
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_SetCaps - set SP capabilities
//
// Entry:		Pointer to DirectPlay
//				Pointer to caps data to use
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_SetCaps"

STDMETHODIMP	DNSP_SetCaps( IDP8ServiceProvider *pThis, SPSETCAPSDATA *pCapsData )
{
	HRESULT			hr;
	BOOL			fInterfaceReferenceAdded;
	CSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pCapsData);

	DNASSERT( pThis != NULL );
	DNASSERT( pCapsData != NULL );
	DNASSERT( pCapsData->dwSize == sizeof( *pCapsData ) );

	//
	// initialize
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );


	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "AddToGroup called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "AddToGroup called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	
	//
	// validate caps
	//
	if ( pCapsData->dwBuffersPerThread == 0 )
	{
		DPFX(DPFPREP,  0, "Failing SetCaps because dwBuffersPerThread == 0" );
		hr = DPNERR_INVALIDPARAM;
		goto Failure;
	}
	

	//
	// change thread count
	//
	DNASSERT( pCapsData->dwIOThreadCount != 0 );
	hr = pSPData->GetThreadPool()->SetIOThreadCount( pCapsData->dwIOThreadCount );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "DNSP_SetCaps: Failed to set thread pool count!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}


Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_ReturnReceiveBuffers - return receive buffers to pool
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_ReturnReceiveBuffers"

STDMETHODIMP	DNSP_ReturnReceiveBuffers( IDP8ServiceProvider *pThis, SPRECEIVEDBUFFER *pReceivedBuffers )
{
	SPRECEIVEDBUFFER	*pBuffers;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pReceivedBuffers);

	//
	// no need to tell thread pool to lock the thread count for this function.
	//
	DNASSERT( pThis != NULL );
	DNASSERT( pReceivedBuffers != NULL );

	pBuffers = pReceivedBuffers;
	while ( pBuffers != NULL )
	{
		SPRECEIVEDBUFFER	*pTemp;
		CReadIOData			*pReadData;


		pTemp = pBuffers;
		pBuffers = pBuffers->pNext;
		pReadData = CReadIOData::ReadDataFromSPReceivedBuffer( pTemp );
		pReadData->DecRef();
	}

	DPFX(DPFPREP, 2, "Returning: [DPN_OK]");

	return	DPN_OK;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_GetAddressInfo - get address information
//
// Entry:		Pointer to service provider interface
//				Pointer to get address data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_GetAddressInfo"

STDMETHODIMP	DNSP_GetAddressInfo( IDP8ServiceProvider *pThis, SPGETADDRESSINFODATA *pGetAddressInfoData )
{
	HRESULT	hr;
	CSPData		*pSPData;
	CEndpoint	*pEndpoint;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pGetAddressInfoData);

	DNASSERT( pThis != NULL );
	DNASSERT( pGetAddressInfoData != NULL );
	DNASSERT( pGetAddressInfoData->hEndpoint != INVALID_HANDLE_VALUE );
	DNASSERT( ( pGetAddressInfoData->Flags & ~( SP_GET_ADDRESS_INFO_LOCAL_ADAPTER |
												SP_GET_ADDRESS_INFO_REMOTE_HOST |
												SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES |
												SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS ) ) == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	pGetAddressInfoData->pAddress = NULL;
	
	pEndpoint = pSPData->EndpointFromHandle( pGetAddressInfoData->hEndpoint );
	if ( pEndpoint != NULL )
	{
		switch ( pGetAddressInfoData->Flags )
		{
			case SP_GET_ADDRESS_INFO_REMOTE_HOST:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetRemoteHostDP8Address();
				break;
			}

			//
			// there is no concept of a 'public' address for this service provider so
			// all local addresses are the same
			//
			case SP_GET_ADDRESS_INFO_LOCAL_ADAPTER:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER );
				break;
			}

			case SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS:
			case SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( ADDRESS_TYPE_LOCAL_ADAPTER_HOST_FORMAT );
				break;
			}

			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
		
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}
	else
	{
		hr = DPNERR_INVALIDENDPOINT;
	}

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem getting DP8Address from endpoint!" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_EnumAdapters - enumerate adapters for this SP
//
// Entry:		Pointer to service provider interface
//				Pointer to enum adapters data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_EnumAdapters"

STDMETHODIMP	DNSP_EnumAdapters( IDP8ServiceProvider *pThis, SPENUMADAPTERSDATA *pEnumAdaptersData )
{
	HRESULT			hr;
	CDataPort   	*pDataPort;
	DATA_PORT_POOL_CONTEXT	DataPortPoolContext;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumAdaptersData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumAdaptersData->dwFlags == 0 );
	DNASSERT( ( pEnumAdaptersData->pAdapterData != NULL ) ||
			  ( pEnumAdaptersData->dwAdapterDataSize == 0 ) );

	//
	// intialize
	//
	hr = DPN_OK;
	pDataPort = NULL;
	pEnumAdaptersData->dwAdapterCount = 0;

	DataPortPoolContext.pSPData = CSPData::SPDataFromCOMInterface( pThis );
	pDataPort = CreateDataPort( &DataPortPoolContext );
	if ( pDataPort == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Problem getting new dataport for DNSP_EnumAdpaters!" );
		goto Failure;
	}

	hr = pDataPort->EnumAdapters( pEnumAdaptersData );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem enumerating adapters in DNSP_EnumAdapters!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( pDataPort != NULL )
	{
		pDataPort->DecRef();
		pDataPort = NULL;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_NotSupported is used for methods required to implement the
 *  interface but that are not supported by this SP.
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_NotSupported"

STDMETHODIMP DNSP_NotSupported( IDP8ServiceProvider *pThis, PVOID pvParam )
{
	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pvParam);
	DPFX(DPFPREP, 2, "Returning: [DPNERR_UNSUPPORTED]");
	return DPNERR_UNSUPPORTED;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\workthread.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       WorkThread.cpp
 *  Content:	main job processing functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnmdmi.h"


#define	DPF_MODNAME	"WorkThread"

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// events for NT enum thread
//
#define	EVENT_INDEX_ENUM_WAKEUP		1

//
// version ID for Win32 OSes
//
#define	WIN_98_VERSION		4
#define	WIN_NT4_VERSION		4

//
// events for Win9x enum thread
//
#define	EVENT_INDEX_SP_CLOSE		0
#define	EVENT_INDEX_PENDING_JOB		1
#define	EVENT_INDEX_TAPI_MESSAGE	2

//
// times to wait in milliseconds when polling for work thread shutdown
//
#define	WORK_THREAD_CLOSE_WAIT_TIME		10000
#define	WORK_THREAD_CLOSE_SLEEP_TIME	100

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// information passed to the Win9x workhorse thread
//
typedef struct	_WIN9X_THREAD_DATA
{
	CWorkThread		*pThisObject;	// pointer to this object
} WIN9X_THREAD_DATA;

//
// information passed to the IOCompletion thread
//
typedef struct	_IOCOMPLETION_THREAD_DATA
{
	CWorkThread		*pThisObject;	// pointer to this object
} IOCOMPLETION_THREAD_DATA;

// structure for common data in Win9x thread
typedef	struct	_WIN9X_CORE_DATA
{
	DWORD	dwHandleCount;				// total handle count
	DWORD	dwActivePortCount;			// count of active COM ports
	DWORD	dwBaseHandleCount;			// count of base handles (SP_CLOSE,	PENDING_JOB, TAPI_MESSAGE)
	DWORD	dwCurrentTimeout;			// current wait timeout
	DWORD	dwLastEnumTime;				// last time enums ran
	HANDLE	hHandles[ MAX_WIN9X_HANDLE_COUNT ];		// handles to wait on
	JKIO_DATA	*ActivePortDataPointers[ MAX_ACTIVE_WIN9X_ENDPOINTS * 2 ];	// pointers to COM IO structures

} WIN9X_CORE_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::CWorkThread - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
CWorkThread::CWorkThread():m_pJobQueueHead( NULL ),
		m_pJobQueueTail( NULL ),
		m_uThreadCount( 0 ),
		m_hPendingJob( NULL ),
		m_fNTEnumThreadRunning( FALSE ),
		m_hWakeNTEnumThread( NULL ),
		m_pSPData( NULL )
//:m_dwThreadCount( 0 ),m_hPendingJob( NULL ),
//		m_hTAPIEvent( NULL ),m_hSPClose( NULL ),m_pThis( NULL ),
//		m_fNTEnumThreadRunning( FALSE ),m_hWakeNTEnumThread( NULL )
{
	DEBUG_ONLY( m_fInitialized = FALSE );
	m_DNSPInterface.pCOMInterface = NULL;
	memset( &m_NTEnumThreadData, 0x00, sizeof( m_NTEnumThreadData ) );

	memset( &m_EnumList, 0x00, sizeof( m_EnumList ) );
	m_EnumList.Linkage.Initialize();
//	memset( &m_EnumList, 0x00, sizeof( m_EnumList ) );
//	memset( &m_JobQueue, 0x00, sizeof( m_JobQueue ) );
//	InitializeCriticalSection( &m_Lock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::~CWorkThread - destructor
//
// Entry:		Nothing
//
// Exit:		Error Code
// ------------------------------
CWorkThread::~CWorkThread()
{
	DNASSERT( m_fInitialized == FALSE );

	DNASSERT( m_pJobQueueHead == NULL );
	DNASSERT( m_pJobQueueTail == NULL );
	DNASSERT( m_uThreadCount == 0 );
	DNASSERT( m_hPendingJob == NULL );
	DNASSERT( m_EnumList.Linkage.IsEmpty() != FALSE );
	DNASSERT( m_fNTEnumThreadRunning == FALSE );
	DNASSERT( m_hWakeNTEnumThread == NULL );
	DNASSERT( m_pSPData == NULL );
//	DNASSERT( m_dwThreadCount == 0 );
//	DNASSERT( m_hPendingJob == NULL );
//	DNASSERT( m_hSPClose == NULL );
//	DNASSERT( m_hTAPIEvent == NULL );
//	DNASSERT( m_pThis == NULL );
//	DNASSERT( m_fNTEnumThreadRunning == FALSE );
//	DeleteCriticalSection( &m_Lock );

	DBG_CASSERT( LENGTHOF( m_NTEnumThreadData.hEventList ) == 2 );
	DNASSERT( m_NTEnumThreadData.hEventList[ 0 ] == NULL );
	DNASSERT( m_NTEnumThreadData.hEventList[ 1 ] == NULL );
	DNASSERT( m_NTEnumThreadData.pThisWorkThread == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::Initialize - initialize work threads
//
// Entry:		DirectNet interface
//
// Exit:		Error Code
// ------------------------------
HRESULT	CWorkThread::Initialize( const DNSPINTERFACE DNSPInterface )
{
	HRESULT		hr;
	HRESULT		hTempResult;


	DNASSERT( DNSPInterface.pCOMInterface != NULL );
//	DNASSERT( hSPClose != NULL );
//	// don't check TAPI event, it will be NULL for serial port
//
	//
	// initialize
	//
	hr = DPN_OK;
	m_DNSPInterface = DNSPInterface;
	m_pSPData = m_DNSPInterface.pDataInterface->pSPData;
	DNASSERT( m_pSPData != NULL );

	//
	// initialize critical sections
	//

	// object lock
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Initialize: Failed to initialize lock!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

	// job data lock
	if ( DNInitializeCriticalSection( &m_JobDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Initialize: failed to initialize job data lock!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_JobDataLock, 0 );

	// enum data lock
	if ( DNInitializeCriticalSection( &m_EnumDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Initialize: failed to initialize enum data lock!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_EnumDataLock, 0 );

//	m_hSPClose = hSPClose;
//	m_hTAPIEvent = hTAPIEvent;

	//
	// initialize pools
	//

	// job pool
	FPM_Initialize( &m_JobPool,					// pointer to pool
					sizeof( WORK_THREAD_JOB ),	// size of pool entry
					WorkThreadJob_Alloc,		// function called on pool entry initial allocation
					WorkThreadJob_Get,			// function called on entry extraction from pool
					WorkThreadJob_Release,		// function called on entry return to pool
					WorkThreadJob_Dealloc		// function called on entry free
					);

	// enum entry pool
	FPM_Initialize( &m_EnumEntryPool,		// pointer to pool
					sizeof( ENUM_ENTRY ),	// size of pool entry
					EnumEntry_Alloc,		// function called on pool entry initial allocation
					EnumEntry_Get,			// function called on entry extraction from pool
					EnumEntry_Release,		// function called on entry return to pool
					EnumEntry_Dealloc		// function called on entry free
					);
	//
	// what OS are we working with?
	//
#ifdef WINNT
	//
	// WinNT
	//
	SYSTEM_INFO		SystemInfo;
	UINT_PTR		uDesiredThreads;


	//
	// get machine information to spin up IOCompletionPort threads
	// ( ( processors * 2 ) + 2 ) as suggested by 'Multithreading
	// Applications in Win32' book
	//
	memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
	GetSystemInfo( &SystemInfo );
	DNASSERT( m_pSPData->GetIOCompletionPort() != NULL );

	DNASSERT( m_uThreadCount == 0 );
	uDesiredThreads = ( SystemInfo.dwNumberOfProcessors * 2 ) + 2;
	DNASSERT( uDesiredThreads != 0 );
	while ( uDesiredThreads > 0 )
	{
		HANDLE	hThread;
		DWORD	dwThreadID;
		IOCOMPLETION_THREAD_DATA	*pIOCompletionThreadData;


		uDesiredThreads--;

		//
		// If we can allocated thread data then start a thread
		//
		pIOCompletionThreadData = static_cast<IOCOMPLETION_THREAD_DATA*>( DNMalloc( sizeof( *pIOCompletionThreadData ) ) );
		if ( pIOCompletionThreadData != NULL )
		{
			pIOCompletionThreadData->pThisObject = this;
			hThread = CreateThread( NULL,						// pointer to security attributes (none)
									0,							// stack size (default)
									IOCompletionThread,			// thread function
									pIOCompletionThreadData,	// thread parameter
									0,							// start thread immediately
									&dwThreadID					// pointer to thread ID destination
									);
			if ( hThread != NULL )
			{
				//
				// note that a thread was created and close the thread
				// handle because we don't need it anymore
				//
				IncrementActiveThreadCount();

				if ( CloseHandle( hThread ) == FALSE )
				{
					DWORD	dwError;

					dwError = GetLastError();
					DPFX(DPFPREP,  0, "Problem creating thread for I/O completion port" );
					DisplayErrorCode( 0, dwError );
				}
			}
			else
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Failed to create I/O completion thread: 0x%d", uDesiredThreads );
				DisplayErrorCode( 0, dwError );

				DNFree( pIOCompletionThreadData );
			}
		}
	}

	//
	// the SP can function with at least one thread
	//
	if ( m_uThreadCount == 0 )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Unable to create any threads to service NT I/O completion port!" );
		goto Failure;
	}

#else // WIN95

	//
	// Windows 9x
	//
	HANDLE	hThread;
	DWORD	dwThreadID;
	WIN9X_THREAD_DATA	*pInput;


	//
	// create event for new job in job list (only under Win9x)
	//
	DNASSERT( m_hPendingJob == NULL );
	m_hPendingJob = CreateEvent( NULL,		// pointer to security attributes (default)
								 TRUE,		// manual reset
								 FALSE,		// start unsignalled
								 NULL		// pointer to name (none)
								 );
	if ( m_hPendingJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot create event for m_hPendingJob!" );
		goto Failure;
	}

	// create main worker thread to handle everything
	pInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pInput ) ) );
	if ( pInput == NULL )
	{
		DPFX(DPFPREP,  0, "Problem allocating memory for Win9x thread!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	memset( pInput, 0x00, sizeof( *pInput ) );
	pInput->pThisObject = this;

	//
	// create one worker thread and attempt to boost its priority
	//
	hThread = CreateThread( NULL,			// pointer to security attributes (none)
							0,				// stack size (default)
							Win9xThread,	// pointer to thread function
							pInput,			// pointer to input parameter
							0,				// let it run
							&dwThreadID		// pointer to destination of thread ID
							);
	if ( hThread == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem creating Win9x thread!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;

		DNASSERT( pInput != NULL );
		DNFree( pInput );
		pInput = NULL;
		goto Failure;
	}

	DNASSERT( hThread != NULL );
#ifdef ADJUST_THREAD_PRIORITY
	if ( SetThreadPriority( hThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
	{
		DWORD	dwError;

		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Could not boost thread priority on Win9x work thread!" );
		DisplayErrorCode( 0, dwError );

		//
		// Not fatal, just continue.
		//
	}
#endif // ADJUST_THREAD_PRIORITY

	//
	// note that we've started a thread, and close the thread handle
	//
	IncrementActiveThreadCount();

	if ( CloseHandle( hThread ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem closing handle to Win9xThread!" );
		DisplayErrorCode( 0, dwError );
	}
#endif

	DEBUG_ONLY( m_fInitialized = TRUE );
Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CreateWorkThreads" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	hTempResult = StopAllThreads();
	if ( hTempResult != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem stopping all threads!" );
		DisplayDNError( 0, hTempResult );
	}

	hTempResult = Deinitialize();
	if ( hTempResult != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Initialize: Problem deinitializing work thread on failure!" );
		DisplayDNError( 0, hTempResult );
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::StopAllThreads - stop all work threads
//
// Entry:		Nothing
//
// Exit:		Error Code
// ------------------------------
HRESULT	CWorkThread::StopAllThreads( void )
{
	HRESULT		hr;
	UINT_PTR	uLoopCount;
	DWORD		dwWaitReturn;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// compute wait timeslice for all threads to quit
	//
	uLoopCount = WORK_THREAD_CLOSE_WAIT_TIME / WORK_THREAD_CLOSE_SLEEP_TIME;

	//
	// verify that threads are stopping
	//
	DNASSERT( m_pSPData != NULL );
	dwWaitReturn = WaitForSingleObject( m_pSPData->GetSPCloseHandle(), 0 );
	switch( dwWaitReturn )
	{
		case WAIT_OBJECT_0:
		{
			break;
		}

		case WAIT_ABANDONED:
		{
			DNASSERT( FALSE );
			break;
		}

		case WAIT_TIMEOUT:
		{
			DNASSERT( FALSE );
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// WinNT: Spool an IO completion message for each outstanding thead.  this may
	// cause extra IO completion messages for threads not waiting on the completion
	// port, but the OS will clean those up.
	//
#ifdef WINNT
	UINT_PTR	uIndex;


	uIndex = m_uThreadCount;
	while ( uIndex > 0 )
	{
		uIndex--;
		if ( PostQueuedCompletionStatus( m_pSPData->GetIOCompletionPort(),		// handle of completion port
										 0,							    		// number of bytes transferred
										 IO_COMPLETION_KEY_SP_CLOSE,    		// completion key
										 NULL						    		// pointer to overlapped structure (none)
										 ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem submitting Stop job to IO completion port!" );
			DisplayErrorCode( 0, dwError );
			DNASSERT( FALSE );
		}
	}
#endif

	//
	// check for outstanding threads
	//
	DPFX(DPFPREP,  0,"Number of outstanding threads: %d", m_uThreadCount );
	while ( ( uLoopCount > 0 ) && ( m_uThreadCount != 0 ) )
	{
		DPFX(DPFPREP,  8, "Waiting for %d threads to quit: %d", m_uThreadCount, uLoopCount );
		uLoopCount--;
		SleepEx( WORK_THREAD_CLOSE_SLEEP_TIME, TRUE );
	}

	DNASSERT( uLoopCount != 0 );
	DNASSERT( m_uThreadCount == 0 );
	m_uThreadCount = 0;

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::Deinitialize - destroy work threads
//
// Entry:		Nothing
//
// Exit:		Error Code
// ------------------------------
HRESULT	CWorkThread::Deinitialize( void )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

//	while ( Queue_IsEmpty( &m_JobQueue ) == FALSE )
//	{
//		JOB_HEADER	*pJobHeader;
//
//
//		pJobHeader = static_cast<JOB_HEADER*>( Queue_DeQ( &m_JobQueue ) );
//		DNASSERT( pJobHeader != NULL );
//		DNFree( pJobHeader );
//	}
//
//	DNASSERT( Queue_IsEmpty( &m_JobQueue ) );
//	Queue_Deinitialize( &m_JobQueue );

	//
	// deinitialize pools
	//

	// enum entry pool
	FPM_Deinitialize( &m_EnumEntryPool );

	// job pool
	FPM_Deinitialize( &m_JobPool );

//	// close handle signalling new jobs
//	if ( m_hPendingJob != NULL )
//	{
//		if ( CloseHandle( m_hPendingJob ) == FALSE )
//		{
//			DPFX(DPFPREP,  0, "Problem with CWorkThread::Deinitialize::CloseHandle( m_hPendingJob )!" );
//			DisplayErrorCode( 0, GetLastError() );
//		}
//
//		m_hPendingJob = NULL;
//	}
//
//	DEBUG_ONLY( m_hSPClose = NULL );
//	DEBUG_ONLY( m_hTAPIEvent = NULL );
//	DEBUG_ONLY( m_pThis = NULL );

	m_DNSPInterface.pCOMInterface = NULL;
	m_pSPData = NULL;

	DNDeleteCriticalSection( &m_EnumDataLock );
	DNDeleteCriticalSection( &m_JobDataLock );
	DNDeleteCriticalSection( &m_Lock );

	DEBUG_ONLY( m_fInitialized = FALSE );

	return	hr;
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// CWorkThread::ProcessEnums - process enumerations
////
//// Entry:		Pointer to new wait timeout
////				Pointer to last enum time
////
//// Exit:		Boolean indicating active enums exist
////				TRUE = there are active enums
////				FALSE = there are no active enums
//// ------------------------------
//BOOL	CWorkThread::ProcessEnums( DWORD *pdwWaitTimeout, DWORD *pdwLastEnumTime )
//{
//	BOOL	fReturn;
//	DWORD	dwDeltaT;
//	DWORD	dwCurrentTime;
//	ENUM_ENTRY	*pEnumEntry;
//	DWORD	dwActiveEnumCount;
//
//
//	DNASSERT( pdwWaitTimeout != NULL );
//	DNASSERT( pdwLastEnumTime != NULL );
//
//	Lock();
//
//	// initialize
//	fReturn = FALSE;
//	DBG_CASSERT( OFFSETOF( ENUM_ENTRY, Linkage ) == 0 );
//	pEnumEntry = reinterpret_cast<ENUM_ENTRY*>( m_EnumList.Linkage.next );
//	*pdwWaitTimeout = INFINITE;
//	dwActiveEnumCount = 0;
//
//	// compute time delta between last enums
//	dwCurrentTime = GetTickCount();
//	dwDeltaT = dwCurrentTime - *pdwLastEnumTime;
//	*pdwLastEnumTime = dwCurrentTime;
//	if ( static_cast<INT>( dwDeltaT ) < 0 )
//	{
//		dwDeltaT = -( static_cast<INT>( dwDeltaT ) );
//	}
//
//	// loop through all enums
//	while ( pEnumEntry != NULL )
//	{
//		// note that there's an active enum
//		dwActiveEnumCount++;
//
//		// are we just waiting for enum responses?
//		if ( pEnumEntry->dwRetryCount == 0 )
//		{
//			// are we waiting forever for responses?
//			if ( pEnumEntry->fWaitForever == FALSE )
//			{
//				// not waiting forever, decrement wait timer
//				pEnumEntry->dwTimeout -= dwDeltaT;
//				if ( static_cast<INT>( pEnumEntry->dwTimeout ) <= 0 )
//				{
//					ENUM_ENTRY	*pTemp;
//
//
//					pTemp = pEnumEntry;
//
//					// back up one node so the loop will advance us to the next node
//					// we're always guaranteed that at least the dummy node is before us
//					DBG_CASSERT( OFFSETOF( ENUM_ENTRY, Linkage ) == 0 );
//					pEnumEntry = reinterpret_cast<ENUM_ENTRY*>( pEnumEntry->Linkage.GetPrev() );
//
////					pTemp->pEnumCompleteFn( DPN_OK );
//					pTemp->pEndpoint->EnumComplete( DPN_OK );
//
//					RemoveEnumEntry( pTemp );
//
//					// note that this enum is no longer active
//					DNASSERT( dwActiveEnumCount != 0 );
//					dwActiveEnumCount--;
//				}
//				else
//				{
//					// we're not done enuming, wake up for us if we're next
//					if ( pEnumEntry->dwTimeout < ( *pdwWaitTimeout ) )
//					{
//						*pdwWaitTimeout = pEnumEntry->dwTimeout;
//					}
//				}
//			}
//		}
//		else
//		{
//			// we're still sending, adjust enum timeout
//			pEnumEntry->dwTimeToNextEnum -= dwDeltaT;
//			if ( static_cast<INT>( pEnumEntry->dwTimeToNextEnum ) <= 0 )
//			{
//				HRESULT	hTempResult;
//
//
//				// timeout, send new enum
//				if ( ( hTempResult = pEnumEntry->pEnumSendFn( pEnumEntry->pEndpoint, &pEnumEntry->MessageInfo ) ) != DPN_OK )
//				{
//					DPFX(DPFPREP,  0, "Problem with enum send function!" );
//					DisplayDNError( 0, hTempResult );
//				}
//
//				if ( pEnumEntry->fEnumForever == FALSE )
//				{
//					pEnumEntry->dwRetryCount--;
//				}
//
//				// set up for next enum
//				pEnumEntry->dwTimeToNextEnum += pEnumEntry->dwRetryInterval;
//			}
//
//			// adjust for long waits
//			if ( static_cast<INT>( pEnumEntry->dwTimeToNextEnum ) <= 0 )
//			{
//				INT		iMultiplier;
//
//				iMultiplier = static_cast<INT>( pEnumEntry->dwTimeToNextEnum ) / static_cast<INT>( pEnumEntry->dwRetryInterval );
//				pEnumEntry->dwTimeToNextEnum = pEnumEntry->dwTimeToNextEnum - ( ( iMultiplier - 1 ) * pEnumEntry->dwRetryInterval );
//			}
//
//			// is this the next enum to fire?
//			DNASSERT( static_cast<INT>( pEnumEntry->dwTimeToNextEnum ) > 0 );
//			if ( pEnumEntry->dwTimeToNextEnum < (*pdwWaitTimeout) )
//			{
//				// we've got the shortest timeout time, wake thread up for us
//				*pdwWaitTimeout = pEnumEntry->dwTimeToNextEnum;
//			}
//		}
//
//		// next entry
//		DBG_CASSERT( sizeof( pEnumEntry ) == sizeof( pEnumEntry->Linkage.next ) );
//		DBG_CASSERT( OFFSETOF( ENUM_ENTRY, Linkage ) == 0 );
//		pEnumEntry = reinterpret_cast<ENUM_ENTRY*>( pEnumEntry->Linkage.next );
//	}
//
//	Unlock();
//
//	if ( dwActiveEnumCount != 0 )
//	{
//		DNASSERT( static_cast<INT>( dwActiveEnumCount ) > 0 );
//		fReturn = TRUE;
//	}
//
//	return	fReturn;
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::SubmitWorkItem - submit a work item for processing and inform workhorse that
//		another job is available
//
// Entry:		Pointer to job information
//
// Exit:		Error code
// ------------------------------
HRESULT	CWorkThread::SubmitWorkItem( WORK_THREAD_JOB *const pJobInfo )
{
	HRESULT	hr;


	DNASSERT( pJobInfo != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_JobDataLock, TRUE );

	//
	// initialize
	//
	hr = DPN_OK;

	//
	// add job to queue
	//
	EnqueueJob( pJobInfo );

#ifdef WINNT
	//
	// WinNT, submit new I/O completion item
	//
	DNASSERT( m_hPendingJob == NULL );

	if ( PostQueuedCompletionStatus( m_pSPData->GetIOCompletionPort(),	// completion port
									 0,									// number of bytes written (unused)
									 IO_COMPLETION_KEY_NEW_JOB,			// completion key
									 NULL								// pointer to overlapped structure (unused)
									 ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem posting completion item for new job!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

#else // WIN95
	//
	// Win9x, set event that the work thread will listen for
	//
	DNASSERT( m_hPendingJob != NULL );
	if ( SetEvent( m_hPendingJob ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_GENERIC;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Cannot set event for pending job!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}
#endif

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with SubmitWorkItem!" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::GetWorkItem - get a work item from the job queue
//
// Entry:		Nothing
//
// Exit:		Pointer to job information (may be NULL)
// ------------------------------
WORK_THREAD_JOB	*CWorkThread::GetWorkItem( void )
{
	WORK_THREAD_JOB	*pReturn;


	//
	// initialize
	//
	pReturn = NULL;

	LockJobData();

	pReturn = DequeueJob();

	//
	// if we're under Win9x (we have a 'pending job' handle),
	// see if the handle needs to be reset
	//
	if ( m_hPendingJob != NULL )
	{
		if ( JobQueueIsEmpty() != FALSE )
		{
			if ( ResetEvent( m_hPendingJob ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP,  0, "Poblem resetting event for pending Win9x jobs!" );
				DisplayErrorCode( 0, dwError );
			}
		}
	}

	UnlockJobData();

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::SubmitEnumJob - add an enum job to the enum list
//
// Entry:		Pointer to enum data
//				Pointer to associated endpoint
//
// Exit:		Error code
// ------------------------------
HRESULT	CWorkThread::SubmitEnumJob( const SPENUMQUERYDATA *const pQueryData,
									CEndpoint *const pEndpoint )
{
	HRESULT			hr;
	ENUM_ENTRY		*pEntry;
	WORK_THREAD_JOB	*pJob;


	DNASSERT( pQueryData != NULL );
	DNASSERT( pEndpoint != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	DNASSERT( m_DNSPInterface.pCOMInterface != NULL );

//	pEntry = NULL;
//	pJob = NULL;
//
//	Lock();
	LockEnumData();
	LockJobData();

	//
	// If we're on NT, attempt to start the enum thread here so we can return
	// an error if it fails to start.  If it does start, it'll sit until it's
	// informed that an enum job has been added.
	//
	DNASSERT( m_DNSPInterface.pDataInterface != NULL );
#ifdef WINNT
	hr = StartNTEnumThread();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Cannot spin up NT enum thread!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
#endif
	//
	// allocate new enum entry
	//
	pEntry = static_cast<ENUM_ENTRY*>( m_EnumEntryPool.Get( &m_EnumEntryPool ) );
	if ( pEntry == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot allocate memory to add to enum list!" );
		goto Failure;
	}
	DNASSERT( pEntry->pEnumCommandData == NULL );

	//
	// check retry count to determine if we're enumerating forever
	//
	if ( pQueryData->dwRetryCount == 0 )
	{
		pEntry->uRetryCount = 1;
		pEntry->fEnumForever = TRUE;
	}
	else
	{
		pEntry->uRetryCount = pQueryData->dwRetryCount;
		pEntry->fEnumForever = FALSE;
	}

	DBG_CASSERT( sizeof( pQueryData->dwRetryInterval ) == sizeof( DWORD ) );
	pEntry->RetryInterval.Time32.TimeHigh = 0;
	pEntry->RetryInterval.Time32.TimeLow = pQueryData->dwRetryInterval;
	pEntry->pEnumCommandData = static_cast<CCommandData*>( pQueryData->hCommand );
	pEntry->pEnumCommandData->AddRef();

	//
	// check timeout to determine if we're waiting forever
	//
	if ( pQueryData->dwTimeout == 0 )
	{
//		DBG_CASSERT( sizeof( pEntry->Timeout.Time64 ) == sizeof( DWORD ) );
		pEntry->Timeout.Time32.TimeHigh = -1;
		pEntry->Timeout.Time32.TimeLow = -1;
		pEntry->fWaitForever = TRUE;
	}
	else
	{
		DBG_CASSERT( sizeof( pQueryData->dwTimeout ) == sizeof( DWORD ) );
		pEntry->Timeout.Time32.TimeHigh = 0;
		pEntry->Timeout.Time32.TimeLow = pQueryData->dwTimeout;
		pEntry->fWaitForever = FALSE;
	}

	//
	// set this enum to fire as soon as it gets a chance
	//
	memset( &pEntry->NextEnumTime, 0x00, sizeof( pEntry->NextEnumTime ) );
	pEntry->pEndpoint = pEndpoint;

	pJob = static_cast<WORK_THREAD_JOB*>( m_JobPool.Get( &m_JobPool ) );
	if ( pJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot allocate memory for enum job!" );
		goto Failure;
	}

	//
	// create job for workhorse thread
	//
	pJob->pCancelFunction = CancelRefreshEnum;
	pJob->JobType = JOB_REFRESH_ENUM;

	// set our dummy paramter to simulate passing data
	DEBUG_ONLY( pJob->JobData.JobRefreshEnum.uDummy = 0 );

	//
	// we can submit the 'ENUM_REFRESH' job before inserting the enum entry
	// into the active enum list because nobody will be able to pull the
	// 'ENUM_REFRESH' job from the queue since we have the job queue locked
	//
	hr = SubmitWorkItem( pJob );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem submitting enum work item" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// link to rest of list
	//
	pEntry->Linkage.InsertAfter( &m_EnumList.Linkage );

Exit:
	UnlockEnumData();
	UnlockJobData();

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with SubmitEnumJob" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	if ( pEntry != NULL )
	{
		if ( pEntry->pEnumCommandData != NULL )
		{
			if ( pEntry->pEnumCommandData->Release() == 0 )
			{	
				m_pSPData->ReturnCommand( pEntry->pEnumCommandData );
			}

			DEBUG_ONLY( pEntry->pEnumCommandData = NULL );
		}

		m_EnumEntryPool.Release( &m_EnumEntryPool, pEntry );
		DEBUG_ONLY( pEntry = NULL );
	}

	if ( pJob != NULL )
	{
		m_JobPool.Release( &m_JobPool, pJob );
		DEBUG_ONLY( pJob = NULL );
	}

	//
	// It's possible that the enum thread has been started for this enum.
	// Since there's no way to stop it without completing the enums or
	// closing the SP, leave it running.
	//

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::CancelRefreshEnum - cancel job to refresh enums
//
// Entry:		Job data
//
// Exit:		Nothing
// ------------------------------
void	CWorkThread::CancelRefreshEnum( WORK_THREAD_JOB *const pJob )
{
	DNASSERT( pJob != NULL );

	//
	// this function doesn't need to do anything
	//
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// CWorkThread::StopEnumJob - remove enum job from list
////
//// Entry:		Pointer to command
////
//// Exit:		Nothing
////
//// Note:	This function is for the forced removal of a job from the enum
////			list.  It is assumed that the caller of this function will
////			clean up any messes.
//// ------------------------------
//void	CWorkThread::StopEnumJob( CCommandData *const pCommand )
//{
//	CBilink	*pTempEntry;
//
//
//	DNASSERT( pCommand != NULL );
//
//	// initialize
//	Lock();
//
//	pTempEntry = m_EnumList.Linkage.GetNext();
//	while ( pTempEntry != &m_EnumList )
//	{
//		ENUM_ENTRY	*pEnumEntry;
//
//
//		pEnumEntry = pTempEntry->EnumEntryFromBilink( pTempEntry );
//		if ( pEnumEntry->pCommandData == pCommand )
//		{
//			RemoveEnumEntry( reinterpret_cast<ENUM_ENTRY*>( pTempEntry ) );
//
//			// stop loop
//			pTempEntry = NULL;
//		}
//		else
//		{
//			pTempEntry = pTempEntry->GetNext();
//		}
//	}
//
//	Unlock();
//}
////**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::SubmitDelayedCommand - submit request to enum query to remote session
//
// Entry:		Pointer to callback function
//				Pointer to callback context
//
// Exit:		Error code
// ------------------------------
HRESULT	CWorkThread::SubmitDelayedCommand( JOB_FUNCTION *const pCommandFunction,
										   JOB_FUNCTION *const pCancelFunction,
										   void *pContext )
{
	HRESULT	hr;
	WORK_THREAD_JOB	*pJob;
	BOOL	fJobDataLocked;


	DNASSERT( pCommandFunction != NULL );
	DNASSERT( pCancelFunction != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pJob = NULL;
	fJobDataLocked = FALSE;


	pJob = static_cast<WORK_THREAD_JOB*>( m_JobPool.Get( &m_JobPool ) );
	if ( pJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot allocate job for DelayedCommand!" );
		goto Failure;
	}

	pJob->JobType = JOB_DELAYED_COMMAND;
	pJob->pCancelFunction = pCancelFunction;
	pJob->JobData.JobDelayedCommand.pCommandFunction = pCommandFunction;
	pJob->JobData.JobDelayedCommand.pContext = pContext;

	LockJobData();
	fJobDataLocked = TRUE;

	hr = SubmitWorkItem( pJob );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem submitting DelayedCommand job!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( fJobDataLocked != FALSE )
	{
		UnlockJobData();
		fJobDataLocked = FALSE;
	}

	return	hr;

Failure:
	if ( pJob != NULL )
	{
		m_JobPool.Release( &m_JobPool, pJob );
		pJob = NULL;
	}

	goto Exit;
}
//**********************************************************************


////**********************************************************************
//// ------------------------------
//// CWorkThread::SubmitAddPort - add a port to the Win9x watch list
////
//// Entry:		Endpoint reference
////
//// Exit:		Error code
//// ------------------------------
//HRESULT	CWorkThread::SubmitAddPort( CEndpoint &Endpoint )
//{
//	HRESULT	hr;
//	JOB_DATA_ADD_PORT	*pJobData;
//
//
//	// initialize
//	hr = DPN_OK;
//	pJobData = NULL;
//
//	// allocate memory for job data
//	pJobData = static_cast<JOB_DATA_ADD_PORT*>( DNMalloc( sizeof( *pJobData ) ) );
//	if ( pJobData == NULL )
//	{
//		hr = DPNERR_OUTOFMEMORY;
//		DPFX(DPFPREP,  0, "Cannot allocate memory for SubmitAddPort job!" );
//		goto Failure;
//	}
//
//	// set information
//	pJobData->Header.dwCommandID = 0;
//	pJobData->Header.JobType = JOB_ADD_WIN9X_PORT;
//	pJobData->Header.pProcessFunction = NULL;
//	pJobData->Header.pCancelFunction = NULL;
//	pJobData->pReadPortData = Endpoint.GetReadData();
//	pJobData->pWritePortData = Endpoint.GetWriteData();
//
//	DBG_CASSERT( OFFSETOF( JOB_DATA_ADD_PORT, Header ) == 0 );
//	if ( ( hr = SubmitWorkItem( &pJobData->Header ) ) != DPN_OK )
//	{
//		DPFX(DPFPREP,  0, "Problem submitting AddPort job!" );
//		DisplayDNError( 0, hr );
//		goto Failure;
//	}
//
//Exit:
//	return	hr;
//
//Failure:
//	if ( pJobData != NULL )
//	{
//		DNFree( pJobData );
//	}
//
//	goto Exit;
//}
////**********************************************************************
//
//
////**********************************************************************
//// ------------------------------
//// CWorkThread::SubmitRemovePort - remove a port from the Win9x watch list
////
//// Entry:		Pointer to read data
////				Pointer to write data
////
//// Exit:		Error code
//// ------------------------------
//HRESULT	CWorkThread::SubmitRemovePort( IO_DATA *pReadData, IO_DATA *pWriteData )
//{
//	HRESULT	hr;
//	JOB_DATA_REMOVE_PORT	*pJobData;
//
//
//	// initialize
//	hr = DPN_OK;
//	pJobData = NULL;
//
//	// allocate memory for job data
//	pJobData = static_cast<JOB_DATA_REMOVE_PORT*>( DNMalloc( sizeof( *pJobData ) ) );
//	if ( pJobData == NULL )
//	{
//		hr = DPNERR_OUTOFMEMORY;
//		DPFX(DPFPREP,  0, "Cannot allocate memory for SubmitRemovePort job!" );
//		goto Failure;
//	}
//
//	// set information
//	pJobData->Header.dwCommandID = 0;
//	pJobData->Header.JobType = JOB_REMOVE_WIN9X_PORT;
//	pJobData->Header.pProcessFunction = NULL;
//	pJobData->Header.pCancelFunction = NULL;
//	pJobData->pReadPortData = pReadData;
//	pJobData->pWritePortData = pWriteData;
//
//	DBG_CASSERT( OFFSETOF( JOB_DATA_REMOVE_PORT, Header ) == 0 );
//	if ( ( hr = SubmitWorkItem( &pJobData->Header ) ) != DPN_OK )
//	{
//		DPFX(DPFPREP,  0, "Problem submitting RemovePort job!" );
//		DisplayDNError( 0, hr );
//		goto Failure;
//	}
//
//Exit:
//	return	hr;
//
//Failure:
//	if ( pJobData != NULL )
//	{
//		DNFree( pJobData );
//	}
//
//	goto Exit;
//}
////**********************************************************************




//**********************************************************************
// ------------------------------
// CWorkThread::ProcessEnums - process enumerations
//
// Entry:		Pointer to destination for time of next enum
//
// Exit:		Boolean indicating active enums exist
//				TRUE = there are active enums
//				FALSE = there are no active enums
// ------------------------------
BOOL	CWorkThread::ProcessEnums( DN_TIME *const pNextEnumTime )
{
	BOOL		fReturn;
	ENUM_ENTRY	*pEnumEntry;
	INT_PTR		iActiveEnumCount;
	DN_TIME		CurrentTime;


	LockEnumData();

	//
	// initialize
	//
	fReturn = FALSE;
	DBG_CASSERT( OFFSETOF( ENUM_ENTRY, Linkage ) == 0 );
	pEnumEntry = reinterpret_cast<ENUM_ENTRY*>( m_EnumList.Linkage.GetNext() );
	iActiveEnumCount = 0;
	memset( pNextEnumTime, 0xFF, sizeof( *pNextEnumTime ) );
	DNTimeGet( &CurrentTime );

	//
	// if we're under NT, acknowledge that we've handled this event
	//
	if ( m_hWakeNTEnumThread != NULL )
	{
		if ( ResetEvent( m_hWakeNTEnumThread ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem resetting event to wake NT enum thread!" );
			DisplayErrorCode( 0, dwError );
		}
	}

	//
	// loop through all enums
	//
	while ( pEnumEntry != &m_EnumList )
	{
		//
		// Note that there's an active enum.  If we retire this enum, this
		// count will be decremented.
		//
		iActiveEnumCount++;

		//
		// If this enum has completed sending enums and is waiting only
		// for responses, decrement the wait time (assuming it's not infinite)
		// and remove the enum if the we've exceed its wait time.
		//
		if ( pEnumEntry->uRetryCount == 0 )
		{
			if ( DNTimeCompare( &pEnumEntry->Timeout, &CurrentTime ) <= 0 )
			{
				ENUM_ENTRY	*pTemp;


				//
				// Back up one node so the next loop iteration will advance us
				// to the next node.  We're guaranteed this is possible because
				// the list has a dummy node at the front.
				//
				pTemp = pEnumEntry;
				DBG_CASSERT( OFFSETOF( ENUM_ENTRY, Linkage ) == 0 );
				pEnumEntry = reinterpret_cast<ENUM_ENTRY*>( pEnumEntry->Linkage.GetPrev() );

				pTemp->pEndpoint->EnumComplete( DPN_OK );

				RemoveEnumEntry( pTemp );

				//
				// note that this enum is no longer active
				//
				DNASSERT( iActiveEnumCount > 0 );
				iActiveEnumCount--;
			}
			else
			{
				//
				// This enum isn't complete, check to see if it's the next enum
				// to need service.
				//
				if ( DNTimeCompare( &pEnumEntry->Timeout, pNextEnumTime ) < 0 )
				{
					DBG_CASSERT( sizeof( *pNextEnumTime ) == sizeof( pEnumEntry->Timeout ) );
					memcpy( pNextEnumTime, &pEnumEntry->Timeout, sizeof( *pNextEnumTime ) );
				}
			}
		}
		else
		{
			//
			// This enum is still sending.  Determine if it's time to send a new enum
			// and adjust the wakeup time if appropriate.
			//
			if ( DNTimeCompare( &pEnumEntry->NextEnumTime, &CurrentTime ) <= 0 )
			{
				HRESULT	hTempResult;


				//
				// Timeout, send new enum and set it to fire again with its
				// normal 'timeout'.
				//
				hTempResult = pEnumEntry->pEndpoint->SendEnumData();
				if ( hTempResult != DPN_OK )
				{
					DPFX(DPFPREP,  0, "Problem with enum send function!" );
					DisplayDNError( 0, hTempResult );
				}

				//
				// If this enum isn't running forever, decrement the retry count.
				// If there are no more retries, set up wait time.  If the enum
				// is waiting forever, set max wait timeout.
				//
				if ( pEnumEntry->fEnumForever == FALSE )
				{
					pEnumEntry->uRetryCount--;
					if ( pEnumEntry->uRetryCount == 0 )
					{
						if ( pEnumEntry->fWaitForever == FALSE )
						{
							//
							// Compute stopping time for this enum's 'Timeout' phase and
							// see if this will be the next enum to need service.  ASSERT
							// if the math wraps.
							//
							DNTimeAdd( &pEnumEntry->Timeout, &CurrentTime, &pEnumEntry->Timeout );
							DNASSERT( pEnumEntry->Timeout.Time32.TimeHigh >= CurrentTime.Time32.TimeHigh );
							if ( DNTimeCompare( &pEnumEntry->Timeout, pNextEnumTime ) < 0 )
							{
								DBG_CASSERT( sizeof( *pNextEnumTime ) == sizeof( pEnumEntry->Timeout ) );
								memcpy( pNextEnumTime, &pEnumEntry->Timeout, sizeof( *pNextEnumTime ) );
							}
						}
						else
						{
							// debug me
							DNASSERT( FALSE );
							//
							// We're waiting forever for enum returns.  ASSERT that we
							// have the maximum timeout and don't bother checking to see
							// if this will be the next enum to need service (it'll never
							// need service).
							//
							DNASSERT( pEnumEntry->Timeout.Time32.TimeLow == -1 );
							DNASSERT( pEnumEntry->Timeout.Time32.TimeHigh == -1 );
						}

						goto SkipNextRetryTimeComputation;
					}
				}

				DNTimeAdd( &CurrentTime, &pEnumEntry->RetryInterval, &pEnumEntry->NextEnumTime );
			}

			//
			// is this the next enum to fire?
			//
			if ( DNTimeCompare( &pEnumEntry->NextEnumTime, pNextEnumTime ) < 0 )
			{
				DBG_CASSERT( sizeof( *pNextEnumTime ) == sizeof( pEnumEntry->Timeout ) );
				memcpy( pNextEnumTime, &pEnumEntry->NextEnumTime, sizeof( *pNextEnumTime ) );
			}

SkipNextRetryTimeComputation:
			//
			// the following blank line is there to shut up the compiler
			//
			;
		}

		//
		// proceed to next entry
		//
		DBG_CASSERT( OFFSETOF( ENUM_ENTRY, Linkage ) == 0 );
		pEnumEntry = reinterpret_cast<ENUM_ENTRY*>( pEnumEntry->Linkage.GetNext() );
	}

	UnlockEnumData();

	if ( iActiveEnumCount != 0 )
	{
		DNASSERT( iActiveEnumCount > 0 );
		fReturn = TRUE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::StartNTEnumThread - start the enum thread for NT
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	This function assumes that the enum data is locked.
// ------------------------------
HRESULT	CWorkThread::StartNTEnumThread( void )
{
	HRESULT	hr;
	HANDLE	hThread;
	DWORD	dwThreadID;


	//
	// initialize
	//
	hr = DPN_OK;

	if ( m_fNTEnumThreadRunning != FALSE )
	{
		//
		// the enum thread is already running, poke it to note new enums
		//
		DNASSERT( m_hWakeNTEnumThread != NULL );
		if ( SetEvent( m_hWakeNTEnumThread ) == FALSE )
		{
			DWORD	dwError;


			hr = DPNERR_OUTOFMEMORY;
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem setting event to wake NTEnumThread!" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		goto Exit;
	}

	DNASSERT( m_hWakeNTEnumThread == NULL );
	m_hWakeNTEnumThread = CreateEvent( NULL,	// pointer to security attributes (none)
									   TRUE,	// manual reset
									   FALSE,	// start unsignalled
									   NULL		// pointer to name (none)
									   );
	if ( m_hWakeNTEnumThread == NULL )
	{
		DWORD	dwError;


		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Could not create event for waking NT enum thread!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}

	DNASSERT( m_NTEnumThreadData.pThisWorkThread == NULL );
	m_NTEnumThreadData.pThisWorkThread = this;

	DNASSERT( m_NTEnumThreadData.hEventList[ EVENT_INDEX_SP_CLOSE ] == NULL );
	m_NTEnumThreadData.hEventList[ EVENT_INDEX_SP_CLOSE ] = m_pSPData->GetSPCloseHandle();
	DNASSERT( m_NTEnumThreadData.hEventList[ EVENT_INDEX_SP_CLOSE ] != NULL );

	DNASSERT( m_NTEnumThreadData.hEventList[ EVENT_INDEX_ENUM_WAKEUP ] == NULL );
	m_NTEnumThreadData.hEventList[ EVENT_INDEX_ENUM_WAKEUP ] = m_hWakeNTEnumThread;
	DNASSERT( m_NTEnumThreadData.hEventList[ EVENT_INDEX_ENUM_WAKEUP ] != NULL );

	hThread = CreateThread( NULL,					// pointer to security attributes (none)
							0,						// stack size (default)
							WinNTEnumThread,		// thread function
							&m_NTEnumThreadData,	// thread parameter
							0,						// creation flags (none, start running now)
							&dwThreadID				// pointer to thread ID
							);
	if ( hThread == NULL )
	{
		DWORD	dwError;


		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to create NT enum thread!" );
		DisplayErrorCode( 0, dwError );

		goto Failure;
	}

	//
	// note that the thread is running
	//
	m_uThreadCount++;
	m_fNTEnumThreadRunning = TRUE;
	if ( CloseHandle( hThread ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem closing handle after starting NTEnumThread!" );
		DisplayErrorCode( 0, dwError );
	}

Exit:
	return	hr;

Failure:
	if ( m_hWakeNTEnumThread != NULL )
	{
		if ( CloseHandle( m_hWakeNTEnumThread ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing handle for 'WakeNTEnumThread'" );
			DisplayErrorCode( 0, dwError );
		}

		m_hWakeNTEnumThread = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::WakeNTEnumThread - wake the enum thread because an enum has
//		been added
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void	CWorkThread::WakeNTEnumThread( void )
{
	if ( SetEvent( m_NTEnumThreadData.hEventList[ EVENT_INDEX_ENUM_WAKEUP ] ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem setting event to wake up NT enum thread!" );
		DisplayErrorCode( 0, dwError );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::RemoveEnumEntry - remove enum job from list
//
// Entry:		Pointer to enum entry
//
// Exit:		Nothing
//
// Note:	This function assumes that the enum list is apprpriately locked
// ------------------------------
void	CWorkThread::RemoveEnumEntry( ENUM_ENTRY *const pEnumData )
{
	DNASSERT( pEnumData != NULL );

	AssertCriticalSectionIsTakenByThisThread( &m_EnumDataLock, TRUE );
	pEnumData->Linkage.RemoveFromList();

	//
	// return any commands, but don't do any signalling of commands being complete,
	// that's someone else's job
	//
	DNASSERT( pEnumData->pEnumCommandData != NULL );
	if ( pEnumData->pEnumCommandData->Release() == 0 )
	{
		m_pSPData->ReturnCommand( pEnumData->pEnumCommandData );
	}
	DEBUG_ONLY( pEnumData->pEnumCommandData = NULL );

	//
	// return entry to pool
	//
	pEnumData->pEndpoint = NULL;
	m_EnumEntryPool.Release( &m_EnumEntryPool, pEnumData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::Win9xThread - main thread to do everything that the SP is
//		supposed to do under Win9x.
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is allocated for this thread and must be
//			deallocated by this thread when it exits
// ------------------------------
DWORD	WINAPI	CWorkThread::Win9xThread( void *pParam )
{
	WIN9X_THREAD_DATA	*pInput;


	DNASSERT( pParam != NULL );

	//
	// initialize
	//
	DNASSERT( FALSE );
	pInput = static_cast<WIN9X_THREAD_DATA *>( pParam );

	pInput->pThisObject->DecrementActiveThreadCount();
	DNFree( pParam );

	return	0;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::IOCompletionThread - thread to service I/O completion port
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is allocated for this thread and must be
//			deallocated by this thread when it exits
// ------------------------------
DWORD	WINAPI	CWorkThread::IOCompletionThread( void *pParam )
{
	IOCOMPLETION_THREAD_DATA	*pInput;
	BOOL	fLooping;
	HANDLE	hIOCompletionPort;


	DNASSERT( pParam != NULL );

	//
	// initialize
	//
	pInput = static_cast<IOCOMPLETION_THREAD_DATA*>( pParam );
	DNASSERT( pInput->pThisObject != NULL );
	fLooping = TRUE;
	hIOCompletionPort = pInput->pThisObject->m_pSPData->GetIOCompletionPort();
	DNASSERT( hIOCompletionPort != NULL );

	//
	// go until we're told to stop
	//
	while ( fLooping != FALSE )
	{
		BOOL		fStatusReturn;
		DWORD		dwBytesTransferred;
		ULONG_PTR	uCompletionKey;
		OVERLAPPED	*pOverlapped;


		//
		// get data from completion port
		//
		DNASSERT( hIOCompletionPort != NULL );
		fStatusReturn = GetQueuedCompletionStatus( hIOCompletionPort,		// handle of completion port
												   &dwBytesTransferred,		// pointer to number of bytes transferred
												   &uCompletionKey,			// pointer to completion key
												   &pOverlapped,			// pointer to overlapped structure
												   INFINITE					// wait forever
												   );
		//
		// did we fail miserably?
		//
		if ( ( fStatusReturn == FALSE ) && ( pOverlapped == FALSE ) )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem getting item from completion port!" );
			DisplayErrorCode( 0, dwError );
		}
		else
		{
			//
			// what happened?
			//
			switch ( uCompletionKey )
			{
				//
				// SP is closing, stop this threads
				//
				case IO_COMPLETION_KEY_SP_CLOSE:
				{
					fLooping = FALSE;
					break;
				}

//				// TAPI message received
//				case IO_COMPLETION_KEY_TAPI_MESSAGE:
//				{
//					LINEMESSAGE	*pLineMessage;
//
//
//					// pointer to line message is in pOverlapped, we are responsible for freeing it
//					DNASSERT( pOverlapped != NULL );
//					DBG_CASSERT( sizeof( pLineMessage ) == sizeof( pOverlapped ) );
//					pLineMessage = reinterpret_cast<LINEMESSAGE*>( pOverlapped );
//					ProcessWinNTTAPIMessage( pInput->pThisObject->m_pThis, pLineMessage );
//					if ( LocalFree( pOverlapped ) != NULL )
//					{
//						DPFX(DPFPREP,  0, "Problem with LocalFree in NTProcessTAPIMessage" );
//						DisplayErrorCode( 0, GetLastError() );
//					}
//
//					break;
//				}

				//
				// ReadFile or WriteFile completed
				//
				case IO_COMPLETION_KEY_IO_COMPLETE:
				{
					SPAM_IO_DATA	*pIOData;
					DWORD			dwError;


					DNASSERT( pOverlapped != NULL );
					DBG_CASSERT( sizeof( pIOData ) == sizeof( pOverlapped ) );
					DBG_CASSERT( OFFSETOF( SPAM_IO_DATA, Overlap ) == 0 );
					pIOData = reinterpret_cast<SPAM_IO_DATA*>( pOverlapped );
					if ( ( fStatusReturn == FALSE ) ||
						 ( ( fStatusReturn != FALSE ) && ( dwBytesTransferred == 0 ) ) )
					{
						dwError = GetLastError();
					}
					else
					{
						dwError = ERROR_SUCCESS;
					}

					(pIOData->pDataPort->*pIOData->pUnifiedCompletionFunction)( dwBytesTransferred, dwError );

					break;
				}

				// a new job was submitted to the job queue
				case IO_COMPLETION_KEY_NEW_JOB:
				{
					WORK_THREAD_JOB	*pJobInfo;


					pJobInfo = pInput->pThisObject->GetWorkItem();
					if ( pJobInfo != NULL )
					{
						switch ( pJobInfo->JobType )
						{
							// enum refresh
							case JOB_REFRESH_ENUM:
							{
								DPFX(DPFPREP,  8, "IOCompletion job REFRESH_ENUM" );
								DNASSERT( pJobInfo->JobData.JobRefreshEnum.uDummy == 0 );
								pInput->pThisObject->WakeNTEnumThread();

								break;
							}

							// issue callback for this job
							case JOB_DELAYED_COMMAND:
							{
								DPFX(DPFPREP,  8, "IOCompletion job DELAYED_COMMAND" );
								DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );

								pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
								break;
							}

							// other job
							case JOB_UNINITIALIZED:
							default:
							{
								DPFX(DPFPREP,  8, "IOCompletion job unknown!" );
								DNASSERT( FALSE );
								break;
							}
						}

						pJobInfo->JobType = JOB_UNINITIALIZED;
						pInput->pThisObject->m_JobPool.Release( &pInput->pThisObject->m_JobPool, pJobInfo );
					}

					break;
				}

				//
				// unknown completion return
				//
				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}
		}
	}

	pInput->pThisObject->DecrementActiveThreadCount();
	DNFree( pParam );

	return	0;
}
//**********************************************************************


#ifdef WINNT
//**********************************************************************
// ------------------------------
// CWorkThread::WinNTEnumThread - enumeration thread for NT
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is a static memory chunk and cannot be freed.
//			Cleanup of this memory is the responsibility of this thread.
// ------------------------------
DWORD	WINAPI	CWorkThread::WinNTEnumThread( void *pParam )
{
	NT_ENUM_THREAD_DATA	*pInput;
	CWorkThread			*pThisWorkThread;
	BOOL	fLooping;
	BOOL	fEnumsActive;
	DWORD	dwWaitReturn;
	DN_TIME	NextEnumTime;


	DNASSERT( pParam != NULL );

	//
	// initialize
	//
	DNASSERT( pParam != NULL );
	pInput = static_cast<NT_ENUM_THREAD_DATA*>( pParam );
	DNASSERT( pInput->hEventList != NULL );
	DNASSERT( pInput->pThisWorkThread != NULL );
	pThisWorkThread = pInput->pThisWorkThread;

	memset( &NextEnumTime, 0xFF, sizeof( NextEnumTime ) );

Reloop:
	//
	// there were no active enums so we want to wait forever for something to
	// happen
	//
	fEnumsActive = FALSE;
	fLooping = TRUE;

	//
	// go until we're told to stop
	//
	while ( fLooping != FALSE )
	{
		DN_TIME		CurrentTime;
		DN_TIME		DeltaT;
		DWORD		dwMaxWaitTime;


		DNTimeGet( &CurrentTime );

		if ( DNTimeCompare( &NextEnumTime, &CurrentTime ) <= 0 )
		{
			pThisWorkThread->ProcessEnums( &NextEnumTime );
		}

		DNTimeSubtract( &NextEnumTime, &CurrentTime, &DeltaT );
		dwMaxWaitTime = pThisWorkThread->SaturatedWaitTime( DeltaT );

		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( pInput->hEventList ),	// number of events
												 pInput->hEventList,				// event list
												 FALSE,								// wait for any one event to be signalled
												 dwMaxWaitTime,						// timeout for enuming
												 TRUE								// be nice and allow APCs
												 );
		switch ( dwWaitReturn )
		{
			//
			// SP closing
			//
			case ( WAIT_OBJECT_0 + EVENT_INDEX_SP_CLOSE ):
			{
				DPFX(DPFPREP,  8, "NT enum thread detected SPClose!" );
				fLooping = FALSE;
				break;
			}

			//
			// Enum wakeup event, someone added an enum to the list.  Clear
			// our enum time and go back to the top of the loop where we
			// will process enums.
			//
			case ( WAIT_OBJECT_0 + EVENT_INDEX_ENUM_WAKEUP ):
			{
				memset( &NextEnumTime, 0x00, sizeof( NextEnumTime ) );
				break;
			}

			//
			// Wait timeout.  We're probably going to process enums, go back
			// to the top of the loop.
			//
			case WAIT_TIMEOUT:
			{
				break;
			}

			//
			// wait failed
			//
			case WAIT_FAILED:
			{
				DPFX(DPFPREP,  0, "NT Enum thread WaitForMultipleObjects failed: 0x%x", dwWaitReturn );
				DNASSERT( FALSE );
				break;
			}

			//
			// problem
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	DPFX(DPFPREP,  8, "NTEnum thread is exiting!" );
	pThisWorkThread->LockEnumData();

	//
	// check for another enum being added since we decided to leave
	//
	dwWaitReturn = WaitForSingleObjectEx( pInput->hEventList[ EVENT_INDEX_ENUM_WAKEUP ], 0, TRUE );
	switch ( dwWaitReturn )
	{
		//
		// Other threads don't know that this thread wants to quit so there
		// was another emum added before we could quit.  Restart the loop.
		//
		case WAIT_OBJECT_0:
		{
			DNASSERT( FALSE );
			memset( &NextEnumTime, 0x00, sizeof( NextEnumTime ) );
			pThisWorkThread->UnlockEnumData();
			goto Reloop;

			break;
		}

		//
		// just what we expected, nothing else to do, keep exiting
		//
		case WAIT_TIMEOUT:
		{
			break;
		}

		//
		// something isn't right!
		//
		default:
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem with final wait in NT enum thread!" );
			DisplayErrorCode( 0, dwError );
			DNASSERT( FALSE );
			break;
		}
	}

	pThisWorkThread->m_fNTEnumThreadRunning = FALSE;
	pThisWorkThread->DecrementActiveThreadCount();

	pInput->pThisWorkThread = NULL;
	pInput->hEventList[ EVENT_INDEX_SP_CLOSE ] = NULL;

	if ( CloseHandle( pInput->hEventList[ EVENT_INDEX_ENUM_WAKEUP ] ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Problem closing event handle on exit of NTEnumThread!" );
		DisplayErrorCode( 0, dwError );
	}
	pThisWorkThread->m_hWakeNTEnumThread = NULL;
	pInput->hEventList[ EVENT_INDEX_ENUM_WAKEUP ] = NULL;

	pThisWorkThread->UnlockEnumData();

	return	0;
}
//**********************************************************************
#endif // WINNT


//**********************************************************************
// ------------------------------
// CWorkThread::WorkThreadJob_Alloc - allocate a new job
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
BOOL	CWorkThread::WorkThreadJob_Alloc( void *pItem )
{
	BOOL			fReturn;
	WORK_THREAD_JOB	*pJob;


	//
	// initialize
	//
	fReturn = TRUE;
	pJob = static_cast<WORK_THREAD_JOB*>( pItem );

	DEBUG_ONLY( memset( pJob, 0x00, sizeof( *pJob ) ) );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::WorkThreadJob_Get - a job is being removed from the pool
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
void	CWorkThread::WorkThreadJob_Get( void *pItem )
{
	WORK_THREAD_JOB	*pJob;


	//
	// initialize
	//
	pJob = static_cast<WORK_THREAD_JOB*>( pItem );
	DNASSERT( pJob->JobType == JOB_UNINITIALIZED );

	//
	// cannot ASSERT the the following because the pool manager uses that memory
	//
//	DNASSERT( pJob->pNext == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::WorkThreadJob_Release - a job is being returned to the pool
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
void	CWorkThread::WorkThreadJob_Release( void *pItem )
{
	WORK_THREAD_JOB	*pJob;


	DNASSERT( pItem != NULL );
	pJob = static_cast<WORK_THREAD_JOB*>( pItem );

	DNASSERT( pJob->JobType == JOB_UNINITIALIZED );
	pJob->pNext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::WorkThreadJob_Dealloc - return job to memory manager
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
void	CWorkThread::WorkThreadJob_Dealloc( void *pItem )
{
	// don't do anything
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::EnumEntry_Alloc - allocate a new enum entry
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
BOOL	CWorkThread::EnumEntry_Alloc( void *pItem )
{
	BOOL			fReturn;
	ENUM_ENTRY		*pEnumEntry;


	DNASSERT( pItem != NULL );

	//
	// initialize
	//
	fReturn = TRUE;
	pEnumEntry = static_cast<ENUM_ENTRY*>( pItem );
	DEBUG_ONLY( memset( pEnumEntry, 0x00, sizeof( *pEnumEntry ) ) );
	pEnumEntry->Linkage.Initialize();

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::EnumEntry_Get - get new entry from pool
//
// Entry:		Pointer to new entry
//
// Exit:		Nothing
// ------------------------------
void	CWorkThread::EnumEntry_Get( void *pItem )
{
	ENUM_ENTRY	*pEnumEntry;


	DNASSERT( pItem != NULL );

	pEnumEntry = static_cast<ENUM_ENTRY*>( pItem );

	pEnumEntry->Linkage.Initialize();
	DNASSERT( pEnumEntry->pEndpoint == NULL );
	DNASSERT( pEnumEntry->pEnumCommandData == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::EnumEntry_Release - return entry to pool
//
// Entry:		Pointer to new entry
//
// Exit:		Nothing
// ------------------------------
void	CWorkThread::EnumEntry_Release( void *pItem )
{
	ENUM_ENTRY	*pEnumEntry;


	DNASSERT( pItem != NULL );

	pEnumEntry = static_cast<ENUM_ENTRY*>( pItem );

	DNASSERT( pEnumEntry->Linkage.IsEmpty() != FALSE );
	DNASSERT( pEnumEntry->pEndpoint == NULL );
	DNASSERT( pEnumEntry->pEnumCommandData == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWorkThread::EnumEntry_Dealloc - deallocate an enum entry
//
// Entry:		Pointer to new entry
//
// Exit:		Nothing
// ------------------------------
void	CWorkThread::EnumEntry_Dealloc( void *pItem )
{
	ENUM_ENTRY	*pEnumEntry;


	DNASSERT( pItem != NULL );

	//
	// initialize
	//
	pEnumEntry = static_cast<ENUM_ENTRY*>( pItem );

	//
	// return associated poiner to write data
	//
// can't DNASSERT on Linkage because pool manager stomped on it
//	DNASSERT( pEnumEntry->Linkage.IsEmpty() != FALSE );
	DNASSERT( pEnumEntry->pEndpoint == NULL );
	DNASSERT( pEnumEntry->pEnumCommandData == NULL );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\classfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       classfac.cpp
 *  Content:	a generic class factory
 *
 *
 *	This is a generic C class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instace of
 *	your object.
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 ***************************************************************************/

#include "dnwsocki.h"

#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// class factory class definition
//
typedef struct GPCLASSFACTORY
{
   IClassFactoryVtbl 		*lpVtbl;
   DWORD					dwRefCnt;
   CLSID					clsid;
} GPCLASSFACTORY, *LPGPCLASSFACTORY;

//
// function prototype for CoLockPbjectExternal()
//
typedef	HRESULT (WINAPI * PCOLOCKOBJECTEXTERNAL)(LPUNKNOWN, BOOL, BOOL );

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************




/*
 * GP_QueryInterface
 */
STDMETHODIMP GP_QueryInterface(
                LPCLASSFACTORY This,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
	HRESULT hr;

    pcf = (LPGPCLASSFACTORY)This;
    *ppvObj = NULL;


    if( IsEqualIID(riid, IID_IClassFactory) ||
                    IsEqualIID(riid, IID_IUnknown))
    {
        pcf->dwRefCnt++;
        *ppvObj = This;
		hr = S_OK;
    }
    else
    {
		hr = E_NOINTERFACE;
    }


	return hr;

} /* GP_QueryInterface */


/*
 * GP_AddRef
 */
STDMETHODIMP_(ULONG) GP_AddRef( LPCLASSFACTORY This )
{
    LPGPCLASSFACTORY pcf;

    pcf = (LPGPCLASSFACTORY)This;
    pcf->dwRefCnt++;
    return pcf->dwRefCnt;
} /* GP_AddRef */



/*
 * GP_Release
 */
STDMETHODIMP_(ULONG) GP_Release( LPCLASSFACTORY This )
{
    LPGPCLASSFACTORY	pcf;

    pcf = (LPGPCLASSFACTORY)This;
    pcf->dwRefCnt--;

    if( pcf->dwRefCnt != 0 )
    {
        return pcf->dwRefCnt;
    }

    DNFree( pcf );
    return 0;

} /* GP_Release */




/*
 * GP_CreateInstance
 *
 * Creates an instance of a DNServiceProvider object
 */
STDMETHODIMP GP_CreateInstance(
                LPCLASSFACTORY This,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT					hr = S_OK;
    LPGPCLASSFACTORY		pcf;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	pcf = (LPGPCLASSFACTORY) This;
	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = DoCreateInstance(This, pUnkOuter, pcf->clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* GP_CreateInstance */



/*
 * GP_LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP GP_LockServer(
                LPCLASSFACTORY This,
                BOOL fLock
				)
{
    HRESULT		hr;
    HINSTANCE	hdll;
    LPGPCLASSFACTORY	pcf;


    pcf = (LPGPCLASSFACTORY) This;

    /*
     * call CoLockObjectExternal
     */
    hr = E_UNEXPECTED;
    hdll = LoadLibrary( TEXT("OLE32.DLL") );
    if( hdll != NULL )
    {
        PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;


		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
        if( lpCoLockObjectExternal != NULL )
        {
            hr = lpCoLockObjectExternal( (LPUNKNOWN) This, fLock, TRUE );
        }
        else
        {
        }
    }
    else
    {
    }

	return hr;

} /* GP_LockServer */

static IClassFactoryVtbl GPClassFactoryVtbl =
{
        GP_QueryInterface,
        GP_AddRef,
        GP_Release,
        GP_CreateInstance,
        GP_LockServer
};


/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
EXP STDAPI  DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
    HRESULT		hr;

    *ppvObj = NULL;

    /*
     * is this our class id?
     */
//	you must implement GetClassID() for your specific COM object
	if (!IsClassImplemented(rclsid))
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, IID_IUnknown ) &&
	    !IsEqualIID( riid, IID_IClassFactory ) )
    {
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = static_cast<GPCLASSFACTORY*>( DNMalloc( sizeof( *pcf ) ) );
    if( NULL == pcf)
    {
        return E_OUTOFMEMORY;
    }

	pcf->lpVtbl = &GPClassFactoryVtbl;
    pcf->dwRefCnt = 0;
	pcf->clsid = rclsid;

    hr = GP_QueryInterface( (LPCLASSFACTORY) pcf, riid, ppvObj );
    if( FAILED( hr ) )
    {
        DNFree ( pcf );
        *ppvObj = NULL;
    }
    else
    {
    }

    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
EXP STDAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

	
	if ( g_lOutstandingInterfaceCount == 0 )
	{
		hr = S_OK;
	}

    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\serial\workthread.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       WorkThread.h
 *  Content:	Functions to manage work thread
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/01/99	jtk		Derived from Utils.h
 ***************************************************************************/

#ifndef __WORK_THREAD_H__
#define __WORK_THREAD_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

// max handles that can be waited on for Win9x
#define	MAX_WIN9X_HANDLE_COUNT	64

//
// job definitions
//
typedef enum
{
	JOB_UNINITIALIZED,		// uninitialized value
	JOB_DELAYED_COMMAND,	// callback provided
	JOB_REFRESH_ENUM,		// revisit enums
	JOB_ADD_WIN9X_PORT,		// add a Win9x com port to list of monitored ports
	JOB_REMOVE_WIN9X_PORT	// remove a Win9x com port from list of monitored ports
} JOB_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

// forward reference
class	CCommandData;
class	CEndpoint;
class	CWorkThread;
typedef	struct	_WIN9X_CORE_DATA	WIN9X_CORE_DATA;
typedef	struct	_JKIO_DATA			JKIO_DATA;
typedef struct	_WORK_THREAD_JOB	WORK_THREAD_JOB;
typedef	void	JOB_FUNCTION( WORK_THREAD_JOB *const pJobInfo );


// structure for enum list entry
// It is assumed that the CBilink is at the start of the following structure!!
typedef struct	_ENUM_ENTRY
{
	CBilink			Linkage;			// list links
	UINT_PTR		uRetryCount;		// number of times to enum
	BOOL			fEnumForever;		// Boolean for enumerating forever
	DN_TIME			RetryInterval;		// time between enums (milliseconds)
	DN_TIME			Timeout;			// time at which we stop waiting for enum returns
	BOOL			fWaitForever;		// Boolean for waiting forever for responses
	DN_TIME			NextEnumTime;		// time at which this enum will fire next (milliseconds)
	CEndpoint		*pEndpoint;			// pointer to endpoint
	CCommandData	*pEnumCommandData;	// pointer to command data

	static _ENUM_ENTRY	*EnumEntryFromBilink( CBilink *const pBilink )
	{
		DNASSERT( pBilink != NULL );
		DBG_CASSERT( OFFSETOF( ENUM_ENTRY, Linkage ) == 0 )
		return	reinterpret_cast<ENUM_ENTRY*>( pBilink );
	}

} ENUM_ENTRY;

// information passed to the NT enum thread
typedef	struct	_NT_ENUM_THREAD_DATA
{
	CWorkThread		*pThisWorkThread;	// pointer to this object
	HANDLE			hEventList[ 2 ];	// list of events
} NT_ENUM_THREAD_DATA;

//
// structure for job callback
//
typedef struct
{
	JOB_FUNCTION	*pCommandFunction;	// pointer to function for the command
	void			*pContext;			// user context (endpoint pointer)
} JOB_DATA_DELAYED_COMMAND;

//
// structure for job to refresh enums
//
typedef	struct
{
	UINT_PTR	uDummy;			// dummy variable to prevent compiler from whining
} JOB_DATA_REFRESH_ENUM;

//
// structure encompassing information for a job for the workhorse thread
//
typedef struct	_WORK_THREAD_JOB
{
	WORK_THREAD_JOB		*pNext;					// pointer to next job
	JOB_TYPE			JobType;				// type of job
	JOB_FUNCTION		*pCancelFunction;		// function for cancelling job

//	DWORD			dwCommandID;			// unique ID used to identify this command
//	JOB_FUNCTION	*pProcessFunction;		// function for performing job

	union
	{
		JOB_DATA_DELAYED_COMMAND	JobDelayedCommand;
//		JOB_DATA_REMOVE_SOCKET		JobRemoveSocket;
//		JOB_DATA_ADD_SOCKET			JobAddSocket;
		JOB_DATA_REFRESH_ENUM		JobRefreshEnum;
	} JobData;

} WORK_THREAD_JOB;


//typedef	HRESULT	ENUM_SEND_FN( void *const pEndpoint, MESSAGE_INFO *const pMessageInfo );
//typedef	void	(CEndpoint::*ENUM_COMPLETE_FN)( const HRESULT hr );


//// job function pointer
//typedef struct	JOB_HEADER	JOB_HEADER;

/*
// structure encompassing information for a job for the workhorse thread
// all 'job' information blocks must be prefixed with a JOB_HEADER
typedef struct	JOB_HEADER
{
	DWORD			dwCommandID;			// unique ID used to identify this command
	JOB_TYPE		JobType;				// type of job
	JOB_FUNCTION	*pProcessFunction;		// function for performing job
	JOB_FUNCTION	*pCancelFunction;		// function for cancelling job

} JOB_HEADER;
*/
/*
// structure for job to start monitoring a port in Win9x
// the header MUST be the first item in this structure
typedef	struct	JOB_DATA_ADD_PORT
{
	JOB_HEADER	Header;				// header
	JKIO_DATA	*pReadPortData;		// pointer to read port information
	JKIO_DATA	*pWritePortData;	// pointer to write port information

} JOB_DATA_ADD_PORT;

// structure for job to stop monitoring a port in Win9x
// the header MUST be the first item in this structure
typedef	struct	JOB_DATA_REMOVE_PORT
{
	JOB_HEADER	Header;				// header
	JKIO_DATA		*pReadPortData;		// pointer to read port information
	JKIO_DATA		*pWritePortData;	// pointer to write port information

} JOB_DATA_REMOVE_PORT;

// structure for job to connect
typedef struct	JOB_DELAYED_COMMAND
{
	JOB_HEADER	Header;			// header
	void		*pContext;		// user context (endpoint pointer)
} JOB_DELAYED_COMMAND;
*/

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for work thread
class	CWorkThread
{
	public:
		CWorkThread();
		~CWorkThread();

		HRESULT	Initialize( const DNSPINTERFACE DNSPInterface );
		HRESULT	Deinitialize( void );
		HRESULT	StopAllThreads( void );

		HRESULT	SubmitDelayedCommand( JOB_FUNCTION *const pCommandFunction,
									  JOB_FUNCTION *const pCancelFunction,
									  void *const pContext );
		HRESULT	SubmitEnumJob( const SPENUMQUERYDATA *const pEnumQueryData,
							   CEndpoint *const pEndpoint );

		void	IncrementActiveThreadCount( void ) { m_uThreadCount++; }
		void	DecrementActiveThreadCount( void ) { m_uThreadCount--; }

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;				// local lock

		DNCRITICAL_SECTION	m_JobDataLock;		// lock for job data
		WORK_THREAD_JOB		*m_pJobQueueHead;	// head of job queue
		WORK_THREAD_JOB		*m_pJobQueueTail;	// tail of job queue
		FPOOL				m_JobPool;			// pool of pending jobs

		volatile UINT_PTR	m_uThreadCount;		// number of active threads in thread pool

		HANDLE		m_hPendingJob;			// Event signalled when a job is
											// pending in the job queue.
											// If there are no jobs, this event,
											// is unsignalled.
											// This event is only for Win9x threads.

		//
		// enum data
		//
		DNCRITICAL_SECTION	m_EnumDataLock;			// lock for enum data
		FPOOL				m_EnumEntryPool;		// pool for enum entries
		ENUM_ENTRY			m_EnumList;				// active enum list, this is a dummy node that the list hangs off of

		BOOL				m_fNTEnumThreadRunning;	// Boolean indicating that there's an enum thread running for NT
													// (cleaned when NT enum thread exists)

		HANDLE				m_hWakeNTEnumThread;	// handle to be signalled to wake NT enum thread
													// (cleaned when NT enum thread exists)

		NT_ENUM_THREAD_DATA	m_NTEnumThreadData;		// data for the NT enum thread
													// (cleaned when the thread exits)

//		// the following are not to be cleaned up by this object!!
		DNSPINTERFACE	m_DNSPInterface;		// pointers to DirectNet interfaces
		CSPData			*m_pSPData;				// pointer to SPData

		static	DWORD	SaturatedWaitTime( const DN_TIME &Time )
		{
//			#ifdef	_WIN64
//				return	Time;
//			#endif	// _WIN64

//			#ifdef	_WIN32
				DWORD	dwReturn;

				DBG_CASSERT( sizeof( dwReturn ) == 4 );
				if ( Time.Time32.TimeHigh != 0 )
				{
					dwReturn = -1;
				}
				else
				{
					dwReturn = Time.Time32.TimeLow;
				}

				return	dwReturn;
//			#endif	// _WIN32
		}

		BOOL	ProcessEnums( DN_TIME *const pNextEnumTime );
		HRESULT	StartNTEnumThread( void );
		void	WakeNTEnumThread( void );
		void	RemoveEnumEntry( ENUM_ENTRY *const pEnumData );

		void	LockJobData( void ) { DNEnterCriticalSection( &m_JobDataLock ); }
		void	UnlockJobData( void ) { DNLeaveCriticalSection( &m_JobDataLock ); }

		void	LockEnumData( void ) { DNEnterCriticalSection( &m_EnumDataLock ); }
		void	UnlockEnumData( void ) { DNLeaveCriticalSection( &m_EnumDataLock ); }

		void	EnqueueJob( WORK_THREAD_JOB *const pJob )
		{
			AssertCriticalSectionIsTakenByThisThread( &m_JobDataLock, TRUE );
			DNASSERT( pJob != NULL );

			if ( m_pJobQueueTail != NULL )
			{
				DNASSERT( m_pJobQueueHead != NULL );
				DNASSERT( m_pJobQueueTail->pNext == NULL );
				m_pJobQueueTail->pNext = pJob;
			}
			else
			{
				m_pJobQueueHead = pJob;
			}

			m_pJobQueueTail = pJob;
			pJob->pNext = NULL;
		}

		WORK_THREAD_JOB	*DequeueJob( void )
		{
			WORK_THREAD_JOB	*pJob;


			AssertCriticalSectionIsTakenByThisThread( &m_JobDataLock, TRUE );
			DNASSERT( JobQueueIsEmpty() == FALSE );

			pJob = m_pJobQueueHead;
			m_pJobQueueHead = pJob->pNext;
			if ( m_pJobQueueHead == NULL )
			{
				DNASSERT( m_pJobQueueTail == pJob );
				m_pJobQueueTail = NULL;
			}

			DEBUG_ONLY( pJob->pNext = NULL );
			return	pJob;
		}

		BOOL	JobQueueIsEmpty( void ) const
		{
			AssertCriticalSectionIsTakenByThisThread( &m_JobDataLock, TRUE );
			return ( m_pJobQueueHead == NULL );
		}

		HRESULT	SubmitWorkItem( WORK_THREAD_JOB *const pJob );
		WORK_THREAD_JOB	*GetWorkItem( void );

#ifdef WIN95
		static	DWORD WINAPI	Win9xThread( void *pParam );
#endif

#ifdef WINNT
		static	DWORD WINAPI	IOCompletionThread( void *pParam );
		static	DWORD WINAPI	WinNTEnumThread( void *pParam );
#endif
		static	void	CancelRefreshEnum( WORK_THREAD_JOB *const pJobData );

		DEBUG_ONLY( BOOL	m_fInitialized );

		//
		// functions for managing the job pool
		//
		static	BOOL	WorkThreadJob_Alloc( void *pItem );
		static	void	WorkThreadJob_Get( void *pItem );
		static	void	WorkThreadJob_Release( void *pItem );
		static	void	WorkThreadJob_Dealloc( void *pItem );

		//
		// functions for managing the enum entry pool
		//
		static BOOL		EnumEntry_Alloc( void *pItem );
		static void		EnumEntry_Get( void *pItem );
		static void		EnumEntry_Release( void *pItem );
		static void		EnumEntry_Dealloc( void *pItem );

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent unwarranted copies
		//
		CWorkThread( const CWorkThread & );
		CWorkThread& operator=( const CWorkThread & );
};

#endif	// __WORK_THREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\cmddata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CmdData.cpp
 *  Content:	Class representing a command
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	04/07/1999	jtk		Derived from SPData.h
 *	01/19/2000	jtk		Derived from CommandData.h
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::CCommandData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::CCommandData"

CCommandData::CCommandData():
	m_State( COMMAND_STATE_UNKNOWN ),
	m_dwDescriptor( NULL_DESCRIPTOR ),
	m_dwNextDescriptor( NULL_DESCRIPTOR + 1 ),
	m_Type( COMMAND_TYPE_UNKNOWN ),
	m_pEndpoint( NULL ),
#ifdef USE_THREADLOCALPOOLS
	m_pUserContext( NULL )
#else // ! USE_THREADLOCALPOOLS
	m_pUserContext( NULL ),
	m_pOwningPool( NULL )
#endif // ! USE_THREADLOCALPOOLS
{
	m_blPostponed.Initialize();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::CCommandData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::~CCommandData"

CCommandData::~CCommandData()
{
	DNASSERT( m_State == COMMAND_STATE_UNKNOWN );
	DNASSERT( m_dwDescriptor == NULL_DESCRIPTOR );
	DNASSERT( m_Type == COMMAND_TYPE_UNKNOWN );
	DNASSERT( m_pEndpoint == NULL );
	DNASSERT( m_pUserContext == NULL );
	DNASSERT( m_blPostponed.IsEmpty() );
#ifndef USE_THREADLOCALPOOLS
	DNASSERT( m_pOwningPool == NULL );
#endif // ! USE_THREADLOCALPOOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::Reset - reset this object
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::Reset"

void	CCommandData::Reset( void )
{
	SetState( COMMAND_STATE_UNKNOWN );
	m_dwDescriptor = NULL_DESCRIPTOR;
	SetType( COMMAND_TYPE_UNKNOWN );
	SetEndpoint( NULL );
	SetUserContext( NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolAllocFunction - called when a pool item is allocated
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolAllocFunction"

BOOL	CCommandData::PoolAllocFunction( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_State == COMMAND_STATE_UNKNOWN );
	DNASSERT( m_dwDescriptor == NULL_DESCRIPTOR );
	DNASSERT( m_Type == COMMAND_TYPE_UNKNOWN );
	DNASSERT( m_pEndpoint == NULL );
	DNASSERT( m_pUserContext == NULL );
	
	//
	// initialize critical section and set recursin depth to 0
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

Exit:
	return	fReturn;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolInitFunction - called when a pool item is allocated
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolInitFunction"

BOOL	CCommandData::PoolInitFunction( void )
{
	DNASSERT( m_State == COMMAND_STATE_UNKNOWN );
	DNASSERT( m_dwDescriptor == NULL_DESCRIPTOR );
	DNASSERT( m_Type == COMMAND_TYPE_UNKNOWN );
	DNASSERT( m_pEndpoint == NULL );
	DNASSERT( m_pUserContext == NULL );
	
	SetDescriptor();
	
	return	TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::PoolReleaseFunction - called when item is returned to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolReleaseFunction"

void	CCommandData::PoolReleaseFunction( void )
{
	Reset();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::Denitialize - deinitialization function for command data
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::PoolDeallocFunction"

void	CCommandData::PoolDeallocFunction( void )
{
	DNDeleteCriticalSection( &m_Lock );
	m_State = COMMAND_STATE_UNKNOWN;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CCommandData::ReturnSelfToPool - return this item to a pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCommandData::ReturnSelfToPool"

void	CCommandData::ReturnSelfToPool( void )
{
	ReturnCommand( this );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\adapterentry.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AdapterEntry.h
 *  Content:	Strucutre definitions for IO data blocks
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/07/2000	jtk		Dereived from IOData.cpp
 ***************************************************************************/

#ifndef __ADAPTER_ENTRY_H__
#define __ADAPTER_ENTRY_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CRsip;
class	CThreadPool;


//
// class containing all data for an adapter list
//
class	CAdapterEntry : public CLockedPoolItem
{
	public:
		CAdapterEntry();
		~CAdapterEntry();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::AddToAdapterList"
		void	AddToAdapterList( CBilink *const pAdapterList )
		{
			DNASSERT( pAdapterList != NULL );

			//
			// This assumes the SPData socketportdata lock is held.
			//
			
			m_AdapterListLinkage.InsertBefore( pAdapterList );
		}

		void	RemoveFromAdapterList( void )
		{

			//
			// This assumes the SPData socketportdata lock is held.
			//
			
			m_AdapterListLinkage.RemoveFromList();
		}
	
		CBilink	*SocketPortList( void ) { return &m_ActiveSocketPorts; }
		const SOCKADDR	*BaseAddress( void ) const { return &m_BaseSocketAddress; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::SetBAseAddress"
		void	SetBaseAddress( const SOCKADDR *const pSocketAddress )
		{
			DBG_CASSERT( sizeof( m_BaseSocketAddress ) == sizeof( *pSocketAddress ) );
			memcpy( &m_BaseSocketAddress, pSocketAddress, sizeof( m_BaseSocketAddress ) );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::AdapterEntryFromAdapterLinkage"
		static	CAdapterEntry	*AdapterEntryFromAdapterLinkage( CBilink *const pLinkage )
		{
			DNASSERT( pLinkage != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pLinkage ) );
			DBG_CASSERT( sizeof( CAdapterEntry* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CAdapterEntry*>( &reinterpret_cast<BYTE*>( pLinkage )[ -OFFSETOF( CAdapterEntry, m_AdapterListLinkage ) ] );
		}

		//
		// Pool functions
		//
		BOOL	PoolAllocFunction( void );
		BOOL	PoolInitFunction( void );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CAdapterEntry::SetOwningPool"
		void	SetOwningPool( CLockedPool< CAdapterEntry > *const pOwningPool )
		{
			DEBUG_ONLY( DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) ) );
			m_pOwningPool = pOwningPool;
		}
	protected:

	private:
		CBilink			m_AdapterListLinkage;			// linkage to other adapters
		CBilink			m_ActiveSocketPorts;			// linkage to active socket ports
		SOCKADDR		m_BaseSocketAddress;			// socket address for this port class

		CLockedPool< CAdapterEntry >	*m_pOwningPool;
		
		void	ReturnSelfToPool( void );
		
		// prevent unwarranted copies
		CAdapterEntry( const CAdapterEntry & );
		CAdapterEntry& operator=( const CAdapterEntry & );
};

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME

#endif	// __ADAPTER_ENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\adapterentry.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AdapterEntry.cpp
 *  Content:	Structure used in the list of active sockets
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/07/2000	jtk		Derived from IODAta.h
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// ------------------------------
// CAdapterEntry::CAdapterEntry - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::CAdapterEntry"

CAdapterEntry::CAdapterEntry():
	m_pOwningPool( NULL )
{
	m_AdapterListLinkage.Initialize();
	m_ActiveSocketPorts.Initialize();
	memset( &m_BaseSocketAddress, 0x00, sizeof( m_BaseSocketAddress ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::~CAdapterEntry - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::~CAdapterEntry"

CAdapterEntry::~CAdapterEntry()
{
	DNASSERT( m_AdapterListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_ActiveSocketPorts.IsEmpty() != FALSE );
	DNASSERT( m_pOwningPool == NULL );
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolAllocFunction - called when item is removed from pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolAllocFunction"

BOOL	CAdapterEntry::PoolAllocFunction( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_AdapterListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_ActiveSocketPorts.IsEmpty() != FALSE );

	return	fReturn;
}
//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolInitFunction - called when item is removed from pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolInitFunction"

BOOL	CAdapterEntry::PoolInitFunction( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;
	
	DNASSERT( m_AdapterListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_ActiveSocketPorts.IsEmpty() != FALSE );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolReleaseFunction - called when item is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolReleaseFunction"

void	CAdapterEntry::PoolReleaseFunction( void )
{
	DNASSERT( m_AdapterListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_ActiveSocketPorts.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::PoolDeallocFunction - called when this item is freed from pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::PoolDeallocFunction"

void	CAdapterEntry::PoolDeallocFunction( void )
{
	DNASSERT( m_AdapterListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_ActiveSocketPorts.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CAdapterEntry::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CAdapterEntry::ReturnSelfToPool"

void	CAdapterEntry::ReturnSelfToPool( void )
{
	DNASSERT( m_pOwningPool != NULL );

	//
	// No more references, time to remove self from list.
	//
	this->RemoveFromAdapterList();
	
	this->m_pOwningPool->Release( this );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\cmddata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CommandData.h
 *  Content:	Declaration of class representing a command
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	04/07/99	jtk		Derived from SPData.h
 ***************************************************************************/

#ifndef __COMMAND_DATA_H__
#define __COMMAND_DATA_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

typedef	enum
{
	COMMAND_STATE_UNKNOWN,					// unknown state
	COMMAND_STATE_PENDING,					// command waiting to be processed
	COMMAND_STATE_INPROGRESS,				// command is executing
	COMMAND_STATE_INPROGRESS_CANNOT_CANCEL,	// command is executing, can't be cancelled
	COMMAND_STATE_CANCELLING,				// command is already being cancelled
} COMMAND_STATE;

typedef	enum
{	
	COMMAND_TYPE_UNKNOWN,		// unknown command
	COMMAND_TYPE_CONNECT,		// connect command
	COMMAND_TYPE_LISTEN,		// listen command
	COMMAND_TYPE_ENUM_QUERY,	// enum command
	COMMAND_TYPE_SEND,			// data send command (enum, enum query, send)
} COMMAND_TYPE;

#define	NULL_DESCRIPTOR		0

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
class	CEndpoint;
class	CCommandData;
class	CSPData;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// the following funtion must be defined
//
void	ReturnCommand( CCommandData *const pCommandData );

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for command data
//
#ifdef USE_THREADLOCALPOOLS
class	CCommandData : public CLockedTLPoolItem
#else // ! USE_THREADLOCALPOOLS
class	CCommandData : public CLockedPoolItem
#endif // ! USE_THREADLOCALPOOLS
{
	public:
		CCommandData();
		~CCommandData();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }


		DWORD	GetDescriptor( void ) const { return m_dwDescriptor; }
		void	SetDescriptor( void )
		{
			m_dwDescriptor = m_dwNextDescriptor;
			m_dwNextDescriptor++;
			if ( m_dwNextDescriptor == NULL_DESCRIPTOR )
			{
				m_dwNextDescriptor++;
			}
			
			SetState( COMMAND_STATE_UNKNOWN );
		}

		COMMAND_STATE	GetState( void ) const { return m_State; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetState"
		void			SetState( const COMMAND_STATE State )	{ m_State = State; }

		COMMAND_TYPE	GetType( void ) const { return m_Type; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetType"
		void			SetType( const COMMAND_TYPE Type )
		{
			DNASSERT( ( m_Type == COMMAND_TYPE_UNKNOWN ) || ( Type == COMMAND_TYPE_UNKNOWN ) );
			m_Type = Type;
		}

		CEndpoint	*GetEndpoint( void ) const { return m_pEndpoint; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetEndpoint"
		void		SetEndpoint( CEndpoint *const pEndpoint )
		{
			DNASSERT( ( m_pEndpoint == NULL ) || ( pEndpoint == NULL ) );
			m_pEndpoint = pEndpoint;
		}

		void	*GetUserContext( void ) const { return m_pUserContext; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetUserContext"
		void	SetUserContext( void *const pUserContext )
		{
			DNASSERT( ( m_pUserContext == NULL ) || ( pUserContext == NULL ) );
			m_pUserContext = pUserContext;
		}

		void	Reset( void );

		
		void	AddToPostponedList( CBilink * pBilink)		{ m_blPostponed.InsertBefore( pBilink ); };	// requires SPData LockSocketPortData() lock
		void	RemoveFromPostponedList(void)				{ m_blPostponed.RemoveFromList(); };		// requires SPData LockSocketPortData() lock

		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::CommandFromPostponedListBilink"
		static	CCommandData	*CommandFromPostponedListBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			return	reinterpret_cast<CCommandData*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CCommandData, m_blPostponed ) ] );
		}


		//
		// pool fnctions
		//
		BOOL	PoolAllocFunction( void );
		BOOL	PoolInitFunction( void );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );

#ifndef USE_THREADLOCALPOOLS
		#undef DPF_MODNAME
		#define DPF_MODNAME "CCommandData::SetOwningPool"
		void	SetOwningPool( CLockedPool< CCommandData > *const pOwningPool )
		{
			DEBUG_ONLY( DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) ) );
			m_pOwningPool = pOwningPool;
		}
#endif // ! USE_THREADLOCALPOOLS

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;

		DWORD				m_dwDescriptor;
		DWORD				m_dwNextDescriptor;
		COMMAND_STATE		m_State;
		COMMAND_TYPE		m_Type;
		CEndpoint			*m_pEndpoint;
		void				*m_pUserContext;
		
		CBilink				m_blPostponed;		// bilink in SP data postponed commands list,  protected by SPData LockSocketPortData() lock

#ifndef USE_THREADLOCALPOOLS
		CLockedPool< CCommandData >	*m_pOwningPool;
#endif // ! USE_THREADLOCALPOOLS

		void	ReturnSelfToPool( void );

		//
		// prevent unwarranted copies
		//
		CCommandData( const CCommandData & );
		CCommandData& operator=( const CCommandData & );
};

#undef DPF_MODNAME

#endif	// __COMMAND_DATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\dnwsocki.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnwsocki.h
 *  Content:    DirectPlay Winsock SP master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNWSOCKI_H__
#define __DNWSOCKI_H__

// 
// Public includes
//
#define INCL_WINSOCK_API_TYPEDEFS 1
#include <Winsock2.h>
#include <windows.h>
#include <WSIPX.h>
#include <IPHlpApi.h>
#include <WS2TCPIP.h>
#include <mstcpip.h>
#include <mmsystem.h>

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#include "dpsp8.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "classbilink.h"
#include "fpm.h"
#include "dneterrors.h"
#include "LockedCFPM.h"
#include "PackBuff.h"
#include "comutil.h"
#include "creg.h"
#include "ClassFPM.h"
#include "LockedContextFixedPool.h"
#include "LockedPool.h"
#include "classhash.h"
#include "ContextCFPM.h"
#include "strutils.h"
#include "createin.h"
#include "threadlocalptrs.h"

#include "dpnathlp.h"


// 
// Wsock private includes
//
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

#include "Locals.h"
#include "MessageStructures.h"
#include "AdapterEntry.h"
#include "CMDData.h"
#include "DebugUtils.h"
#include "dwinsock.h"
#include "HandleTable.h"
#include "IOData.h"
#include "JobQueue.h"
#include "Pools.h"
#include "SendQueue.h"
#include "SPAddress.h"
#include "SPData.h"
#include "Utils.h"
#include "WSockSP.h"
#include "SocketPort.h"
#include "ThreadPool.h"
#include "Endpoint.h"
#include "IPAddress.h"
#include "IPXAddress.h"

// provides us winsock1/2 support
#define DWINSOCK_EXTERN
#include "dwnsock1.inc"
#include "dwnsock2.inc"
#undef DWINSOCK_EXTERN

#include "IPEndpt.h"
#include "IPUI.h"
#include "IPXEndpt.h"
#include "Resource.h"

#endif // __DNWSOCKI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\debugutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DebugUtils.cpp
 *  Content:	Winsock service provider debug utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnwsocki.h"

#ifdef	_DEBUG

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// HexDump - perform a hex dump of information
//
// Entry:		Pointer to data
//				Data size
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "HexDump"

void	HexDump( PVOID pData, UINT32 uDataSize )
{
	DWORD	uIdx = 0;


	// go through all data
	while ( uIdx < uDataSize )
	{
		// output character
		DPFX(DPFPREP,  0, "0x%2x ", ( (LPBYTE) pData )[ uIdx ] );

		// increment index
		uIdx++;

		// are we off the end of a line?
		if ( ( uIdx % 12 ) == 0 )
		{
			DPFX(DPFPREP,  0, "\n" );
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DumpSocketAddress - dump a socket address
//
// Entry:		Debug level
//				Pointer to socket address
//				Socket family
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DumpSocketAddress"

void	DumpSocketAddress( const DWORD dwDebugLevel, const SOCKADDR *const pSocketAddress, const DWORD dwFamily )
{
	switch ( dwFamily )
	{
		case AF_INET:
		{
			const SOCKADDR_IN	*const pInetAddress = reinterpret_cast<const SOCKADDR_IN*>( pSocketAddress );

			DPFX(DPFPREP,  dwDebugLevel, "IP socket:\tAddress: %d.%d.%d.%d\tPort: %d",
					pInetAddress->sin_addr.S_un.S_un_b.s_b1,
					pInetAddress->sin_addr.S_un.S_un_b.s_b2,
					pInetAddress->sin_addr.S_un.S_un_b.s_b3,
					pInetAddress->sin_addr.S_un.S_un_b.s_b4,
					p_ntohs( pInetAddress->sin_port )
					);
			break;
		}

		case AF_IPX:
		{
			const SOCKADDR_IPX *const pIPXAddress = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );

			DPFX (DPFPREP, dwDebugLevel, "IPX socket:\tNet (hex) %x-%x-%x-%x\tNode (hex): %x-%x-%x-%x-%x-%x\tSocket: %d",
					(BYTE)pIPXAddress->sa_netnum[ 0 ],
					(BYTE)pIPXAddress->sa_netnum[ 1 ],
					(BYTE)pIPXAddress->sa_netnum[ 2 ],
					(BYTE)pIPXAddress->sa_netnum[ 3 ],
					(BYTE)pIPXAddress->sa_nodenum[ 0 ],
					(BYTE)pIPXAddress->sa_nodenum[ 1 ],
					(BYTE)pIPXAddress->sa_nodenum[ 2 ],
					(BYTE)pIPXAddress->sa_nodenum[ 3 ],
					(BYTE)pIPXAddress->sa_nodenum[ 4 ],
					(BYTE)pIPXAddress->sa_nodenum[ 5 ],
					p_ntohs( pIPXAddress->sa_socket )
					);
			break;
		}

		default:
		{
			DPFX(DPFPREP,  0, "Unknown socket type!" );
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DumpAddress - convert an address to a URL and output via debugger
//
// Entry:		Debug level
//				Pointer to base message string
//				Pointer to address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DumpAddress"

void	DumpAddress( const DWORD dwDebugLevel, const char *const pBaseString, IDirectPlay8Address *const pAddress )
{
	HRESULT	hr;
	char	*pURL;
	DWORD	dwURLSize;


	DNASSERT( pBaseString != NULL );
	DNASSERT( pAddress != NULL );
	
	pURL = NULL;
	dwURLSize = 0;

	hr = IDirectPlay8Address_GetURLA( pAddress, pURL, &dwURLSize );
	if ( hr != DPNERR_BUFFERTOOSMALL )
	{
		goto Failure;
	}
	
	pURL = static_cast<char*>( DNMalloc( dwURLSize ) );
	if ( pURL == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	hr = IDirectPlay8Address_GetURLA( pAddress, pURL, &dwURLSize );
	if ( hr != DPN_OK )
	{
		goto Failure;
	}


	DNASSERT( pURL != NULL );
	DPFX(DPFPREP,  dwDebugLevel, "%s 0x%p - \"%s\"", pBaseString, pAddress, pURL );

Exit:
	if ( pURL != NULL )
	{
		DNFree( pURL );
		pURL = NULL;
	}

	return;

Failure:
	DPFX(DPFPREP,  dwDebugLevel, "Failing DumpAddress:" );
	DisplayDNError( dwDebugLevel, hr );

	goto Exit;
}

#endif	// _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\dwinsock.h ===
//
// DWINSOCK.H	Dynamic WinSock
//
//				Functions for dynamically linking to
//				best available WinSock.
//
//				Dynamically links to WS2_32.DLL or
//				if WinSock 2 isn't available, it
//				dynamically links to WSOCK32.DLL.
//
//

#ifndef DWINSOCK_H
#define DWINSOCK_H


// added to support multiple instantiation/initialization
typedef struct _DWSSTATE
{
	HINSTANCE	hndlWinSock;
	int			nVersion;
	int			nMaxUdp	;
} DWSSTATE, *LPDWSSTATE;


int  DWSInitWinSock(LPDWSSTATE lpState );
BOOL DWSFreeWinSock(LPDWSSTATE lpState);
int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
					   DWORD dwAddrLen,
					   LPSTR lpAddrStr,
					   LPDWORD pdwStrLen);
//
// Define generic pointer names for both
// ANSI and Wide versions
//
#ifdef UNICODE
	#define p_WSASocket							p_WSASocketW
#else
	#define p_WSASocket							p_WSASocketA
#endif // UNICODE


#endif // DWINSOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\dwnsock2.inc ===
//
// DWNSOCK2.INC	Macros for dynamically linking to WinSock 2
//

#ifdef DWINSOCK_GLOBAL
	#undef DYNAMICWINSOCK
	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
#endif

#ifdef DWINSOCK_EXTERN
	#undef DYNAMICWINSOCK
	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
#endif

#ifdef DWINSOCK_GETPROCADDRESS
	#undef DYNAMICWINSOCK
	#define DYNAMICWINSOCK(name, ptr)							\
				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
				if (p_##name == NULL) fOK = FALSE
#endif

	DYNAMICWINSOCK(WSAGetOverlappedResult, LPFN_WSAGETOVERLAPPEDRESULT);
	DYNAMICWINSOCK(WSAIoctl, LPFN_WSAIOCTL);
	DYNAMICWINSOCK(WSARecvFrom, LPFN_WSARECVFROM);
	DYNAMICWINSOCK(WSASendTo, LPFN_WSASENDTO);
	DYNAMICWINSOCK(WSASocketA, LPFN_WSASOCKETA);
	DYNAMICWINSOCK(WSASocketW, LPFN_WSASOCKETW);
	DYNAMICWINSOCK(WSAEnumProtocolsA, LPFN_WSAENUMPROTOCOLSA);
	DYNAMICWINSOCK(WSAEnumProtocolsW, LPFN_WSAENUMPROTOCOLSW);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\dwnsock1.inc ===
//
// DWNSOCK1.INC	Macros for dynamically linking to WinSock 1.1
//

#ifdef DWINSOCK_GLOBAL
	#undef DYNAMICWINSOCK
	#define DYNAMICWINSOCK(name, ptr) ptr p_##name
#endif

#ifdef DWINSOCK_EXTERN
	#undef DYNAMICWINSOCK
	#define DYNAMICWINSOCK(name, ptr) extern ptr p_##name
#endif

#ifdef DWINSOCK_GETPROCADDRESS
	#undef DYNAMICWINSOCK
	#define DYNAMICWINSOCK(name, ptr)							\
				p_##name = (ptr)GetProcAddress(hndlWinSock, #name);	\
				if (p_##name == NULL) fOK = FALSE
#endif

#ifndef ___WSAFDISSET___
typedef
int
(WSAAPI * LPFN_WSAFDISSET)(
    IN SOCKET s,
    OUT fd_set FAR *fds
    );
#define ___WSAFDISSET___
#endif

	//
	// Function available in both versions
	//
	DYNAMICWINSOCK(accept, LPFN_ACCEPT);
	DYNAMICWINSOCK(bind, LPFN_BIND);
	DYNAMICWINSOCK(closesocket, LPFN_CLOSESOCKET);
	DYNAMICWINSOCK(connect, LPFN_CONNECT);
	DYNAMICWINSOCK(gethostbyname, LPFN_GETHOSTBYNAME);
	DYNAMICWINSOCK(gethostname, LPFN_GETHOSTNAME);
	DYNAMICWINSOCK(getsockname, LPFN_GETSOCKNAME);
	DYNAMICWINSOCK(getsockopt, LPFN_GETSOCKOPT);
	DYNAMICWINSOCK(htonl, LPFN_HTONL);
	DYNAMICWINSOCK(htons, LPFN_HTONS);
	DYNAMICWINSOCK(inet_addr, LPFN_INET_ADDR);
	DYNAMICWINSOCK(inet_ntoa, LPFN_INET_NTOA);
	DYNAMICWINSOCK(ioctlsocket, LPFN_IOCTLSOCKET);
	DYNAMICWINSOCK(listen, LPFN_LISTEN);
	DYNAMICWINSOCK(ntohl, LPFN_NTOHL);
	DYNAMICWINSOCK(ntohs, LPFN_NTOHS);
	DYNAMICWINSOCK(recvfrom, LPFN_RECVFROM);
	DYNAMICWINSOCK(select, LPFN_SELECT);
	DYNAMICWINSOCK(sendto, LPFN_SENDTO);
	DYNAMICWINSOCK(setsockopt, LPFN_SETSOCKOPT);
	DYNAMICWINSOCK(shutdown, LPFN_SHUTDOWN);
	DYNAMICWINSOCK(socket, LPFN_SOCKET);
	DYNAMICWINSOCK(WSACleanup, LPFN_WSACLEANUP);
	DYNAMICWINSOCK(WSAGetLastError, LPFN_WSAGETLASTERROR);
	DYNAMICWINSOCK(WSASetLastError, LPFN_WSASETLASTERROR);
	DYNAMICWINSOCK(WSAStartup, LPFN_WSASTARTUP);
	DYNAMICWINSOCK(__WSAFDIsSet, LPFN_WSAFDISSET);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\debugutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DebugUtils.h
 *  Content:	Winsock service provider debug utilitiy functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	12/01/98	jtk		Created
 *  01/10/20000	rmt		Updated to build with Millenium build process
 ***************************************************************************/

#ifndef __DEBUG_UTILS_H__
#define __DEBUG_UTILS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct sockaddr SOCKADDR;
typedef struct IDirectPlay8Address	IDirectPlay8Address;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifdef	_DEBUG

void	HexDump( PVOID pData, UINT32 uDataSize );
void	DumpSocketAddress( const DWORD dwDebugLevel, const SOCKADDR *const pSocketAddress, const DWORD dwFamily );
void	DumpAddress( const DWORD dwDebugLevel, const char *const pBaseString, IDirectPlay8Address *const pAddress );

#else	// _DEBUG

#define HexDump( x, y )
#define DumpSocketAddress( x, y, z )
#define	DumpAddress( x, y, z )

#endif	// _DEBUG

#endif	// __DEBUG_UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\dwinsock.cpp ===
//
// DWINSOCK.C	Dynamic WinSock
//
//				Functions for dynamically linking to
//				best available WinSock.
//
//				Dynamically links to WS2_32.DLL or
//				if WinSock 2 isn't available, it
//				dynamically links to WSOCK32.DLL.
//
//

#include "dnwsocki.h"


//
// Declare global function pointers
//
#define DWINSOCK_GLOBAL
#include "dwnsock1.inc"
#include "dwnsock2.inc"

//
// Internal Functions and data
//
static BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2);
static int IPXAddressToString(LPSOCKADDR_IPX pAddr,
					   DWORD dwAddrLen,
					   LPTSTR lpAddrStr,
					   LPDWORD pdwStrLen);

////////////////////////////////////////////////////////////

int DWSInitWinSock(LPDWSSTATE lpState )
{
	WORD wVersionRequested;
	BOOL f2Loaded = TRUE;
	WSADATA wsaData;
	int nRet;

	if (lpState == NULL)
		return 0;
	//
	// Attempt to dynamically load WS2_32.DLL
	//
#ifdef WINNT
	lpState->hndlWinSock = LoadLibrary(TEXT("WS2_32.DLL"));
	if (lpState->hndlWinSock == NULL)
	{
		return 0;
	}
#else // WIN95
	//
	// Try Winsock 2 first
	//
	lpState->hndlWinSock = LoadLibrary(TEXT("WS2_32.DLL"));
	if (lpState->hndlWinSock != NULL)
	{
		goto SkipWinsock1Load;
	}

	//
	// Couldn't load WinSock 2, try 1.1
	//
	f2Loaded = FALSE;
	lpState->hndlWinSock = LoadLibrary(TEXT("WSOCK32.DLL"));
	if (lpState->hndlWinSock == NULL)
		return 0;

SkipWinsock1Load:
#endif // WIN95
	//
	// Use GetProcAddress to initialize
	// the function pointers
	//
	if (!MapFunctionPointers(lpState, f2Loaded))
		return 0;

	//
	// If WinSock 2 was loaded, ask for 2.2 otherwise 1.1
	//
	if (f2Loaded)
		wVersionRequested = MAKEWORD(2,2);
	else
		wVersionRequested = MAKEWORD(1,1);

	//
	// Call WSAStartup()
	//
	nRet = p_WSAStartup(wVersionRequested, &wsaData);
	if (nRet)
	{
		FreeLibrary(lpState->hndlWinSock);
		return 0;
	}

	if (wVersionRequested != wsaData.wVersion)
	{
		FreeLibrary(lpState->hndlWinSock);
		return 0;
	}

	// Save Max UDP for use with 1.1
	lpState->nMaxUdp = wsaData.iMaxUdpDg;

	//
	// Return 1 or 2
	//
	lpState->nVersion = f2Loaded ? 2 : 1;
	return(lpState->nVersion);
}

////////////////////////////////////////////////////////////

BOOL DWSFreeWinSock(LPDWSSTATE lpState)
{
	if (lpState == NULL)
		return FALSE;

	if (p_WSACleanup != NULL)
		p_WSACleanup();
	lpState->nVersion = 0;
	return(FreeLibrary(lpState->hndlWinSock));
}

////////////////////////////////////////////////////////////

BOOL MapFunctionPointers(LPDWSSTATE lpState, BOOL fMapVersion2)
{
	// we set the local lib handle for use with the
	//	macros
	HINSTANCE	hndlWinSock = lpState->hndlWinSock;
	//
	// This variable must be declared
	// with this name in order to use
	// #define DWINSOCK_GETPROCADDRESS
	//
	BOOL fOK = TRUE;

	//
	// GetProcAddress for functions
	// available in both 1.1 and 2
	//
	#define DWINSOCK_GETPROCADDRESS
	#include "dwnsock1.inc"

	//
	// If that went OK, and we're supposed
	// to map version 2, then do GetProcAddress
	// for functions only available in WinSock 2
	//
	if (fOK && fMapVersion2)
	{
		#include "dwnsock2.inc"
	}
	return fOK;
}

////////////////////////////////////////////////////////////

char NibbleToHex(BYTE b)
{
    if (b < 10)
		return (b + '0');

    return (b - 10 + 'A');
}

void BinToHex(PBYTE pBytes, int nNbrBytes, LPSTR lpStr)
{
	BYTE b;
    while(nNbrBytes--)
    {
		// High order nibble first
		b = (*pBytes >> 4);
		*lpStr = NibbleToHex(b);
		lpStr++;
		// Then low order nibble
		b = (*pBytes & 0x0F);
		*lpStr = NibbleToHex(b);
		lpStr++;
		pBytes++;
    }
    *lpStr = '\0';
}

////////////////////////////////////////////////////////////

//
// Workaround for WSAAddressToString()/IPX bug
//
int IPXAddressToString(LPSOCKADDR_IPX pAddr,
					   DWORD dwAddrLen,
					   LPTSTR lpAddrStr,
					   LPDWORD pdwStrLen)
{
	char szAddr[32];
	char szTmp[20];
	char *cp = szAddr;
	//
	// Check destination length
	//
	if (*pdwStrLen < 27)
	{
		p_WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;
	}

	//
	// Convert network number
	//
    BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
	strcpy(szAddr, szTmp);
    strcat(szAddr, ",");

	// Node Number
    BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
    strcat(szAddr, szTmp);
    strcat(szAddr, ":");

	// IPX Address Socket number
    BinToHex((PBYTE)&pAddr->sa_socket, 2, szTmp);
    strcat(szAddr, szTmp);

#ifdef UNICODE
	//
	// Convert inet_ntoa string to wide char
	//
	int nRet = MultiByteToWideChar(CP_ACP,
								0,
								szAddr,
								-1,
								lpAddrStr,
								*pdwStrLen);
	if (nRet == 0)
	{
		if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
			p_WSASetLastError(WSAEFAULT);
		else
			p_WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;
	}
#else
	//
	// ANSI -- Check the string length
	//
	if (strlen(szAddr) > *pdwStrLen)
	{
		p_WSASetLastError(WSAEFAULT);
		*pdwStrLen = strlen(szAddr);
		return SOCKET_ERROR;
	}
	strcpy(lpAddrStr, szAddr);
	*pdwStrLen = strlen(szAddr);
#endif

	return 0;
}


//
// Workaround for WSAAddressToString()/IPX bug
//
int IPXAddressToStringNoSocket(LPSOCKADDR pSAddr,
					   DWORD dwAddrLen,
					   LPSTR lpAddrStr,
					   LPDWORD pdwStrLen)
{
	char szAddr[32];
	char szTmp[20];
	char *cp = szAddr;
	LPSOCKADDR_IPX pAddr = (LPSOCKADDR_IPX) pSAddr;
	//
	// Check destination length
	//
	if (*pdwStrLen < 27)
	{
		p_WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;
	}

	//
	// Convert network number
	//
    BinToHex((PBYTE)&pAddr->sa_netnum, 4, szTmp);
	strcpy(szAddr, szTmp);
    strcat(szAddr, ",");

	// Node Number
    BinToHex((PBYTE)&pAddr->sa_nodenum, 6, szTmp);
    strcat(szAddr, szTmp);

	strcpy(lpAddrStr, szAddr);
	*pdwStrLen = strlen(szAddr);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\endpoint.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Endpoint.cpp
 *  Content:	Winsock endpoint base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 *  01/10/2000	rmt		Updated to build with Millenium build process
 *  03/22/2000	jtk		Updated with changes to interface names
 *	03/12/01	mjn		Prevent enum responses from being indicated up after completion
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK



//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _MULTIPLEXEDADAPTERASSOCIATION
{
	CSPData *	pSPData;		// pointer to current SP interface for verification
	CBilink *	pBilink;		// pointer to list of endpoints for commands multiplexed over more than one adapter
	DWORD		dwEndpointID;	// identifier of endpoint referred to in bilink
} MULTIPLEXEDADAPTERASSOCIATION, * PMULTIPLEXEDADAPTERASSOCIATION;


//
// It's possible (although not advised) that this structure would get
// passed to a different platform, so we need to ensure that it always
// looks the same.
//
#pragma	pack(push, 1)

typedef struct _PROXIEDRESPONSEORIGINALADDRESS
{
	DWORD	dwSocketPortID;				// unique identifier for socketport originally sending packet
	DWORD	dwOriginalTargetAddressV4;	// the IPv4 address to which the packet was originally sent, in network byte order
	WORD	wOriginalTargetPort;		// the port to which the packet was originally sent, in network byte order
} PROXIEDRESPONSEORIGINALADDRESS, * PPROXIEDRESPONSEORIGINALADDRESS;

#pragma	pack(pop)


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CEndpoint - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CEndpoint"

CEndpoint::CEndpoint():
	m_State( ENDPOINT_STATE_UNINITIALIZED ),
	m_fConnectSignalled( FALSE ),
	m_EndpointType( ENDPOINT_TYPE_UNKNOWN ),
	m_pRemoteMachineAddress( NULL ),
	m_pSPData( NULL ),
	m_pSocketPort( NULL ),
	m_GatewayBindType( GATEWAY_BIND_TYPE_UNKNOWN ),
	m_pUserEndpointContext( NULL ),
	m_fListenStatusNeedsToBeIndicated( FALSE ),
	m_dwNumReceives( 0 ),
	m_Handle( INVALID_HANDLE_VALUE ),
	m_lCommandRefCount( 0 ),
	m_hActiveSettingsDialog( NULL ),
	m_hDisconnectIndicationHandle( INVALID_HANDLE_VALUE ),
	m_pCommandParameters( NULL ),
	m_pActiveCommandData( NULL ),
	m_dwThreadCount( 0 ),
	m_dwEndpointID( 0 )
{
	m_blMultiplex.Initialize();
	DEBUG_ONLY( m_fInitialized = FALSE );
	DEBUG_ONLY( m_fEndpointOpen = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::~CEndpoint - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::~CEndpoint"

CEndpoint::~CEndpoint()
{
	DNASSERT( m_State == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( m_fConnectSignalled == FALSE );
	DNASSERT( m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( m_pRemoteMachineAddress == NULL );
	DNASSERT( m_pSPData == NULL );
	DNASSERT( m_pSocketPort == NULL );
	DNASSERT( m_GatewayBindType == GATEWAY_BIND_TYPE_UNKNOWN );
	DNASSERT( m_pUserEndpointContext == NULL );
	DNASSERT( GetActiveDialogHandle() == NULL );
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( m_blMultiplex.IsEmpty() );
	DNASSERT( m_Handle == INVALID_HANDLE_VALUE );
	DNASSERT( m_lCommandRefCount == 0 );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetCommandParameters() == NULL );
	DNASSERT( m_pActiveCommandData == NULL );

	DNASSERT( m_EnumKey.GetKey() == INVALID_ENUM_KEY );
	DNASSERT( m_fEndpointOpen == FALSE );
	DNASSERT( m_fInitialized == FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Initialize - initialize an endpoint
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Initialize"

HRESULT	CEndpoint::Initialize( void )
{
	HRESULT	hr;


	DNASSERT( m_pSPData == NULL );
	DNASSERT( m_fInitialized == FALSE );

	//
	// initialize
	//
	hr = DPN_OK;

	//
	// attempt to initialize the internal critical section
	//
	if ( DNInitializeCriticalSection( &m_Lock )	== FALSE )
	{
		DPFX(DPFPREP, 0, "Problem initializing critical section for this endpoint!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Deinitilize - deinitialize an endpoint
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Deinitialize"

void	CEndpoint::Deinitialize( void )
{
	DNDeleteCriticalSection( &m_Lock );
	DNASSERT( m_pSPData == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Open - open endpoint for use
//
// Entry:		Type of endpoint
//				Pointer to address to of remote machine
//				Pointer to socket address of remote machine
//
// Exit:		Nothing
//
// Note:	Any call to Open() will require an associated call to Close().
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Open"

HRESULT	CEndpoint::Open( const ENDPOINT_TYPE EndpointType,
						 IDirectPlay8Address *const pDP8Address,
						 const CSocketAddress *const pSocketAddress
						 )
{
	HRESULT	hr;


	DPFX(DPFPREP, 6, "(0x%p) Parameters (%u, 0x%p, 0x%p)",
		this, EndpointType, pDP8Address, pSocketAddress);


//	DNASSERT( pSocketPort != NULL );
	DNASSERT( ( pDP8Address != NULL ) ||
			  ( pSocketAddress != NULL ) ||
			  ( ( EndpointType == ENDPOINT_TYPE_LISTEN ) )
			  );
	DNASSERT( m_fInitialized != FALSE );
	DNASSERT( m_fEndpointOpen == FALSE );

	//
	// initialize
	//
	hr = DPN_OK;
	DEBUG_ONLY( m_fEndpointOpen = TRUE );

//	DNASSERT( m_pSocketPort == NULL );
//	m_pSocketPort = pSocketPort;
//	pSocketPort->EndpointAddRef();

	DNASSERT( m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	m_EndpointType = EndpointType;

	//
	// determine the endpoint type so we know how to handle the input parameters
	//
	switch ( EndpointType )
	{
		case ENDPOINT_TYPE_ENUM:
		{
			DNASSERT( pSocketAddress == NULL );
			DNASSERT( pDP8Address != NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			
			//
			//	Preset thread count
			//
			m_dwThreadCount = 0;
			
			hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pDP8Address, SP_ADDRESS_TYPE_HOST );
			if ( hr != DPN_OK )
			{
				if (hr == DPNERR_INCOMPLETEADDRESS)
				{
					DPFX(DPFPREP, 1, "Enum endpoint DP8Address is incomplete." );
				}
				else
				{
					DPFX(DPFPREP, 0, "Problem converting DP8Address to IP address in Open!" );
					DisplayDNError( 0, hr );
				}
				goto Failure;
			}
			
			break;
		}

		//
		// standard endpoint creation, attempt to parse the input address
		//
		case ENDPOINT_TYPE_CONNECT:
		{
			DNASSERT( pSocketAddress == NULL );
			DNASSERT( pDP8Address != NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			
			hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pDP8Address, SP_ADDRESS_TYPE_HOST );
			if ( hr != DPN_OK )
			{
				if (hr == DPNERR_INCOMPLETEADDRESS)
				{
					DPFX(DPFPREP, 1, "Connect endpoint DP8Address is incomplete." );
				}
				else
				{
					DPFX(DPFPREP, 0, "Problem converting DP8Address to IP address in Open!" );
					DisplayDNError( 0, hr );
				}
				goto Failure;
			}


			//
			// Make sure the user isn't trying to connect to the DPNSVR port.
			//
			if ( p_ntohs(m_pRemoteMachineAddress->GetPort()) == DPNA_DPNSVR_PORT )
			{
				DPFX(DPFPREP, 0, "Attempting to connect to DPNSVR reserved port!" );
				hr = DPNERR_INVALIDHOSTADDRESS;
				goto Failure;
			}

			break;
		}

		//
		// listen, there should be no input DNAddress
		//
		case ENDPOINT_TYPE_LISTEN:
		{
			DNASSERT( pSocketAddress == NULL );
			DNASSERT( pDP8Address == NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );

			break;
		}

		//
		// new endpoint spawned from a listen, copy the input address and
		// note that this endpoint is really just a connection
		//
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
		{
			DNASSERT( pSocketAddress != NULL );
			DNASSERT( pDP8Address == NULL );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			m_pRemoteMachineAddress->CopyAddressSettings( pSocketAddress );
			//m_EndpointType = ENDPOINT_TYPE_CONNECT;
			m_State = ENDPOINT_STATE_ATTEMPTING_CONNECT;

			break;
		}

		//
		// unknown type
		//
		default:
		{
			DNASSERT( FALSE );
			break;

		}
	}

Exit:

	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);
	
	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Close - close an endpoint
//
// Entry:		Error code for active command
//
// Exit:		Error code
//
// Note:	This code does not disconnect an endpoint from its associated
//			socket port.  That is the responsibility of the code that is
//			calling this function.  This function assumes that this endpoint
//			is locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Close"

void	CEndpoint::Close( const HRESULT hActiveCommandResult )
{
	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%lx)", this, hActiveCommandResult);

	
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	this->SetEndpointID( 0 );
	
	//
	// There are cases where an attempt can be made to close an endpoint
	// twice.  Ideally, that would be fixed, but for now, since it's benign, I'm
	// removing the assert.
	//
	//DNASSERT( m_fEndpointOpen != FALSE );
	DNASSERT( m_fInitialized != FALSE );

	//
	// is there an active command?
	//
	if ( CommandPending() != FALSE )
	{
		//
		// cancel any active dialogs
		// if there are no dialogs, cancel the active command
		//
		if ( GetActiveDialogHandle() != NULL )
		{
			StopSettingsDialog( GetActiveDialogHandle() );
		}

		SetPendingCommandResult( hActiveCommandResult );
	}
	else
	{
		//
		// there should be no active dialog if there isn't an active command
		//
		DNASSERT( GetActiveDialogHandle() == NULL );
	}

	DEBUG_ONLY( m_fEndpointOpen = FALSE );


	DPFX(DPFPREP, 6, "(0x%p) Leaving", this);

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ChangeLoopbackAlias - change the loopback alias to a real address
//
// Entry:		Pointer to real address to use
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ChangeLoopbackAlias"

void	CEndpoint::ChangeLoopbackAlias( const CSocketAddress *const pSocketAddress ) const
{
	DNASSERT( m_pRemoteMachineAddress != NULL );
	m_pRemoteMachineAddress->ChangeLoopBackToLocalAddress( pSocketAddress );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::MungeProxiedAddress - modify this endpoint's remote address with proxied response information, if any
//
// Entry:		Pointer to socketport about to be bound
//				Pointer to remote host address
//				Whether its an enum or not
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CEndpoint::MungeProxiedAddress"

void	CEndpoint::MungeProxiedAddress( const CSocketPort * const pSocketPort,
										IDirectPlay8Address *const pHostAddress,
										const BOOL fEnum )
{
	HRESULT							hrTemp;
	PROXIEDRESPONSEORIGINALADDRESS	proa;
	DWORD							dwComponentSize;
	DWORD							dwComponentType;
	BYTE *							pbZeroExpandedStruct;
	DWORD							dwZeroExpands;
	BYTE *							pbStructAsBytes;
	BYTE *							pbValue;


	DNASSERT((this->GetType() == ENDPOINT_TYPE_CONNECT) || (this->GetType() == ENDPOINT_TYPE_ENUM));

	DNASSERT(this->m_pRemoteMachineAddress != NULL);

	DNASSERT(pSocketPort != NULL);
	DNASSERT(pSocketPort->GetNetworkAddress() != NULL);

	DNASSERT(pHostAddress != NULL);
	

	//
	// Proxying can only occur for IP, so bail if it's IPX.
	//
	if (pSocketPort->GetNetworkAddress()->GetFamily() != AF_INET)
	{
		//
		// Not IP socketport.  Bail.
		//
		return;
	}


	//
	// See if the proxied response address component exists.
	//

	dwComponentSize = 0;
	dwComponentType = 0;
	hrTemp = IDirectPlay8Address_GetComponentByName( pHostAddress,										// interface
													DPNA_PRIVATEKEY_PROXIED_RESPONSE_ORIGINAL_ADDRESS,	// tag
													NULL,												// component buffer
													&dwComponentSize,									// component size
													&dwComponentType									// component type
													);
	if (hrTemp != DPNERR_BUFFERTOOSMALL)
	{
		//
		// The component doesn't exist (or something else really weird
		// happened).  Bail.
		//
		return;
	}


	memset(&proa, 0, sizeof(proa));


	//
	// If the component type indicates the data is "binary", this is the original
	// address and we're good to go.  Same with ANSI strings; but the
	// addressing library currently will never return that I don't believe.
	// If it's a "Unicode string", the data probably got washed through the
	// GetURL/BuildFromURL functions (via Duplicate most likely).
	// The funky part is, every time through the wringer, each byte gets expanded
	// into a word (i.e. char -> WCHAR).  So when we retrieve it, it's actually not
	// a valid Unicode string, but a goofy expanded byte blob.  See below.
	// In all cases, the size of the buffer should be a multiple of the size of the
	// PROXIEDRESPONSEORIGINALADDRESS structure.
	//
	if ((dwComponentSize % sizeof(proa)) != 0)
	{
		//
		// The component isn't the right size.  Bail.
		//
		DPFX(DPFPREP, 0, "Private proxied response original address value is not a valid size (%u is not a multiple of %u)!  Ignoring.",
			dwComponentSize, sizeof(proa));
		return;
	}


	pbZeroExpandedStruct = (BYTE*) DNMalloc(dwComponentSize);
	if (pbZeroExpandedStruct == NULL)
	{
		//
		// Out of memory.  We have to bail.
		//
		return;
	}


	//
	// Retrieve the actual data.
	//
	hrTemp = IDirectPlay8Address_GetComponentByName( pHostAddress,										// interface
													DPNA_PRIVATEKEY_PROXIED_RESPONSE_ORIGINAL_ADDRESS,	// tag
													pbZeroExpandedStruct,									// component buffer
													&dwComponentSize,									// component size
													&dwComponentType									// component type
													);
	if (hrTemp != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed retrieving private proxied response original address value (err = 0x%lx)!",
			hrTemp);

		DNFree(pbZeroExpandedStruct);
		pbZeroExpandedStruct = NULL;

		return;
	}


	//
	// Loop through the returned buffer and pop out the relevant bytes.
	//
	// 0xBB 0xAA			became 0xBB 0x00 0xAA, 0x00,
	// 0xBB 0x00 0xAA, 0x00	became 0xBB 0x00 0x00 0x00 0xAA 0x00 0x00 0x00,
	// etc.
	//

	dwZeroExpands = dwComponentSize / sizeof(proa);
	DNASSERT(dwZeroExpands > 0);


	DPFX(DPFPREP, 3, "Got %u byte expanded private proxied response original address key value (%u to 1 correspondence).",
		dwComponentSize, dwZeroExpands);


	pbStructAsBytes = (BYTE*) (&proa);
	pbValue = pbZeroExpandedStruct;

	while (dwComponentSize > 0)
	{
		(*pbStructAsBytes) = (*pbValue);
		pbStructAsBytes++;
		pbValue += dwZeroExpands;
		dwComponentSize -= dwZeroExpands;
	}
	

	DNFree(pbZeroExpandedStruct);
	pbZeroExpandedStruct = NULL;


	//
	// Once here, we've successfully read the proxied response original
	// address structure.
	//
	// We could have regkey to always set the target socketaddress back
	// to the original but the logic that picks the port could give the
	// wrong one and it's not necessary for the scenario we're
	// specifically trying to enable (ISA Server proxy).  See
	// CSocketPort::ProcessReceivedData.
	if (proa.dwSocketPortID != pSocketPort->GetSocketPortID())
	{
		SOCKADDR_IN *	psaddrinTemp;


		//
		// Since we're not using the exact same socket as what sent the
		// enum that generated the redirected response, the proxy may
		// have since removed the mapping.  Sending to the redirect
		// address will probably not work, so let's try going back to
		// the original address we were enumerating (and having the
		// proxy generate a new mapping).
		//


		//
		// Update the target.
		//
		psaddrinTemp = (SOCKADDR_IN*) this->m_pRemoteMachineAddress->GetWritableAddress();
		psaddrinTemp->sin_addr.S_un.S_addr	= proa.dwOriginalTargetAddressV4;
		psaddrinTemp->sin_port				= proa.wOriginalTargetPort;


		DPFX(DPFPREP, 2, "Socketport 0x%p is different from the one that received redirected response, using original target address %s:%u",
			pSocketPort, p_inet_ntoa(psaddrinTemp->sin_addr),
			p_ntohs(psaddrinTemp->sin_port));


		DNASSERT(psaddrinTemp->sin_addr.S_un.S_addr != INADDR_ANY);
		DNASSERT(psaddrinTemp->sin_addr.S_un.S_addr != INADDR_BROADCAST);
		

		//
		//
		// There's a wrinkle involved here.  If the enum was originally
		// for the DPNSVR port, but we're now trying to connect, trying
		// to connect to the DPNSVR port won't work.  So we have to...
		// uh... guess the port.  So my logic will be: assume the remote
		// port is the same as the local one.  I figure, if the app is
		// using a custom port here, it probably was set on the other
		// side.  If it was an arbitrary port, we used a deterministic
		// algorithm to pick it, and it probably was done on the other
		// side, too.  The three cases where this won't work:
		//	1) when the server binds to a specific port but clients let
		//		DPlay pick. But if that side knew the server port ahead
		//		of time, this side probably doesn't need to enumerate
		//		the DPNSVR port, it should just enum the game port.
		//	2) when the other side let DPlay pick the port, but it was
		//		behind a NAT and thus the external port is something
		//		other than our default range.  Since it's behind a NAT,
		//		the remote user almost certainly communicated the public
		//		IP to this user, it should also be mentioning the port,
		//		and again, we can avoid the DPNSVR port.
		//	3) when DPlay was allowed to choose a port, but this machine
		//		and the remote one had differing ports already in use
		//		(i.e. this machine has no DPlay apps running and picked
		//		2302, but the remote machine has another DPlay app
		//		occupying port 2302 so we're actually want to get to
		//		2303.  Obviously, only workaround here is to keep that
		//		enum running so that we skip here and drop into the
		//		'else' case instead.
		//
		if ((p_ntohs(proa.wOriginalTargetPort) == DPNA_DPNSVR_PORT) && (! fEnum))
		{
			psaddrinTemp->sin_port			= pSocketPort->GetNetworkAddress()->GetPort();

			DPFX(DPFPREP, 1, "Original enum target was for DPNSVR port, attempting to connect to port %u instead.",
				p_ntohs(psaddrinTemp->sin_port));
		}
	}
	else
	{
		//
		// Keep the redirected response address as the target, it's the
		// one the proxy probably intends us to use, see above comment).
		//
		// One additional problem - although we have the original target
		// we tried, it's conceivable that the proxy timed out the
		// mapping for the receive address and it would be no longer
		// valid.  The only way that would be possible with the current
		// DirectPlay core API is if the user got one of the redirected
		// enum responses, then the enum hit its retry limit and went to
		// the "wait for response" idle state and stayed that way such
		// that the the user started this enum/connect after the proxy
		// timeout but before the idle time expired.  Alternatively, if
		// he/she cancelled the enum before trying this enum/connect,
		// the above socketport ID check would fail unless a
		// simultaneous operation had kept the socketport open during
		// that time.  These scenarios don't seem that common, and I
		// don't expect a proxy timeout to be much shorter than 30-60
		// seconds anyway, so I think these are tolerable shortcomings.
		//
		DPFX(DPFPREP, 2, "Socketport 0x%p is the same, keeping redirected response address.",
			pSocketPort);
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CopyConnectData - copy data for connect command
//
// Entry:		Pointer to job information
//
// Exit:		Error code
//
// Note:	Device address needs to be preserved for later use.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyConnectData"

HRESULT	CEndpoint::CopyConnectData( const SPCONNECTDATA *const pConnectData )
{
	HRESULT	hr;
	ENDPOINT_COMMAND_PARAMETERS	*pCommandParameters;


	DNASSERT( pConnectData != NULL );
	
	DNASSERT( pConnectData->hCommand != NULL );
	DNASSERT( pConnectData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_pActiveCommandData == FALSE );

	//
	// initialize
	//
	hr = DPN_OK;
	pCommandParameters = NULL;

	pCommandParameters = CreateEndpointCommandParameters();
	if ( pCommandParameters != NULL )
	{
		SetCommandParameters( pCommandParameters );

		DBG_CASSERT( sizeof( pCommandParameters->PendingCommandData.ConnectData ) == sizeof( *pConnectData ) );
		memcpy( &pCommandParameters->PendingCommandData, pConnectData, sizeof( pCommandParameters->PendingCommandData.ConnectData ) );

		pCommandParameters->PendingCommandData.ConnectData.pAddressHost = pConnectData->pAddressHost;
		IDirectPlay8Address_AddRef( pConnectData->pAddressHost );

		pCommandParameters->PendingCommandData.ConnectData.pAddressDeviceInfo = pConnectData->pAddressDeviceInfo;
		IDirectPlay8Address_AddRef( pConnectData->pAddressDeviceInfo );

		m_pActiveCommandData = static_cast<CCommandData*>( pCommandParameters->PendingCommandData.ConnectData.hCommand );
		m_pActiveCommandData->SetUserContext( pCommandParameters->PendingCommandData.ConnectData.pvContext );
		m_State = ENDPOINT_STATE_ATTEMPTING_CONNECT;
	
		DNASSERT( hr == DPN_OK );
	}
	else
	{
		hr = DPNERR_OUTOFMEMORY;
	}

	return	hr;
};
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ConnectJobCallback - asynchronous callback wrapper from work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ConnectJobCallback"

void	CEndpoint::ConnectJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	// initialize
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo != NULL );

	hr = pThisEndpoint->CompleteConnect();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem completing connect in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	//
	// Don't do anything here because it's possible that this object was returned
	// to the pool!!!
	//

Exit:
	pThisEndpoint->DecRef();
	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CancelConnectJobCallback - cancel for connect job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CancelConnectJobCallback"

void	CEndpoint::CancelConnectJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_CONNECT );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	pThisEndpoint->m_pActiveCommandData->Lock();
	DNASSERT( ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_PENDING ) ||
			  ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pActiveCommandData->Unlock();
	

	//
	// clean up
	//

	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );

	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost != NULL );
	IDirectPlay8Address_Release( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost );

	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo != NULL );
	IDirectPlay8Address_Release( pThisEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo );

	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->m_pSPData->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompleteConnect - complete connection
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompleteConnect"

HRESULT	CEndpoint::CompleteConnect( void )
{
	HRESULT							hr;
	HRESULT							hTempResult;
	SPIE_CONNECT					ConnectIndicationData;
	BOOL							fEndpointBound;
	SPIE_CONNECTADDRESSINFO			ConnectAddressInfo;
	IDirectPlay8Address *			pHostAddress;
	IDirectPlay8Address *			pDeviceAddress;
	GATEWAY_BIND_TYPE				GatewayBindType;
	DWORD							dwConnectFlags;
	MULTIPLEXEDADAPTERASSOCIATION	maa;
	DWORD							dwComponentSize;
	DWORD							dwComponentType;
	CBilink *						pBilinkAll;
	CEndpoint *						pTempEndpoint;
	CSocketPort *					pSocketPort;
	SOCKADDR_IN *					psaddrinTemp;
	SOCKADDR						saddrPublic;
	CBilink *						pBilinkPublic;
	CEndpoint *						pPublicEndpoint;
	CSocketPort *					pPublicSocketPort;
	DWORD							dwTemp;
	DWORD							dwPublicAddressesSize;
	DWORD							dwAddressTypeFlags;
	CSocketAddress *				pSocketAddress;
	CBilink							blIndicate;
	CBilink							blFail;
	BOOL							fLockedSocketPortData;


	DNASSERT( GetCommandParameters() != NULL );
	DNASSERT( m_State == ENDPOINT_STATE_ATTEMPTING_CONNECT );
	DNASSERT( m_pActiveCommandData != NULL );

	DPFX(DPFPREP, 6, "(0x%p) Enter", this);
	
	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointBound = FALSE;
	memset( &ConnectAddressInfo, 0x00, sizeof( ConnectAddressInfo ) );
	blIndicate.Initialize();
	blFail.Initialize();
	fLockedSocketPortData = FALSE;

	DNASSERT( GetCommandParameters()->PendingCommandData.ConnectData.hCommand == m_pActiveCommandData );
	DNASSERT( GetCommandParameters()->PendingCommandData.ConnectData.dwCommandDescriptor != NULL_DESCRIPTOR );

	DNASSERT( GetCommandParameters()->GatewayBindType == GATEWAY_BIND_TYPE_UNKNOWN) ;


	//
	// Transfer address references to our local pointers.  These will be released
	// at the end of this function, but we'll keep the pointers in the pending command
	// data so CSPData::BindEndpoint can still access them.
	//
	
	pHostAddress = GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost;
	DNASSERT( pHostAddress != NULL );

	pDeviceAddress = GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo;
	DNASSERT( pDeviceAddress != NULL );


	//
	// Retrieve other parts of the command parameters for convenience.
	//
	GatewayBindType = GetCommandParameters()->GatewayBindType;
	dwConnectFlags = GetCommandParameters()->PendingCommandData.ConnectData.dwFlags;


	//
	// check for user cancelling command
	//
	this->m_pActiveCommandData->Lock();

	DNASSERT( this->m_pActiveCommandData->GetType() == COMMAND_TYPE_CONNECT );
	switch ( this->m_pActiveCommandData->GetState() )
	{
		//
		// command was pending, that's fine
		//
		case COMMAND_STATE_PENDING:
		{
			DNASSERT( hr == DPN_OK );

			break;
		}
		
		//
		// command was previously uninterruptable (probably because the connect UI
		// was displayed), mark it as pending
		//
		case COMMAND_STATE_INPROGRESS_CANNOT_CANCEL:
		{
			this->m_pActiveCommandData->SetState( COMMAND_STATE_PENDING );
			DNASSERT( hr == DPN_OK );

			break;
		}
		
		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP, 0, "User cancelled connect!" );

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	this->m_pActiveCommandData->Unlock();
	
	if ( hr != DPN_OK )
	{
		goto Failure;
	}



	//
	// Bind the endpoint.  Note that the GATEWAY_BIND_TYPE actually used
	// (this->GetGatewayBindType()) may differ from GatewayBindType.
	//
	hr = m_pSPData->BindEndpoint( this, pDeviceAddress, NULL, GatewayBindType );
	if ( hr != DPN_OK )
	{
		//
		// If this is the last adapter, we may still need to complete other
		// connects, so we'll drop through to check for those.  Otherwise,
		// we'll bail right now.
		//
		if (dwConnectFlags & DPNSPF_ADDITIONALMULTIPLEXADAPTERS )
		{
			DPFX(DPFPREP, 0, "Failed to bind endpoint with other adapters remaining (err = 0x%lx)!", hr );
			DisplayDNError( 0, hr );
			goto Failure;
		}

		DPFX(DPFPREP, 0, "Failed to bind last multiplexed endpoint (err = 0x%lx)!", hr );
		DisplayDNError( 0, hr );
		
		this->SetPendingCommandResult( hr );
		hr = DPN_OK;

		//
		// Note that the endpoint is not bound!
		//
	}
	else
	{
		fEndpointBound = TRUE;
		
		//
		// attempt to indicate addressing to a higher layer
		//
		ConnectAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT,
																					this->GetGatewayBindType() );
		ConnectAddressInfo.pHostAddress = GetRemoteHostDP8Address();
		ConnectAddressInfo.hCommandStatus = DPN_OK;
		ConnectAddressInfo.pCommandContext = this->m_pActiveCommandData->GetUserContext();

		if ( ( ConnectAddressInfo.pHostAddress == NULL ) ||
			 ( ConnectAddressInfo.pDeviceAddress == NULL ) )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
	}


	//
	// We can run into problems with "multiplexed" device attempts when you are on
	// a NAT machine.  The core will try connecting on multiple adapters, but since
	// we are on the network boundary, each adapter can see and get responses from
	// both networks.  This causes problems with peer-to-peer sessions when the
	// "wrong" adapter gets selected (because it receives a response first).  To
	// prevent that, we are going to internally remember the association between
	// the multiplexed Connects so we can decide on the fly whether to indicate a
	// response or not.  Obviously this workaround/decision logic relies on having
	// internal knowledge of what the upper layer would be doing...
	//
	// So either build or add to the linked list of multiplexed Connects.
	// Technically this is only necessary for IP, since IPX can't have NATs, but
	// what's the harm in having a little extra info?
	//
		
	dwComponentSize = sizeof(maa);
	dwComponentType = 0;
	hTempResult = IDirectPlay8Address_GetComponentByName( pDeviceAddress,									// interface
														DPNA_PRIVATEKEY_MULTIPLEXED_ADAPTER_ASSOCIATION,	// tag
														&maa,												// component buffer
														&dwComponentSize,									// component size
														&dwComponentType									// component type
														);
	if (( hTempResult == DPN_OK ) && ( dwComponentSize == sizeof(MULTIPLEXEDADAPTERASSOCIATION) ) && ( dwComponentType == DPNA_DATATYPE_BINARY ))
	{
		//
		// We found the right component type.  See if it matches the right
		// CSPData object.
		//
		if ( maa.pSPData == this->m_pSPData )
		{
			this->m_pSPData->LockSocketPortData();
			//fLockedSocketPortData = TRUE;

			pTempEndpoint = CONTAINING_OBJECT(maa.pBilink, CEndpoint, m_blMultiplex);

			//
			// Make sure the endpoint is still around/valid.
			//
			// THIS MAY CRASH IF OBJECT POOLING IS DISABLED!
			//
			if ( pTempEndpoint->GetEndpointID() == maa.dwEndpointID )
			{
				DPFX(DPFPREP, 3, "Found correctly formed private multiplexed adapter association key, linking endpoint 0x%p with earlier connects (prev endpoint = 0x%p).",
					this, pTempEndpoint);

				DNASSERT( pTempEndpoint->GetType() == ENDPOINT_TYPE_CONNECT );
				DNASSERT( pTempEndpoint->GetState() != ENDPOINT_STATE_UNINITIALIZED );

				//
				// Actually link to the other endpoints.
				//
				this->m_blMultiplex.InsertAfter(maa.pBilink);
			}
			else
			{
				DPFX(DPFPREP, 1, "Found private multiplexed adapter association key, but prev endpoint 0x%p ID doesn't match (%u != %u), cannot link endpoint 0x%p and hoping this connect gets cancelled, too.",
					pTempEndpoint, pTempEndpoint->GetEndpointID(), maa.dwEndpointID, this);
			}


			//
			// Add this endpoint's connect command to the postponed list in case we need
			// to clean it up at shutdown.
			//
			this->m_pActiveCommandData->AddToPostponedList( this->m_pSPData->GetPostponedConnectsBilink() );
			

			this->m_pSPData->UnlockSocketPortData();
			//fLockedSocketPortData = FALSE;
		}
		else
		{
			//
			// We are the only ones who should know about this key, so if it
			// got there either someone is trying to imitate our address format,
			// or someone is passing around device addresses returned by
			// xxxADDRESSINFO to a different interface or over the network.
			// None of those situations make a whole lot of sense, but we'll
			// just ignore it.
			//
			DPFX(DPFPREP, 0, "Multiplexed adapter association key exists, but 0x%p doesn't match expected 0x%p, is someone trying to get cute with device address 0x%p?!",
				maa.pSPData, this->m_pSPData, pDeviceAddress );
		}
	}
	else
	{
		//
		// Either the key is not there, it's the wrong size (too big for our
		// buffer and returned BUFFERTOOSMALL somehow), it's not a binary
 		// component, or something else bad happened.  Assume that this is the
		// first device.
		//
		DPFX(DPFPREP, 8, "Could not get appropriate private multiplexed adapter association key, error = 0x%lx, component size = %u, type = %u, continuing.",
			hTempResult, dwComponentSize, dwComponentType);
	}
	

	//
	// Add the multiplex information to the device address for future use if
	// necessary.
	// Ignore failure, we can still survive without it, we just might have the
	// race conditions for responses on NAT machines.
	//
	// NOTE: There is an inherent design problem here!  We're adding a pointer to
	// an endpoint (well, a field within the endpoint structure) inside the address.
	// If this endpoint goes away but the upper layer reuses the address at a later
	// time, this memory will be bogus!  We will assume that the endpoint will not
	// go away while this modified device address object is in existence.
	//
	if ( dwConnectFlags & DPNSPF_ADDITIONALMULTIPLEXADAPTERS )
	{
		maa.pSPData = this->m_pSPData;
		maa.pBilink = &this->m_blMultiplex;
		maa.dwEndpointID = this->GetEndpointID();

		DPFX(DPFPREP, 7, "Additional multiplex adapters on the way, adding SPData 0x%p and bilink 0x%p to address.",
			maa.pSPData, maa.pBilink);
		
		hTempResult = IDirectPlay8Address_AddComponent( ConnectAddressInfo.pDeviceAddress,						// interface
														DPNA_PRIVATEKEY_MULTIPLEXED_ADAPTER_ASSOCIATION,	// tag
														&maa,												// component data
														sizeof(maa),										// component data size
														DPNA_DATATYPE_BINARY								// component data type
														);
		if ( hTempResult != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Couldn't add private multiplexed adapter association component (err = 0x%lx)!  Ignoring.", hTempResult);
		}

		//
		// Mark the command as "in-progress" so that the cancel thread knows it needs
		// to do the completion itself.
		// If the command has already been marked for cancellation, then we have to
		// do that now.
		//
		this->m_pActiveCommandData->Lock();
		if ( this->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
		{
			this->m_pActiveCommandData->Unlock();


			DPFX(DPFPREP, 1, "Connect 0x%p (endpoint 0x%p) has already been cancelled, bailing.",
				this->m_pActiveCommandData, this);
			
			//
			// Complete the connect with USERCANCEL.
			//
			hr = DPNERR_USERCANCEL;
			goto Failure;
		}

		this->m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS );
		this->m_pActiveCommandData->Unlock();
	}



	//
	// Now tell the user about the address info that we ended up using, if we
	// successfully bound the endpoint (see BindEndpoint failure above for the case
	// where that's not true).
	//
	if (fEndpointBound)
	{
		DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_CONNECTADDRESSINFO 0x%p to interface 0x%p.",
			this, &ConnectAddressInfo, m_pSPData->DP8SPCallbackInterface());
		DumpAddress( 8, "\t Device:", ConnectAddressInfo.pDeviceAddress );

		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// interface
													SPEV_CONNECTADDRESSINFO,				// event type
													&ConnectAddressInfo						// pointer to data
													);

		DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_CONNECTADDRESSINFO [0x%lx].",
			this, hTempResult);
		
		DNASSERT( hTempResult == DPN_OK );
	}
	else
	{
		//
		// Endpoint not bound, we're just performing completions.
		//
		DNASSERT( this->PendingCommandResult() != DPN_OK );
	}


	//
	// If there aren't more multiplex adapter commands on the way, then signal
	// the connection and complete the command for all connections, including
	// this one.
	//
	if ( ! (dwConnectFlags & DPNSPF_ADDITIONALMULTIPLEXADAPTERS ))
	{
		DPFX(DPFPREP, 7, "Completing all connects (including multiplexed).");

#pragma BUGBUG(vanceo, "Do we need to lock the endpoint while submitting/cancelling the jobs?")

		this->m_pSPData->LockSocketPortData();
		fLockedSocketPortData = TRUE;


		//
		// Attach a root node to the list of adapters.
		//
		blIndicate.InsertAfter(&(this->m_blMultiplex));


		//
		// Move this adapter to the failed list if it did fail to bind.
		//
		if (! fEndpointBound)
		{
			this->m_blMultiplex.RemoveFromList();
			this->m_blMultiplex.InsertBefore(&blFail);
		}


		//
		// Loop through all the remaining adapters in the list.
		//
		pBilinkAll = blIndicate.GetNext();
		while (pBilinkAll != &blIndicate)
		{
			pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);


			//
			// THIS MUST BE CLEANED UP PROPERLY WITH AN INTERFACE CHANGE!
			//
			// The endpoint may have been returned to the pool and its associated
			// socketport pointer may have become NULL, or now be pointing to
			// something that's no longer valid.  So we try to handle NULL
			// pointers.  Obviously this is indicative of poor design, but it's
			// not possible to change this the correct way at this time.
			//

			
			//
			// If this is a NAT machine, then some adapters may be better than others
			// for reaching the desired address.  Particularly, it's better to use a
			// private adapter, which can directly reach the private network & be
			// mapped on the public network, than to use the public adapter.  It's not
			// fun to join a private game from an ICS machine while dialed up, have
			// your Internet connection go down, and lose the connection to the
			// private game which didn't (shouldn't) involve the Internet at all.  So
			// if we detect a public adapter when we have a perfectly good private
			// adapter, we'll fail connect attempts on the public one.
			//


			//
			// Cast to get rid of the const.  Don't worry, we won't actually change it.
			//
			pSocketAddress = (CSocketAddress*) pTempEndpoint->GetRemoteAddressPointer();
			psaddrinTemp = (SOCKADDR_IN*) pSocketAddress->GetAddress();
			pSocketPort = pTempEndpoint->GetSocketPort();

			//
			// See if this is an IP connect.
			//
			if (( pSocketAddress != NULL) &&
				( pSocketPort != NULL ) &&
				( pSocketAddress->GetFamily() == AF_INET ))
			{
				for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
				{
					if (pSocketPort->GetNATHelpPort(dwTemp) != NULL)
					{
						DNASSERT( g_papNATHelpObjects[dwTemp] != NULL );
						dwPublicAddressesSize = sizeof(saddrPublic);
						dwAddressTypeFlags = 0;
						hTempResult = IDirectPlayNATHelp_GetRegisteredAddresses(g_papNATHelpObjects[dwTemp],
																				pSocketPort->GetNATHelpPort(dwTemp),
																				&saddrPublic,
																				&dwPublicAddressesSize,
																				&dwAddressTypeFlags,
																				NULL,
																				0);
						if ((hTempResult != DPNH_OK) || (! (dwAddressTypeFlags & DPNHADDRESSTYPE_GATEWAYISLOCAL)))
						{
							DPFX(DPFPREP, 7, "Socketport 0x%p is not locally mapped on gateway with NAT Help index %u (err = 0x%lx, flags = 0x%lx).",
								pSocketPort, dwTemp, hTempResult, dwAddressTypeFlags);
						}
						else
						{
							//
							// There is a local NAT.
							//
							DPFX(DPFPREP, 7, "Socketport 0x%p is locally mapped on gateway with NAT Help index %u (flags = 0x%lx), public address:",
								pSocketPort, dwTemp, dwAddressTypeFlags);
							DumpSocketAddress(7, &saddrPublic, AF_INET);
							

							//
							// Find the multiplexed connect on the public adapter that
							// we need to fail, as described above.
							//
							pBilinkPublic = blIndicate.GetNext();
							while (pBilinkPublic != &blIndicate)
							{
								pPublicEndpoint = CONTAINING_OBJECT(pBilinkPublic, CEndpoint, m_blMultiplex);

								//
								// Don't bother checking the endpoint whose public
								// address we're seeking.
								//
								if (pPublicEndpoint != pTempEndpoint)
								{
									pPublicSocketPort = pPublicEndpoint->GetSocketPort();
									if ( pPublicSocketPort != NULL )
									{
										//
										// Cast to get rid of the const.  Don't worry, we won't
										// actually change it.
										//
										pSocketAddress = (CSocketAddress*) pPublicSocketPort->GetNetworkAddress();
										if ( pSocketAddress != NULL )
										{
											if ( pSocketAddress->CompareToBaseAddress( &saddrPublic ) == 0)
											{
												DPFX(DPFPREP, 3, "Endpoint 0x%p is multiplexed onto public adapter for endpoint 0x%p (current endpoint = 0x%p), failing public connect.",
													pTempEndpoint, pPublicEndpoint, this);

												//
												// Pull it out of the multiplex association list and move
												// it to the "fail" list.
												//
												pPublicEndpoint->RemoveFromMultiplexList();
												pPublicEndpoint->m_blMultiplex.InsertBefore(&blFail);

												break;
											}
											

											//
											// Otherwise, continue searching.
											//

											DPFX(DPFPREP, 8, "Endpoint 0x%p is multiplexed onto different adapter:",
												pPublicEndpoint);
											DumpSocketAddress(8, pSocketAddress->GetWritableAddress(), pSocketAddress->GetFamily());
										}
										else
										{
											DPFX(DPFPREP, 1, "Public endpoint 0x%p's socket port 0x%p is going away, skipping.",
												pPublicEndpoint, pPublicSocketPort);
										}
									}
									else
									{
										DPFX(DPFPREP, 1, "Public endpoint 0x%p is going away, skipping.",
											pPublicEndpoint);
									}
								}
								else
								{
									//
									// The same endpoint as the one whose
									// public address we're seeking.
									//
								}

								pBilinkPublic = pBilinkPublic->GetNext();
							}


							//
							// No need to search for any more NAT Help registrations.
							//
							break;
						} // end else (is mapped locally on Internet gateway)
					}
					else
					{
						//
						// No DirectPlay NAT Helper registration in this slot.
						//
					}
				} // end for (each DirectPlay NAT Helper)


				//
				// NOTE: We should fail connects for non-optimal adapters even
				// when it's multiadapter but not a PAST/UPnP enabled NAT (see
				// ProcessEnumResponseData for WSAIoctl usage related to this).
				// We do not currently do this.  There can still be race conditions
				// for connects where the response for the "wrong" device arrives
				// first.
				//
			}
			else
			{
				//
				// Not IP address, or possibly the endpoint is shutting down.
				//
				DPFX(DPFPREP, 1, "Found non-IP endpoint (possibly closing) (endpoint = 0x%p, socket address = 0x%p, socketport = 0x%p), not checking for local NAT mapping.",
					pTempEndpoint, pSocketAddress, pSocketPort);
			}


			//
			// Go to the next associated endpoint.  Although it's possible for
			// entries to have been removed from the list, the current entry
			// could not have been, so we're safe.
			//
			pBilinkAll = pBilinkAll->GetNext();
		}


		//
		// Now loop through the remaining endpoints and indicate their
		// connections.
		//
		while (! blIndicate.IsEmpty())
		{
			pBilinkAll = blIndicate.GetNext();
			pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);


			//
			// See notes above about NULL handling.
			//
			if (pTempEndpoint->m_pActiveCommandData != NULL)
			{
				//
				// Pull it from the "indicate" list.
				//
				pTempEndpoint->RemoveFromMultiplexList();


				pTempEndpoint->m_pActiveCommandData->Lock();

				if ( pTempEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
				{
					pTempEndpoint->m_pActiveCommandData->Unlock();
					
					DPFX(DPFPREP, 3, "Connect 0x%p is cancelled, not indicating endpoint 0x%p.",
						pTempEndpoint->m_pActiveCommandData, pTempEndpoint);
					
					//
					// Put it on the list of connects to fail.
					//
					pTempEndpoint->m_blMultiplex.InsertBefore(&blFail);
				}
				else
				{
					//
					// Mark the connect as uncancellable, since we're about to indicate
					// the connection.
					//
					pTempEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
						
					pTempEndpoint->m_pActiveCommandData->Unlock();


					//
					// Get a reference to keep the endpoint and command around while we
					// drop the socketport list lock.
					//
					pTempEndpoint->AddCommandRef();

					
					//
					// Drop the socket port lock.  It's safe since we pulled everything we
					// need off of the list that needs protection.
					//
					this->m_pSPData->UnlockSocketPortData();
					fLockedSocketPortData = FALSE;

				
					//
					// Inform user of connection.  Assume that the user will accept and
					// everything will succeed so we can set the user context for the
					// endpoint.  If the connection fails, clear the user endpoint
					// context.
					//
					memset( &ConnectIndicationData, 0x00, sizeof( ConnectIndicationData ) );
					DBG_CASSERT( sizeof( ConnectIndicationData.hEndpoint ) == sizeof( this ) );
					ConnectIndicationData.hEndpoint = pTempEndpoint->GetHandle();
					DNASSERT( pTempEndpoint->GetCommandParameters() != NULL );
					ConnectIndicationData.pCommandContext = pTempEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pvContext;
					pTempEndpoint->SetUserEndpointContext( NULL );
					hTempResult = pTempEndpoint->SignalConnect( &ConnectIndicationData );
					if ( hTempResult != DPN_OK )
					{
						DNASSERT( hTempResult == DPNERR_ABORTED );
						DPFX(DPFPREP, 1, "User refused connect in CompleteConnect (err = 0x%lx), completing connect with USERCANCEL.",
							hTempResult );
						DisplayDNError( 1, hTempResult );
						pTempEndpoint->SetUserEndpointContext( NULL );


						//
						// Retake the socket port lock so we can modify list linkage.
						//
						this->m_pSPData->LockSocketPortData();
						fLockedSocketPortData = TRUE;

						
						//
						// Put it on the list of connects to fail.
						//
						pTempEndpoint->m_blMultiplex.InsertBefore(&blFail);


						//
						// Mark the connect as cancelled so that we complete with
						// the right error code.
						//
						pTempEndpoint->m_pActiveCommandData->Lock();
						DNASSERT( pTempEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
						pTempEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_CANCELLING );
						pTempEndpoint->m_pActiveCommandData->Unlock();


						//
						// Drop the reference.
						// Note: SocketPort lock is still held, but since the command was
						// marked as uncancellable, this should not cause the endpoint to
						// get unbound yet, and thus we shouldn't reenter the
						// socketportdata lock.
						//
						pTempEndpoint->DecCommandRef();
					}
					else
					{
						//
						// We're done and everyone's happy, complete the command.
						// This will clear all of our internal command data.
						//
						pTempEndpoint->CompletePendingCommand( hTempResult );
						DNASSERT( pTempEndpoint->GetCommandParameters() == NULL );
						DNASSERT( pTempEndpoint->m_pActiveCommandData == NULL );


						//
						// Drop the reference (may result in endpoint unbinding).
						//
						pTempEndpoint->DecCommandRef();


						//
						// Retake the socket port lock in preparation for the next item.
						//
						this->m_pSPData->LockSocketPortData();
						fLockedSocketPortData = TRUE;
					}
				}
			}
			else
			{
				DPFX(DPFPREP, 1, "Endpoint 0x%p's active command data is NULL, skipping.",
					pTempEndpoint);
			}

			
			//
			// Go to the next associated endpoint.
			//
		}



		//
		// Finally loop through all the connects that need to fail and do
		// just that.
		//
		while (! blFail.IsEmpty())
		{
			pBilinkAll = blFail.GetNext();
			pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);


			//
			// Pull it from the "fail" list.
			//
			pTempEndpoint->RemoveFromMultiplexList();


			//
			// Get a reference to keep the endpoint and command around while we
			// drop the socketport list lock.
			//
			pTempEndpoint->AddCommandRef();


			//
			// Drop the socket port lock.  It's safe since we pulled everything we
			// need off of the list that needs protection.
			//
			this->m_pSPData->UnlockSocketPortData();
			fLockedSocketPortData = FALSE;


			//
			// See notes above about NULL handling.
			//
			if (pTempEndpoint->m_pActiveCommandData != NULL)
			{
				//
				// Complete it (by closing this endpoint).  Be considerate about the error
				// code expected by our caller.
				//

				pTempEndpoint->m_pActiveCommandData->Lock();

				if ( pTempEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
				{
					pTempEndpoint->m_pActiveCommandData->Unlock();
					
					DPFX(DPFPREP, 3, "Connect 0x%p is already cancelled, continuing to close endpoint 0x%p.",
						pTempEndpoint->m_pActiveCommandData, pTempEndpoint);

					hTempResult = DPNERR_USERCANCEL;
				}
				else
				{
					//
					// Mark the connect as uncancellable, since we're about to complete
					// it with a failure.
					//
					if ( pTempEndpoint->m_pActiveCommandData->GetState() != COMMAND_STATE_INPROGRESS_CANNOT_CANCEL )
					{
						pTempEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
					}


					//
					// Retrieve the current command result.
					//
					hTempResult = pTempEndpoint->PendingCommandResult();
					
					pTempEndpoint->m_pActiveCommandData->Unlock();


					//
					// If the command didn't have a descriptive error, assume it was
					// not previously set (i.e. wasn't overridden by BindEndpoint above),
					// and use NOCONNECTION instead.
					//
					if ( hTempResult == DPNERR_GENERIC )
					{
						hTempResult = DPNERR_NOCONNECTION;
					}
				
					DPFX(DPFPREP, 6, "Completing endpoint 0x%p connect (command 0x%p) with error 0x%lx.",
						pTempEndpoint, pTempEndpoint->m_pActiveCommandData, hTempResult);
				}

				pTempEndpoint->Close( hTempResult );
				pTempEndpoint->m_pSPData->CloseEndpointHandle( pTempEndpoint );
				}
			else
			{
				DPFX(DPFPREP, 1, "Endpoint 0x%p's active command data is NULL, skipping.",
					pTempEndpoint);
			}

			//
			// Drop the reference we used with the socketport list lock dropped.
			//
			pTempEndpoint->DecCommandRef();


			//
			// Retake the socket port lock and go to next item.
			//
			this->m_pSPData->LockSocketPortData();
			fLockedSocketPortData = TRUE;
		}


		this->m_pSPData->UnlockSocketPortData();
		fLockedSocketPortData = FALSE;
	}
	else
	{
		//
		// Not last multiplexed adapter.  All the work needed to be done for these
		// endpoints at this time has already been done.
		//
		DPFX(DPFPREP, 6, "Endpoint 0x%p is not the last multiplexed adapter, not completing connect yet.",
			this);
	}


Exit:
	
	if ( ConnectAddressInfo.pHostAddress != NULL )
	{
		IDirectPlay8Address_Release( ConnectAddressInfo.pHostAddress );
		ConnectAddressInfo.pHostAddress = NULL;
	}

	if ( ConnectAddressInfo.pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( ConnectAddressInfo.pDeviceAddress );
		ConnectAddressInfo.pDeviceAddress = NULL;
	}

	DNASSERT( pDeviceAddress != NULL );
	IDirectPlay8Address_Release( pDeviceAddress );

	DNASSERT( pHostAddress != NULL );
	IDirectPlay8Address_Release( pHostAddress );


	DNASSERT( !fLockedSocketPortData );

	DNASSERT(blIndicate.IsEmpty());
	DNASSERT(blFail.IsEmpty());

	
	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);
	
	return	hr;

Failure:

	//
	// If we still have the socket port lock, drop it.
	//
	if ( fLockedSocketPortData )
	{
		this->m_pSPData->UnlockSocketPortData();
		fLockedSocketPortData = FALSE;
	}
	
	//
	// we've failed to complete the connect, clean up and return this endpoint
	// to the pool
	//
	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::Disconnect - disconnect an endpoint
//
// Entry:		Old endpoint handle
//
// Exit:		Error code
//
// Notes:	This function assumes that the endpoint is locked.  If this
//			function completes successfully (returns DPN_OK), the endpoint
//			is no longer locked (it was returned to the pool).
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::Disconnect"

HRESULT	CEndpoint::Disconnect( const HANDLE hOldEndpointHandle )
{
	HRESULT	hr;


	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%p)", this, hOldEndpointHandle);

	DNASSERT( hOldEndpointHandle != INVALID_HANDLE_VALUE );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// initialize
	//
	hr = DPNERR_PENDING;

	Lock();
	switch ( GetState() )
	{
		//
		// connected endpoint
		//
		case ENDPOINT_STATE_CONNECT_CONNECTED:
		{
			DNASSERT( GetCommandParameters() == NULL );
			DNASSERT( m_pActiveCommandData == NULL );

			SetState( ENDPOINT_STATE_DISCONNECTING );
			AddRef();

			//
			// Unlock this endpoint before calling to a higher level.  The endpoint
			// has already been labeled as DISCONNECTING so nothing will happen to it.
			//
			Unlock();

			//
			// Note the old endpoint handle so it can be used in the disconnect
			// indication that will be given just before this endpoint is returned
			// to the pool.  Need to release the reference that was added for the
			// connection at this point or the endpoint will never be returned to
			// the pool.
			//
			SetDisconnectIndicationHandle( hOldEndpointHandle );
			DecRef();

			//
			// release reference from just after setting state
			//
			Close( DPN_OK );
			DecCommandRef();
			DecRef();

			break;
		}

		//
		// some other endpoint state
		//
		default:
		{
			hr = DPNERR_INVALIDENDPOINT;
			DPFX(DPFPREP, 0, "Attempted to disconnect endpoint that's not connected!" );
			switch ( m_State )
			{
				case ENDPOINT_STATE_UNINITIALIZED:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_UNINITIALIZED" );
					break;
				}

				case ENDPOINT_STATE_ATTEMPTING_CONNECT:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_ATTEMPTING_CONNECT" );
					break;
				}

				case ENDPOINT_STATE_ATTEMPTING_LISTEN:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_ATTEMPTING_LISTEN" );
					break;
				}

				case ENDPOINT_STATE_ENUM:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_ENUM" );
					break;
				}

				case ENDPOINT_STATE_DISCONNECTING:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_DISCONNECTING" );
					break;
				}

				case ENDPOINT_STATE_WAITING_TO_COMPLETE:
				{
					DPFX(DPFPREP, 0, "ENDPOINT_STATE_WAITING_TO_COMPLETE" );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			Unlock();
			DNASSERT( FALSE );
			goto Failure;

			break;
		}
	}

Exit:
	
	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);
	
	return	hr;

Failure:
	// nothing to do
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::StopEnumCommand - stop a running enum command
//
// Entry:		Command result
//
// Exit:		Nothing
//
// Notes:	This function assumes that the endpoint is locked.  If this
//			function completes successfully (returns DPN_OK), the endpoint
//			is no longer locked (it was returned to the pool).
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::StopEnumCommand"

void	CEndpoint::StopEnumCommand( const HRESULT hCommandResult )
{
	Lock();
/*	REMOVE - MJN
	DNASSERT( GetState() == ENDPOINT_STATE_DISCONNECTING );
*/
	if ( GetActiveDialogHandle() != NULL )
	{
		StopSettingsDialog( GetActiveDialogHandle() );
		Unlock();
	}
	else
	{
		BOOL	fStoppedJob;

		
		//
		// Don't hold the lock when cancelling a timer job because the
		// job might be in progress and attempting to use this endpoint!
		//
		Unlock();
		fStoppedJob = m_pSPData->GetThreadPool()->StopTimerJob( m_pActiveCommandData, hCommandResult );
		if ( ! fStoppedJob )
		{
			//
			// Either the endpoint just completed or it had never been started.
			// Check the state to determine which of those scenarios happened.
			//
			Lock();	
			if ( this->GetState() == ENDPOINT_STATE_ENUM )
			{
				//
				// This is a multiplexed enum that is getting cancelled.  We
				// need to complete it.
				//
				Unlock();

				DPFX(DPFPREP, 1, "Endpoint 0x%p completing unstarted multiplexed enum (context 0x%p) with result 0x%lx.",
					this, m_pActiveCommandData, hCommandResult);
				
				CEndpoint::EnumCompleteWrapper( hCommandResult,
												this->m_pActiveCommandData );			
			}
			else
			{
				Unlock();

				DPFX(DPFPREP, 1, "Endpoint 0x%p unable to stop timer job (context 0x%p, result would have been 0x%lx).",
					this, this->m_pActiveCommandData, hCommandResult);
			}
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CopyListenData - copy data for listen command
//
// Entry:		Pointer to job information
//				Pointer to device address
//
// Exit:		Error code
//
// Note:	Device address needs to be preserved for later use.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyListenData"

HRESULT	CEndpoint::CopyListenData( const SPLISTENDATA *const pListenData, IDirectPlay8Address *const pDeviceAddress )
{
	HRESULT	hr;
	ENDPOINT_COMMAND_PARAMETERS	*pCommandParameters;

	
	DNASSERT( pListenData != NULL );
	DNASSERT( pDeviceAddress != NULL );
	
	DNASSERT( pListenData->hCommand != NULL );
	DNASSERT( pListenData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_pActiveCommandData == NULL );
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );

	//
	// initialize
	//
	hr = DPN_OK;
	pCommandParameters = NULL;

	pCommandParameters = CreateEndpointCommandParameters();
	if ( pCommandParameters != NULL )
	{
		SetCommandParameters( pCommandParameters );

		DBG_CASSERT( sizeof( pCommandParameters->PendingCommandData.ListenData ) == sizeof( *pListenData ) );
		memcpy( &pCommandParameters->PendingCommandData.ListenData, pListenData, sizeof( pCommandParameters->PendingCommandData.ListenData ) );
		pCommandParameters->PendingCommandData.ListenData.pAddressDeviceInfo = pDeviceAddress;
		IDirectPlay8Address_AddRef( pDeviceAddress );

		m_fListenStatusNeedsToBeIndicated = TRUE;
		m_pActiveCommandData = static_cast<CCommandData*>( pCommandParameters->PendingCommandData.ListenData.hCommand );
		m_pActiveCommandData->SetUserContext( pListenData->pvContext );
		m_State = ENDPOINT_STATE_ATTEMPTING_LISTEN;
		
		DNASSERT( hr == DPN_OK );
	}
	else
	{
		hr = DPNERR_OUTOFMEMORY;
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ListenJobCallback - asynchronous callback wrapper for work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ListenJobCallback"

void	CEndpoint::ListenJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.pAddressDeviceInfo != NULL );

	hr = pThisEndpoint->CompleteListen();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem completing listen in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

Exit:
	pThisEndpoint->DecRef();

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CancelListenJobCallback - cancel for listen job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CancelListenJobCallback"

void	CEndpoint::CancelListenJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_LISTEN );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	pThisEndpoint->m_pActiveCommandData->Lock();
	DNASSERT( ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_PENDING ) ||
			  ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pActiveCommandData->Unlock();
	
	//
	// clean up
	//
	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.pAddressDeviceInfo != NULL );
	IDirectPlay8Address_Release( pThisEndpoint->GetCommandParameters()->PendingCommandData.ListenData.pAddressDeviceInfo );

	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->m_pSPData->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompleteListen - complete listen process
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	Calling this function may result in the deletion of 'this', don't
//			do anything else with this object after calling!!!!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompleteListen"

HRESULT	CEndpoint::CompleteListen( void )
{
	HRESULT							hr;
	HRESULT							hTempResult;
	SPIE_LISTENSTATUS				ListenStatus;
	BOOL							fEndpointLocked;
	SPIE_LISTENADDRESSINFO			ListenAddressInfo;
	IDirectPlay8Address *			pDeviceAddress;
	ENDPOINT_COMMAND_PARAMETERS *	pCommandParameters;


	DPFX(DPFPREP, 6, "(0x%p) Enter", this);
	
	DNASSERT( GetCommandParameters() != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointLocked = FALSE;
	memset( &ListenStatus, 0x00, sizeof( ListenStatus ) );
	memset( &ListenAddressInfo, 0x00, sizeof( ListenAddressInfo ) );
	pCommandParameters = GetCommandParameters();

	//
	// Transfer address reference to the local pointer.  This will be released at the
	// end of this function, but we'll keep the pointer in the pending command data so
	// CSPData::BindEndpoint can still access it.
	//

	pDeviceAddress = pCommandParameters->PendingCommandData.ListenData.pAddressDeviceInfo;
	DNASSERT( pDeviceAddress != NULL );


	DNASSERT( m_State == ENDPOINT_STATE_ATTEMPTING_LISTEN );
	DNASSERT( m_pActiveCommandData != NULL );
	DNASSERT( pCommandParameters->PendingCommandData.ListenData.hCommand == m_pActiveCommandData );
	DNASSERT( pCommandParameters->PendingCommandData.ListenData.dwCommandDescriptor != NULL_DESCRIPTOR );

#ifdef DEBUG
	if (pCommandParameters->PendingCommandData.ListenData.dwFlags & DPNSPF_BINDLISTENTOGATEWAY)
	{
		DNASSERT( pCommandParameters->GatewayBindType == GATEWAY_BIND_TYPE_SPECIFIC_SHARED );
	}
	else
	{
		DNASSERT( pCommandParameters->GatewayBindType == GATEWAY_BIND_TYPE_UNKNOWN );
	}
#endif // DEBUG

	//
	// check for user cancelling command
	//
	m_pActiveCommandData->Lock();

	DNASSERT( m_pActiveCommandData->GetType() == COMMAND_TYPE_LISTEN );
	switch ( m_pActiveCommandData->GetState() )
	{
		//
		// command is pending, mark as in-progress
		//
		case COMMAND_STATE_PENDING:
		{
			m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS );
			
			Lock();
			fEndpointLocked = TRUE;
			
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP, 0, "User cancelled listen!" );

			break;
		}

		//
		// other state
		//
		default:
		{
			break;
		}
	}
	m_pActiveCommandData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// note that this endpoint is officially listening before adding it to the
	// socket port because it may get used immediately.
	// Also note that the GATEWAY_BIND_TYPE actually used
	// (this->GetGatewayBindType()) may differ from
	// pCommandParameters->GatewayBindType.
	//
	m_State = ENDPOINT_STATE_LISTEN;

	hr = m_pSPData->BindEndpoint( this, pDeviceAddress, NULL, pCommandParameters->GatewayBindType );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to bind endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}


	//
	// attempt to indicate addressing to a higher layer
	//
	ListenAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT,
																					this->GetGatewayBindType() );
	ListenAddressInfo.hCommandStatus = DPN_OK;
	ListenAddressInfo.pCommandContext = m_pActiveCommandData->GetUserContext();

	if ( ListenAddressInfo.pDeviceAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Listens are not affected by the same multiplexed adapter problems (see
	// CompleteConnect and CompleteEnumQuery), so we don't need that workaround
	// code.
	//


	DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_LISTENADDRESSINFO 0x%p to interface 0x%p.",
		this, &ListenAddressInfo, m_pSPData->DP8SPCallbackInterface());
	DumpAddress( 8, "\t Device:", ListenAddressInfo.pDeviceAddress );

	hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// interface
												SPEV_LISTENADDRESSINFO,					// event type
												&ListenAddressInfo						// pointer to data
												);

	DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_LISTENADDRESSINFO [0x%lx].",
		this, hTempResult);

	DNASSERT( hTempResult == DPN_OK );
	
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

Exit:
	//
	// report the listen status
	//
	if ( m_fListenStatusNeedsToBeIndicated != FALSE )
	{
		m_fListenStatusNeedsToBeIndicated = FALSE;
		ListenStatus.hResult = hr;
		DNASSERT( m_pActiveCommandData == pCommandParameters->PendingCommandData.ListenData.hCommand );
		ListenStatus.hCommand = pCommandParameters->PendingCommandData.ListenData.hCommand;
		ListenStatus.pUserContext = pCommandParameters->PendingCommandData.ListenData.pvContext;
		ListenStatus.hEndpoint = GetHandle();

		//
		// if the listen binding failed, there's no socket port to dereference so
		// return GUID_NULL as set by the memset.
		//
		if ( GetSocketPort() != NULL )
		{
			GetSocketPort()->GetNetworkAddress()->GuidFromInternalAddressWithoutPort( ListenStatus.ListenAdapter );
		}

		//
		// it's possible that this endpoint was cleaned up so its internal pointers to the
		// COM and data interfaces may have been wiped, use the cached pointer
		//

		DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_LISTENSTATUS 0x%p to interface 0x%p.",
			this, &ListenStatus, m_pSPData->DP8SPCallbackInterface());
		
		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to DPlay callback interface
													SPEV_LISTENSTATUS,						// data type
													&ListenStatus							// pointer to data
													);

		DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_LISTENSTATUS [0x%lx].",
			this, hTempResult);
		
		DNASSERT( hTempResult == DPN_OK );
	}

	if ( ListenAddressInfo.pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( ListenAddressInfo.pDeviceAddress );
		ListenAddressInfo.pDeviceAddress = NULL;
	}
	
	DNASSERT( pDeviceAddress != NULL );
	IDirectPlay8Address_Release( pDeviceAddress );

	
	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);
	
	return	hr;

Failure:
	//
	// we've failed to complete the listen, clean up and return this
	// endpoint to the pool
	//
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CopyEnumQueryData - copy data for enum query command
//
// Entry:		Pointer to command data
//
// Exit:		Error code
//
// Note:	Device address needs to be preserved for later use.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CopyEnumQueryData"

HRESULT	CEndpoint::CopyEnumQueryData( const SPENUMQUERYDATA *const pEnumQueryData )
{
	HRESULT	hr;
	ENDPOINT_COMMAND_PARAMETERS	*pCommandParameters;


	DNASSERT( pEnumQueryData != NULL );

	DNASSERT( pEnumQueryData->hCommand != NULL );
	DNASSERT( pEnumQueryData->dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( m_pActiveCommandData == NULL );
	
	//
	// initialize
	//
	hr = DPN_OK;
	pCommandParameters = NULL;

	pCommandParameters = CreateEndpointCommandParameters();
	if ( pCommandParameters != NULL )
	{
		SetCommandParameters( pCommandParameters );

		DBG_CASSERT( sizeof( pCommandParameters->PendingCommandData.EnumQueryData ) == sizeof( *pEnumQueryData ) );
		memcpy( &pCommandParameters->PendingCommandData.EnumQueryData, pEnumQueryData, sizeof( pCommandParameters->PendingCommandData.EnumQueryData ) );

		pCommandParameters->PendingCommandData.EnumQueryData.pAddressHost = pEnumQueryData->pAddressHost;
		IDirectPlay8Address_AddRef( pEnumQueryData->pAddressHost );

		pCommandParameters->PendingCommandData.EnumQueryData.pAddressDeviceInfo = pEnumQueryData->pAddressDeviceInfo;
		IDirectPlay8Address_AddRef( pEnumQueryData->pAddressDeviceInfo );

		m_pActiveCommandData = static_cast<CCommandData*>( pCommandParameters->PendingCommandData.EnumQueryData.hCommand );
		m_pActiveCommandData->SetUserContext( pEnumQueryData->pvContext );
		m_State = ENDPOINT_STATE_ATTEMPTING_ENUM;
	
		DNASSERT( hr == DPN_OK );
	}
	else
	{
		hr = DPNERR_OUTOFMEMORY;
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumQueryJobCallback - asynchronous callback wrapper for work thread
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumQueryJobCallback"

void	CEndpoint::EnumQueryJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	HRESULT		hr;
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	// initialize
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );

	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.hCommand == pThisEndpoint->m_pActiveCommandData );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost != NULL );
	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo != NULL );

	hr = pThisEndpoint->CompleteEnumQuery();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem completing enum query in job callback!" );
		DisplayDNError( 0, hr );
		goto Exit;
	}

	//
	// Don't do anything here because it's possible that this object was returned to the pool!!!!
	//
Exit:
	pThisEndpoint->DecRef();

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CancelEnumQueryJobCallback - cancel for enum query job
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CancelEnumQueryJobCallback"

void	CEndpoint::CancelEnumQueryJobCallback( THREAD_POOL_JOB *const pDelayedCommand )
{
	CEndpoint	*pThisEndpoint;


	DNASSERT( pDelayedCommand != NULL );

	//
	// initialize
	//
	pThisEndpoint = static_cast<CEndpoint*>( pDelayedCommand->JobData.JobDelayedCommand.pContext );
	DNASSERT( pThisEndpoint != NULL );
	DNASSERT( pThisEndpoint->m_State == ENDPOINT_STATE_ATTEMPTING_ENUM );

	//
	// we're cancelling this command, set the command state to 'cancel'
	//
	DNASSERT( pThisEndpoint->m_pActiveCommandData != NULL );
	pThisEndpoint->m_pActiveCommandData->Lock();
	DNASSERT( ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_INPROGRESS ) ||
			  ( pThisEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING ) );
	pThisEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_CANCELLING );
	pThisEndpoint->m_pActiveCommandData->Unlock();
	

	//
	// clean up
	//

	DNASSERT( pThisEndpoint->GetCommandParameters() != NULL );

	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost != NULL );
	IDirectPlay8Address_Release( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost );

	DNASSERT( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo != NULL );
	IDirectPlay8Address_Release( pThisEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo );

	pThisEndpoint->Close( DPNERR_USERCANCEL );
	pThisEndpoint->m_pSPData->CloseEndpointHandle( pThisEndpoint );
	pThisEndpoint->DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompleteEnumQuery - complete enum query process
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	Calling this function may result in the deletion of 'this', don't
//			do anything else with this object after calling!!!!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompleteEnumQuery"

HRESULT	CEndpoint::CompleteEnumQuery( void )
{
	HRESULT							hr;
	HRESULT							hTempResult;
	BOOL							fEndpointLocked;
	BOOL							fEndpointBound;
	UINT_PTR						uRetryCount;
	BOOL							fRetryForever;
	DN_TIME							RetryInterval;
	BOOL							fWaitForever;
	DN_TIME							IdleTimeout;
	SPIE_ENUMADDRESSINFO			EnumAddressInfo;
	IDirectPlay8Address *			pHostAddress;
	IDirectPlay8Address *			pDeviceAddress;
	GATEWAY_BIND_TYPE				GatewayBindType;
	DWORD							dwEnumQueryFlags;
	MULTIPLEXEDADAPTERASSOCIATION	maa;
	DWORD							dwComponentSize;
	DWORD							dwComponentType;
	CBilink *						pBilinkEnd;
	CBilink *						pBilinkAll;
	CEndpoint *						pTempEndpoint;
	CSocketPort *					pSocketPort;
	SOCKADDR_IN *					psaddrinTemp;
	SOCKADDR						saddrPublic;
	CBilink *						pBilinkPublic;
	CEndpoint *						pPublicEndpoint;
	CSocketPort *					pPublicSocketPort;
	DWORD							dwTemp;
	DWORD							dwPublicAddressesSize;
	DWORD							dwAddressTypeFlags;
	CSocketAddress *				pSocketAddress;
	CBilink							blInitiate;
	CBilink							blCompleteEarly;
	BOOL							fLockedSocketPortData;
	CBilink *						pBilinkNext;



	DNASSERT( GetCommandParameters() != NULL );

	DPFX(DPFPREP, 6, "(0x%p) Enter", this);
	
	//
	// initialize
	//
	hr = DPN_OK;
	fEndpointLocked = FALSE;
	fEndpointBound = FALSE;
	IdleTimeout.Time32.TimeHigh = 0;
	IdleTimeout.Time32.TimeLow = 0;
	memset( &EnumAddressInfo, 0x00, sizeof( EnumAddressInfo ) );

	DNASSERT( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost != NULL );

	//
	// Transfer address references to our local pointers.  These will be released
	// at the end of this function, but we'll keep the pointers in the pending command
	// data so CSPData::BindEndpoint can still access them.
	//

	pHostAddress = GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost;
	DNASSERT( pHostAddress != NULL );

	pDeviceAddress = GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo;
	DNASSERT( pDeviceAddress != NULL );


	//
	// Retrieve other parts of the command parameters for convenience.
	//
	GatewayBindType = GetCommandParameters()->GatewayBindType;
	dwEnumQueryFlags = GetCommandParameters()->PendingCommandData.EnumQueryData.dwFlags;


	blInitiate.Initialize();
	blCompleteEarly.Initialize();
	fLockedSocketPortData = FALSE;


	DNASSERT( m_pSPData != NULL );

	DNASSERT( m_State == ENDPOINT_STATE_ATTEMPTING_ENUM );
	DNASSERT( m_pActiveCommandData != NULL );
	DNASSERT( GetCommandParameters()->PendingCommandData.EnumQueryData.hCommand == m_pActiveCommandData );
	DNASSERT( GetCommandParameters()->PendingCommandData.EnumQueryData.dwCommandDescriptor != NULL_DESCRIPTOR );

	DNASSERT( GatewayBindType == GATEWAY_BIND_TYPE_UNKNOWN );


	//
	// Since this endpoint will be passed off to the timer thread, add a reference
	// for the thread.  If the handoff fails, DecRef()
	//
	AddRef();
	
	//
	// check for user cancelling command
	//
	m_pActiveCommandData->Lock();

	DNASSERT( m_pActiveCommandData->GetType() == COMMAND_TYPE_ENUM_QUERY );
	switch ( m_pActiveCommandData->GetState() )
	{
		//
		// command is still pending, that's good
		//
		case COMMAND_STATE_PENDING:
		{
			Lock();
			fEndpointLocked = TRUE;
			DNASSERT( hr == DPN_OK );

			break;
		}

		//
		// command has been cancelled
		//
		case COMMAND_STATE_CANCELLING:
		{
			hr = DPNERR_USERCANCEL;
			DPFX(DPFPREP, 0, "User cancelled enum query!" );

			break;
		}
	
		//
		// command is in progress (probably came here from a dialog), mark it
		// as pending
		//
		case COMMAND_STATE_INPROGRESS:
		{
			m_pActiveCommandData->SetState( COMMAND_STATE_PENDING );
			
			Lock();
			fEndpointLocked = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	m_pActiveCommandData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// Mark the endpoint as enuming in case the enum thread takes off immediately.
	// If the endpoint fails to submit the enum job it will be closed so changing
	// the state was just a waste of a clock cycle.
	// Note that the GATEWAY_BIND_TYPE actually used (this->GetGatewayBindType())
	// may differ from GatewayBindType.
	//
	m_State = ENDPOINT_STATE_ENUM;
	
	hr = m_pSPData->BindEndpoint( this, pDeviceAddress, NULL, GatewayBindType );
	if ( hr != DPN_OK )
	{
		//
		// If this is the last adapter, we may still need to complete other
		// enums, so we'll drop through to check for those.  Otherwise,
		// we'll bail right now.
		//
		if (dwEnumQueryFlags & DPNSPF_ADDITIONALMULTIPLEXADAPTERS )
		{
			DPFX(DPFPREP, 0, "Failed to bind endpoint with other adapters remaining (err = 0x%lx)!", hr );
			DisplayDNError( 0, hr );
			goto Failure;
		}

		DPFX(DPFPREP, 0, "Failed to bind last multiplexed endpoint (err = 0x%lx)!", hr );
		DisplayDNError( 0, hr );
		
		this->SetPendingCommandResult( hr );
		hr = DPN_OK;

		//
		// Note that the endpoint is not bound!
		//
	}
	else
	{
		fEndpointBound = TRUE;


		EnumAddressInfo.pDeviceAddress = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT,
																					this->GetGatewayBindType() );
		EnumAddressInfo.pHostAddress = GetRemoteHostDP8Address();
		EnumAddressInfo.hCommandStatus = DPN_OK;
		EnumAddressInfo.pCommandContext = m_pActiveCommandData->GetUserContext();

		if ( ( EnumAddressInfo.pHostAddress == NULL ) ||
			 ( EnumAddressInfo.pDeviceAddress == NULL ) )
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
	}

	//
	// We can run into problems with "multiplexed" device attempts when you are on
	// a NAT machine.  The core will try enuming on multiple adapters, but since
	// we are on the network boundary, each adapter can see and get responses from
	// both networks.  This causes problems with peer-to-peer sessions when the
	// "wrong" adapter gets selected (because it receives a response first).  To
	// prevent that, we are going to internally remember the association between
	// the multiplexed Enums so we can decide on the fly whether to indicate a
	// response or not.  Obviously this workaround/decision logic relies on having
	// internal knowledge of what the upper layer would be doing...
	//
	// So either build or add to the linked list of multiplexed Enums.
	// Technically this is only necessary for IP, since IPX can't have NATs, but
	// what's the harm in having a little extra info?
	//
		
	dwComponentSize = sizeof(maa);
	dwComponentType = 0;
	hTempResult = IDirectPlay8Address_GetComponentByName( pDeviceAddress,									// interface
														DPNA_PRIVATEKEY_MULTIPLEXED_ADAPTER_ASSOCIATION,	// tag
														&maa,												// component buffer
														&dwComponentSize,									// component size
														&dwComponentType									// component type
														);
	if (( hTempResult == DPN_OK ) && ( dwComponentSize == sizeof(MULTIPLEXEDADAPTERASSOCIATION) ) && ( dwComponentType == DPNA_DATATYPE_BINARY ))
	{
		//
		// We found the right component type.  See if it matches the right
		// CSPData object.
		//
		if ( maa.pSPData == this->m_pSPData )
		{
			this->m_pSPData->LockSocketPortData();
			//fLockedSocketPortData = TRUE;

			pTempEndpoint = CONTAINING_OBJECT(maa.pBilink, CEndpoint, m_blMultiplex);

			
			//
			// Make sure the endpoint is still around/valid.
			//
			// THIS MAY CRASH IF OBJECT POOLING IS DISABLED!
			//
			if ( pTempEndpoint->GetEndpointID() == maa.dwEndpointID )
			{
				DPFX(DPFPREP, 3, "Found correctly formed private multiplexed adapter association key, linking endpoint 0x%p with earlier enums (prev endpoint = 0x%p).",
					this, pTempEndpoint);

				DNASSERT( pTempEndpoint->GetType() == ENDPOINT_TYPE_ENUM );
				DNASSERT( pTempEndpoint->GetState() != ENDPOINT_STATE_UNINITIALIZED );

				//
				// Actually link to the other endpoints.
				//
				this->m_blMultiplex.InsertAfter(maa.pBilink);
			}
			else
			{
				DPFX(DPFPREP, 1, "Found private multiplexed adapter association key, but prev endpoint 0x%p ID doesn't match (%u != %u), cannot link endpoint 0x%p and hoping this enum gets cancelled, too.",
					pTempEndpoint, pTempEndpoint->GetEndpointID(), maa.dwEndpointID, this);
			}


			//
			// Add this endpoint's enum command to the postponed list in case we need
			// to clean it up at shutdown.
			//
			this->m_pActiveCommandData->AddToPostponedList( this->m_pSPData->GetPostponedEnumsBilink() );


			this->m_pSPData->UnlockSocketPortData();
			//fLockedSocketPortData = FALSE;
		}
		else
		{
			//
			// We are the only ones who should know about this key, so if it
			// got there either someone is trying to imitate our address format,
			// or someone is passing around device addresses returned by
			// xxxADDRESSINFO to a different interface or over the network.
			// None of those situations make a whole lot of sense, but we'll
			// just ignore it.
			//
			DPFX(DPFPREP, 0, "Multiplexed adapter association key exists, but 0x%p doesn't match expected 0x%p, is someone trying to get cute with device address 0x%p?!",
				maa.pSPData, this->m_pSPData, pDeviceAddress );
		}
	}
	else
	{
		//
		// Either the key is not there, it's the wrong size (too big for our
		// buffer and returned BUFFERTOOSMALL somehow), it's not a binary
 		// component, or something else bad happened.  Assume that this is the
		// first device.
		//
		DPFX(DPFPREP, 8, "Could not get appropriate private multiplexed adapter association key, error = 0x%lx, component size = %u, type = %u, continuing.",
			hTempResult, dwComponentSize, dwComponentType);
	}
	

	//
	// Add the multiplex information to the device address for future use if
	// necessary.
	// Ignore failure, we can still survive without it, we just might have the
	// race conditions for responses on NAT machines.
	//
	// NOTE: There is an inherent design problem here!  We're adding a pointer to
	// an endpoint (well, a field within the endpoint structure) inside the address.
	// If this endpoint goes away but the upper layer reuses the address at a later
	// time, this memory will be bogus!  We will assume that the endpoint will not
	// go away while this modified device address object is in existence.
	//
	if ( dwEnumQueryFlags & DPNSPF_ADDITIONALMULTIPLEXADAPTERS )
	{
		maa.pSPData = this->m_pSPData;
		maa.pBilink = &this->m_blMultiplex;
		maa.dwEndpointID = this->GetEndpointID();

		DPFX(DPFPREP, 7, "Additional multiplex adapters on the way, adding SPData 0x%p and bilink 0x%p to address.",
			maa.pSPData, maa.pBilink);
		
		hTempResult = IDirectPlay8Address_AddComponent( EnumAddressInfo.pDeviceAddress,						// interface
														DPNA_PRIVATEKEY_MULTIPLEXED_ADAPTER_ASSOCIATION,	// tag
														&maa,												// component data
														sizeof(maa),										// component data size
														DPNA_DATATYPE_BINARY								// component data type
														);
		if ( hTempResult != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Couldn't add private multiplexed adapter association component (err = 0x%lx)!  Ignoring.", hTempResult);
		}

		//
		// Mark the command as "in-progress" so that the cancel thread knows it needs
		// to do the completion itself.
		// If the command has already been marked for cancellation, then we have to
		// do that now.
		//
		this->m_pActiveCommandData->Lock();
		if ( this->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
		{
			this->m_pActiveCommandData->Unlock();


			DPFX(DPFPREP, 1, "Enum query 0x%p (endpoint 0x%p) has already been cancelled, bailing.",
				this->m_pActiveCommandData, this);
			
			//
			// Complete the enum with USERCANCEL.
			//
			hr = DPNERR_USERCANCEL;
			goto Failure;
		}

		this->m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS );
		this->m_pActiveCommandData->Unlock();
	}



	//
	// Now tell the user about the address info that we ended up using, if we
	// successfully bound the endpoint (see BindEndpoint failure above for the case
	// where that's not true).
	//
	if (fEndpointBound)
	{
		DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_ENUMADDRESSINFO 0x%p to interface 0x%p.",
			this, &EnumAddressInfo, m_pSPData->DP8SPCallbackInterface());
		DumpAddress( 8, "\t Device:", EnumAddressInfo.pDeviceAddress );
		
		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// interface
													SPEV_ENUMADDRESSINFO,					// event type
													&EnumAddressInfo						// pointer to data
													);

		DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_ENUMADDRESSINFO [0x%lx].",
			this, hTempResult);

		DNASSERT( hTempResult == DPN_OK );
	}
	else
	{
		//
		// Endpoint not bound, we're just performing completions.
		//
		DNASSERT( this->PendingCommandResult() != DPN_OK );
	}
	

	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}


	//
	// If there aren't more multiplex adapter commands on the way, then submit the timer
	// jobs for all of the multiplex commands, including this one.
	//
	if ( ! ( dwEnumQueryFlags & DPNSPF_ADDITIONALMULTIPLEXADAPTERS ))
	{
		DPFX(DPFPREP, 7, "Completing/starting all enum queries (including multiplexed).");

		
#pragma BUGBUG(vanceo, "Do we need to lock the endpoint while submitting/cancelling the jobs?")


		this->m_pSPData->LockSocketPortData();
		fLockedSocketPortData = TRUE;


		//
		// Attach a root node to the list of adapters.
		//
		blInitiate.InsertAfter(&(this->m_blMultiplex));


		//
		// Move this adapter to the failed list if it did fail to bind.
		//
		if (! fEndpointBound)
		{
			this->m_blMultiplex.RemoveFromList();
			this->m_blMultiplex.InsertBefore(&blCompleteEarly);
		}


		//
		// Loop through all the remaining adapters in the list.
		//
		pBilinkAll = blInitiate.GetNext();
		while (pBilinkAll != &blInitiate)
		{
			pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);

			pBilinkNext = pBilinkAll->GetNext();

			
			//
			// THIS MUST BE CLEANED UP PROPERLY WITH AN INTERFACE CHANGE!
			//
			// The endpoint may have been returned to the pool and its associated
			// socketport pointer may have become NULL, or now be pointing to
			// something that's no longer valid.  So we try to handle NULL
			// pointers.  Obviously this is indicative of poor design, but it's
			// not possible to change this the correct way at this time.
			//


			//
			// If the enum is directed (not the broadcast address), and this is a NAT
			// machine, then some adapters may be better than others for reaching the
			// desired address.  Particularly, it's better to use a private adapter,
			// which can directly reach the private network & be mapped on the public
			// network, than to use the public adapter.  It's not fun to join a private
			// game from an ICS machine while dialed up, have your Internet connection
			// go down, and lose the connection to the private game which didn't
			// (shouldn't) involve the Internet at all.  So if we detect a public
			// adapter when we have a perfectly good private adapter, we'll prematurely
			// complete enumerations on the public one.
			//


			//
			// Cast to get rid of the const.  Don't worry, we won't actually change it.
			//
			pSocketAddress = (CSocketAddress*) pTempEndpoint->GetRemoteAddressPointer();
			psaddrinTemp = (SOCKADDR_IN*) pSocketAddress->GetAddress();
			pSocketPort = pTempEndpoint->GetSocketPort();


			//
			// See if this is a directed IP enum.
			//
			if ( ( pSocketAddress != NULL ) &&
				( pSocketPort != NULL ) &&
				( pSocketAddress->GetFamily() == AF_INET ) &&
				( psaddrinTemp->sin_addr.S_un.S_addr != INADDR_BROADCAST ) )
			{
				for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
				{
					if (pSocketPort->GetNATHelpPort(dwTemp) != NULL)
					{
						DNASSERT( g_papNATHelpObjects[dwTemp] != NULL );
						dwPublicAddressesSize = sizeof(saddrPublic);
						dwAddressTypeFlags = 0;
						hTempResult = IDirectPlayNATHelp_GetRegisteredAddresses(g_papNATHelpObjects[dwTemp],
																				pSocketPort->GetNATHelpPort(dwTemp),
																				&saddrPublic,
																				&dwPublicAddressesSize,
																				&dwAddressTypeFlags,
																				NULL,
																				0);
						if ((hTempResult != DPNH_OK) || (! (dwAddressTypeFlags & DPNHADDRESSTYPE_GATEWAYISLOCAL)))
						{
							DPFX(DPFPREP, 7, "Socketport 0x%p is not locally mapped on gateway with NAT Help index %u (err = 0x%lx, flags = 0x%lx).",
								pSocketPort, dwTemp, hTempResult, dwAddressTypeFlags);
						}
						else
						{
							//
							// There is a local NAT.
							//
							DPFX(DPFPREP, 7, "Socketport 0x%p is locally mapped on gateway with NAT Help index %u (flags = 0x%lx), public address:",
								pSocketPort, dwTemp, dwAddressTypeFlags);
							DumpSocketAddress(7, &saddrPublic, AF_INET);
							

							//
							// Find the multiplexed enum on the public adapter that
							// we need to complete early, as described above.
							//
							pBilinkPublic = blInitiate.GetNext();
							while (pBilinkPublic != &blInitiate)
							{
								pPublicEndpoint = CONTAINING_OBJECT(pBilinkPublic, CEndpoint, m_blMultiplex);

								//
								// Don't bother checking the endpoint whose public
								// address we're seeking.
								//
								if (pPublicEndpoint != pTempEndpoint)
								{
									pPublicSocketPort = pPublicEndpoint->GetSocketPort();
									if ( pPublicSocketPort != NULL )
									{
										//
										// Cast to get rid of the const.  Don't worry, we won't
										// actually change it.
										//
										pSocketAddress = (CSocketAddress*) pPublicSocketPort->GetNetworkAddress();
										if ( pSocketAddress != NULL )
										{
											if ( pSocketAddress->CompareToBaseAddress( &saddrPublic ) == 0)
											{
												DPFX(DPFPREP, 3, "Endpoint 0x%p is multiplexed onto public adapter for endpoint 0x%p (current endpoint = 0x%p), completing public enum.",
													pTempEndpoint, pPublicEndpoint, this);

												//
												// Pull it out of the multiplex association list and move
												// it to the "early completion" list.
												//
												pPublicEndpoint->RemoveFromMultiplexList();
												pPublicEndpoint->m_blMultiplex.InsertBefore(&blCompleteEarly);

												break;
											}
											

											//
											// Otherwise, continue searching.
											//

											DPFX(DPFPREP, 8, "Endpoint 0x%p is multiplexed onto different adapter:",
												pPublicEndpoint);
											DumpSocketAddress(8, pSocketAddress->GetWritableAddress(), pSocketAddress->GetFamily());
										}
										else
										{
											DPFX(DPFPREP, 1, "Public endpoint 0x%p's socket port 0x%p is going away, skipping.",
												pPublicEndpoint, pPublicSocketPort);
										}
									}
									else
									{
										DPFX(DPFPREP, 1, "Public endpoint 0x%p is going away, skipping.",
											pPublicEndpoint);
									}
								}
								else
								{
									//
									// The same endpoint as the one whose
									// public address we're seeking.
									//
								}

								pBilinkPublic = pBilinkPublic->GetNext();
							}


							//
							// No need to search for any more NAT Help registrations.
							//
							break;
						} // end else (is mapped locally on Internet gateway)
					}
					else
					{
						//
						// No DirectPlay NAT Helper registration in this slot.
						//
					}
				} // end for (each DirectPlay NAT Helper)


				//
				// NOTE: We should complete enums for non-optimal adapters even
				// when it's multiadapter but not a PAST/UPnP enabled NAT (see
				// ProcessEnumResponseData for WSAIoctl usage related to this).
				// We do not currently do this.  There can still be race conditions
				// for directed enums where the response for the "wrong" device
				// arrives first.
				//
			}
			else
			{
				//
				// Not IP address, or enum being sent to the broadcast address,
				// or possibly the endpoint is shutting down.
				//
				DPFX(DPFPREP, 1, "Found non-IP endpoint (possibly closing) or enum IP endpoint bound to broadcast address (endpoint = 0x%p, socket address = 0x%p, socketport = 0x%p), not checking for local NAT mapping.",
					pTempEndpoint, pSocketAddress, pSocketPort);
			}


			//
			// Go to the next associated endpoint.  Although it's possible for
			// entries to have been removed from the list, the current entry
			// could not have been, so we're safe.
			//
			pBilinkAll = pBilinkAll->GetNext();
		}


		//
		// Because we walk the list of associated multiplex enums when we receive
		// responses, and that list walker does not expect to see a root node, we
		// need to make sure that's gone before we drop the lock.  Get a pointer
		// to the first and last items remaining in the list before we do that (if
		// there are entries).
		//
		if (! blInitiate.IsEmpty())
		{
			pBilinkAll = blInitiate.GetNext();
			pBilinkEnd = blInitiate.GetPrev();
			blInitiate.RemoveFromList();


			//
			// Now loop through the remaining endpoints and kick off their enum jobs.
	 		//
			// Unlike Connects, we will not remove the Enums from the list since we
			// need to filter out broadcasts received on the "wrong" adapter (see
			// ProcessEnumResponseData).
			//
			do
			{
				pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);

				pBilinkNext = pBilinkAll->GetNext();


				//
				// See notes above about NULL handling.
				//
				if ( pTempEndpoint->m_pActiveCommandData != NULL )
				{
					//
					// The endpoint's command may be cancelled already.  So we take the
					// command lock now, and abort the enum if it's no longer necessary.  
					//
					
					pTempEndpoint->m_pActiveCommandData->Lock();
				
					if ( pTempEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
					{
						//
						// If the command has been cancelled, pull this endpoint out of the multiplex
						// association list and move it to the "early completion" list.
						//
						
						pTempEndpoint->m_pActiveCommandData->Unlock();
						
						DPFX(DPFPREP, 1, "Endpoint 0x%p's enum command (0x%p) has been cancelled, moving to early completion list.",
							pTempEndpoint, pTempEndpoint->m_pActiveCommandData);


						pTempEndpoint->RemoveFromMultiplexList();
						pTempEndpoint->m_blMultiplex.InsertBefore(&blCompleteEarly);
					}
					else
					{
						//
						// The command has not been cancelled.
						//
						// This is very hairy, but we drop the socketport data lock and
						// keep the command data lock.  Dropping the socketport data
						// lock should prevent deadlocks with the enum completing inside
						// the timer lock, and keeping the command data lock should
						// prevent people from cancelling the endpoint's command.
						//
						// However, once we drop the command lock, we do want the
						// command to be cancellable, so set the state appropriately now.
						//
						
						pTempEndpoint->m_pActiveCommandData->SetState( COMMAND_STATE_INPROGRESS );

						this->m_pSPData->UnlockSocketPortData();
						fLockedSocketPortData = FALSE;



						//
						// check retry count to determine if we're enumerating forever
						//
						switch ( pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwRetryCount )
						{
							//
							// let SP determine retry count
							//
							case 0:
							{
								uRetryCount = DEFAULT_ENUM_RETRY_COUNT;
								fRetryForever = FALSE;
								break;
							}

							//
							// retry forever
							//
							case INFINITE:
							{
								uRetryCount = 1;
								fRetryForever = TRUE;
								break;
							}

							//
							// other
							//
							default:
							{
								uRetryCount = pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwRetryCount;
								fRetryForever = FALSE;
								break;
							}
						}
						
						//
						// check interval for default
						//
						RetryInterval.Time32.TimeHigh = 0;
						if ( pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwRetryInterval == 0 )
						{
							RetryInterval.Time32.TimeLow = DEFAULT_ENUM_RETRY_INTERVAL;
						}
						else
						{
							RetryInterval.Time32.TimeLow = pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwRetryInterval;
						}

						//
						// check timeout to see if we're enumerating forever
						//
						switch ( pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwTimeout )
						{
							//
							// wait forever
							//
							case INFINITE:
							{
								fWaitForever = TRUE;
								IdleTimeout.Time32.TimeHigh = -1;
								IdleTimeout.Time32.TimeLow = -1;
								break;
							}

							//
							// possible default
							//
							case 0:
							{
								fWaitForever = FALSE;
								IdleTimeout.Time32.TimeHigh = 0;
								IdleTimeout.Time32.TimeLow = DEFAULT_ENUM_TIMEOUT;	
								break;
							}

							//
							// other
							//
							default:
							{
								fWaitForever = FALSE;
								IdleTimeout.Time32.TimeHigh = 0;
								IdleTimeout.Time32.TimeLow = pTempEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.dwTimeout;
								break;
							}
						}

						//
						// initialize array to compute round-trip times
						//
						memset( pTempEndpoint->GetCommandParameters()->dwEnumSendTimes, 0x00, sizeof( pTempEndpoint->GetCommandParameters()->dwEnumSendTimes ) );
						pTempEndpoint->GetCommandParameters()->dwEnumSendIndex = 0;

						
						DPFX(DPFPREP, 6, "Submitting enum timer job for endpoint 0x%p, retry count = %u, retry forever = %i, retry interval = %u, wait forever = %i, idle timeout = %u, context = 0x%p.",
							pTempEndpoint,
							uRetryCount,
							fRetryForever,
							RetryInterval.Time32.TimeLow,
							fWaitForever,
							IdleTimeout.Time32.TimeLow,
							pTempEndpoint->m_pActiveCommandData);

						if ( pTempEndpoint->m_pSPData != NULL )
						{
							hTempResult = pTempEndpoint->m_pSPData->GetThreadPool()->SubmitTimerJob( TRUE,								// perform immediately
																								uRetryCount,							// number of times to retry command
																								fRetryForever,							// retry forever
																								RetryInterval,							// retry interval
																								fWaitForever,							// wait forever after all enums sent
																								IdleTimeout,							// timeout to wait after command complete
																								CEndpoint::EnumTimerCallback,			// function called when timer event fires
																								CEndpoint::EnumCompleteWrapper,			// function called when timer event expires
																								pTempEndpoint->m_pActiveCommandData );	// context
						}
						else
						{
							DPFX(DPFPREP, 1, "Endpoint 0x%p's SP data is NULL, not submitting timer job.",
								pTempEndpoint);
						}


						//
						// Drop active command data lock now that we've finished submission.
						//
						pTempEndpoint->m_pActiveCommandData->Unlock();

						
						//
						// Retake the socketport data lock so we can continue to work with the
						// list.
						//
						this->m_pSPData->LockSocketPortData();
						fLockedSocketPortData = TRUE;


						if ( hTempResult != DPN_OK )
						{
							DPFX(DPFPREP, 0, "Failed to spool enum job for endpoint 0x%p onto work thread (err = 0x%lx)!  Moving to early completion list.",
								pTempEndpoint, hTempResult);
							DisplayDNError( 0, hTempResult );
							
							//
							// Move it to the "early completion" list.
							//
							pTempEndpoint->RemoveFromMultiplexList();
							pTempEndpoint->m_blMultiplex.InsertBefore(&blCompleteEarly);
						}
					}
				}
				else
				{
					DPFX(DPFPREP, 1, "Endpoint 0x%p's active command data is NULL, skipping.",
						pTempEndpoint);
				}


				//
				// If we've looped back around to the beginning, we're done.
				//
				if (pBilinkAll == pBilinkEnd)
				{
					break;
				}


				//
				// Go to the next associated endpoint.
				//
				pBilinkAll = pBilinkNext;
			}
			while (TRUE);
		}
		else
		{
			DPFX(DPFPREP, 1, "No remaining enums to initiate.");
		}


		//
		// Finally loop through all the enums that need to complete early and
		// do just that.
		//
		while (! blCompleteEarly.IsEmpty())
		{
			pBilinkAll = blCompleteEarly.GetNext();
			pTempEndpoint = CONTAINING_OBJECT(pBilinkAll, CEndpoint, m_blMultiplex);


			//
			// Pull it from the "complete early" list.
			//
			pTempEndpoint->RemoveFromMultiplexList();


			//
			// Drop the socket port lock.  It's safe since we pulled everything we
			// we need off of the list that needs protection.
			//
			this->m_pSPData->UnlockSocketPortData();
			fLockedSocketPortData = FALSE;


			//
			// See notes above about NULL handling.
			//
			if ( pTempEndpoint->m_pActiveCommandData != NULL )
			{
				//
				// Complete it with the appropriate error code.
				//
				
				pTempEndpoint->m_pActiveCommandData->Lock();

				if ( pTempEndpoint->m_pActiveCommandData->GetState() == COMMAND_STATE_CANCELLING )
				{
					DPFX(DPFPREP, 6, "Completing endpoint 0x%p enum with USERCANCEL.", pTempEndpoint);
					hTempResult = DPNERR_USERCANCEL;
				}
				else
				{
					//
					// Retrieve the current command result.
					// If the command didn't have a descriptive error, assume it was
					// not previously set (i.e. wasn't overridden by BindEndpoint above),
					// and use NOCONNECTION instead.
					//
					hTempResult = pTempEndpoint->PendingCommandResult();
					if ( hTempResult == DPNERR_GENERIC )
					{
						hTempResult = DPNERR_NOCONNECTION;
					}
				
					DPFX(DPFPREP, 6, "Completing endpoint 0x%p enum query (command 0x%p) with error 0x%lx.",
						pTempEndpoint, pTempEndpoint->m_pActiveCommandData, hTempResult);
				}
				
				pTempEndpoint->m_pActiveCommandData->Unlock();
				
				CEndpoint::EnumCompleteWrapper( hTempResult, pTempEndpoint->m_pActiveCommandData );
			}
			else
			{
				DPFX(DPFPREP, 1, "Endpoint 0x%p's active command data is NULL, skipping.",
					pTempEndpoint);
			}


			//
			// Retake the socket port lock and go to next item.
			//
			this->m_pSPData->LockSocketPortData();
			fLockedSocketPortData = TRUE;
		}


		this->m_pSPData->UnlockSocketPortData();
		fLockedSocketPortData = FALSE;
	}
	else
	{
		//
		// Not last multiplexed adapter.  All the work needed to be done for these
		// endpoints at this time has already been done.
		//
		DPFX(DPFPREP, 6, "Endpoint 0x%p is not the last multiplexed adapter, not submitting enum timer job yet.",
			this);
	}


Exit:
	if ( EnumAddressInfo.pHostAddress != NULL )
	{
		IDirectPlay8Address_Release( EnumAddressInfo.pHostAddress );
		EnumAddressInfo.pHostAddress = NULL;
	}

	if ( EnumAddressInfo.pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( EnumAddressInfo.pDeviceAddress );
		EnumAddressInfo.pDeviceAddress = NULL;
	}
	
	DNASSERT( pDeviceAddress != NULL );
	IDirectPlay8Address_Release( pDeviceAddress );

	DNASSERT( pHostAddress != NULL );
	IDirectPlay8Address_Release( pHostAddress );

	DNASSERT( !fLockedSocketPortData );

	DNASSERT(blCompleteEarly.IsEmpty());


	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);

	return	hr;

Failure:

	//
	// If we still have the socket port lock, drop it.
	//
	if ( fLockedSocketPortData )
	{
		this->m_pSPData->UnlockSocketPortData();
		fLockedSocketPortData = FALSE;
	}
	
	//
	// we've failed to complete the enum query, clean up and return this
	// endpoint to the pool
	//
	if ( fEndpointLocked != FALSE )
	{
		Unlock();
		fEndpointLocked = FALSE;
	}

	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	//
	// remove timer thread reference
	//
	DecRef();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumCompleteWrapper - wrapper when enum has completed
//
// Entry:		Error code from enum command
//				Pointer to context	
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumCompleteWrapper"

void	CEndpoint::EnumCompleteWrapper( const HRESULT hResult, void *const pContext )
{
	CCommandData	*pCommandData;


	DNASSERT( pContext != NULL );
	pCommandData = static_cast<CCommandData*>( pContext );
	pCommandData->GetEndpoint()->EnumComplete( hResult );
/*	REMOVE - MJN
	pCommandData->GetEndpoint()->Close( hResult );
	pCommandData->GetEndpoint()->m_pSPData->CloseEndpointHandle( pCommandData->GetEndpoint() );
	pCommandData->GetEndpoint()->DecRef();
*/
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumComplete - enum has completed
//
// Entry:		Error code from enum command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumComplete"

void	CEndpoint::EnumComplete( const HRESULT hResult )
{
	BOOL	fProcessCompletion;
	BOOL	fReleaseEndpoint;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%lx)", this, hResult);

	fProcessCompletion = FALSE;
	fReleaseEndpoint = FALSE;

	Lock();
	switch ( m_State )
	{
		//
		// enumerating, note that this endpoint is disconnecting
		//
		case ENDPOINT_STATE_ENUM:
		{
			//
			//	If there are threads using this endpoint,
			//	queue the completion
			//
			if (m_dwThreadCount)
			{
				SetState( ENDPOINT_STATE_WAITING_TO_COMPLETE );
			}
			else
			{
				SetState( ENDPOINT_STATE_DISCONNECTING );
				fReleaseEndpoint = TRUE;
			}

			//
			//	Prevent more responses from finding this endpoint
			//
			fProcessCompletion = TRUE;

			break;
		}

		//
		//	endpoint needs to have a completion indicated
		//
		case ENDPOINT_STATE_WAITING_TO_COMPLETE:
		{
			if (m_dwThreadCount == 0)
			{
				SetState( ENDPOINT_STATE_DISCONNECTING );
				fReleaseEndpoint = TRUE;
			}
			break;
		}

		//
		// disconnecting (command was probably cancelled)
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			DNASSERT( m_dwThreadCount == 0 );
			fReleaseEndpoint = TRUE;
			break;
		}

		//
		// there's a problem
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	Unlock();

	if (fProcessCompletion)
	{
		GetCommandParameters()->dwEnumSendIndex = 0;
		Close( hResult );
		m_pSPData->CloseEndpointHandle( this );
	}
	if (fReleaseEndpoint)
	{
		DecRef();
	}


	DPFX(DPFPREP, 6, "(0x%p) Leave", this);

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CleanUpCommand - clean up this endpoint and unbind from CSocketPort
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CleanupCommand"

void	CEndpoint::CleanUpCommand( void )
{
	DPFX(DPFPREP, 6, "(0x%p) Enter", this);

	
	//
	// There is an 'EndpointRef' that the endpoint holds against the
	// socket port since it was created and always must be released.
	// If the endpoint was bound it needs to be unbound.
	//
	if ( GetSocketPort() != NULL )
	{
		DNASSERT( m_pSPData != NULL );
		m_pSPData->UnbindEndpoint( this );
	}
	
	//
	// If we're bailing here it's because the UI didn't complete.  There is no
	// adapter guid to return because one may have not been specified.  Return
	// a bogus endpoint handle so it can't be queried for addressing data.
	//
	if ( m_fListenStatusNeedsToBeIndicated != FALSE )
	{
		HRESULT				hTempResult;
		SPIE_LISTENSTATUS	ListenStatus;
		

		m_fListenStatusNeedsToBeIndicated = FALSE;
		memset( &ListenStatus, 0x00, sizeof( ListenStatus ) );
		ListenStatus.hCommand = m_pActiveCommandData;
		ListenStatus.hEndpoint = INVALID_HANDLE_VALUE;
		ListenStatus.hResult = PendingCommandResult();
		memset( &ListenStatus.ListenAdapter, 0x00, sizeof( ListenStatus.ListenAdapter ) );
		ListenStatus.pUserContext = m_pActiveCommandData->GetUserContext();


		DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_LISTENSTATUS 0x%p to interface 0x%p.",
			this, &ListenStatus, m_pSPData->DP8SPCallbackInterface());
		
		hTempResult = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),	// pointer to DPlay callbacks
													SPEV_LISTENSTATUS,						// data type
													&ListenStatus							// pointer to data
													);

		DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_LISTENSTATUS [0x%lx].",
			this, hTempResult);

		DNASSERT( hTempResult == DPN_OK );
	}
	
	m_State = ENDPOINT_STATE_UNINITIALIZED;
	SetHandle( INVALID_HANDLE_VALUE );

	
	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessEnumData - process received enum data
//
// Entry:		Pointer to received buffer
//				Associated enum key
//				Pointer to return address
//
// Exit:		Nothing
//
// Note:	This function assumes that the endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessEnumData"

void	CEndpoint::ProcessEnumData( SPRECEIVEDBUFFER *const pBuffer, const DWORD dwEnumKey, const CSocketAddress *const pReturnSocketAddress )
{
	DNASSERT( pBuffer != NULL );
	DNASSERT( pReturnSocketAddress != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// find out what state the endpoint is in before processing data
	//
	switch ( m_State )
	{
		//
		// we're listening, this is the only way to detect enums
		//
		case ENDPOINT_STATE_LISTEN:
		{
			ENDPOINT_ENUM_QUERY_CONTEXT	QueryContext;
			HRESULT		hr;


			//
			// initialize
			//
			DNASSERT( m_pActiveCommandData != NULL );
			DEBUG_ONLY( memset( &QueryContext, 0x00, sizeof( QueryContext ) ) );

			//
			// set callback data
			//
			QueryContext.hEndpoint = GetHandle();
			QueryContext.dwEnumKey = dwEnumKey;
			QueryContext.pReturnAddress = pReturnSocketAddress;
			
			QueryContext.EnumQueryData.pReceivedData = pBuffer;
			QueryContext.EnumQueryData.pUserContext = m_pActiveCommandData->GetUserContext();

			//
			// attempt to build a DNAddress for the user, if we can't allocate
			// the memory ignore this enum
			//
			QueryContext.EnumQueryData.pAddressSender = pReturnSocketAddress->DP8AddressFromSocketAddress();
			QueryContext.EnumQueryData.pAddressDevice = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT,
																									GetGatewayBindType() );

			if ( ( QueryContext.EnumQueryData.pAddressSender != NULL ) &&
				 ( QueryContext.EnumQueryData.pAddressDevice != NULL ) )
			{
				DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_ENUMQUERY 0x%p to interface 0x%p.",
					this, &QueryContext.EnumQueryData, m_pSPData->DP8SPCallbackInterface());

				DumpAddress( 8, "\t Sender:", QueryContext.EnumQueryData.pAddressSender );
				DumpAddress( 8, "\t Device:", QueryContext.EnumQueryData.pAddressDevice );

				hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet interface
												   SPEV_ENUMQUERY,							// data type
												   &QueryContext.EnumQueryData				// pointer to data
												   );

				DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_ENUMQUERY [0x%lx].", this, hr);

				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "User returned unexpected error from enum query indication!" );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );
				}
			}

			if ( QueryContext.EnumQueryData.pAddressSender != NULL )
			{
				IDirectPlay8Address_Release( QueryContext.EnumQueryData.pAddressSender );
				QueryContext.EnumQueryData.pAddressSender = NULL;
 			}
			
			if ( QueryContext.EnumQueryData.pAddressDevice != NULL )
			{
				IDirectPlay8Address_Release( QueryContext.EnumQueryData.pAddressDevice );
				QueryContext.EnumQueryData.pAddressDevice = NULL;
 			}

			break;
		}

		//
		// we're disconnecting, ignore this message
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessEnumResponseData - process received enum response data
//
// Entry:		Pointer to received data
//				Pointer to address of sender
//
// Exit:		Nothing
//
// Note:	This function assumes that the endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessEnumResponseData"

void	CEndpoint::ProcessEnumResponseData( SPRECEIVEDBUFFER *const pBuffer,
											const CSocketAddress *const pReturnSocketAddress,
											const UINT_PTR uRTTIndex )
{
	HRESULT				hrTemp;
	BOOL				fAddedThreadCount = FALSE;
	SPIE_QUERYRESPONSE	QueryResponseData;

	DNASSERT( pBuffer != NULL );
	DNASSERT( pReturnSocketAddress != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	//
	// Initialize.
	//
	memset( &QueryResponseData, 0x00, sizeof( QueryResponseData ) );


	DPFX(DPFPREP, 8, "Socketport 0x%p, endpoint 0x%p receiving enum RTT index 0x%x/%u.",
		this->GetSocketPort(), this, uRTTIndex, uRTTIndex); 


	Lock();
	switch( m_State )
	{
		case ENDPOINT_STATE_ENUM:
		{
			//
			// Valid endpoint - increment the thread count to prevent premature completion
			//
			AddRefThreadCount();
			
			fAddedThreadCount = TRUE;


			//
			// Attempt to build a sender DPlay8Addresses for the user.
			// If this fails, we'll ignore the enum.
			//
			QueryResponseData.pAddressSender = pReturnSocketAddress->DP8AddressFromSocketAddress();
			break;
		}
		case ENDPOINT_STATE_WAITING_TO_COMPLETE:
		case ENDPOINT_STATE_DISCONNECTING:
		{
			//
			// Endpoint is waiting to complete or is disconnecting - ignore data
			//
			DPFX(DPFPREP, 2, "Endpoint 0x%p in state %u, ignoring enum response.",
				this, m_State);
			break;
		}
		default:
		{
			//
			// What's going on ?
			//
			DNASSERT( !"Invalid endpoint state" );
			break;
		}
	}
	Unlock();


	//
	// If this is a multiplexed IP broadcast enum, we may want to drop the response
	// because there may be a more appropriate adapter (NAT private side adapter)
	// that should also be getting responses.
	// Also, if this is a directed IP enum, we should note whether this response
	// got proxied or not.
	//
	if ( QueryResponseData.pAddressSender != NULL )
	{
		CSocketAddress *		pSocketAddress;
		const SOCKADDR_IN *		psaddrinOriginalTarget;
		const SOCKADDR_IN *		psaddrinResponseSource;
		CSocketPort *			pSocketPort;
		DWORD					dwTemp;
		CBilink *				pBilink;
		CEndpoint *				pTempEndpoint;
		DWORD					dwPublicAddressesSize;
		DWORD					dwAddressTypeFlags;
		SOCKADDR				saddrTemp;
		BOOL					fFoundMatchingEndpoint;
		DWORD					dwBytesReturned;


		//
		// Find out where and how this enum was originally sent.
		//
		pSocketAddress = (CSocketAddress*) this->GetRemoteAddressPointer();
		DNASSERT( pSocketAddress != NULL );

	
		//
		// See if this is a response to and IP enum, either broadcast on multiple
		// adapters or directed, so we can have special NAT/proxy behavior.
		//
		if ( pSocketAddress->GetFamily() == AF_INET )
		{
			psaddrinOriginalTarget = (const SOCKADDR_IN *) pSocketAddress->GetAddress();

			pSocketPort = this->GetSocketPort();
			DNASSERT( pSocketPort != NULL );

			if ( psaddrinOriginalTarget->sin_addr.S_un.S_addr == INADDR_BROADCAST )
			{
				//
				// Lock the list while we look at the entries.
				//
				this->m_pSPData->LockSocketPortData();
				
				if (! this->m_blMultiplex.IsEmpty())
				{
					//
					// It's a broadcast IP enum on multiple adapters.
					//

					//
					// Cast to get rid of the const.  Don't worry, we won't actually
					// change it.
					//
					pSocketAddress = (CSocketAddress*) pSocketPort->GetNetworkAddress();
					DNASSERT( pSocketAddress != NULL );


					fFoundMatchingEndpoint = FALSE;

					//
					// Loop through all other associated multiplexed endpoints to see
					// if one is more appropriate to receive responses from this
					// endpoint.  See CompleteEnumQuery.
					//
					pBilink = this->m_blMultiplex.GetNext();
					do
					{
						pTempEndpoint = CONTAINING_OBJECT(pBilink, CEndpoint, m_blMultiplex);

						DNASSERT( pTempEndpoint != this );
						DNASSERT( pTempEndpoint->GetType() == ENDPOINT_TYPE_ENUM );
						DNASSERT( pTempEndpoint->GetState() != ENDPOINT_STATE_UNINITIALIZED );
						DNASSERT( pTempEndpoint->GetCommandParameters() != NULL );
						DNASSERT( pTempEndpoint->m_pActiveCommandData != NULL );


						pSocketPort = pTempEndpoint->GetSocketPort();
						DNASSERT( pSocketPort != NULL );

						for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
						{
							if (pSocketPort->GetNATHelpPort(dwTemp) != NULL)
							{
								DNASSERT( g_papNATHelpObjects[dwTemp] != NULL );
								dwPublicAddressesSize = sizeof(saddrTemp);
								dwAddressTypeFlags = 0;
								hrTemp = IDirectPlayNATHelp_GetRegisteredAddresses(g_papNATHelpObjects[dwTemp],
																					pSocketPort->GetNATHelpPort(dwTemp),
																					&saddrTemp,
																					&dwPublicAddressesSize,
																					&dwAddressTypeFlags,
																					NULL,
																					0);
								if ((hrTemp != DPNH_OK) || (! (dwAddressTypeFlags & DPNHADDRESSTYPE_GATEWAYISLOCAL)))
								{
									DPFX(DPFPREP, 7, "Socketport 0x%p is not locally mapped on gateway with NAT Help index %u (err = 0x%lx, flags = 0x%lx).",
										pSocketPort, dwTemp, hrTemp, dwAddressTypeFlags);
								}
								else
								{
									//
									// There is a local NAT.
									//
									DPFX(DPFPREP, 7, "Socketport 0x%p is locally mapped on gateway with NAT Help index %u (flags = 0x%lx), public address:",
										pSocketPort, dwTemp, dwAddressTypeFlags);
									DumpSocketAddress(7, &saddrTemp, AF_INET);
									

									//
									// Are we receiving via an endpoint on the public
									// adapter for that locally NATted endpoint?
									//
									if ( pSocketAddress->CompareToBaseAddress( &saddrTemp ) == 0)
									{
										//
										// If this response came from a private address,
										// then it would be better if the private adapter
										// handled it instead.
										//
										hrTemp = IDirectPlayNATHelp_QueryAddress(g_papNATHelpObjects[dwTemp],
																					pSocketPort->GetNetworkAddress()->GetAddress(),
																					pReturnSocketAddress->GetAddress(),
																					&saddrTemp,
																					sizeof(saddrTemp),
																					(DPNHQUERYADDRESS_CACHEFOUND | DPNHQUERYADDRESS_CACHENOTFOUND | DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED));
										if ((hrTemp == DPNH_OK) || (hrTemp == DPNHERR_NOMAPPINGBUTPRIVATE))
										{
											//
											// The address is private.  Drop this response,
											// and assume the private adapter will get one
											//
											DPFX(DPFPREP, 3, "Got enum response via public endpoint 0x%p that should be handled by associated private endpoint 0x%p instead, dropping.",
												this, pTempEndpoint);

											//
											// Clear the sender address so that we don't
											// indicate this enum.
											//
											IDirectPlay8Address_Release( QueryResponseData.pAddressSender );
											QueryResponseData.pAddressSender = NULL;
										}
										else
										{
											//
											// The address does not appear to be private.  Let the
											// response through.
											//
											DPFX(DPFPREP, 3, "Receiving enum response via public endpoint 0x%p but associated private endpoint 0x%p does not see sender as local (err = 0x%lx).",
												this, pTempEndpoint, hrTemp);
										}

										//
										// No need to search for any more private-side
										// endpoints.
										//
										fFoundMatchingEndpoint = TRUE;
									}
									else
									{
										DPFX(DPFPREP, 8, "Receiving enum response via endpoint 0x%p, which is not on the public adapter for associated multiplex endpoint 0x%p.",
											this, pTempEndpoint);
									}


									//
									// No need to search for any more NAT Help
									// registrations.
									//
									break;
								} // end else (is mapped locally on Internet gateway)
							}
							else
							{
								//
								// No DirectPlay NAT Helper registration in this slot.
								//
							}
						} // end for (each DirectPlay NAT Helper)


						//
						// If we found a matching private adapter, we can stop
						// searching.
						//
						if (fFoundMatchingEndpoint)
						{
							break;
						}


						//
						// Otherwise, go to the next endpoint.
						//
						pBilink = pBilink->GetNext();
					}
					while (pBilink != &this->m_blMultiplex);


					//
					// Drop the lock now that we're done with the list.
					//
					this->m_pSPData->UnlockSocketPortData();


					//
					// If we didn't already find a matching endpoint, see if
					// WinSock reports this as the best route for the response.
					//
					if (! fFoundMatchingEndpoint)
					{
						pSocketPort = this->GetSocketPort();
					
						if (p_WSAIoctl(pSocketPort->GetSocket(),
									SIO_ROUTING_INTERFACE_QUERY,
									(PVOID) pReturnSocketAddress->GetAddress(),
									pReturnSocketAddress->GetAddressSize(),
									&saddrTemp,
									sizeof(saddrTemp),
									&dwBytesReturned,
									NULL,
									NULL) == 0)
						{
							if (( ((SOCKADDR_IN*) (&saddrTemp))->sin_addr.S_un.S_addr != p_htonl(INADDR_LOOPBACK) ) &&
								( pSocketPort->GetNetworkAddress()->CompareToBaseAddress( &saddrTemp ) != 0))
							{
								//
								// The response would be better off arriving
								// on a different interface.
								//
								DPFX(DPFPREP, 3, "Got enum response via endpoint 0x%p (socketport 0x%p) that should be handled by the socketport for %s instead, dropping.",
									this, pSocketPort, p_inet_ntoa(((SOCKADDR_IN*) (&saddrTemp))->sin_addr));

								//
								// Clear the sender address so that we don't
								// indicate this enum.
								//
								IDirectPlay8Address_Release( QueryResponseData.pAddressSender );
								QueryResponseData.pAddressSender = NULL;
							}
							else
							{
								//
								// The response arrived on the interface with
								// the best route.
								//
								DPFX(DPFPREP, 3, "Receiving enum response via endpoint 0x%p (socketport 0x%p) that appears to be the best route (%s).",
									this, pSocketPort, p_inet_ntoa(((SOCKADDR_IN*) (&saddrTemp))->sin_addr));
							}
						}
#ifdef DEBUG
						else
						{
							DWORD					dwError;
							const SOCKADDR_IN *		psaddrinTemp;



							dwError = p_WSAGetLastError();
							psaddrinTemp = (const SOCKADDR_IN *) pReturnSocketAddress->GetAddress();
							DPFX(DPFPREP, 0, "Couldn't query routing interface for %s (err = %u)!  Assuming endpoint 0x%p (socketport 0x%p) is best route.",
								p_inet_ntoa(psaddrinTemp->sin_addr),
								dwError, this, pSocketPort);
						}
#endif // DEBUG
					} // end if (didn't find matching endpoint)
				}
				else
				{
					//
					// IP broadcast enum, but no multiplexed adapters.
					//

					//
					// Drop the lock we only needed it to look for multiplexed
					// adapters.
					//
					this->m_pSPData->UnlockSocketPortData();
					
					DPFX(DPFPREP, 8, "IP broadcast enum endpoint (0x%p) is not multiplexed, not checking for local NAT mapping.",
						this);
				}
			}
			else
			{
				psaddrinResponseSource = (const SOCKADDR_IN *) pReturnSocketAddress->GetAddress();

				//
				// It's an IP enum that wasn't sent to the broadcast address.
				// If the enum was sent to a specific port (not the DPNSVR
				// port) but we're getting a response from a different IP
				// address or port, then someone along the way is proxying/
				// NATting the data.  Store the original target in the
				// address, since it might come in handy depending on what
				// the user tries to do with that address.
				//
				if ((psaddrinResponseSource->sin_addr.S_un.S_addr != psaddrinOriginalTarget->sin_addr.S_un.S_addr) ||
					((psaddrinResponseSource->sin_port != psaddrinOriginalTarget->sin_port) &&
					 (p_ntohs(psaddrinOriginalTarget->sin_port) != DPNA_DPNSVR_PORT)))
				{
					if ((pSocketPort->IsUsingProxyWinSockLSP()) || (g_fTreatAllResponsesAsProxied))
					{
						PROXIEDRESPONSEORIGINALADDRESS	proa;

						
						DPFX(DPFPREP, 3, "Endpoint 0x%p (proxied socketport 0x%p) receiving enum response from different IP address and/or port.",
							this, pSocketPort);

						memset(&proa, 0, sizeof(proa));
						proa.dwSocketPortID				= pSocketPort->GetSocketPortID();
						proa.dwOriginalTargetAddressV4	= psaddrinOriginalTarget->sin_addr.S_un.S_addr;
						proa.wOriginalTargetPort		= psaddrinOriginalTarget->sin_port;
						
						//
						// Add the component, but ignore failure, we might be able
						// to survive without it.
						//
						hrTemp = IDirectPlay8Address_AddComponent( QueryResponseData.pAddressSender,					// interface
																	DPNA_PRIVATEKEY_PROXIED_RESPONSE_ORIGINAL_ADDRESS,	// tag
																	&proa,												// component data
																	sizeof(proa),										// component data size
																	DPNA_DATATYPE_BINARY								// component data type
																	);
						if ( hrTemp != DPN_OK )
						{
							DPFX(DPFPREP, 0, "Couldn't add private proxied response original address component (err = 0x%lx)!  Ignoring.",
								hrTemp);
						}
					}
					else
					{
						DPFX(DPFPREP, 3, "Endpoint 0x%p receiving enum response from different IP address and/or port, but socketport 0x%p not considered proxied, indicating as is.",
							this, pSocketPort);
					}
				}
				else
				{
					//
					// The IP address and port to which enum was originally
					// sent is the same as where this response came from, or
					// the port differs but the enum was originally sent to
					// the DPNSVR port, so it _should_ differ.
					//
				}
			}
		}
		else
		{
			//
			// Not IP address.
			//
			DPFX(DPFPREP, 8, "Non-IP endpoint (0x%p), not checking for local NAT mapping or proxy.",
				this);
		}
	}


	if ( QueryResponseData.pAddressSender != NULL )
	{
		DNASSERT( m_pActiveCommandData != NULL );

		//
		// set message data
		//
		DNASSERT( GetCommandParameters() != NULL );
		QueryResponseData.pReceivedData = pBuffer;
		QueryResponseData.dwRoundTripTime = GETTIMESTAMP() - GetCommandParameters()->dwEnumSendTimes[ uRTTIndex ];
		QueryResponseData.pUserContext = m_pActiveCommandData->GetUserContext();


		//
		// If we can't allocate the device address object, ignore this
		// enum.
		//
		QueryResponseData.pAddressDevice = GetSocketPort()->GetDP8BoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT,
																						GetGatewayBindType() );
		if ( QueryResponseData.pAddressDevice != NULL )
		{
			DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_QUERYRESPONSE 0x%p to interface 0x%p.",
				this, &QueryResponseData, m_pSPData->DP8SPCallbackInterface());

			DumpAddress( 8, "\t Sender:", QueryResponseData.pAddressSender );
			DumpAddress( 8, "\t Device:", QueryResponseData.pAddressDevice );

			hrTemp = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet interface
												   SPEV_QUERYRESPONSE,						// data type
												   &QueryResponseData						// pointer to data
												   );

			DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_QUERYRESPONSE [0x%lx].", this, hrTemp);

			if ( hrTemp != DPN_OK )
			{
				DPFX(DPFPREP, 0, "User returned unknown error when indicating query response!" );
				DisplayDNError( 0, hrTemp );
				DNASSERT( FALSE );
			}


			IDirectPlay8Address_Release( QueryResponseData.pAddressDevice );
			QueryResponseData.pAddressDevice = NULL;
		}

		IDirectPlay8Address_Release( QueryResponseData.pAddressSender );
		QueryResponseData.pAddressSender = NULL;
	}

	if (fAddedThreadCount)
	{
		DWORD	dwThreadCount;
		BOOL	fNeedToComplete;


		//
		//	Decrement thread count and complete if required
		//
		fNeedToComplete = FALSE;
		Lock();
		dwThreadCount = DecRefThreadCount();
		if ((m_State == ENDPOINT_STATE_WAITING_TO_COMPLETE) && (dwThreadCount == 0))
		{
			fNeedToComplete = TRUE;
		}
		Unlock();

		if (fNeedToComplete)
		{
			EnumComplete( DPN_OK );
		}
	}

	DNASSERT( QueryResponseData.pAddressSender == NULL );
	DNASSERT( QueryResponseData.pAddressDevice == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessUserData - process received user data
//
// Entry:		Pointer to received data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessUserData"

void	CEndpoint::ProcessUserData( CReadIOData *const pReadData )
{
	DNASSERT( pReadData != NULL );

	switch ( m_State )
	{
		//
		// endpoint is connected
		//
		case ENDPOINT_STATE_CONNECT_CONNECTED:
		{
			HRESULT		hr;
			SPIE_DATA	UserData;


			//
			// Although the endpoint is marked as connected, it's possible that
			// we haven't stored the user context yet.  Make sure we've done
			// that.
			//
			if ( ! m_fConnectSignalled )
			{
				DPFX(DPFPREP, 1, "(0x%p) Thread indicating connect has not stored user context yet, dropping read data 0x%p.",
					this, pReadData);
				break;
			}
			
			//
			// it's possible that the user wants to keep the data, add a
			// reference to keep it from going away
			//
			pReadData->AddRef();
			DEBUG_ONLY( DNASSERT( pReadData->m_fRetainedByHigherLayer == FALSE ) );
			DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = TRUE );

			//
			// we're connected report the user data
			//
			DEBUG_ONLY( memset( &UserData, 0x00, sizeof( UserData ) ) );
			UserData.hEndpoint = GetHandle();
			UserData.pEndpointContext = GetUserEndpointContext();
			UserData.pReceivedData = pReadData->ReceivedBuffer();


			DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_DATA 0x%p to interface 0x%p.",
				this, &UserData, m_pSPData->DP8SPCallbackInterface());
		
			hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// pointer to interface
											   SPEV_DATA,								// user data was received
											   &UserData								// pointer to data
											   );

			DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_DATA [0x%lx].", this, hr);

			switch ( hr )
			{
				//
				// user didn't keep the data, remove the reference added above
				//
				case DPN_OK:
				{
					DNASSERT( pReadData != NULL );
					DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
					pReadData->DecRef();
					break;
				}

				//
				// The user kept the data buffer, they will return it later.
				// Leave the reference to prevent this buffer from being returned
				// to the pool.
				//
				case DPNERR_PENDING:
				{
					break;
				}


				//
				// Unknown return.  Remove the reference added above.
				//
				default:
				{
					DNASSERT( pReadData != NULL );
					DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
					pReadData->DecRef();

					DPFX(DPFPREP, 0, "User returned unknown error when indicating user data (err = 0x%lx)!", hr );
					DisplayDNError( 0, hr );
					DNASSERT( FALSE );

					break;
				}
			}

			break;
		}

		//
		// Endpoint hasn't finished connecting yet, ignore data.
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		{
			DPFX(DPFPREP, 3, "Endpoint 0x%p still connecting, dropping read data 0x%p.",
				this, pReadData);
			break;
		}
		
		//
		// Endpoint disconnecting, ignore data.
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			DPFX(DPFPREP, 3, "Endpoint 0x%p disconnecting, dropping read data 0x%p.",
				this, pReadData);
			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::ProcessUserDataOnListen - process received user data on a listen
//		port that may result in a new connection
//
// Entry:		Pointer to received data
//				Pointer to socket address that data was received from
//
// Exit:		Nothing
//
// Note:	This function assumes that this endpoint has been locked.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::ProcessUserDataOnListen"

void	CEndpoint::ProcessUserDataOnListen( CReadIOData *const pReadData, const CSocketAddress *const pSocketAddress )
{
	HRESULT			hr;
	CEndpoint *		pNewEndpoint;
	SPIE_CONNECT	ConnectData;


	DNASSERT( pReadData != NULL );
	DNASSERT( pSocketAddress != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );

	DPFX(DPFPREP, 7, "Endpoint 0x%p reporting connect on a listen.", this );

	//
	// initialize
	//
	pNewEndpoint = NULL;

	switch ( m_State )
	{
		//
		// this endpoint is still listening
		//
		case ENDPOINT_STATE_LISTEN:
		{
			break;
		}

		//
		// we're unable to process this user data, exti
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			goto Exit;

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// get a new endpoint from the pool
	//
	pNewEndpoint = m_pSPData->GetNewEndpoint();
	if ( pNewEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Could not create new endpoint for new connection on listen!" );
		goto Failure;
	}


	//
	// We are adding this endpoint to the hash table and indicating it up
	// to the user, so it's possible that it could be disconnected (and thus
 	// removed from the table) while we're still in here.  We need to
 	// hold an additional reference for the duration of this function to
  	// prevent it from disappearing while we're still indicating data.
	//
	pNewEndpoint->AddCommandRef();


	//
	// open this endpoint as a new connection, since the new endpoint
	// is related to 'this' endpoint, copy local information
	//
	hr = pNewEndpoint->Open( ENDPOINT_TYPE_CONNECT_ON_LISTEN,
							 NULL,
							 pSocketAddress
							 );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem initializing new endpoint when indicating connect on listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}


	hr = m_pSPData->BindEndpoint( pNewEndpoint, NULL, GetSocketPort()->GetNetworkAddress(), GATEWAY_BIND_TYPE_NONE );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to bind new endpoint for connect on listen!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	

	//
	// Indicate connect on this endpoint.
	//
	DEBUG_ONLY( memset( &ConnectData, 0x00, sizeof( ConnectData ) ) );
	DBG_CASSERT( sizeof( ConnectData.hEndpoint ) == sizeof( pNewEndpoint ) );
	ConnectData.hEndpoint = pNewEndpoint->GetHandle();

	DNASSERT( m_pActiveCommandData != NULL );
	DNASSERT( GetCommandParameters() != NULL );
	ConnectData.pCommandContext = GetCommandParameters()->PendingCommandData.ListenData.pvContext;

	DNASSERT( pNewEndpoint->GetUserEndpointContext() == NULL );
	hr = pNewEndpoint->SignalConnect( &ConnectData );
	switch ( hr )
	{
		//
		// user accepted new connection
		//
		case DPN_OK:
		{
			//
			// fall through to code below
			//

			break;
		}

		//
		// user refused new connection
		//
		case DPNERR_ABORTED:
		{
			DNASSERT( pNewEndpoint->GetUserEndpointContext() == NULL );
			DPFX(DPFPREP, 8, "User refused new connection!" );
			goto Failure;

			break;
		}

		//
		// other
		//
		default:
		{
			DPFX(DPFPREP, 0, "Unknown return when indicating connect event on new connect from listen!" );
			DisplayDNError( 0, hr );
			DNASSERT( FALSE );

			break;
		}
	}

	//
	// note that a connection has been established and send the data received
	// through this new endpoint
	//
	pNewEndpoint->ProcessUserData( pReadData );


	//
	// Remove the reference we added just after creating the endpoint.
	//
	pNewEndpoint->DecCommandRef();
	//pNewEndpoint = NULL;

Exit:
	return;

Failure:
	if ( pNewEndpoint != NULL )
	{
		//
		// closing endpoint decrements reference count and may return it to the pool
		//
		pNewEndpoint->Close( hr );
		m_pSPData->CloseEndpointHandle( pNewEndpoint );
		pNewEndpoint->DecCommandRef();	// remove reference added just after creating endpoint
		//pNewEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::EnumTimerCallback - timed callback to send enum data
//
// Entry:		Pointer to context
//				Pointer to current timer retry interval
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumTimerCallback"

void	CEndpoint::EnumTimerCallback( void *const pContext, DN_TIME * const pRetryInterval )
{
	CCommandData	*pCommandData;
	CEndpoint		*pThisObject;
	WRITE_IO_DATA_POOL_CONTEXT	PoolContext;
	CWriteIOData	*pWriteData;


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	pCommandData = static_cast<CCommandData*>( pContext );
	pThisObject = pCommandData->GetEndpoint();
	pWriteData = NULL;

	pThisObject->Lock();

	switch ( pThisObject->m_State )
	{
		//
		// we're enumerating (as expected)
		//
		case ENDPOINT_STATE_ENUM:
		{
			break;
		}

		//
		// this endpoint is disconnecting, bail!
		//
		case ENDPOINT_STATE_WAITING_TO_COMPLETE:
		case ENDPOINT_STATE_DISCONNECTING:
		{
			pThisObject->Unlock();
			goto Exit;

			break;
		}

		//
		// there's a problem
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	pThisObject->Unlock();

	//
	// attempt to get a new IO buffer for this endpoint
	//
	PoolContext.SPType = pThisObject->m_pSPData->GetType();
	pWriteData = pThisObject->m_pSPData->GetThreadPool()->GetNewWriteIOData( &PoolContext );
	if ( pWriteData == NULL )
	{
		DPFX(DPFPREP, 0, "Failed to get write data for an enum!" );
		goto Failure;
	}

	//
	// Set all data for the write.  Since this is an enum and we
	// don't care about the outgoing data, don't send an indication
	// when it completes.
	//
	DNASSERT( pThisObject->m_pActiveCommandData != NULL );
	DNASSERT( pThisObject->GetCommandParameters() != NULL );
	pWriteData->m_pBuffers = pThisObject->GetCommandParameters()->PendingCommandData.EnumQueryData.pBuffers;
	pWriteData->m_uBufferCount = pThisObject->GetCommandParameters()->PendingCommandData.EnumQueryData.dwBufferCount;
	pWriteData->m_pDestinationSocketAddress = pThisObject->GetRemoteAddressPointer();
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_NONE;

	DNASSERT( pWriteData->m_pCommand != NULL );
	DNASSERT( pWriteData->m_pCommand->GetUserContext() == NULL );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );

	DNASSERT( pThisObject->GetSocketPort() != NULL );
	pThisObject->GetCommandParameters()->dwEnumSendIndex++;
	pThisObject->GetCommandParameters()->dwEnumSendTimes[ ( pThisObject->GetCommandParameters()->dwEnumSendIndex & ENUM_RTT_MASK ) ] = GETTIMESTAMP();

	DPFX(DPFPREP, 8, "Socketport 0x%p, endpoint 0x%p sending enum RTT index 0x%x/%u.",
		pThisObject->GetSocketPort(),
		pThisObject,
		( pThisObject->GetCommandParameters()->dwEnumSendIndex & ENUM_RTT_MASK ),
		( pThisObject->GetCommandParameters()->dwEnumSendIndex & ENUM_RTT_MASK )); 

	pThisObject->GetSocketPort()->SendEnumQueryData( pWriteData,
													 ( pThisObject->GetEnumKey()->GetKey() | ( pThisObject->GetCommandParameters()->dwEnumSendIndex & ENUM_RTT_MASK ) ) );

Exit:
	return;

Failure:
	// nothing to clean up at this time

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SignalConnect - note connection
//
// Entry:		Pointer to connect data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::SignalConnect"

HRESULT	CEndpoint::SignalConnect( SPIE_CONNECT *const pConnectData )
{
	HRESULT	hr;


	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->hEndpoint == GetHandle() );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, FALSE );


	//
	// Lock while we check state.
	//
	Lock();

	//
	// initialize
	//
	hr = DPN_OK;

	switch ( m_State )
	{
		//
		// disconnecting, nothing to do
		//
		case ENDPOINT_STATE_DISCONNECTING:
		{
			DPFX(DPFPREP, 1, "Endpoint 0x%p disconnecting, not indicating SPEV_CONNECT.",
				this);
			
			//
			// Drop the lock.
			//
			Unlock();

			hr = DPNERR_USERCANCEL;
			
			break;
		}

		//
		// we're attempting to connect
		//
		case ENDPOINT_STATE_ATTEMPTING_CONNECT:
		{
			DNASSERT( m_fConnectSignalled == FALSE );

			//
			// Set the state as connected.
			//
			m_State = ENDPOINT_STATE_CONNECT_CONNECTED;

			//
			// Add a reference for the user.
			//
			AddRef();

			//
			// Drop the lock.
			//
			Unlock();

		
			DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_CONNECT 0x%p to interface 0x%p.",
				this, pConnectData, m_pSPData->DP8SPCallbackInterface());

			hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// interface
											   SPEV_CONNECT,							// event type
											   pConnectData								// pointer to data
											   );

			DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_CONNECT [0x%lx].", this, hr);

			switch ( hr )
			{
				//
				// connection accepted
				//
				case DPN_OK:
				{
					//
					// note that we're connected, unless we're already trying to
					// disconnect.
					//
					
					Lock();
					
					SetUserEndpointContext( pConnectData->pEndpointContext );
					m_fConnectSignalled = TRUE;

					if (m_State == ENDPOINT_STATE_DISCONNECTING)
					{
						//
						// Although the endpoint is disconnecting, whatever caused the
						// disconnect will release the reference added before we indicated
						// the connect.
						//

						DPFX(DPFPREP, 1, "Endpoint 0x%p already disconnecting.", this);
					}
					else
					{
						DNASSERT(m_State == ENDPOINT_STATE_CONNECT_CONNECTED);

						//
						// The reference added before we indicated the connect will be
						// removed when the endpoint is disconnected.
						//
					}

					Unlock();
					
					break;
				}

				//
				// user aborted connection attempt, nothing to do, just pass
				// the result on
				//
				case DPNERR_ABORTED:
				{
					DNASSERT( GetUserEndpointContext() == NULL );
					
					//
					// Remove the user reference.
					//
					DecRef();
					
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					
					//
					// Remove the user reference.
					//
					DecRef();
					
					break;
				}
			}

			break;
		}

		//
		// states where we shouldn't be getting called
		//
		default:
		{
			DNASSERT( FALSE );
			
			//
			// Drop the lock.
			//
			Unlock();
			
			break;
		}
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::SignalDisconnect - note disconnection
//
// Entry:		Old endpoint handle
//
// Exit:		Nothing
//
// Note:	This function assumes that this endpoint's data is locked!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::SignalDisconnect"

void	CEndpoint::SignalDisconnect( const HANDLE hOldEndpointHandle )
{
	HRESULT	hr;
	SPIE_DISCONNECT	DisconnectData;


	// tell user that we're disconnecting
	DNASSERT( m_fConnectSignalled != FALSE );
	DBG_CASSERT( sizeof( DisconnectData.hEndpoint ) == sizeof( this ) );
	DisconnectData.hEndpoint = hOldEndpointHandle;
	DisconnectData.pEndpointContext = GetUserEndpointContext();
	m_fConnectSignalled = FALSE;
	
	DPFX(DPFPREP, 2, "Endpoint 0x%p indicating SPEV_DISCONNECT 0x%p to interface 0x%p.",
		this, &DisconnectData, m_pSPData->DP8SPCallbackInterface());
		
	hr = IDP8SPCallback_IndicateEvent( m_pSPData->DP8SPCallbackInterface(),		// interface
									   SPEV_DISCONNECT,							// event type
									   &DisconnectData							// pointer to data
									   );

	DPFX(DPFPREP, 2, "Endpoint 0x%p returning from SPEV_DISCONNECT [0x%lx].", this, hr);

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem with SignalDisconnect!" );
		DisplayDNError( 0, hr );
		DNASSERT( FALSE );
	}

	SetDisconnectIndicationHandle( INVALID_HANDLE_VALUE );

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CEndpoint::CompletePendingCommand - complete a pending command
//
// Entry:		Error code returned for command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::CompletePendingCommand"

void	CEndpoint::CompletePendingCommand( const HRESULT hCommandResult )
{
	HRESULT								hr;
	ENDPOINT_COMMAND_PARAMETERS *		pCommandParameters;
	CCommandData *						pActiveCommandData;


	DNASSERT( GetCommandParameters() != NULL );
	DNASSERT( m_pActiveCommandData != NULL );

	pCommandParameters = GetCommandParameters();
	SetCommandParameters( NULL );

	pActiveCommandData = m_pActiveCommandData;
	m_pActiveCommandData = NULL;

	//
	// If this was a connect or enum command, it may be on the list of postponed
	// connects.  Even if it were not on the list, though, this remove is safe.
	//
	m_pSPData->LockSocketPortData();
	pActiveCommandData->RemoveFromPostponedList();
	m_pSPData->UnlockSocketPortData();


	DPFX(DPFPREP, 5, "Endpoint 0x%p completing command 0x%p (result = 0x%lx, user context 0x%p) to interface 0x%p.",
		this, pActiveCommandData, hCommandResult,
		pActiveCommandData->GetUserContext(),
		m_pSPData->DP8SPCallbackInterface());

	hr = IDP8SPCallback_CommandComplete( m_pSPData->DP8SPCallbackInterface(),	// pointer to callbacks
										pActiveCommandData,						// command handle
										hCommandResult,							// return
										pActiveCommandData->GetUserContext()	// user cookie
										);

	DPFX(DPFPREP, 5, "Endpoint 0x%p returning from command complete [0x%lx].", this, hr);


	memset( pCommandParameters, 0x00, sizeof( *pCommandParameters ) );
	ReturnEndpointCommandParameters( pCommandParameters );
	
	
	pActiveCommandData->DecRef();
	pActiveCommandData = NULL;

	//
	// Now that the command is done, release the interface reference we were
	// holding.
	//
	IDP8ServiceProvider_Release( m_pSPData->COMInterface() );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\endpoint.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Endpoint.h
 *  Content:	Winsock endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 *  01/10/2000	rmt		Updated to build with Millenium build process
 *  03/22/2000	jtk		Updated with changes to interface names
 *	03/12/01	mjn		Added ENDPOINT_STATE_WAITING_TO_COMPLETE, m_dwThreadCount
 ***************************************************************************/

#ifndef __ENDPOINT_H__
#define __ENDPOINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumeration of types of endpoints
//
typedef	enum	_ENDPOINT_TYPE
{
	ENDPOINT_TYPE_UNKNOWN = 0,				// unknown
	ENDPOINT_TYPE_CONNECT,					// endpoint is for connect
	ENDPOINT_TYPE_LISTEN,					// endpoint is for enum
	ENDPOINT_TYPE_ENUM,						// endpoint is for listen
	ENDPOINT_TYPE_CONNECT_ON_LISTEN,		// endpoint is for new connect coming from a listen
} ENDPOINT_TYPE;

//
// enumeration of the states an endpoint can be in
//
typedef	enum
{
	ENDPOINT_STATE_UNINITIALIZED = 0,		// uninitialized state
	ENDPOINT_STATE_ATTEMPTING_ENUM,			// attempting to enum
	ENDPOINT_STATE_ENUM,					// endpoint is supposed to enum connections
	ENDPOINT_STATE_ATTEMPTING_CONNECT,		// attempting to connect
	ENDPOINT_STATE_CONNECT_CONNECTED,		// endpoint is supposed to connect and is connected
	ENDPOINT_STATE_ATTEMPTING_LISTEN,		// attempting to listen
	ENDPOINT_STATE_LISTEN,					// endpoint is supposed to listen for connections
	ENDPOINT_STATE_DISCONNECTING,			// endpoint is disconnecting
	ENDPOINT_STATE_WAITING_TO_COMPLETE,		// endpoint is waiting to complete
} ENDPOINT_STATE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CSocketPort;
class	CSocketAddress;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;

//
// context structure used to get endpoints from the pool
//
typedef	struct	_ENDPOINT_POOL_CONTEXT
{
	CSPData *	pSPData;
	DWORD		dwEndpointID;
} ENDPOINT_POOL_CONTEXT;

//
// structure to bind extra information to an enum query to be used on enum reponse
//
typedef	struct	_ENDPOINT_ENUM_QUERY_CONTEXT
{
	SPIE_QUERY				EnumQueryData;
	HANDLE					hEndpoint;
	DWORD					dwEnumKey;
	const CSocketAddress	*pReturnAddress;
} ENDPOINT_ENUM_QUERY_CONTEXT;

//
// structure to hold command parameters for endpoints
//
typedef	struct	_ENDPOINT_COMMAND_PARAMETERS
{
	union										// Local copy of the pending command data.
	{											// This data contains the pointers to the
		SPCONNECTDATA		ConnectData;		// active command, and the user context.
		SPLISTENDATA		ListenData;			//
		SPENUMQUERYDATA		EnumQueryData;		//
	} PendingCommandData;						//

	GATEWAY_BIND_TYPE	GatewayBindType;		// type of NAT binding that should be made for the endpoint
	DWORD				dwEnumSendIndex;		// index of time stamp on enumeration to be sent
	DWORD				dwEnumSendTimes[ 16 ];	// times of last enumeration sends

} ENDPOINT_COMMAND_PARAMETERS;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

//
// class to act as a key for the enum lists in socket ports
//
class	CEndpointEnumKey
{
	public:
		CEndpointEnumKey() { };
		~CEndpointEnumKey() { };

		const UINT_PTR	GetKey( void ) const { return ( m_uKey & ~( ENUM_RTT_MASK ) ); }
		void	SetKey( const UINT_PTR uNewKey ) { m_uKey = uNewKey; };

		const INT_PTR	CompareFunction( const CEndpointEnumKey *const OtherKey ) const
		{
			INT_PTR	iReturn;


			if ( GetKey() == OtherKey->GetKey() )
			{
				iReturn = 0;
			}
			else
			{
				if ( GetKey() < OtherKey->GetKey() )
				{
					iReturn = -1;
				}
				else
				{
					iReturn = 1;
				}
			}

			return iReturn;
		}

		const INT_PTR	HashFunction( const UINT_PTR HashBitCount ) const
		{
			INT_PTR		iReturn;
			UINT_PTR	Temp;


			//
			// initialize
			//
			iReturn = 0;

			//
			// hash enum key
			//
			Temp = GetKey();
			do
			{
				iReturn ^= Temp & ( ( 1 << HashBitCount ) - 1 );
				Temp >>= HashBitCount;
			} while ( Temp != 0 );

			return	 iReturn;
		}

	private:
		UINT_PTR	m_uKey;
};

//
// class for an endpoint
//
class	CEndpoint : public CLockedContextFixedPoolItem< ENDPOINT_POOL_CONTEXT* >
{
	public:
		//
		// we need a virtual destructor to guarantee we call destructors in base classes
		//
		CEndpoint();
		virtual	~CEndpoint();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::Lock"
		void	Lock( void )
		{
			DNASSERT( m_fInitialized != FALSE );
			DNEnterCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::Unlock"
		void	Unlock( void )
		{
			DNASSERT( m_fInitialized != FALSE );
			DNLeaveCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::AddCommandRef"
		void	AddCommandRef( void )
		{
			DNInterlockedIncrement( &m_lCommandRefCount );
			AddRef();
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::DecCommandRef"
		void	DecCommandRef( void )
		{
			if ( DNInterlockedDecrement( &m_lCommandRefCount ) == 0 )
			{
				CleanUpCommand();
			}

			DecRef();
		}

		HANDLE	GetHandle( void ) const { return m_Handle; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetHandle"
		void	SetHandle( const HANDLE Handle )
		{
			DNASSERT( ( m_Handle == INVALID_HANDLE_VALUE ) || ( Handle == INVALID_HANDLE_VALUE ) );
			m_Handle = Handle;
		}

		HRESULT	Open( const ENDPOINT_TYPE EndpointType,
					  IDirectPlay8Address *const pDP8Address,
					  const CSocketAddress *const pSocketAddress );
		void	Close( const HRESULT hActiveCommandResult );
		void	ReinitializeWithBroadcast( void ) { m_pRemoteMachineAddress->InitializeWithBroadcastAddress(); }

		void	*GetUserEndpointContext( void ) const { return m_pUserEndpointContext; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetUserEndpointContext"
		void	SetUserEndpointContext( void *const pUserEndpointContext )
		{
			DNASSERT( ( m_pUserEndpointContext == NULL ) ||
					  ( pUserEndpointContext == NULL ) );
			m_pUserEndpointContext = pUserEndpointContext;
		}

		const ENDPOINT_TYPE		GetType( void ) const { return m_EndpointType; }
		
		const ENDPOINT_STATE	GetState( void ) const { return m_State; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetState"
		void	SetState( const ENDPOINT_STATE EndpointState )
		{
			DNASSERT( (EndpointState == ENDPOINT_STATE_DISCONNECTING ) || (EndpointState == ENDPOINT_STATE_WAITING_TO_COMPLETE));
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			m_State = EndpointState;
		}
		
		const GATEWAY_BIND_TYPE		GetGatewayBindType( void ) const { return m_GatewayBindType; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetGatewayBindType"
		void	SetGatewayBindType( const GATEWAY_BIND_TYPE GatewayBindType )
		{
			DNASSERT( (m_GatewayBindType != GATEWAY_BIND_TYPE_UNKNOWN) || (GatewayBindType != GATEWAY_BIND_TYPE_UNKNOWN));
			m_GatewayBindType = GatewayBindType;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetWritableRemoteAddressPointer"
		CSocketAddress	*GetWritableRemoteAddressPointer( void ) const
		{
		    DNASSERT( m_pRemoteMachineAddress != NULL );
		    return m_pRemoteMachineAddress;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetRemoteAddressPointer"
		const CSocketAddress	*GetRemoteAddressPointer( void ) const
		{
		    DNASSERT( m_pRemoteMachineAddress != NULL );
		    return m_pRemoteMachineAddress;
		}
		
		void	ChangeLoopbackAlias( const CSocketAddress *const pSocketAddress ) const;

		const CEndpointEnumKey	*GetEnumKey( void ) const { return &m_EnumKey; }
		void	SetEnumKey( const UINT_PTR uKey ) { m_EnumKey.SetKey( uKey ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetLocalAdapterDP8Address"
		IDirectPlay8Address *GetLocalAdapterDP8Address( const SP_ADDRESS_TYPE AddressType ) const
		{
			DNASSERT( m_fInitialized != FALSE );
			DNASSERT( GetSocketPort() != NULL );
			return	GetSocketPort()->GetDP8BoundNetworkAddress( AddressType, GetGatewayBindType() );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::GetRemoteHostDP8Address"
		IDirectPlay8Address *GetRemoteHostDP8Address( void ) const
		{
			DNASSERT( m_fInitialized != FALSE );
			DNASSERT( m_pRemoteMachineAddress != NULL );
			return	m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
		}

		CSocketPort	*GetSocketPort( void ) const { return m_pSocketPort; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetSocketPort"
		void		SetSocketPort( CSocketPort *const pSocketPort )
		{
			DNASSERT( ( m_pSocketPort == NULL ) || ( pSocketPort == NULL ) );
			m_pSocketPort = pSocketPort;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetCommandParametersGatewayBindType"
		void	SetCommandParametersGatewayBindType( GATEWAY_BIND_TYPE GatewayBindType )
		{
			DNASSERT( GetCommandParameters() != NULL );
			GetCommandParameters()->GatewayBindType = GatewayBindType;
		}

		void	MungeProxiedAddress( const CSocketPort * const pSocketPort,
									IDirectPlay8Address *const pHostAddress,
									const BOOL fEnum );

		HRESULT	CopyConnectData( const SPCONNECTDATA *const pConnectData );
		static	void	ConnectJobCallback( THREAD_POOL_JOB *const pJobHeader );
		static	void	CancelConnectJobCallback( THREAD_POOL_JOB *const pJobHeader );
		HRESULT	CompleteConnect( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::CleanupConnect"
		void	CleanupConnect( void )
		{
			DNASSERT( GetCommandParameters() != NULL );

			DNASSERT( GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost != NULL );
			IDirectPlay8Address_Release( GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost );

			DNASSERT( GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo != NULL );
			IDirectPlay8Address_Release( GetCommandParameters()->PendingCommandData.ConnectData.pAddressDeviceInfo );
		}

		BOOL	ConnectHasBeenSignalled( void ) const { return m_fConnectSignalled; }
		void	SignalDisconnect( const HANDLE hOldEndpointHandle );
		HANDLE	GetDisconnectIndicationHandle( void ) const { return this->m_hDisconnectIndicationHandle; }
		void	SetDisconnectIndicationHandle( const HANDLE hDisconnectIndicationHandle )
		{
			DNASSERT( ( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE ) ||
					  ( hDisconnectIndicationHandle == INVALID_HANDLE_VALUE ) );
			m_hDisconnectIndicationHandle = hDisconnectIndicationHandle;
		}

		HRESULT	Disconnect( const HANDLE hOldEndpointHandle );
		void	StopEnumCommand( const HRESULT hCommandResult );

		HRESULT	CopyListenData( const SPLISTENDATA *const pListenData, IDirectPlay8Address *const pDeviceAddress );
		static	void	ListenJobCallback( THREAD_POOL_JOB *const pJobHeader );
		static	void	CancelListenJobCallback( THREAD_POOL_JOB *const pJobHeader );
		HRESULT	CompleteListen( void );

		HRESULT	CopyEnumQueryData( const SPENUMQUERYDATA *const pEnumQueryData );
		static	void	EnumQueryJobCallback( THREAD_POOL_JOB *const pJobHeader );			// delayed job callback
		static	void	CancelEnumQueryJobCallback( THREAD_POOL_JOB *const pJobHeader );	// cancel delayed job callback
		HRESULT	CompleteEnumQuery( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::CleanupEnumQuery"
		void	CleanupEnumQuery( void )
		{
			DNASSERT( GetCommandParameters() != NULL );

			DNASSERT( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost != NULL );
			IDirectPlay8Address_Release( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost );

			DNASSERT( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo != NULL );
			IDirectPlay8Address_Release( GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressDeviceInfo );
		}

		void	ProcessEnumData( SPRECEIVEDBUFFER *const pBuffer, const DWORD dwEnumKey, const CSocketAddress *const pReturnSocketAddress );
		void	ProcessEnumResponseData( SPRECEIVEDBUFFER *const pBuffer,
										 const CSocketAddress *const pReturnSocketAddress,
										 const UINT_PTR uRTTIndex );
		void	ProcessUserData( CReadIOData *const pReadData );
		void	ProcessUserDataOnListen( CReadIOData *const pReadData, const CSocketAddress *const pSocketAddress );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SendUserData"
		void	SendUserData( CWriteIOData *const pWriteData )
		{
			DNASSERT( ( m_State == ENDPOINT_STATE_CONNECT_CONNECTED ) );
			DNASSERT( GetSocketPort() != NULL );
			DNASSERT( pWriteData->SocketPort() == NULL );

			GetSocketPort()->SendUserData( pWriteData );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SendEnumResponseData"
		void	SendEnumResponseData( CWriteIOData *const pWriteData, const UINT_PTR uEnumKey )
		{
			DNASSERT( GetSocketPort() != NULL );
			GetSocketPort()->SendEnumResponseData( pWriteData, uEnumKey );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SendProxiedEnumData"
		void	SendProxiedEnumData( CWriteIOData *const pWriteData, const CSocketAddress *const pReturnAddress, const UINT_PTR uOldEnumKey )
		{
			DNASSERT( pWriteData != NULL );
			DNASSERT( pReturnAddress != NULL );

			DNASSERT( m_State == ENDPOINT_STATE_LISTEN );
			DNASSERT( GetSocketPort() != NULL );

			GetSocketPort()->SendProxiedEnumData( pWriteData, pReturnAddress, uOldEnumKey );
		}

		void	RemoveFromMultiplexList(void)				{ m_blMultiplex.RemoveFromList(); };				// requires SPData LockSocketPortData() lock

		void	AddToSocketPortList( CBilink * pBilink)		{ m_blSocketPortList.InsertBefore( pBilink ); };	// requires SPData LockSocketPortData() lock
		void	RemoveFromSocketPortList(void)				{ m_blSocketPortList.RemoveFromList(); };			// requires SPData LockSocketPortData() lock

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::EndpointFromSocketPortListBilink"
		static	CEndpoint	*EndpointFromSocketPortListBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			return	reinterpret_cast<CEndpoint*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CEndpoint, m_blSocketPortList ) ] );
		}


		//
		//	Thread count references
		//
		DWORD	AddRefThreadCount( void )
		{
			return( ++m_dwThreadCount );
		}

		DWORD	DecRefThreadCount( void )
		{
			return( --m_dwThreadCount );
		}


		ENDPOINT_COMMAND_PARAMETERS	*GetCommandParameters( void ) const { return m_pCommandParameters; }


		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::IncNumReceives"
		void	IncNumReceives( void )
		{
			//
			// Assume the lock is held.
			//
			this->m_dwNumReceives++;

			//
			// Make sure it hasn't wrapped back to 0.
			//
			if ( this->m_dwNumReceives == 0 )
			{
				DPFX(DPFPREP, 1, "Endpoint 0x%p number of receives wrapped, will be off by one from now on.",
					this);

				this->m_dwNumReceives++;
			}
		}

		DWORD	GetNumReceives( void ) { return this->m_dwNumReceives; }


		//
		// UI functions
		//
		virtual	HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool ) = 0;
		virtual	void	StopSettingsDialog( const HWND hDlg ) = 0;
		virtual	void	SettingsDialogComplete( const HRESULT hr ) = 0;
		HWND	GetActiveDialogHandle( void ) const { return m_hActiveSettingsDialog; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetActiveDialogHandle"
		void	SetActiveDialogHandle( const HWND hDialog )
		{
			DNASSERT( ( GetActiveDialogHandle() == NULL ) ||
					  ( hDialog == NULL ) );
			m_hActiveSettingsDialog = hDialog;
		}

		//
		// pool functions
		//
		virtual	BOOL	PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pContext ) = 0;
		virtual	BOOL	PoolInitFunction( ENDPOINT_POOL_CONTEXT *pContext ) = 0;
		virtual	void	PoolReleaseFunction( void ) = 0;
		virtual	void	PoolDeallocFunction( void ) = 0;

	protected:
		volatile	ENDPOINT_STATE		m_State;				// endpoint state
		volatile	BOOL				m_fConnectSignalled;	// Boolean indicating whether we've indicated a connection on this endpoint

		ENDPOINT_TYPE		m_EndpointType;						// type of endpoint
		CSocketAddress		*m_pRemoteMachineAddress;			// pointer to address of remote machine

		CSPData				*m_pSPData;							// pointer to SPData
		CSocketPort			*m_pSocketPort;						// pointer to associated socket port
		GATEWAY_BIND_TYPE	m_GatewayBindType;					// type of binding made (whether there should be a port mapping on the gateway or not)

		CEndpointEnumKey	m_EnumKey;							// key used for enums
		void				*m_pUserEndpointContext;			// context passed back with endpoint handles

		BOOL				m_fListenStatusNeedsToBeIndicated;
		
		CBilink				m_blMultiplex;						// bilink in multiplexed command list,  protected by SPData LockSocketPortData() lock
		CBilink				m_blSocketPortList;					// bilink in socketport list (not hash),  protected by SPData LockSocketPortData() lock

		DWORD				m_dwNumReceives;					// how many packets have been received by this CONNECT/CONNECT_ON_LISTEN endpoint, or 0 if none



		HRESULT	Initialize( void );
		void	Deinitialize( void );
		
		BOOL	CommandPending( void ) const { return ( GetCommandParameters() != NULL ); }
		void	SetPendingCommandResult( const HRESULT hr ) { m_hPendingCommandResult = hr; }
		HRESULT	PendingCommandResult( void ) const { return m_hPendingCommandResult; }
		void	CompletePendingCommand( const HRESULT hCommandResult );

		HRESULT	SignalConnect( SPIE_CONNECT *const pConnectData );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CEndpoint::SetCommandParameters"
		void	SetCommandParameters( ENDPOINT_COMMAND_PARAMETERS *const pCommandParameters )
		{
			DNASSERT( ( GetCommandParameters() == NULL ) ||
					  ( pCommandParameters == NULL ) );
			m_pCommandParameters = pCommandParameters;
		}

		void SetEndpointID( const DWORD dwEndpointID )	{ m_dwEndpointID = dwEndpointID; }
		DWORD GetEndpointID( void ) const		{ return m_dwEndpointID; }


		DEBUG_ONLY(	BOOL	m_fInitialized );
		DEBUG_ONLY( BOOL	m_fEndpointOpen );

	private:
		DNCRITICAL_SECTION	m_Lock;					// critical section
		HANDLE				m_Handle;				// endpoint handle returned when queried
		volatile LONG		m_lCommandRefCount;		// Command ref count.  When this goes to
													// zero, the endpoint is unbound from
													// the CSocketPort
		DWORD volatile		m_dwThreadCount;		// Number of (ENUM) threads using endpoint
		DWORD				m_dwEndpointID;			// unique identifier for this endpoint


		HWND						m_hActiveSettingsDialog;		// handle of active settings dialog
		ENDPOINT_COMMAND_PARAMETERS	*m_pCommandParameters;			// pointer to command parameters
		HRESULT						m_hPendingCommandResult;		// result for pending command
		HANDLE						m_hDisconnectIndicationHandle;	// handle to be returned when disconnect is finally signalled

		CCommandData				*m_pActiveCommandData;	// pointer to command data that's embedded in the command parameters
															// We don't know where in the union the command data really is, and
															// finding it programmatically each time would bloat the code.

		static void		EnumCompleteWrapper( const HRESULT hCompletionCode, void *const pContext );	
		static void		EnumTimerCallback( void *const pContext, DN_TIME * const pRetryInterval );
		void	EnumComplete( const HRESULT hCompletionCode );	
		void	CleanUpCommand( void );

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CEndpoint( const CEndpoint & );
		CEndpoint& operator=( const CEndpoint & );
};

#undef DPF_MODNAME

#endif	// __ENDPOINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\iodata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IOData.cpp
 *  Content:	Functions for IO structures
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 *	02/11/2000	jtk		Derived from IODAta.h
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// ------------------------------
// CIOData::CIOData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIOData::CIOData"

CIOData::CIOData():
	m_pSocketPort( NULL )
{
	memset( &m_Overlap, 0x00, sizeof( m_Overlap ) );
	memset( &m_Flags, 0x00, sizeof( m_Flags ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIOData::~CIOData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIOData::~CIOData"

CIOData::~CIOData()
{
	DNASSERT( SocketPort() == NULL );
#ifdef WIN95
	DNASSERT( OverlapEvent() == NULL );
	DNASSERT( Win9xOperationPending() == FALSE );
#endif
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::CReadIOData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::CReadIOData"

CReadIOData::CReadIOData():
    m_iSocketAddressSize( 0 ),
    m_pSourceSocketAddress( NULL ),
	m_ReceiveWSAReturn( ERROR_SUCCESS ),
    m_dwOverlappedBytesReceived( 0 ),
	m_dwBytesRead( 0 ),
	m_dwReadFlags( 0 ),
	m_lRefCount( 0 ),
	m_pThreadPool( NULL )
{
	m_Sig[0] = 'R';
	m_Sig[1] = 'I';
	m_Sig[2] = 'O';
	m_Sig[3] = 'D';
	
	m_OutstandingReadListLinkage.Initialize();
	DEBUG_ONLY( memset( &m_ReceivedData, 0x00, sizeof( m_ReceivedData ) ) );
	DEBUG_ONLY( m_fRetainedByHigherLayer = FALSE );
	DNASSERT( IsReadOperation() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::~CReadIOData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::~CReadIOData"

CReadIOData::~CReadIOData()
{
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_iSocketAddressSize == 0 );
	DNASSERT( m_pSourceSocketAddress == NULL );
	
	//
	// don't bother looking at the WSA error or bytes received
	//

	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_pThreadPool == NULL );
	DEBUG_ONLY( DNASSERT( m_fRetainedByHigherLayer ==  FALSE ) );
	DNASSERT( IsReadOperation() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Alloc - called when new CReadIOData is allocated
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Alloc"

BOOL	CReadIOData::ReadIOData_Alloc( READ_IO_DATA_POOL_CONTEXT *const pContext )
{
	BOOL			fReturn;
	CSocketAddress	*pSocketAddress;


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	fReturn = TRUE;
	pSocketAddress = NULL;

	DNASSERT( IsReadOperation() != FALSE );
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_iSocketAddressSize == 0 );
	DNASSERT( m_pSourceSocketAddress == NULL );
	DEBUG_ONLY( DNASSERT( m_fRetainedByHigherLayer == FALSE ) );

	//
	// attempt to get a socket address for this item
	//
	m_AddressType = pContext->SPType;
	switch ( pContext->SPType )
	{
		case TYPE_IP:
		{
			pSocketAddress = CreateIPAddress();
			break;
		}

		case TYPE_IPX:
		{
			pSocketAddress = CreateIPXAddress();
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	if ( pSocketAddress == NULL )
	{
		DPFX(DPFPREP,  0, "Problem allocating a new socket address when creating ReadIOData pool item" );
		fReturn = FALSE;
		goto Exit;
	}

	pSocketAddress->SetAddressType( SP_ADDRESS_TYPE_READ_HOST );
	m_pSourceSocketAddress = pSocketAddress;
	m_iSocketAddressSize = pSocketAddress->GetAddressSize();

#ifdef WIN95
   	DNASSERT( OverlapEvent() == NULL );
#endif
	DNASSERT( m_pThreadPool == NULL );
	DNASSERT( m_lRefCount == 0 );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Get - called when new CReadIOData is removed from pool
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Get"

void	CReadIOData::ReadIOData_Get( READ_IO_DATA_POOL_CONTEXT *const pContext )
{
	DNASSERT( pContext != NULL );

	DNASSERT( IsReadOperation() != FALSE );
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_pSourceSocketAddress != NULL );
	DNASSERT( m_iSocketAddressSize == m_pSourceSocketAddress->GetAddressSize() );
	DNASSERT( SocketPort() == NULL );
#ifdef WIN95
	DNASSERT( Win9xOperationPending() == FALSE );
#endif

	DNASSERT( pContext->pThreadPool != NULL );
	DEBUG_ONLY( DNASSERT( m_fRetainedByHigherLayer == FALSE ) );

	m_pSourceSocketAddress->Reset();
	m_pThreadPool = pContext->pThreadPool;
#ifdef WIN95
	SetOverlapEvent( pContext->pThreadPool->GetWinsock2ReceiveCompleteEvent() );
#endif

	DNASSERT( m_lRefCount == 0 );
	
	//
	// Initialize internal SPRECEIVEDDATA.  When data is received, it's possible
	// that the pointers in the SPRECEIVEDDATA block were manipulated.  Reset
	// them to reflect that the entire buffer is available.
	//
	ZeroMemory( &m_SPReceivedBuffer, sizeof( m_SPReceivedBuffer ) );
	m_SPReceivedBuffer.BufferDesc.pBufferData = m_ReceivedData;
	m_SPReceivedBuffer.BufferDesc.dwBufferSize = sizeof( m_ReceivedData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Release - called when CReadIOData is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Release"

void	CReadIOData::ReadIOData_Release( void )
{
	DNASSERT( IsReadOperation() != FALSE );
	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_pSourceSocketAddress != NULL );
#ifdef WIN95
	DNASSERT( Win9xOperationPending() == FALSE );
	SetOverlapEvent( NULL );
#endif
	DEBUG_ONLY( DNASSERT( m_fRetainedByHigherLayer == FALSE ) );

	DNASSERT( m_dwOverlappedBytesReceived == 0 );
	m_pThreadPool = NULL;
	SetSocketPort( NULL );

	DEBUG_ONLY( memset( &m_ReceivedData, 0x00, sizeof( m_ReceivedData ) ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReadIOData_Dealloc - called when CReadIOData is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReadIOData_Dealloc"

void	CReadIOData::ReadIOData_Dealloc( void )
{
	DNASSERT( IsReadOperation() != FALSE );
	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_pSourceSocketAddress != NULL );
	DEBUG_ONLY( DNASSERT( m_fRetainedByHigherLayer == FALSE ) );
	switch ( m_AddressType )
	{
		case TYPE_IP:
		{
			ReturnIPAddress( static_cast<CIPAddress*>( m_pSourceSocketAddress ) );
			break;
		}

		case TYPE_IPX:
		{
			ReturnIPXAddress( static_cast<CIPXAddress*>( m_pSourceSocketAddress ) );
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	m_pSourceSocketAddress = NULL;
	m_iSocketAddressSize = 0;
	m_AddressType = TYPE_UNKNOWN;

	DNASSERT( m_OutstandingReadListLinkage.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CReadIOData::ReturnSelfToPool - return this item to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CReadIOData::ReturnSelfToPool"

void	CReadIOData::ReturnSelfToPool( void )
{
	CThreadPool	*pThreadPool;


	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_pThreadPool != NULL );

	pThreadPool = m_pThreadPool;
	pThreadPool->ReturnReadIOData( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::CWriteIOData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::CWriteIOData"

CWriteIOData::CWriteIOData():
	m_pNext( NULL ),
	m_pDestinationSocketAddress( NULL ),
	m_pBuffers( NULL ),
	m_uBufferCount( 0 ),
	m_pCommand( NULL ),
	m_SendCompleteAction( SEND_COMPLETE_ACTION_UNKNOWN ),
#ifdef WIN95
	m_Win9xSendHResult( DPN_OK ),
#endif
	m_dwOverlappedBytesSent( 0 ),
	m_dwBytesSent( 0 ),
	m_pProxiedEnumReceiveBuffer( NULL )
{
	m_Sig[0] = 'W';
	m_Sig[1] = 'I';
	m_Sig[2] = 'O';
	m_Sig[3] = 'D';
	
	m_OutstandingWriteListLinkage.Initialize();
	memset( &m_PrependBuffer, 0x00, sizeof( m_PrependBuffer ) );
	SetWriteOperation();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::~CWriteIOData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::~CWriteIOData"

CWriteIOData::~CWriteIOData()
{
	DNASSERT( m_pNext == NULL );
	DNASSERT( m_pDestinationSocketAddress == NULL );
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );
	DNASSERT( m_pCommand == NULL );
	DNASSERT( m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_pProxiedEnumReceiveBuffer == NULL );
	DNASSERT( IsWriteOperation() != FALSE );

	//
	// don't bother checking the send hResult or the count of byes sent
	//
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::WriteIOData_Alloc - called when new CWriteIOData is allocated
//
// Entry:		Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = allocation succeeded
//				FALSE = allocation failed
//
// Note:	We always want a command structure associated with CWriteIOData
//			so we don't need to grab a new command from the command pool each
//			time a CWriteIOData entry is removed from its pool.  This is done
//			for speed.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::WriteIOData_Alloc"

BOOL	CWriteIOData::WriteIOData_Alloc( WRITE_IO_DATA_POOL_CONTEXT *const pContext )
{
	BOOL	fReturn;
	CCommandData	*pCommand;


	DNASSERT( IsWriteOperation() != FALSE );
	DNASSERT( pContext != NULL );
	DNASSERT( m_pNext == NULL );
	DNASSERT( m_pDestinationSocketAddress == NULL );
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );
	DNASSERT( m_pCommand == NULL );
	DNASSERT( m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );

	//
	// initialize
	//
	fReturn = TRUE;

	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		DPFX(DPFPREP,  0, "Could not get command when allocating new CWriteIOData!" );
		fReturn = FALSE;
		goto Exit;
	}

	//
	// associate this command with the WriteData, clear the command descriptor
	// because the command isn't really being used yet, and it'll
	// cause an ASSERT when it's removed from the WriteIOData pool.
	//
	m_pCommand = pCommand;
#ifdef WIN95
	DNASSERT( OverlapEvent() == NULL );
#endif

	DPFX(DPFPREP, 8, "Write I/O data 0x%p created with command 0x%p.",
		this, pCommand);

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::WriteIOData_Get - called when new CWriteIOData is removed from pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::WriteIOData_Get"

void	CWriteIOData::WriteIOData_Get( WRITE_IO_DATA_POOL_CONTEXT *const pContext )
{
	DNASSERT( pContext != NULL );

	DNASSERT( IsWriteOperation() != FALSE );
	DNASSERT( m_pNext == NULL );
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );

	DNASSERT( m_pCommand != NULL );
	m_pCommand->SetDescriptor();

	DNASSERT( m_pCommand->GetDescriptor() != NULL_DESCRIPTOR );
	DNASSERT( m_pCommand->GetUserContext() == NULL );
	
	DNASSERT( m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	DNASSERT( m_pDestinationSocketAddress == NULL );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
	DNASSERT( SocketPort() == NULL );
#ifdef WIN95
	DNASSERT( Win9xOperationPending() == FALSE );
#endif

	DNASSERT( m_PrependBuffer.GenericHeader.bSPLeadByte == SP_HEADER_LEAD_BYTE );
#ifdef WIN95
	SetOverlapEvent( pContext->hOverlapEvent );
#endif
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::WriteIOData_Release - called when CWriteIOData is returned to pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::WriteIOData_Release"

void	CWriteIOData::WriteIOData_Release( void )
{
	DNASSERT( m_pCommand != NULL );
	m_pCommand->Reset();

	DNASSERT( IsWriteOperation() != FALSE );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
#ifdef WIN95
	DNASSERT( Win9xOperationPending() == FALSE );
	SetOverlapEvent( NULL );
#endif

	m_pBuffers = NULL;
	m_uBufferCount = 0;
	m_pDestinationSocketAddress = NULL;
	m_pNext = NULL;
	SetSocketPort( NULL );
	m_SendCompleteAction = SEND_COMPLETE_ACTION_UNKNOWN;

	DEBUG_ONLY( memset( &m_PrependBuffer, 0x00, sizeof( m_PrependBuffer ) ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CWriteIOData::WriteIOData_Dealloc - called when new CWriteIOData is deallocated
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CWriteIOData::WriteIOData_Dealloc"

void	CWriteIOData::WriteIOData_Dealloc( void )
{
	DNASSERT( m_pCommand != NULL );
	m_pCommand->DecRef();
	m_pCommand = NULL;

	DNASSERT( IsWriteOperation() != FALSE );
	DNASSERT( m_OutstandingWriteListLinkage.IsEmpty() != FALSE );

	DNASSERT( m_pDestinationSocketAddress == NULL );
	DNASSERT( m_pBuffers == NULL );
	DNASSERT( m_uBufferCount == 0 );
	DNASSERT( m_pCommand == NULL );
#ifdef WIN95
	SetOverlapEvent( NULL );
#endif
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\handletable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		HandleTable.cpp
 *  Content:	Handle table
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/28/2000	jtk		Copied from Modem service provider
 ***************************************************************************/

#include "dnwsocki.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	HANDLE_GROW_COUNT		32
#define	INVALID_HANDLE_INDEX	WORD_MAX

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	struct	_HANDLE_TABLE_ENTRY
{
	DWORD_PTR	dwHandleIndex;
	void		*pContext;
} HANDLE_TABLE_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::CHandleTable - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::CHandleTable"

CHandleTable::CHandleTable():
	m_AllocatedEntries( 0 ),
	m_EntriesInUse( 0 ),
	m_FreeIndex( INVALID_HANDLE_INDEX ),
	m_pEntries( NULL ),
	m_fLockInitialized( FALSE )
{
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::~CHandleTable - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::~CHandleTable"

CHandleTable::~CHandleTable()
{
	DNASSERT( m_AllocatedEntries == 0 );
	DNASSERT( m_EntriesInUse == 0 );
	DNASSERT( m_FreeIndex == INVALID_HANDLE_INDEX );
	DNASSERT( m_pEntries == NULL );
	DNASSERT( m_fLockInitialized == FALSE );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::Initialize - initialization function
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Initialize"

HRESULT	CHandleTable::Initialize( void )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );

	DNASSERT( m_fLockInitialized == FALSE );
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to initialize handle table lock!" );
		goto Failure;
	}
	m_fLockInitialized = TRUE;

	DEBUG_ONLY( m_fInitialized = TRUE );

Exit:
	return hr;

Failure:
	Deinitialize();	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::Deinitialize - deinitialization function
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Deinitialize"

void	CHandleTable::Deinitialize( void )
{
	DNASSERT( m_EntriesInUse == 0 );

	if ( m_fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		m_fLockInitialized = FALSE;
	}

	if ( m_pEntries != NULL )
	{
		DNFree( m_pEntries );
		m_pEntries = NULL;
	}
	
	m_AllocatedEntries = 0;
	m_FreeIndex = WORD_MAX;

	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::CreateHandle - create a handle
//
// Entry:		Pointer to handle destination
//				Pointer to handle context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::CreateHandle"

HRESULT	CHandleTable::CreateHandle( HANDLE *const pHandle, void *const pContext )
{
	HRESULT		hr;
	HANDLE		hReturn;
	DWORD_PTR	Index;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	DNASSERT( pHandle != NULL );
	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	hReturn = INVALID_HANDLE_VALUE;

	//
	// grow table if applicable
	//
	if ( m_EntriesInUse == m_AllocatedEntries )
	{
		hr = Grow();
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP,  0, "Failed to grow handle table!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}

	//
	// build a handle
	//
	DNASSERT( m_FreeIndex < INVALID_HANDLE_INDEX );
	DBG_CASSERT( sizeof( hReturn ) == sizeof( m_FreeIndex ) );
	hReturn = reinterpret_cast<HANDLE>( m_FreeIndex );
	
	DBG_CASSERT( sizeof( hReturn ) == sizeof( DWORD_PTR ) );
	hReturn = reinterpret_cast<HANDLE>( reinterpret_cast<DWORD_PTR>( hReturn ) | ( ( m_pEntries[ m_FreeIndex ].dwHandleIndex & WORD_MAX ) << 16 ) );
	
	//
	// adjust free handle list before setting handle context
	//
	DBG_CASSERT( sizeof( m_FreeIndex ) == sizeof( m_pEntries[ m_FreeIndex ].pContext ) );
	Index = m_FreeIndex;
	m_FreeIndex = reinterpret_cast<DWORD_PTR>( m_pEntries[ m_FreeIndex ].pContext );
	DNASSERT( m_FreeIndex <= INVALID_HANDLE_INDEX );
	
	m_pEntries[ Index ].pContext = pContext;

	m_EntriesInUse++;

	DNASSERT( hReturn != INVALID_HANDLE_VALUE );
	DNASSERT( hReturn != reinterpret_cast<HANDLE>( INVALID_HANDLE_INDEX ) );
	
	*pHandle = hReturn;
	DNASSERT( hr == DPN_OK );

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::InvalidateHandle - invalidate a handle
//
// Entry:		Handle
//
// Exit:		Boolean indicating whether the handle was invalidated in this
//				operation
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::InvalidateHandle"

BOOL	CHandleTable::InvalidateHandle( const HANDLE Handle )
{
	BOOL		fReturn;
	DWORD_PTR	Index;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	DBG_CASSERT( sizeof( Index ) == sizeof( Handle ) );
	DBG_CASSERT( sizeof( Handle ) == sizeof( DWORD_PTR ) );
	Index = reinterpret_cast<DWORD_PTR>( Handle ) & WORD_MAX;

	DBG_CASSERT( sizeof( Handle ) == sizeof( DWORD_PTR ) );
	if ( ( Index < m_AllocatedEntries ) &&
		 ( ( m_pEntries[ Index ].dwHandleIndex & WORD_MAX ) == ( ( reinterpret_cast<DWORD_PTR>( Handle ) >> 16 ) & WORD_MAX ) ) )
	{
		m_pEntries[ Index ].dwHandleIndex++;
		DBG_CASSERT( sizeof( void* ) == sizeof( m_FreeIndex ) );
		m_pEntries[ Index ].pContext = reinterpret_cast<void*>( m_FreeIndex );
		m_EntriesInUse--;
		m_FreeIndex = Index;
		fReturn = TRUE;
	}
	else
	{
		//
		// There are cases where an attempt can be made to close a handle
		// twice.  Ideally, that would be fixed, but for now, since it's benign,
		// I'm removing the assert.
		//
		//DNASSERT( Handle == INVALID_HANDLE_VALUE );
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::GetAssociatedData - get data associated with the handle
//
// Entry:		Handle
//
// Exit:		Associated data
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::GetAssociatedData"

void	*CHandleTable::GetAssociatedData( const HANDLE Handle ) const
{
	void		*pReturn;
	DWORD_PTR	Index;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	pReturn = NULL;
	DBG_CASSERT( sizeof( Handle ) == sizeof( DWORD_PTR ) );
	Index = reinterpret_cast<DWORD_PTR>( Handle ) & WORD_MAX;
	if ( ( Index < m_AllocatedEntries ) &&
		 ( ( m_pEntries[ Index ].dwHandleIndex & WORD_MAX ) == ( ( reinterpret_cast<DWORD_PTR>( Handle ) >> 16 ) & WORD_MAX ) ) )
	{
		pReturn = m_pEntries[ Index ].pContext;
	}

	DNASSERT( pReturn != INVALID_HANDLE_VALUE );
	DNASSERT( pReturn != reinterpret_cast<HANDLE>( INVALID_HANDLE_INDEX ) );
	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CHandleTable::Grow - grow handle table
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Grow"

HRESULT	CHandleTable::Grow( void )
{
	HRESULT	hr;
	void	*pTemp;


	hr = DPN_OK;
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	DNASSERT( m_FreeIndex == WORD_MAX );
	
	if ( m_pEntries == NULL )
	{
		pTemp = DNMalloc( sizeof( *m_pEntries ) * ( m_AllocatedEntries + HANDLE_GROW_COUNT ) );
	}
	else
	{
		pTemp = DNRealloc( m_pEntries, sizeof( *m_pEntries ) * ( m_AllocatedEntries + HANDLE_GROW_COUNT ) );
	}
	
	if ( pTemp == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Failed to grow handle table!" );
	}
	else
	{
		DWORD_PTR	Index;


		//
		// Table was enlarged, link all of the entires at the end of the list
		// into the free list.  Make sure the free list is properly terminated.
		//
		m_pEntries = static_cast<HANDLE_TABLE_ENTRY*>( pTemp );
		Index = m_AllocatedEntries;
		m_FreeIndex = m_AllocatedEntries;
		
		m_AllocatedEntries += HANDLE_GROW_COUNT;
		while ( Index < m_AllocatedEntries )
		{
			DBG_CASSERT( sizeof( Index ) == sizeof( void* ) );
			m_pEntries[ Index ].dwHandleIndex = 0;
			m_pEntries[ Index ].pContext = reinterpret_cast<void*>( Index + 1 );
			Index++;
		}
		
		m_pEntries[ m_AllocatedEntries - 1 ].pContext = reinterpret_cast<void*>( WORD_MAX );
	}

	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\handletable.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		HandleTable.h
 *  Content:	DNSerial communications handle table
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/15/2000	jtk		Created
 ***************************************************************************/

#ifndef __HANDLE_TABLE_H__
#define __HANDLE_TABLE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward srtucture references
//
typedef	struct	_HANDLE_TABLE_ENTRY	HANDLE_TABLE_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CHandleTable
{
	public:
		CHandleTable();
		virtual	~CHandleTable();

		#undef DPF_MODNAME
		#define DPF_MODNAME "CHandleTable::Lock"
		void	Lock( void )
		{
			DNASSERT( m_fInitialized != FALSE );
			DNEnterCriticalSection( &m_Lock );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CHandleTable::Unlock"
		void	Unlock( void )
		{
			DNASSERT( m_fInitialized != FALSE );
			DNLeaveCriticalSection( &m_Lock );
		}

		HRESULT	Initialize( void );
		void	Deinitialize( void );

		HRESULT	CreateHandle( HANDLE *const pHandle, void *const pContext );
		BOOL	InvalidateHandle( const HANDLE Handle );
		void	*GetAssociatedData( const HANDLE Handle ) const;

	private:
		DNCRITICAL_SECTION	m_Lock;	   		// critical section
		
		DWORD_PTR	m_AllocatedEntries;
		DWORD_PTR	m_EntriesInUse;
		DWORD_PTR	m_FreeIndex;
		HANDLE_TABLE_ENTRY	*m_pEntries;

		//
		// initialization state booleans
		//
		BOOL	m_fLockInitialized;
		
		HRESULT	Grow( void );
		
		
		DEBUG_ONLY(	BOOL	m_fInitialized );
		
		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CHandleTable( const CHandleTable & );
		CHandleTable& operator=( const CHandleTable & );
};

#undef DPF_MODNAME

#endif	// __HANDLE_TABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\ipaddress.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPAddress.h
 *  Content:	IP address class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __IP_ADDRESS_H__
#define __IP_ADDRESS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// external variables
//
extern const WCHAR	g_IPBroadcastAddress[];
extern const DWORD	g_dwIPBroadcastAddressSize;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CIPAddress : public CSocketAddress
{
	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPAddress::CIPAddress"
		CIPAddress()
		{
			DBG_CASSERT( sizeof( &m_SocketAddress.IPSocketAddress ) == sizeof( SOCKADDR* ) );
			m_iSocketAddressSize = sizeof( m_SocketAddress.IPSocketAddress );
			m_SocketAddress.IPSocketAddress.sin_family = AF_INET;
			m_iSocketProtocol = IPPROTO_UDP;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPAddress::~CIPAddress"
		~CIPAddress()
		{
			DNASSERT( m_iSocketAddressSize == sizeof( m_SocketAddress.IPSocketAddress ) );
			DNASSERT( m_SocketAddress.IPSocketAddress.sin_family == AF_INET );
			DNASSERT( m_iSocketProtocol == IPPROTO_UDP );
		}

		void	InitializeWithBroadcastAddress( void );
		void	SetAddressFromSOCKADDR( const SOCKADDR &Address, const INT_PTR iAddressSize );

		HRESULT	SocketAddressFromDP8Address( IDirectPlay8Address *const pDP8Address,
											 const SP_ADDRESS_TYPE AddressType );

		IDirectPlay8Address	*DP8AddressFromSocketAddress( void ) const;

		INT_PTR	CompareFunction( const CSocketAddress *const pOtherAddress ) const;
		INT_PTR	HashFunction( const INT_PTR HashBitcount ) const;
		INT_PTR	CompareToBaseAddress( const SOCKADDR *const pBaseAddress ) const;

		HRESULT	EnumAdapters( SPENUMADAPTERSDATA *const pEnumData ) const;

		void	GuidFromInternalAddressWithoutPort( GUID &OutputGuid ) const;
		
		BOOL	IsUndefinedHostAddress( void ) const;
		void	ChangeLoopBackToLocalAddress( const CSocketAddress *const pOtherSocketAddress );
		
		WORD	GetPort( void ) const { return m_SocketAddress.IPSocketAddress.sin_port; }
		void	SetPort( const WORD wPort ) { m_SocketAddress.IPSocketAddress.sin_port = wPort; }

		//
		// functions to create default addresses
		//
		IDirectPlay8Address *CreateBroadcastAddress( void );
		IDirectPlay8Address *CreateListenAddress( void );
		IDirectPlay8Address *CreateGenericAddress( void );

	protected:
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPAddress::AddressFromGuid"
		virtual void	AddressFromGuid( const GUID &InputGuid, SOCKADDR &SocketAddress ) const
		{
			DBG_CASSERT( sizeof( InputGuid ) == sizeof( SocketAddress ) );
			DecryptGuid( &InputGuid,
						 reinterpret_cast<GUID*>( &SocketAddress ),
						 &g_IPSPEncryptionGuid );
		}

	private:
		void	CopyInternalSocketAddressWithoutPort( SOCKADDR &AddressDestination ) const;

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPAddress::GuidFromAddress"
		static void	GuidFromAddress( GUID &OutputGuid, const SOCKADDR &SocketAddress )
		{
			const SOCKADDR_IN	*pSocketAddress = reinterpret_cast<const SOCKADDR_IN*>( &SocketAddress );


		    DBG_CASSERT( sizeof( OutputGuid ) == sizeof( SocketAddress ) );
			memcpy( &OutputGuid, &SocketAddress, ( sizeof( OutputGuid ) - sizeof( pSocketAddress->sin_zero ) ) );
			memset( &( reinterpret_cast<BYTE*>( &OutputGuid )[ OFFSETOF( SOCKADDR_IN, sin_zero ) ] ), 0, sizeof( pSocketAddress->sin_zero ) );
			DNASSERT( SinZeroIsZero( reinterpret_cast<SOCKADDR_IN*>( &OutputGuid ) ) );
			EncryptGuid( &OutputGuid, &OutputGuid, &g_IPSPEncryptionGuid );
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPAddress::SinZeroIsZero"
		static BOOL	SinZeroIsZero( const SOCKADDR_IN *const pSocketAddress )
		{
			if ( ( ( reinterpret_cast<const DWORD*>( &pSocketAddress->sin_zero[ 0 ] )[ 0 ] == 0 ) &&
				   ( reinterpret_cast<const DWORD*>( &pSocketAddress->sin_zero[ 0 ] )[ 1 ] == 0 ) ) != FALSE )
			{
				return	TRUE;
			}

			return	FALSE;
		}
		
		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CIPAddress( const CIPAddress & );
		CIPAddress& operator=( const CIPAddress & );
};

#undef DPF_MODNAME

#endif	// __IP_ADDRESS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\ipendpt.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPEndpoint.cpp
 *  Content:	IP endpoint class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

static const TCHAR	g_PortSeparator = TEXT(':');
static const TCHAR	g_NULLToken = TEXT('\0');

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::CIPEndpoint - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::CIPEndpoint"

CIPEndpoint::CIPEndpoint():
	m_pOwningPool( NULL )
{
	m_Sig[0] = 'I';
	m_Sig[1] = 'P';
	m_Sig[2] = 'E';
	m_Sig[3] = 'P';
	
	m_pRemoteMachineAddress = &m_IPAddress;
	memset( m_TempHostName, 0x00, sizeof( m_TempHostName ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::~CIPEndpoint - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::~CIPEndpoint"

CIPEndpoint::~CIPEndpoint()
{
	DEBUG_ONLY( m_pRemoteMachineAddress = NULL );
	DNASSERT( m_pOwningPool == NULL );
	DNASSERT( GetActiveDialogHandle() == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::ShowSettingsDialog - show dialog for settings
//
// Entry:		Pointer to thread pool
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::ShowSettingsDialog"

HRESULT	CIPEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
{
	HRESULT	hr;


	DNASSERT( pThreadPool != NULL );
	DNASSERT( GetActiveDialogHandle() == NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	AddRef();
	hr = pThreadPool->SpawnDialogThread( DisplayIPHostNameSettingsDialog, this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to start IP hostname dialog!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:	
	return	hr;

Failure:	
	DecRef();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::SettingsDialogComplete - dialog has completed
//
// Entry:		Error code for dialog
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::SettingsDialogComplete"

void	CIPEndpoint::SettingsDialogComplete( const HRESULT hDialogResult )
{
	HRESULT					hr;
	IDirectPlay8Address		*pBaseAddress;
	WCHAR					WCharHostName[ sizeof( m_TempHostName ) + 1 ];
	DWORD					dwWCharHostNameSize;
	TCHAR					*pPortString;
	DWORD					dwPort;
	BOOL					fPortFound;


	//
	// initialize
	//
	hr = hDialogResult;
	pBaseAddress = NULL;
	pPortString = NULL;
	dwPort = 0;
	fPortFound = FALSE;

	//
	// since the dialog is exiting, clear our handle to the dialog
	//
	SetActiveDialogHandle( NULL );

	//
	// dialog failed, fail the user's command
	//
	if ( hr != DPN_OK )
	{
		if ( hr != DPNERR_USERCANCEL)
		{
			DPFX(DPFPREP, 0, "Failing endpoint hostname dialog!" );
			DisplayDNError( 0, hr );

		}

		goto Failure;
	}

	//
	// The dialog completed OK, rebuild remote address and complete command
	//

#ifdef _UNICODE
	DPFX(DPFPREP, 1, "Dialog completed successfully, got host name \"%S\".", m_TempHostName);
#else // ! _UNICODE
	DPFX(DPFPREP, 1, "Dialog completed successfully, got host name \"%s\".", m_TempHostName);
#endif // ! _UNICODE

	//
	// get the base DNADDRESS
	//
	pBaseAddress = m_pRemoteMachineAddress->DP8AddressFromSocketAddress();
	if ( pBaseAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to get base address when completing IP hostname dialog!" );
		goto Failure;
	}

	//
	// If there is a port separator in the string, replace it with a NULL
	// to terminate the hostname and advance the port start index past the
	// separator.  Only indicate the presence of a port if the character
	// following the port separator is numeric.
	//
	pPortString = m_TempHostName;
	while ( ( *pPortString != g_NULLToken ) &&
			( fPortFound == FALSE ) )
	{
		TCHAR	*pTemp;

		pTemp = pPortString;
		pPortString = CharNext( pPortString );

		if ( *pTemp == g_PortSeparator )
		{
			*pTemp = g_NULLToken;
			fPortFound = TRUE;
		}
	}

	//
	// If a port was found, attempt to convert it from text.  If the resulting
	// port is zero, treat as if the port wasn't found.
	//
	if ( fPortFound != FALSE )
	{
		TCHAR		*pPortParser;

		pPortParser = pPortString;
		
		while ( *pPortParser != g_NULLToken )
		{
			if ( ( *pPortParser < TEXT('0') ) ||
				 ( *pPortParser > TEXT('9') ) )
			{
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP, 0, "Invalid characters when parsing port from UI!" );
				goto Failure;
			}

			dwPort *= 10;
			dwPort += *pPortParser - '0';

			if ( dwPort > WORD_MAX )
			{
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP, 0, "Invalid value when parsing port from UI!" );
				goto Failure;
			}

			pPortParser = CharNext( pPortParser );
		}

		DNASSERT( dwPort < WORD_MAX );

		if ( dwPort == 0 )
		{
			fPortFound = FALSE;
		}
	}

	//
	// Add the new 'HOSTNAME' parameter to the address.  If the hostname is blank
	// and this is an enum, copy the broadcast hostname.  If the hostname is blank
	// on a connect, fail!
	//
	if ( m_TempHostName[ 0 ] == g_NULLToken )
	{
		if ( GetType() == ENDPOINT_TYPE_ENUM )
		{
			//
			// PREfast doesn't like unvalidated sizes for memcpys, so just double
			// check that it's reasonable.
			//
			if ( g_dwIPBroadcastAddressSize < sizeof( WCharHostName ) )
			{
				memcpy( WCharHostName, g_IPBroadcastAddress, g_dwIPBroadcastAddressSize );
				dwWCharHostNameSize = g_dwIPBroadcastAddressSize;
			}
			else
			{
				DNASSERT( FALSE );
				hr = DPNERR_GENERIC;
				goto Failure;
			}
		}
		else
		{
			hr = DPNERR_ADDRESSING;
			DNASSERT( GetType() == ENDPOINT_TYPE_CONNECT );
			DPFX(DPFPREP, 0, "No hostname in dialog!" );
			goto Failure;
		}
	}
	else
	{
#ifdef UNICODE
		dwWCharHostNameSize = (wcslen(m_TempHostName) + 1) * sizeof(WCHAR);
		memcpy( WCharHostName, m_TempHostName, dwWCharHostNameSize );
#else
		dwWCharHostNameSize = LENGTHOF( WCharHostName );
		hr = STR_AnsiToWide( m_TempHostName, -1, WCharHostName, &dwWCharHostNameSize );
		DNASSERT( hr == DPN_OK );
		dwWCharHostNameSize *= sizeof( WCHAR );
#endif
	}

	hr = IDirectPlay8Address_AddComponent( pBaseAddress, DPNA_KEY_HOSTNAME, WCharHostName, dwWCharHostNameSize, DPNA_DATATYPE_STRING );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to add hostname to address!" );
		goto Failure;
	}

	//
	// if there was a specified port, add it to the address
	//
	if ( fPortFound != FALSE )
	{
		hr = IDirectPlay8Address_AddComponent( pBaseAddress,
											   DPNA_KEY_PORT,
											   &dwPort,
											   sizeof( dwPort ),
											   DPNA_DATATYPE_DWORD
											   );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Failed to add user specified port from the UI!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
	else
	{
		//
		// There was no port specified.  If this is a connect, then we don't
		// have enough information (we can't try connecting to the DPNSVR
		// port).
		//
		if ( GetType() == ENDPOINT_TYPE_CONNECT )
		{
			hr = DPNERR_ADDRESSING;
			DPFX(DPFPREP, 0, "No port specified in dialog!" );
			goto Failure;
		}
		else
		{
			DNASSERT( GetType() == ENDPOINT_TYPE_ENUM );
		}
	}


	//
	// set the address
	//
	hr = m_pRemoteMachineAddress->SocketAddressFromDP8Address( pBaseAddress, SP_ADDRESS_TYPE_HOST );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to rebuild DNADDRESS when completing IP hostname dialog!" );
		goto Failure;
	}

	AddRef();

	//
	// Since any asynchronous I/O posted on a thread is quit when the thread
	// exits, it's necessary for the completion of this operation to happen
	// on one of the thread pool threads.
	//
	switch ( GetType() )
	{
	    case ENDPOINT_TYPE_ENUM:
	    {
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( EnumQueryJobCallback,
																   CancelEnumQueryJobCallback,
																   this );
			if ( hr != DPN_OK )
			{
				DecRef();
				DPFX(DPFPREP, 0, "Failed to set enum query!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

	    	break;
	    }

	    case ENDPOINT_TYPE_CONNECT:
	    {
			hr = m_pSPData->GetThreadPool()->SubmitDelayedCommand( ConnectJobCallback,
																   CancelConnectJobCallback,
																   this );
			if ( hr != DPN_OK )
			{
				DecRef();
				DPFX(DPFPREP, 0, "Failed to set enum query!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

	    	break;
	    }

	    //
	    // unknown!
	    //
	    default:
	    {
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
	    	goto Failure;

	    	break;
	    }
	}

Exit:
	if ( pBaseAddress != NULL )
	{
		IDirectPlay8Address_Release( pBaseAddress );
		pBaseAddress = NULL;
	}

	if ( pBaseAddress != NULL )
	{
		DNFree( pBaseAddress );
		pBaseAddress = NULL;
	}

	DecRef();

	return;

Failure:
	//
	// cleanup and close this endpoint
	//
	switch ( GetType() )
	{
		case ENDPOINT_TYPE_CONNECT:
		{
			CleanupConnect();
			break;
		}

		case ENDPOINT_TYPE_ENUM:
		{
			CleanupEnumQuery();
			break;
		}

		//
		// other state (note that LISTEN doesn't have a dialog)
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	Close( hr );
	m_pSPData->CloseEndpointHandle( this );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::StopSettingsDialog - stop an active settings dialog
//
// Entry:		Handle of dialog to close
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::StopSettingsDialog"

void	CIPEndpoint::StopSettingsDialog( const HWND hDlg)
{
	StopIPHostNameSettingsDialog( hDlg );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::PoolAllocFunction - function called when item is created in pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::PoolAllocFunction"

BOOL	CIPEndpoint::PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pContext )
{
	BOOL	fReturn;
	HRESULT	hr;


	DNASSERT( pContext != NULL );
	
	//
	// initialize
	//
	fReturn = TRUE;
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetCommandParameters() == NULL );

	hr = Initialize();
	if ( hr != DPN_OK )
	{
		fReturn = FALSE;
		DPFX(DPFPREP, 0, "Failed to initialize base endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	fReturn;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::PoolInitFunction - function called when item is removed from pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::PoolInitFunction"

BOOL	CIPEndpoint::PoolInitFunction( ENDPOINT_POOL_CONTEXT *pContext )
{
	BOOL	fReturn;


	DPFX(DPFPREP, 8, "This = 0x%p, context = 0x%p", this, pContext);
	
	DNASSERT( pContext != NULL );
	DNASSERT( pContext->pSPData != NULL );

	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_pSPData == NULL );
	m_pSPData = pContext->pSPData;
	m_pSPData->ObjectAddRef();
	this->SetPendingCommandResult( DPNERR_GENERIC );
	this->SetEndpointID( pContext->dwEndpointID );

	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( m_blMultiplex.IsEmpty() );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetCommandParameters() == NULL );
	
	DEBUG_ONLY( m_fInitialized = TRUE );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::PoolReleaseFunction - function called when item is returning
//		to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::PoolReleaseFunction"

void	CIPEndpoint::PoolReleaseFunction( void )
{
	DPFX(DPFPREP, 8, "This = 0x%p", this);
	
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DEBUG_ONLY( DNASSERT( m_fEndpointOpen == FALSE ) );

	m_EndpointType = ENDPOINT_TYPE_UNKNOWN;
	m_EnumKey.SetKey( INVALID_ENUM_KEY );

	DNASSERT( m_fConnectSignalled == FALSE );
	DNASSERT( m_State == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( m_pRemoteMachineAddress != NULL );

	DNASSERT( m_pSPData != NULL );
	m_pSPData->ObjectDecRef();
	m_pSPData = NULL;

	m_pRemoteMachineAddress->Reset();

	DNASSERT( GetSocketPort() == NULL );
	DNASSERT( m_pUserEndpointContext == NULL );
	DNASSERT( GetActiveDialogHandle() == NULL );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetCommandParameters() == NULL );

	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( m_blMultiplex.IsEmpty() );
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::PoolDeallocFunction - function called when item is deallocated
//		from the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::PoolDeallocFunction"

void	CIPEndpoint::PoolDeallocFunction( void )
{
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetCommandParameters() == NULL );
	Deinitialize();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPEndpoint::ReturnSelfToPool - return this endpoint to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPEndpoint::ReturnSelfToPool"

void	CIPEndpoint::ReturnSelfToPool( void )
{
	DNASSERT( this->GetEndpointID() == 0 );
	
	if ( CommandPending() != FALSE )
	{
		CompletePendingCommand( PendingCommandResult() );
	}

	if ( ConnectHasBeenSignalled() != FALSE )
	{
		SignalDisconnect( GetDisconnectIndicationHandle() );
	}
	
	DNASSERT( ConnectHasBeenSignalled() == FALSE );

	SetUserEndpointContext( NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\ipaddress.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPAddress.cpp
 *  Content:	Winsock IP address class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// 192.168.0.1 in network byte order
//
#define IP_PRIVATEICS_ADDRESS	0x0100A8C0



//
// default size of buffers when parsing
//
#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000

//
// default broadcast and listen addresses
//
const WCHAR	g_IPBroadcastAddress[] = L"255.255.255.255";
const DWORD	g_dwIPBroadcastAddressSize = sizeof( g_IPBroadcastAddress );
static const WCHAR	g_IPListenAddress[] = L"0.0.0.0";

//
// string for IP helper API
//
static const TCHAR	c_tszIPHelperDLLName[] = TEXT("IPHLPAPI.DLL");
static const char	c_szAdapterNameTemplate[] = "%s - %s";

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef DWORD (WINAPI *PFNGETADAPTERSINFO)(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen);

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::InitializeWithBroadcastAddress - initialize with the IP broadcast address
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
void	CIPAddress::InitializeWithBroadcastAddress( void )
{
	m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = p_htonl( INADDR_BROADCAST );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::SetAddressFromSOCKADDR - set address from a socket address
//
// Entry:		Reference to address
//				Size of address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::SetAddressFromSOCKADDR"

void	CIPAddress::SetAddressFromSOCKADDR( const SOCKADDR &Address, const INT_PTR iAddressSize )
{
	DNASSERT( iAddressSize == GetAddressSize() );
	memcpy( &m_SocketAddress.SocketAddress, &Address, iAddressSize );

	//
	// Since Winsock won't guarantee that the sin_zero part of an IP address is
	// really zero, we ned to do it ourself.  If we don't, it'll make a mess out
	// of the Guid<-->Address code.
	//
	DBG_CASSERT( sizeof( &m_SocketAddress.IPSocketAddress.sin_zero[ 0 ] ) == sizeof( DWORD* ) );
	DBG_CASSERT( sizeof( &m_SocketAddress.IPSocketAddress.sin_zero[ sizeof( DWORD ) ] ) == sizeof( DWORD* ) );
	*reinterpret_cast<DWORD*>( &m_SocketAddress.IPSocketAddress.sin_zero[ 0 ] ) = 0;
	*reinterpret_cast<DWORD*>( &m_SocketAddress.IPSocketAddress.sin_zero[ sizeof( DWORD ) ] ) = 0;
	DNASSERT( SinZeroIsZero( &m_SocketAddress.IPSocketAddress ) != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::SocketAddressFromDP8Address - convert a DP8Address to a socket address
//											NOTE: The address object may be modified
//
// Entry:		Pointer to address
//				Address type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::SocketAddressFromDP8Address"

HRESULT	CIPAddress::SocketAddressFromDP8Address( IDirectPlay8Address *const pDP8Address,
												 const SP_ADDRESS_TYPE AddressType )
{
	HRESULT		hr;
	DWORD		dwAddressSize;
	IDirectPlay8AddressIP	*pIPAddress;
	//IDirectPlay8Address		*pDuplicateAddress;
	SOCKADDR	*pSocketAddresses;


	DNASSERT( pDP8Address != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pIPAddress = NULL;
	//pDuplicateAddress = NULL;
	pSocketAddresses = NULL;

	//
	// reset internal flags
	//
	Reset();

	switch ( AddressType )
	{
		//
		// local device address, ask for the device guid and port to build a socket
		// address
		//
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		case SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET:
		{
			HRESULT	hTempResult;
			DWORD	dwTempSize;
			GUID	AdapterGuid;
			DWORD	dwPort;
			DWORD	dwDataType;
			union
			{
				SOCKADDR	SocketAddress;
				SOCKADDR_IN	INetAddress;
			} INetSocketAddress;


			//
			// Ask for the adapter guid.  If none is found, fail.
			//
			dwTempSize = sizeof( AdapterGuid );
			hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_DEVICE, &AdapterGuid, &dwTempSize, &dwDataType );
			switch ( hTempResult )
			{
				//
				// ok
				//
				case DPN_OK:
				{
					DNASSERT( dwDataType == DPNA_DATATYPE_GUID );
					break;
				}

				//
				// remap missing component to 'addressing' error
				//
				case DPNERR_DOESNOTEXIST:
				{
					hr = DPNERR_ADDRESSING;
					goto Failure;
					break;
				}

				default:
				{
					hr = hTempResult;
					goto Failure;
					break;
				}
			}
			DNASSERT( sizeof( AdapterGuid ) == dwTempSize );

			//
			// Ask for the port.  If none is found, choose a default.
			//
			dwTempSize = sizeof( dwPort );
			hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
			switch ( hTempResult )
			{
				//
				// port present, nothing to do
				//
				case DPN_OK:
				{
					DNASSERT( dwDataType == DPNA_DATATYPE_DWORD );
					break;
				}

				//
				// port not present, fill in the appropriate default
				//
				case DPNERR_DOESNOTEXIST:
				{
					DNASSERT( hr == DPN_OK );
					switch ( AddressType )
					{
						case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
						{
							dwPort = ANY_PORT;
							break;
						}

						default:
						{
							DNASSERT( FALSE );
							break;
						}
					}

					break;
				}

				//
				// other error, fail
				//
				default:
				{
					hr = hTempResult;
					goto Failure;
					break;
				}
			}
			DNASSERT( sizeof( dwPort ) == dwTempSize );

			//
			// convert the GUID to an address in temp space because the GUID contains ALL address information (port, etc)
			// and we don't want to blindly wail on any information that might have already been set.  Verify data
			// integrity and then only copy the raw address.
			//
			AddressFromGuid( AdapterGuid, INetSocketAddress.SocketAddress );
			if ( ( INetSocketAddress.INetAddress.sin_family != m_SocketAddress.IPSocketAddress.sin_family ) ||
				 ( reinterpret_cast<DWORD*>( &INetSocketAddress.INetAddress.sin_zero[ 0 ] )[ 0 ] != 0 ) ||
				 ( reinterpret_cast<DWORD*>( &INetSocketAddress.INetAddress.sin_zero[ 0 ] )[ 1 ] != 0 ) )
			{
				DNASSERT( FALSE );
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP,  0, "Invalid device guid!" );
				goto Exit;
			}

			//
			// if this is a proxied enum, check for the all-adapters address
			// being passed because it's not a valid target (it needs to be
			// remapped to the local loopback).
			//
			if ( ( AddressType == SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET ) &&
				 ( INetSocketAddress.INetAddress.sin_addr.S_un.S_addr == p_htonl( INADDR_ANY ) ) )
			{
				m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = p_htonl( INADDR_LOOPBACK );
			}
			else
			{
				m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = INetSocketAddress.INetAddress.sin_addr.S_un.S_addr;
			}

			m_SocketAddress.IPSocketAddress.sin_port = p_htons( static_cast<WORD>( dwPort ) );
			break;
		}

		//
		// hostname
		//
		case SP_ADDRESS_TYPE_HOST:
		{
			HRESULT	hTempResult;
			DWORD	dwPort;
			DWORD	dwTempSize;
			DWORD	dwDataType;



			/*
			//
			// duplicate the input address because it might need to be modified
			//
			DNASSERT( pDuplicateAddress == NULL );
			IDirectPlay8Address_Duplicate( pDP8Address, &pDuplicateAddress );
			if ( pDuplicateAddress == NULL )
			{
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}
			*/

			//
			// Ask for the port.  If none is found, choose a default.
			//
			dwTempSize = sizeof( dwPort );
			//hTempResult = IDirectPlay8Address_GetComponentByName( pDuplicateAddress, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
			hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
			switch ( hTempResult )
			{
				//
				// port present, nothing to do
				//
				case DPN_OK:
				{
					DNASSERT( dwDataType == DPNA_DATATYPE_DWORD );
					m_SocketAddress.IPSocketAddress.sin_port = p_htons( static_cast<WORD>( dwPort ) );
					break;
				}

				//
				// port not present, fill in the appropriate default
				//
				case DPNERR_DOESNOTEXIST:
				{
					const DWORD	dwTempPort = DPNA_DPNSVR_PORT;


					m_SocketAddress.IPSocketAddress.sin_port = p_htons( static_cast<const WORD>( dwTempPort ) );
					//hTempResult = IDirectPlay8Address_AddComponent( pDuplicateAddress,
					hTempResult = IDirectPlay8Address_AddComponent( pDP8Address,
																	DPNA_KEY_PORT,
																	&dwTempPort,
																	sizeof( dwTempPort ),
																	DPNA_DATATYPE_DWORD
																	);
					if ( hTempResult != DPN_OK )
					{
						hr = hTempResult;
						goto Failure;
					}

					break;
				}

				//
				// remap everything else to an addressing failure
				//
				default:
				{
					hr = DPNERR_ADDRESSING;
					goto Failure;
				}
			}

			//
			// get an IP interface
			//
			/*
			DNASSERT( pDuplicateAddress != NULL );
			hr = IDirectPlay8Address_QueryInterface( pDuplicateAddress, IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ) );
			*/
			hr = IDirectPlay8Address_QueryInterface( pDP8Address, IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ) );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0, "SocketAddressFromDP8Address: Failed to get IPAddress interface" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// attempt to determine the host name
			//
			dwAddressSize = 0;
			DNASSERT( pSocketAddresses == NULL );
			
RegetSocketAddressData:
			memset( pSocketAddresses, 0x00, dwAddressSize );
			hr = IDirectPlay8AddressIP_GetSockAddress( pIPAddress, pSocketAddresses, &dwAddressSize );
			switch ( hr )
			{
				//
				// conversion succeeded, check the size of the data returned
				// before setting the information in the local address structure.
				//
				case DPN_OK:
				{
					if ( dwAddressSize < sizeof( *pSocketAddresses ) )
					{
						hr = DPNERR_ADDRESSING;
						goto Failure;
					}
					
					SetAddressFromSOCKADDR( *pSocketAddresses, sizeof( *pSocketAddresses ) );					

					break;
				}

				//
				// Buffer too small, if there is no buffer, allocate one.  If
				// there is a buffer, resize it to containt the data before
				// attempting to get the data again.
				//
				case DPNERR_BUFFERTOOSMALL:
				{
					if ( pSocketAddresses == NULL )
					{
						pSocketAddresses = static_cast<SOCKADDR*>( DNMalloc( dwAddressSize ) );
						if ( pSocketAddresses == NULL )
						{
							hr = DPNERR_OUTOFMEMORY;
							goto Failure;
						}
					}
					else
					{
						void	*pTemp;


						pTemp = DNRealloc( pSocketAddresses, dwAddressSize );
						if ( pTemp == NULL )
						{
							hr = DPNERR_OUTOFMEMORY;
							goto Failure;
						}
					
						pSocketAddresses = static_cast<SOCKADDR*>( pTemp );
					}

					goto RegetSocketAddressData;
					break;
				}

				//
				// Incomplete address, set the address type and return.  It's
				// up to the caller to decide if this is really a problem.
				//
				case DPNERR_INCOMPLETEADDRESS:
				{
					break;
				}

				//
				// pass these error returns untouched
				//
				case DPNERR_OUTOFMEMORY:
				{
					goto Failure;
					break;
				}
			
				//
				// other problem, map it to an addressing error
				//
				default:
				{
					hr = DPNERR_ADDRESSING;
					goto Failure;
					break;
				}
			}

			break;
		}

		//
		// unknown address type
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	DNASSERT( SinZeroIsZero( &m_SocketAddress.IPSocketAddress ) != FALSE );

	//
	// now that the address has been completely parsed, set the address type
	//
	m_AddressType = AddressType;

Exit:
	if ( pIPAddress != NULL )
	{
		IDirectPlay8AddressIP_Release( pIPAddress );
		pIPAddress = NULL;
	}

	/*
	if ( pDuplicateAddress != NULL )
	{
		IDirectPlay8Address_Release( pDuplicateAddress );
		pDuplicateAddress = NULL;
	}
	*/

	if ( pSocketAddresses != NULL )
	{
		DNFree( pSocketAddresses );
		pSocketAddresses = NULL;
	}

	if (( hr != DPN_OK ) && ( hr != DPNERR_INCOMPLETEADDRESS ))
	{
		DPFX(DPFPREP,  0, "Problem with IPAddress::SocketAddressFromDP8Address() (0x%lx)", hr );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::DP8AddressFromSocketAddress - convert a socket address to a DP8Address
//
// Entry:		Nothing
//
// Exit:		Pointer to DP8Address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::DP8AddressFromSocketAddress"

IDirectPlay8Address *CIPAddress::DP8AddressFromSocketAddress( void ) const
{
	HRESULT		hr;
	IDirectPlay8Address		*pDP8Address;
	IDirectPlay8AddressIP	*pIPAddress;


	DNASSERT( ( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_DEVICE ] != SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED ) &&
			  ( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_HOSTNAME ] != SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED ) &&
			  ( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_PORT ] != SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED ) );


	//
	// intialize
	//
	hr = DPN_OK;
	pDP8Address = NULL;
	pIPAddress = NULL;

	//
	// create and initialize the address
	//
	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ) );
	if ( hr != S_OK )
	{
		DNASSERT( pIPAddress == NULL );
		DPFX(DPFPREP,  0, "DP8AddressFromSocketAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	switch ( m_AddressType )
	{
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		{
			GUID		DeviceGuid;


			GuidFromInternalAddressWithoutPort( DeviceGuid );
			hr = IDirectPlay8AddressIP_BuildLocalAddress( pIPAddress,
														  &DeviceGuid,
														  p_ntohs( m_SocketAddress.IPSocketAddress.sin_port )
														  );
			break;
		}

		case SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS:
		case SP_ADDRESS_TYPE_READ_HOST:
		case SP_ADDRESS_TYPE_HOST:
		{
			hr = IDirectPlay8AddressIP_BuildFromSockAddr( pIPAddress, &m_SocketAddress.SocketAddress );
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	//
	// clean up the IP interface pointer.  If we got this far and there was
	// no error it means that we built the IP address properly.  Get a generic
	// address interface to return to the user.
	//
	if ( pIPAddress != NULL )
	{
		if ( hr == DPN_OK )
		{
			DNASSERT( pDP8Address == NULL );
			hr = IDirectPlay8AddressIP_QueryInterface( pIPAddress, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDP8Address ) );
			DNASSERT( ( hr == DPN_OK ) || ( pDP8Address == NULL ) );
		}

		IDirectPlay8AddressIP_Release( pIPAddress );
	}

	return	pDP8Address;

Failure:

	if ( pDP8Address != NULL )
	{
		IDirectPlay8Address_Release( pDP8Address );
		pDP8Address = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CompareFunction - compare against another address
//
// Entry:		Pointer to other address
//
// Exit:		Integer indicating relative magnitude:
//				0 = items equal
//				-1 = other item is of greater magnitude
//				1 = this item is of lesser magnitude
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CompareFunction"

INT_PTR	CIPAddress::CompareFunction( const CSocketAddress *const pOtherAddress ) const
{
	INT_PTR	iReturn;
	const CIPAddress *const pIPAddress = static_cast<const CIPAddress*>( pOtherAddress );


	DNASSERT( pOtherAddress != NULL );
	DNASSERT( m_SocketAddress.IPSocketAddress.sin_family == pIPAddress->m_SocketAddress.IPSocketAddress.sin_family );

	//
	// we need to compare the IP address and port to guarantee uniqueness
	//
	if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == pIPAddress->m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr )
	{
		if ( m_SocketAddress.IPSocketAddress.sin_port == pIPAddress->m_SocketAddress.IPSocketAddress.sin_port )
		{
			iReturn = 0;
		}
		else
		{
			if ( m_SocketAddress.IPSocketAddress.sin_port < pIPAddress->m_SocketAddress.IPSocketAddress.sin_port )
			{
				iReturn = -1;
			}
			else
			{
				iReturn = 1;
			}
		}
	}
	else
	{
		if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr < pIPAddress->m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr )
		{
			iReturn = -1;
		}
		else
		{
			iReturn = 1;
		}
	}

	return	iReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CreateBroadcastAddress - create DP8Address used for broadcast sends
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CreateBroadcastAddress"

IDirectPlay8Address *CIPAddress::CreateBroadcastAddress( void )
{
	HRESULT	hr;
	IDirectPlay8Address		*pDPlayAddress;
	IDirectPlay8AddressIP	*pIPAddress;


	//
	// initialize
	//
	pDPlayAddress = NULL;
	pIPAddress = NULL;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
	if ( hr != S_OK )
	{
		DNASSERT( pDPlayAddress == NULL );
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = IDirectPlay8Address_QueryInterface( pDPlayAddress, IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ) );
	if ( hr != S_OK )
	{
		goto Failure;
	}

	hr = IDirectPlay8AddressIP_BuildAddress( pIPAddress, g_IPBroadcastAddress, DPNA_DPNSVR_PORT );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to set hostname and port!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( pIPAddress != NULL )
	{
		IDirectPlay8AddressIP_Release( pIPAddress );
		pIPAddress = NULL;
	}

	return	pDPlayAddress;

Failure:
	if ( pDPlayAddress != NULL )
	{
		IDirectPlay8Address_Release( pDPlayAddress );
		pDPlayAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CreateListenAddress - create DP8Address used for listens
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CreateListenAddress"

IDirectPlay8Address *CIPAddress::CreateListenAddress( void )
{
	HRESULT	hr;
	IDirectPlay8Address		*pDPlayAddress;
	IDirectPlay8AddressIP	*pIPAddress;


	//
	// initialize
	//
	pDPlayAddress = NULL;
	pIPAddress = NULL;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
	if ( hr != S_OK )
	{
		DNASSERT( pDPlayAddress == NULL );
		DPFX(DPFPREP,  0, "CreateListenAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = IDirectPlay8Address_QueryInterface( pDPlayAddress, IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ) );
	if ( hr != S_OK )
	{
		goto Failure;
	}

	hr = IDirectPlay8AddressIP_BuildAddress( pIPAddress, g_IPListenAddress, ANY_PORT );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateListenAddress: Failed to set hostname and port!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( pIPAddress != NULL )
	{
		IDirectPlay8AddressIP_Release( pIPAddress );
		pIPAddress = NULL;
	}

	return	pDPlayAddress;

Failure:
	if ( pDPlayAddress != NULL )
	{
		IDirectPlay8Address_Release( pDPlayAddress );
		pDPlayAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CreateGenericAddress - create a generic address
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CreateGenericAddress"

IDirectPlay8Address *CIPAddress::CreateGenericAddress( void )
{
	HRESULT	hr;
	IDirectPlay8Address		*pDPlayAddress;
	IDirectPlay8AddressIP	*pIPAddress;


	//
	// initialize
	//
	pDPlayAddress = NULL;
	pIPAddress = NULL;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
	if ( hr != S_OK )
	{
		DNASSERT( pDPlayAddress == NULL );
		DPFX(DPFPREP,  0, "CreateGenericAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = IDirectPlay8Address_QueryInterface( pDPlayAddress, IID_IDirectPlay8AddressIP, reinterpret_cast<void**>( &pIPAddress ) );
	if ( hr != S_OK )
	{
		goto Failure;
	}

	hr = IDirectPlay8AddressIP_BuildAddress( pIPAddress, g_IPListenAddress, ANY_PORT );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateGenericAddress: Failed to set hostname and port!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( pIPAddress != NULL )
	{
		IDirectPlay8AddressIP_Release( pIPAddress );
		pIPAddress = NULL;
	}

	return	pDPlayAddress;

Failure:
	if ( pDPlayAddress != NULL )
	{
		IDirectPlay8Address_Release( pDPlayAddress );
		pDPlayAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CompareToBaseAddress - compare this address to a 'base' address
//		of this class
//
// Entry:		Pointer to base address
//
// Exit:		Integer indicating relative magnitude:
//				0 = items equal
//				-1 = other item is of greater magnitude
//				1 = this item is of lesser magnitude
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CompareToBaseAddress"

INT_PTR	CIPAddress::CompareToBaseAddress( const SOCKADDR *const pBaseAddress ) const
{
	const SOCKADDR_IN	*pBaseIPAddress;
	DNASSERT( pBaseAddress != NULL );

	
	DNASSERT( pBaseAddress->sa_family == m_SocketAddress.SocketAddress.sa_family );
	pBaseIPAddress = reinterpret_cast<const SOCKADDR_IN*>( pBaseAddress );
	if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == pBaseIPAddress->sin_addr.S_un.S_addr )
	{
		return 0;
	}
	else
	{
		if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr < pBaseIPAddress->sin_addr.S_un.S_addr )
		{
			return	1;
		}
		else
		{
			return	-1;
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::HashFunction - hash address to N bits
//
// Entry:		Count of bits to hash to
//
// Exit:		Hashed value
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::HashFunction"

INT_PTR	CIPAddress::HashFunction( const INT_PTR iHashBitCount ) const
{
	INT_PTR		iReturn;
	UINT_PTR	Temp;


	DNASSERT( iHashBitCount != 0 );

	//
	// initialize
	//
	iReturn = 0;

	//
	// hash IP address
	//
	Temp = m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr;
	do
	{
		iReturn ^= Temp & ( ( 1 << iHashBitCount ) - 1 );
		Temp >>= iHashBitCount;
	} while ( Temp != 0 );

	//
	// hash IP port
	//
	Temp = m_SocketAddress.IPSocketAddress.sin_port;
	do
	{
		iReturn^= Temp & ( ( 1 << iHashBitCount ) - 1 );
		Temp >>= iHashBitCount;
	}
	while ( Temp != 0 );

	return iReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::EnumAdapters - enumerate all of the adapters for this machine
//
// Entry:		Pointer to enum adapters data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::EnumAdapters"

HRESULT	CIPAddress::EnumAdapters( SPENUMADAPTERSDATA *const pEnumData ) const
{
	HRESULT				hr;
	DWORD				dwError;
	SOCKADDR_IN			saddrinTemp;
	const HOSTENT *		pHostData;
	IN_ADDR **			ppinaddrTemp;
	DWORD				dwAddressCount;
	BOOL				fFoundPrivateICS = FALSE;
	IN_ADDR *			pinaddrBuffer = NULL;
	DWORD				dwIndex;
	HMODULE				hIpHlpApiDLL;
	PFNGETADAPTERSINFO	pfnGetAdaptersInfo;
	IP_ADAPTER_INFO *	pAdapterInfoBuffer = NULL;
	ULONG				ulAdapterInfoBufferSize = 0;
	const char *		pszIPAddress;
	IP_ADAPTER_INFO *	pCurrentAdapterInfo;
	PIP_ADDR_STRING		pIPAddrString;
	GUID				guidAdapter;
	CPackedBuffer		PackedBuffer;
	char				acBuffer[512];


	DPFX(DPFPREP, 6, "Parameters: (0x%p)", pEnumData);


	PackedBuffer.Initialize( pEnumData->pAdapterData, pEnumData->dwAdapterDataSize );

	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family	= GetFamily();


	//
	// Get the list of local IPs from WinSock.  We use this method since it's
	// available on all platforms and conveniently returns the loopback address
	// when no valid adapters are currently available.
	//
	
	if (p_gethostname(acBuffer, sizeof(acBuffer)) == SOCKET_ERROR)
	{
#ifdef DEBUG
		dwError = p_WSAGetLastError();
		DPFX(DPFPREP, 0, "Failed to get host name into fixed size buffer (err = %u)!", dwError);
		DisplayWinsockError(0, dwError);
#endif // DEBUG
		hr = DPNERR_GENERIC;
		goto Failure;
	}

	pHostData = p_gethostbyname(acBuffer);
	if (pHostData == NULL)
	{
#ifdef DEBUG
		dwError = p_WSAGetLastError();
		DPFX(DPFPREP,  0, "Failed to get host data (err = %u)!", dwError);
		DisplayWinsockError(0, dwError);
#endif // DEBUG
		hr = DPNERR_GENERIC;
		goto Failure;
	}


	//
	// Count number of addresses.
	//
	dwAddressCount = 0;
	ppinaddrTemp = (IN_ADDR**) (pHostData->h_addr_list);
	while ((*ppinaddrTemp) != NULL)
	{
		//
		// Remember if it's 192.168.0.1.  See below
		//
		if ((*ppinaddrTemp)->S_un.S_addr == IP_PRIVATEICS_ADDRESS)
		{
			fFoundPrivateICS = TRUE;
		}

		dwAddressCount++;
		ppinaddrTemp++;
	}

	if (dwAddressCount == 0)
	{
		DPFX(DPFPREP, 1, "No IP addresses, forcing loopback address.");
		DNASSERTX(!" No IP addresses!", 2);
		dwAddressCount++;
	}
	else
	{
		DPFX(DPFPREP, 3, "WinSock reported %u addresses.", dwAddressCount);
	}


	//
	// Winsock says we should copy this data before any other Winsock calls.
	//
	// We also use this as an opportunity to ensure that the order returned to the caller is
	// to our liking.  In particular, we make sure the private address 192.168.0.1 appears
	// first.
	//
	DNASSERT(pHostData->h_length == sizeof(IN_ADDR));
	pinaddrBuffer = (IN_ADDR*) DNMalloc(dwAddressCount * sizeof(IN_ADDR));
	if (pinaddrBuffer == NULL)
	{
		DPFX(DPFPREP,  0, "Failed to allocate memory to store copy of addresses!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}


	dwIndex = 0;

	//
	// First, store 192.168.0.1 if we found it.
	//
	if (fFoundPrivateICS)
	{
		pinaddrBuffer[dwIndex].S_un.S_addr = IP_PRIVATEICS_ADDRESS;
		dwIndex++;
	}

	//
	// Then copy the rest.
	//
	ppinaddrTemp = (IN_ADDR**) (pHostData->h_addr_list);
	while ((*ppinaddrTemp) != NULL)
	{
		if ((*ppinaddrTemp)->S_un.S_addr != IP_PRIVATEICS_ADDRESS)
		{
			pinaddrBuffer[dwIndex].S_un.S_addr = (*ppinaddrTemp)->S_un.S_addr;
			dwIndex++;
		}

		ppinaddrTemp++;
	}

	//
	// If we didn't have any addresses, slap in the loopback address.
	//
	if (dwIndex == 0)
	{
		pinaddrBuffer[0].S_un.S_addr = p_htonl(INADDR_LOOPBACK);
		dwIndex++;
	}


	DNASSERT(dwIndex == dwAddressCount);
	

	//
	// Now we try to generate names and GUIDs for these IP addresses.
	// We'll use what IPHLPAPI reports for a name if possible, and fall
	// back to just using the IP address string as the name.
	//

	//
	// Load the IPHLPAPI module and get the adapter list if possible.
	//
	hIpHlpApiDLL = LoadLibrary(c_tszIPHelperDLLName);
	if (hIpHlpApiDLL != NULL)
	{
		pfnGetAdaptersInfo = (PFNGETADAPTERSINFO) GetProcAddress(hIpHlpApiDLL, "GetAdaptersInfo");
		if (pfnGetAdaptersInfo != NULL)
		{
			//
			// Keep resizing the buffer until there's enough room.
			//
			do
			{
				dwError = pfnGetAdaptersInfo(pAdapterInfoBuffer,
											&ulAdapterInfoBufferSize);
				if (dwError == ERROR_SUCCESS)
				{
					//
					// We got all the info we're going to get.  Make sure it
					// was something.
					//
					if (ulAdapterInfoBufferSize == 0)
					{
						DPFX(DPFPREP, 0, "GetAdaptersInfo returned 0 byte size requirement!  Ignoring.");

						//
						// Get rid of the buffer if allocated.
						//
						if (pAdapterInfoBuffer != NULL)
						{
							DNFree(pAdapterInfoBuffer);
							pAdapterInfoBuffer = NULL;
						}

						//
						// Continue with exiting the loop.
						//
					}
#ifdef DEBUG
					else
					{
						int		iStrLen;
						char	szIPList[256];
						char *	pszCurrentIP;


						//
						// Print out all the adapters for debugging purposes.
						//
						pCurrentAdapterInfo = pAdapterInfoBuffer;
						while (pCurrentAdapterInfo != NULL)
						{
							//
							// Initialize IP address list string.
							//
							szIPList[0] = '\0';
							pszCurrentIP = szIPList;


							//
							// Loop through all addresses for this adapter.
							//
							pIPAddrString = &pCurrentAdapterInfo->IpAddressList;
							while (pIPAddrString != NULL)
							{
								//
								// Copy the IP address string (if there's enough room),
								// then tack on a space and NULL terminator.
								//
								iStrLen = strlen(pIPAddrString->IpAddress.String);
								if ((pszCurrentIP + iStrLen + 2) < (szIPList + sizeof(szIPList)))
								{
									memcpy(pszCurrentIP, pIPAddrString->IpAddress.String, iStrLen);
									pszCurrentIP += iStrLen;
									(*pszCurrentIP) = ' ';
									pszCurrentIP++;
									(*pszCurrentIP) = '\0';
									pszCurrentIP++;
								}

								pIPAddrString = pIPAddrString->Next;
							}


							DPFX(DPFPREP, 8, "Adapter index %u IPs = %s, %s, \"%s\".",
								pCurrentAdapterInfo->Index,
								szIPList,
								pCurrentAdapterInfo->AdapterName,
								pCurrentAdapterInfo->Description);


							//
							// Go to next adapter.
							//
							pCurrentAdapterInfo = pCurrentAdapterInfo->Next;
						}
					} // end else (got valid buffer size)
#endif // DEBUG

					break;
				}

				if (dwError != ERROR_BUFFER_OVERFLOW)
				{
					DPFX(DPFPREP, 0, "GetAdaptersInfo failed (err = 0x%lx)!  Ignoring.", dwError);

					//
					// Get rid of the buffer if allocated, and then bail out of
					// the loop.
					//
					if (pAdapterInfoBuffer != NULL)
					{
						DNFree(pAdapterInfoBuffer);
						pAdapterInfoBuffer = NULL;
					}

					break;
				}


				//
				// If we're here, then we need to reallocate the buffer.
				//
				if (pAdapterInfoBuffer != NULL)
				{
					DNFree(pAdapterInfoBuffer);
					pAdapterInfoBuffer = NULL;
				}

				pAdapterInfoBuffer = (IP_ADAPTER_INFO*) DNMalloc(ulAdapterInfoBufferSize);
				if (pAdapterInfoBuffer == NULL)
				{
					//
					// Couldn't allocate memory.  Bail out of the loop.
					//
					break;
				}

				//
				// Successfully allocated buffer.  Try again.
				//
			}
			while (TRUE);


			//
			// We get here in all cases, so we may have failed to get an info
			// buffer.  That's fine, we'll use the fallback to generate the
			// names.
			//
		}
		else
		{
#ifdef DEBUG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Failed to get proc address for GetAdaptersInfo!");
			DisplayErrorCode(0, dwError);
#endif // DEBUG

			//
			// Continue.  We'll use the fallback to generate the names.
			//
		}


		//
		// We don't need the library anymore.
		//
		FreeLibrary(hIpHlpApiDLL);
		hIpHlpApiDLL = NULL;
	}
	else
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to get proc address for GetAdaptersInfo!");
		DisplayErrorCode(0, dwError);
#endif // DEBUG

		//
		// Continue.  We'll use the fallback to generate the names.
		//
	}


	//
	// Loop through all IP addresses, generating names and GUIDs.
	//
	for(dwIndex = 0; dwIndex < dwAddressCount; dwIndex++)
	{
		//
		// Get the IP address string.  We don't make any other WinSock
		// calls, so holding on to the pointer is OK.  This pointer
		// may be used as the device name string, too.
		//
		pszIPAddress = p_inet_ntoa(pinaddrBuffer[dwIndex]);


		//
		// Look for an adapter name from IPHLPAPI if possible.
		//
		if (pAdapterInfoBuffer != NULL)
		{
			pCurrentAdapterInfo = pAdapterInfoBuffer;
			while (pCurrentAdapterInfo != NULL)
			{
				//
				// Look for matching IP.
				//
				pIPAddrString = &pCurrentAdapterInfo->IpAddressList;
				while (pIPAddrString != NULL)
				{
					if (strcmp(pIPAddrString->IpAddress.String, pszIPAddress) == 0)
					{
						DPFX(DPFPREP, 9, "Found %s under adapter index %u (\"%s\").",
							pszIPAddress, pCurrentAdapterInfo->Index,
							pCurrentAdapterInfo->Description);


						//
						// Build the name string.
						//
						wsprintfA(acBuffer,
								  c_szAdapterNameTemplate,
								  pCurrentAdapterInfo->Description,
								  pszIPAddress);

						//
						// Point the name string to the buffer and drop out
						// of the loop.
						//
						pszIPAddress = acBuffer;
						break;
					}

					//
					// Move to next IP address.
					//
					pIPAddrString = pIPAddrString->Next;
				}


				//
				// If we found the address, stop looping through adapters,
				// too.
				//
				if (pszIPAddress == acBuffer)
				{
					break;
				}


				//
				// Otherwise, go to next adapter.
				//
				pCurrentAdapterInfo = pCurrentAdapterInfo->Next;
			}

			//
			// If we never found the adapter, pszIPAddress will still point to
			// the IP address string.
			//
		}
		else
		{
			//
			// Didn't successfully get IPHLPAPI adapter info.  pszIPAddress will
			// still point to the IP address string.
			//
		}



		//
		// Generate the GUID.
		//
		saddrinTemp.sin_addr = pinaddrBuffer[dwIndex];
		GuidFromAddress(guidAdapter, *((SOCKADDR*) (&saddrinTemp)));

		
		DPFX(DPFPREP, 7, "Returning adapter %u: \"%s\" {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}.",
			dwIndex,
			pszIPAddress,
			guidAdapter.Data1,
			guidAdapter.Data2,
			guidAdapter.Data3,
			guidAdapter.Data4[0],
			guidAdapter.Data4[1],
			guidAdapter.Data4[2],
			guidAdapter.Data4[3],
			guidAdapter.Data4[4],
			guidAdapter.Data4[5],
			guidAdapter.Data4[6],
			guidAdapter.Data4[7]);
		
		//
		// Add to buffer.
		//
		hr = AddNetworkAdapterToBuffer(&PackedBuffer, pszIPAddress, &guidAdapter);
		if ((hr != DPN_OK) && (hr != DPNERR_BUFFERTOOSMALL))
		{
			DPFX(DPFPREP,  0, "Failed to add adapter to buffer (err = 0x%lx)!", hr);
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}


	//
	// If we're here, we successfully built the list of adapters, although
	// the caller may not have given us enough buffer space to store it.
	//
	pEnumData->dwAdapterCount = dwAddressCount;
	pEnumData->dwAdapterDataSize = PackedBuffer.GetSizeRequired();


Exit:

	if (pAdapterInfoBuffer != NULL)
	{
		DNFree(pAdapterInfoBuffer);
		pAdapterInfoBuffer = NULL;
	}

	if (pinaddrBuffer != NULL)
	{
		DNFree(pinaddrBuffer);
		pinaddrBuffer = NULL;
	}

	DPFX(DPFPREP, 6, "Return [0x%lx]", hr);

	return hr;


Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::GuidFromInternalAddressWithoutPort - get a guid from the internal
//		address without a port.
//
// Entry:		Reference to desintation GUID
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::GuidFromInternalAddressWithoutPort"

void	CIPAddress::GuidFromInternalAddressWithoutPort( GUID &OutputGuid ) const
{
	union
	{
		SOCKADDR	SockAddr;
		SOCKADDR_IN	IPSockAddr;
	} TempSocketAddress;


	DBG_CASSERT( sizeof( TempSocketAddress.SockAddr ) == sizeof( m_SocketAddress.SocketAddress ) );
	memcpy( &TempSocketAddress.SockAddr, &m_SocketAddress.SocketAddress, sizeof( TempSocketAddress.SockAddr ) );
	TempSocketAddress.IPSockAddr.sin_port = 0;
	GuidFromAddress( OutputGuid, TempSocketAddress.SockAddr );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::IsUndefinedHostAddress - determine if this is an undefined host
//		address
//
// Entry:		Nothing
//
// Exit:		Boolean indicating whether this is an undefined host address
//				TRUE = this is an undefined address
//				FALSE = this is not an undefined address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::IsUndefinedHostAddress"

BOOL	CIPAddress::IsUndefinedHostAddress( void ) const
{
	BOOL	fReturn;


	fReturn = FALSE;
	if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == p_htonl( INADDR_ANY ) )
	{
		fReturn = TRUE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::ChangeLoopBackToLocalAddress - change loopback to a local address
//
// Entry:		Pointer to other address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::ChangeLoopBackToLocalAddress"

void	CIPAddress::ChangeLoopBackToLocalAddress( const CSocketAddress *const pOtherSocketAddress )
{
	const CIPAddress	*pOtherIPAddress;

	
	DNASSERT( pOtherSocketAddress != NULL );
	pOtherIPAddress = static_cast<const CIPAddress*>( pOtherSocketAddress );

	if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == p_htonl( INADDR_LOOPBACK ) )
	{
		DPFX(DPFPREP, 2, "Changing loopback address to %s.", p_inet_ntoa(m_SocketAddress.IPSocketAddress.sin_addr));
		m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = pOtherIPAddress->m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPAddress::CopyInternalSocketAddressWithoutPort - copy socket address
//		without the port field.
//
// Entry:		Reference to destination address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPAddress::CopyInternalSocketAddressWithoutPort"

void	CIPAddress::CopyInternalSocketAddressWithoutPort( SOCKADDR &AddressDestination ) const
{
	SOCKADDR_IN	*pIPSocketAddress;


	DNASSERT( SinZeroIsZero( &m_SocketAddress.IPSocketAddress ) != FALSE );

	//
	// copy address and zero out the port
	//
	DBG_CASSERT( sizeof( AddressDestination ) == sizeof( m_SocketAddress.SocketAddress ) );
	memcpy( &AddressDestination, &m_SocketAddress.SocketAddress, sizeof( AddressDestination ) );

	DBG_CASSERT( sizeof( SOCKADDR_IN* ) == sizeof( &AddressDestination ) );
	pIPSocketAddress = reinterpret_cast<SOCKADDR_IN*>( &AddressDestination );
	pIPSocketAddress->sin_port = p_htons( 0 );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\iodata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IOData.h
 *  Content:	Strucutre definitions for IO data blocks
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __IODATA_H__
#define __IODATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated types for what action to take when a send completes
//
typedef	enum	_SEND_COMPLETE_ACTION
{
	SEND_COMPLETE_ACTION_UNKNOWN = 0,				// unknown value
	SEND_COMPLETE_ACTION_NONE,						// no action
	SEND_COMPLETE_ACTION_COMPLETE_COMMAND,			// complete command
	SEND_COMPLETE_ACTION_PROXIED_ENUM_CLEANUP		// clean up proxied enum data
} SEND_COMPLETE_ACTION;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure and class references
//
class	CCommandData;
class	CEndpoint;
class	CIOData;
class	CSocketPort;
class	CSocketAddress;
class	CThreadPool;
typedef	enum	_SP_TYPE	SP_TYPE;

//
// structures used to get I/O data from the pools
//
typedef	struct	_READ_IO_DATA_POOL_CONTEXT
{
	SP_TYPE		SPType;
	CThreadPool	*pThreadPool;
}READ_IO_DATA_POOL_CONTEXT;

typedef	struct	_WRITE_IO_DATA_POOL_CONTEXT
{
	SP_TYPE	SPType;
#ifdef WIN95
	HANDLE	hOverlapEvent;
#endif
}WRITE_IO_DATA_POOL_CONTEXT;

//
// class containing all data for I/O completion
//
class	CIOData
{
	public:
		CIOData();
		virtual ~CIOData();


		CSocketPort	*SocketPort( void ) const { return m_pSocketPort; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::SetSocketPort"
		void	SetSocketPort( CSocketPort *const pSocketPort )
		{
			DNASSERT( ( m_pSocketPort == NULL ) || ( pSocketPort == NULL ) );
			m_pSocketPort = pSocketPort;
		}

#ifdef WIN95
		BOOL	Win9xOperationPending( void ) const { return m_Flags.fWin9xOperationPending; }
		void	SetWin9xOperationPending( const BOOL fOperationPending ) { m_Flags.fWin9xOperationPending = fOperationPending; }
#endif

		void	SetWriteOperation( void ) { m_Flags.fWriteOperation = TRUE; }
		BOOL	IsReadOperation( void ) const { return ( m_Flags.fWriteOperation == FALSE ); }
		BOOL	IsWriteOperation( void ) const { return m_Flags.fWriteOperation; }

		OVERLAPPED	*Overlap( void ) { return &m_Overlap; }
#ifdef WIN95
		HANDLE	OverlapEvent( void ) const { return m_Overlap.hEvent; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::SetOverlapEvent"
		void	SetOverlapEvent( const HANDLE hEvent )
		{
			DNASSERT( ( m_Overlap.hEvent == NULL ) || ( hEvent == NULL ) );
			m_Overlap.hEvent = hEvent;
		}
#endif

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIOData::IODataFromOverlap"
		static	CIOData	*IODataFromOverlap( OVERLAPPED *const pOverlap )
		{
			DNASSERT( pOverlap != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pOverlap ) );
			DBG_CASSERT( sizeof( CIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CIOData*>( &reinterpret_cast<BYTE*>( pOverlap )[ -OFFSETOF( CIOData, m_Overlap ) ] );
		}

	protected:

	private:
		OVERLAPPED	m_Overlap;		// overlapped I/O structure

		CSocketPort		*m_pSocketPort;				// pointer to socket port associated with this IO request
		struct
		{
#ifdef WIN95
			BOOL	fWin9xOperationPending : 1;		// this structure has been initialized and the operation is pending on Win9x
#endif
			BOOL	fWriteOperation : 1;			// this is a write operation
		} m_Flags;

		// prevent unwarranted copies
		CIOData( const CIOData & );
		CIOData& operator=( const CIOData & );
};

//
// all data for a read operation
//
class	CReadIOData : public CIOData
{
	public:
		CReadIOData();
		~CReadIOData();

		void	AddRef( void ) { DNInterlockedIncrement( &m_lRefCount ); }

		void	DecRef( void )
		{
			if ( DNInterlockedDecrement( &m_lRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		CBilink				m_OutstandingReadListLinkage;	// links to the unbound list
		INT					m_iSocketAddressSize;			// size of received socket address (from Winsock)
		CSocketAddress		*m_pSourceSocketAddress;		// pointer to socket address class that's bound to the
															// local 'SocketAddress' element and is used to get the
															// address of the machine that originated the datagram

		INT		m_ReceiveWSAReturn;		
		DWORD	m_dwOverlappedBytesReceived;

		DWORD	m_dwBytesRead;
		DWORD	m_dwReadFlags;
		DEBUG_ONLY( BOOL	m_fRetainedByHigherLayer );

		SP_TYPE	GetAddressType( void ) const { DNASSERT( m_pThreadPool != NULL ); return m_AddressType; }
		SPRECEIVEDBUFFER	*ReceivedBuffer( void ) { DNASSERT( m_pThreadPool != NULL ); return &m_SPReceivedBuffer; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::ReadDataFromBilink"
		static CReadIOData	*ReadDataFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CReadIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CReadIOData*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CReadIOData, m_OutstandingReadListLinkage ) ] );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CReadIOData::ReadDataFromSPReceivedBuffer"
    	static CReadIOData	*ReadDataFromSPReceivedBuffer( SPRECEIVEDBUFFER *const pSPReceivedBuffer )
    	{
    		DNASSERT( pSPReceivedBuffer != NULL );
    		DBG_CASSERT( sizeof( BYTE* ) == sizeof( pSPReceivedBuffer ) );
    		DBG_CASSERT( sizeof( CReadIOData* ) == sizeof( BYTE* ) );
    		return	reinterpret_cast<CReadIOData*>( &reinterpret_cast<BYTE*>( pSPReceivedBuffer )[ -OFFSETOF( CReadIOData, m_SPReceivedBuffer ) ] );
    	}

		//
		// functions for managing read IO data pool
		//
		BOOL	ReadIOData_Alloc( READ_IO_DATA_POOL_CONTEXT *const pContext );
		void	ReadIOData_Get( READ_IO_DATA_POOL_CONTEXT *const pContext );
		void	ReadIOData_Release( void );
		void	ReadIOData_Dealloc( void );

	private:
		void	ReturnSelfToPool( void );
		
		BYTE			m_Sig[4];	// debugging signature ('RIOD')
		
		volatile LONG	m_lRefCount;
		CThreadPool		*m_pThreadPool;
		SP_TYPE			m_AddressType;
	
		SPRECEIVEDBUFFER	m_SPReceivedBuffer;
		BYTE				m_ReceivedData[ MAX_MESSAGE_SIZE ];
		

		// prevent unwarranted copies
		CReadIOData( const CReadIOData & );
		CReadIOData& operator=( const CReadIOData & );
};

//
// all data for a write operation
//
class	CWriteIOData : public CIOData
{
	public:
		CWriteIOData();
		~CWriteIOData();

		CWriteIOData			*m_pNext;							// link to next write in the send queue (see CSendQueue)

		CBilink					m_OutstandingWriteListLinkage;		// links to the outstanding write list
		const CSocketAddress	*m_pDestinationSocketAddress;		// pointer to socket address of destination
		BUFFERDESC				*m_pBuffers;						// pointer to outgoing buffers
		UINT_PTR				m_uBufferCount;						// count of outgoing buffers
		CCommandData			*m_pCommand;						// associated command

		SEND_COMPLETE_ACTION	m_SendCompleteAction;	// enumerated value indicating the action to take
														// when a send completes

#ifdef WIN95
		HRESULT	m_Win9xSendHResult;
#endif
		DWORD	m_dwOverlappedBytesSent;
		DWORD	m_dwBytesSent;

		//
		// since the following is a packed structure, put it at the end
		// to preserve as much alignment as possible with the
		// above fields
		//
		PREPEND_BUFFER	m_PrependBuffer;				// optional data that may be prepeded on a write
		BUFFERDESC		m_ProxyEnumSendBuffers[ 2 ];	// static buffers used to send data in a proxied enum

		CReadIOData		*m_pProxiedEnumReceiveBuffer;

		#undef DPF_MODNAME
		#define DPF_MODNAME "CWriteIOData::WriteDataFromBilink"
		static CWriteIOData	*WriteDataFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CWriteIOData* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CWriteIOData*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CWriteIOData, m_OutstandingWriteListLinkage ) ] );
		}

		//
		// functions for managing write IO data pool
		//
		BOOL	WriteIOData_Alloc( WRITE_IO_DATA_POOL_CONTEXT *const pContext );
		void	WriteIOData_Get( WRITE_IO_DATA_POOL_CONTEXT *const pContext );
		void	WriteIOData_Release( void );
		void	WriteIOData_Dealloc( void );

	private:
		BYTE			m_Sig[4];	// debugging signature ('WIOD')
		
		// prevent unwarranted copies
		CWriteIOData( const CWriteIOData & );
		CWriteIOData& operator=( const CWriteIOData & );

};

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#undef DPF_MODNAME

#endif	// __IODATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\ipui.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPUI.h
 *  Content:	Winsock provider IP UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/15/1999	jtk		Derived from ComPortUI.h
 ***************************************************************************/

#ifndef __IP_UI_H__
#define __IP_UI_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
void	DisplayIPHostNameSettingsDialog( void *const pContext );
void	StopIPHostNameSettingsDialog( const HWND hDlg );

#endif	// __IP_UI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\ipui.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPUI.cpp
 *  Content:	Winsock service provider IP UI functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/15/1999	jtk		Dervied from ComPortUI.cpp
 ***************************************************************************/

#include "dnwsocki.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// expected return from IP dialog
//
static const INT_PTR	g_iExpectedIPDialogReturn = 0x12345678;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
static	INT_PTR CALLBACK	SettingsDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
static	HRESULT	SetIPHostName( const HWND hDlg, const CIPEndpoint *const pEndpoint );
static	HRESULT	GetDialogData( const HWND hDlg, CIPEndpoint *const pEndpoint );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// DisplayIPHostNameDialog - dialog for comport settings
//
// Entry:		Pointer to endpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DisplayIPHostNameSettingsDialog"

void	DisplayIPHostNameSettingsDialog( void *const pContext )
{
	CIPEndpoint	*pEndpoint;
	INT_PTR		iDlgReturn;

	
	DNASSERT( pContext != NULL );

	//
	// intialize
	//
	pEndpoint = static_cast<CIPEndpoint*>( pContext );
	DBG_CASSERT( sizeof( pEndpoint ) == sizeof( LPARAM ) );
	
	SetLastError( ERROR_SUCCESS );
	iDlgReturn = DialogBoxParam( g_hDLLInstance,						// handle of module for resources
								 MAKEINTRESOURCE( IDD_IP_SETTINGS ),	// resource for dialog
								 NULL,									// parent window (none)
								 SettingsDialogProc,					// dialog message proc
								 reinterpret_cast<LPARAM>( pEndpoint )	// startup parameter
								 );
	if ( iDlgReturn != g_iExpectedIPDialogReturn )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to start IP settings dialog!" );
		DisplayErrorCode( 0, dwError );
	
		pEndpoint->SettingsDialogComplete( DPNERR_OUTOFMEMORY );
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetopIPHostNameSettingsDialog - stop dialog dialog for serial settings
//
// Entry:		Handle of dialog
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "StopIPHostNameSettingsDialog"

void	StopIPHostNameSettingsDialog( const HWND hDlg )
{
	DNASSERT( hDlg != NULL );
	if ( PostMessage( hDlg, WM_COMMAND, MAKEWPARAM( IDCANCEL, NULL ), NULL ) == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to stop dialog!" );
		DisplayErrorCode( 0, dwError );
		DNASSERT( FALSE );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SettingsDialogProc - dialog proc serial settings
//
// Entry:		Window handle
//				Message
//				Message LPARAM
//				Message WPARAM
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SettingsDialogProc"

static	INT_PTR CALLBACK	SettingsDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	CIPEndpoint	*pEndpoint;
	HRESULT		hr;


	//
	// initialize
	//
	hr = DPN_OK;
	pEndpoint = NULL;

	//
	// Get the dialog context.  Note that the dialog context will be NULL
	// until the WM_INITDIALOG message is processed so the endpoint may note be
	// availble yet.
	//
	DBG_CASSERT( sizeof( pEndpoint ) == sizeof( LPARAM ) );
	pEndpoint = reinterpret_cast<CIPEndpoint*>( GetWindowLongPtr( hDlg, GWLP_USERDATA ) );

	switch ( uMsg )
	{
		//
		// initialize dialog
		//
		case WM_INITDIALOG:
		{
			//
			// since this is the first dialog message, the default code to set
			// pEndpoint isn't getting valid data
			//
			DBG_CASSERT( sizeof( pEndpoint ) == sizeof( lParam ) );
			pEndpoint = reinterpret_cast<CIPEndpoint*>( lParam );
			pEndpoint->SetActiveDialogHandle( hDlg );

			//
			// SetWindowLongPtr() returns NULL in case of error.  It's possible that
			// the old value from SetWindowLongPtr() was really NULL in which case it's not
			// an error.  To be safe, clear any residual error code before calling
			// SetWindowLongPtr().
			//
			SetLastError( 0 );
			if ( SetWindowLongPtr( hDlg, GWLP_USERDATA, lParam ) == NULL )
			{
				DWORD	dwError;


				dwError = GetLastError();
				if ( dwError != ERROR_SUCCESS )
				{
					DPFX(DPFPREP,  0, "Problem setting user data for window!" );
					DisplayErrorCode( 0, dwError );
					hr = DPNERR_GENERIC;
					goto Failure;
				}
			}

			//
			// set dialog parameters
			//
			if ( ( hr = SetIPHostName( hDlg, pEndpoint ) ) != DPN_OK )
			{
				DPFX(DPFPREP,  0,  "Problem setting device in WM_INITDIALOG!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			return	TRUE;

			break;
		}

		//
		// a control did something
		//
		case WM_COMMAND:
		{
			//
			// what was the control?
			//
			switch ( LOWORD( wParam ) )
			{
				case IDOK:
				{
					if ( ( hr = GetDialogData( hDlg, pEndpoint ) ) != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Problem getting UI data!" );
						DisplayDNError( 0, hr );
						goto Failure;
					}

					//
					// pass any error code on to 'DialogComplete'
					//
					pEndpoint->SettingsDialogComplete( hr );
					EndDialog( hDlg, g_iExpectedIPDialogReturn );

					break;
				}

				case IDCANCEL:
				{
					pEndpoint->SettingsDialogComplete( DPNERR_USERCANCEL );
					EndDialog( hDlg, g_iExpectedIPDialogReturn );

					break;
				}

				default:
				{
					break;
				}
			}

			break;
		}

		// window is closing
		case WM_CLOSE:
		{
			break;
		}
	}

Exit:
	return	FALSE;

Failure:
	DNASSERT( pEndpoint != NULL );
	DNASSERT( hr != DPN_OK );
	pEndpoint->SettingsDialogComplete( hr );
	EndDialog( hDlg, g_iExpectedIPDialogReturn );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// SetIPHostName - set hostname field
//
// Entry:		Window handle
//				Pointer to endpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "SetIPHostName"

static	HRESULT	SetIPHostName( const HWND hDlg, const CIPEndpoint *const pEndpoint )
{
	HRESULT	hr;
	HWND	hEditControl;


	//
	// initialize
	//
	hr = DPN_OK;
	hEditControl = GetDlgItem( hDlg, IDC_EDIT_IP_HOSTNAME );
	if ( hEditControl == NULL )
	{
		DWORD	dwErrorCode;


		hr = DPNERR_GENERIC;
		dwErrorCode = GetLastError();
		DPFX(DPFPREP,  0, "Problem getting handle of hostname edit control!" );
		DisplayErrorCode( 0, dwErrorCode );
		goto Failure;
	}

	//
	// set edit field limit (this message does not have a return result)
	//
	SendMessage( hEditControl, EM_LIMITTEXT, TEMP_HOSTNAME_LENGTH, 0 );

	//
	// add string to dialog
	//
	if ( SetWindowText( hEditControl, TEXT("") ) == FALSE )
	{
		DWORD	dwErrorCode;


		hr = DPNERR_OUTOFMEMORY;
		dwErrorCode = GetLastError();
		DPFX(DPFPREP,  0, "Problem setting IP hostname in dialog!" );
		DisplayErrorCode( 0, dwErrorCode );
		goto Failure;
	}

Failure:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetDialogData - set endpoint data from serial dialog
//
// Entry:		Window handle
//				Pointer to endpoint
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetDialogData"

static	HRESULT	GetDialogData( HWND hDlg, CIPEndpoint *pEndpoint )
{
	HRESULT		hr;
	UINT_PTR	uHostNameLength;
	TCHAR		HostName[ TEMP_HOSTNAME_LENGTH ];
	HWND		hEditControl;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// get control ID and then the host name
	//
	hEditControl = GetDlgItem( hDlg, IDC_EDIT_IP_HOSTNAME );
	if ( hEditControl == NULL )
	{
		DWORD	dwErrorCode;


		DNASSERT( FALSE );
		hr = DPNERR_OUTOFMEMORY;
		dwErrorCode = GetLastError();
		DPFX(DPFPREP,  0, "Failed to get control handle when attempting to read IP hostname!" );
		DisplayDNError( 0, dwErrorCode );
		goto Failure;
	}

	//
	// Clear the error since Japanese Windows 9x does not seem to set it properly.
	//
	SetLastError(0);
	
	uHostNameLength = GetWindowText( hEditControl, HostName, LENGTHOF( HostName ) );
	if ( uHostNameLength == 0 )
	{
		DWORD	dwErrorCode;


		//
		// zero, possible empty name or error
		//
		dwErrorCode = GetLastError();
		if ( dwErrorCode != ERROR_SUCCESS )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP,  0, "Failed to read hostname from dialog!" );
			DisplayErrorCode( 0, dwErrorCode );
			goto Failure;
		}
	}

	pEndpoint->SetTempHostName( HostName, uHostNameLength );

Failure:
	return	hr;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\ipxaddress.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPXAddress.h
 *  Content:	Winsock IPX address class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __IPX_ADDRESS_H__
#define __IPX_ADDRESS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CIPXAddress : public CSocketAddress
{
	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPXAddress::CIPXAddress"
		CIPXAddress()
		{
			DBG_CASSERT( sizeof( &m_SocketAddress.IPXSocketAddress ) == sizeof( SOCKADDR* ) );
			m_iSocketAddressSize = sizeof( m_SocketAddress.IPXSocketAddress );
			m_SocketAddress.IPXSocketAddress.sa_family = AF_IPX;
			m_iSocketProtocol = NSPROTO_IPX;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPXAddress::~CIPXAddress"
		~CIPXAddress()
		{
			DNASSERT( m_iSocketAddressSize == sizeof( m_SocketAddress.IPXSocketAddress ) );
			DNASSERT( m_SocketAddress.IPXSocketAddress.sa_family == AF_IPX );
			DNASSERT( m_iSocketProtocol == NSPROTO_IPX );
		}

		void	InitializeWithBroadcastAddress( void );
		void	SetAddressFromSOCKADDR( const SOCKADDR &Address, const INT_PTR iAddressSize );
		HRESULT	SocketAddressFromDP8Address( IDirectPlay8Address *const pDP8Address,
											 const SP_ADDRESS_TYPE AddressType );
		IDirectPlay8Address *DP8AddressFromSocketAddress( void ) const;

		INT_PTR	CompareFunction( const CSocketAddress *const pOtherAddress ) const;
		INT_PTR	HashFunction( const INT_PTR HashBitcount ) const;
		INT_PTR	CompareToBaseAddress( const SOCKADDR *const pBaseAddress ) const;

		HRESULT	EnumAdapters( SPENUMADAPTERSDATA *const pEnumData ) const;

		void	GuidFromInternalAddressWithoutPort( GUID &OutputGuid ) const;
		
		BOOL	IsUndefinedHostAddress( void ) const;
		void	ChangeLoopBackToLocalAddress( const CSocketAddress *const pOtherAddress );
		
		WORD	GetPort( void ) const { return m_SocketAddress.IPXSocketAddress.sa_socket; }
		void	SetPort( const WORD wPort ) { m_SocketAddress.IPXSocketAddress.sa_socket = wPort; }

		//
		// functions to create default addresses
		//
		IDirectPlay8Address *CreateBroadcastAddress( void );
		IDirectPlay8Address *CreateListenAddress( void );
		IDirectPlay8Address *CreateGenericAddress( void );

	protected:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPXAddress::AddressFromGuid"
		virtual void	AddressFromGuid( const GUID &InputGuid, SOCKADDR &SocketAddress ) const
		{
			DBG_CASSERT( sizeof( InputGuid ) == sizeof( SocketAddress ) );
			DecryptGuid( &InputGuid, reinterpret_cast<GUID*>( &SocketAddress ), &g_IPXSPEncryptionGuid );

			//
			// in the custom case of ALL_ADAPTERS_GUID, fix up the address family
			//
			if ( SocketAddress.sa_family == 0 )
			{
				DNASSERT( InputGuid == g_InvalidAdapterGuid );
				SocketAddress.sa_family = GetFamily();
			}
		}

	private:
		HRESULT	ParseHostName( const char *const pHostName, const DWORD dwHostNameLength );

		void	CopyInternalSocketAddressWithoutPort( SOCKADDR &AddressDestination ) const;

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPXAddress::GuidFromAddress"
		static void	GuidFromAddress( GUID &OutputGuid, const SOCKADDR &SocketAddress )
		{
			const SOCKADDR_IPX	*pSocketAddress = reinterpret_cast<const SOCKADDR_IPX*>( &SocketAddress );

		    DBG_CASSERT( sizeof( OutputGuid ) == sizeof( SocketAddress ) );
			DBG_CASSERT( sizeof( *pSocketAddress ) < sizeof( SocketAddress ) );
			memcpy( &OutputGuid, &SocketAddress, sizeof( *pSocketAddress ) );
			memset( &( reinterpret_cast<BYTE*>( &OutputGuid )[ sizeof( *pSocketAddress ) ] ), 0, ( sizeof( OutputGuid ) - sizeof( *pSocketAddress ) ) );
			EncryptGuid( &OutputGuid, &OutputGuid, &g_IPXSPEncryptionGuid );	
		}

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CIPXAddress( const CIPXAddress & );
		CIPXAddress& operator=( const CIPXAddress & );
};

#undef DPF_MODNAME

#endif	// __IPX_ADDRESS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\ipxendpt.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPXEndpt.cpp
 *  Content:	IPX endpoint endpoint class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXEndpoint::CIPXEndpoint - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPXEndpoint::CIPXEndpoint"

CIPXEndpoint::CIPXEndpoint():
	m_pOwningPool( NULL )
{
	m_Sig[0] = 'I';
	m_Sig[1] = 'P';
	m_Sig[2] = 'X';
	m_Sig[3] = 'E';
	
	m_pRemoteMachineAddress = &m_IPXAddress;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXEndpoint::~CIPXEndpoint - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPXEndpoint::~CIPXEndpoint"

CIPXEndpoint::~CIPXEndpoint()
{
	m_pRemoteMachineAddress = NULL;
	DNASSERT( m_pOwningPool == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXEndpoint::ShowSettingsDialog - show dialog for settings
//
// Entry:		Pointer to thread pool
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPXEndpoint::ShowSettingsDialog"

HRESULT	CIPXEndpoint::ShowSettingsDialog( CThreadPool *const pThreadPool )
{
	//
	// we should never be here!
	//
	DNASSERT( pThreadPool != NULL );
	DNASSERT( FALSE );
	return	DPNERR_ADDRESSING;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXEndpoint::SettingsDialogComplete - dialog has completed
//
// Entry:		Error code for dialog
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPXEndpoint::SettingsDialogComplete"

void	CIPXEndpoint::SettingsDialogComplete( const HRESULT hr )
{
	//
	// we should never be here!
	//
	DNASSERT( FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXEndpoint::StopSettingsDialog - stop active settings dialog
//
// Entry:		Handle of dialog to close
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPXEndpoint::StopSettingsDialog"

void	CIPXEndpoint::StopSettingsDialog( const HWND hDlg )
{
	//
	// we shold never have a dialog!
	//
	DNASSERT( FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXEndpoint::PoolAllocFunction - function called when item is created in pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPXEndpoint::PoolAllocFunction"

BOOL	CIPXEndpoint::PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pContext )
{
	BOOL	fReturn;
	HRESULT	hr;


	DNASSERT( pContext != NULL );
	
	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetCommandParameters() == NULL );
	
	hr = Initialize();
	if ( hr != DPN_OK )
	{
		fReturn = FALSE;
		DPFX(DPFPREP, 0, "Failed to intialize base endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	fReturn;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXEndpoint::PoolInitFunction - function called when item is removed from pool
//
// Entry:		Pointer to context
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPXEndpoint::PoolInitFunction"

BOOL	CIPXEndpoint::PoolInitFunction( ENDPOINT_POOL_CONTEXT *pContext )
{
	BOOL	fReturn;


	DNASSERT( pContext != NULL );
	DNASSERT( pContext->pSPData != NULL );

	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_pSPData == NULL );
	m_pSPData = pContext->pSPData;
	m_pSPData->ObjectAddRef();
	this->SetPendingCommandResult( DPNERR_GENERIC );
	this->SetEndpointID( pContext->dwEndpointID );

	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( m_blMultiplex.IsEmpty() );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetCommandParameters() == NULL );
	
	DEBUG_ONLY( m_fInitialized = TRUE );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXEndpoint::PoolReleaseFunction - function called when item is returning
//		to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPXEndpoint::PoolReleaseFunction"

void	CIPXEndpoint::PoolReleaseFunction( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DEBUG_ONLY( DNASSERT( m_fEndpointOpen == FALSE ) );

	m_EndpointType = ENDPOINT_TYPE_UNKNOWN;
	m_EnumKey.SetKey( INVALID_ENUM_KEY );

	DNASSERT( m_fConnectSignalled == FALSE );
	DNASSERT( m_State == ENDPOINT_STATE_UNINITIALIZED );
	DNASSERT( m_EndpointType == ENDPOINT_TYPE_UNKNOWN );
	DNASSERT( m_pRemoteMachineAddress != NULL );

	DNASSERT( m_pSPData != NULL );
	m_pSPData->ObjectDecRef();
	m_pSPData = NULL;

	m_pRemoteMachineAddress->Reset();

	DNASSERT( GetSocketPort() == NULL );
	DNASSERT( m_pUserEndpointContext == NULL );
	DNASSERT( GetActiveDialogHandle() == NULL );
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( m_blMultiplex.IsEmpty() );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetCommandParameters() == NULL );

	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXEndpoint::PoolDeallocFunction - function called when item is deallocated
//		from the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPXEndpoint::PoolDeallocFunction"

void	CIPXEndpoint::PoolDeallocFunction( void )
{
	DNASSERT( m_fListenStatusNeedsToBeIndicated == FALSE );
	DNASSERT( GetDisconnectIndicationHandle() == INVALID_HANDLE_VALUE );
	DNASSERT( GetCommandParameters() == NULL );
	Deinitialize();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXEndpoint::ReturnSelfToPool - return this endpoint to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CIPXEndpoint::ReturnSelfToPool"

void	CIPXEndpoint::ReturnSelfToPool( void )
{
	DNASSERT( this->GetEndpointID() == 0 );
	
	if ( CommandPending() != FALSE )
	{
		CompletePendingCommand( PendingCommandResult() );
	}

	if ( ConnectHasBeenSignalled() != FALSE )
	{
		SignalDisconnect( GetDisconnectIndicationHandle() );
	}

	DNASSERT( ConnectHasBeenSignalled() == FALSE );
	
	SetUserEndpointContext( NULL );
	m_pOwningPool->Release( this );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\jobqueue.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		JobQueue.cpp
 *  Content:	Job queue for use in the thread pool
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/21/2000	jtk		Created
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::CJobQueue - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::CJobQueue"

CJobQueue::CJobQueue():
	m_pQueueHead( NULL ),
	m_pQueueTail( NULL ),
	m_hPendingJob( NULL )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::~CJobQueue - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::~CJobQueue"

CJobQueue::~CJobQueue()
{
	DNASSERT( m_pQueueHead == NULL );
	DNASSERT( m_pQueueTail == NULL );
	DNASSERT( m_hPendingJob == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::Initialize - initialize
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::Initialize"

BOOL	CJobQueue::Initialize( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize critical section on job queue!" );
		goto Failure;
	}

	m_hPendingJob = CreateEvent( NULL,		// pointer to security attributes (none)
								 TRUE,		// manual reset
								 FALSE,		// start unsignalled
								 NULL );	// pointer to name (none)
	if ( m_hPendingJob == NULL )
	{
		DPFX(DPFPREP,  0, "Failed to create event for pending job!" );
		goto Failure;
	}

Exit:
	return	fReturn;

Failure:
	fReturn = FALSE;
	Deinitialize();

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::Deinitialize - deinitialize
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::Deinitialize"

void	CJobQueue::Deinitialize( void )
{
	DNASSERT( m_pQueueHead == NULL );
	DNASSERT( m_pQueueTail == NULL );
	DNDeleteCriticalSection( &m_Lock );

	if ( m_hPendingJob != NULL )
	{
		if ( CloseHandle( m_hPendingJob ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem closing job queue handle" );
			DisplayErrorCode( 0, dwError );
		}

		m_hPendingJob = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::SignalPendingJob - set flag to signal a pending job
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::SignalPendingJob"

BOOL	CJobQueue::SignalPendingJob( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;

	if ( SetEvent( GetPendingJobHandle() ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Cannot set event for pending job!" );
		DisplayErrorCode( 0, dwError );
		fReturn = FALSE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::EnqueueJob - add a job to the job list
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::EnqueueJob"

void	CJobQueue::EnqueueJob( THREAD_POOL_JOB *const pJob )
{
	DNASSERT( pJob != NULL );

	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	if ( m_pQueueTail != NULL )
	{
		DNASSERT( m_pQueueHead != NULL );
		DNASSERT( m_pQueueTail->pNext == NULL );
		m_pQueueTail->pNext = pJob;
	}
	else
	{
		m_pQueueHead = pJob;
	}

	m_pQueueTail = pJob;
	pJob->pNext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CJobQueue::DequeueJob - remove job from job queue
//
// Entry:		Nothing
//
// Exit:		Pointer to job
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CJobQueue::DequeueJob"

THREAD_POOL_JOB	*CJobQueue::DequeueJob( void )
{
	THREAD_POOL_JOB	*pJob;


	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
	
	pJob = NULL;
	
	if ( m_pQueueHead != NULL )
	{
		pJob = m_pQueueHead;
		m_pQueueHead = pJob->pNext;
		if ( m_pQueueHead == NULL )
		{
			DNASSERT( m_pQueueTail == pJob );
			m_pQueueTail = NULL;
		}

		DEBUG_ONLY( pJob->pNext = NULL );
	}

	return	pJob;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\ipxaddress.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPXAddress.cpp
 *  Content:	Winsock IPX address class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// length of IPX host names 'xxxxxxxx,xxxxxxxxxxxx' including NULL
//
#define	IPX_ADDRESS_STRING_LENGTH	22

//
// default buffer size to use when parsing address components
//
#define	DEFAULT_COMPONENT_BUFFER_SIZE	1000

//
// default broadcast and listen addresses
//
static const WCHAR	g_IPXBroadcastAddress[] = L"00000000,FFFFFFFFFFFF";
static const WCHAR	g_IPXListenAddress[] = L"00000000,000000000000";

//
// string used for single IPX adapter
//
static const char	g_IPXAdapterString[] = "Local IPX Adapter";

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::InitializeWithBroadcastAddress - initialize with the broadcast address
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::InitializeWithBroadcastAddress"

void	CIPXAddress::InitializeWithBroadcastAddress( void )
{
	DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress.sa_netnum ) == sizeof( DWORD ) );
	*reinterpret_cast<DWORD*>( m_SocketAddress.IPXSocketAddress.sa_netnum ) = 0x00000000;
	
	DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress.sa_nodenum ) == 6 );
	DBG_CASSERT( sizeof( DWORD ) == 4 );
	*reinterpret_cast<DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum ) = 0xFFFFFFFF;
	*reinterpret_cast<DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum[ 2 ] ) = 0xFFFFFFFF;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CIPXAddress::SetAddressFromSOCKADDR - set address from a socket address
//
// Entry:		Reference to address
//				Size of address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::SetAddressFromSOCKADDR"

void	CIPXAddress::SetAddressFromSOCKADDR( const SOCKADDR &Address, const INT_PTR iAddressSize )
{
	DNASSERT( iAddressSize == GetAddressSize() );
	DNASSERT( iAddressSize == GetAddressSize() );
	memcpy( &m_SocketAddress.SocketAddress, &Address, iAddressSize );

	//
	// IPX addresses are only 14 of the 16 bytes in the socket address structure,
	// make sure the exrta bytes are zero!
	//
	DNASSERT( m_SocketAddress.SocketAddress.sa_data[ 12 ] == 0 );
	DNASSERT( m_SocketAddress.SocketAddress.sa_data[ 13 ] == 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::SocketAddressFromDP8Address - convert a DP8Address into a socket address
//											NOTE: The address object may be modified
//
// Entry:		Pointer to DP8Address
//				Address type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::SocketAddressFromDP8Address"

HRESULT	CIPXAddress::SocketAddressFromDP8Address( IDirectPlay8Address *const pDP8Address, const SP_ADDRESS_TYPE AddressType )
{
	HRESULT	    hr;
	char		*pHostNameBuffer;
	DWORD		dwWCharHostNameSize;
	//IDirectPlay8Address		*pDuplicateAddress;


	DNASSERT( pDP8Address != NULL );


	//
	// initialize
	//
	hr = DPN_OK;
	//pDuplicateAddress = NULL;
	pHostNameBuffer = NULL;
	dwWCharHostNameSize = 0;

	//
	// the address type will determine how the address is handled
	//
	switch ( AddressType )
	{
		//
		// local device address, ask for the device guid and port to build a socket
		// address
		//
		case SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET:
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		{
			HRESULT	hTempResult;
			DWORD	dwTempSize;
			GUID	AdapterGuid;
			DWORD	dwPort;
			DWORD	dwDataType;
			union
			{
				SOCKADDR		SocketAddress;
				SOCKADDR_IPX	IPXSocketAddress;
			} NetAddress;


			//
			// Ask for the adapter guid.  If none is found, fail.
			//
			dwTempSize = sizeof( AdapterGuid );
			hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_DEVICE, &AdapterGuid, &dwTempSize, &dwDataType );
			switch ( hTempResult )
			{
				//
				// ok
				//
				case DPN_OK:
				{
					DNASSERT( dwDataType == DPNA_DATATYPE_GUID );
					break;
				}

				//
				// remap missing component to 'addressing' error
				//
				case DPNERR_DOESNOTEXIST:
				{
					hr = DPNERR_ADDRESSING;
					goto Failure;
					break;
				}

				default:
				{
					hr = hTempResult;
					goto Failure;
					break;
				}
			}
			DNASSERT( sizeof( AdapterGuid ) == dwTempSize );

			//
			// Ask for the port.  If none is found, choose a default.
			//
			dwTempSize = sizeof( dwPort );
			hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
			switch ( hTempResult )
			{
				//
				// port present, nothing to do
				//
				case DPN_OK:
				{
					DNASSERT( dwDataType == DPNA_DATATYPE_DWORD );
					break;
				}

				//
				// port not present, fill in the appropriate default
				//
				case DPNERR_DOESNOTEXIST:
				{
					DNASSERT( hr == DPN_OK );
					switch ( AddressType )
					{
						case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
						{
							dwPort = ANY_PORT;
							break;
						}

						default:
						{
							DNASSERT( FALSE );
							break;
						}
					}

					break;
				}

				//
				// other error, fail
				//
				default:
				{
					hr = hTempResult;
					goto Failure;
					break;
				}
			}
			DNASSERT( sizeof( dwPort ) == dwTempSize );

			//
			// convert the GUID to an address in temp space because the GUID contains ALL address information (port, etc)
			// and we don't want to blindly wail on any information that might have already been set.  Verify data
			// integrity and then only copy the raw address.
			//
			AddressFromGuid( AdapterGuid, NetAddress.SocketAddress );
			if ( NetAddress.IPXSocketAddress.sa_family != m_SocketAddress.IPXSocketAddress.sa_family )
			{
				DNASSERT( FALSE );
				hr = DPNERR_ADDRESSING;
				DPFX(DPFPREP,  0, "Invalid device guid!" );
				goto Exit;
			}

			DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress ) == sizeof( NetAddress.IPXSocketAddress ) );
			memcpy( &m_SocketAddress.IPXSocketAddress, &NetAddress.IPXSocketAddress, sizeof( m_SocketAddress.IPXSocketAddress ) );
			m_SocketAddress.IPXSocketAddress.sa_socket = p_htons( static_cast<WORD>( dwPort ) );
			break;
		}

		//
		// hostname
		//
		case SP_ADDRESS_TYPE_HOST:
		{
			HRESULT	hTempResult;
			DWORD	dwPort;
			DWORD	dwTempSize;
			DWORD	dwDataType;


			/*
			//
			// duplicate the input address because it might need to be modified
			//
			DNASSERT( pDuplicateAddress == NULL );
			IDirectPlay8Address_Duplicate( pDP8Address, &pDuplicateAddress );
			if ( pDuplicateAddress == NULL )
			{
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}
			*/
			

			//
			// Ask for the port.  If none is found, choose a default.
			//
			dwTempSize = sizeof( dwPort );
			//hTempResult = IDirectPlay8Address_GetComponentByName( pDuplicateAddress, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
			hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
			switch ( hTempResult )
			{
				//
				// port present, nothing to do
				//
				case DPN_OK:
				{
					DNASSERT( dwDataType == DPNA_DATATYPE_DWORD );
					m_SocketAddress.IPXSocketAddress.sa_socket = p_htons( static_cast<WORD>( dwPort ) );
					break;
				}

				//
				// port not present, fill in the appropriate default
				//
				case DPNERR_DOESNOTEXIST:
				{
					const DWORD	dwTempPort = DPNA_DPNSVR_PORT;


					m_SocketAddress.IPXSocketAddress.sa_socket = p_htons( static_cast<const WORD>( dwTempPort ) );
					//hTempResult = IDirectPlay8Address_AddComponent( pDuplicateAddress,
					hTempResult = IDirectPlay8Address_AddComponent( pDP8Address,
																	DPNA_KEY_PORT,
																	&dwTempPort,
																	sizeof( dwTempPort ),
																	DPNA_DATATYPE_DWORD
																	);
					if ( hTempResult != DPN_OK )
					{
						hr = hTempResult;
						goto Failure;
					}

					break;
				}

				//
				// remap everything else to an addressing failure
				//
				default:
				{
					hr = DPNERR_ADDRESSING;
					goto Failure;
				}
			}

			//
			// attempt to determine host name
			//
			dwWCharHostNameSize = 0;
			//hr = IDirectPlay8Address_GetComponentByName( pDuplicateAddress, DPNA_KEY_HOSTNAME, pHostNameBuffer, &dwWCharHostNameSize, &dwDataType );
			hr = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_HOSTNAME, pHostNameBuffer, &dwWCharHostNameSize, &dwDataType );
			switch ( hr )
			{
				//
				// keep the following codes and fail
				//
				case DPNERR_OUTOFMEMORY:
				case DPNERR_INCOMPLETEADDRESS:
				{
					goto Failure;
					break;
				}

				//
				// Buffer too small.  Allocate a buffer large enough to store both
				// the Unicode and ASCII versions of the hostname and then attempt
				// to parse the hostname.
				//
				case DPNERR_BUFFERTOOSMALL:
				{
					DWORD	dwAnsiHostNameSize;
					DWORD	dwTempAnsiHostNameSize;
					DWORD	dwTempWCharHostNameSize;
					DWORD	dwTempDataType;


					dwAnsiHostNameSize = dwWCharHostNameSize / sizeof( WCHAR );
					dwTempWCharHostNameSize = dwWCharHostNameSize + dwAnsiHostNameSize;
					pHostNameBuffer = static_cast<char*>( DNMalloc( dwTempWCharHostNameSize ) );
					if ( pHostNameBuffer == NULL )
					{
						hr = DPNERR_OUTOFMEMORY;
						DPFX(DPFPREP,  0, "IPXAddressFromDP8Address: Failed to allocate memory for hostname!" );
						goto Failure;
					}

					//hr = IDirectPlay8Address_GetComponentByName( pDuplicateAddress, DPNA_KEY_HOSTNAME, pHostNameBuffer, &dwTempWCharHostNameSize, &dwTempDataType );
					hr = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_HOSTNAME, pHostNameBuffer, &dwTempWCharHostNameSize, &dwTempDataType );
					switch( hr )
					{
						//
						// no problem
						//
						case DPN_OK:
						{
							DNASSERT( dwTempDataType == DPNA_DATATYPE_STRING );
							DNASSERT( dwTempWCharHostNameSize == dwWCharHostNameSize );
							break;
						}

						//
						// return these error codes unmodified
						//
						case DPNERR_OUTOFMEMORY:
						{
							goto Failure;
							break;
						}

						//
						// remap other errors to an addressing error
						//
						default:
						{
							DNASSERT( FALSE );
							hr = DPNERR_ADDRESSING;
							goto Failure;
							break;
						}
					}

					//
					// convert host name to ANSI, ASSERT that we had just enough space
					//
					DNASSERT( dwAnsiHostNameSize == ( dwWCharHostNameSize / sizeof( WCHAR ) ) );
					dwTempAnsiHostNameSize = dwAnsiHostNameSize;
					hr = STR_WideToAnsi( reinterpret_cast<WCHAR*>( pHostNameBuffer ), -1, &pHostNameBuffer[ dwWCharHostNameSize ], &dwTempAnsiHostNameSize );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "IPXAddressFromDP8Address: Failed to convert hostname to ANSI!" );
						DisplayDNError( 0, hr );
						goto Failure;
					}
					DNASSERT( dwTempAnsiHostNameSize == dwAnsiHostNameSize );

					//
					// convert the text host name into the SOCKADDR structure
					//
					hr = ParseHostName( &pHostNameBuffer[ dwWCharHostNameSize ], dwAnsiHostNameSize );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "IPXAddressFromDP8Address: Failed to parse IPX host name!" );
						goto Failure;
					}

					break;
				}

				//
				// hostname does not exist, treat as an incomplete address
				//
				case DPNERR_DOESNOTEXIST:
				{
					hr = DPNERR_INCOMPLETEADDRESS;
					break;
				}

				//
				// other problem, remap to addressing failure.  We're expecting
				// a 'buffer too small' error so success here is treated as an
				// error.
				//
				case DPN_OK:
				default:
				{
					hr = DPNERR_ADDRESSING;
					goto Failure;
					break;
				}
			}

			break;
		}

		//
		// unknown address type
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// now that the address has been completely parsed, set the address type
	//
	m_AddressType = AddressType;

Exit:
	if ( pHostNameBuffer != NULL )
	{
		DNFree( pHostNameBuffer );
		pHostNameBuffer = NULL;
	}

	/*
	if ( pDuplicateAddress != NULL )
	{
		IDirectPlay8Address_Release( pDuplicateAddress );
		pDuplicateAddress = NULL;
	}
	*/

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with IPXAddress::SocketAddressFromDNAddress()" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::DP8AddressFromSocketAddress - convert a socket address into a DP8Address
//
// Entry:		Nothing
//
// Exit:		Pointer to DP8Address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::DP8AddressFromSocketAddress"

IDirectPlay8Address *CIPXAddress::DP8AddressFromSocketAddress( void ) const
{
	HRESULT	    hr;
	IDirectPlay8Address	*pDP8Address;
	DWORD		dwPort;


	//
	// intialize
	//
	hr = DPN_OK;
	pDP8Address = NULL;

	//
	// create and initialize the address
	//
	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address,
						   NULL,
						   CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Address,
						   reinterpret_cast<void**>( &pDP8Address ) );
	if ( hr != S_OK )
	{
		DNASSERT( pDP8Address == NULL );
		DPFX(DPFPREP,  0, "DP8AddressFromSocketAddress: Failed to create DP8Address when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	//
	// set SP
	//
	hr = IDirectPlay8Address_SetSP( pDP8Address, &CLSID_DP8SP_IPX );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "DP8AddressFromSocketAddress: Failed to set SP type!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// add on the port because it's always set
	//
	dwPort = p_ntohs( m_SocketAddress.IPXSocketAddress.sa_socket );
	hr = IDirectPlay8Address_AddComponent( pDP8Address, DPNA_KEY_PORT, &dwPort, sizeof( dwPort ), DPNA_DATATYPE_DWORD );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "DP8AddressFromSocketAddress: Failed to set port!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// add on the device or hostname depending on what type of address this is
	//
	switch ( m_AddressType )
	{
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		{
			GUID		DeviceGuid;


			GuidFromInternalAddressWithoutPort( DeviceGuid );
			hr = IDirectPlay8Address_AddComponent( pDP8Address,
												   DPNA_KEY_DEVICE,
												   &DeviceGuid,
												   sizeof( DeviceGuid ),
												   DPNA_DATATYPE_GUID );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0, "DP8AddressFromSocketAddress: Failed to add device!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			break;
		}

		//
		// host address type
		//
		case SP_ADDRESS_TYPE_READ_HOST:
		case SP_ADDRESS_TYPE_HOST:
		{
			char    HostName[ 255 ];
			WCHAR	WCharHostName[ sizeof( HostName ) ];
			DWORD   dwHostNameLength;
			DWORD	dwWCharHostNameLength;


			//
			// remove constness of parameter for broken Socket API
			//
			dwHostNameLength = LENGTHOF( HostName );
			if ( IPXAddressToStringNoSocket( const_cast<SOCKADDR*>( &m_SocketAddress.SocketAddress ),
											 sizeof( m_SocketAddress.IPXSocketAddress ),
											 HostName,
											 &dwHostNameLength
											 ) != 0 )
			{
				DPFERR("Error returned from IPXAddressToString");
				hr = DPNERR_ADDRESSING;
				goto Exit;
			}

			//
			// convert ANSI host name to WCHAR
			//
			dwWCharHostNameLength = LENGTHOF( WCharHostName );
			hr = STR_AnsiToWide( HostName, -1, WCharHostName, &dwWCharHostNameLength );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0, "DP8AddressFromSocketAddress: Failed to convert hostname to WCHAR!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			hr = IDirectPlay8Address_AddComponent( pDP8Address,
												   DPNA_KEY_HOSTNAME,
												   WCharHostName,
												   dwWCharHostNameLength * sizeof( WCHAR ),
												   DPNA_DATATYPE_STRING );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0, "DP8AddressFromSocketAddress: Failed to add hostname!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			break;
		}

		//
		// unknown address type
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

Exit:
	return	pDP8Address;

Failure:
	if ( pDP8Address != NULL )
	{
		IDirectPlay8Address_Release( pDP8Address );
		pDP8Address = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::CompareFunction - compare against another address
//
// Entry:		Pointer to other address
//
// Exit:		Integer indicating relative magnitude:
//				0 = items equal
//				-1 = other item is of greater magnitude
//				1 = this item is of lesser magnitude
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::CompareFunction"

INT_PTR	CIPXAddress::CompareFunction( const CSocketAddress *const pOtherAddress ) const
{
	const CIPXAddress *const pIPXAddress = static_cast<const CIPXAddress*>( pOtherAddress );


	DNASSERT( pOtherAddress != NULL );
	DNASSERT( m_SocketAddress.IPXSocketAddress.sa_family == pIPXAddress->m_SocketAddress.IPXSocketAddress.sa_family );

	//
	// We only need to compare:
	//	netnumber (IPX network address) [ 4 bytes ]
	//	nodenumber (netcard adapter address) [ 6 bytes ]
	// 	port [ 2 bytes ]
	//
	// Note that the nodenumber and port fields are sequentially arranged in the
	// address structure and can be compared with DWORDs
	//
	DBG_CASSERT( OFFSETOF( SOCKADDR_IPX, sa_nodenum ) == ( OFFSETOF( SOCKADDR_IPX, sa_netnum ) + sizeof( m_SocketAddress.IPXSocketAddress.sa_netnum ) ) );
	DBG_CASSERT( OFFSETOF( SOCKADDR_IPX, sa_socket ) == ( OFFSETOF( SOCKADDR_IPX, sa_nodenum ) + sizeof( m_SocketAddress.IPXSocketAddress.sa_nodenum ) ) );
	
	return	memcmp( &m_SocketAddress.IPXSocketAddress.sa_netnum,
					pIPXAddress->m_SocketAddress.IPXSocketAddress.sa_netnum,
					( sizeof( m_SocketAddress.IPXSocketAddress.sa_netnum ) +
					  sizeof( m_SocketAddress.IPXSocketAddress.sa_nodenum ) +
					  sizeof( m_SocketAddress.IPXSocketAddress.sa_socket ) ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::EnumAdapters - enumerate all of the adapters for this machine
//
// Entry:		Pointer to enum adapters data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::EnumAdapters"

HRESULT	CIPXAddress::EnumAdapters( SPENUMADAPTERSDATA *const pEnumData ) const
{
	HRESULT			hr;
	CPackedBuffer	PackedBuffer;
	SOCKET			TestSocket;
	INT				iWSAReturn;
	DWORD			dwAddressCount;
	union
	{
		SOCKADDR_IPX	IPXSocketAddress;
		SOCKADDR		SocketAddress;
	} SockAddr;

	
	DNASSERT( pEnumData != NULL );

	//
	// initialize
	//
	DEBUG_ONLY( memset( pEnumData->pAdapterData, 0xAA, pEnumData->dwAdapterDataSize ) );
	hr = DPN_OK;
	PackedBuffer.Initialize( pEnumData->pAdapterData, pEnumData->dwAdapterDataSize );
	pEnumData->dwAdapterCount = 0;
	TestSocket = INVALID_SOCKET;
	dwAddressCount = 0;

	//
	// create a socket and attempt to query for all of the IPX addresses.  If
	// that fails, fall back to using just the address from 'getsockname'.
	//
	TestSocket = p_socket( GetFamily(), SOCK_DGRAM, NSPROTO_IPX );
	if ( TestSocket == INVALID_SOCKET )
	{
		DWORD	dwWSAError;


		hr = DPNERR_UNSUPPORTED;
		dwWSAError = p_WSAGetLastError();
		DPFX(DPFPREP,  0, "Failed to create IPX socket when enumerating adapters!" );
		DisplayWinsockError( 0, dwWSAError );
		goto Failure;
	}

	memset( &SockAddr, 0x00, sizeof( SockAddr ) );
	SockAddr.IPXSocketAddress.sa_family = GetFamily();
	
	iWSAReturn = p_bind( TestSocket, &SockAddr.SocketAddress, sizeof( SockAddr.IPXSocketAddress ) );
	if ( iWSAReturn == SOCKET_ERROR )
	{
		DWORD	dwWSAError;


		hr = DPNERR_OUTOFMEMORY;
		dwWSAError = p_WSAGetLastError();
		DPFX(DPFPREP,  0, "Failed to bind IPX socket when enumerating adapters!" );
		DisplayWinsockError( 0, dwWSAError );
		goto Failure;
	}

//
// NOTE: THE CODE TO EXTRACT ALL IPX ADDRESSES ON NT HAS BEEN DISABLED BECAUSE
// NT TREATS ALL OF THEM AS THE SAME ONCE THEY ARE BOUND TO THE NETWORK.  IF THE
// CORE IS ATTEMPTING TO BIND TO ALL ADAPTERS THIS WILL CAUSE ALL OF THE BINDS
// AFTER THE FIRST TO FAIL!
//

//	iIPXAdapterCount = 0;
//	iIPXAdapterCountSize = sizeof( iIPXAdapterCount );
//	iWSAReturn = p_getsockopt( TestSocket,
//			    			   NSPROTO_IPX,
//			    			   IPX_MAX_ADAPTER_NUM,
//			    			   reinterpret_cast<char*>( &iIPXAdapterCount ),
//			    			   &iIPXAdapterCountSize );
//	if ( iWSAReturn != 0 )
//	{
//		DWORD   dwWSAError;
//
//
//		dwWSAError = p_WSAGetLastError();
//		switch ( dwWSAError )
//		{
//			//
//			// can't enumerate adapters on this machine, fallback to getsockname()
//			//
//			case WSAENOPROTOOPT:
//			{
				INT		iReturn;
				INT		iSocketNameSize;
				union
				{
					SOCKADDR		SocketAddress;
					SOCKADDR_IPX	SocketAddressIPX;
				} SocketAddress;


				memset( &SocketAddress, 0x00, sizeof( SocketAddress ) );
				iSocketNameSize = sizeof( SocketAddress );
				iReturn = p_getsockname( TestSocket, &SocketAddress.SocketAddress, &iSocketNameSize );
				if ( iReturn != 0 )
				{
					DWORD	dwWSAError;


					hr = DPNERR_OUTOFMEMORY;
					dwWSAError = p_WSAGetLastError();
					DPFX(DPFPREP, 0, "Failed to get socket name enumerating IPX sockets!", dwWSAError );
					goto Failure;
				}
				else
				{
					GUID	SocketAddressGUID;


					SocketAddress.SocketAddressIPX.sa_socket = 0;
					GuidFromAddress( SocketAddressGUID, SocketAddress.SocketAddress );
					hr = AddNetworkAdapterToBuffer( &PackedBuffer, g_IPXAdapterString, &SocketAddressGUID );
					if ( ( hr != DPN_OK ) && ( hr != DPNERR_BUFFERTOOSMALL ) )
					{
						DPFX(DPFPREP, 0, "Failed to add adapter (getsockname)!" );
						DisplayDNError( 0, hr );
						goto Failure;
					}

					dwAddressCount++;
				}
				
//	    		break;
//	    	}
//
//	    	//
//	    	// other Winsock error
//	    	//
//	    	default:
//	    	{
//	    		DWORD	dwWSAError;
//
//
//	    		hr = DPNERR_OUTOFMEMORY;
//	    		dwWSAError = p_WSAGetLastError();
//	    		DPFX(DPFPREP,  0, "Failed to get IPX adapter count!" );
//	    		DisplayWinsockError( 0, dwWSAError );
//	    		goto Failure;
//
//	    		break;
//	    	}
//	    }
//	}
//	else
//	{
//	    while ( iIPXAdapterCount != 0 )
//	    {
//	    	IPX_ADDRESS_DATA	IPXData;
//	    	int					iIPXDataSize;
//
//
//	    	iIPXAdapterCount--;
//	    	memset( &IPXData, 0x00, sizeof( IPXData ) );
//	    	iIPXDataSize = sizeof( IPXData );
//	    	IPXData.adapternum = iIPXAdapterCount;
//
//	    	iWSAReturn = p_getsockopt( TestSocket,
//	    							   NSPROTO_IPX,
//	    							   IPX_ADDRESS,
//	    							   reinterpret_cast<char*>( &IPXData ),
//	    							   &iIPXDataSize );
//	    	if ( iWSAReturn != 0 )
//	    	{
//	    		DPFX(DPFPREP,  0, "Failed to get adapter information for adapter: 0x%x", ( iIPXAdapterCount + 1 ) );
//	    	}
//	    	else
//	    	{
//	    		char	Buffer[ 500 ];
//	    		GUID	SocketAddressGUID;
//	    		union
//	    		{
//	    			SOCKADDR_IPX	IPXSocketAddress;
//	    			SOCKADDR		SocketAddress;
//	    		} SocketAddress;
//
//
//	    		wsprintf( Buffer,
//	    				  "IPX Adapter %d - (%02X%02X%02X%02X-%02X%02X%02X%02X%02X%02X)",
//	    				  ( iIPXAdapterCount + 1 ),
//	    				  IPXData.netnum[ 0 ],
//	    				  IPXData.netnum[ 1 ],
//	    				  IPXData.netnum[ 2 ],
//	    				  IPXData.netnum[ 3 ],
//	    				  IPXData.nodenum[ 0 ],
//	    				  IPXData.nodenum[ 1 ],
//	    				  IPXData.nodenum[ 2 ],
//	    				  IPXData.nodenum[ 3 ],
//	    				  IPXData.nodenum[ 4 ],
//	    				  IPXData.nodenum[ 5 ] );
//
//	    		memset( &SocketAddress, 0x00, sizeof( SocketAddress ) );
//	    		SocketAddress.IPXSocketAddress.sa_family = GetFamily();
//	    		DBG_CASSERT( sizeof( SocketAddress.IPXSocketAddress.sa_netnum ) == sizeof( IPXData.netnum ) );
//	    		memcpy( &SocketAddress.IPXSocketAddress.sa_netnum, IPXData.netnum, sizeof( SocketAddress.IPXSocketAddress.sa_netnum ) );
//	    		DBG_CASSERT( sizeof( SocketAddress.IPXSocketAddress.sa_nodenum ) == sizeof( IPXData.nodenum ) );
//	    		memcpy( &SocketAddress.IPXSocketAddress.sa_nodenum, IPXData.nodenum, sizeof( SocketAddress.IPXSocketAddress.sa_nodenum ) );
//	    		GuidFromAddress( SocketAddressGUID, SocketAddress.SocketAddress );
//
//	    		hr = AddNetworkAdapterToBuffer( &PackedBuffer, Buffer, &SocketAddressGUID );
//	    		if ( ( hr != DPN_OK ) && ( hr != DPNERR_BUFFERTOOSMALL ) )
//	    		{
//	    			DPFX(DPFPREP,  0, "Failed to add adapter (getsockname)!" );
//	    			DisplayDNError( 0, hr );
//	    			goto Failure;
//	    		}
//
//	    		dwAddressCount++;
//	    	}
//	    }
//	}

//	//
//	// if there was one adapter added, we can return 'All Adapters'
//	//
//	if ( dwAddressCount != 0 )
//	{
//	    dwAddressCount++;
//	    hr = AddNetworkAdapterToBuffer( &PackedBuffer, g_AllAdaptersString, &ALL_ADAPTERS_GUID );
//	    if ( ( hr != DPN_OK ) && ( hr != DPNERR_BUFFERTOOSMALL ) )
//	    {
//	    	DPFX(DPFPREP,  0, "Failed to add 'All Adapters'" );
//	    	DisplayDNError( 0, hr );
//	    	goto Failure;
//	    }
//	}

	pEnumData->dwAdapterCount = dwAddressCount;
	pEnumData->dwAdapterDataSize = PackedBuffer.GetSizeRequired();

Exit:
	if ( TestSocket != INVALID_SOCKET )
	{
		p_closesocket( TestSocket );
		TestSocket = INVALID_SOCKET;
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::GuidFromInternalAddressWithoutPort - get a guid from the internal
//		address without a port.
//
// Entry:		Reference to desintation GUID
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::GuidFromInternalAddressWithoutPort"

void	CIPXAddress::GuidFromInternalAddressWithoutPort( GUID &OutputGuid ) const
{
	union
	{
		SOCKADDR	SockAddr;
		SOCKADDR_IPX	IPXSockAddr;
	} TempSocketAddress;


	DBG_CASSERT( sizeof( TempSocketAddress.SockAddr ) == sizeof( m_SocketAddress.SocketAddress ) );
	memcpy( &TempSocketAddress.SockAddr, &m_SocketAddress.SocketAddress, sizeof( TempSocketAddress.SockAddr ) );
	TempSocketAddress.IPXSockAddr.sa_socket = 0;
	GuidFromAddress( OutputGuid, TempSocketAddress.SockAddr );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::IsUndefinedHostAddress - determine if this is an undefined host
//		address
//
// Entry:		Nothing
//
// Exit:		Boolean indicating whether this is an undefined host address
//				TRUE = this is an undefined address
//				FALSE = this is not an undefined address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::IsUndefinedHostAddress"

BOOL	CIPXAddress::IsUndefinedHostAddress( void ) const
{
	BOOL	fReturn;


	fReturn = FALSE;
	
	DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress.sa_netnum ) == sizeof( DWORD ) );
	DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress.sa_nodenum ) == 6 );
	if ( ( *reinterpret_cast<const DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_netnum ) == 0 ) &&
		 ( *reinterpret_cast<const DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum ) == 0 ) &&
		 ( *reinterpret_cast<const DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum[ 2 ] ) == 0 ) )
	{
		fReturn = TRUE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::ChangeLoopBackToLocalAddress - change loopback to a local address
//
// Entry:		Pointer to other address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::ChangeLoopBackToLocalAddress"

void	CIPXAddress::ChangeLoopBackToLocalAddress( const CSocketAddress *const pOtherSocketAddress )
{
	DNASSERT( pOtherSocketAddress != NULL );
	//
	// there is no 'loopback' for IPX so this function doesn't do anything
	//
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::CreateBroadcastAddress - create DP8Address used for broadcast sends
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::CreateBroadcastAddress"

IDirectPlay8Address *CIPXAddress::CreateBroadcastAddress( void )
{
	HRESULT	hr;
	IDirectPlay8Address		*pDPlayAddress;
	const DWORD		dwPort = DPNA_DPNSVR_PORT;


	//
	// initialize
	//
	pDPlayAddress = NULL;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
	if ( hr != S_OK )
	{
		DNASSERT( pDPlayAddress == NULL );
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = IDirectPlay8Address_SetSP( pDPlayAddress, &CLSID_DP8SP_IPX );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to set SP type!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	hr = IDirectPlay8Address_AddComponent( pDPlayAddress, DPNA_KEY_HOSTNAME, g_IPXBroadcastAddress, sizeof( g_IPXBroadcastAddress ), DPNA_DATATYPE_STRING );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to set hostname!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	hr = IDirectPlay8Address_AddComponent( pDPlayAddress, DPNA_KEY_PORT, &dwPort, sizeof( dwPort ), DPNA_DATATYPE_DWORD );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to set port!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	pDPlayAddress;

Failure:
	if ( pDPlayAddress != NULL )
	{
		IDirectPlay8Address_Release( pDPlayAddress );
		pDPlayAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::CreateListenAddress - create DP8Address used for listens
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::CreateListenAddress"

IDirectPlay8Address *CIPXAddress::CreateListenAddress( void )
{
	HRESULT	hr;
	IDirectPlay8Address		*pDPlayAddress;
	const DWORD		dwPort = ANY_PORT;


	//
	// initialize
	//
	pDPlayAddress = NULL;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address, reinterpret_cast<void**>( &pDPlayAddress ) );
	if ( hr != S_OK )
	{
		DNASSERT( pDPlayAddress == NULL );
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = IDirectPlay8Address_SetSP( pDPlayAddress, &CLSID_DP8SP_IPX );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to set SP type!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	hr = IDirectPlay8Address_AddComponent( pDPlayAddress, DPNA_KEY_HOSTNAME, g_IPXListenAddress, sizeof( g_IPXListenAddress ), DPNA_DATATYPE_STRING );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to set hostname!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	hr = IDirectPlay8Address_AddComponent( pDPlayAddress, DPNA_KEY_PORT, &dwPort, sizeof( dwPort ), DPNA_DATATYPE_DWORD );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to set port!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	pDPlayAddress;

Failure:
	if ( pDPlayAddress != NULL )
	{
		IDirectPlay8Address_Release( pDPlayAddress );
		pDPlayAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::CreateGenericAddress - create a generic address
//
// Entry:		Nothing
//
// Exit:		Pointer to address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::CreateGenericAddress"

IDirectPlay8Address *CIPXAddress::CreateGenericAddress( void )
{
	HRESULT	hr;
	IDirectPlay8Address		*pDPlayAddress;
	const DWORD		dwPort = 0;


	//
	// initialize
	//
	pDPlayAddress = NULL;

	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address,
						   NULL,
						   CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8Address,
						   reinterpret_cast<void**>( &pDPlayAddress ) );
	if ( hr != S_OK )
	{
		DNASSERT( pDPlayAddress == NULL );
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to create IPAddress when converting socket address do DP8Address" );
		DNASSERT( FALSE );
		goto Failure;
	}

	hr = IDirectPlay8Address_SetSP( pDPlayAddress, &CLSID_DP8SP_IPX );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to set SP type!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	hr = IDirectPlay8Address_AddComponent( pDPlayAddress,
										   DPNA_KEY_HOSTNAME,
										   g_IPXListenAddress,
										   sizeof( g_IPXListenAddress ),
										   DPNA_DATATYPE_STRING );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to set hostname!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	hr = IDirectPlay8Address_AddComponent( pDPlayAddress,
										   DPNA_KEY_PORT,
										   &dwPort,
										   sizeof( dwPort ),
										   DPNA_DATATYPE_DWORD );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "CreateBroadcastAddress: Failed to set port!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	return	pDPlayAddress;

Failure:
	if ( pDPlayAddress != NULL )
	{
		IDirectPlay8Address_Release( pDPlayAddress );
		pDPlayAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::HashFunction - hash address to N bits
//
// Entry:		Count of bits to hash to
//
// Exit:		Hashed value
//
// Note:	We only need to compare the nodenumber (netcard adapter address)
//			[ 6 bytes ] and the port (socket) [ 2 bytes ] to guarantee uniqueness.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::HashFunction"

INT_PTR	CIPXAddress::HashFunction( const INT_PTR iHashBitCount ) const
{
	INT_PTR		iReturn;
	UINT_PTR	Temp;


	DNASSERT( iHashBitCount != 0 );

	//
	// initialize
	//
	iReturn = 0;

	//
	// hash first DWORD of IPX address
	//
	Temp = *reinterpret_cast<const DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum[ 0 ] );
	do
	{
		iReturn ^= Temp & ( ( 1 << iHashBitCount ) - 1 );
		Temp >>= iHashBitCount;
	} while ( Temp != 0 );

	//
	// hash second DWORD of IPX address and IPX socket
	//
	Temp = *reinterpret_cast<const WORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum[ sizeof( DWORD ) ] );
	Temp += ( m_SocketAddress.IPXSocketAddress.sa_socket << ( sizeof( WORD ) * 8 ) );
	do
	{
		iReturn ^= Temp & ( ( 1 << iHashBitCount ) - 1 );
		Temp >>= iHashBitCount;
	}
	while ( Temp != 0 );

	return iReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::CompareToBaseAddress - compare this address to a 'base' address
//		of this class
//
// Entry:		Pointer to base address
//
// Exit:		Integer indicating relative magnitude:
//				0 = items equal
//				-1 = other item is of greater magnitude
//				1 = this item is of lesser magnitude
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::CompareToBaseAddress"

INT_PTR	CIPXAddress::CompareToBaseAddress( const SOCKADDR *const pBaseAddress ) const
{
	const SOCKADDR_IPX	*pBaseIPXAddress;
	

	DNASSERT( pBaseAddress != NULL );
	pBaseIPXAddress = reinterpret_cast<const SOCKADDR_IPX *>( pBaseAddress );
	
	DBG_CASSERT( OFFSETOF( SOCKADDR_IPX, sa_nodenum ) == OFFSETOF( SOCKADDR_IPX, sa_netnum ) + sizeof( pBaseIPXAddress->sa_netnum ) );
	return	memcmp( &m_SocketAddress.IPXSocketAddress.sa_netnum,
					&pBaseIPXAddress->sa_netnum,
					( sizeof( pBaseIPXAddress->sa_netnum ) + sizeof( pBaseIPXAddress->sa_nodenum ) ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::ParseHostName - parse a host name
//
// Entry:		Pointer to host name
//				Size of host name (including NULL)
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::ParseHostName"

HRESULT	CIPXAddress::ParseHostName( const char *const pHostName, const DWORD dwHostNameLength )
{
	HRESULT		hr;
	long		val;
	char		temp[3];
	const char	*a, *b;
	UINT_PTR	uIndex;


	//
	// initialize
	//
	hr = DPN_OK;
	DNASSERT( pHostName != NULL );
	DNASSERT( pHostName[ dwHostNameLength - 1 ] == '\0' );

	DNASSERT( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_HOSTNAME ] == SP_ADDRESS_COMPONENT_UNINITIALIZED );
	m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_HOSTNAME ] = SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED;

	if ( dwHostNameLength != IPX_ADDRESS_STRING_LENGTH )
	{
		DPFX(DPFPREP,  0, "Invalid IPX net/node.  Must be %d bytes of ASCII hex (net,node:socket)", ( IPX_ADDRESS_STRING_LENGTH - 1 ) );
		hr = DPNERR_ADDRESSING;
		goto Exit;
	}

	// we convert the string for the hostname field into the components
	temp[ 2 ] = 0;
	a = static_cast<const char*>( pHostName );

	// the net number is 4 bytes
	for ( uIndex = 0; uIndex < 4; uIndex++ )
	{
		strncpy( temp, a, 2 );
		val = strtol( temp, const_cast<char**>( &b ), 16 );
		m_SocketAddress.IPXSocketAddress.sa_netnum[ uIndex ] = (char) val;
		a += 2;
	}

	// followed by a dot
	a++;

	// the node is 6 bytes
	for ( uIndex = 0; uIndex < 6; uIndex++ )
	{
		strncpy( temp, a, 2 );
		val = strtol( temp, const_cast<char**>( &b ), 16 );
		m_SocketAddress.IPXSocketAddress.sa_nodenum[ uIndex ] = (char) val;
		a += 2;
	}

	m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_HOSTNAME ] = SP_ADDRESS_COMPONENT_INITIALIZED;

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CIPXAddress::CopyInternalSocketAddressWithoutPort - copy socket address
//		without the port field.
//
// Entry:		Reference to destination address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CIPXAddress::CopyInternalSocketAddressWithoutPort"

void	CIPXAddress::CopyInternalSocketAddressWithoutPort( SOCKADDR &AddressDestination ) const
{
	SOCKADDR_IPX	*pIPXSocketAddress;


	//
	// copy address and zero out the port
	//
	DBG_CASSERT( sizeof( AddressDestination ) == sizeof( m_SocketAddress.SocketAddress ) );
	memcpy( &AddressDestination, &m_SocketAddress.SocketAddress, sizeof( AddressDestination ) );

	DBG_CASSERT( sizeof( SOCKADDR_IPX* ) == sizeof( &AddressDestination ) );
	pIPXSocketAddress = reinterpret_cast<SOCKADDR_IPX*>( &AddressDestination );
	pIPXSocketAddress->sa_socket = p_htons( 0 );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\ipendpt.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPEndpt.h
 *  Content:	IP endpoint
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 ***************************************************************************/

#ifndef __IP_ENDPOINT_H__
#define __IP_ENDPOINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	TEMP_HOSTNAME_LENGTH	100

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CIPEndpoint : public CEndpoint
{
	public:
		//
		// we need a virtual destructor to guarantee we call destructors in base classes
		//
		CIPEndpoint();
		~CIPEndpoint();

		//
		// UI functions
		//
		HRESULT		ShowSettingsDialog( CThreadPool *const pThreadPool );
		void		SettingsDialogComplete( const HRESULT hr );
		void		StopSettingsDialog( const HWND hDlg );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPEndpoint::SetTempHostName"
		void		SetTempHostName( const TCHAR *const pHostName, const UINT_PTR uHostNameLength )
		{
			DNASSERT( pHostName[ uHostNameLength ] == TEXT('\0') );
			DNASSERT( ( uHostNameLength + 1 ) <= LENGTHOF( m_TempHostName ) );
			memcpy( m_TempHostName, pHostName, ( uHostNameLength + 1) * sizeof(TCHAR) );
		}

		//
		// pool functions
		//
		BOOL	PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pContext );
		BOOL	PoolInitFunction( ENDPOINT_POOL_CONTEXT *pContext );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );
		void	ReturnSelfToPool( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPEndpoint::SetOwningPool"
		void	SetOwningPool( CLockedContextFixedPool< CIPEndpoint, ENDPOINT_POOL_CONTEXT* > *pOwningPool )
		{
			DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) );
			m_pOwningPool = pOwningPool;
		}

	protected:

	private:
		BYTE		m_Sig[4];	// debugging signature ('IPEP')
		
		CLockedContextFixedPool< CIPEndpoint, ENDPOINT_POOL_CONTEXT* >	*m_pOwningPool;
		
		CIPAddress	m_IPAddress;
		TCHAR		m_TempHostName[ TEMP_HOSTNAME_LENGTH ];
		
		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CIPEndpoint( const CIPEndpoint & );
		CIPEndpoint& operator=( const CIPEndpoint & );
};

#undef DPF_MODNAME

#endif	// __IP_ENDPOINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\ipxendpt.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       IPXEndpt.h
 *  Content:	IPX endpoint class definition
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 ***************************************************************************/

#ifndef __IPX_ENDPOINT_H__
#define __IPX_ENDPOINT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

class	CIPXEndpoint: public CEndpoint
{
	public:
		//
		// we need a virtual destructor to guarantee we call destructors in base classes
		//
		CIPXEndpoint();
		virtual	~CIPXEndpoint();

		// UI functions
		HRESULT	ShowSettingsDialog( CThreadPool *const pThreadPool );
		void	SettingsDialogComplete( const HRESULT hr );
		void	StopSettingsDialog( const HWND hDlg );

		//
		// pool functions
		//
		BOOL	PoolAllocFunction( ENDPOINT_POOL_CONTEXT *pContext );
		BOOL	PoolInitFunction( ENDPOINT_POOL_CONTEXT *pContext );
		void	PoolReleaseFunction( void );
		void	PoolDeallocFunction( void );
		void	ReturnSelfToPool( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CIPXEndpoint::SetOwningPool"
		void	SetOwningPool( CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* > *pOwningPool )
		{
			DNASSERT( ( m_pOwningPool == NULL ) || ( pOwningPool == NULL ) );
			m_pOwningPool = pOwningPool;
		}

	protected:

	private:
		BYTE			m_Sig[4];	// debugging signature ('IPXE')
		
		CIPXAddress		m_IPXAddress;

		CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*m_pOwningPool;

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CIPXEndpoint( const CIPXEndpoint & );
		CIPXEndpoint& operator=( const CIPXEndpoint & );
};

#undef DPF_MODNAME

#endif	// __IPX_ENDPOINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\locals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Locals.cpp
 *  Content:	Global variables for the DNWsock service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// DLL instance
//
HINSTANCE				g_hDLLInstance = NULL;

//
// count of outstanding COM interfaces
//
volatile LONG			g_lOutstandingInterfaceCount = 0;

//
// invalid adapter guid
//
const GUID				g_InvalidAdapterGuid = { 0 };



//
// thread count
//
LONG					g_iThreadCount = 0;

//
// Winssock receive buffer size
//
BOOL					g_fWinsockReceiveBufferSizeOverridden = FALSE;
INT						g_iWinsockReceiveBufferSize = 0;

//
// Winsock receive buffer multiplier
//
DWORD_PTR				g_dwWinsockReceiveBufferMultiplier = 1;


//
// global NAT/firewall traversal information
//
BOOL					g_fDisableDPNHGatewaySupport = FALSE;
BOOL					g_fDisableDPNHFirewallSupport = FALSE;
BOOL					g_fUseNATHelpAlert = FALSE;		// problems with random firings necessitate that we don't use it by default for now

IDirectPlayNATHelp **	g_papNATHelpObjects = NULL;


//
// ignore enums performance option
//
BOOL					g_fIgnoreEnums = FALSE;


//
// proxy support options
//
BOOL					g_fDontAutoDetectProxyLSP = FALSE;
BOOL					g_fTreatAllResponsesAsProxied = FALSE;



//
// ID of most recent endpoint generated
//
DWORD					g_dwCurrentEndpointID = 0;


//
// registry strings
//
const WCHAR	g_RegistryBase[] = L"SOFTWARE\\Microsoft\\DirectPlay8";
const WCHAR	g_RegistryKeyReceiveBufferSize[] = L"WinsockReceiveBufferSize";
const WCHAR	g_RegistryKeyThreadCount[] = L"ThreadCount";
const WCHAR	g_RegistryKeyReceiveBufferMultiplier[] = L"WinsockReceiveBufferMultiplier";
const WCHAR	g_RegistryKeyDisableDPNHGatewaySupport[] = L"DisableDPNHGatewaySupport";
const WCHAR	g_RegistryKeyDisableDPNHFirewallSupport[] = L"DisableDPNHFirewallSupport";
const WCHAR	g_RegistryKeyUseNATHelpAlert[] = L"UseNATHelpAlert";
const WCHAR	g_RegistryKeyAppsToIgnoreEnums[] = L"AppsToIgnoreEnums";
const WCHAR	g_RegistryKeyDontAutoDetectProxyLSP[] = L"DontAutoDetectProxyLSP";
const WCHAR	g_RegistryKeyTreatAllResponsesAsProxied[] = L"TreatAllResponsesAsProxied";


//
// GUIDs for munging device IDs
//
// {4CE725F4-7B00-4397-BA6F-11F965BC4299}
GUID	g_IPSPEncryptionGuid = { 0x4ce725f4, 0x7b00, 0x4397, { 0xba, 0x6f, 0x11, 0xf9, 0x65, 0xbc, 0x42, 0x99 } };

// {CA734945-3FC1-42ea-BF49-84AFCD4764AA}
GUID	g_IPXSPEncryptionGuid = { 0xca734945, 0x3fc1, 0x42ea, { 0xbf, 0x49, 0x84, 0xaf, 0xcd, 0x47, 0x64, 0xaa } };




//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\jobqueue.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       JobQueue.h
 *  Content:	Job queue for thread pool
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/24/2000	jtk		Created
 ***************************************************************************/

#ifndef __JOB_QUEUE_H__
#define __JOB_QUEUE_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CSocketPort;
typedef	enum	_JOB_TYPE	JOB_TYPE;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;
typedef	void	JOB_FUNCTION( THREAD_POOL_JOB *const pJobInfo );

//
// structure for job to start monitoring a socket in Win9x
//
typedef	struct
{
	CSocketPort	*pSocketPort;	// pointer to associated socket port

} DATA_ADD_SOCKET;

//
// structure for job to stop monitoring a socket in Win9x
//
typedef	struct
{
	CSocketPort	*pSocketPort;		// pointer to associated socket port

} DATA_REMOVE_SOCKET;

//
// structure for job to connect
//
typedef struct
{
	JOB_FUNCTION	*pCommandFunction;	// pointer to function for the command
	void			*pContext;			// user context (i.e. CEndpoint pointer)
	UINT_PTR		uData;				// user data
} DATA_DELAYED_COMMAND;

//
// structure for job to refresh enums
//
typedef	struct
{
	UINT_PTR	uDummy;			// dummy variable to prevent compiler from whining
} DATA_REFRESH_TIMED_JOBS;

//
// structure encompassing information for a job for the workhorse thread
//
typedef struct	_THREAD_POOL_JOB
{
	THREAD_POOL_JOB		*pNext;					// pointer to next job
	JOB_TYPE			JobType;				// type of job
	JOB_FUNCTION		*pCancelFunction;		// function for cancelling job

//	DWORD		dwCommandID;			// unique ID used to identify this command
//	FUNCTION	*pProcessFunction;		// function for performing job

	union
	{
		DATA_DELAYED_COMMAND	JobDelayedCommand;
		DATA_REMOVE_SOCKET		JobRemoveSocket;
		DATA_ADD_SOCKET			JobAddSocket;
		DATA_REFRESH_TIMED_JOBS	JobRefreshTimedJobs;
	} JobData;

} THREAD_POOL_JOB;


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	BOOL	(CSocketPort::*PSOCKET_SERVICE_FUNCTION)( void );


//**********************************************************************
// Class prototypes
//**********************************************************************


//
// class to encapsultate a job queue
//
class	CJobQueue
{
	public:
		CJobQueue();
		~CJobQueue();

		BOOL	Initialize( void );
		void	Deinitialize( void );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CJobQueue::GetPendingJobHandle"
		HANDLE	GetPendingJobHandle( void ) const
		{
			DNASSERT( m_hPendingJob != NULL );
			return	m_hPendingJob;
		}

		BOOL	SignalPendingJob( void );

		BOOL	IsEmpty( void ) const { return ( m_pQueueHead == NULL ); }

		void	EnqueueJob( THREAD_POOL_JOB *const pJob );
		THREAD_POOL_JOB	*DequeueJob( void );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;			// lock
		THREAD_POOL_JOB		*m_pQueueHead;	// head of job queue
		THREAD_POOL_JOB		*m_pQueueTail;	// tail of job queue
		HANDLE				m_hPendingJob;	// event indicating a pending job

		//
		// prevent unwarranted copies
		//
		CJobQueue( const CJobQueue & );
		CJobQueue& operator=( const CJobQueue & );
};

#undef DPF_MODNAME

#endif	// __JOB_QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dnwsock.rc
//
#define IDS_FRIENDLYNAME_IPX            1
#define IDS_FRIENDLYNAME_TCPIP          2
#define IDD_IP_SETTINGS                 101
#define IDC_EDIT_IP_HOSTNAME            1000
#define IDC_STATIC_IP_HOSTNAME          -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\locals.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Locals.h
 *  Content:	Global information for the DNWSock service provider
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __LOCALS_H__
#define __LOCALS_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	BITS_PER_BYTE	8

//
// Maximum size of a receved message (1500 byte ethernet frame - 28 byte UDP
// header).  The SP will have a bit reserved in the received data by the protocol
// so it knows that the data is a 'user datagram'.  If that bit is not set, the
// data is SP-specific (enum query, enum response, proxied enum query).
//
#define	MAX_MESSAGE_SIZE	1472

//
// maximum data size in bytes
//
#define	MAX_USER_PAYLOAD	( MAX_MESSAGE_SIZE )

#define	MAX_ACTIVE_WIN9X_ENDPOINTS	25

//
// enumerated constants for IO completion returns
//
typedef	enum
{
	IO_COMPLETION_KEY_UNKNOWN = 0,			// invalid value
	IO_COMPLETION_KEY_SP_CLOSE,				// SP is closing, bail on completion threads
	IO_COMPLETION_KEY_IO_COMPLETE,			// IO operation complete
	IO_COMPLETION_KEY_NEW_JOB,				// new job notification
	IO_COMPLETION_KEY_NATHELP_UPDATE,		// NAT Help needs maintenance
} IO_COMPLETION_KEY;


//
// maximum value of a 32-bit unsigned variable
//
#define	UINT32_MAX	((DWORD) 0xFFFFFFFF)
#define	WORD_MAX	((WORD) 0xFFFF)

//
// default enum retries for Winsock SP and retry time (milliseconds)
//
#define	DEFAULT_ENUM_RETRY_COUNT		5
#define	DEFAULT_ENUM_RETRY_INTERVAL		1500
#define	DEFAULT_ENUM_TIMEOUT			1500
#define	ENUM_RTT_ARRAY_SIZE				16


//
// Private address key that allows for friendlier multi-device commands issued
// using xxxADDRESSINFO indications; specifically, this allows us to detect
// responses sent to the "wrong" adapter when the core multiplexes an
// enum or connect into multiple adapters.
//
#define DPNA_PRIVATEKEY_MULTIPLEXED_ADAPTER_ASSOCIATION		L"pk_ipsp_maa"


//
// Private address key that allows for friendlier multi-device commands issued
// using xxxADDRESSINFO indications; specifically, this allows us to distinguish
// between the user specifying a fixed port and the core handing us back the
// port we chose for a previous adapter when it multiplexes an enum, connect,
// or listen into multiple adapters.
//
#define DPNA_PRIVATEKEY_PORT_NOT_SPECIFIC					L"pk_ipsp_pns"


//
// Private address key designed to improve support for MS Proxy/ISA Firewall
// client software.  This key tracks the original target address for enums so
// that if the application closes the socketport before trying to connect to
// the responding address, the connect attempts will go to the real target
// instead of the old proxy address.
//
#define DPNA_PRIVATEKEY_PROXIED_RESPONSE_ORIGINAL_ADDRESS	L"pk_ipsp_proa"




//**********************************************************************
// Macro definitions
//**********************************************************************

//
// macro for length of array
//
#define	LENGTHOF( arg )		( sizeof( arg ) / sizeof( arg[ 0 ] ) )

//
// macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
//
#define OFFSETOF(s,m)	( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure and class references
//
typedef	struct	IDP8ServiceProvider	IDP8ServiceProvider;

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// DLL instance
//
extern	HINSTANCE				g_hDLLInstance;

//
// count of outstanding COM interfaces
//
extern volatile	LONG			g_lOutstandingInterfaceCount;

//
// invalid adapter guid
//
extern const GUID				g_InvalidAdapterGuid;


//
// thread count
//
extern	LONG					g_iThreadCount;




//
// Winsock receive buffer size
//
extern	BOOL					g_fWinsockReceiveBufferSizeOverridden;
extern	INT						g_iWinsockReceiveBufferSize;

//
// Winsock receive buffer multiplier
//
extern	DWORD_PTR				g_dwWinsockReceiveBufferMultiplier;

//
// GUIDs for munging device IDs
//
extern	GUID					g_IPSPEncryptionGuid;
extern	GUID					g_IPXSPEncryptionGuid;



//
// global NAT/firewall traversal information
//
#define MAX_NUM_DIRECTPLAYNATHELPERS		5

extern	BOOL					g_fDisableDPNHGatewaySupport;
extern	BOOL					g_fDisableDPNHFirewallSupport;
extern	BOOL					g_fUseNATHelpAlert;

extern IDirectPlayNATHelp **	g_papNATHelpObjects;


//
// ignore enums performance option
//
extern	BOOL					g_fIgnoreEnums;


#ifdef IPBANNING
//
// IP banning globals
//
extern	BOOL					g_fIPBanning;
#endif // IPBANNING



//
// proxy support options
//
extern	BOOL					g_fDontAutoDetectProxyLSP;
extern	BOOL					g_fTreatAllResponsesAsProxied;


//
// ID of most recent endpoint generated
//
extern	DWORD					g_dwCurrentEndpointID;


//
// Registry strings
//
extern	const WCHAR	g_RegistryBase[];
extern	const WCHAR	g_RegistryKeyReceiveBufferSize[];
extern	const WCHAR	g_RegistryKeyThreadCount[];
extern	const WCHAR	g_RegistryKeyReceiveBufferMultiplier[];
extern	const WCHAR	g_RegistryKeyDisableDPNHGatewaySupport[];
extern	const WCHAR	g_RegistryKeyDisableDPNHFirewallSupport[];
extern	const WCHAR	g_RegistryKeyUseNATHelpAlert[];
extern	const WCHAR	g_RegistryKeyAppsToIgnoreEnums[];
extern	const WCHAR	g_RegistryKeyDontAutoDetectProxyLSP[];
extern	const WCHAR	g_RegistryKeyTreatAllResponsesAsProxied[];



//**********************************************************************
// Function prototypes
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNInterlockedIncrement - Interlocked increment
//
// Entry:		Pointer to value to increment
//
// Exit:		New value
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNInterlockedIncrement"

inline LONG	DNInterlockedIncrement( volatile LONG *const pValue )
{
	DNASSERT( pValue != NULL );
	DNASSERT( *pValue != -1 );
	return	InterlockedIncrement( const_cast<LONG*>( pValue ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNInterlockedDecrement - interlocked decrement wrapper
//
// Entry:		Pointer to value to decrement
//
// Exit:		New value
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNInterlockedDecrement"

inline LONG	DNInterlockedDecrement( volatile LONG *const pValue )
{
	DNASSERT( pValue != NULL );
	DNASSERT( *pValue != 0 );
	return	InterlockedDecrement( const_cast<LONG*>( pValue ) );
}
//**********************************************************************

#undef DPF_MODNAME

#endif	// __LOCALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\messagestructures.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MessageStructures.h
 *  Content:	Message strucutre definitions for messages on the wire
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/20/2000	jtk		Derived from IOData.h
 ***************************************************************************/

#ifndef __MESSAGE_STRUCTURES_H__
#define __MESSAGE_STRUCTURES_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	SP_HEADER_LEAD_BYTE			0x00
#define	ESCAPED_USER_DATA_PAD_VALUE	0x0000

//
// Data types used by service provider messages.  Note, the high-order bit
// is reserved for future use and should not be set!
//
#define	ESCAPED_USER_DATA_KIND		0x01
#define	ENUM_DATA_KIND				0x02
#define	ENUM_RESPONSE_DATA_KIND		0x03
#define	PROXIED_ENUM_DATA_KIND		0x04

//
// DPlay port limits (inclusive) scanned to find an available port.
// Exclude 2300 and 2301 because there are network broadcasts on 2301
// that we may receive.
//
#define	BASE_DPLAY8_PORT	((WORD) 2302)
#define	MAX_DPLAY8_PORT		((WORD) 2400)

//
// mask for RTT sequence number
//
#define	ENUM_RTT_MASK	0X0F

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// Structure used to prepend data to a send, this structure is byte aligned to
// save bandwidth.  The goal is to keep all data DWORD aligned so the structure
// elements should be sized such that any payload passed to a higher layer is
// DWORD aligned.  In the case of the proxied enum query, the full SOCKADDR
// structure is used to keep alignment.
//
#pragma	pack( push, 1 )
typedef union	_PREPEND_BUFFER
{
	struct	_GENERIC_HEADER				// generic header to determine data kind
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;			//
	} GenericHeader;					//

	struct _ESCAPED_USER_DATA_HEADER	// header used when escaping user data
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;			//
		WORD	wPad;					// used to keep message DWORD aligned
	} EscapedUserDataHeader;			//

	struct	_ENUM_DATA_HEADER			// header used to indicate enum query data
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;			//
		WORD	wEnumPayload;			// combination of RTT sequence and enum key
	} EnumDataHeader;					//

	struct	_ENUM_RESPONSE_DATA_HEADER	// header used to indicate enum response data
	{									//
		BYTE	bSPLeadByte;			//
		BYTE	bSPCommandByte;			//
		WORD	wEnumResponsePayload;	// combination of RTT sequence and enum key
	} EnumResponseDataHeader;			//

	struct	_PROXIED_ENUM_DATA_HEADER	// header used to indicate proxied enum data
	{									//
		BYTE		bSPLeadByte;		//
		BYTE		bSPCommandByte;		//
		WORD		wEnumKey;			// key from the original enum
		SOCKADDR	ReturnAddress;		// real socket address to return the data to
	} ProxiedEnumDataHeader;			//

} PREPEND_BUFFER;
#pragma	pack( pop )

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************


#endif	// __MESSAGE_STRUCTURES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\pools.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.cpp
 *  Content:	Pool utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/2000	jtk		Derived from Utils.h
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

#ifdef USE_THREADLOCALPOOLS
//
// implement the thread local pools
//
IMPL_THREADLOCALPTRS(WSockThreadLocalPools);

//
// global backup pools for thread-local pools
//
CFixedTLPool< CIPAddress > *										g_pGlobalIPAddressPool = NULL;
CFixedTLPool< CIPXAddress > *										g_pGlobalIPXAddressPool = NULL;
CContextFixedTLPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT > *		g_pGlobalIPReadIODataPool = NULL;
CContextFixedTLPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT > *		g_pGlobalIPXReadIODataPool = NULL;
CLockedTLPool< CCommandData > *										g_pGlobalCommandDataPool = NULL;
CContextFixedTLPool< CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT > *	g_pGlobalWriteIODataPool = NULL;

//
// boolean that gets set when pools are being cleaned up (inside DllMain
// PROCESS_DETACH).
//
static BOOL		g_fShuttingDown = FALSE;
#endif // USE_THREADLOCALPOOLS



//
// pool for adapter entries
//
static	CLockedPool< CAdapterEntry >	*g_pAdapterEntryPool = NULL;


#ifndef USE_THREADLOCALPOOLS
//
// pool for command data
//
static	CLockedPool< CCommandData >	*g_pCommandDataPool = NULL;


//
// Pools for addresses.  Since these pools don't
// see a lot of action, they share one lock
//
static	DNCRITICAL_SECTION	g_AddressLock;
static	CFixedPool< CIPAddress >	*g_pIPAddressPool = NULL;
static	CFixedPool< CIPXAddress >	*g_pIPXAddressPool = NULL;
#endif // ! USE_THREADLOCALPOOLS


//
// pools for endpoints
//
static	CLockedContextFixedPool< CIPEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPEndpointPool = NULL;
static	CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >	*g_pIPXEndpointPool = NULL;
static	CLockedFixedPool< ENDPOINT_COMMAND_PARAMETERS >	*g_pEndpointCommandParameterPool = NULL;

//
// pool for socket ports
//
static	CLockedFixedPool< CSocketPort >	*g_pSocketPortPool = NULL;

//
// pool for thread pools
//
static	CLockedFixedPool< CThreadPool >	*g_pThreadPoolPool = NULL;



//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitializePools - initialize pools
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "InitializePools"

BOOL	InitializePools( void )
{
	BOOL	fReturn;


	//
	// initialize
	//
	fReturn = TRUE;


	//
	// AdapterEntry object pool
	//
	DNASSERT( g_pAdapterEntryPool == NULL );
	g_pAdapterEntryPool = new CLockedPool< CAdapterEntry >;
	if ( g_pAdapterEntryPool != NULL )
	{
		if ( g_pAdapterEntryPool->Initialize() == FALSE )
		{
			delete	g_pAdapterEntryPool;
			g_pAdapterEntryPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}
	
	
#ifndef USE_THREADLOCALPOOLS
	//
	// command data pool
	//
	DNASSERT( g_pCommandDataPool == NULL );
	g_pCommandDataPool = new CLockedPool< CCommandData >;
	if ( g_pCommandDataPool != NULL )
	{
		if ( g_pCommandDataPool->Initialize() == FALSE )
		{
			delete	g_pCommandDataPool;
			g_pCommandDataPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


	//
	// initialize lock for address and endpoint pools
	//
	if ( DNInitializeCriticalSection( &g_AddressLock ) == FALSE )
	{
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &g_AddressLock, 0 );

	//
	// address pools
	//
	DNASSERT( g_pIPAddressPool == NULL );
	g_pIPAddressPool = new CFixedPool< CIPAddress >;
	if ( g_pIPAddressPool == NULL )
	{
		goto Failure;
	}

	DNASSERT( g_pIPXAddressPool == NULL );
	g_pIPXAddressPool = new CFixedPool< CIPXAddress >;
	if ( g_pIPXAddressPool == NULL )
	{
		goto Failure;
	}
#endif // ! USE_THREADLOCALPOOLS


	//
	// endpoint pools
	//
	DNASSERT( g_pIPEndpointPool == NULL );
	g_pIPEndpointPool = new CLockedContextFixedPool< CIPEndpoint, ENDPOINT_POOL_CONTEXT* >;
	if ( g_pIPEndpointPool != NULL )
	{
		if ( g_pIPEndpointPool->Initialize() == FALSE )
		{
			delete	g_pIPEndpointPool;
			g_pIPEndpointPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}

	DNASSERT( g_pIPXEndpointPool == NULL );
	g_pIPXEndpointPool = new CLockedContextFixedPool< CIPXEndpoint, ENDPOINT_POOL_CONTEXT* >;
	if ( g_pIPXEndpointPool != NULL )
	{
		if ( g_pIPXEndpointPool->Initialize() == FALSE )
		{
			delete	g_pIPXEndpointPool;
			g_pIPXEndpointPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}

	//
	// endpoint command parameter pools
	//
	DNASSERT( g_pEndpointCommandParameterPool == NULL );
	g_pEndpointCommandParameterPool = new CLockedFixedPool< ENDPOINT_COMMAND_PARAMETERS >;
	if ( g_pEndpointCommandParameterPool != NULL )
	{
		if ( g_pEndpointCommandParameterPool->Initialize() == FALSE )
		{
			delete	g_pEndpointCommandParameterPool;
			g_pEndpointCommandParameterPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


	//
	// socket port pool
	//
	DNASSERT( g_pSocketPortPool == NULL );
	g_pSocketPortPool = new CLockedFixedPool< CSocketPort >;
	if ( g_pSocketPortPool != NULL )
	{
		if ( g_pSocketPortPool->Initialize() == FALSE )
		{
			delete	g_pSocketPortPool;
			g_pSocketPortPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


	//
	// thread pool pool
	//
	DNASSERT( g_pThreadPoolPool == NULL );
	g_pThreadPoolPool = new CLockedFixedPool< CThreadPool >;
	if ( g_pThreadPoolPool != NULL )
	{
		if ( g_pThreadPoolPool->Initialize() == FALSE )
		{
			delete	g_pThreadPoolPool;
			g_pThreadPoolPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


#ifdef USE_THREADLOCALPOOLS
	//
	// global IP address pool that backs up the thread-local ones.
	//
	DNASSERT( g_pGlobalIPAddressPool == NULL );
	g_pGlobalIPAddressPool = new CFixedTLPool< CIPAddress > ( NULL );
	if ( g_pGlobalIPAddressPool == NULL )
	{
		goto Failure;
	}


	//
	// global IPX address pool that backs up the thread-local ones.
	//
	DNASSERT( g_pGlobalIPXAddressPool == NULL );
	g_pGlobalIPXAddressPool = new CFixedTLPool< CIPXAddress > ( NULL );
	if ( g_pGlobalIPXAddressPool == NULL )
	{
		goto Failure;
	}


	//
	// global IP read data pool that backs up the thread-local ones.
	//
	DNASSERT( g_pGlobalIPReadIODataPool == NULL );
	g_pGlobalIPReadIODataPool = new CContextFixedTLPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >;
	if ( g_pGlobalIPReadIODataPool != NULL )
	{
		if (! g_pGlobalIPReadIODataPool->Initialize( NULL,
													CReadIOData::ReadIOData_Alloc,
													CReadIOData::ReadIOData_Get,
													CReadIOData::ReadIOData_Release,
													CReadIOData::ReadIOData_Dealloc
													))
		{
			delete	g_pGlobalIPReadIODataPool;
			g_pGlobalIPReadIODataPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


	//
	// global IPX read data pool that backs up the thread-local ones.
	//
	DNASSERT( g_pGlobalIPXReadIODataPool == NULL );
	g_pGlobalIPXReadIODataPool = new CContextFixedTLPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >;
	if ( g_pGlobalIPXReadIODataPool != NULL )
	{
		if (! g_pGlobalIPXReadIODataPool->Initialize( NULL,
													CReadIOData::ReadIOData_Alloc,
													CReadIOData::ReadIOData_Get,
													CReadIOData::ReadIOData_Release,
													CReadIOData::ReadIOData_Dealloc
													))
		{
			delete	g_pGlobalIPXReadIODataPool;
			g_pGlobalIPXReadIODataPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


	//
	// global command data pool that backs up the thread-local ones.
	//
	DNASSERT( g_pGlobalCommandDataPool == NULL );
	g_pGlobalCommandDataPool = new CLockedTLPool< CCommandData >;
	if ( g_pGlobalCommandDataPool != NULL )
	{
		if ( g_pGlobalCommandDataPool->Initialize( NULL ) == FALSE )
		{
			delete	g_pGlobalCommandDataPool;
			g_pGlobalCommandDataPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


	//
	// global write data pool that backs up the thread-local ones.
	//
	DNASSERT( g_pGlobalWriteIODataPool == NULL );
	g_pGlobalWriteIODataPool = new CContextFixedTLPool< CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT >;
	if ( g_pGlobalWriteIODataPool != NULL )
	{
		if (! g_pGlobalWriteIODataPool->Initialize( NULL,
													CWriteIOData::WriteIOData_Alloc,
													CWriteIOData::WriteIOData_Get,
													CWriteIOData::WriteIOData_Release,
													CWriteIOData::WriteIOData_Dealloc
													))
		{
			delete	g_pGlobalWriteIODataPool;
			g_pGlobalWriteIODataPool = NULL;
			goto Failure;
		}
	}
	else
	{
		goto Failure;
	}


	//
	// prepare thread local pool pointers
	//
	if ( INIT_THREADLOCALPTRS(WSockThreadLocalPools) == FALSE )
	{
		goto Failure;
	}
#endif // USE_THREADLOCALPOOLS


Exit:
	return	fReturn;

Failure:
	fReturn = FALSE;
	DeinitializePools();

	goto Exit;
}
//**********************************************************************




#ifdef USE_THREADLOCALPOOLS
//**********************************************************************
// ------------------------------
// CleanupThreadLocalPools - cleans up the thread local pool entries
//
// Entry:		pointer to structure to cleanup
//				thread ID that owned the structure (may not exist any more)
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CleanupThreadLocalPools"

void	CleanupThreadLocalPools( WSockThreadLocalPools * pThreadLocalPools, DWORD dwThreadID )
{
	if (pThreadLocalPools->pWriteIODataPool != NULL)
	{
		DPFX(DPFPREP, 8, "Cleaning up thread %u/0x%x's write I/O data pool 0x%p.",
			dwThreadID, dwThreadID, pThreadLocalPools->pWriteIODataPool);
		pThreadLocalPools->pWriteIODataPool->Deinitialize();
		delete pThreadLocalPools->pWriteIODataPool;
	}

	if (pThreadLocalPools->pCommandDataPool != NULL)
	{
		DPFX(DPFPREP, 8, "Cleaning up thread %u/0x%x's command data pool 0x%p.",
			dwThreadID, dwThreadID, pThreadLocalPools->pCommandDataPool);
		pThreadLocalPools->pCommandDataPool->Deinitialize();
		delete pThreadLocalPools->pCommandDataPool;
	}

	if (pThreadLocalPools->pIPXReadIODataPool != NULL)
	{
		DPFX(DPFPREP, 8, "Cleaning up thread %u/0x%x's IPX read I/O data pool 0x%p.",
			dwThreadID, dwThreadID, pThreadLocalPools->pIPXReadIODataPool);
		pThreadLocalPools->pIPXReadIODataPool->Deinitialize();
		delete pThreadLocalPools->pIPXReadIODataPool;
	}

	if (pThreadLocalPools->pIPReadIODataPool != NULL)
	{
		DPFX(DPFPREP, 8, "Cleaning up thread %u/0x%x's IP read I/O data pool 0x%p.",
			dwThreadID, dwThreadID, pThreadLocalPools->pIPReadIODataPool);
		pThreadLocalPools->pIPReadIODataPool->Deinitialize();
		delete pThreadLocalPools->pIPReadIODataPool;
	}

	if ( pThreadLocalPools->pIPXAddressPool != NULL )
	{
		DPFX(DPFPREP, 8, "Cleaning up thread %u/0x%x's IPX address pool 0x%p.",
			dwThreadID, dwThreadID, pThreadLocalPools->pIPXAddressPool);
		delete pThreadLocalPools->pIPXAddressPool;
	}

	if ( pThreadLocalPools->pIPAddressPool != NULL )
	{
		DPFX(DPFPREP, 8, "Cleaning up thread %u/0x%x's IP address pool 0x%p.",
			dwThreadID, dwThreadID, pThreadLocalPools->pIPAddressPool);
		delete pThreadLocalPools->pIPAddressPool;
	}
}
//**********************************************************************
#endif // USE_THREADLOCALPOOLS





//**********************************************************************
// ------------------------------
// DeinitializePools - deinitialize the pools
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DeinitializePools"

void	DeinitializePools( void )
{
#ifdef USE_THREADLOCALPOOLS
	//
	// Note that we are shutting down.
	//
	g_fShuttingDown = TRUE;


	DEINIT_THREADLOCALPTRS(WSockThreadLocalPools, CleanupThreadLocalPools);


	//
	// global write data pool that backs up the thread-local ones.
	//
	if ( g_pGlobalWriteIODataPool != NULL )
	{
		g_pGlobalWriteIODataPool->Deinitialize();
		delete	g_pGlobalWriteIODataPool;
		g_pGlobalWriteIODataPool = NULL;
	}


	//
	// global command data pool that backs up the thread-local ones.
	//
	if ( g_pGlobalCommandDataPool != NULL )
	{
		g_pGlobalCommandDataPool->Deinitialize();
		delete	g_pGlobalCommandDataPool;
		g_pGlobalCommandDataPool = NULL;
	}


	//
	// global IPX read data pool that backs up the thread-local ones.
	//
	if ( g_pGlobalIPXReadIODataPool != NULL )
	{
		g_pGlobalIPXReadIODataPool->Deinitialize();
		delete	g_pGlobalIPXReadIODataPool;
		g_pGlobalIPXReadIODataPool = NULL;
	}


	//
	// global IP read data pool that backs up the thread-local ones.
	//
	if ( g_pGlobalIPReadIODataPool != NULL )
	{
		g_pGlobalIPReadIODataPool->Deinitialize();
		delete	g_pGlobalIPReadIODataPool;
		g_pGlobalIPReadIODataPool = NULL;
	}


	//
	// global IPX address pool that backs up the thread-local ones.
	//
	if ( g_pGlobalIPXAddressPool != NULL )
	{
		delete	g_pGlobalIPXAddressPool;
		g_pGlobalIPXAddressPool = NULL;
	}


	//
	// global IP address pool that backs up the thread-local ones.
	//
	if ( g_pGlobalIPAddressPool != NULL )
	{
		delete	g_pGlobalIPAddressPool;
		g_pGlobalIPAddressPool = NULL;
	}
#endif // USE_THREADLOCALPOOLS


	//
	// thread pool pool
	//
	if ( g_pThreadPoolPool != NULL )
	{
		g_pThreadPoolPool->Deinitialize();
		delete	g_pThreadPoolPool;
		g_pThreadPoolPool = NULL;
	}

	//
	// socket port pool
	//
	if ( g_pSocketPortPool != NULL )
	{
		g_pSocketPortPool->Deinitialize();
		delete	g_pSocketPortPool;
		g_pSocketPortPool = NULL;
	}

	//
	// endpoint command parameter pool
	//
	if ( g_pEndpointCommandParameterPool != NULL )
	{
		g_pEndpointCommandParameterPool->Deinitialize();
		delete	g_pEndpointCommandParameterPool;
		g_pEndpointCommandParameterPool = NULL;
	}

	//
	// endpoint pools
	//
	if ( g_pIPXEndpointPool != NULL )
	{
		g_pIPXEndpointPool->Deinitialize();
		delete	g_pIPXEndpointPool;
		g_pIPXEndpointPool = NULL;
	}

	if ( g_pIPEndpointPool != NULL )
	{
		g_pIPEndpointPool->Deinitialize();
		delete	g_pIPEndpointPool;
		g_pIPEndpointPool = NULL;
	}


#ifndef USE_THREADLOCALPOOLS
	//
	// address pools
	//
	if ( g_pIPXAddressPool != NULL )
	{
		delete	g_pIPXAddressPool;
		g_pIPXAddressPool = NULL;
	}

	if ( g_pIPAddressPool != NULL )
	{
		delete	g_pIPAddressPool;
		g_pIPAddressPool = NULL;
	}

	//
	// remove lock for endpoint and address pools
	//
	DNDeleteCriticalSection( &g_AddressLock );
	


	//
	// command data pool
	//
	if ( g_pCommandDataPool != NULL )
	{
		g_pCommandDataPool->Deinitialize();
		delete	g_pCommandDataPool;
		g_pCommandDataPool = NULL;
	}
#endif // ! USE_THREADLOCALPOOLS

	
	//
	// AdapterEntry pool
	//
	if ( g_pAdapterEntryPool != NULL )
	{
		g_pAdapterEntryPool->Deinitialize();
		delete	g_pAdapterEntryPool;
		g_pAdapterEntryPool = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateAdapterEntry - create an adapter entry
//
// Entry:		Nothing
//
// Exit:		Poiner to entry (NULL = out of memory)
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateAdapterEntry"

CAdapterEntry	*CreateAdapterEntry( void )
{
	DNASSERT( g_pAdapterEntryPool != NULL );
	return	g_pAdapterEntryPool->Get();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnAdapterEntry - return an adapter entry to the pool
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnAdapterEntry"

void	ReturnAdapterEntry( CAdapterEntry *const pAdapterEntry )
{
	DNASSERT( FALSE );
	DNASSERT( pAdapterEntry != NULL );
	DNASSERT( g_pAdapterEntryPool != NULL );
	g_pAdapterEntryPool->Release( pAdapterEntry );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateCommand - create command
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateCommand"

CCommandData	*CreateCommand( void )
{
#ifdef USE_THREADLOCALPOOLS
	CLockedTLPool< CCommandData > *		pPool;
	BOOL								fResult;
	CCommandData *						pCommandData;

	//
	// Get the pool pointer.
	//
	GET_THREADLOCALPTR(WSockThreadLocalPools,
						pCommandDataPool,
						&pPool);

	//
	// Create the pool if it didn't exist.
	//
	if (pPool == NULL)
	{
		pPool = new CLockedTLPool<CCommandData>;
		if (pPool == NULL)
		{
			pCommandData = NULL;
			goto Exit;
		}


		//
		// Try to initialize the pool.
		//
		if ( pPool->Initialize(g_pGlobalCommandDataPool) == FALSE )
		{
			//
			// Initializing pool failed, delete it and abort.
			//
			delete	pPool;
			pCommandData = NULL;
			goto Exit;
		}


		//
		// Associate the pool with this thread.
		//
		SET_THREADLOCALPTR(WSockThreadLocalPools,
							pCommandDataPool,
							pPool,
							&fResult);

		if (! fResult)
		{
			//
			// Associating pool with thread failed, de-initialize it, delete it,
			// and abort.
			//
			pPool->Deinitialize();
			delete pPool;
			pCommandData = NULL;
			goto Exit;
		}
	}

	//
	// Get an item out of the pool.
	//
	pCommandData = pPool->Get();


Exit:
	
	return	pCommandData;
#else // ! USE_THREADLOCALPOOLS
	DNASSERT( g_pCommandDataPool != NULL );
	return	g_pCommandDataPool->Get();
#endif // ! USE_THREADLOCALPOOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnCommand - return a command
//
// Entry:		Pointer to command
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnCommand"

void	ReturnCommand( CCommandData *const pCommand )
{
#ifdef USE_THREADLOCALPOOLS
	CLockedTLPool< CCommandData > *		pPool;
	BOOL								fResult;


	DNASSERT( pCommand != NULL );


	//
	// Get the pool pointer.
	//
	GET_THREADLOCALPTR(WSockThreadLocalPools,
						pCommandDataPool,
						&pPool);


	//
	// Create the pool if it didn't exist.
	//
	if (pPool == NULL)
	{
		if (g_fShuttingDown)
		{
			//
			// Don't try to allocate the pool, just release the item.
			//
			CLockedTLPool<CCommandData>::ReleaseWithoutPool(pCommand);

			return;
		}

		
		pPool = new CLockedTLPool<CCommandData>;
		if (pPool == NULL)
		{
			//
			// Couldn't create this thread's pool, just release the item
			// without the pool.
			//
			CLockedTLPool<CCommandData>::ReleaseWithoutPool(pCommand);

			return;
		}


		//
		// Try to initialize the pool.
		//
		if ( pPool->Initialize(g_pGlobalCommandDataPool) == FALSE )
		{
			//
			// Initializing this thread's pool failed, just release the
			// item without the pool, and destroy the pool object that
			// couldn't be used.
			//
			CLockedTLPool<CCommandData>::ReleaseWithoutPool(pCommand);
			delete pPool;

			return;
		}

		SET_THREADLOCALPTR(WSockThreadLocalPools,
							pCommandDataPool,
							pPool,
							&fResult);
		if (! fResult)
		{
			//
			// Couldn't store this thread's pool, just release the item
			// without the pool, plus de-initialize and destroy the pool
			// object that couldn't be used.
			//
			CLockedTLPool<CCommandData>::ReleaseWithoutPool(pCommand);
			pPool->Deinitialize();
			delete pPool;
			return;
		}
	}

	pPool->Release(pCommand);
#else // ! USE_THREADLOCALPOOLS
	DNASSERT( pCommand != NULL );
	DNASSERT( g_pCommandDataPool != NULL );
	g_pCommandDataPool->Release( pCommand );
#endif // ! USE_THREADLOCALPOOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateEndpointCommandParameter - create an endpoint command parameter
//
// Entry:		Nothing
//
// Exit:		Pointer endpoint command parameter
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateEndpointCommandParameters"

ENDPOINT_COMMAND_PARAMETERS	*CreateEndpointCommandParameters( void )
{
	ENDPOINT_COMMAND_PARAMETERS	*pReturn;

	
	DNASSERT( g_pEndpointCommandParameterPool != NULL );
	pReturn = g_pEndpointCommandParameterPool->Get();
	if ( pReturn != NULL )
	{
		memset( pReturn, 0x00, sizeof( *pReturn ) );
	}

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnEndpointCommandParameter - return an endpoint command parameter
//
// Entry:		Nothing
//
// Exit:		Pointer to endpoint command parameter
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnEndpointCommandParameters"

void	ReturnEndpointCommandParameters( ENDPOINT_COMMAND_PARAMETERS *const pCommandParameters )
{
	DNASSERT( pCommandParameters != NULL );
	DNASSERT( g_pEndpointCommandParameterPool != NULL );
	g_pEndpointCommandParameterPool->Release( pCommandParameters );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateIPAddress - create IP address
//
// Entry:		Nothing
//
// Exit:		Pointer to IP address
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateIPAddress"

CIPAddress	*CreateIPAddress( void )
{
#ifdef USE_THREADLOCALPOOLS
	CFixedTLPool< CIPAddress > *	pPool;
	BOOL							fResult;
	CIPAddress *					pReturnAddress;

	//
	// Get the pool pointer.
	//
	GET_THREADLOCALPTR(WSockThreadLocalPools,
						pIPAddressPool,
						&pPool);

	//
	// Create the pool if it didn't exist.
	//
	if (pPool == NULL)
	{
		pPool = new CFixedTLPool<CIPAddress>(g_pGlobalIPAddressPool);
		if (pPool == NULL)
		{
			pReturnAddress = NULL;
			goto Exit;
		}

		//
		// Associate the pool with this thread.
		//
		SET_THREADLOCALPTR(WSockThreadLocalPools,
							pIPAddressPool,
							pPool,
							&fResult);

		if (! fResult)
		{
			delete pPool;
			pReturnAddress = NULL;
			goto Exit;
		}
	}

	//
	// Get an item out of the pool.
	//
	pReturnAddress = pPool->Get();


Exit:
	
	return	pReturnAddress;
#else // ! USE_THREADLOCALPOOLS
	CIPAddress	*pReturnAddress;


	DNASSERT( g_pIPAddressPool != NULL );

	DNEnterCriticalSection( &g_AddressLock );
	pReturnAddress = g_pIPAddressPool->Get();
	DNLeaveCriticalSection( &g_AddressLock );
	
	return	pReturnAddress;
#endif // ! USE_THREADLOCALPOOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnIPAddress - return an IP address
//
// Entry:		Pointer to IP address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnIPAddress"

void	ReturnIPAddress( CIPAddress *const pIPAddress )
{
#ifdef USE_THREADLOCALPOOLS
	CFixedTLPool< CIPAddress > *	pPool;
	BOOL							fResult;


	DNASSERT( pIPAddress != NULL );

	//
	// Get the pool pointer.
	//
	GET_THREADLOCALPTR(WSockThreadLocalPools,
						pIPAddressPool,
						&pPool);


	//
	// Create the pool if it didn't exist, unless we're shutting down.
	//
	if (pPool == NULL)
	{
		if (g_fShuttingDown)
		{
			//
			// Don't try to allocate the pool, just release the item.
			//
			CFixedTLPool<CIPAddress>::ReleaseWithoutPool(pIPAddress);

			return;
		}

		pPool = new CFixedTLPool<CIPAddress>(g_pGlobalIPAddressPool);
		if (pPool == NULL)
		{
			//
			// Couldn't create this thread's pool, just release the item
			// without the pool.
			//
			CFixedTLPool<CIPAddress>::ReleaseWithoutPool(pIPAddress);

			return;
		}

		SET_THREADLOCALPTR(WSockThreadLocalPools,
							pIPAddressPool,
							pPool,
							&fResult);
		if (! fResult)
		{
			//
			// Couldn't store this thread's pool, just release the item
			// without the pool, and destroy the pool object that
			// couldn't be used.
			//
			CFixedTLPool<CIPAddress>::ReleaseWithoutPool(pIPAddress);
			delete pPool;
			return;
		}
	}

	pPool->Release(pIPAddress);
#else // ! USE_THREADLOCALPOOLS
	DNASSERT( pIPAddress != NULL );
	DNASSERT( g_pIPAddressPool != NULL );
	DNEnterCriticalSection( &g_AddressLock );
	g_pIPAddressPool->Release( pIPAddress );
	DNLeaveCriticalSection( &g_AddressLock );
#endif // ! USE_THREADLOCALPOOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateIPXAddress - create IPX address
//
// Entry:		Nothing
//
// Exit:		Pointer to IPX address
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateIPXAddress"

CIPXAddress	*CreateIPXAddress( void )
{
#ifdef USE_THREADLOCALPOOLS
	CFixedTLPool< CIPXAddress > *	pPool;
	BOOL							fResult;
	CIPXAddress *					pReturnAddress;


	//
	// Get the pool pointer.
	//
	GET_THREADLOCALPTR(WSockThreadLocalPools,
						pIPXAddressPool,
						&pPool);

	//
	// Create the pool if it didn't exist.
	//
	if (pPool == NULL)
	{
		pPool = new CFixedTLPool<CIPXAddress>(g_pGlobalIPXAddressPool);
		if (pPool == NULL)
		{
			pReturnAddress = NULL;
			goto Exit;
		}

		//
		// Associate the pool with this thread.
		//
		SET_THREADLOCALPTR(WSockThreadLocalPools,
							pIPXAddressPool,
							pPool,
							&fResult);

		if (! fResult)
		{
			delete pPool;
			pReturnAddress = NULL;
			goto Exit;
		}
	}

	//
	// Get an item out of the pool.
	//
	pReturnAddress = pPool->Get();


Exit:
	
	return	pReturnAddress;
#else // ! USE_THREADLOCALPOOLS
	CIPXAddress	*pReturnAddress;


	DNASSERT( g_pIPXAddressPool != NULL );

	DNEnterCriticalSection( &g_AddressLock );
	pReturnAddress = g_pIPXAddressPool->Get();
	DNLeaveCriticalSection( &g_AddressLock );
	
	return	pReturnAddress;
#endif // ! USE_THREADLOCALPOOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnIPXAddress - return an IPX address
//
// Entry:		Pointer to IPX address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnIPXAddress"

void	ReturnIPXAddress( CIPXAddress *const pIPXAddress )
{
#ifdef USE_THREADLOCALPOOLS
	CFixedTLPool< CIPXAddress > *	pPool;
	BOOL							fResult;


	DNASSERT( pIPXAddress != NULL );


	//
	// Get the pool pointer.
	//
	GET_THREADLOCALPTR(WSockThreadLocalPools,
						pIPXAddressPool,
						&pPool);


	//
	// Create the pool if it didn't exist.
	//
	if (pPool == NULL)
	{
		if (g_fShuttingDown)
		{
			//
			// Don't try to allocate the pool, just release the item.
			//
			CFixedTLPool<CIPXAddress>::ReleaseWithoutPool(pIPXAddress);

			return;
		}

		
		pPool = new CFixedTLPool<CIPXAddress>(g_pGlobalIPXAddressPool);
		if (pPool == NULL)
		{
			//
			// Couldn't create this thread's pool, just release the item
			// without the pool.
			//
			CFixedTLPool<CIPXAddress>::ReleaseWithoutPool(pIPXAddress);

			return;
		}

		SET_THREADLOCALPTR(WSockThreadLocalPools,
							pIPXAddressPool,
							pPool,
							&fResult);
		if (! fResult)
		{
			//
			// Couldn't store this thread's pool, just release the item
			// without the pool, and destroy the pool object that
			// couldn't be used.
			//
			CFixedTLPool<CIPXAddress>::ReleaseWithoutPool(pIPXAddress);
			delete pPool;
			return;
		}
	}

	pPool->Release(pIPXAddress);
#else // ! USE_THREADLOCALPOOLS
	DNASSERT( pIPXAddress != NULL );
	DNASSERT( g_pIPXAddressPool != NULL );
	DNEnterCriticalSection( &g_AddressLock );
	g_pIPXAddressPool->Release( pIPXAddress );
	DNLeaveCriticalSection( &g_AddressLock );
#endif // ! USE_THREADLOCALPOOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateIPEndpoint - create IP endpoint
//
// Entry:		Pointer to context
//
// Exit:		Pointer to IP endpoint
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateEndpoint"

CIPEndpoint	*CreateIPEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
{
	DNASSERT( g_pIPEndpointPool != NULL );
	return	g_pIPEndpointPool->Get( pContext );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateIPXEndpoint - create IPX endpoint
//
// Entry:		Pointer to context
//
// Exit:		Pointer to IPX endpoint
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateIPXEndpoint"

CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *const pContext )
{
	DNASSERT( g_pIPXEndpointPool != NULL );
	return	g_pIPXEndpointPool->Get( pContext );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateSocketPort - create a socket port
//
// Entry:		Nothing
//
// Exit:		Pointer to socket port
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateSocketPort"

CSocketPort	*CreateSocketPort( void )
{
	CSocketPort	*pReturn;


	DNASSERT( g_pSocketPortPool != NULL );

	pReturn = g_pSocketPortPool->Get();
	if ( pReturn != NULL )
	{
		pReturn->AddRef();
	}
	
	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnSocketPort - return socket port to pool
//
// Entry:		Pointer to socket port
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnSocketPort"

void	ReturnSocketPort( CSocketPort *const pSocketPort )
{
	DNASSERT( pSocketPort != NULL );
	DNASSERT( g_pSocketPortPool != NULL );
	g_pSocketPortPool->Release( pSocketPort );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateThreadPool - create a thread pool
//
// Entry:		Nothing
//
// Exit:		Pointer to thread pool
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateThreadPool"

CThreadPool	*CreateThreadPool( void )
{
	CThreadPool	*pReturn;


	DNASSERT( g_pThreadPoolPool != NULL );
	pReturn = g_pThreadPoolPool->Get();
	if ( pReturn != NULL )
	{
		pReturn->AddRef();
	}

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReturnThreadPool - return a thread pool
//
// Entry:		Pointer to thread pool
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReturnThreadPool"

void	ReturnThreadPool( CThreadPool *const pThreadPool )
{
	DNASSERT( pThreadPool != NULL );
	DNASSERT( g_pThreadPoolPool != NULL );
	g_pThreadPoolPool->Release( pThreadPool );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\pools.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.h
 *  Content:	Pool functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/2000	jtk		Derived from utils.h
 ***************************************************************************/

#ifndef __POOLS_H__
#define __POOLS_H__




//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward structure references
//
class	CAdapterEntry;
class	CCommandData;
class	CIPAddress;
class	CIPXAddress;
class	CIPEndpoint;
class	CIPXEndpoint;
class	CSocketPort;
class	CSPData;
class	CThreadPool;
class	CReadIOData;
class	CWriteIOData;

template< class T >				class	CFixedTLPool;
template< class T, class S >	class	CContextFixedTLPool;

typedef	struct	_ENDPOINT_POOL_CONTEXT			ENDPOINT_POOL_CONTEXT;
typedef	struct	_ENDPOINT_COMMAND_PARAMETERS	ENDPOINT_COMMAND_PARAMETERS;
typedef	struct	_READ_IO_DATA_POOL_CONTEXT		READ_IO_DATA_POOL_CONTEXT;
typedef	struct	_WRITE_IO_DATA_POOL_CONTEXT		WRITE_IO_DATA_POOL_CONTEXT;



#ifdef USE_THREADLOCALPOOLS
//
// Declare the per-thread pool pointers.
//

DECLARE_THREADLOCALPTRS(WSockThreadLocalPools)
{
	CFixedTLPool< CIPAddress > *									pIPAddressPool;		// pointer to pool of IP addresses
	CFixedTLPool< CIPXAddress > *									pIPXAddressPool;	// pointer to pool of IPX addresses
	CContextFixedTLPool<CReadIOData, READ_IO_DATA_POOL_CONTEXT> *	pIPReadIODataPool;	// pointer to pool of IP read data objects
	CContextFixedTLPool<CReadIOData, READ_IO_DATA_POOL_CONTEXT> *	pIPXReadIODataPool;	// pointer to pool of IPX read data objects
	CLockedTLPool< CCommandData > *									pCommandDataPool;	// pointer to pool of command data objects
	CContextFixedTLPool<CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT> *	pWriteIODataPool;	// pointer to pool of write data objects
};

//
// Global backup pools for thread-local pools.
//
extern CFixedTLPool< CIPAddress > *											g_pGlobalIPAddressPool;		// pointer to global IP address pool
extern CFixedTLPool< CIPXAddress > *										g_pGlobalIPXAddressPool;	// pointer to global IPX address pool
extern CContextFixedTLPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT > *		g_pGlobalIPReadIODataPool;	// pointer to global IP read data pool
extern CContextFixedTLPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT > *		g_pGlobalIPXReadIODataPool;	// pointer to global IPX read data pool
extern CLockedTLPool< CCommandData> *										g_pGlobalCommandDataPool;	// pointer to global command data pool
extern CContextFixedTLPool< CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT > *	g_pGlobalWriteIODataPool;	// pointer to global write data pool
#endif // USE_THREADLOCALPOOLS




//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	InitializePools( void );
#ifdef USE_THREADLOCALPOOLS
void	CleanupThreadLocalPools( WSockThreadLocalPools * pThreadLocalPools, DWORD dwThreadID );
#endif // USE_THREADLOCALPOOLS
void	DeinitializePools( void );


CAdapterEntry	*CreateAdapterEntry( void );
void	ReturnAdapterEntry( CAdapterEntry *const pAdapterEntry );

CCommandData	*CreateCommand( void );
void	ReturnCommand( CCommandData *const pCommandData );

ENDPOINT_COMMAND_PARAMETERS	*CreateEndpointCommandParameters( void );
void	ReturnEndpointCommandParameters( ENDPOINT_COMMAND_PARAMETERS *const pCommandParamters );

CIPAddress	*CreateIPAddress( void );
void	ReturnIPAddress( CIPAddress *const pIPAddress );

CIPXAddress	*CreateIPXAddress( void );
void	ReturnIPXAddress( CIPXAddress *const pIPXAddress );

CIPEndpoint		*CreateIPEndpoint( ENDPOINT_POOL_CONTEXT *pContext );
CIPXEndpoint	*CreateIPXEndpoint( ENDPOINT_POOL_CONTEXT *pContext );

CSocketPort	*CreateSocketPort( void );
void	ReturnSocketPort( CSocketPort *const pSocketPort );

CThreadPool	*CreateThreadPool( void );
void	ReturnThreadPool( CThreadPool *const pThreadPool );



#endif	// __POOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\sendqueue.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SendQueue.cpp
 *  Content:	Queue to manage outgoing sends on socket port
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/14/99	jtk		Created
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::CSendQueue - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSendQueue::CSendQueue"

CSendQueue::CSendQueue():m_pHead( NULL ),m_pTail( NULL )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::~CSendQueue - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSendQueue::~CSendQueue"

CSendQueue::~CSendQueue()
{
	DNASSERT( m_pHead == NULL );
	DNASSERT( m_pTail == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::Initialize - initialize this send queue
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSendQueue::Initialize"

HRESULT	CSendQueue::Initialize( void )
{
	HRESULT	hr;


	hr = DPN_OK;
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Could not initialize critical section for SendQueue!" );
	}
	else
	{
		DebugSetCriticalSectionRecursionCount( &m_Lock, 1 );
	}

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSendQueue::FindNextByEndpoint - find next entry in send queue given an endpoint
//
// Entry:		Pointer to handle (initialized to NULL to start scanning)
//				Pointer to endpoint to find
//
// Exit:		Pointer to next item referring to given endpoint
//				NULL = no item found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSendQueue::FindNextByEndpoint"

CWriteIOData	*CSendQueue::FindNextByEndpoint( HANDLE *const pHandle, const CEndpoint *const pEndpoint )
{
	CWriteIOData	*pReturn;


	DNASSERT( pEndpoint != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );

	//
	// initialize
	//
	pReturn = NULL;
	if ( *pHandle == NULL )
	{
		pReturn = m_pHead;
	}

	//
	// loop until we find something
	//
	while ( pReturn != NULL )
	{
		if ( pReturn->m_pCommand->GetEndpoint() == pEndpoint )
		{
			goto Exit;
		}

		pReturn = pReturn->m_pNext;
	}

Exit:
	*pHandle = pReturn;
	return	pReturn;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\sendqueue.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CSendQueue.h
 *  Content:	Queue to manage outgoing sends on socket port
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	06/14/99	jtk		Created
 ***************************************************************************/

#ifndef __SEND_QUEUE_H__
#define __SEND_QUEUE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definition
//**********************************************************************

//
// forward structure references
//
class	CEndpoint;
class	CWriteIOData;

//
// main class definition
//
class	CSendQueue
{
	public:
		CSendQueue();
		~CSendQueue();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		HRESULT	Initialize( void );
		void	Deinitialize( void ) { DNDeleteCriticalSection( &m_Lock ); }

		//
		// add item to end of queue
		//
		void	Enqueue( CWriteIOData *const pWriteData )
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pTail == NULL )
			{
				m_pHead = pWriteData;
			}
			else
			{
				m_pTail->m_pNext = pWriteData;
			}

			m_pTail = pWriteData;
			pWriteData->m_pNext = NULL;
		}

		//
		// add item to front of queue
		//
		void	AddToFront( CWriteIOData *const pWriteData )
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pHead != NULL )
			{
				pWriteData->m_pNext = m_pHead;
			}
			else
			{
				m_pTail = pWriteData;
				pWriteData->m_pNext = NULL;
			}

			m_pHead = pWriteData;
		}

		//
		// remove item from queue
		//
		CWriteIOData	*Dequeue( void )
		{
			CWriteIOData	*pReturn;


			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			pReturn = m_pHead;
			if ( m_pHead != NULL )
			{
				m_pHead = m_pHead->m_pNext;
				if ( m_pHead == NULL )
				{
					m_pTail = NULL;
				}

				DEBUG_ONLY( pReturn->m_pNext = NULL );
			}

			return	pReturn;
		};

		//
		// determine if queue is empty
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CWriteIOData::IsEmpty"
		BOOL	IsEmpty( void )	const
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			if ( m_pHead == NULL )
			{
				DNASSERT( m_pTail == NULL );
				return	TRUE;
			}
			else
			{
				return	FALSE;
			}
		}

		CWriteIOData	*FindNextByEndpoint( HANDLE *const pHandle, const CEndpoint *const pEndpoint );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;		// critical section
		CWriteIOData		*m_pHead;	// pointer to queue head
		CWriteIOData		*m_pTail;	// pointer to queue tail
};

#undef DPF_MODNAME

#endif	// __SEND_QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\socketport.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SocketPort.cpp
 *  Content:	Winsock socket port that manages data flow on a given adapter,
 *				address and port.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	SOCKET_RECEIVE_BUFFER_SIZE		( 128 * 1024 )

#define NAT_LEASE_TIME					3600000 // ask for 1 hour


//
// DPlay port limits (inclusive) scanned to find an available port.
// Exclude 2300 and 2301 because there are network broadcasts on 2301
// that we may receive.
//
static const WORD	g_wBaseDPlayPort = 2302;
static const WORD	g_wMaxDPlayPort = 2400;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::CSocketPort - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	Do not allocate anything in a constructor
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::CSocketPort"

CSocketPort::CSocketPort():
	m_pSPData( NULL ),
	m_pThreadPool( NULL ),
	m_iRefCount( 0 ),
	m_iEndpointRefCount( 0 ),
	m_State( SOCKET_PORT_STATE_UNKNOWN ),
	m_pNetworkSocketAddress( NULL ),
	m_pAdapterEntry( NULL ),
	m_Socket( INVALID_SOCKET ),
	m_hListenEndpoint( INVALID_HANDLE_VALUE ),
	m_iEnumKey( INVALID_ENUM_KEY ),
	m_dwSocketPortID( 0 ),
	m_fUsingProxyWinSockLSP( FALSE ),
	m_pRemoveSocketPortData( NULL ),
	m_pSendFunction( NULL ),
	m_iThreadsInReceive(0)
{
	m_Sig[0] = 'S';
	m_Sig[1] = 'O';
	m_Sig[2] = 'K';
	m_Sig[3] = 'P';
	
	DEBUG_ONLY( m_fInitialized = FALSE );
	m_ActiveListLinkage.Initialize();
	m_blConnectEndpointList.Initialize();
	ZeroMemory( m_ahNATHelpPorts, sizeof(m_ahNATHelpPorts) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::~CSocketPort - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::~CSocketPort"

CSocketPort::~CSocketPort()
{
#ifdef DEBUG
	DWORD	dwTemp;


	//
	// m_pThis needs to be around for the life of the endpoint
	// it should be part of the constructor, but can't be since we're using
	// a pool manager
	//
	DNASSERT( m_pSPData == NULL );
	DNASSERT( m_fInitialized == FALSE );

	DNASSERT( m_iRefCount == 0 );
	DNASSERT( m_iEndpointRefCount == 0 );
	DNASSERT( m_State == SOCKET_PORT_STATE_UNKNOWN );
	DNASSERT( GetSocket() == INVALID_SOCKET );
	DNASSERT( m_pNetworkSocketAddress == NULL );
	DNASSERT( m_pAdapterEntry == NULL );
	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		DNASSERT( m_ahNATHelpPorts[dwTemp] == NULL );
	}
	DNASSERT( m_ActiveListLinkage.IsEmpty() != FALSE );
	DNASSERT( m_blConnectEndpointList.IsEmpty() != FALSE );
	DNASSERT( m_hListenEndpoint == INVALID_HANDLE_VALUE );
	DNASSERT( m_iEnumKey == INVALID_ENUM_KEY );
	DNASSERT( m_pRemoveSocketPortData == NULL );
	DNASSERT( m_pSendFunction == NULL );
	DNASSERT( m_pThreadPool == NULL );
	DNASSERT( m_pSPData == NULL );

	DNASSERT( m_iThreadsInReceive == 0);
#endif // DEBUG
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Initialize - initialize this socket port
//
// Entry:		Pointer to CSPData
//				Pointer to address to bind to
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Initialize"

HRESULT	CSocketPort::Initialize( CSPData *const pSPData, CSocketAddress *const pAddress )
{
	HRESULT	hr;
	HRESULT	hTempResult;


	DNASSERT( pSPData != NULL );
	DNASSERT( pAddress != NULL );

	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%p, 0x%p)", this, pSPData, pAddress);

	//
	// initialize
	//
	hr = DPN_OK;
	m_pSPData = pSPData;
	m_pSPData->ObjectAddRef();
	m_pThreadPool = m_pSPData->GetThreadPool();

	// Deinitialize will assert that these are set in the fail cases, so we set them up front
	DEBUG_ONLY( m_fInitialized = TRUE );
	DNASSERT( m_State != SOCKET_PORT_STATE_INITIALIZED );
	m_State = SOCKET_PORT_STATE_INITIALIZED;

	//
	// attempt to initialize the internal critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to initialize critical section for socket port!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

	if ( DNInitializeCriticalSection( &m_EndpointDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to initialize EndpointDataLock critical section!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_EndpointDataLock, 0 );

	//
	// attempt to initialize the contained send queue
	//
	hr = m_SendQueue.Initialize();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem initializing send queue!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// initialize the endpoint list with 64 entries and grow by a factor of 16
	//
	DNASSERT( hr == DPN_OK );
	if ( m_ConnectEndpointHash.Initialize( 6, 4 ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Could not initialize the connect endpoint list!" );
		goto Failure;
	}

	//
	// initialize enum list with 16 entries and grow by a factor of 4
	//
	DNASSERT( hr == DPN_OK );
	if ( m_EnumEndpointHash.Initialize( 4, 2 ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Could not initialize the enum endpoint list!" );
		goto Failure;
	}

	//
	// allocate addresses:
	//		local address this socket is binding to
	//		address of received messages
	//
	DNASSERT( m_pNetworkSocketAddress == NULL );
	m_pNetworkSocketAddress = pAddress;

	DNASSERT( m_pSendFunction == NULL );
	
	//
	// Winsock 2 functionality always exists on WinNT.  If we're on Win9x, we can
	// only use Winsock2 interfaces for TCP.
	//
#ifdef WINNT
	m_pSendFunction = Winsock2Send;
#else // WIN95
	if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) && ( m_pSPData->GetType() == TYPE_IP ) )
	{
		m_pSendFunction = Winsock2Send;
	}
	else
	{
		m_pSendFunction = Winsock1Send;
	}
#endif

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem in CSocketPort::Initialize()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 6, "(0x%p) Leave [0x%lx]", this, hr);

	return hr;

Failure:
	DEBUG_ONLY( m_fInitialized = FALSE );

	hTempResult = Deinitialize();
	if ( hTempResult != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem deinitializing CSocketPort on failed Initialize!" );
		DisplayDNError( 0, hTempResult );
	}

	m_pNetworkSocketAddress = NULL;

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Deinitialize - deinitialize this socket port
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Deinitialize"

HRESULT	CSocketPort::Deinitialize( void )
{
	HRESULT	hr;
#ifdef DEBUG
	DWORD	dwTemp;
#endif // DEBUG


	DPFX(DPFPREP, 6, "(0x%p) Enter", this);

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();
	DNASSERT( ( m_State == SOCKET_PORT_STATE_INITIALIZED ) ||
			  ( m_State == SOCKET_PORT_STATE_UNBOUND ) );
	DEBUG_ONLY( m_fInitialized = FALSE );

	DNASSERT( m_iEndpointRefCount == 0 );
	DNASSERT( m_iRefCount == 0 );

	//
	// return base network socket addresses
	//
	if ( m_pNetworkSocketAddress != NULL )
	{
		m_pSPData->ReturnAddress( m_pNetworkSocketAddress );
		m_pNetworkSocketAddress = NULL;
	}


#ifdef DEBUG
	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		DNASSERT( m_ahNATHelpPorts[dwTemp] == NULL );
	}
#endif // DEBUG

	m_pSendFunction = NULL;
	m_iEnumKey = INVALID_ENUM_KEY;

	m_SendQueue.Deinitialize();

	m_EnumEndpointHash.Deinitialize();
	m_ConnectEndpointHash.Deinitialize();

	Unlock();

	DNDeleteCriticalSection( &m_EndpointDataLock );
	DNDeleteCriticalSection( &m_Lock );

	DNASSERT( m_pSPData != NULL );
	m_pSPData->ObjectDecRef();
	m_pSPData = NULL;
	m_pThreadPool = NULL;


	DPFX(DPFPREP, 6, "(0x%p) Leave [0x%lx]", this, hr);

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::EndpointAddRef - increment endpoint reference count
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	This function should not be called without having the SP's SocketPort
//			data locked to make sure we're the only ones playing with socket ports!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::EndpointAddRef"

void	CSocketPort::EndpointAddRef( void )
{
	Lock();

	//
	// add a global reference and then add an endpoint reference
	//
	DNASSERT( m_iEndpointRefCount != -1 );
	m_iEndpointRefCount++;
	AddRef();

	DPFX(DPFPREP, 9, "(0x%p) Endpoint refcount is now %i.",
		this, m_iEndpointRefCount );

	Unlock();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::EndpointDecRef - decrement endpoint reference count
//
// Entry:		Nothing
//
// Exit:		Endpoint reference count
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::EndpointDecRef"

DWORD	CSocketPort::EndpointDecRef( void )
{
	DWORD	dwReturn;


	Lock();

	DNASSERT( m_iEndpointRefCount != 0 );

	m_iEndpointRefCount--;
	dwReturn = m_iEndpointRefCount;
	if ( m_iEndpointRefCount == 0 )
	{
		HRESULT	hr;


		DPFX(DPFPREP, 7, "(0x%p) Endpoint refcount hit 0, beginning to unbind from network.", this );
		
		//
		// No more endpoints are referencing this item, unbind this socket port
		// from the network and then remove it from the active socket port list.
		// If we're on Winsock1, tell the other thread that this socket needs to
		// be removed so we can get rid of our outstanding I/O reference.
		//
#ifdef WIN95
		if ( ( LOWORD( GetWinsockVersion() ) == 1 ) || ( m_pSPData->GetType() == TYPE_IPX ) ) 
		{
			m_pSPData->GetThreadPool()->RemoveSocketPort( this );
		}
#endif

		// Don't allow any more receives through
		m_State = SOCKET_PORT_STATE_UNBOUND;

		// Wait for any receives that were already in to get out
		while (m_iThreadsInReceive != 0)
		{
			DPFX(DPFPREP, 9, "There are %i threads still receiving for socketport 0x%p...", m_iThreadsInReceive, this);
			Unlock();
			Sleep(10);
			Lock();
		}

		hr = UnbindFromNetwork();
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Problem unbinding from network when final endpoint has disconnected!" );
			DisplayDNError( 0, hr );
		}

		DNASSERT( m_pNetworkSocketAddress != NULL );
	}
	else
	{
		DPFX(DPFPREP, 9, "(0x%p) Endpoint refcount is %i, not unbinding from network.",
			this, m_iEndpointRefCount );
	}

	//
	// Decrement global reference count.  This had better not result in this
 	// socketport being returned to the pool!  There should always be at
 	// least one more regular reference than an endpoint reference because
 	// our caller should have a regular reference.
	//
	DNASSERT(m_iRefCount > 1);
	DecRef();

	Unlock();

	return	dwReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::BindEndpoint - add an endpoint to this SP's list
//
// Entry:		Pointer to endpoint
//				Gateway bind type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindEndpoint"

HRESULT	CSocketPort::BindEndpoint( CEndpoint *const pEndpoint, GATEWAY_BIND_TYPE GatewayBindType )
{
	HRESULT					hr;
#ifdef DEBUG
	const CSocketAddress *	pSocketAddress;
	const SOCKADDR *		pSockAddr;
#endif // DEBUG


	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%p, %i)",
		this, pEndpoint, GatewayBindType);

	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( m_iRefCount != 0 );
	DNASSERT( m_iEndpointRefCount != 0 );

	pEndpoint->ChangeLoopbackAlias( GetNetworkAddress() );

	LockEndpointData();


	switch ( pEndpoint->GetType() )
	{
		//
		// Treat 'connect' and 'connect on listen' endpoints as the same type.
 		// We don't care how many connections are made through this socket port,
 		// just make sure we're not connecting to the same person more than once.
		//
		case ENDPOINT_TYPE_CONNECT:
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
		{
			HANDLE	hExistingEndpoint;


#ifdef DEBUG
			//
			// Make sure it's a valid address.
			//

			pSocketAddress = pEndpoint->GetRemoteAddressPointer();
			DNASSERT(pSocketAddress != NULL);
			pSockAddr = pSocketAddress->GetAddress();
			DNASSERT(pSockAddr != NULL);

			if (pSocketAddress->GetFamily() == AF_INET)
			{
				DNASSERT( ((SOCKADDR_IN*) pSockAddr)->sin_addr.S_un.S_addr != 0 );
				DNASSERT( ((SOCKADDR_IN*) pSockAddr)->sin_addr.S_un.S_addr != INADDR_BROADCAST );
				DNASSERT( pSocketAddress->GetPort() != 0 );
			}
#endif // DEBUG

			if ( m_ConnectEndpointHash.Find( pEndpoint->GetRemoteAddressPointer() , &hExistingEndpoint ) != FALSE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPFX(DPFPREP, 0, "Attempted to connect twice to the same endpoint!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			if ( m_ConnectEndpointHash.Insert( pEndpoint->GetRemoteAddressPointer(), pEndpoint->GetHandle() ) == FALSE )
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP, 0, "Problem adding endpoint to connect socket port hash!" );
				goto Failure;
			}

			if (pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT)
			{
				pEndpoint->AddToSocketPortList(&this->m_blConnectEndpointList);

				//
				// CONNECTs must be on a DPlay selected or fixed port.  They can't be
				// shared but the underlying socketport must be mapped on the gateway.
				//
				DNASSERT((GatewayBindType == GATEWAY_BIND_TYPE_DEFAULT) || (GatewayBindType == GATEWAY_BIND_TYPE_SPECIFIC));
			}
			else
			{
				//
				// CONNECT_ON_LISTEN endpoints should always be bound as NONE
				// since they should not need port mappings on the gateway.
				//
				DNASSERT(GatewayBindType == GATEWAY_BIND_TYPE_NONE);
			}
			pEndpoint->SetSocketPort( this );
			pEndpoint->AddRef();

			break;
		}

		//
		// we only allow one listen endpoint on a socket port
		//
		case ENDPOINT_TYPE_LISTEN:
		{
			if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPFX(DPFPREP, 0, "Attempted to listen more than once on a given SocketPort!" );
				goto Failure;
			}
			
			//
			// LISTENs can be on a DPlay selected or fixed port, and the fixed port
			// may be shared.
			//
			DNASSERT((GatewayBindType == GATEWAY_BIND_TYPE_DEFAULT) || (GatewayBindType == GATEWAY_BIND_TYPE_SPECIFIC) || (GatewayBindType == GATEWAY_BIND_TYPE_SPECIFIC_SHARED));

			m_hListenEndpoint = pEndpoint->GetHandle();
			pEndpoint->SetSocketPort( this );
			pEndpoint->AddRef();

			break;
		}

		//
		// we don't allow duplicate enum endpoints
		//
		case ENDPOINT_TYPE_ENUM:
		{
			HANDLE	hExistingEndpoint;


#ifdef DEBUG
			//
			// Make sure it's a valid address.
			//

			pSocketAddress = pEndpoint->GetRemoteAddressPointer();
			DNASSERT(pSocketAddress != NULL);
			pSockAddr = pSocketAddress->GetAddress();
			DNASSERT(pSockAddr != NULL);

			if (pSocketAddress->GetFamily() == AF_INET)
			{
				DNASSERT( ((SOCKADDR_IN*) pSockAddr)->sin_addr.S_un.S_addr != 0 );
				DNASSERT( pSocketAddress->GetPort() != 0 );
			}
#endif // DEBUG

			pEndpoint->SetEnumKey( GetEnumKey() );
			if ( m_EnumEndpointHash.Find( pEndpoint->GetEnumKey(), &hExistingEndpoint ) != FALSE )
			{
				hr = DPNERR_ALREADYINITIALIZED;
				DPFX(DPFPREP, 0, "Attempted to enum twice to the same endpoint!" );
				goto Failure;
			}

			DNASSERT( hr == DPN_OK );
			if ( m_EnumEndpointHash.Insert( pEndpoint->GetEnumKey(), pEndpoint->GetHandle() ) == FALSE )
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP, 0, "Problem adding endpoint to enum socket port h!" );
				goto Failure;
			}

			//
			// ENUMs must be on a DPlay selected or fixed port.  They can't be
			// shared but the underlying socketport must be mapped on the gateway.
			//
			DNASSERT((GatewayBindType == GATEWAY_BIND_TYPE_DEFAULT) || (GatewayBindType == GATEWAY_BIND_TYPE_SPECIFIC));

			pEndpoint->SetSocketPort( this );
			pEndpoint->AddRef();

			break;
		}

		//
		// unknown endpoint type
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}

	pEndpoint->SetGatewayBindType(GatewayBindType);
	
	
	UnlockEndpointData();

Exit:

	DPFX(DPFPREP, 6, "(0x%p) Returning [0x%lx]", this, hr);

	return	hr;


Failure:
	UnlockEndpointData();
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::UnbindEndpoint - remove an endpoint from the SP's list
//
// Entry:		Pointer to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::UnbindEndpoint"

void	CSocketPort::UnbindEndpoint( CEndpoint *const pEndpoint )
{
#ifdef DEBUG
	HANDLE	hFindTemp;
#endif // DEBUG

	DPFX(DPFPREP, 6, "(0x%p) Parameters (0x%p)", this, pEndpoint);

	LockEndpointData();


	pEndpoint->SetGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


	//
	// adjust any special pointers before removing endpoint
	//
	switch ( pEndpoint->GetType() )
	{
		//
		// Connect and connect-on-listen endpoints are the same.
		// Remove endpoint from connect list.
		//
		case ENDPOINT_TYPE_CONNECT:
		case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
		{
			DNASSERT( m_ConnectEndpointHash.Find( pEndpoint->GetRemoteAddressPointer(), &hFindTemp ) );
			m_ConnectEndpointHash.Remove( pEndpoint->GetRemoteAddressPointer() );

			if (pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT)
			{
				pEndpoint->RemoveFromSocketPortList();
			}

			//
			// The multiplex list is protected by the SPData -> LockSocketPortData() lock,
			// which should already be taken by our caller.  Unfortunately we can't assert
			// that since we don't have access to that member variable.
			// Removing from a list when not in a list does not cause any problems.
			//
			//AssertCriticalSectionIsTakenByThisThread( &this->m_pSPData->m_SocketPortDataLock, TRUE );
			pEndpoint->RemoveFromMultiplexList();

			pEndpoint->SetSocketPort( NULL );
			pEndpoint->DecRef();
			break;
		}

		//
		// make sure this is really the active listen and then remove it
		//
		case ENDPOINT_TYPE_LISTEN:
		{
			DNASSERT( m_hListenEndpoint != INVALID_HANDLE_VALUE );
			m_hListenEndpoint = INVALID_HANDLE_VALUE;
			pEndpoint->SetSocketPort( NULL );
			pEndpoint->DecRef();
			break;
		}

		//
		// remove endpoint from enum list
		//
		case ENDPOINT_TYPE_ENUM:
		{
			DEBUG_ONLY( DNASSERT( m_EnumEndpointHash.Find( pEndpoint->GetEnumKey(), &hFindTemp ) != FALSE ) );
			m_EnumEndpointHash.Remove( pEndpoint->GetEnumKey() );

			//
			// The multiplex list is protected by the SPData -> LockSocketPortData() lock,
			// which should already be taken by our caller.  Unfortunately we can't assert
			// that since we don't have access to that member variable.
			// Removing from a list when not in a list does not cause any problems.
			//
			//AssertCriticalSectionIsTakenByThisThread( &this->m_pSPData->m_SocketPortDataLock, TRUE );
			pEndpoint->RemoveFromMultiplexList();

			pEndpoint->SetSocketPort( NULL );
			pEndpoint->DecRef();
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	UnlockEndpointData();


	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::ReturnSelfToPool - return this object to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::ReturnSelfToPool"

void	CSocketPort::ReturnSelfToPool( void )
{
	m_State = SOCKET_PORT_STATE_UNKNOWN;
	DNASSERT( m_pSPData == NULL );
	ReturnSocketPort( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SendEnumQueryData - send data for an enum query
//
// Entry:		Pointer to write data
//				Enum key
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendEnumQueryData"

void	CSocketPort::SendEnumQueryData( CWriteIOData *const pWriteData, const UINT_PTR uEnumKey )
{
	pWriteData->m_pBuffers = &pWriteData->m_pBuffers[ -1 ];
	pWriteData->m_uBufferCount++;
	DBG_CASSERT( sizeof( &pWriteData->m_PrependBuffer.EnumDataHeader ) == sizeof( BYTE* ) );
	pWriteData->m_pBuffers[ 0 ].pBufferData = reinterpret_cast<BYTE*>( &pWriteData->m_PrependBuffer.EnumDataHeader );
	pWriteData->m_pBuffers[ 0 ].dwBufferSize = sizeof( pWriteData->m_PrependBuffer.EnumDataHeader );
	
	DNASSERT( pWriteData->m_PrependBuffer.EnumResponseDataHeader.bSPLeadByte == SP_HEADER_LEAD_BYTE);
	pWriteData->m_PrependBuffer.EnumResponseDataHeader.bSPCommandByte = ENUM_DATA_KIND;

	DNASSERT( uEnumKey <= WORD_MAX );
	pWriteData->m_PrependBuffer.EnumResponseDataHeader.wEnumResponsePayload = static_cast<WORD>( uEnumKey );


	SendData( pWriteData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SendData - send data
//
// Entry:		Pointer to write data
//				Pointer to return address (real address the message should be returned to)
//				Enum key
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendProxiedEnumData"

void	CSocketPort::SendProxiedEnumData( CWriteIOData *const pWriteData, const CSocketAddress *const pReturnAddress, const UINT_PTR uOldEnumKey )
{
	DNASSERT( pWriteData != NULL );
	DNASSERT( pReturnAddress != NULL );

	pWriteData->m_pBuffers = &pWriteData->m_pBuffers[ -1 ];
	pWriteData->m_uBufferCount++;

	//
	// We could save 2 bytes on IPX by only passing 14 bytes for the
	// SOCKADDR structure but it's not worth it, especially since it's
	// looping back in the local network stack.  SOCKADDR structures are also
	// 16 bytes so reducing the data passed to 14 bytes would destroy alignment.
	//
	DBG_CASSERT( sizeof( pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.ReturnAddress ) == 16 );
	DBG_CASSERT( sizeof( &pWriteData->m_PrependBuffer.ProxiedEnumDataHeader ) == sizeof( BYTE* ) );
	pWriteData->m_pBuffers[ 0 ].pBufferData = reinterpret_cast<BYTE*>( &pWriteData->m_PrependBuffer.ProxiedEnumDataHeader );
	pWriteData->m_pBuffers[ 0 ].dwBufferSize = sizeof( pWriteData->m_PrependBuffer.ProxiedEnumDataHeader );
	
	DNASSERT( pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.bSPLeadByte == SP_HEADER_LEAD_BYTE );
	pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.bSPCommandByte = PROXIED_ENUM_DATA_KIND;
	
	DNASSERT( uOldEnumKey <= WORD_MAX );
	pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.wEnumKey = static_cast<WORD>( uOldEnumKey );

	DBG_CASSERT( sizeof( pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.ReturnAddress ) == sizeof( *pReturnAddress->GetAddress() ) );
	memcpy( &pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.ReturnAddress,
			pReturnAddress->GetAddress(),
			sizeof( pWriteData->m_PrependBuffer.ProxiedEnumDataHeader.ReturnAddress ) );

	SendData( pWriteData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SendData - send data
//
// Entry:		Pointer to write data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendData"

void	CSocketPort::SendData( CWriteIOData *const pWriteData )
{
	DNASSERT( pWriteData != NULL );
	DNASSERT( pWriteData->SocketPort() == NULL );

	pWriteData->SetSocketPort( this );

	m_SendQueue.Lock();

	//
	// If the send queue is not empty, add this item to the end of the queue and
	// then attempt to send as much as possible.  Otherwise attempt to send this
	// data immediately.
	//
	if ( m_SendQueue.IsEmpty() == FALSE )
	{
		BOOL	fIOServiced;


		m_SendQueue.Enqueue( pWriteData );
		m_SendQueue.Unlock();
		fIOServiced = SendFromWriteQueue();
	}
	else
	{
		SEND_COMPLETION_CODE	SendCompletionCode;


		//
		// there are no items in the queue, attempt to send
		//
		m_SendQueue.Unlock();

		DPFX(DPFPREP, 8, "WriteData 0x%p", pWriteData);
		
		pWriteData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );

		SendCompletionCode = (this->*m_pSendFunction)( pWriteData );
		switch ( SendCompletionCode )
		{
			//
			// Send has been spooled to Winsock, nothing to do
			//
			case SEND_IN_PROGRESS:
			{
				DPFX(DPFPREP, 8, "SendInProgress, will complete later" );
				break;
			}

			//
			// send completed immediately on Winsock1
			//
			case SEND_COMPLETED_IMMEDIATELY_WS1:
			{
				SendComplete( pWriteData, DPN_OK );
				break;
			}

			//
			// Send can't be submitted, spool it so it will go out the next
			// time someone tries to send.  Reset the command state to allow the
			// user to cancel the command.
			//
			case SEND_WINSOCK_BUSY:
			{
				DPFX(DPFPREP, 8, "Winsock Busy - Requeueing Send" );
				pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );
				m_SendQueue.Lock();
				m_SendQueue.AddToFront( pWriteData );
				m_SendQueue.Unlock();
				break;
			}

			//
			// something went wrong, tell the user that their send barfed and
			// that the connection is probably going bye-bye
			//
			case SEND_FAILED:
			{
				SendComplete( pWriteData, DPNERR_CONNECTIONLOST );
				break;
			}

			//
			// invalid return
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}
}
//**********************************************************************

#ifdef WIN95
//**********************************************************************
// ------------------------------
// CSocketPort::Winsock1ReadService - service a read request on a socket
//
// Entry:		Nothing
//
// Exit:		Boolean indicating whether I/O was serviced
//				TRUE = I/O serviced
//				FALSE = I/O not serviced
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock1ReadService"

BOOL	CSocketPort::Winsock1ReadService( void )
{
	BOOL		fIOServiced;
	INT			iSocketReturn;
	READ_IO_DATA_POOL_CONTEXT	PoolContext;
	CReadIOData		*pReadData;


	//
	// initialize
	//
	fIOServiced = FALSE;
	
	//
	// Attempt to get a new receive buffer from the pool.  If we fail, we'll
	// just fail to service this read and the socket will still be labeled
	// as ready to receive so we'll try again later.
	//
	PoolContext.SPType = m_pSPData->GetType();
	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
	if ( pReadData == NULL )
	{
		DPFX(DPFPREP, 0, "Could not get read data to perform a Winsock1 read!" );
		goto Exit;
	}

	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( char* ) );
	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
	pReadData->SetSocketPort( NULL );
	iSocketReturn = p_recvfrom( GetSocket(),												// socket to read from
								reinterpret_cast<char*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ),	// pointer to receive buffer
								pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize,		// size of receive buffer
								0,															// flags (none)
								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
								&pReadData->m_iSocketAddressSize							// size of address of sending socket
								);
	switch ( iSocketReturn )
	{
		//
		// socket has been closed
		//
		case 0:
		{
			break;
		}

		//
		// problem
		//
		case SOCKET_ERROR:
		{
			DWORD	dwWinsockError;


			dwWinsockError = p_WSAGetLastError();
			switch ( dwWinsockError )
			{
				//
				// one of our previous sends failed to get through,
				// and we don't really care anymore
				//
				case WSAECONNRESET:
				{
					break;
				}

				//
				// This socket was probably closed
				//
				case WSAENOTSOCK:
				{
					DPFX(DPFPREP, 8, "Winsock1 reporting 'Not a socket' on receive!" );
					break;
				}

				//
				// there is no data to read
				//
				case WSAEWOULDBLOCK:
				{
					DPFX(DPFPREP, 8, "Winsock1 reporting there is no data to receive on a socket!" );
					break;
				}

				//
				// something bad happened
				//
				default:
				{
					DPFX(DPFPREP, 0, "Problem with Winsock1 recvfrom!" );
					DisplayWinsockError( 0, dwWinsockError );
					DNASSERT( FALSE );

					break;
				}
			}

			break;
		}

		//
		// bytes were read
		//
		default:
		{
			fIOServiced = TRUE;
			pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = iSocketReturn;
			ProcessReceivedData( pReadData );

			break;
		}
	}

	DNASSERT( pReadData != NULL );
	pReadData->DecRef();

Exit:
	return fIOServiced;
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CSocketPort::Winsock1WriteService - service a write request on a socket
//
// Entry:		Nothing
//
// Exit:		Boolean indicating whether I/O was serviced
//				TRUE = I/O serviced
//				FALSE = I/O not serviced
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock1WriteService"

BOOL	CSocketPort::Winsock1WriteService( void )
{
	BOOL	fIOServiced;


	fIOServiced = FALSE;
	m_SendQueue.Lock();

	//
	// if there's data to send, attempt to send it
	//
	if ( m_SendQueue.IsEmpty() == FALSE )
	{
		fIOServiced = SendFromWriteQueue();
	}

	m_SendQueue.Unlock();

	return	fIOServiced;
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CSocketPort::Winsock1ErrorService - service an error on this socket
//
// Entry:		Nothing
//
// Exit:		Boolean indicating whether I/O was serviced
//				TRUE = I/O serviced
//				FALSE = I/O not serviced
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock1ErrorService"

BOOL	CSocketPort::Winsock1ErrorService( void )
{
	//
	// this function doesn't do anything because errors on sockets will usually
	// result in the socket being closed soon
	//
	return	FALSE;
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CSocketPort::Winsock1Send - send data in a Winsock 1.0 fashion
//
// Entry:		Pointer to write data
//
// Exit:		Send completion code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock1Send"

SEND_COMPLETION_CODE	CSocketPort::Winsock1Send( CWriteIOData *const pWriteData )
{
	SEND_COMPLETION_CODE	SendCompletionCode;
	INT			iSendToReturn;
	UINT_PTR	uOutputBufferIndex;
	INT			iOutputByteCount;
	char		TempBuffer[ MAX_MESSAGE_SIZE ];


	DNASSERT( pWriteData != NULL );

	//
	// initialize
	//
	SendCompletionCode = SEND_COMPLETED_IMMEDIATELY_WS1;

	//
	// flatten output data
	//
	iOutputByteCount = 0;
	uOutputBufferIndex = 0;

	DNASSERT( pWriteData->m_uBufferCount != 0 );
	do
	{
		DNASSERT( ( iOutputByteCount + pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize ) <= LENGTHOF( TempBuffer ) );
		memcpy( &TempBuffer[ iOutputByteCount ], pWriteData->m_pBuffers[ uOutputBufferIndex ].pBufferData, pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize );
		iOutputByteCount += pWriteData->m_pBuffers[ uOutputBufferIndex ].dwBufferSize;

		uOutputBufferIndex++;
	} while( uOutputBufferIndex < pWriteData->m_uBufferCount );

#ifdef DEBUG
	DPFX(DPFPREP, 8, "Winsock1 sending %i bytes to socket:", iOutputByteCount);
	DumpSocketAddress( 8, pWriteData->m_pDestinationSocketAddress->GetAddress(), pWriteData->m_pDestinationSocketAddress->GetFamily() );

	switch (pWriteData->m_pDestinationSocketAddress->GetFamily() )
	{
		case AF_INET:
		{
			SOCKADDR_IN *	psaddrin;

			psaddrin = (SOCKADDR_IN *) pWriteData->m_pDestinationSocketAddress->GetAddress();
			
			DNASSERT( psaddrin->sin_addr.S_un.S_addr != 0 );
			DNASSERT( psaddrin->sin_port != 0 );

			break;
		}
		
		case AF_IPX:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
#endif // DEBUG


	//
	// there is no need to note an I/O reference because our Winsock1 I/O is synchronous
	//
	iSendToReturn = p_sendto( GetSocket(),			// socket
							  TempBuffer,			// data to send
							  iOutputByteCount,		// number of bytes to send
							  0,					// flags (none)
							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
							  pWriteData->m_pDestinationSocketAddress->GetAddressSize()		// size of destination address
							  );
	switch ( iSendToReturn )
	{
		//
		// problem with send
		//
		case SOCKET_ERROR:
		{
			DWORD	dwWinsockError;


			dwWinsockError = p_WSAGetLastError();
			switch ( dwWinsockError )
			{
				//
				// socket would block on call
				//
				case WSAEWOULDBLOCK:
				{
					SendCompletionCode = SEND_WINSOCK_BUSY;
					break;
				}

				//
				// other problem
				//
				default:
				{
					SendCompletionCode = SEND_FAILED;
					DNASSERT( pWriteData->Win9xOperationPending() == FALSE );

					DPFX(DPFPREP, 0, "Problem with Winsock1 sendto!" );
					DisplayWinsockError( 0, dwWinsockError );
					break;
				}
			}

			break;
		}

		//
		// send went through, make sure all bytes were sent
		//
		default:
		{
			DNASSERT( iSendToReturn == iOutputByteCount );
			DNASSERT( SendCompletionCode == SEND_COMPLETED_IMMEDIATELY_WS1 );

			break;
		}
	}

	return	SendCompletionCode;
}
//**********************************************************************
#endif // WIN95


//**********************************************************************
// ------------------------------
// CSocketPort::Winsock2Send - send data in a Winsock 2.0 fashion
//
// Entry:		Pointer to write data
//
// Exit:		Send completion code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock2Send"

SEND_COMPLETION_CODE	CSocketPort::Winsock2Send( CWriteIOData *const pWriteData )
{
	SEND_COMPLETION_CODE	SendCompletionCode;
	INT						iWSAReturn;
#ifdef DEBUG
	UINT_PTR				uBuffer;
	UINT_PTR				uTotalSize;
#endif // DEBUG


	DNASSERT( pWriteData != NULL );
	DNASSERT( pWriteData->SocketPort() == this );

	//
	// initialize
	//
	SendCompletionCode = SEND_IN_PROGRESS;

	//
	// note an I/O reference before submitting command
	//
	AddRef();

	DBG_CASSERT( sizeof( pWriteData->m_pBuffers ) == sizeof( WSABUF* ) );
	DBG_CASSERT( sizeof( *pWriteData->m_pBuffers ) == sizeof( WSABUF ) );
#ifdef WIN95
	DNASSERT(pWriteData->OverlapEvent() != NULL );
#endif
	DNASSERT( pWriteData->m_pDestinationSocketAddress != NULL );


#ifdef DEBUG
	uTotalSize = 0;
	
	for(uBuffer = 0; uBuffer < pWriteData->m_uBufferCount; uBuffer++)
	{
		DNASSERT(pWriteData->m_pBuffers[uBuffer].pBufferData != NULL);
		DNASSERT(pWriteData->m_pBuffers[uBuffer].dwBufferSize != 0);

		uTotalSize += pWriteData->m_pBuffers[uBuffer].dwBufferSize;
	}
	
	DPFX(DPFPREP, 7, "(0x%p) Winsock2 sending %u bytes (in WriteData 0x%p's %u buffers, command = 0x%p) from + to:",
		this, uTotalSize, pWriteData, uBuffer, pWriteData->m_pCommand );
	DumpSocketAddress( 7, this->GetNetworkAddress()->GetAddress(), this->GetNetworkAddress()->GetFamily() );
	DumpSocketAddress( 7, pWriteData->m_pDestinationSocketAddress->GetAddress(), pWriteData->m_pDestinationSocketAddress->GetFamily() );

	switch (pWriteData->m_pDestinationSocketAddress->GetFamily() )
	{
		case AF_INET:
		{
			SOCKADDR_IN *	psaddrin;

			psaddrin = (SOCKADDR_IN *) pWriteData->m_pDestinationSocketAddress->GetAddress();
			
			DNASSERT( psaddrin->sin_addr.S_un.S_addr != 0 );
			DNASSERT( psaddrin->sin_port != 0 );

			break;
		}
		
		case AF_IPX:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
#endif // DEBUG

	//
	// lock the 'pending operation' list over the call to Winsock to prevent the
	// operation from being completed while it's being set up.
	//
#ifdef WIN95
	m_pSPData->GetThreadPool()->LockWriteData();
#endif
	
	//
	// Note that this operation is now in a 'pending' status.  It really
	// isn't yet, but Windows should alert us to that if we attempt to query
	// for I/O completion before the operation has been submitted.  Only assert
	// the 'pending' flag on Win9x.
	//
	DNASSERT( pWriteData->m_dwOverlappedBytesSent == 0 );
#ifdef WIN95
	DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
	pWriteData->SetWin9xOperationPending( TRUE );
#endif

	DNASSERT( pWriteData->m_uBufferCount <= UINT32_MAX );
	iWSAReturn = p_WSASendTo( GetSocket(),													// socket
							  reinterpret_cast<WSABUF*>( pWriteData->m_pBuffers ),			// buffers
							  static_cast<DWORD>( pWriteData->m_uBufferCount ),				// count of buffers
							  &pWriteData->m_dwBytesSent,									// pointer to number of bytes sent
							  0,															// send flags
							  pWriteData->m_pDestinationSocketAddress->GetAddress(),		// pointer to destination address
							  pWriteData->m_pDestinationSocketAddress->GetAddressSize(),	// size of destination address
							  pWriteData->Overlap(),										// pointer to overlap structure
							  NULL															// APC callback (unused)
							  );
#ifdef WIN95
	m_pSPData->GetThreadPool()->UnlockWriteData();
#endif

	if ( iWSAReturn == SOCKET_ERROR )
	{
		DWORD	dwWSAError;


		dwWSAError = p_WSAGetLastError();
		switch ( dwWSAError )
		{
			//
			// I/O is pending, note that the command cannot be cancelled,
			// wait for completion
			//
			case WSA_IO_PENDING:
			{
				DNASSERT( SendCompletionCode == SEND_IN_PROGRESS );				
				break;
			}

			//
			// could not submit another overlapped I/O request, indicate that
			// the send was busy so someone above us spools the send for later
			//
			case WSAEWOULDBLOCK:
			{
				DPFX(DPFPREP, 8, "Got WSAEWOULDBLOCK from WSASendTo." );
				SendCompletionCode = SEND_WINSOCK_BUSY;
				DecRef();
				break;
			}

			//
			// socket was closed on us
			//
			case WSAENOTSOCK:
			default:
			{
				SendCompletionCode = SEND_FAILED;

				DPFX(DPFPREP, 8, "WSASendTo failed (error = %u).", dwWSAError );

				//
				// the operation was assumed to be pending and it's definitely
				// not going to be sent now
				//
#ifdef WIN95
				DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
				pWriteData->SetWin9xOperationPending( FALSE );
#endif

				switch ( dwWSAError )
				{
					//
					// WSAENOTSOCK: another thread closed the socket
					// WSAENOBUFS: machine out of memory
					// WSAEADDRNOTAVAIL: can't reach destination (dialup connection probably dropped)
					//
					case WSAENOTSOCK:
					case WSAENOBUFS:
					case WSAEADDRNOTAVAIL:
					{
						break;
					}

					default:
					{
						//
						// something bad happened, stop and take a look
						//
						DisplayWinsockError( 0, dwWSAError );
						DNASSERT( FALSE );
						break;
					}
				}

				DecRef();
				break;
			}
		}
	}
	else
	{
		//
		// Send completed immediately.  There should be nothing to do because
		// the delayed I/O completion notification will still be given and we
		// will do final processing at that time.
		//
		DNASSERT( SendCompletionCode == SEND_IN_PROGRESS );
	}

	return	SendCompletionCode;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Winsock2Receive - receive data in a Winsock 2.0 fashion
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock2Receive"

HRESULT	CSocketPort::Winsock2Receive( void )
{
	HRESULT			hr;
	INT				iWSAReturn;
	READ_IO_DATA_POOL_CONTEXT	PoolContext;
	CReadIOData		*pReadData;


	//
	// initialize
	//
	hr = DPN_OK;

	PoolContext.SPType = m_pSPData->GetType();
	pReadData = m_pThreadPool->GetNewReadIOData( &PoolContext );
	if ( pReadData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Out of memory attempting Winsock2 read!" );
		goto Exit;
	}

	//
	// pReadData has one reference so far, the one for this function.
	//


	//
	// note the IO reference before attempting the read
	//
	AddRef();

	DNASSERT( pReadData->m_pSourceSocketAddress != NULL );
	DNASSERT( pReadData->SocketPort() == NULL );

	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc ) == sizeof( WSABUF ) );
	DBG_CASSERT( OFFSETOF( BUFFERDESC, dwBufferSize ) == OFFSETOF( WSABUF, len ) );
	DBG_CASSERT( OFFSETOF( BUFFERDESC, pBufferData ) == OFFSETOF( WSABUF, buf ) );

#ifdef WIN95
	DNASSERT(pReadData->OverlapEvent() != NULL );
#endif

	pReadData->m_dwReadFlags = 0;
	pReadData->m_iSocketAddressSize = pReadData->m_pSourceSocketAddress->GetAddressSize();
	pReadData->SetSocketPort( this );

	DPFX(DPFPREP, 8, "Submitting read 0x%p (socketport 0x%p, socket 0x%p).",
		pReadData, this, GetSocket());


	//
	// Add a reference for submitting the read to WinSock.  This should be
	// removed when the receive completes.
	//
	pReadData->AddRef();


	//
	// lock the 'pending operation' list over the call to Winsock to prevent the
	// operation from being completed while it's being set up.
	//
#ifdef WIN95
	m_pSPData->GetThreadPool()->LockReadData();
#endif

	//
	// Note that this operation is 'pending'.  It really isn't, but Windows
	// should let us know if we query for completion status and this operation
	// isn't complete.  Only assert state on Win9x because NT doesn't use the
	// 'pending' field.
	//
	DNASSERT( pReadData->m_dwOverlappedBytesReceived == 0 );
#ifdef WIN95
	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
	pReadData->SetWin9xOperationPending( TRUE );
#endif

Reread:

	if ( GetSocket() == INVALID_SOCKET )
	{
		DPFX(DPFPREP, 1, "Attempting to submit read 0x%p on socketport (0x%p) that does not have a valid handle.",
			pReadData, this);
	}
	
	iWSAReturn = p_WSARecvFrom( GetSocket(),							// socket
								reinterpret_cast<WSABUF*>( &pReadData->ReceivedBuffer()->BufferDesc ),	// pointer to receive buffers
								1,										// number of receive buffers
								&pReadData->m_dwBytesRead,				// pointer to bytes received (if command completes immediately)
								&pReadData->m_dwReadFlags,				// flags (none)
								pReadData->m_pSourceSocketAddress->GetWritableAddress(),	// address of sending socket
								&pReadData->m_iSocketAddressSize,		// size of address of sending socket
								pReadData->Overlap(),					// pointer to overlapped structure
								NULL									// APC callback (unused)
								);	
	if ( iWSAReturn == 0 )
	{
		DPFX(DPFPREP, 8, "WSARecvFrom for read data 0x%p completed immediately.",
			pReadData );

#ifdef WIN95
		//
		// Function completed immediately, drop the lock and signal the
		// read event to ensure that the I/O threads pick up this completed
		// read.
		// Ignore SetEvent failure, there's nothing we can do (and it should
		// never happen anyway).
		//
		
		m_pSPData->GetThreadPool()->UnlockReadData();

		SetEvent(m_pSPData->GetThreadPool()->GetWinsock2ReceiveCompleteEvent());
#else // WINNT
		//
		// function completed immediately, do nothing, wait for IOCompletion
		// notification to be processed
		//
#endif // WINNT
	}
	else
	{
		DWORD	dwWSAReceiveError;


		//
		// failure, check for pending operation
		//
		dwWSAReceiveError = p_WSAGetLastError();
		switch ( dwWSAReceiveError )
		{
			//
			// the send is pending, nothing to do
			//
			case WSA_IO_PENDING:
			{
#ifdef WIN95
				m_pSPData->GetThreadPool()->UnlockReadData();
#endif

				break;
			}

			//
			// Since this is a UDP socket, this is an indication
			// that a previous send failed.  Ignore it and move
			// on.
			//
			case WSAECONNRESET:
			{
				DPFX(DPFPREP, 8, "WSARecvFrom issued a WSACONNRESET." );
				goto Reread;
				break;
			}

			case WSAENOTSOCK:
			{
				DPFX(DPFPREP, 8, "Got WSAENOTSOCK on RecvFrom." );

#ifdef WIN95
				m_pSPData->GetThreadPool()->UnlockReadData();
#endif

				hr = DPNERR_GENERIC;

				DNASSERT( pReadData != NULL );

#ifdef WIN95
				DNASSERT( pReadData->Win9xOperationPending() != FALSE );
				pReadData->SetWin9xOperationPending( FALSE );
#endif

				//
				// Remove the WinSock reference.
				//
				pReadData->DecRef();

				//
				// the following DecRef may result in this object being returned to the
				// pool, make sure we don't access member variables after this point!
				//
				DecRef();

				goto Exit;
			}

			//
			// there was a problem, no completion notification will
			// be given, decrement our IO reference count
			//
			default:
			{
#ifdef WIN95
				m_pSPData->GetThreadPool()->UnlockReadData();
#endif
				hr = DPNERR_GENERIC;
				
				//
				// 'Known Errors' that we don't want to ASSERT on.
				//
				// WSAEINTR: the socket has been shut down and is about to be/has been closed
				// WSAESHUTDOWN: the socket has been shut down and is about to be/has been closed
				// WSAENOBUFS: out of memory (stress condition)
				//
				switch ( dwWSAReceiveError )
				{
					case WSAEINTR:
					{
						DPFX(DPFPREP, 1, "Got WSAEINTR while trying to RecvFrom." );
						break;
					}

					case WSAESHUTDOWN:
					{
						DPFX(DPFPREP, 1, "Got WSAESHUTDOWN while trying to RecvFrom." );
						break;
					}

					case WSAENOBUFS:
					{
						DPFX(DPFPREP, 1, "Got WSAENOBUFS while trying to RecvFrom." );
						break;
					}

					default:
					{
						DPFX(DPFPREP, 0, "Unknown WinSock error when issuing read!" );
						DisplayWinsockError( 0, dwWSAReceiveError );
						DNASSERT( FALSE );
					}
				}

				DNASSERT( pReadData != NULL );

#ifdef WIN95
				DNASSERT( pReadData->Win9xOperationPending() != FALSE );
				pReadData->SetWin9xOperationPending( FALSE );
#endif

				//
				// Remove the WinSock reference.
				//
				pReadData->DecRef();

				//
				// the following DecRef may result in this object being returned to the
				// pool, make sure we don't access member variables after this point!
				//
				DecRef();

				goto Exit;
			}
		}
	}

Exit:
	
	if ( pReadData != NULL )
	{
		pReadData->DecRef();
	}
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SendComplete - a Wisock send is complete, clean up and
//			notify user
//
// Entry:		Pointer to write data
//				Error code for this operation
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendComplete"

void	CSocketPort::SendComplete( CWriteIOData *const pWriteData, const HRESULT hResult )
{
	HRESULT		hr;

	
	DNASSERT( pWriteData != NULL );
#ifdef WIN95
	DNASSERT( pWriteData->Win9xOperationPending() == FALSE );
#endif


	//
	// only signal user if requested
	//
	switch ( pWriteData->m_SendCompleteAction )
	{
		//
		// send command completion to user (most common case)
		//
		case SEND_COMPLETE_ACTION_COMPLETE_COMMAND:
		{
			DPFX(DPFPREP, 8, "Socket port 0x%p completing send command 0x%p, hr = 0x%lx, context = 0x%p to interface 0x%p.",
				this, pWriteData->m_pCommand, hResult,
				pWriteData->m_pCommand->GetUserContext(),
				m_pSPData->DP8SPCallbackInterface());
			
			hr = IDP8SPCallback_CommandComplete( m_pSPData->DP8SPCallbackInterface(),		// pointer to DirectNet
													pWriteData->m_pCommand,						// command handle
													hResult,									// error code
													pWriteData->m_pCommand->GetUserContext()	// user cookie
													);
			
			DPFX(DPFPREP, 8, "Socketport 0x%p returning from command complete [0x%lx].", this, hr);
		
			break;
		}

		//
		// no action
		//
		case SEND_COMPLETE_ACTION_NONE:
		{
			if (pWriteData->m_pCommand != NULL)
			{
				DPFX(DPFPREP, 8, "Socket port 0x%p not completing send command 0x%p, hr = 0x%lx, context = 0x%p.",
					this, pWriteData->m_pCommand, hResult, pWriteData->m_pCommand->GetUserContext() );
			}
			else
			{
				DPFX(DPFPREP, 8, "Socket port 0x%p not completing NULL send command, hr = 0x%lx",
					this, hResult );
			}
			break;
		}

		//
		// Clean up after proxied enum.  The proxied enum will remove the
		// reference on the leave the receive buffer that came in on the enum.
		// The destination address that was supplied needs to be released
		// because it was allocated specifically for this task.
		//
		case SEND_COMPLETE_ACTION_PROXIED_ENUM_CLEANUP:
		{
			DPFX(DPFPREP, 8, "Socket port 0x%p completing proxied enum command 0x%p, hr = 0x%lx, context = 0x%p.",
				this, pWriteData->m_pCommand, hResult, pWriteData->m_pCommand->GetUserContext() );
			
			DNASSERT( pWriteData->m_pProxiedEnumReceiveBuffer != NULL );
			DNASSERT( pWriteData->m_pDestinationSocketAddress != NULL );

			pWriteData->m_pProxiedEnumReceiveBuffer->DecRef();
			pWriteData->m_pProxiedEnumReceiveBuffer = NULL;

			//
			// We know that this address was allocated specifically for this
			// proxied enum and we need to free it.
			//
			m_pSPData->ReturnAddress( const_cast<CSocketAddress*>( pWriteData->m_pDestinationSocketAddress ) );
			pWriteData->m_pDestinationSocketAddress = NULL;

			break;
		}

		//
		// unknown case
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	m_pThreadPool->ReturnWriteIOData( pWriteData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::SetWinsockBufferSize -  set the buffer size used by Winsock for
//			this socket.
//
// Entry:		Buffer size
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SetWinsockBufferSize"

void	CSocketPort::SetWinsockBufferSize( const INT iBufferSize ) const
{
	INT	iReturnValue;


	DPFX(DPFPREP, 3, "(0x%p) Setting socket 0x%p receive buffer size to: %d",
		this, GetSocket(), g_iWinsockReceiveBufferSize );

	iReturnValue = p_setsockopt( GetSocket(),
								 SOL_SOCKET,
								 SO_RCVBUF,
								 reinterpret_cast<char*>( &g_iWinsockReceiveBufferSize ),
								 sizeof( g_iWinsockReceiveBufferSize )
								 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = p_WSAGetLastError();
		DPFX(DPFPREP, 0, "Failed to set the socket buffer receive size!" );
		DisplayWinsockError( 0, dwErrorCode );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::IncreaseOutstandingReceives - increase the number of outstanding
//		receives on this socket port.
//
// Entry:		Number of receives to add
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::IncreaseOutstandingReceives"

void	CSocketPort::IncreaseOutstandingReceives( const DWORD dwDelta )
{
	if ( m_pSendFunction == CSocketPort::Winsock2Send )
	{
		DWORD	dwIdx;


		dwIdx = dwDelta;
		while ( dwIdx != 0 )
		{
			dwIdx--;
			Winsock2Receive();
		}
	}
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CSocketPort::BindToNetwork - bind this socket port to the network
//
// Entry:		Handle of I/O completion port (NT only)
//				Type of socket
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindToNetwork"

HRESULT	CSocketPort::BindToNetwork( const HANDLE hIOCompletionPort, const GATEWAY_BIND_TYPE GatewayBindType )
{
	HRESULT				hr;
	INT					iReturnValue;
	BOOL				fTemp;
	BOOL				fBoundToNetwork;
	INT					iSendBufferSize;
	CSocketAddress *	pBoundSocketAddress;
	WORD				wBasePort;
	DWORD				dwErrorCode;
	DWORD *				pdwAddressChunk;
	DWORD *				pdwLastAddressChunk;
	DWORD				dwTemp;


	//
	// initialize
	//
	hr = DPN_OK;
	fBoundToNetwork = FALSE;
	pBoundSocketAddress = NULL;

	wBasePort = g_wBaseDPlayPort;


RebindToNextPort:

	DNASSERT( m_fInitialized != FALSE );
	DNASSERT( m_State == SOCKET_PORT_STATE_INITIALIZED );

	//
	// get a socket for this socket port
	//
	DNASSERT( GetSocket() == INVALID_SOCKET );

#ifdef WIN95
	if (GetWinsockVersion() >= 2)
	{
#endif
		m_Socket = p_WSASocket( m_pNetworkSocketAddress->GetFamily(),	// address family
							  SOCK_DGRAM,								// datagram (connectionless) socket
							  m_pNetworkSocketAddress->GetProtocol(),	// protocol
							  NULL,										// protocol info structure
							  NULL,										// group
							  WSA_FLAG_OVERLAPPED );					// flags
#ifdef WIN95
	}
	else
	{
		m_Socket = p_socket( m_pNetworkSocketAddress->GetFamily(),		// address family
							  SOCK_DGRAM,								// datagram (connectionless) socket
							  m_pNetworkSocketAddress->GetProtocol() );	// protocol
	}
#endif	
	if ( GetSocket() == INVALID_SOCKET )
	{
		hr = DPNERR_NOCONNECTION;
		DPFX(DPFPREP, 0, "Failed to bind to socket!" );
		goto Failure;
	}

	//
	// set socket to allow broadcasts
	//
	fTemp = TRUE;
	DBG_CASSERT( sizeof( &fTemp ) == sizeof( char * ) );
	iReturnValue = p_setsockopt( GetSocket(),		// socket
	    						 SOL_SOCKET,		// level (set socket options)
	    						 SO_BROADCAST,		// set broadcast option
	    						 reinterpret_cast<char *>( &fTemp ),	// allow broadcast
	    						 sizeof( fTemp )	// size of parameter
	    						 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		dwErrorCode = p_WSAGetLastError();
	    DPFX(DPFPREP, 0, "Unable to set broadcast socket option (err = %u)!",
	    	dwErrorCode );
	    DisplayWinsockError( 0, dwErrorCode );
	    hr = DPNERR_GENERIC;
	    goto Failure;
	}

	//
	// set socket receive buffer space if the user overrode it
	// Failing this is a preformance hit so ignore and errors.
	//
	if ( g_fWinsockReceiveBufferSizeOverridden != FALSE )
	{
		SetWinsockBufferSize( g_iWinsockReceiveBufferSize) ;
	}
	
	//
	// set socket send buffer space to 0 (we will supply all buffers).
	// Failing this is only a performance hit so ignore any errors.
	//
	iSendBufferSize = 0;
	iReturnValue = p_setsockopt( GetSocket(),
								 SOL_SOCKET,
								 SO_SNDBUF,
								 reinterpret_cast<char*>( &iSendBufferSize ),
								 sizeof( iSendBufferSize )
								 );
	if ( iReturnValue == SOCKET_ERROR )
	{
		dwErrorCode = p_WSAGetLastError();
		DPFX(DPFPREP, 0, "Failed to set the socket buffer send size (err = %u)!", dwErrorCode );
		DisplayWinsockError( 0, dwErrorCode );
	}


#ifdef WIN95
	//
	// put socket into non-blocking mode, if WinSock 1 or 9x IPX
	//
	if ( ( LOWORD( GetWinsockVersion() ) == 1 ) || ( m_pSPData->GetType() == TYPE_IPX ) ) 
	{
		DPFX(DPFPREP, 5, "Marking socket as non-blocking." );
		
		dwTemp = 1;
		iReturnValue = p_ioctlsocket( GetSocket(),	// socket
		    						  FIONBIO,		// I/O option to set (blocking mode)
		    						  &dwTemp		// I/O option value (non-zero puts socked into non-block mode)
		    						  );
		if ( iReturnValue == SOCKET_ERROR )
		{
			dwErrorCode = p_WSAGetLastError();
			DPFX(DPFPREP, 0, "Could not set socket into non-blocking mode (err = %u)!",
				dwErrorCode );
			DisplayWinsockError( 0, dwErrorCode );
			hr = DPNERR_GENERIC;
			goto Failure;
		}
	}
#else // ! WIN95
	//
	// Attempt to make buffer circular.
	//

	iReturnValue = p_WSAIoctl(GetSocket(),					// socket
							SIO_ENABLE_CIRCULAR_QUEUEING,	// io control code
							NULL,							// in buffer
							0,								// in buffer size
							NULL,							// out buffer
							0,								// out buffer size
							&dwTemp,						// pointer to bytes returned
							NULL,							// overlapped
							NULL							// completion routine
							);
	if ( iReturnValue == SOCKET_ERROR )
	{
		dwErrorCode = p_WSAGetLastError();
		DPFX(DPFPREP, 1, "Could not enable circular queuing (err = %u), ignoring.",
		    dwErrorCode );
		DisplayWinsockError( 1, dwErrorCode );
	}


	//
	// Make broadcasts only go out on the interface on which they were sent
	// (as opposed to all interfaces).
	//

	fTemp = TRUE;
	iReturnValue = p_WSAIoctl(GetSocket(),			// socket
							SIO_LIMIT_BROADCASTS,	// io control code
							&fTemp,					// in buffer
							sizeof(fTemp),			// in buffer size
							NULL,					// out buffer
							0,						// out buffer size
							&dwTemp,				// pointer to bytes returned
							NULL,					// overlapped
							NULL					// completion routine
							);
	if ( iReturnValue == SOCKET_ERROR )
	{
		dwErrorCode = p_WSAGetLastError();
		DPFX(DPFPREP, 1, "Could not limit broadcasts (err = %u), ignoring.",
		    dwErrorCode );
		DisplayWinsockError( 1, dwErrorCode );
	}
#endif // ! WIN95


	//
	// bind socket
	//
	DPFX(DPFPREP, 1, "Binding to socket addess:" );
	DumpSocketAddress( 1, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
	
	DNASSERT( GetSocket() != INVALID_SOCKET );
	
	hr = BindToNextAvailablePort( m_pNetworkSocketAddress, wBasePort );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to bind to network!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	fBoundToNetwork = TRUE;

	//
	// Find out what address we really bound to.  This information is needed to
	// talk to the Internet gateway and will be needed when someone above queries for
	// what the local network address is.
	//
	pBoundSocketAddress = GetBoundNetworkAddress( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
	if ( pBoundSocketAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to get bound adapter address!" );
		goto Failure;
	}
	DPFX(DPFPREP, 1, "Socket we really bound to:" );
	DumpSocketAddress( 1, pBoundSocketAddress->GetAddress(), pBoundSocketAddress->GetFamily() );


	//
	// Perform the same error handling twice for two different functions.
	//	0 = check for an existing mapping
	//	1 = attempt to create a new mapping
	//
	for(dwTemp = 0; dwTemp < 2; dwTemp++)
	{
		if (dwTemp == 0)
		{
			//
			// Make sure we're not slipping under an existing Internet gateway mapping.
			// We have to do this because the current Windows NAT implementations do
			// not mark the port as "in use", so if you bound to a port on the public
			// adapter that had a mapping, you'd never receive any data.  It would all
			// be forwarded according to the mapping.
			//
			hr = this->CheckForOverridingMapping( pBoundSocketAddress );
		}
		else
		{
			//
			// Attempt to bind to an Internet gateway.
			//
			hr = this->BindToInternetGateway( pBoundSocketAddress, GatewayBindType );
		}
		
		switch (hr)
		{
			case DPN_OK:
			{
				//
				// 0 = there's no existing mapping that would override our socket
				// 1 = mapping on Internet gateway (if any) was successful
				//
				break;
			}
			
			case DPNERR_ALREADYINITIALIZED:
			{
				//
				// 0 = there's an existing mapping that would override our socket
				// 1 = Internet gateway already had a conflicting mapping
				//
				// If we can, try binding to a different port.  Otherwise we have to fail.
				//
				if (GatewayBindType == GATEWAY_BIND_TYPE_DEFAULT)
				{
					DPFX(DPFPREP, 1, "%s address already in use on Internet gateway (port = %u), rebinding.",
						((dwTemp == 0) ? "Private" : "Public"),
						p_ntohs(pBoundSocketAddress->GetPort()));


					//
					// Whether we succeed in unbinding or not, don't consider this bound anymore.
					//
					fBoundToNetwork = FALSE;
					
					hr = UnbindFromNetwork();
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't unbind network socket address 0x%p from network before rebind attempt!",
							this );
						goto Failure;
					}


					//
					// Move to the next port and try again.
					//
					wBasePort = p_ntohs(pBoundSocketAddress->GetPort()) + 1;
					
					//
					// If we weren't in the DPlay range, then we must have gone through all
					// of the DPlay range, plus let WinSock pick at least once.  Since we can't
					// trust WinSock to not keep picking the same port, we need to manually
					// increase the port number.
					//
					if ((p_ntohs(pBoundSocketAddress->GetPort()) < g_wBaseDPlayPort) || (p_ntohs(pBoundSocketAddress->GetPort()) > g_wMaxDPlayPort))
					{
						//
						// If we just walked back into the DPlay range, skip over it.
						//
						if ((wBasePort >= g_wBaseDPlayPort) && (wBasePort <= g_wMaxDPlayPort))
						{
							wBasePort = g_wMaxDPlayPort + 1;
						}

						//
						// If we have wrapped all the way back to 0 (!) then fail, to prevent
						// infinite looping.
						//
						if (wBasePort == 0)
						{
							DPFX(DPFPREP, 0, "Managed to fail binding socket address 0x%p to every port, aborting!",
								this );
							hr = DPNERR_ALREADYINITIALIZED;
							goto Failure;
						}
						
						//
						// Force the "fixed port" code path in BindToNextAvailablePort, even
						// though it isn't really fixed.
						//
	 					DPFX(DPFPREP, 5, "Forcing port %u.", wBasePort );
						m_pNetworkSocketAddress->SetPort(p_htons(wBasePort));
					}

					
					//
					// Return the previous address and try again.
					//
					m_pSPData->ReturnAddress( pBoundSocketAddress );
					pBoundSocketAddress = NULL;

					
					goto RebindToNextPort;
				}

				DPFX(DPFPREP, 0, "%s address already in use on Internet gateway (port = %u)!",
					((dwTemp == 0) ? "Private" : "Public"),
					p_ntohs(pBoundSocketAddress->GetPort()));
				goto Failure;
				break;
			}
			
			case DPNERR_UNSUPPORTED:
			{
				//
				// 0 & 1 = NATHelp not loaded or isn't supported for SP
				//
				if (dwTemp == 0)
				{
					DPFX(DPFPREP, 2, "Not able to find existing private mapping for socketport 0x%p on local Internet gateway, unsupported/not necessary.",
						this);
				}
				else
				{
					DPFX(DPFPREP, 2, "Didn't bind socketport 0x%p to Internet gateway, unsupported/not necessary.",
						this);
				}
				
				//
				// Ignore the error.
				//
				break;
			}
			
			default:
			{
				//
				// 0 & 1 = ?
				//
				if (dwTemp == 0)
				{
					DPFX(DPFPREP, 1, "Unable to look for existing private mapping for socketport 0x%p on local Internet gateway (error = 0x%lx), ignoring.",
						this, hr);
				}
				else
				{
					DPFX(DPFPREP, 1, "Unable to bind socketport 0x%p to Internet gateway (error = 0x%lx), ignoring.",
						this, hr);
				}
				
				//
				// Ignore the error, we can survive without the mapping.
				//
				break;
			}
		}

		//
		// Go to the next function to be handled in this manner.
		//
	}


	//
	// Save the address we actually ended up with.
	//
	m_pSPData->ReturnAddress( m_pNetworkSocketAddress );
	m_pNetworkSocketAddress = pBoundSocketAddress;
	pBoundSocketAddress = NULL;


	//
	// Generate a unique socketport ID.  Start with the current time and
	// combine in the address.
	//
	m_dwSocketPortID = GETTIMESTAMP();
	pdwAddressChunk = (DWORD*) m_pNetworkSocketAddress->GetAddress();
	pdwLastAddressChunk = (DWORD*) (((BYTE*) pdwAddressChunk) + m_pNetworkSocketAddress->GetAddressSize() - sizeof(DWORD));
	while (pdwAddressChunk <= pdwLastAddressChunk)
	{
		m_dwSocketPortID ^= (*pdwAddressChunk);
		pdwAddressChunk++;
	}



	if (m_pSPData->GetType() == TYPE_IP)
	{
		//
		// Detect whether this socket has WinSock Proxy Client a.k.a. ISA Firewall
		// Client installed (unless the user turned auto-detection off in the
		// registry).  We do this by looking at the name of the protocol that got
		// bound to the socket.  If it contains "Proxy", consider it proxied.
		//
		// Ignore failure (WinSock 1 probably doesn't have this socket option), and
		// assume the proxy client isn't installed.
		//
		if (! g_fDontAutoDetectProxyLSP)
		{

#if 1

			int					aiProtocols[2];
			WSAPROTOCOL_INFO *	pwsapi;
			DWORD				dwBufferSize;
			int					i;
#ifdef DEBUG
#ifdef WINNT
			WCHAR				wszProtocol[WSAPROTOCOL_LEN+1];
#else // WIN95
			char				szProtocol[WSAPROTOCOL_LEN+1];
#endif // WIN95
#endif // DEBUG


#ifdef WIN95
			if (GetWinsockVersion() == 2)
#endif // WIN95
			{
				aiProtocols[0] = IPPROTO_UDP;
				aiProtocols[1] = 0;

				dwBufferSize = 0;

				//
				// Ignore error, assume the buffer is too small.
				//
#ifdef WINNT
				p_WSAEnumProtocolsW(aiProtocols, NULL, &dwBufferSize);
#else // WIN95
				p_WSAEnumProtocolsA(aiProtocols, NULL, &dwBufferSize);
#endif // WIN95
				

				pwsapi = (WSAPROTOCOL_INFO*) DNMalloc(dwBufferSize);
				if (pwsapi == NULL)
				{
					hr = DPNERR_OUTOFMEMORY;
					goto Failure;
				}


#ifdef WINNT
				iReturnValue = p_WSAEnumProtocolsW(aiProtocols, pwsapi, &dwBufferSize);
#else // WIN95
				iReturnValue = p_WSAEnumProtocolsA(aiProtocols, pwsapi, &dwBufferSize);
#endif // WIN95
				if (iReturnValue == SOCKET_ERROR)
				{
					dwErrorCode = p_WSAGetLastError();
					DPFX(DPFPREP, 1, "Couldn't enumerate UDP protocols for socketport 0x%p ID 0x%x (err = %u)!  Assuming not using proxy client.",
						this, m_dwSocketPortID, dwErrorCode);
					DisplayWinsockError( 0, dwErrorCode );
				}
				else
				{
					//
					// Loop through all the UDP protocols installed.
					//
					for(i = 0; i < iReturnValue; i++)
					{
						//
						// See if the name contains "Proxy", case insensitive.
						// Save the original string in debug so we can print it.
						//
#ifdef WINNT
#ifdef DEBUG
						wcscpy(wszProtocol, pwsapi[i].szProtocol);
#endif // DEBUG
						_wcslwr(pwsapi[i].szProtocol);
						if (wcsstr(pwsapi[i].szProtocol, L"proxy") != NULL)
						{
							DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) appears to be using proxy client (protocol %i = \"%S\").",
								this, m_dwSocketPortID, i, wszProtocol);
							this->m_fUsingProxyWinSockLSP = TRUE;

							//
							// Stop searching.
							//
							break;
						}

						
						DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) protocol %i (\"%S\") does not contain \"proxy\".",
							this, m_dwSocketPortID, i, wszProtocol);
#else // WIN95
#ifdef DEBUG
						strcpy(szProtocol, pwsapi[i].szProtocol);
#endif // DEBUG
						_strlwr(pwsapi[i].szProtocol);
						if (strstr(pwsapi[i].szProtocol, "proxy") != NULL)
						{
							DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) appears to be using proxy client (protocol %i = \"%s\").",
								this, m_dwSocketPortID, i, szProtocol);
							this->m_fUsingProxyWinSockLSP = TRUE;

							//
							// Stop searching.
							//
							break;
						}

						
						DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) protocol %i (\"%s\") does not contain \"proxy\".",
							this, m_dwSocketPortID, i, szProtocol);
#endif // WIN95
					} // end for (each returned protocol)
				}

				DNFree(pwsapi);
			}
#ifdef WIN95
			else
			{
				//
				// WinSock 1 doesn't have this entry point.
				//
				DPFX(DPFPREP, 1, "Unable to auto-detect proxy client on WinSock 1, assuming not present.");
			}
#endif // WIN95




#else // 0



			WSAPROTOCOL_INFO	wsapi;
			int					iBufferSize;
#ifdef DEBUG
			TCHAR				tszProtocol[WSAPROTOCOL_LEN+1];
#endif // DEBUG


			memset(&wsapi, 0, sizeof(wsapi));
			iBufferSize = sizeof(wsapi);

			iReturnValue = p_getsockopt( GetSocket(),
										SOL_SOCKET,
										SO_PROTOCOL_INFO,
										(char*) &wsapi,
										&iBufferSize );
			if (iReturnValue == SOCKET_ERROR)
			{
				dwErrorCode = p_WSAGetLastError();
				DPFX(DPFPREP, 1, "Couldn't get bound protocol info for socketport 0x%p ID 0x%x (err = %u)!  Assuming not using proxy client.",
					this, m_dwSocketPortID, dwErrorCode);
				DisplayWinsockError( 0, dwErrorCode );
			}
			else
			{
				//
				// See if the name contains "Proxy", case insensitive.
				// Save the original string in debug so we can print it.
				//
#ifdef DEBUG
				_tcscpy(tszProtocol, wsapi.szProtocol);
#endif // DEBUG
				_tcslwr(wsapi.szProtocol);
				if (_tcsstr(wsapi.szProtocol, _T("proxy")) != NULL)
				{
#ifdef UNICODE
					DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) appears to be using proxy client (bound protocol = \"%S\").",
#else // ! UNICODE
					DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) appears to be using proxy client (bound protocol = \"%s\").",
#endif // ! UNICODE
						this, m_dwSocketPortID, tszProtocol);
					this->m_fUsingProxyWinSockLSP = TRUE;
				}
				else
				{
#ifdef UNICODE
					DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) does not appear to be using proxy client (bound protocol = \"%S\").",
#else // ! UNICODE
					DPFX(DPFPREP, 5, "Socketport 0x%p (ID 0x%x) does not appear to be using proxy client (bound protocol = \"%s\").",
#endif // ! UNICODE
						this, m_dwSocketPortID, tszProtocol);
				}
			}


#endif // 0
		}
		else
		{
			DPFX(DPFPREP, 5, "Not auto-detecting whether socketport 0x%p (ID 0x%x) is using proxy client.",
				this, m_dwSocketPortID);
		}
	}
	else
	{
		//
		// IPX, don't worry about proxies.
		//
	}


	
	//
	// start processing input messages
	// It's possible that messages will arrive before an endpoint is officially
	// bound to this socket port, but that's not a problem, the contents will
	// be lost
	//
	hr = StartReceiving( hIOCompletionPort );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem starting endpoint receiving!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem in CSocketPort::BindToNetwork()" );
		DisplayDNError( 0, hr );
	}

	if ( pBoundSocketAddress != NULL )
	{
		m_pSPData->ReturnAddress( pBoundSocketAddress );
		pBoundSocketAddress = NULL;
	}

	return hr;

Failure:
	DEBUG_ONLY( m_fInitialized = FALSE );
	if ( fBoundToNetwork != FALSE )
	{
		UnbindFromNetwork();
	}
	else
	{
		//
		// If we were bound to network, m_Socket will be reset to
		// INVALID_SOCKET.
		// Otherwise, we will take care of this ourselves (!)
		//
		iReturnValue = p_closesocket( m_Socket );
		if ( iReturnValue == SOCKET_ERROR )
		{
			dwErrorCode = p_WSAGetLastError();
			DPFX(DPFPREP, 0, "Problem closing socket!" );
			DisplayWinsockError( 0, dwErrorCode );
		}
		m_Socket = INVALID_SOCKET;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::UnbindFromNetwork - unbind this socket port from the network
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	It is assumed that this socket port's information is locked!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::UnbindFromNetwork"

HRESULT	CSocketPort::UnbindFromNetwork( void )
{
	INT			iWSAReturn;
	SOCKET		TempSocket;
	DWORD		dwTemp;
	DWORD		dwErrorCode;


	DPFX(DPFPREP, 7, "(0x%p) Enter", this );


	TempSocket = GetSocket();
	m_Socket = INVALID_SOCKET;
	DNASSERT( TempSocket != INVALID_SOCKET );

	iWSAReturn = p_shutdown( TempSocket, SD_BOTH );
	if ( iWSAReturn == SOCKET_ERROR )
	{
		dwErrorCode = p_WSAGetLastError();
		DPFX(DPFPREP, 0, "Problem shutting down socket!" );
		DisplayWinsockError( 0, dwErrorCode );
	}

	DPFX(DPFPREP, 5, "Closing socketport 0x%p socket 0x%p.", this, TempSocket);

	iWSAReturn = p_closesocket( TempSocket );
	if ( iWSAReturn == SOCKET_ERROR )
	{
		dwErrorCode = p_WSAGetLastError();
		DPFX(DPFPREP, 0, "Problem closing socket!" );
		DisplayWinsockError( 0, dwErrorCode );
	}

	//
	// Unbind with all DirectPlayNATHelp instances.
	//
	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		if ( m_ahNATHelpPorts[dwTemp] != NULL )
		{
			DNASSERT( m_pThreadPool != NULL );
			DNASSERT( m_pThreadPool->IsNATHelpLoaded() );

			//
			// Ignore error.
			//
			IDirectPlayNATHelp_DeregisterPorts( g_papNATHelpObjects[dwTemp], m_ahNATHelpPorts[dwTemp], 0 );
			m_ahNATHelpPorts[dwTemp] = NULL;
		}
	}

	DPFX(DPFPREP, 7, "(0x%p) Returning [DPN_OK]", this );
	
	return	DPN_OK;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::BindToNextAvailablePort - bind to next available port
//
// Entry:		Pointer adapter address to bind to
//				Base port to try assigning.
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindToNextAvailablePort"

HRESULT	CSocketPort::BindToNextAvailablePort( const CSocketAddress *const pNetworkAddress,
												const WORD wBasePort) const
{
	HRESULT				hr;
	INT					iSocketReturn;
	CSocketAddress *	pDuplicateNetworkAddress;

	
	DNASSERT( pNetworkAddress != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pDuplicateNetworkAddress = NULL;

	//
	// If a port was specified, try to bind to that port.  If no port was
	// specified, start walking the reserved DPlay port range looking for an
	// available port.  If none is found, let Winsock choose the port.
	//
	if ( pNetworkAddress->GetPort() != ANY_PORT )
	{
		iSocketReturn = p_bind( GetSocket(),
								pNetworkAddress->GetAddress(),
								pNetworkAddress->GetAddressSize()
								);
		if ( iSocketReturn == SOCKET_ERROR )
		{
			DWORD	dwErrorCode;


			hr = DPNERR_ALREADYINITIALIZED;
			dwErrorCode = p_WSAGetLastError();
			DPFX(DPFPREP, 0, "Failed to bind socket to fixed port!" );
			DumpSocketAddress(0, pNetworkAddress->GetAddress(), pNetworkAddress->GetFamily() );
			DisplayWinsockError( 0, dwErrorCode );
			goto Failure;
		}
	}
	else
	{
		WORD	wPort;
		BOOL	fBound;


		fBound = FALSE;
		DNASSERT( pDuplicateNetworkAddress == NULL );
		pDuplicateNetworkAddress = m_pSPData->GetNewAddress();
		if ( pDuplicateNetworkAddress == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP, 0, "Failed to get address for walking DPlay port range!" );
			goto Failure;
		}
	
		pDuplicateNetworkAddress->CopyAddressSettings( pNetworkAddress );

		wPort = wBasePort;

		//
		// Try picking the next port in the DPlay range.
		//
		while ( ( wPort >= g_wBaseDPlayPort ) && ( wPort <= g_wMaxDPlayPort ) && ( fBound == FALSE ) )
		{
			pDuplicateNetworkAddress->SetPort( p_htons( wPort ) );
			iSocketReturn = p_bind( GetSocket(),
									pDuplicateNetworkAddress->GetAddress(),
									pDuplicateNetworkAddress->GetAddressSize()
									);
			if ( iSocketReturn == SOCKET_ERROR )
			{
				DWORD	dwErrorCode;


				dwErrorCode = p_WSAGetLastError();
				switch ( dwErrorCode )
				{
					case WSAEADDRINUSE:
					{
						DPFX(DPFPREP, 8, "Port %u in use, skipping to next port.", wPort );
						break;
					}

					default:
					{
						hr = DPNERR_NOCONNECTION;
						DPFX(DPFPREP, 0, "Failed to bind socket to port in DPlay range!" );
						DumpSocketAddress(0, pDuplicateNetworkAddress->GetAddress(), pDuplicateNetworkAddress->GetFamily() );
						DisplayWinsockError( 0, dwErrorCode );
						goto Failure;
						
						break;
					}
				}
			}
			else
			{
				DNASSERT( hr == DPN_OK );
				fBound = TRUE;
			}

			wPort++;
		}
	
		//
		// For some reason, all of the default DPlay ports were in use, let
		// Winsock choose.  We can use the network address passed because it
		// has 'ANY_PORT'.
		//
		if ( fBound == FALSE )
		{
			DNASSERT( pNetworkAddress->GetPort() == ANY_PORT );
			iSocketReturn = p_bind( GetSocket(),
									pNetworkAddress->GetAddress(),
									pNetworkAddress->GetAddressSize()
									);
			if ( iSocketReturn == SOCKET_ERROR )
			{
				DWORD	dwErrorCode;


				hr = DPNERR_NOCONNECTION;
				dwErrorCode = p_WSAGetLastError();
				DPFX(DPFPREP, 0, "Failed to bind socket (any port)!" );
				DumpSocketAddress(0, pNetworkAddress->GetAddress(), pNetworkAddress->GetFamily() );
				DisplayWinsockError( 0, dwErrorCode );
				goto Failure;
			}
		}
	}

Exit:
	if ( pDuplicateNetworkAddress != NULL )
	{
		m_pSPData->ReturnAddress( pDuplicateNetworkAddress );
		pDuplicateNetworkAddress = NULL;
	}

	return	hr;

Failure:
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::CheckForOverridingMapping - looks for an existing mapping if there's a local NAT
//
// Entry:		Pointer to SocketAddress to query
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::CheckForOverridingMapping"

HRESULT	CSocketPort::CheckForOverridingMapping( const CSocketAddress *const pBoundSocketAddress )
{
	HRESULT		hr;
	DWORD		dwTemp;
	SOCKADDR	saddrSource;
	SOCKADDR	saddrPublic;


	DNASSERT( pBoundSocketAddress != NULL );
	DNASSERT( GetAdapterEntry() != NULL );
	DNASSERT( m_pThreadPool != NULL );

	
	if ((pBoundSocketAddress->GetFamily() != AF_INET) ||
		( ! m_pThreadPool->IsNATHelpLoaded() ))
	{
		//
		// We skipped initializing NAT Help, it failed starting up, or this is just
		// not an IP socket.
		//
		hr = DPNERR_UNSUPPORTED;
		goto Exit;
	}


	//
	// Query using INADDR_ANY.  This will ensure that the best device is picked
	// (i.e. the private interface on a NAT, whose public mappings matter when
	// we're looking for overriding mappings on the public adapter).
	// Alternatively, we could query on every device, but this should do the trick.
	//
	ZeroMemory(&saddrSource, sizeof(saddrSource));
	saddrSource.sa_family				= AF_INET;
	//saddrinSource.sin_addr.S_un.S_addr	= INADDR_ANY;
	//saddrinSource.sin_port				= 0;
	

	//
	// Register the ports with all DirectPlayNATHelp instances.  We might break
	// out of the loop if we detect a gateway mapping.
	//
	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		DNASSERT(m_ahNATHelpPorts[dwTemp] == NULL);

		if ( g_papNATHelpObjects[dwTemp] != NULL )
		{
			hr = IDirectPlayNATHelp_QueryAddress( g_papNATHelpObjects[dwTemp],
												&saddrSource,
												pBoundSocketAddress->GetAddress(),
												&saddrPublic,
												sizeof (saddrPublic),
												0 );
			switch ( hr )
			{
				case DPNH_OK:
				{
					//
					// Uh oh, this address is in use.
					//
					DPFX(DPFPREP, 0, "Private address already in use according to NAT Help object %u!", dwTemp );
					DumpSocketAddress( 0, pBoundSocketAddress->GetAddress(), pBoundSocketAddress->GetFamily() );
					DumpSocketAddress( 0, &saddrPublic, pBoundSocketAddress->GetFamily() );
					hr = DPNERR_ALREADYINITIALIZED;
					goto Exit;
					break;
				}
				
				case DPNHERR_NOMAPPING:
				{
					//
					// It's not in use.
					//
					DPFX(DPFPREP, 8, "Private address not in use according to NAT Help object %u.", dwTemp );
					break;
				}
				
				case DPNHERR_SERVERNOTAVAILABLE:
				{
					//
					// There's no server.
					//
					DPFX(DPFPREP, 8, "Private address not in use because NAT Help object %u didn't detect any servers.",
						dwTemp );
					break;
				}
				
				default:
				{
					//
					// Something else.  Assume it's not in use.
					//
					DPFX(DPFPREP, 1, "NAT Help object %u failed private address lookup (err = 0x%lx), assuming not in use.",
						dwTemp, hr );
					break;
				}
			}
		}
		else
		{
			//
			// No NAT Help object.
			//
		}
	}


	//
	// If we're here, no Internet gateways reported the port as in use.
	//
	DPFX(DPFPREP, 2, "No NAT Help object reported private address as in use." );
	hr = DPN_OK;


Exit:
	
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::BindToInternetGateway - binds a socket to a NAT, if available
//
// Entry:		Pointer to SocketAddress we bound to
//				Gateway bind type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::BindToInternetGateway"

HRESULT	CSocketPort::BindToInternetGateway( const CSocketAddress *const pBoundSocketAddress,
										   const GATEWAY_BIND_TYPE GatewayBindType )
{
	HRESULT		hr;
	DWORD		dwTemp;
	DWORD		dwRegisterFlags;
	DWORD		dwAddressTypeFlags;
	BOOL		fUnavailable;
#ifdef DEBUG
	BOOL		fFirewallMapping = FALSE;
#endif // DEBUG


	DNASSERT( pBoundSocketAddress != NULL );
	DNASSERT( GetAdapterEntry() != NULL );
	DNASSERT( m_pThreadPool != NULL );

	
	if ((pBoundSocketAddress->GetFamily() != AF_INET) ||
		( ! m_pThreadPool->IsNATHelpLoaded() ))
	{
		//
		// We skipped initializing NAT Help, it failed starting up, or this is just
		// not an IP socket.
		//
		hr = DPNERR_UNSUPPORTED;
		goto Exit;
	}
	
	switch ( GatewayBindType )
	{
		//
		// just ask the server to open a generic port for us (connect, listen, enum)
		//
		case GATEWAY_BIND_TYPE_DEFAULT:
		{
			dwRegisterFlags = 0;
			break;
		}

		//
		// ask the NAT to open a fixed port for us (address is specified)
		//
		case GATEWAY_BIND_TYPE_SPECIFIC:
		{
			dwRegisterFlags = DPNHREGISTERPORTS_FIXEDPORTS;
			break;
		}

		//
		// ask the NAT to share the listen for us (this should be DPNSVR only)
		//
		case GATEWAY_BIND_TYPE_SPECIFIC_SHARED:
		{
			dwRegisterFlags = DPNHREGISTERPORTS_FIXEDPORTS | DPNHREGISTERPORTS_SHAREDPORTS;
			break;
		}

		//
		// no binding
		//
		case GATEWAY_BIND_TYPE_NONE:
		{
			DPFX(DPFPREP, 8, "Not binding socket address 0x%p to NAT because bind type is NONE.",
				pBoundSocketAddress);

			DNASSERT( ! "Gateway bind type is NONE?" );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}

		//
		// unknown condition, someone broke the code!
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}


	//
	// Detect whether any servers said the port was unavailable.
	//
	fUnavailable = FALSE;


	//
	// Register the ports with all DirectPlayNATHelp instances.  We might break
	// out of the loop if we detect a gateway mapping.
	//
	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		DNASSERT(m_ahNATHelpPorts[dwTemp] == NULL);

		if ( g_papNATHelpObjects[dwTemp] != NULL )
		{
			hr = IDirectPlayNATHelp_RegisterPorts( g_papNATHelpObjects[dwTemp],
												pBoundSocketAddress->GetAddress(),
												sizeof (SOCKADDR),
												1,
												NAT_LEASE_TIME,
												&m_ahNATHelpPorts[dwTemp],
												dwRegisterFlags );
			if ( hr != DPNH_OK )
			{
				DNASSERT(m_ahNATHelpPorts[dwTemp] == NULL);
				DPFX(DPFPREP, 0, "Failed to register port with NAT Help object %u!  Ignoring.", dwTemp );
				DumpSocketAddress( 0, pBoundSocketAddress->GetAddress(), pBoundSocketAddress->GetFamily() );
				DisplayDNError( 0, hr );
				hr = DPN_OK;
			}
			else
			{
				//
				// There might be an Internet gateway device already present.  If so,
				// then DPNATHelp already tried to register the port mapping with it, which
	 			// might have failed because the port is already in use.  If we're not
	  			// binding to a fixed port, then we could just pick a different port and try
	  			// again.  So check if there's a UPnP device but DPNATHelp couldn't map
	  			// the port and return that error to the caller so he can make the
	  			// decision to retry or not.
	  			//
	  			// IDirectPlayNATHelp::GetCaps had better have been called with the
	  			// DPNHGETCAPS_UPDATESERVERSTATUS flag at least once prior to this.
	 			// See CThreadPool::PreventThreadPoolReduction
				//
				hr = IDirectPlayNATHelp_GetRegisteredAddresses( g_papNATHelpObjects[dwTemp],	// object
																m_ahNATHelpPorts[dwTemp],		// port binding
																NULL,							// don't need address
																NULL,							// don't need address buffer size
																&dwAddressTypeFlags,			// get address type flags
																NULL,							// don't need lease time remaining
																0 );							// no flags
				switch (hr)
				{
					case DPNH_OK:
					{
						//
						// If this is a mapping on a gateway, then we're done.
						// We don't need to try to make any more NAT mappings.
						//
						if (dwAddressTypeFlags & DPNHADDRESSTYPE_GATEWAY)
						{
							DPFX(DPFPREP, 4, "Address has already successfully been registered with gateway using object index %u (type flags = 0x%lx), not trying additional mappings.",
								dwTemp, dwAddressTypeFlags);
							goto Exit;
						}

						DNASSERT(dwAddressTypeFlags & DPNHADDRESSTYPE_LOCALFIREWALL);

						DPFX(DPFPREP, 4, "Address has already successfully been registered with firewall using object index %u (type flags = 0x%lx), looking for gateways.",
							dwTemp, dwAddressTypeFlags);
						
#ifdef DEBUG
						fFirewallMapping = TRUE;
#endif // DEBUG
					
						break;
					}

					case DPNHERR_NOMAPPING:
					{
						DPFX(DPFPREP, 4, "Address already registered with Internet gateway index %u, but it does not have a public address (type flags = 0x%lx).",
							dwTemp, dwAddressTypeFlags);


						//
						// It doesn't make any sense for a firewall not to have a
						// mapping.
						//
						DNASSERT(dwAddressTypeFlags & DPNHADDRESSTYPE_GATEWAY);
						DNASSERT(! (dwAddressTypeFlags & DPNHADDRESSTYPE_LOCALFIREWALL));


						//
						// Since it is a gateway (that might have a public address
						// at some point, we don't need to try to make any more
						// NAT mappings.
						//
						goto Exit;
						
						break;
					}

					case DPNHERR_PORTUNAVAILABLE:
					{
						DPFX(DPFPREP, 1, "Port is unavailable on Internet gateway device index %u (type flags = 0x%lx).",
							dwTemp, dwAddressTypeFlags);
						
						fUnavailable = TRUE;
						break;
					}

					case DPNHERR_SERVERNOTAVAILABLE:
					{
						DPFX(DPFPREP, 6, "No Internet gateway detected by object index %u at this time.", dwTemp);
						break;
					}

					default:
					{
						DPFX(DPFPREP, 1, "An error (0x%lx) occurred while getting registered address mapping (index %u)! Ignoring.",
							hr, dwTemp);
						break;
					}
				}
			}
		}
		else
		{
			//
			// No NAT Help object.
			//
		}
	}


	//
	// If we're here, no Internet gateways were detected, or if one was, the
	// mapping was already in use there.  If it's the latter, fail so our caller
	// can unbind locally and possibly try again.  Note that we are ignoring
	// firewall mappings, since it's assumed we can make those with pretty
	// much any port, so there's no point in hanging on to those mappings
	// if the NAT port is in use.
	//
	if (fUnavailable)
	{
		DPFX(DPFPREP, 2, "At least one Internet gateway reported port as unavailable, failing.");
		hr = DPNERR_ALREADYINITIALIZED;
	}
	else
	{
#ifdef DEBUG
		if (fFirewallMapping)
		{
			DPFX(DPFPREP, 2, "No gateway mappings but there is at least one firewall mapping.");
		}
		else
		{
			DPFX(DPFPREP, 2, "No gateway or firewall mappings detected.");
		}
#endif // DEBUG
		hr = DPN_OK;
	}


Exit:
	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::StartReceiving - start receiving data on this socket port
//
// Entry:		Handle of I/O completion port to bind to (used on NT only)
//
// Exit:		Error code
//
// Notes:	There is no 'Failure' label in this function because failures need
//			to be cleaned up for each OS variant.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::StartReceiving"

HRESULT	CSocketPort::StartReceiving( const HANDLE hIOCompletionPort )
{
	HRESULT	hr;


	//
	// initialize
	//
	hr = DPN_OK;

#ifdef WINNT
	//
	// we're on NT, bind to the completion port, issue a read and we're done
	//
	HRESULT		hTempResult;
	HANDLE		hCreateReturn;
	LONG		lIndex;
	DWORD_PTR	dwTotalReceives;


	//
	// bind to completion port
	//
	DNASSERT( GetSocket() != INVALID_SOCKET );
	DNASSERT( hIOCompletionPort != NULL );
	DBG_CASSERT( sizeof( m_Socket ) == sizeof( HANDLE ) );
	hCreateReturn = CreateIoCompletionPort( reinterpret_cast<HANDLE>( GetSocket() ),	// current file handle (socket)
											hIOCompletionPort,							// handle of completion port
											IO_COMPLETION_KEY_IO_COMPLETE,				// completion key
											0											// number of concurrent threads (default to number of processors)
											);
	if ( hCreateReturn == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot bind SocketPort to completion port!" );
		DisplayErrorCode( 0, GetLastError() );
		goto Failure;
	}
	DNASSERT( hCreateReturn == hIOCompletionPort );

	//
	// We're set, read requests equal to the number of I/O completion
	// threads.  If the reads fail, nothing will be received.
	//
	hTempResult = m_pSPData->GetThreadPool()->GetIOThreadCount( &lIndex );
	DNASSERT( hTempResult == DPN_OK );
	
	dwTotalReceives = lIndex * g_dwWinsockReceiveBufferMultiplier;
	DNASSERT( dwTotalReceives != 0 );
	
	while ( dwTotalReceives != 0 )
	{
		dwTotalReceives--;

		hr = Winsock2Receive();
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Problem issuing initial IOCompletion read in StartReceiving!" );
			DisplayDNError( 0, hr );
			DNASSERT( FALSE );
		}
	}

#else // WIN95
	//
	// Win9x.
	// If this is not an IPX socket and Winsock 2 (or greater) is available,
	// call the Winsock 2 read function.  If this is IPX or we're stuck with
	// Winsock 1, inform the thread pool as such.
	//
	DNASSERT( hIOCompletionPort == NULL );

	if ( ( LOWORD( GetWinsockVersion() ) >= 2 ) &&
		 ( m_pSPData->GetType() == TYPE_IP ) )
	{
		DWORD_PTR	dwTotalReceives;



		//
		// we're using Winsock2, call for two outstanding reads per socket.
		//
		dwTotalReceives = m_pSPData->GetThreadPool()->ThreadCount() * g_dwWinsockReceiveBufferMultiplier;
		
		DNASSERT( dwTotalReceives != 0 );
		while ( dwTotalReceives != 0 )
		{
			dwTotalReceives--;
			
			hr = Winsock2Receive();
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Problem issuing Win9x read in StartReceiving!" );
				DisplayDNError( 0, hr );
				DNASSERT( FALSE );
			}
		}
	}
	else
	{
		DNASSERT( m_pSPData != NULL );
		hr = m_pSPData->GetThreadPool()->AddSocketPort( this );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Failed to add to active socket list!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
#endif

Exit:
	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CSocketPort::SendFromWriteQueue - send as many items as possible from the
//		write queue
//
// Entry:		Nothing
//
// Exit:		Boolean indicating that something was sent
//				TRUE = data was sent
//				FALSE = no data was sent
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::SendFromWriteQueue"

BOOL	CSocketPort::SendFromWriteQueue( void )
{
	BOOL					fDataSent;
	CWriteIOData			*pWriteData;
	SEND_COMPLETION_CODE	TempCompletionCode;	


	DPFX(DPFPREP, 8,"SendFromWriteQueue");

	//
	// initialize
	//
	fDataSent = FALSE;
	TempCompletionCode = SEND_IN_PROGRESS;

	m_SendQueue.Lock();
	pWriteData = m_SendQueue.Dequeue();
	DPFX(DPFPREP, 8,"WriteData 0x%p",pWriteData);
	m_SendQueue.Unlock();

	while ( ( pWriteData != NULL ) && ( TempCompletionCode == SEND_IN_PROGRESS ) )
	{
		pWriteData->m_pCommand->Lock();
		switch ( pWriteData->m_pCommand->GetState() )
		{
			//
			// command is still pending, attempt to send the data
			//
			case COMMAND_STATE_PENDING:
			{
				DPFX(DPFPREP, 8,"COMMAND_STATE_PENDING");
				TempCompletionCode = (this->*m_pSendFunction)( pWriteData );
				DPFX(DPFPREP, 8,"TempCompletionCode %x",TempCompletionCode);
				switch ( TempCompletionCode )
				{
					//
					// We managed to get this send going.  It's already been removed
					// from the queue.  Get the next item from the queue and restart
					// the loop.
					//
					case SEND_IN_PROGRESS:
					{
						DPFX(DPFPREP, 8,"Send In Progress, going ok, so getting another");
						pWriteData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
						pWriteData->m_pCommand->Unlock();
						
						m_SendQueue.Lock();
						pWriteData = m_SendQueue.Dequeue();
						DPFX(DPFPREP, 8,"(SIP) WriteData %p",pWriteData);
						m_SendQueue.Unlock();

						fDataSent = TRUE;
						break;
					}

					//
					// Winsock is still busy, put this item back at the front of
					// the queue.  Clear 'pWriteData' to stop the loop.
					//
					case SEND_WINSOCK_BUSY:
					{
						DPFX(DPFPREP, 8,"Winsock Busy, requeuing for later");
						DNASSERT( pWriteData->m_pCommand->GetState() == COMMAND_STATE_PENDING );
						m_SendQueue.Lock();
						m_SendQueue.AddToFront( pWriteData );
						m_SendQueue.Unlock();
						pWriteData->m_pCommand->Unlock();
						pWriteData = NULL;

						break;
					}

					//
					// Winsock1 send completed immediately, try sending something
					// else
					//
					case SEND_COMPLETED_IMMEDIATELY_WS1:
					{
						DPFX(DPFPREP, 8,"Completed immediately (Winsock1), getting another");
						pWriteData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
						pWriteData->m_pCommand->Unlock();

						SendComplete( pWriteData, DPN_OK );

						m_SendQueue.Lock();
						pWriteData = m_SendQueue.Dequeue();
						m_SendQueue.Unlock();
						DPFX(DPFPREP, 8,"(SIW) WriteData %p",pWriteData);
						fDataSent = TRUE;
						TempCompletionCode = SEND_IN_PROGRESS;
						break;
					}

					//
					// send failed, try sending the next item
					//
					case SEND_FAILED:
					{
						DPFX(DPFPREP, 8,"Send Failed");
						pWriteData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
						pWriteData->m_pCommand->Unlock();

						SendComplete( pWriteData, DPNERR_GENERIC );

						m_SendQueue.Lock();
						pWriteData = m_SendQueue.Dequeue();
						m_SendQueue.Unlock();

						break;
					}

					//
					// invalid return
					//
					default:
					{
						DNASSERT( FALSE );
						break;
					}
				}

				break;
			}

			//
			// This command is to be cancelled, remove it from the queue
			// and issue completion notification to caller.  Then we can
			// look at the next item.
			//
			case COMMAND_STATE_CANCELLING:
			{
				pWriteData->m_pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
				pWriteData->m_pCommand->Unlock();

				SendComplete( pWriteData, DPNERR_USERCANCEL );

				m_SendQueue.Lock();
				pWriteData = m_SendQueue.Dequeue();
				m_SendQueue.Unlock();

				break;
			}

			//
			// invalid command state
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	return	fDataSent;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::GetBoundNetworkAddress - get the full network address that
//		this socket port was really bound to
//
// Entry:		Address type for bound address
//
// Exit:		Pointer to network address
//
// Note:	Since this function creates a local address to derive the network
//			address from, it needs to know what kind of address to derive.  This
//			address type is supplied as the function parameter.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::GetBoundNetworkAddress"

CSocketAddress	*CSocketPort::GetBoundNetworkAddress( const SP_ADDRESS_TYPE AddressType ) const
{
	HRESULT			hr;
	CSocketAddress	*pTempSocketAddress;
	SOCKADDR		BoundSocketAddress;
	INT_PTR			iReturnValue;
	INT				iBoundSocketAddressSize;


	//
	// initialize
	//
	pTempSocketAddress = NULL;

	//
	// create addresses
	//
	pTempSocketAddress = m_pSPData->GetNewAddress();
	if ( pTempSocketAddress == NULL )
	{
		DPFX(DPFPREP, 0, "GetBoundNetworkAddress: Failed to create socket address!" );
		goto Failure;
	}

	//
	// find out what address we really bound to and reset the information for
	// this socket port
	//
	iBoundSocketAddressSize = pTempSocketAddress->GetAddressSize();
	iReturnValue = p_getsockname( GetSocket(), &BoundSocketAddress, &iBoundSocketAddressSize );
	if ( iReturnValue == SOCKET_ERROR )
	{
		DWORD	dwErrorCode;


		dwErrorCode = p_WSAGetLastError();
		hr = DPNERR_GENERIC;
		DPFX(DPFPREP, 0, "GetBoundNetworkAddress: Failed to get local socket name after bind!" );
		DisplayWinsockError( 0, dwErrorCode );
		goto Failure;
	}
	pTempSocketAddress->SetAddressFromSOCKADDR( BoundSocketAddress, iBoundSocketAddressSize );
	DNASSERT( iBoundSocketAddressSize == pTempSocketAddress->GetAddressSize() );

	//
	// Since this address was created locally, we need to tell it what type of
	// address to export according to the input.
	//
	pTempSocketAddress->SetAddressType( AddressType );

	switch ( AddressType )
	{
		//
		//  known types
		//
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		case SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET:
		case SP_ADDRESS_TYPE_HOST:
		case SP_ADDRESS_TYPE_READ_HOST:
		{
			break;
		}

		//
		// if we're looking for a public address, we need to make sure that this
		// is not an undefined address.  If it is, don't return an address.
		// Otherwise, remap the address type to a 'host' address.
		//
		case SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS:
		{
			if ( pTempSocketAddress->IsUndefinedHostAddress() != FALSE )
			{
				m_pSPData->ReturnAddress( pTempSocketAddress );
				pTempSocketAddress = NULL;
			}
			else
			{
				pTempSocketAddress->SetAddressType( SP_ADDRESS_TYPE_HOST );
			}

			break;
		}

		//
		// unknown address type, fix the code!
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}

	}

Exit:
	return	pTempSocketAddress;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::GetDP8BoundNetworkAddress - get the network address this machine
//		is bound to according to the input parameter.  If the requested address
//		for the public address and an Internet gateway are available, use the
//		public address.  If a public address is requested but is unavailable,
//		fall back to the bound network address for local host-style device
//		addresses.  If a public address is unavailable but we're explicitly
//		looking for a public address, return NULL.
//
// Entry:		Type of address to get (local adapter vs. host)
//
// Exit:		Pointer to network address
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::GetDP8BoundNetworkAddress"

IDirectPlay8Address *CSocketPort::GetDP8BoundNetworkAddress( const SP_ADDRESS_TYPE AddressType,
																const GATEWAY_BIND_TYPE GatewayBindType) const
{
	HRESULT					hr;
	IDirectPlay8Address *	pAddress;
	CSocketAddress *		pTempAddress = NULL;
	DWORD					dwTemp;
	SOCKADDR				saddr;
	DWORD					dwAddressSize;
#ifdef DEBUG
	SOCKADDR_IN *			psaddrin;
	DWORD					dwAddressTypeFlags;
#endif // DEBUG


	DPFX(DPFPREP, 8, "(0x%p) Parameters: (0x%i)", this, AddressType );

	//
	// initialize
	//
	pAddress = NULL;


	DNASSERT( m_pThreadPool != NULL );
	DNASSERT( m_pNetworkSocketAddress != NULL );

#ifdef DEBUG
	switch ( m_pNetworkSocketAddress->GetFamily() )
	{
		case AF_INET:
		{
			psaddrin = (SOCKADDR_IN *) m_pNetworkSocketAddress->GetAddress();
			DNASSERT( psaddrin->sin_addr.S_un.S_addr != 0 );
			DNASSERT( psaddrin->sin_addr.S_un.S_addr != INADDR_BROADCAST );
			DNASSERT( psaddrin->sin_port != 0 );
			break;
		}
		
		case AF_IPX:
		{
			break;
		}
		
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
#endif // DEBUG

	switch ( AddressType )
	{
		case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
		{
		
			pAddress = m_pNetworkSocketAddress->DP8AddressFromSocketAddress();


			//
			// We hand up the exact device address we ended up using for this adapter.
			// In multi-adapter systems, our user is probably going to switch in a different
			// device GUID and pass it back down for another connect attempt (because
			// we told them we support ALL_ADAPTERS).  This can pose a problem since
			// we include the specific port in this address.  If the port was available on this
			// adapter but not on others.  The other attempts will fail.  This can also cause
			// problems when indicating the device with enum responses.  If the application
			// allowed us to select a local port, enumerated and got a response, shutdown
			// the interface (or just the enum), then connected with the device address, we
			// would try to use that port again, even though it may now be in use by
			// another local application (or more likely, on the NAT).
			// 
			// We are not required to use the same port on all adapters if the caller did
			// not choose a specific port in the first place, so there's no reason why we
			// couldn't try a different one.
			//
			// We know whether the port was specified or not, because GatewayBindType
			// will be GATEWAY_BIND_TYPE_DEFAULT if the port can float, _SPECIFIC or
			// _SPECIFIC_SHARED if not.
			//
			// So we can add a special key to the device address indicating that while it
			// does contain a port, don't take that too seriously.  That way, if this device
			// address is reused, we can detect the special key and handle port-in-use
			// problems gracefully by trying a different one.
			//
			// This special key is not documented and should not be used by anyone but
			// us.  We'll use the socketport ID as the value so that it's seemingly random,
 			// just to try to scare anyone off from mimicking it in addresses they generate.
 			// But we're not going to actually use the value.  If the component is present
 			// and the value is the right size, we'll use it.  If someone puts this into an
 			// address on their own, they get what they deserve (not like this will cause
 			// us to blow up or anything)...
 			//
 			// Look in CSPData::BindEndpoint for where this gets read back in.
			//

			if ( GatewayBindType == GATEWAY_BIND_TYPE_DEFAULT )
			{
				//
				// Add the component, but ignore failure, we can still survive without it.
				//
				hr = IDirectPlay8Address_AddComponent( pAddress,							// interface
														DPNA_PRIVATEKEY_PORT_NOT_SPECIFIC,	// tag
														&(this->m_dwSocketPortID),			// component data
														sizeof(this->m_dwSocketPortID),		// component data size
														DPNA_DATATYPE_DWORD					// component data type
														);
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Couldn't add private port-not-specific component (err = 0x%lx)!  Ignoring.", hr);
					hr = DPN_OK;
				}
			}
			
			break;
		}

		case SP_ADDRESS_TYPE_HOST:
		case SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS:
		{
			//
			// Try to get the public address, if we have one.
			//
			if ( ( m_pNetworkSocketAddress->GetFamily() == AF_INET ) &&
				( m_pThreadPool->IsNATHelpLoaded() ) )		
			{
				pTempAddress = m_pSPData->GetNewAddress();
				if ( pTempAddress != NULL)
				{
			  		//
				  	// IDirectPlayNATHelp::GetCaps had better have been called with the
			  		// DPNHGETCAPS_UPDATESERVERSTATUS flag at least once prior to this.
			  		// See CThreadPool::PreventThreadPoolReduction
			  		//
			  		
					for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
					{
						if (g_papNATHelpObjects[dwTemp] != NULL)
						{
							dwAddressSize = sizeof(saddr);
#ifdef DEBUG
							hr = IDirectPlayNATHelp_GetRegisteredAddresses( g_papNATHelpObjects[dwTemp],	// object
																			m_ahNATHelpPorts[dwTemp],		// port binding
																			&saddr,							// place to store address
																			&dwAddressSize,					// address buffer size
																			&dwAddressTypeFlags,			// get type flags for printing in debug
																			NULL,							// don't need lease time remaining
																			0 );							// no flags
#else
							hr = IDirectPlayNATHelp_GetRegisteredAddresses( g_papNATHelpObjects[dwTemp],	// object
																			m_ahNATHelpPorts[dwTemp],		// port binding
																			&saddr,							// place to store address
																			&dwAddressSize,					// address buffer size
																			NULL,							// don't bother getting type flags in retail
																			NULL,							// don't need lease time remaining
																			0 );							// no flags
#endif // DEBUG
							if (hr == DPNH_OK)
							{
								pTempAddress->SetAddressFromSOCKADDR( saddr, sizeof(saddr) );

								DPFX(DPFPREP, 2, "Internet gateway index %u currently maps address (type flags = 0x%lx):",
									dwTemp, dwAddressTypeFlags);
								DumpSocketAddress( 2, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
								DumpSocketAddress( 2, pTempAddress->GetAddress(), pTempAddress->GetFamily() );

								//
								// Double check that the address we got was valid.
								//
								DNASSERT( ((SOCKADDR_IN*) (&saddr))->sin_addr.S_un.S_addr != 0 );

								//
								// Get out of the loop since we have a mapping.
								//
								break;
							}


#ifdef DEBUG
							switch (hr)
							{
								case DPNHERR_NOMAPPING:
								{
									DPFX(DPFPREP, 1, "Internet gateway (index %u, type flags = 0x%lx) does not have a public address.",
										dwTemp, dwAddressTypeFlags);
									break;
								}

								case DPNHERR_PORTUNAVAILABLE:
								{
									DPFX(DPFPREP, 1, "Port is unavailable on Internet gateway (index %u).", dwTemp );
									break;
								}

								case DPNHERR_SERVERNOTAVAILABLE:
								{
									DPFX(DPFPREP, 1, "No Internet gateway (index %u).", dwTemp );
									break;
								}

								default:
								{
									DPFX(DPFPREP, 1, "An error (0x%lx) occurred while getting registered address mapping index %u.",
										hr, dwTemp);
									break;
								}
							}
#endif // DEBUG
						}
						else
						{
							//
							// No object in this slot.
							//
						}
					} // end for (each DPNATHelp object)


					//
					// If we found a mapping, pTempAddress is not NULL and contains the mapping's
					// address.  If we couldn't find any mappings with any of the NAT Help objects,
					// pTempAddress will be non-NULL, but bogus.  We should return the local address
					// if it's a HOST address, or NULL if the caller was trying to get the public
					// address.
					//
					if (hr != DPNH_OK)
					{
						if (AddressType == SP_ADDRESS_TYPE_HOST)
						{
							DPFX(DPFPREP, 1, "No NAT Help mappings exist, using regular address:");
							DumpSocketAddress( 1, m_pNetworkSocketAddress->GetAddress(), m_pNetworkSocketAddress->GetFamily() );
							pTempAddress->CopyAddressSettings( m_pNetworkSocketAddress );
						}
						else
						{
							DPFX(DPFPREP, 1, "No NAT Help mappings exist, not returning address.");
							m_pSPData->ReturnAddress( pTempAddress );
							pTempAddress = NULL;
						}
					}
					else
					{
						//
						// We found a mapping.
						//
					}
				}
				else
				{
					//
					// Couldn't get temporary address object, we won't return an address.
					//
				}
			}
			else
			{
				//
				// NAT Help not loaded or not necessary.
				//
				
				if (AddressType == SP_ADDRESS_TYPE_HOST)
				{
					pTempAddress = m_pSPData->GetNewAddress();
					if ( pTempAddress != NULL )
					{
						pTempAddress->CopyAddressSettings( m_pNetworkSocketAddress );
					}
					else
					{
						//
						// Couldn't allocate memory, we won't return an address.
						//
					}
				}
				else
				{
					//
					// Public host address requested.  NAT Help not available, so of course
					// there won't be a public address.  Return NULL.
					//
				}
			}


			//
			// If we determined we had an address to return, convert it to the
			// IDirectPlay8Address object our caller is expecting.
			//
			if ( pTempAddress != NULL )
			{
				//
				// We have an address to return.
				//
#ifdef DEBUG
				if (pTempAddress->GetFamily() == AF_INET)
				{
					psaddrin = (SOCKADDR_IN *) pTempAddress->GetAddress();
					DNASSERT( psaddrin->sin_addr.S_un.S_addr != 0 );
					DNASSERT( psaddrin->sin_addr.S_un.S_addr != INADDR_BROADCAST );
					DNASSERT( psaddrin->sin_port != 0 );
				}
				else
				{
					DNASSERT(pTempAddress->GetFamily() == AF_IPX);
				}
#endif // DEBUG


				//
				// Convert the socket address to an IDirectPlay8Address
				//
				pTempAddress->SetAddressType( SP_ADDRESS_TYPE_HOST );
				pAddress = pTempAddress->DP8AddressFromSocketAddress();

				m_pSPData->ReturnAddress( pTempAddress );
				pTempAddress = NULL;
			}
			else
			{
				//
				// Not returning an address.
				//
				DNASSERT( pAddress == NULL );
			}

			break;
		}

		default:
		{
			//
			// shouldn't be here
			//
			DNASSERT( FALSE );
			break;
		}
	}


	DPFX(DPFPREP, 8, "(0x%p) Returning [0x%p]", this, pAddress );
	
	return	pAddress;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::Winsock2ReceiveComplete - a Winsock2 socket receive completed
//
// Entry:		Pointer to read data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::Winsock2ReceiveComplete"

void	CSocketPort::Winsock2ReceiveComplete( CReadIOData *const pReadData )
{
	DPFX(DPFPREP, 8, "Socket port 0x%p completing read data 0x%p with result %i, bytes %u.",
		this, pReadData, pReadData->m_ReceiveWSAReturn, pReadData->m_dwOverlappedBytesReceived);


	DNASSERT( pReadData != NULL );

	//
	// initialize
	//
#ifdef WIN95
	DNASSERT( pReadData->Win9xOperationPending() == FALSE );
#endif

	//
	// figure out what's happening with this socket port
	//
	Lock();
	switch ( m_State )
	{
		//
		// we're unbound, discard this message and don't ask for any more
		//
		case SOCKET_PORT_STATE_UNBOUND:
		{
			DPFX(DPFPREP, 1, "Socket port 0x%p is unbound ignoring result %i (%u bytes).",
				this, pReadData->m_ReceiveWSAReturn, pReadData->m_dwOverlappedBytesReceived );
			Unlock();
			break;
		}

		//
		// we're initialized, process input data and submit a new receive if
		// applicable
		//
		case SOCKET_PORT_STATE_INITIALIZED:
		{
			switch ( pReadData->m_ReceiveWSAReturn )
			{
				//
				// the socket was closed on an outstanding read, stop
				// receiving
				//
				case WSAENOTSOCK:					// WinNT return for closed socket
				case ERROR_OPERATION_ABORTED:		// Win9x return for closed socket
				{
					Unlock();
					DPFX(DPFPREP, 1, "Ignoring socket closing err (%u/0x%lx).",
						pReadData->m_ReceiveWSAReturn, pReadData->m_ReceiveWSAReturn );
					break;
				}

				//
				// other error, perform another receive and process data if
				// applicable
				//
				default:
                {
					//
					// stop if the error isn't 'expected'
					//
					switch ( pReadData->m_ReceiveWSAReturn )
					{
						//
						// ERROR_SUCCESS = no problem (process received data)
						//
						case ERROR_SUCCESS:
						{
							break;
						}
						
						//
						// WSAECONNRESET = previous send failed
						// ERROR_PORT_UNREACHABLE = previous send failed
						// ERROR_MORE_DATA = datagram was sent that was too large
						// ERROR_FILE_NOT_FOUND = socket was closed or previous send failed
						//
						case WSAECONNRESET:
						case ERROR_PORT_UNREACHABLE:
						case ERROR_MORE_DATA:
						case ERROR_FILE_NOT_FOUND:
						{
							DPFX(DPFPREP, 1, "Ignoring known receive err 0x%lx.", pReadData->m_ReceiveWSAReturn );
							break;
						}

						default:
						{
							DPFX(DPFPREP, 0, "Unexpected return from WSARecvFrom() 0x%lx.", pReadData->m_ReceiveWSAReturn );
							DisplayErrorCode( 0, pReadData->m_ReceiveWSAReturn );
							DNASSERT( FALSE );
							break;
						}
					}

					// The socket state must not go to UNBOUND while we are in a receive or we will be using
					// an invalid socket handle.
					m_iThreadsInReceive++;

					Unlock();

					Winsock2Receive();

					Lock();

					m_iThreadsInReceive--;

					Unlock();

					if ( pReadData->m_ReceiveWSAReturn == ERROR_SUCCESS )
					{
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize = pReadData->m_dwOverlappedBytesReceived;
						ProcessReceivedData( pReadData );
					}
					break;
				}
			}

			break;
		}

		//
		// other state
		//
		default:
		{
			DNASSERT( FALSE );
			Unlock();
			break;
		}
	}

	//
	// Return the current data to the pool and note that this I/O operation is
	// complete.  Clear the overlapped bytes received so they aren't misinterpreted
	// if this item is reused from the pool.
	//
	DNASSERT( pReadData != NULL );
	pReadData->m_dwOverlappedBytesReceived = 0;	
	pReadData->DecRef();	
	DecRef();

	return;
}
//**********************************************************************




//**********************************************************************
// ------------------------------
// CSocketPort::CancelReceive - cancel a pending receive
//
// Entry:		Poiner to read data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::CancelReceive"

void	CSocketPort::CancelReceive( CReadIOData *const pRead )
{
	DPFX(DPFPREP, 1, "Cancelling receive 0x%p.", pRead);

	DNASSERT( pRead != NULL );

	pRead->DecRef();
	DecRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketPort::ProcessReceivedData - process received data
//
// Entry:		Pointer to CReadIOData
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSocketPort::ProcessReceivedData"

void	CSocketPort::ProcessReceivedData( CReadIOData *const pReadData )
{
	PREPEND_BUFFER *	pPrependBuffer;
	HANDLE				hEndpoint;
	CEndpoint *			pEndpoint;
	BOOL				fDataClaimed;
	CBilink *			pBilink;
	CEndpoint *			pCurrentEndpoint;
	CSocketAddress *	pSocketAddress;


	DNASSERT( pReadData != NULL );


	DPFX(DPFPREP, 7, "(0x%p) Processing %u bytes of data from + to:", this, pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize);
	DumpSocketAddress(7, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily());
	DumpSocketAddress(7, this->GetNetworkAddress()->GetAddress(), this->GetNetworkAddress()->GetFamily());

	
	DBG_CASSERT( sizeof( pReadData->ReceivedBuffer()->BufferDesc.pBufferData ) == sizeof( PREPEND_BUFFER* ) );
	pPrependBuffer = reinterpret_cast<PREPEND_BUFFER*>( pReadData->ReceivedBuffer()->BufferDesc.pBufferData );

	//
	// Check data for integrity and decide what to do with it.  If there is
	// enough data to determine an SP command type, try that.  If there isn't
	// enough data, and it looks spoofed, reject it.
	//
	if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->GenericHeader ) )
	{
		if ( pPrependBuffer->GenericHeader.bSPLeadByte != SP_HEADER_LEAD_BYTE )
		{
			goto ProcessUserData;
		}
		else
		{
			switch ( pPrependBuffer->GenericHeader.bSPCommandByte )
			{
				//
				// Normal data, the user's first byte matched the service
				// provider tag byte.  Check for a non-zero payload and skip the
				// header that was added.
				//
				case ESCAPED_USER_DATA_KIND:
				{
					if ( ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->EscapedUserDataHeader ) ) &&
						 ( pPrependBuffer->EscapedUserDataHeader.wPad == ESCAPED_USER_DATA_PAD_VALUE ) )
					{
						pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->EscapedUserDataHeader ) ];
						DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->EscapedUserDataHeader ) );
						pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->EscapedUserDataHeader );
						goto ProcessUserData;
					}

					break;
				}

				//
				// Enum data, send it to the active listen (if there's one).  Allow users to send
				// enum requests that contain no data.
				//
				case ENUM_DATA_KIND:
				{
					if ( ! g_fIgnoreEnums )
					{
						if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->EnumDataHeader ) )
						{
							LockEndpointData();
							if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
							{
								//
								// add a reference to this endpoint so it doesn't go away while we're processing
								// this data
								//
								pEndpoint = m_pSPData->EndpointFromHandle( m_hListenEndpoint );
								UnlockEndpointData();
								
								if ( pEndpoint != NULL )
								{
									//
									// skip prepended enum header
									//
									pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->EnumDataHeader ) ];
									DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->EnumDataHeader ) );
									pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->EnumDataHeader );

									//
									// process data
									//
									pEndpoint->ProcessEnumData( pReadData->ReceivedBuffer(),
																pPrependBuffer->EnumDataHeader.wEnumPayload,
																pReadData->m_pSourceSocketAddress );
									pEndpoint->DecCommandRef();
								}
							}
							else
							{
								//
								// there's no listen active, return the receive buffer to the pool
								//
								UnlockEndpointData();

								DPFX(DPFPREP, 7, "Ignoring enumeration, no associated listen." );
							}
						}
					}
					else
					{
						DPFX(DPFPREP, 7, "Ignoring enumeration attempt." );
					}

					break;
				}

				//
				// Enum response data, find the appropriate enum and pass it on.  Allow users to send
				// enum responses that contain no data.
				//
				case ENUM_RESPONSE_DATA_KIND:
				{
					if ( ! g_fIgnoreEnums )
					{
						if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->EnumResponseDataHeader ) )
						{
							CEndpointEnumKey	Key;


							Key.SetKey( pPrependBuffer->EnumResponseDataHeader.wEnumResponsePayload );
							LockEndpointData();
							if ( m_EnumEndpointHash.Find( &Key, &hEndpoint ) != FALSE )
							{
								UnlockEndpointData();

								DNASSERT( hEndpoint != INVALID_HANDLE_VALUE );
								pEndpoint = m_pSPData->EndpointFromHandle( hEndpoint );
								if ( pEndpoint != NULL )
								{
									pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->EnumResponseDataHeader ) ];
									DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->EnumResponseDataHeader ) );
									pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->EnumResponseDataHeader );

									pEndpoint->ProcessEnumResponseData( pReadData->ReceivedBuffer(),
																		pReadData->m_pSourceSocketAddress,
																		( pPrependBuffer->EnumResponseDataHeader.wEnumResponsePayload & ENUM_RTT_MASK ) );
									pEndpoint->DecCommandRef();
								}
							}
							else
							{
								//
								// the associated ENUM doesn't exist, return the receive buffer
								//
								UnlockEndpointData();

								DPFX(DPFPREP, 7, "Ignoring enumeration response, no enum associated with key (%u).",
									pPrependBuffer->EnumResponseDataHeader.wEnumResponsePayload );
							}
						}
					}
					else
					{
						DPFX(DPFPREP, 7, "Ignoring enumeration response attempt." );
					}
	
					break;
				}

				//
				// proxied query data, this data was forwarded from another port.  Munge
				// the return address, modify the buffer pointer and then send it up
				// through the normal enum data processing pipeline.
				//
				case PROXIED_ENUM_DATA_KIND:
				{
					if ( ! g_fIgnoreEnums )
					{
						if ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->ProxiedEnumDataHeader ) )
						{
							LockEndpointData();
							if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
							{
								//
								// add a reference to this endpoint so it doesn't go
								// away while we're processing this data
								//
								pEndpoint = m_pSPData->EndpointFromHandle( m_hListenEndpoint );
								UnlockEndpointData();
		
								if ( pEndpoint != NULL )
								{
									pReadData->m_pSourceSocketAddress->SetAddressFromSOCKADDR( pPrependBuffer->ProxiedEnumDataHeader.ReturnAddress,
																							   pReadData->m_pSourceSocketAddress->GetAddressSize() );

									pReadData->ReceivedBuffer()->BufferDesc.pBufferData = &pReadData->ReceivedBuffer()->BufferDesc.pBufferData[ sizeof( pPrependBuffer->ProxiedEnumDataHeader ) ];

									DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize > sizeof( pPrependBuffer->ProxiedEnumDataHeader ) );
									pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize -= sizeof( pPrependBuffer->ProxiedEnumDataHeader );

									pEndpoint->ProcessEnumData( pReadData->ReceivedBuffer(),
																pPrependBuffer->ProxiedEnumDataHeader.wEnumKey,
																pReadData->m_pSourceSocketAddress );
									pEndpoint->DecCommandRef();
								}
							}
							else
							{
								//
								// there's no listen active, return the receive buffer to the pool
								//
								UnlockEndpointData();

								DPFX(DPFPREP, 7, "Ignoring proxied enumeration, no associated listen." );
							}
						}
					}
					else
					{
						DPFX(DPFPREP, 7, "Ignoring proxied enumeration attempt." );
					}
		
					break;
				}
			}
		}
	}
	else	// pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize >= sizeof( pPrependBuffer->GenericHeader
	{
		if ( ( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize == 1 ) &&
			 ( pPrependBuffer->GenericHeader.bSPLeadByte != SP_HEADER_LEAD_BYTE ) )
		{
			goto ProcessUserData;
		}
	}

Exit:
	return;

ProcessUserData:
	//	
	// If there's an active connection, send it to the connection.  If there's
	// no active connection, send it to an available 'listen' to indicate a
	// potential new connection.	
	//
	LockEndpointData();
	DNASSERT( pReadData->ReceivedBuffer()->BufferDesc.dwBufferSize != 0 );
	
	if ( m_ConnectEndpointHash.Find( pReadData->m_pSourceSocketAddress, &hEndpoint ) )
	{
		DNASSERT( hEndpoint != INVALID_HANDLE_VALUE );
		pEndpoint = m_pSPData->EndpointFromHandle( hEndpoint );
		if ( pEndpoint != NULL )
		{
			pEndpoint->IncNumReceives();

			UnlockEndpointData();

			pEndpoint->ProcessUserData( pReadData );
			pEndpoint->DecCommandRef();
		}
		else
		{
			UnlockEndpointData();
		}
	}
	else
	{
		//
		// Next see if the data is a proxied response
		//
		if ((this->IsUsingProxyWinSockLSP()) || (g_fTreatAllResponsesAsProxied))
		{
			pEndpoint = NULL;
			pBilink = this->m_blConnectEndpointList.GetNext();
			while (pBilink != &this->m_blConnectEndpointList)
			{
				pCurrentEndpoint = CEndpoint::EndpointFromSocketPortListBilink(pBilink);
				
				if (pCurrentEndpoint->GetNumReceives() == 0)
				{
					if (pEndpoint != NULL)
					{
						DPFX(DPFPREP, 1, "Receiving data from unknown source, but two or more connects are pending on socketport 0x%p, no proxied association can be made.",
							this);
						pEndpoint = NULL;
						break;
					}

					pEndpoint = pCurrentEndpoint;
					
					//
					// Continue, so we can verify there aren't two simultaneous
					// connects going on.
					//
				}
				else
				{
					//
					// This endpoint has already received some data.
					// It can't be proxied.
					//
				}

				pBilink = pBilink->GetNext();
			}

			if (pEndpoint != NULL)
			{
				pSocketAddress = pEndpoint->GetWritableRemoteAddressPointer();

				DPFX(DPFPREP, 1, "Found connecting endpoint 0x%p off socketport 0x%p, assuming data from unknown source is a proxied response.  Changing target (was + now):",
					pEndpoint, this);
				DumpSocketAddress(1, pSocketAddress->GetAddress(), pSocketAddress->GetFamily());
				DumpSocketAddress(1, pReadData->m_pSourceSocketAddress->GetAddress(), pReadData->m_pSourceSocketAddress->GetFamily());
				

				DNASSERT( this->m_ConnectEndpointHash.Find( pSocketAddress, &hEndpoint ) );
				this->m_ConnectEndpointHash.Remove( pSocketAddress );

				//
				// We could have regkey to leave the target socketaddress the same
				// so outbound always goes to that address and inbound always comes
				// in via the different one, however that means adding a variable to
				// hold the original target address because we currently pull the
				// endpoint out of the hash table by it's remoteaddress pointer, so
				// if that differed from what was in the hash, we would fail to find
				// it.  Since we're not trying to enable that scenario for now
				// (we're just doing this for ISA Server proxy), I'm not doing that
				// work yet.  See CSPData::BindEndpoint.
				//
				pSocketAddress->CopyAddressSettings( pReadData->m_pSourceSocketAddress );

				if ( m_ConnectEndpointHash.Insert( pSocketAddress, pEndpoint->GetHandle() ) == FALSE )
				{
					UnlockEndpointData();

					DPFX(DPFPREP, 0, "Problem adding endpoint to connect socket port hash!" );

					//
					// Nothing we can really do... We're hosed.
					//
				}
				else
				{
					//
					// Indicate the data via the new address.
					//

					pEndpoint->IncNumReceives();
					pEndpoint->AddCommandRef();

					UnlockEndpointData();

					pEndpoint->ProcessUserData( pReadData );
					pEndpoint->DecCommandRef();
				}

				fDataClaimed = TRUE;
			}
			else
			{
				//
				// Either there weren't any connects pending, or there
				// were 2 or more so we couldn't pick.
				//
				fDataClaimed = FALSE;
			}
		}
		else
		{
			//
			// Not considering data as proxied.
			//

			fDataClaimed = FALSE;
		}


		if (! fDataClaimed)
		{
			if ( m_hListenEndpoint != INVALID_HANDLE_VALUE )
			{
				pEndpoint = m_pSPData->EndpointFromHandle( m_hListenEndpoint );
				UnlockEndpointData();

				if ( pEndpoint != NULL )
				{
					pEndpoint->ProcessUserDataOnListen( pReadData, pReadData->m_pSourceSocketAddress );
					pEndpoint->DecCommandRef();
				}
			}
			else
			{
				//
				// Nobody claimed this data.
				//
				UnlockEndpointData();
			}
		}
	}

	goto Exit;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dpnwsock
DLLDEF=..\wsocksp.def
UMTYPE=windows

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dnwsocki.h
PRECOMPILED_PCH=dnwsocki.pch
PRECOMPILED_OBJ=dnwsocki.obj
!endif

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           ..\..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
           ..\..\..\common\obj$(BUILD_ALT_DIR)\*\common.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib

#
# If a debug mode is selected, make sure we include the defines to make the
# logging code operate.
#
!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=$(DXROOT)\inc;..\..\..\inc;..\..\..\common;..\..\..\..\dpnathlp\inc;..\


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\AdapterEntry.cpp \
	 ..\Classfac.cpp \
         ..\CMDData.cpp \
	 ..\DebugUtils.cpp \
	 ..\DNWsock.rc \
	 ..\DWinsock.cpp \
	 ..\Endpoint.cpp \
	 ..\HandleTable.cpp \
	 ..\IOData.cpp \
	 ..\IPAddress.cpp \
	 ..\IPEndpt.cpp \
	 ..\IPUI.cpp \
	 ..\IPXAddress.cpp \
	 ..\IPXEndpt.cpp \
	 ..\JobQueue.cpp \
	 ..\Locals.cpp \
         ..\Pools.cpp \
	 ..\SendQueue.cpp \
	 ..\Socketport.cpp \
	 ..\SPAddress.cpp \
 	 ..\SPData.cpp \
	 ..\ThreadPool.cpp \
	 ..\UNK.cpp \
	 ..\Utils.cpp \
	 ..\WSockSP.cpp
#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL /DCINTERFACE

USE_NOLIBS=1

DLLENTRY=_DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\spdata.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   SPData.cpp
 *  Content:	Global variables for the DNSerial service provider in class
 *				format.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/15/99	jtk		Dereived from Locals.cpp
 *  01/10/20000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// CSPData::CSPData - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::CSPData"

CSPData::CSPData():
	m_lRefCount( 0 ),
	m_lObjectRefCount( 0 ),
	m_hShutdownEvent( NULL ),
	m_SPType( TYPE_UNKNOWN ),
	m_SPState( SPSTATE_UNINITIALIZED ),
	m_pBroadcastAddress( NULL ),
	m_pListenAddress( NULL ),
	m_pGenericAddress( NULL ),
	m_pThreadPool( NULL )
{
	m_Sig[0] = 'S';
	m_Sig[1] = 'P';
	m_Sig[2] = 'D';
	m_Sig[3] = 'T';
	
	memset( &m_ClassID, 0x00, sizeof( m_ClassID ) );
	memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	memset( &m_COMInterface, 0x00, sizeof( m_COMInterface ) );
	memset( &m_Flags, 0x00, sizeof( m_Flags ) );
	m_blActiveAdapterList.Initialize();
	m_blPostponedEnums.Initialize();
	m_blPostponedConnects.Initialize();
	
	DNInterlockedIncrement( &g_lOutstandingInterfaceCount );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::~CSPData - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::~CSPData"

CSPData::~CSPData()
{
	DNASSERT( m_lRefCount == 0 );
	DNASSERT( m_lObjectRefCount == 0 );
	DNASSERT( m_hShutdownEvent == NULL );
	DNASSERT( m_SPType == TYPE_UNKNOWN );
	DNASSERT( m_SPState == SPSTATE_UNINITIALIZED );
	DNASSERT( m_pThreadPool == NULL );
	DNASSERT( m_ActiveSocketPortList.IsEmpty() != FALSE );
	DNASSERT( m_Flags.fWinsockLoaded == FALSE );
	DNASSERT( m_Flags.fHandleTableInitialized == FALSE );
	DNASSERT( m_Flags.fLockInitialized == FALSE );
	DNASSERT( m_Flags.fSocketPortDataLockInitialized == FALSE );
	DNASSERT( m_Flags.fSocketPortListInitialized == FALSE );
	DNASSERT( m_Flags.fInterfaceGlobalsInitialized == FALSE );
	DNASSERT( m_Flags.fDefaultAddressesBuilt == FALSE );
	DNASSERT( m_blActiveAdapterList.IsEmpty() );
	DNASSERT( m_blPostponedEnums.IsEmpty() );
	DNASSERT( m_blPostponedConnects.IsEmpty() );
	DNInterlockedDecrement( &g_lOutstandingInterfaceCount );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Initialize - initialize
//
// Entry:		Class ID
//				SP type
//				Pointer to SP COM vtable
//
// Exit:		Error code
//
// Note:	This function assumes that someone else is preventing reentry!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::Initialize"

HRESULT	CSPData::Initialize( const CLSID *const pClassID,
							 const SP_TYPE SPType,
							 IDP8ServiceProviderVtbl *const pVtbl )
{
	HRESULT			hr;


	DNASSERT( pClassID != NULL );
	DNASSERT( pVtbl != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	DNASSERT( m_lRefCount == 1 );
	DNASSERT( m_lObjectRefCount == 0 );

	DNASSERT( GetType() == TYPE_UNKNOWN );
	m_SPType = SPType;
	
	DBG_CASSERT( sizeof( m_ClassID ) == sizeof( *pClassID ) );
	memcpy( &m_ClassID, pClassID, sizeof( m_ClassID ) );

	DNASSERT( m_COMInterface.m_pCOMVtbl == NULL );
	m_COMInterface.m_pCOMVtbl = pVtbl;

	//
	// attempt to initialize shutdown event
	//
	DNASSERT( m_hShutdownEvent == NULL );
	m_hShutdownEvent = CreateEvent( NULL,		// pointer to security (none)
									TRUE,		// manual reset
									TRUE,		// start signalled (so close can be called without any endpoints being created)
									NULL		// pointer to name (none)
									);
	if ( m_hShutdownEvent == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to create event for shutting down spdata!" );
		DisplayErrorCode( 0, dwError );
	}

	//
	// Attempt to load Winsock.
	//
	DNASSERT( m_Flags.fWinsockLoaded == FALSE );
	if ( LoadWinsock() == FALSE )
	{
		DPFX(DPFPREP, 0, "Failed to load winsock!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	m_Flags.fWinsockLoaded = TRUE;

	
	DNASSERT( m_Flags.fLockInitialized == FALSE );
	DNASSERT( m_Flags.fSocketPortDataLockInitialized == FALSE );
	DNASSERT( m_Flags.fSocketPortListInitialized == FALSE );
	DNASSERT( m_Flags.fInterfaceGlobalsInitialized == FALSE );
	DNASSERT( m_Flags.fDefaultAddressesBuilt == FALSE );

	hr = m_HandleTable.Initialize();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to initialize handle table!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	m_Flags.fHandleTableInitialized = TRUE;
	
	//
	// initialize internal critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Problem initializing main critical section!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	m_Flags.fLockInitialized = TRUE;

	if ( DNInitializeCriticalSection( &m_SocketPortDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Problem initializing SocketPortDataLock critical section!" );
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_SocketPortDataLock, 0 );
	m_Flags.fSocketPortDataLockInitialized = TRUE;

	//
	// initialize hash table for socket ports with 64 etries and a multiplier of 32
	//
	if ( m_ActiveSocketPortList.Initialize( 6, 5 ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Could not initialize socket port list!" );
		goto Failure;
	}
	m_Flags.fSocketPortListInitialized = TRUE;

	//
	// get a thread pool
	//
	DNASSERT( m_pThreadPool == NULL );
	hr = InitializeInterfaceGlobals( this );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to create thread pool!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	m_Flags.fInterfaceGlobalsInitialized = TRUE;

	//
	// build default addresses
	//
	hr = BuildDefaultAddresses();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem building default addresses!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	m_Flags.fDefaultAddressesBuilt = TRUE;

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem with CSPData::Initialize" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	
	if ( m_Flags.fWinsockLoaded != FALSE )
	{
		UnloadWinsock();
		m_Flags.fWinsockLoaded = FALSE;
	}


	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Shutdown - shut down this set of SP data
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::Shutdown"

void	CSPData::Shutdown( void )
{
	BOOL	fLooping;


	DPFX(DPFPREP, 2, "(0x%p) Enter", this);

	//
	// Unbind this interface from the globals.  This will cause a closure of all
	// of the I/O which will release endpoints, socket ports and then this data.
	//
	if ( m_Flags.fInterfaceGlobalsInitialized != FALSE )
	{
		this->CancelPostponedCommands();
		
		DeinitializeInterfaceGlobals( this );
		DNASSERT( GetThreadPool() != NULL );
		m_Flags.fInterfaceGlobalsInitialized = FALSE;
	}

	SetState( SPSTATE_CLOSING );
	
	DNASSERT( m_hShutdownEvent != NULL );


#ifdef DEBUG
	m_pThreadPool->DebugPrintOutstandingReads();
	m_pThreadPool->DebugPrintOutstandingWrites();
#endif // DEBUG


#if (defined(WIN95) || defined(DEBUG))
	DPFX(DPFPREP, 3, "(0x%p) Waiting for shutdown event 0x%p (with timeout).",
		this, m_hShutdownEvent);
#else // ! WIN95
	DPFX(DPFPREP, 3, "(0x%p) Waiting for shutdown event 0x%p.",
		this, m_hShutdownEvent);
#endif // ! WIN95
	
	fLooping = TRUE;
	while ( fLooping != FALSE )
	{
		//
		// On 9x, always wake up every 5 seconds to kick the receive thread (see
		// comment below).  On NT, only wake up every 5 seconds in debug, and
		// only do so to print out a warning.
		//
#if (defined(WIN95) || defined(DEBUG))
		switch ( WaitForSingleObjectEx( m_hShutdownEvent, 5000, TRUE ) )
#else // ! WIN95
		switch ( WaitForSingleObjectEx( m_hShutdownEvent, INFINITE, TRUE ) )
#endif // ! WIN95
		{
			case WAIT_OBJECT_0:
			{
				fLooping = FALSE;
				break;
			}

			case WAIT_IO_COMPLETION:
			{
				DPFX(DPFPREP, 1, "Ignoring I/O completion, continuing to wait.");
				break;
			}

#ifdef WIN95
			case WAIT_TIMEOUT:
			{
				//
				// If we're using the Win9x code path, kick the receive event.  This is
				// because (as far as I can tell) there are cases where receives complete
				// but don't trigger this event when shutting down the socket.  When that
				// occurs, the read I/O data completion isn't picked up and we sit here
				// waiting for references to go away.
				// Ideally, this issue would be reinvestigated in the future, but for now,
				// the workaround is to ping the event.  It's harmless if all the receives
				// actually did complete, plus if everything goes well, we won't even get
				// here.
				//

				DPFX(DPFPREP, 2, "(0x%p) Still waiting for shutdown event 0x%p, kicking receive event 0x%p.",
					this, m_pThreadPool->GetWinsock2ReceiveCompleteEvent(), m_hShutdownEvent);

#ifdef DEBUG
				m_pThreadPool->DebugPrintOutstandingReads();
				m_pThreadPool->DebugPrintOutstandingWrites();
#endif // DEBUG

				//
				// Ignore error.
				//
				SetEvent(m_pThreadPool->GetWinsock2ReceiveCompleteEvent());
				break;
			}
#else // ! WIN95
#ifdef DEBUG
			case WAIT_TIMEOUT:
			{
				//
				// Print a warning to the log about why we're still sitting here.
				//

				DPFX(DPFPREP, 2, "(0x%p) Still waiting for shutdown event 0x%p.",
					this, m_hShutdownEvent);
				m_pThreadPool->DebugPrintOutstandingReads();
				m_pThreadPool->DebugPrintOutstandingWrites();
				break;
			}
#endif // DEBUG
#endif // ! WIN95

			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	if ( CloseHandle( m_hShutdownEvent ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to close shutdown event!" );
		DisplayErrorCode( 0, dwError );
	}
	m_hShutdownEvent = NULL;

	if ( DP8SPCallbackInterface() != NULL)
	{
		IDP8SPCallback_Release( DP8SPCallbackInterface() );
		memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	}

	
	DPFX(DPFPREP, 2, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::Deinitialize - deinitialize
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Note:	This function assumes that someone else is preventing reentry.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::Deinitialize"

void	CSPData::Deinitialize( void )
{
	DPFX(DPFPREP, 6, "(0x%p) Enter", this );


	if ( m_Flags.fDefaultAddressesBuilt != FALSE )
	{
		FreeDefaultAddresses();
		m_Flags.fDefaultAddressesBuilt = FALSE;
	}

	//
	// release our reference to the global SP objects
	//
	if ( m_Flags.fInterfaceGlobalsInitialized != FALSE )
	{
		DeinitializeInterfaceGlobals( this );
		DNASSERT( GetThreadPool() != NULL );
		m_Flags.fInterfaceGlobalsInitialized = FALSE;
	}

	//
	// clean up lists and pools
	//
	if ( m_Flags.fSocketPortListInitialized != FALSE )
	{
		if ( m_ActiveSocketPortList.IsEmpty() == FALSE )
		{
			CSocketPort				*pSocketPort;

			DPFX(DPFPREP, 1, "Attempt to close interface with active connections!" );

			//
			// All of the threads have stopped so we could force close the socket ports
			// by cancelling all IO requests and unbinding all endpoints.
			// However, all of the endpoints should be gone by now.
			//
			DNASSERT(! m_ActiveSocketPortList.RemoveLastEntry(&pSocketPort));
		}
		
		m_ActiveSocketPortList.Deinitialize();
		m_Flags.fSocketPortListInitialized = FALSE;
	}
		

	if ( m_Flags.fSocketPortDataLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_SocketPortDataLock );
		m_Flags.fSocketPortDataLockInitialized = FALSE;
	}

	if ( m_Flags.fLockInitialized != FALSE )
	{
		DNDeleteCriticalSection( &m_Lock );
		m_Flags.fLockInitialized = FALSE;
	}

	if ( m_Flags.fHandleTableInitialized != FALSE )
	{
		m_HandleTable.Deinitialize();
		m_Flags.fHandleTableInitialized = FALSE;
	}

	SetState( SPSTATE_UNINITIALIZED );
	m_SPType = TYPE_UNKNOWN;
	memset( &m_ClassID, 0x00, sizeof( m_ClassID ) );
	memset( &m_InitData, 0x00, sizeof( m_InitData ) );
	memset( &m_COMInterface, 0x00, sizeof( m_COMInterface ) );
	
	DPFX(DPFPREP, 6, "(0x%p) Leave", this );

	if ( GetThreadPool() != NULL )
	{
		GetThreadPool()->DecRef();
		SetThreadPool( NULL );
	}

	if ( m_hShutdownEvent != NULL )
	{
		if ( CloseHandle( m_hShutdownEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Failed to close shutdown handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hShutdownEvent = NULL;
	}

	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::SetCallbackData - set data for SP callbacks to application
//
// Entry:		Pointer to initialization data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::SetCallbackData"

void	CSPData::SetCallbackData( const SPINITIALIZEDATA *const pInitData )
{
	DNASSERT( pInitData != NULL );

	DNASSERT( pInitData->dwFlags == 0 );
	m_InitData.dwFlags = pInitData->dwFlags;

	DNASSERT( pInitData->pIDP != NULL );
	m_InitData.pIDP = pInitData->pIDP;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::BindEndpoint - bind an endpoint to a socket port
//
// Entry:		Pointer to endpoint
//				Pointer to IDirectPlay8Address for socket port
//				Pointer to CSocketAddress for socket port
//				Gateway bind type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::BindEndpoint"

HRESULT	CSPData::BindEndpoint( CEndpoint *const pEndpoint,
							   IDirectPlay8Address *const pDeviceAddress,
							   const CSocketAddress *const pSocketAddress,
							   const GATEWAY_BIND_TYPE GatewayBindType )
{
	HRESULT				hr;
	CSocketAddress *	pDeviceSocketAddress;
	CSocketPort *		pSocketPort;
	BOOL				fSocketCreated;
	BOOL				fSocketPortDataLocked;
	BOOL				fSocketPortInActiveList;
	BOOL				fBindReferenceAdded;
	CBilink *			pAdapterBilink;
	CAdapterEntry *		pAdapterEntry;
	GATEWAY_BIND_TYPE	NewGatewayBindType;


	DNASSERT( pEndpoint != NULL );
	DNASSERT( ( pDeviceAddress != NULL ) || ( pSocketAddress != NULL ) );

	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, %i)",
		this, pEndpoint, pDeviceAddress, pSocketAddress, GatewayBindType);

	//
	// initialize
	//
	hr = DPN_OK;
	pDeviceSocketAddress = NULL;	
	pSocketPort = NULL;
	fSocketCreated = FALSE;
	fSocketPortDataLocked = FALSE;
	fSocketPortInActiveList = FALSE;
	fBindReferenceAdded = FALSE;
	pAdapterEntry = NULL;
	
	//
	// create and initialize a device address to be used for this socket port
	//
	pDeviceSocketAddress = GetNewAddress();
	if ( pDeviceSocketAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to allocate address for new socket port!" );
		goto Failure;
	}

	//
	// Initialize the socket address with the provided base addresses.
	//
	if ( pDeviceAddress != NULL )
	{
		DNASSERT( pSocketAddress == NULL );
		hr = pDeviceSocketAddress->SocketAddressFromDP8Address( pDeviceAddress, SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Failed to parse device address!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
	else
	{
		DNASSERT( pSocketAddress != NULL );
		pDeviceSocketAddress->CopyAddressSettings( pSocketAddress );
	}


	//
	// Munge the public address into a local alias, if there is one for the given device.
	// It's OK for the device socket address to not have a port yet.
	//
	switch ( pEndpoint->GetType() )
	{
		case ENDPOINT_TYPE_CONNECT:
		{
			this->MungePublicAddress( pDeviceSocketAddress, pEndpoint->GetWritableRemoteAddressPointer(), FALSE );
			break;
		}
		
		case ENDPOINT_TYPE_ENUM:
		{
			this->MungePublicAddress( pDeviceSocketAddress, pEndpoint->GetWritableRemoteAddressPointer(), TRUE );
			break;
		}
	
		default:
		{
			break;
		}
	}


	LockSocketPortData();
	fSocketPortDataLocked = TRUE;	

	//
	// Find the base adapter entry for this network address.  If none is found,
	// create a new one.  If a new one cannot be created, fail.
	//
	pAdapterBilink = m_blActiveAdapterList.GetNext();
	while ( pAdapterBilink != &m_blActiveAdapterList )
	{
		CAdapterEntry	*pTempAdapterEntry;
	
		
		pTempAdapterEntry = CAdapterEntry::AdapterEntryFromAdapterLinkage( pAdapterBilink );
		if ( pDeviceSocketAddress->CompareToBaseAddress( pTempAdapterEntry->BaseAddress() ) == 0 )
		{
			DPFX(DPFPREP, 5, "Found adapter for network address (0x%p).", pTempAdapterEntry );
			DNASSERT( pAdapterEntry == NULL );
			pTempAdapterEntry->AddRef();
			pAdapterEntry = pTempAdapterEntry;
		}
	
		pAdapterBilink = pAdapterBilink->GetNext();
	}

	if ( pAdapterEntry == NULL )
	{
		pAdapterEntry = CreateAdapterEntry();
		if ( pAdapterEntry == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP, 0, "Failed to create a new adapter entry!" );
			goto Failure;
		}
	
		pAdapterEntry->SetBaseAddress( pDeviceSocketAddress->GetAddress() );
		pAdapterEntry->AddToAdapterList( &m_blActiveAdapterList );
	}

	//
	// At this point we have a reference to an adapter entry that's also in
	// m_ActiveAdapterList (which has a reference, too).
	//


	//
	// If the device gave a specific port, it's possible that the address has
	// our special "it's not actually a specific port" key (see
	// CSocketPort::GetDP8BoundNetworkAddress).
	//
	if ( ( pDeviceAddress != NULL ) &&
		( pDeviceSocketAddress->GetPort() != ANY_PORT ) )
	{
		DWORD		dwSocketPortID;
		DWORD		dwComponentSize;
		DWORD		dwComponentType;
		

		
		dwComponentSize = sizeof(dwSocketPortID);
		dwComponentType = 0;
		hr = IDirectPlay8Address_GetComponentByName( pDeviceAddress,						// interface
														DPNA_PRIVATEKEY_PORT_NOT_SPECIFIC,	// tag
														&dwSocketPortID,						// component buffer
														&dwComponentSize,					// component size
														&dwComponentType					// component type
														);
		if ( hr == DPN_OK )
		{
			//
 			// We found the component.  Make sure it's the right size and type.
			//
			if (( dwComponentSize == sizeof(dwSocketPortID) ) && ( dwComponentType == DPNA_DATATYPE_DWORD ))
			{
				DPFX(DPFPREP, 3, "Found correctly formed private port-not-specific key (socketport ID = %u), ignoring port %u.",
					dwSocketPortID, p_ntohs(pDeviceSocketAddress->GetPort()) );
				
				pDeviceSocketAddress->SetPort( ANY_PORT ) ;
			}
			else
			{
				//
				// We are the only ones who should know about this key, so if it
				// got there without being formed correctly, either someone is
				// trying to imitate our address format, or it got corrupted.
				// We'll just ignore it.
				//
				DPFX(DPFPREP, 0, "Private port-not-specific key exists, but doesn't match expected type (%u != %u) or size (%u != %u), is someone trying to get cute with device address 0x%p?!",
					dwComponentSize, sizeof(dwSocketPortID),
					dwComponentType, DPNA_DATATYPE_DWORD,
					pDeviceAddress );
			}
		}
		else
		{
			//
			// The key is not there, it's the wrong size (too big for our buffer
			// and returned BUFFERTOOSMALL), or something else bad happened.
			// It doesn't matter.  Carry on.
			//
			DPFX(DPFPREP, 8, "Could not get appropriate private port-not-specific key, error = 0x%lx, component size = %u, type = %u, continuing.",
				hr, dwComponentSize, dwComponentType);
		}
	}

	
	//
	// if a specific port is not needed, check the list of active adapters for a matching
	// base address and reuse that CSocketPort.
	//
	if ( pDeviceSocketAddress->GetPort() == ANY_PORT )
	{
		DPFX(DPFPREP, 8, "Device socket address 0x%p not mapped to a specific port, gateway bind type = %u.",
			pDeviceSocketAddress, GatewayBindType);


		//
		// Convert the preliminary bind type to a real one, based on the fact that
		// the caller allowed any port.
		//
		switch (GatewayBindType)
		{
			case GATEWAY_BIND_TYPE_UNKNOWN:
			{
				//
				// Caller didn't know ahead of time how to bind.
				// Since there's no port, we can let the gateway bind whatever it wants.
				//
				NewGatewayBindType = GATEWAY_BIND_TYPE_DEFAULT;
				break;
			}
			
			case GATEWAY_BIND_TYPE_NONE:
			{
				//
				// Caller didn't actually want to bind on gateway.
				//
				
				NewGatewayBindType = GatewayBindType;
				break;
			}
			
			default:
			{
				//
				// Some wacky value, or a type was somehow already chosen.
				//
				DNASSERT(FALSE);
				NewGatewayBindType = GatewayBindType;
				break;
			}
		}


		if ( pAdapterEntry->SocketPortList()->IsEmpty() == FALSE )
		{
			pSocketPort = CSocketPort::SocketPortFromBilink( pAdapterEntry->SocketPortList()->GetNext() );
			DNASSERT( pSocketPort != NULL );

			DPFX(DPFPREP, 6, "Picked socket port 0x%p for binding.",
				pSocketPort);
		}
	}
	else
	{
		DPFX(DPFPREP, 8, "Device socket address 0x%p specified port %u, gateway bind type = %u.",
			pDeviceSocketAddress, p_ntohs(pDeviceSocketAddress->GetPort()),
			GatewayBindType);


		//
		// Convert the preliminary bind type to a real one, based on the fact that
		// the caller gave us a port.
		//
		switch (GatewayBindType)
		{
			case GATEWAY_BIND_TYPE_UNKNOWN:
			{
				//
				// Caller didn't know ahead of time how to bind.
				// Since there's a port, it should be fixed on the gateway, too.
				//
				NewGatewayBindType = GATEWAY_BIND_TYPE_SPECIFIC;
				break;
			}
			
			case GATEWAY_BIND_TYPE_SPECIFIC_SHARED:
			{
				//
				// Caller wanted to bind to a specific port on the gateway,
				// and it needs to be shared (DPNSVR).
				//
				
				NewGatewayBindType = GatewayBindType;
				break;
			}
			
			case GATEWAY_BIND_TYPE_NONE:
			{
				//
				// Caller didn't actually want to bind on gateway.
				//
				
				NewGatewayBindType = GatewayBindType;
				break;
			}
			
			default:
			{
				//
				// Some wacky value, or default/specific was somehow already chosen.
				// That shouldn't happen.
				//
				DNASSERT(FALSE);
				NewGatewayBindType = GatewayBindType;
				break;
			}
		}
	}

	//
	// If a socket port has not been found, attempt to look it up by network
	// address.  If that fails, attempt to create a new socket port.
	//
	if ( pSocketPort == NULL )
	{
		if ( m_ActiveSocketPortList.Find( pDeviceSocketAddress, &pSocketPort ) == FALSE )
		{
			CSocketPort	*pDuplicateSocket;


			//
			// No socket port found.  Create a new one, initialize it and attempt
			// to add it to the list (may result in a duplicate).  Whatever happens
			// there will be a socket port to bind the endpoint to.  Save the
			// reference on the CSocketPort from the call to 'Create' until the
            // socket port is removed from the active list.
			//

			UnlockSocketPortData();
			fSocketPortDataLocked = FALSE;

            pDuplicateSocket = NULL;

    	    DNASSERT( pSocketPort == NULL );
    	    pSocketPort = CreateSocketPort();
    	    if ( pSocketPort == NULL )
    	    {
    	    	hr = DPNERR_OUTOFMEMORY;
    	    	DPFX(DPFPREP, 0, "Failed to create new socket port!" );
    	    	goto Failure;
    	    }
    	    fSocketCreated = TRUE;

  
			DPFX(DPFPREP, 6, "Created new socket port 0x%p.", pSocketPort);


			hr = pSocketPort->Initialize( this, pDeviceSocketAddress );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Failed to initialize new socket port!" );
				DisplayDNError( 0, hr );
    	    	goto Failure;
			}
			pDeviceSocketAddress = NULL;

			pAdapterEntry->AddRef();
			pSocketPort->SetAdapterEntry( pAdapterEntry );
    	
#ifdef WINNT
			hr = pSocketPort->BindToNetwork( GetThreadPool()->GetIOCompletionPort(), NewGatewayBindType );
#else // WIN95
			hr = pSocketPort->BindToNetwork( NULL, NewGatewayBindType );
#endif
			if ( hr != DPN_OK )
    	    {
				pSocketPort->SetAdapterEntry( NULL );
				pAdapterEntry->DecRef();

    	    	DPFX(DPFPREP, 0, "Failed to bind new socket port to network!" );
    	    	DisplayDNError( 0, hr );
    	    	goto Failure;
    	    }

    	    LockSocketPortData();
			fSocketPortDataLocked = TRUE;
			
			//
			// The only way to get here is to have the socket bound to the
			// network.  The socket can't be bound twice, if there was a
			// race to bind the socket, Winsock would have decided which
			// thread lost and failed 'BindToNetwork'.
			//
			DNASSERT( m_ActiveSocketPortList.Find( pSocketPort->GetNetworkAddress(), &pDuplicateSocket ) == FALSE );
   	    	if ( m_ActiveSocketPortList.Insert( pSocketPort->GetNetworkAddress(), pSocketPort ) == FALSE )
			{
				hr = DPNERR_OUTOFMEMORY;
				DPFX(DPFPREP, 0, "Could not add new socket port to list!" );
				goto Failure;
			}

			pSocketPort->AddToActiveList( pAdapterEntry->SocketPortList() );
			fSocketPortInActiveList = TRUE;
		}
		else
		{
			DPFX(DPFPREP, 6, "Found matching socket port 0x%p.", pSocketPort);
		}
	}
	
	//
	// bind the endpoint to whatever socketport we have
	//
	DNASSERT( pSocketPort != NULL );
	pSocketPort->EndpointAddRef();
	fBindReferenceAdded = TRUE;
	
	
	hr = pSocketPort->BindEndpoint( pEndpoint, NewGatewayBindType );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to bind endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	
Exit:

	if ( fSocketPortDataLocked != FALSE )
	{
		UnlockSocketPortData();
		fSocketPortDataLocked = FALSE;
	}
	
	if ( pDeviceSocketAddress != NULL )
	{
		ReturnAddress( pDeviceSocketAddress );
		pDeviceSocketAddress = NULL;
	}

	if (pAdapterEntry != NULL)
	{
		pAdapterEntry->DecRef();
		pAdapterEntry = NULL;
	}
	
	DPFX(DPFPREP, 6, "(0x%p) Return [0x%lx]", this, hr);
	
	return	hr;

Failure:
	//
	// If we're failing and cleanup will require removal of some resources.
	// This requires the socket port data lock.
	//
	if ( fSocketPortDataLocked == FALSE )
	{
		LockSocketPortData();
		fSocketPortDataLocked = TRUE;
	}

	if ( pSocketPort != NULL )
	{
		if ( fBindReferenceAdded != FALSE )
		{
			pSocketPort->EndpointDecRef();
			fBindReferenceAdded = FALSE;
		}

		if ( fSocketPortInActiveList != FALSE )
		{
			pSocketPort->RemoveFromActiveList();
			fSocketPortInActiveList = FALSE;
		}
	
		if ( fSocketCreated != FALSE )
		{
			pSocketPort->DecRef();
			fSocketCreated = FALSE;
			pSocketPort = NULL;
		}
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::UnbindEndpoint - unbind an endpoint from a socket port
//
// Entry:		Pointer to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::UnbindEndpoint"

void	CSPData::UnbindEndpoint( CEndpoint *const pEndpoint )
{
	CSocketPort *	pSocketPort;
	BOOL			fCleanUpSocketPortAndAdapterEntry;
	CAdapterEntry *	pAdapterEntry;


	DNASSERT( pEndpoint != NULL );

	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p)", this, pEndpoint);

	//
	// initialize
	//
	pSocketPort = pEndpoint->GetSocketPort();
	DNASSERT( pSocketPort != NULL );
	fCleanUpSocketPortAndAdapterEntry = FALSE;

	LockSocketPortData();
	
	pSocketPort->UnbindEndpoint( pEndpoint );
	if ( pSocketPort->EndpointDecRef() == 0 )
	{
		fCleanUpSocketPortAndAdapterEntry = TRUE;
		
		DNASSERT( pSocketPort->GetNetworkAddress() != NULL );
		m_ActiveSocketPortList.Remove( pSocketPort->GetNetworkAddress() );

		pSocketPort->RemoveFromActiveList();
		
		pAdapterEntry = pSocketPort->GetAdapterEntry();
		DNASSERT( pAdapterEntry != NULL );
		pSocketPort->SetAdapterEntry( NULL );
	}

	UnlockSocketPortData();

	if ( fCleanUpSocketPortAndAdapterEntry != FALSE )
	{
		pSocketPort->DecRef();
		pAdapterEntry->DecRef();
		fCleanUpSocketPortAndAdapterEntry = FALSE;
	}
	
	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::GetNewEndpoint - get a new endpoint
//
// Entry:		Nothing
//
// Exit:		Pointer to new endpoint
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::GetNewEndpoint"

CEndpoint	*CSPData::GetNewEndpoint( void )
{
	HRESULT		hTempResult;
	CEndpoint	*pEndpoint;
	HANDLE		hEndpoint;
	ENDPOINT_POOL_CONTEXT	PoolContext;

	
	//
	// initialize
	//
	pEndpoint = NULL;
	hEndpoint = INVALID_HANDLE_VALUE;
	memset( &PoolContext, 0x00, sizeof( PoolContext ) );

	PoolContext.pSPData = this;

	//
	// NOTE: This doesn't work properly on Windows 95.  From MSDN:
	// "the return value is positive, but it is not necessarily equal to the result."
	// All endpoints will probably get an ID of 1 on that platform.
	//
	PoolContext.dwEndpointID = (DWORD) DNInterlockedIncrement((LONG*) (&g_dwCurrentEndpointID));
	
	switch ( GetType() )
	{
		case TYPE_IP:
		{
			pEndpoint = CreateIPEndpoint( &PoolContext );
			break;
		}

		case TYPE_IPX:
		{
			pEndpoint = CreateIPXEndpoint( &PoolContext );
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	
	if ( pEndpoint == NULL )
	{
		DPFX(DPFPREP, 0, "Failed to create endpoint!" );
		goto Failure;
	}
	
	m_HandleTable.Lock();
	hTempResult = m_HandleTable.CreateHandle( &hEndpoint, pEndpoint );
	m_HandleTable.Unlock();
	
	if ( hTempResult != DPN_OK )
	{
		DNASSERT( hEndpoint == INVALID_HANDLE_VALUE );
		DPFX(DPFPREP, 0, "Failed to create endpoint handle!" );
		DisplayDNError( 0, hTempResult );
		goto Failure;
	}

	pEndpoint->SetHandle( hEndpoint );
	pEndpoint->AddCommandRef();
	pEndpoint->DecRef();

Exit:
	return	pEndpoint;

Failure:
	if ( hEndpoint != INVALID_HANDLE_VALUE )
	{
		m_HandleTable.Lock();
		m_HandleTable.InvalidateHandle( hEndpoint );
		m_HandleTable.Unlock();
	
		hEndpoint = INVALID_HANDLE_VALUE;
	}

	if ( pEndpoint != NULL )
	{
		pEndpoint->DecRef();
		pEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::EndpointFromHandle - get endpoint from handle
//
// Entry:		Handle
//
// Exit:		Pointer to endpoint
//				NULL = invalid handle
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::EndpointFromHandle"

CEndpoint	*CSPData::EndpointFromHandle( const HANDLE hEndpoint )
{
	CEndpoint	*pEndpoint;


	pEndpoint = NULL;
	m_HandleTable.Lock();
	
	pEndpoint = static_cast<CEndpoint*>( m_HandleTable.GetAssociatedData( hEndpoint ) );
	if ( pEndpoint != NULL )
	{
		pEndpoint->AddCommandRef();
	}
	
	m_HandleTable.Unlock();

	return	pEndpoint;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::CloseEndpointHandle - close endpoint handle
//
// Entry:		Poiner to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::CloseEndpointHandle"

void	CSPData::CloseEndpointHandle( CEndpoint *const pEndpoint )
{
	HANDLE	Handle;
	BOOL	fCloseReturn;


	DNASSERT( pEndpoint != NULL );
	Handle = pEndpoint->GetHandle();
	
	m_HandleTable.Lock();
	fCloseReturn = m_HandleTable.InvalidateHandle( Handle );
	m_HandleTable.Unlock();

	if ( fCloseReturn != FALSE )
	{
		pEndpoint->DecCommandRef();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::GetEndpointAndCloseHandle - get endpoint from handle and close the
//		handle
//
// Entry:		Handle
//
// Exit:		Pointer to endpoint (it needs a call to 'DecCommandRef' when done)
//				NULL = invalid handle
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::GetEndpointAndCloseHandle"

CEndpoint	*CSPData::GetEndpointAndCloseHandle( const HANDLE hEndpoint )
{
	CEndpoint	*pEndpoint;
	BOOL	fCloseReturn;


	//
	// initialize
	//
	pEndpoint = NULL;
	fCloseReturn = FALSE;
	m_HandleTable.Lock();
	
	pEndpoint = static_cast<CEndpoint*>( m_HandleTable.GetAssociatedData( hEndpoint ) );
	if ( pEndpoint != NULL )
	{
		pEndpoint->AddRef();
		pEndpoint->AddCommandRef();
		fCloseReturn = m_HandleTable.InvalidateHandle( hEndpoint );
		DNASSERT( fCloseReturn != FALSE );
	}
	
	m_HandleTable.Unlock();

	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
	}
	
	return	pEndpoint;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::MungePublicAddress - get a public socket address' local alias, if any
//
// Entry:		Pointer to device address
//				Pointer to public address to munge
//				Whether it's an enum or not
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::MungePublicAddress"

void	CSPData::MungePublicAddress( const CSocketAddress * const pDeviceBaseAddress, CSocketAddress * const pPublicAddress, const BOOL fEnum )
{
	HRESULT		hr = DPNHERR_NOMAPPING;
	SOCKADDR	SocketAddress;
	DWORD		dwTemp;


	DNASSERT( pDeviceBaseAddress != NULL );
	DNASSERT( pPublicAddress != NULL );
	DNASSERT( this->m_pThreadPool != NULL );
	
	
	if (( this->GetType() == TYPE_IP ) && ( this->m_pThreadPool->IsNATHelpLoaded() ))
	{
		//
		// Don't bother looking up the broadcast address, that's a waste of
		// time.
		//
		if (((SOCKADDR_IN*) pPublicAddress->GetAddress())->sin_addr.S_un.S_addr == INADDR_BROADCAST)

		{
			//
			// This had better be an enum, you can't connect to the broadcast
			// address.
			//
			DNASSERT(fEnum);
			DPFX(DPFPREP, 8, "Not attempting to lookup alias for broadcast address." );
		}
		else
		{
			DBG_CASSERT( sizeof( SocketAddress ) == sizeof( *pPublicAddress->GetAddress() ) );


			//
			// Start by copying the 
			//
			for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
			{
				if (g_papNATHelpObjects[dwTemp] != NULL)
				{
		  			//
		  			// IDirectPlayNATHelp::GetCaps had better have been called with the
	  				// DPNHGETCAPS_UPDATESERVERSTATUS flag at least once prior to this.
	  				// See CThreadPool::PreventThreadPoolReduction
	  				//
					hr = IDirectPlayNATHelp_QueryAddress( g_papNATHelpObjects[dwTemp],
													pDeviceBaseAddress->GetAddress(),
													pPublicAddress->GetAddress(),
													&SocketAddress,
													sizeof(SocketAddress),
													(DPNHQUERYADDRESS_CACHEFOUND | DPNHQUERYADDRESS_CACHENOTFOUND) );
					if ( hr == DPNH_OK )
					{
						//
						// There is a local alias for the address.
						//

						//
						// Bad news:
						// The PAST protocol can only return one address, but the SHARED
						// UDP LISTENER extension which allows multiple machines to listen
						// on the same fixed port.  Someone querying for the local alias
						// for that address will only get the first person to register the
						// shared port, which may not be the machine desired.
						//
						// Good news:
						// Only DPNSVR uses SHARED UDP LISTENERs, and thus it only happens
						// with enums on DPNSVRs port.  Further, it only affects a person
						// behind the same ICS machine.  So we can workaround this by
						// detecting an enum attempt on the public address and DPNSVR port,
						// and instead of using the single address returned by PAST, use
						// the broadcast address.  Since anyone registered with the ICS
						// server would have to be local, broadcasting should find the same
						// servers (and technically more, but that shouldn't matter).
						//
						// So:
						// If the address has a local alias, and it's the DPNSVR port
						// (which is the only one that can be shared), and its an enum,
						// broadcast instead.
						//
 						if ((fEnum) && (((SOCKADDR_IN*) pPublicAddress->GetAddress())->sin_port == p_ntohs(DPNA_DPNSVR_PORT)))
						{
							((SOCKADDR_IN*) pPublicAddress->GetAddress())->sin_addr.S_un.S_addr = INADDR_BROADCAST;

							DPFX(DPFPREP, 7, "Address for enum has local alias (via object %u), but is on DPNSVR's shared fixed port, substituting broadcast address instead:",
								dwTemp );
							DumpSocketAddress( 7, pPublicAddress->GetAddress(), pPublicAddress->GetFamily() );
						}
						else
						{
							pPublicAddress->SetAddressFromSOCKADDR( SocketAddress, sizeof( SocketAddress ) );
							DPFX(DPFPREP, 7, "Object %u had mapping, modified address is now:", dwTemp );
							DumpSocketAddress( 7, pPublicAddress->GetAddress(), pPublicAddress->GetFamily() );
						}

						//
						// Stop searching.
						//
						break;
					}


					DPFX(DPFPREP, 8, "Address was not modified by object %u (err = 0x%lx).",
						dwTemp, hr );
				}
				else
				{
					//
					// No DPNATHelp object in this slot.
					//
				}
			} // end for (each DPNATHelp object)


			//
			// If no object touched it, remember that.
			//
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 7, "Address was not modified by any objects:" );
				DumpSocketAddress( 7, pPublicAddress->GetAddress(), pPublicAddress->GetFamily() );
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 7, "NAT Help not loaded or not necessary, not modifying address." );
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::SetBufferSizeOnAllSockets - set buffer size on all sockets
//
// Entry:		New buffer size
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::SetWinsockBufferSizeOnAllSockets"
void	CSPData::SetWinsockBufferSizeOnAllSockets( const INT iBufferSize )
{
	CBilink		*pAdapterEntryLink;

	
	LockSocketPortData();
	
	pAdapterEntryLink = m_blActiveAdapterList.GetNext();
	while ( pAdapterEntryLink != &m_blActiveAdapterList )
	{
		CAdapterEntry	*pAdapterEntry;
		CBilink			*pSocketPortList;


		pAdapterEntry = CAdapterEntry::AdapterEntryFromAdapterLinkage( pAdapterEntryLink );
		pSocketPortList = pAdapterEntry->SocketPortList()->GetNext();
		while ( pSocketPortList != pAdapterEntry->SocketPortList() )
		{
			CSocketPort	*pSocketPort;


			pSocketPort = CSocketPort::SocketPortFromBilink( pSocketPortList );
			pSocketPort->SetWinsockBufferSize( iBufferSize );

			pSocketPortList = pSocketPortList->GetNext();
		}

		pAdapterEntryLink = pAdapterEntryLink->GetNext();
	}
	
	UnlockSocketPortData();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::IncreaseOutstandingReceivesOnAllSockets - increase the number of outstanding receives
//
// Entry:		Delta to increase outstanding receives by
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::IncreaseOutstandingReceivesOnAllSockets"

void	CSPData::IncreaseOutstandingReceivesOnAllSockets( const DWORD dwDelta )
{
	CBilink		*pAdapterEntryLink;
	LONG		lIOThreadCount;

	
	LockSocketPortData();
	
	if ( m_pThreadPool->GetIOThreadCount( &lIOThreadCount ) != DPN_OK )
	{
		DNASSERT( FALSE );
	}
	
	pAdapterEntryLink = m_blActiveAdapterList.GetNext();
	while ( pAdapterEntryLink != &m_blActiveAdapterList )
	{
		CAdapterEntry	*pAdapterEntry;
		CBilink			*pSocketPortList;


		pAdapterEntry = CAdapterEntry::AdapterEntryFromAdapterLinkage( pAdapterEntryLink );
		pSocketPortList = pAdapterEntry->SocketPortList()->GetNext();
		while ( pSocketPortList != pAdapterEntry->SocketPortList() )
		{
			CSocketPort	*pSocketPort;


			pSocketPort = CSocketPort::SocketPortFromBilink( pSocketPortList );
			pSocketPort->IncreaseOutstandingReceives( dwDelta * lIOThreadCount );

			pSocketPortList = pSocketPortList->GetNext();
		}

		pAdapterEntryLink = pAdapterEntryLink->GetNext();
	}
	
	UnlockSocketPortData();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::CancelPostponedCommands - closes any endpoints whose connect/enum
//									commands haven't already completed or are
//									not in the process of completing
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::CancelPostponedCommands"

void	CSPData::CancelPostponedCommands( void )
{
	CBilink				blEnumsToComplete;
	CBilink				blConnectsToComplete;
	CBilink *			pBilink;
	CCommandData *		pCommand;
	CEndpoint *			pEndpoint;


	blEnumsToComplete.Initialize();
	blConnectsToComplete.Initialize();
	
	this->LockSocketPortData();
	
	pBilink = m_blPostponedEnums.GetNext();
	while ( pBilink != &m_blPostponedEnums )
	{
		pCommand = CCommandData::CommandFromPostponedListBilink( pBilink );
		pBilink = pBilink->GetNext();

		pEndpoint = pCommand->GetEndpoint();
		DNASSERT(pEndpoint != NULL);


		pCommand->Lock();

		if ((pCommand->GetState() == COMMAND_STATE_INPROGRESS) ||
			(pCommand->GetState() == COMMAND_STATE_CANCELLING))
		{
			DPFX(DPFPREP, 6, "Enum 0x%p (state %i, endpoint 0x%p) needs to be cancelled.",
				pCommand, pCommand->GetState(), pEndpoint);
			
			//
			// Mark the command as cancelling just in case someone tries to cancel
			// it now.
			//
			pCommand->SetState(COMMAND_STATE_CANCELLING);
			
			//
			// Pull the endpoint from the multiplex list so no other associated enum
			// command will find it.
			//
			pEndpoint->RemoveFromMultiplexList();

			//
			// Pull the command from the postponed list.
			//
			pCommand->RemoveFromPostponedList();

			
			//
			// Put it on the list of items we need to complete.
			//
			pCommand->AddToPostponedList(&blEnumsToComplete);
		}
		else
		{
			//
			// If it's on the list but not marked as in-progress or cancelling, then
			// someone else should be indicating the completion.
			//
			DPFX(DPFPREP, 1, "Enum 0x%p (endpoint 0x%p) is in progress and will complete later.",
				pCommand, pEndpoint);
			DNASSERT(pCommand->GetState() == COMMAND_STATE_INPROGRESS_CANNOT_CANCEL);
		}
		
		pCommand->Unlock();
	}
	
	pBilink = m_blPostponedConnects.GetNext();
	while ( pBilink != &m_blPostponedConnects )
	{
		pCommand = CCommandData::CommandFromPostponedListBilink( pBilink );
		pBilink = pBilink->GetNext();

		pEndpoint = pCommand->GetEndpoint();
		DNASSERT(pEndpoint != NULL);


		pCommand->Lock();

		if ((pCommand->GetState() == COMMAND_STATE_INPROGRESS) ||
			(pCommand->GetState() == COMMAND_STATE_CANCELLING))
		{
			DPFX(DPFPREP, 6, "Connect 0x%p (state %i, endpoint 0x%p) needs to be cancelled.",
				pCommand, pCommand->GetState(), pEndpoint);
			
			//
			// Mark the command as cancelling just in case someone tries to cancel
			// it now.
			//
			pCommand->SetState(COMMAND_STATE_CANCELLING);
			
			//
			// Pull the endpoint from the multiplex list so no other associated connect
			// command will find it.
			//
			pEndpoint->RemoveFromMultiplexList();

			//
			// Pull the command from the postponed list.
			//
			pCommand->RemoveFromPostponedList();

			
			//
			// Put it on the list of items we need to complete.
			//
			pCommand->AddToPostponedList(&blConnectsToComplete);
		}
		else
		{
			//
			// If it's on the list but not marked as in-progress or cancelling, then
			// someone else should be indicating the completion.
			//
			DPFX(DPFPREP, 1, "Connect 0x%p (endpoint 0x%p) is in progress and will complete later.",
				pCommand, pEndpoint);
			DNASSERT(pCommand->GetState() == COMMAND_STATE_INPROGRESS_CANNOT_CANCEL);
		}
		
		pCommand->Unlock();
	}


	//
	// Now loop through all the enums we need to complete.
	//
	while ( ! blEnumsToComplete.IsEmpty() )
	{
		pBilink = blEnumsToComplete.GetNext();
		pCommand = CCommandData::CommandFromPostponedListBilink( pBilink );
		pBilink = pBilink->GetNext();

		pEndpoint = pCommand->GetEndpoint();
		DNASSERT(pEndpoint != NULL);


		//
		// Pull the command from the completion list.
		//
		pCommand->RemoveFromPostponedList();


		//
		// Drop the socket port lock.  It's safe since we pulled everything we
		// need off of the list that needs protection.
		//
		this->UnlockSocketPortData();


		//
		// Cancel it.
		//

		DPFX(DPFPREP, 1, "Stopping endpoint 0x%p enum command 0x%p with USERCANCEL.",
			pEndpoint, pCommand);

		pEndpoint->StopEnumCommand( DPNERR_USERCANCEL );


		//
		// Retake the socket port lock and go to next item.
		//
		this->LockSocketPortData();
	}


	//
	// Now loop through all the connects we need to complete.
	//
	while ( ! blConnectsToComplete.IsEmpty() )
	{
		pBilink = blConnectsToComplete.GetNext();
		pCommand = CCommandData::CommandFromPostponedListBilink( pBilink );
		pBilink = pBilink->GetNext();

		pEndpoint = pCommand->GetEndpoint();
		DNASSERT(pEndpoint != NULL);


		//
		// Pull the command from the completion list.
		//
		pCommand->RemoveFromPostponedList();


		//
		// Drop the socket port lock.  It's safe since we pulled everything we
		// need off of the list that needs protection.
		//
		this->UnlockSocketPortData();


		//
		// Complete it (by closing this endpoint).
		//

		DPFX(DPFPREP, 1, "Closing endpoint 0x%p (connect command 0x%p) with USERCANCEL.",
			pEndpoint, pCommand);
			
		pEndpoint->Close( DPNERR_USERCANCEL );
		this->CloseEndpointHandle( pEndpoint );


		//
		// Retake the socket port lock and go to next item.
		//
		this->LockSocketPortData();
	}
	
	this->UnlockSocketPortData();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::BuildDefaultAddresses - construct default addresses
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Notes:	This function is initializing with default values that should always
//			work.  If this function asserts, fix it!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::BuildDefaultAddresses"

HRESULT	CSPData::BuildDefaultAddresses( void )
{
	HRESULT			hr;
	CSocketAddress	*pSPAddress;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// create appropriate address
	//
	pSPAddress = GetNewAddress();
	if ( pSPAddress == NULL )
	{
		DPFX(DPFPREP, 0, "Failed to get address when building default addresses!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// query for broadcast address
	//
	DNASSERT( m_pBroadcastAddress == NULL );
	m_pBroadcastAddress = pSPAddress->CreateBroadcastAddress();
	if ( m_pBroadcastAddress == NULL )
	{
		DPFX(DPFPREP, 0, "Failed to create template for broadcast address." );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// query for listen address
	//
	DNASSERT( m_pListenAddress == NULL );
	m_pListenAddress = pSPAddress->CreateListenAddress();
	if ( m_pListenAddress == NULL )
	{
		DPFX(DPFPREP, 0, "Failed to create template for listen address." );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// query for generic address
	//
	DNASSERT( m_pGenericAddress == NULL );
	m_pGenericAddress = pSPAddress->CreateGenericAddress();
	if ( m_pGenericAddress == NULL )
	{
		DPFX(DPFPREP, 0, "Failed to create template for generic address." );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

Exit:
	if ( pSPAddress != NULL )
	{
		ReturnAddress( pSPAddress );
		pSPAddress = NULL;
	}

	return	hr;

Failure:
	if ( m_pGenericAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pGenericAddress );
		m_pGenericAddress = NULL;
	}

	if ( m_pListenAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pListenAddress );
		m_pListenAddress = NULL;
	}

	if ( m_pBroadcastAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pBroadcastAddress );
		m_pBroadcastAddress = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::FreeDefaultAddresses - free default addresses
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::FreeDefaultAddresses"

void	CSPData::FreeDefaultAddresses( void )
{
	if ( m_pBroadcastAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pBroadcastAddress );
		m_pBroadcastAddress = NULL;
	}

	if ( m_pListenAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pListenAddress );
		m_pListenAddress = NULL;
	}

	if ( m_pGenericAddress != NULL )
	{
		IDirectPlay8Address_Release( m_pGenericAddress );
		m_pGenericAddress = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::DestroyThisObject - destroy this object
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::DestroyThisObject"
void	CSPData::DestroyThisObject( void )
{
	if ( m_Flags.fWinsockLoaded != FALSE )
	{
		UnloadWinsock();
		m_Flags.fWinsockLoaded = FALSE;
	}
	
	Deinitialize();
	delete	this;		// maybe a little too extreme......
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::GetNewAddress - get a new address
//
// Entry:		Nothing
//
// Exit:		Pointer to new address
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::GetNewAddress"

CSocketAddress	*CSPData::GetNewAddress( void )
{
	CSocketAddress	*pReturn;


	pReturn = NULL;

	switch ( GetType() )
	{
		case TYPE_IP:
		{
			pReturn = CreateIPAddress();
			break;
		}

		case TYPE_IPX:
		{
			pReturn = CreateIPXAddress();
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::ReturnAddress - return address to list
//
// Entry:		Poiner to address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::ReturnAddress"

void	CSPData::ReturnAddress( CSocketAddress *const pAddress )
{
	DNASSERT( pAddress != NULL );

	pAddress->Reset();

	switch ( GetType() )
	{
		case TYPE_IP:
		{
			ReturnIPAddress( static_cast<CIPAddress*>( pAddress ) );
			break;
		}

		case TYPE_IPX:
		{
			ReturnIPXAddress( static_cast<CIPXAddress*>( pAddress ) );
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\spaddress.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPAddress.h
 *  Content:	Winsock address base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/1999	jtk		Created
 *	05/11/1999	jtk		Split out to make a base class
 *  01/10/2000	rmt		Updated to build with Millenium build process
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __SP_ADDRESS_H__
#define __SP_ADDRESS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated values for noting which components have been initialized
//
typedef enum
{
	SPADDRESS_PARSE_KEY_DEVICE = 0,
	SPADDRESS_PARSE_KEY_HOSTNAME,
	SPADDRESS_PARSE_KEY_PORT,

	// this must be the last item
	SPADDRESS_PARSE_KEY_MAX
} SPADDRESS_PARSE_KEY_INDEX;

//
// these are only for the debug build, but make sure they don't match
// any legal values, anyway
//
#define	INVALID_SOCKET_FAMILY		0
#define	INVALID_SOCKET_PROTOCOL		5000

//
// types of addresses
//
typedef	enum
{
	SP_ADDRESS_TYPE_UNKNOWN = 0,				// unknown
	SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT,		// address is for local device and dynamically bind to a port
	SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET,	// address is for a proxied enum, map IP 'all-adapters' to 'loopback'
	SP_ADDRESS_TYPE_HOST,						// address is for a remote host (default port always used if none specified)
	SP_ADDRESS_TYPE_READ_HOST,					// address is for a remote host address from a socket read
	SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS			// public address for this host
} SP_ADDRESS_TYPE;

//
// initialization states of address components
//
typedef	enum
{
	SP_ADDRESS_COMPONENT_UNINITIALIZED = 0,
	SP_ADDRESS_COMPONENT_INITIALIZATION_FAILED,
	SP_ADDRESS_COMPONENT_INITIALIZED
} SP_ADDRESS_COMPONENT_STATE;

//
// define for any port
//
#define	ANY_PORT	((WORD) 0)

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
		
//
// GUID encryption/decription code.  Note that it's presently an XOR function
// so map the decryption code to the encryption function.
//
void	EncryptGuid( const GUID *const pSourceGuid,
					 GUID *const pDestinationGuid,
					 const GUID *const pEncrpytionKey );

inline void	DecryptGuid( const GUID *const pSourceGuid,
						 GUID *const pDestinationGuid,
						 const GUID *const pEncryptionKey ) { EncryptGuid( pSourceGuid, pDestinationGuid, pEncryptionKey ); }


//**********************************************************************
// Class definition
//**********************************************************************

//
// This class assumes that the size of a SOCKADDR is constant, and equal to
// the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
// This is a virtual base class, you cannot instantiate one of these!
//
class	CSocketAddress
{
	public:
		//
		// We need a virtual destructor to guarantee we call destructors in the bass classes.
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::CSocketAddress"
		CSocketAddress():m_AddressType( SP_ADDRESS_TYPE_UNKNOWN )
		{
			m_Sig[0] = 'S';
			m_Sig[1] = 'P';
			m_Sig[2] = 'A';
			m_Sig[3] = 'D';
	
			//
			// if the following ASSERT breaks down, revisit this class and all of its derived
			// classes to make sure they still work!!!
			//
			DBG_CASSERT( ( sizeof( m_SocketAddress ) == sizeof( m_SocketAddress.SocketAddress ) ) &&
						 ( sizeof( m_SocketAddress.SocketAddress ) == sizeof( m_SocketAddress.IPSocketAddress ) ) &&
						 ( sizeof( m_SocketAddress.IPSocketAddress ) == ( sizeof( m_SocketAddress.IPXSocketAddress ) + 2 ) ) );
			
			memset( &m_ComponentInitializationState, 0x00, sizeof( m_ComponentInitializationState ) );
			memset( &m_SocketAddress, 0x00, sizeof( m_SocketAddress ) );
			m_SocketAddress.SocketAddress.sa_family = INVALID_SOCKET_FAMILY;
		}
		virtual	~CSocketAddress(){};

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::SetAddressType"
		void	SetAddressType( const SP_ADDRESS_TYPE AddressType )
		{
			DNASSERT( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_DEVICE ] == SP_ADDRESS_COMPONENT_UNINITIALIZED );
			m_AddressType = AddressType;

			if ( ( AddressType == SP_ADDRESS_TYPE_READ_HOST ) || ( AddressType == SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS ) )
			{
				DNASSERT( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_HOSTNAME ] == SP_ADDRESS_COMPONENT_UNINITIALIZED );
				m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_HOSTNAME ] = SP_ADDRESS_COMPONENT_INITIALIZED;
				DNASSERT( m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_PORT ] == SP_ADDRESS_COMPONENT_UNINITIALIZED );
				m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_PORT ] = SP_ADDRESS_COMPONENT_INITIALIZED;
			}
		}
		const SOCKADDR *GetAddress( void ) const { return	&m_SocketAddress.SocketAddress; }

		virtual	void	InitializeWithBroadcastAddress( void ) = 0;
		virtual	void	SetAddressFromSOCKADDR( const SOCKADDR &Address, const INT_PTR iAddressSize ) = 0;
		SOCKADDR	*GetWritableAddress( void ) { return &m_SocketAddress.SocketAddress; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetAddressSize"
		const INT	GetAddressSize( void ) const
		{
			DNASSERT( m_iSocketAddressSize != 0 );
			return	m_iSocketAddressSize;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::Reset"
		void	Reset( void )
		{
			//
			// don't clear the family, protocol, or socket address size because they're only
			// set once, in the constructor!!
			//
			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) ||
					  ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
			memset( &m_SocketAddress.SocketAddress.sa_data, 0x00, sizeof( m_SocketAddress.SocketAddress.sa_data ) );
			memset( &m_ComponentInitializationState, 0x00, sizeof( m_ComponentInitializationState ) );
		};

		//
		// address manipulations
		//
		virtual	HRESULT	SocketAddressFromDP8Address( IDirectPlay8Address *const pDP8Address, const SP_ADDRESS_TYPE AddressType ) = 0;
		virtual	IDirectPlay8Address *DP8AddressFromSocketAddress( void ) const = 0;
		virtual	INT_PTR	CompareFunction( const CSocketAddress *const pOtherAddress ) const = 0;
		virtual	INT_PTR	HashFunction( const INT_PTR iHashBitCount ) const = 0;
		virtual INT_PTR	CompareToBaseAddress( const SOCKADDR *const pBaseAddress ) const = 0;

		//
		// adapter enumeration code
		//
		virtual	HRESULT	EnumAdapters( SPENUMADAPTERSDATA *const pEnumData ) const = 0;

		virtual void	GuidFromInternalAddressWithoutPort( GUID &OutputGuid ) const = 0;
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::CopyAddressSettings"
		void	CopyAddressSettings( const CSocketAddress * const pOtherAddress )
		{
			DBG_CASSERT( sizeof( m_SocketAddress ) == sizeof( pOtherAddress->m_SocketAddress ) );

			DNASSERT( GetFamily() == pOtherAddress->GetFamily() );
			memcpy( &m_SocketAddress, &pOtherAddress->m_SocketAddress, sizeof( m_SocketAddress ) );
			m_AddressType = pOtherAddress->m_AddressType;
			m_iSocketAddressSize = pOtherAddress->m_iSocketAddressSize;

			DBG_CASSERT( sizeof( m_ComponentInitializationState ) == sizeof( pOtherAddress->m_ComponentInitializationState ) );
			memcpy( &m_ComponentInitializationState, &pOtherAddress->m_ComponentInitializationState, sizeof( m_ComponentInitializationState ) );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetFamily"
		USHORT	GetFamily( void ) const
		{
			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPSocketAddress.sin_family ) );
			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IN, sin_family ) );
			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );

			DNASSERT( m_SocketAddress.SocketAddress.sa_family != INVALID_SOCKET_FAMILY );
			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ) );
			return	m_SocketAddress.SocketAddress.sa_family;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetProtocol"
		INT	GetProtocol( void ) const
		{
			DNASSERT( m_iSocketProtocol != INVALID_SOCKET_PROTOCOL );
			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
			return	m_iSocketProtocol;
		}

		virtual	BOOL	IsUndefinedHostAddress( void ) const = 0;
		virtual	void	ChangeLoopBackToLocalAddress( const CSocketAddress *const pOtherAddress ) = 0;

		//
		// the following functions work in NETWORK BYTE ORDER!!!
		//
		virtual WORD	GetPort( void ) const = 0;
		virtual void	SetPort( const WORD wPort ) = 0;

		//
		// functions to create default addresses
		//
		virtual IDirectPlay8Address *CreateBroadcastAddress( void ) = 0;
		virtual IDirectPlay8Address *CreateListenAddress( void ) = 0;
		virtual IDirectPlay8Address *CreateGenericAddress( void ) = 0;

	protected:
		BYTE				m_Sig[4];	// debugging signature ('SPAD')
		
		//
		// combine all of the SOCKADDR variants into one item, we assume that
		// they're all the same size (or close in the case of IPX)
		//
		union
		{
			SOCKADDR		SocketAddress;
			SOCKADDR_IN		IPSocketAddress;
			SOCKADDR_IPX	IPXSocketAddress;
		} m_SocketAddress;

		INT				m_iSocketAddressSize;
		INT				m_iSocketProtocol;
		SP_ADDRESS_TYPE	m_AddressType;

		virtual void	AddressFromGuid( const GUID &InputGuid, SOCKADDR &SocketAddress ) const = 0;
		
		virtual void	CopyInternalSocketAddressWithoutPort( SOCKADDR &AddressDestination ) const = 0;

		//
		// Booleans indicating which components have been initialized
		//
		SP_ADDRESS_COMPONENT_STATE	m_ComponentInitializationState[ SPADDRESS_PARSE_KEY_MAX ];
		
	private:
		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CSocketAddress( const CSocketAddress & );
		CSocketAddress& operator=( const CSocketAddress & );
};

#undef DPF_MODNAME

#endif	// __SP_ADDRESS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\spdata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		SPData.h
 *  Content:	Global information for the DNSerial service provider in class
 *				format.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/15/1999	jtk		Derived from Locals.h
 *  03/22/20000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __SPDATA_H__
#define __SPDATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DEFAULT_ADDRESS_BUFFER_SIZE	151

//
// enumeration of the states the SP can be in
//
typedef enum
{
	SPSTATE_UNKNOWN = 0,		// uninitialized state
	SPSTATE_UNINITIALIZED = 0,	// uninitialized state
	SPSTATE_INITIALIZED,		// service provider has been initialized
	SPSTATE_CLOSING				// service provider is closing
} SPSTATE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

// forward structure and class references
class	CCommandData;
class	CEndpoint;
class	CIPEndpoint;
class	CIPAddress;
class	CIPXEndpoint;
class	CIPXAddress;
class	CSocketAddress;
class	CSocketPort;
class	CThreadPool;
class	CWriteIOData;
typedef	enum	_ENDPOINT_TYPE		ENDPOINT_TYPE;
typedef	enum	_GATEWAY_BIND_TYPE	GATEWAY_BIND_TYPE;
typedef	struct	_SPRECEIVEDBUFFER	SPRECEIVEDBUFFER;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;
typedef	void	JOB_FUNCTION( THREAD_POOL_JOB *const pJobInfo );
typedef	void	DNADDRESS, *PDNADDRESS;

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for information used by the provider
//
class	CSPData
{	
	public:
		CSPData();
		~CSPData();
		
		DWORD	AddRef( void ) { return DNInterlockedIncrement( &m_lRefCount ); }
		
		DWORD	DecRef( void )
		{
			DWORD	dwReturn;
			
				
			dwReturn = DNInterlockedDecrement( &m_lRefCount );
			if ( dwReturn == 0 )
			{
				//
				// WARNING, the following function deletes this object!!!
				//
				DestroyThisObject();
			}

			return	dwReturn;
		}

		#undef DPF_MODNAME
		#define	DPF_MODNAME "CSPData::ObjectAddRef"
		void	ObjectAddRef( void )
		{
			AddRef();
			
			Lock();

			//
			// This is actually bogus on 95, since you can only count on
			// negative, 0, or positive.  Doesn't seem to hurt, though.
			//
			if ( DNInterlockedIncrement( &m_lObjectRefCount ) == 1 )
			{
				DPFX(DPFPREP, 8, "(0x%p) Resetting shutdown event.",
					this);
				
				DNASSERT( m_hShutdownEvent != NULL );
				if ( ResetEvent( m_hShutdownEvent ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPFX(DPFPREP, 0, "Failed to reset shutdown event!");
					DisplayErrorCode( 0, dwError );
				}
			}
			else
			{
				DPFX(DPFPREP, 9, "(0x%p) Not resetting shutdown event.",
					this);
			}

			Unlock();
		}

		#undef DPF_MODNAME
		#define	DPF_MODNAME "CSPData::ObjectDecRef"
		void	ObjectDecRef( void )
		{
			Lock();

			if ( DNInterlockedDecrement( &m_lObjectRefCount ) == 0 )
			{
				DPFX(DPFPREP, 8, "(0x%p) Setting shutdown event.",
					this);
				
				if ( SetEvent( m_hShutdownEvent ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPFX(DPFPREP, 0, "Failed to set shutdown event!");
					DisplayErrorCode( 0, dwError );
				}
			}
			else
			{
				DPFX(DPFPREP, 9, "(0x%p) Not setting shutdown event.",
					this);
			}
			
			Unlock();
			
			DecRef();
		}
		

		HRESULT	Initialize( const CLSID *const pClassID,
							const SP_TYPE SPType,
							IDP8ServiceProviderVtbl *const pVtbl );
		void	Shutdown( void );
		void	Deinitialize( void );

		void	SetCallbackData( const SPINITIALIZEDATA *const pInitData );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		SP_TYPE	GetType( void ) const { return m_SPType; }

		const SPSTATE	GetState( void ) const { return m_SPState; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SetState"
		void SetState( const SPSTATE NewState )
		{
			DNASSERT( ( NewState == SPSTATE_UNINITIALIZED ) ||
					  ( NewState == SPSTATE_INITIALIZED ) ||
					  ( NewState == SPSTATE_CLOSING ) );

			m_SPState = NewState;
		}

		CThreadPool	*GetThreadPool( void ) const { return m_pThreadPool; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SetThreadPool"
		void	SetThreadPool( CThreadPool *const pThreadPool )
		{
			DNASSERT( ( m_pThreadPool == NULL ) || ( pThreadPool == NULL ) );
			m_pThreadPool = pThreadPool;
		}


		//
		// functions to manage the socket port list
		//
		void	LockSocketPortData( void ) { DNEnterCriticalSection( &m_SocketPortDataLock ); }
		void	UnlockSocketPortData( void ) { DNLeaveCriticalSection( &m_SocketPortDataLock ); }
		HRESULT	BindEndpoint( CEndpoint *const pEndpoint,
							  IDirectPlay8Address *const pDeviceAddress,
							  const CSocketAddress *const pSocketAddress,
							  const GATEWAY_BIND_TYPE GatewayBindType );
		void	UnbindEndpoint( CEndpoint *const pEndpoint );

		//
		// address pool functions
		//
		CSocketAddress	*GetNewAddress( void );
		void			ReturnAddress( CSocketAddress *const pAddress );

		//
		// endpoint pool management
		//
		CEndpoint	*GetNewEndpoint( void );
		CEndpoint	*EndpointFromHandle( const HANDLE hEndpoint );
		void		CloseEndpointHandle( CEndpoint *const pEndpoint );
		CEndpoint	*GetEndpointAndCloseHandle( const HANDLE hEndpoint );

		void	MungePublicAddress( const CSocketAddress * const pDeviceBaseAddress, CSocketAddress * const pPublicAddress, const BOOL fEnum );


		//
		// generic address functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::GetBroadcastHostAddress"
		IDirectPlay8Address *GetBroadcastHostAddress( void ) const
		{
			DNASSERT( m_pBroadcastAddress != NULL );
			return	m_pBroadcastAddress;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "GetListenDeviceAddress"
		IDirectPlay8Address *GetListenDeviceAddress( void ) const
		{
			DNASSERT( m_pListenAddress != NULL );
			IDirectPlay8Address_AddRef( m_pListenAddress );
			return	m_pListenAddress;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::GetGenericDeviceAddress"
		IDirectPlay8Address	 *GetGenericDeviceAddress( void ) const
		{
			DNASSERT( m_pGenericAddress != NULL );
			IDirectPlay8Address_AddRef( m_pGenericAddress );
			return	m_pGenericAddress;
		}

		const GUID	*GetServiceProviderGuid( void ) const { return &m_ClassID; }


		IDP8SPCallback	*DP8SPCallbackInterface( void ) { return reinterpret_cast<IDP8SPCallback*>( m_InitData.pIDP ); }
		IDP8ServiceProvider	*COMInterface( void ) { return reinterpret_cast<IDP8ServiceProvider*>( &m_COMInterface ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SPDataFromCOMInterface"
		static	CSPData	*SPDataFromCOMInterface( IDP8ServiceProvider *const pCOMInterface )
		{
			CSPData *	pResult;
			
			
			DNASSERT( pCOMInterface != NULL );
			
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pCOMInterface ) );
			DBG_CASSERT( sizeof( CSPData* ) == sizeof( BYTE* ) );

			pResult = reinterpret_cast<CSPData*>( &reinterpret_cast<BYTE*>( pCOMInterface )[ -OFFSETOF( CSPData, m_COMInterface ) ] );

			// Verify signature is 'TDPS' DWORD a.k.a. 'SPDT' in bytes.
			DNASSERT(*((DWORD*) (&pResult->m_Sig)) == 0x54445053);

			return pResult;
		}

		void	SetWinsockBufferSizeOnAllSockets( const INT iBufferSize );
		void	IncreaseOutstandingReceivesOnAllSockets( const DWORD dwDelta );

		CBilink *	GetPostponedEnumsBilink( void ) 	{ return &(this->m_blPostponedEnums); }
		CBilink *	GetPostponedConnectsBilink( void ) 	{ return &(this->m_blPostponedConnects); }
		void	CancelPostponedCommands( void );
		


	private:
		BYTE				m_Sig[4];				// debugging signature ('SPDT')
		DNCRITICAL_SECTION	m_Lock;					// lock
		volatile LONG		m_lRefCount;			// reference count
		volatile LONG		m_lObjectRefCount;		// reference count of outstanding objects (CEndpoint, CSocketPort, etc.)
		HANDLE				m_hShutdownEvent;		// handle for shutdown
		CLSID				m_ClassID;				// ClassID
		SP_TYPE				m_SPType;				// type of SP
		SPSTATE				m_SPState;				// what state is the SP in?
		SPINITIALIZEDATA	m_InitData;				// initialization data

		//
		// job management
		//
		CThreadPool		*m_pThreadPool;

		//
		// List of active adapters.  This encapsulates active device addresses
		// so sockets can be reused when possible
		//
		CBilink				m_blActiveAdapterList;

		//
		// List of all enum query commands that were postponed and are not in the
		// process of being completed.
		//
		CBilink				m_blPostponedEnums;

		//
		// List of all connect commands that were postponed and are not in the
		// process of being completed.
		//
		CBilink				m_blPostponedConnects;
		

		//
		// default addresses
		//
		IDirectPlay8Address	*m_pBroadcastAddress;	// broadcast address for this protocol
		IDirectPlay8Address	*m_pListenAddress;		// listen address for this protocol
		IDirectPlay8Address	*m_pGenericAddress;		// generic address for this protocol (allows protocol
													// to choose address and port)

		CHandleTable			m_HandleTable;			// handle table for endpoints
		DNCRITICAL_SECTION		m_SocketPortDataLock;	// lock for socket port list
		CClassHash< CSocketPort*, const CSocketAddress* >	m_ActiveSocketPortList;	// list of active socket ports

		//
		// initialization state Booleans
		//
		struct
		{
			BOOL	fWinsockLoaded : 1;
			BOOL	fHandleTableInitialized : 1;			
			BOOL	fLockInitialized : 1;
			BOOL	fSocketPortDataLockInitialized : 1;
			BOOL	fSocketPortListInitialized : 1;
			BOOL	fInterfaceGlobalsInitialized : 1;
			BOOL	fDefaultAddressesBuilt : 1;
		} m_Flags;
		

		struct
		{
			IDP8ServiceProviderVtbl	*m_pCOMVtbl;
		} m_COMInterface;

		HRESULT	BuildDefaultAddresses( void );
		void	FreeDefaultAddresses( void );
		void	DestroyThisObject( void );
		
		//
		// prevent unwarranted copies
		//
		CSPData( const CSPData & );
		CSPData& operator=( const CSPData & );
};

#undef DPF_MODNAME

#endif	// __SPDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\spaddress.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPAddress.cpp
 *  Content:	Winsock address base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/12/99	jtk		Derived from modem endpoint class
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************




//**********************************************************************
// ------------------------------
// EncryptGuid - encrypt a guid
//
// Entry:		Pointer to source guid
//				Pointer to destination guid
//				Pointer to encryption key
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "EncryptGuid"

void	EncryptGuid( const GUID *const pSourceGuid,
					 GUID *const pDestinationGuid,
					 const GUID *const pEncryptionKey )
{
	const char	*pSourceBytes;
	char		*pDestinationBytes;
	const char	*pEncryptionBytes;
	DWORD_PTR	dwIndex;


	DNASSERT( pSourceGuid != NULL );
	DNASSERT( pDestinationGuid != NULL );
	DNASSERT( pEncryptionKey != NULL );

	DBG_CASSERT( sizeof( pSourceBytes ) == sizeof( pSourceGuid ) );
	pSourceBytes = reinterpret_cast<const char*>( pSourceGuid );
	
	DBG_CASSERT( sizeof( pDestinationBytes ) == sizeof( pDestinationGuid ) );
	pDestinationBytes = reinterpret_cast<char*>( pDestinationGuid );
	
	DBG_CASSERT( sizeof( pEncryptionBytes ) == sizeof( pEncryptionKey ) );
	pEncryptionBytes = reinterpret_cast<const char*>( pEncryptionKey );
	
	DBG_CASSERT( ( sizeof( *pSourceGuid ) == sizeof( *pEncryptionKey ) ) &&
				 ( sizeof( *pDestinationGuid ) == sizeof( *pEncryptionKey ) ) );
	dwIndex = sizeof( *pSourceGuid );
	while ( dwIndex != 0 )
	{
		dwIndex--;
		pDestinationBytes[ dwIndex ] = pSourceBytes[ dwIndex ] ^ pEncryptionBytes[ dwIndex ];
	}
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\threadpool.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		ThreadPool.cpp
 *  Content:	main job thread pool
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// types of threads
//
typedef	enum	_THREAD_TYPE
{
	THREAD_TYPE_UNKNOWN,			// unknown
	THREAD_TYPE_PRIMARY_WIN9X,		// primary Win9x thread
	THREAD_TYPE_SECONDARY_WIN9X,	// secondary Win9x thread

} THREAD_TYPE;

//
// events for threads
//
enum
{
	EVENT_INDEX_STOP_ALL_THREADS = 0,
	EVENT_INDEX_PENDING_JOB = 1,
	EVENT_INDEX_WAKE_NT_TIMER_THREAD = 1,
	EVENT_INDEX_WINSOCK_2_SEND_COMPLETE = 2,
	EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE = 3,
	EVENT_INDEX_NATHELP_UPDATE = 4,

	EVENT_INDEX_MAX
};

//
// times to wait in milliseconds when polling for work thread shutdown
//
#define	WORK_THREAD_CLOSE_SLEEP_TIME	100

//
// select polling period for writes (milliseconds)
//
static const DWORD	g_dwSelectTimeSlice = 2;


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct	_TIMER_OPERATION_ENTRY
{
	CBilink		Linkage;			// list links
	void		*pContext;			// user context passed back in timer events

	//
	// timer information
	//
	BOOL		fPerformImmediately;	// whether the operation should occur right away, or whether it should be delayed until the timeout elapses
	UINT_PTR	uRetryCount;			// number of times to retry this event
	BOOL		fRetryForever;			// Boolean for retrying forever
	DN_TIME		RetryInterval;			// time between enums (milliseconds)
	DN_TIME		IdleTimeout;			// time at which the command sits idle after all retrys are complete
	BOOL		fIdleWaitForever;		// Boolean for waiting forever in idle state
	DN_TIME		NextRetryTime;			// time at which this event will fire next (milliseconds)

	TIMER_EVENT_CALLBACK	*pTimerCallback;	// callback for when this event fires
	TIMER_EVENT_COMPLETE	*pTimerComplete;	// callback for when this event is complete

	#undef DPF_MODNAME
	#define	DPF_MODNAME	"_TIMER_OPERATION_ENTRY::TimerOperationFromLinkage"
	static TIMER_OPERATION_ENTRY	*TimerOperationFromLinkage( CBilink *const pLinkage )
	{
		DNASSERT( pLinkage != NULL );
		DBG_CASSERT( OFFSETOF( _TIMER_OPERATION_ENTRY, Linkage ) == 0 );
		return	reinterpret_cast<_TIMER_OPERATION_ENTRY*>( pLinkage );
	}

} TIMER_OPERATION_ENTRY;

//
// structure for common data in Win9x thread
//
typedef	struct	_WIN9X_CORE_DATA
{
	DN_TIME		NextTimerJobTime;					// time when the next timer job needs service
	HANDLE		hWaitHandles[ EVENT_INDEX_MAX ];	// handles for waiting on
	DWORD		dwTimeToNextJob;					// time to next job
	BOOL		fTimerJobsActive;					// Boolean indicating that there are active jobs
	BOOL		fLooping;							// Boolean indicating that this thread is still running

} WIN9X_CORE_DATA;

//
// information passed to the Win9x workhorse thread
//
typedef struct	_WIN9X_THREAD_DATA
{
	CThreadPool		*pThisThreadPool;	// pointer to this object
} WIN9X_THREAD_DATA;

//
// information passed to the IOCompletion thread
//
typedef struct	_IOCOMPLETION_THREAD_DATA
{
	CThreadPool		*pThisThreadPool;	// pointer to this object
} IOCOMPLETION_THREAD_DATA;

//
// structure passed to dialog threads
//
typedef	struct	_DIALOG_THREAD_PARAM
{
	DIALOG_FUNCTION	*pDialogFunction;
	void			*pContext;
	CThreadPool		*pThisThreadPool;
} DIALOG_THREAD_PARAM;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CThreadPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CThreadPool"

CThreadPool::CThreadPool():
		m_iRefCount( 0 ),
		m_iTotalThreadCount( 0 ),
#ifdef WINNT
		m_iNTCompletionThreadCount( 0 ),
		m_fNTTimerThreadRunning( FALSE ),
		m_hIOCompletionPort( NULL ),
#endif
		m_fAllowThreadCountReduction( FALSE ),
		m_iIntendedThreadCount( 0 ),
		m_fNATHelpLoaded( FALSE ),
		m_fNATHelpTimerJobSubmitted( FALSE ),
		m_dwNATHelpUpdateThreadID( 0 ),
		m_hStopAllThreads( NULL ),
#ifdef WIN95
		m_hWinsock2SendComplete( NULL ),
		m_hWinsock2ReceiveComplete( NULL ),
		m_hNATHelpUpdateEvent( NULL ),
#endif
		m_uReservedSocketCount( 0 )
{
	m_Sig[0] = 'T';
	m_Sig[1] = 'H';
	m_Sig[2] = 'P';
	m_Sig[3] = 'L';
	
	memset( &m_SocketSet, 0x00, sizeof( m_SocketSet ) );
	m_OutstandingReadList.Initialize();
	m_OutstandingWriteList.Initialize();
	m_TimerJobList.Initialize();
	memset( &m_pSocketPorts, 0x00, sizeof( m_pSocketPorts ) );
	
#ifdef DEBUG
	m_dwNumNATHelpUpdatesNotScheduled = 0;
#endif // DEBUG
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::~CThreadPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::~CThreadPool"

CThreadPool::~CThreadPool()
{
	DNASSERT( m_iRefCount == 0 );
	DNASSERT( m_iTotalThreadCount == 0 );
#ifdef WINNT
	DNASSERT( m_iNTCompletionThreadCount == 0 );
	DNASSERT( m_fNTTimerThreadRunning == FALSE );
	DNASSERT( m_hIOCompletionPort == NULL );
#endif
	DNASSERT( m_fAllowThreadCountReduction == FALSE );
	DNASSERT( m_iIntendedThreadCount == 0 );
	DNASSERT( m_fNATHelpLoaded == FALSE );
	DNASSERT( m_fNATHelpTimerJobSubmitted == FALSE );
	DNASSERT( m_dwNATHelpUpdateThreadID == 0 );
	DNASSERT( m_hStopAllThreads == NULL );
#ifdef WIN95
	DNASSERT( m_hWinsock2SendComplete == NULL );
	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
	DNASSERT( m_hNATHelpUpdateEvent == NULL );
#endif

	DNASSERT( m_uReservedSocketCount == 0 );
	DNASSERT( m_OutstandingReadList.IsEmpty() != FALSE );
	DNASSERT( m_OutstandingWriteList.IsEmpty() != FALSE );
	DNASSERT( m_TimerJobList.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::Initialize - initialize work threads
//
// Entry:		Nothing
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::Initialize"

HRESULT	CThreadPool::Initialize( void )
{
	HRESULT			hr;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// initialize critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );


	if ( DNInitializeCriticalSection( &m_ReadDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Win9x has poor APC support and as part of the workaround, the read data
	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
	//
#ifdef DEBUG
	DebugSetCriticalSectionRecursionCount( &m_ReadDataLock, 1 );
#endif

	if ( DNInitializeCriticalSection( &m_WriteDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Win9x has poor APC support and as part of the workaround, the write data
	// lock needs to be taken twice.  Adjust the recursion counts accordingly.
	//
#ifdef DEBUG
	DebugSetCriticalSectionRecursionCount( &m_WriteDataLock, 1 );
#endif


	if ( DNInitializeCriticalSection( &m_JobDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_JobDataLock, 0 );

	if ( DNInitializeCriticalSection( &m_TimerDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_TimerDataLock, 1 );

	//
	// initialize job queue
	//
	if ( m_JobQueue.Initialize() == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// initialize pools
	//

#ifndef USE_THREADLOCALPOOLS
	// pool of IP read requests
	m_IPReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
								   CReadIOData::ReadIOData_Get,
								   CReadIOData::ReadIOData_Release,
								   CReadIOData::ReadIOData_Dealloc
								   );

	// pool of IPX read requests
	m_IPXReadIODataPool.Initialize( CReadIOData::ReadIOData_Alloc,
									CReadIOData::ReadIOData_Get,
									CReadIOData::ReadIOData_Release,
									CReadIOData::ReadIOData_Dealloc
									);

	// pool of write requests
	m_WriteIODataPool.Initialize( CWriteIOData::WriteIOData_Alloc,
								  CWriteIOData::WriteIOData_Get,
								  CWriteIOData::WriteIOData_Release,
								  CWriteIOData::WriteIOData_Dealloc
								  );
#endif // ! USE_THREADLOCALPOOLS

	// job pool
	if ( FPM_Initialize( &m_JobPool,					// pointer to pool
						 sizeof( THREAD_POOL_JOB ),		// size of pool entry
						 WorkThreadJob_Alloc,			// function called on pool entry initial allocation
						 WorkThreadJob_Get,				// function called on entry extraction from pool
						 WorkThreadJob_Release,			// function called on entry return to pool
						 WorkThreadJob_Dealloc			// function called on entry free
						 ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	// enum entry pool
	if ( FPM_Initialize( &m_TimerEntryPool,					// pointer to pool
						 sizeof( TIMER_OPERATION_ENTRY ),	// size of pool entry
						 TimerEntry_Alloc,					// function called on pool entry initial allocation
						 TimerEntry_Get,					// function called on entry extraction from pool
						 TimerEntry_Release,				// function called on entry return to pool
						 TimerEntry_Dealloc					// function called on entry free
						 ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Create event to stop all threads.  Win9x needs this to stop processing
	// and the NT enum thread uses this to stop processing
	//
	DNASSERT( m_hStopAllThreads == NULL );
	m_hStopAllThreads = CreateEvent( NULL,		// pointer to security (none)
									 TRUE,		// manual reset
									 FALSE,		// start unsignalled
									 NULL );	// pointer to name (none)
	if ( m_hStopAllThreads == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to create event to stop all threads!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DNASSERT( m_fAllowThreadCountReduction == FALSE );
	m_fAllowThreadCountReduction = TRUE;

	

	//
	// Attempt to load the NAT helper, unless all NAT/firewall traversal is disabled.
	//
	DNASSERT( m_fNATHelpLoaded == FALSE );

	if ((! g_fDisableDPNHGatewaySupport) || (! g_fDisableDPNHFirewallSupport))
	{
		if ( LoadNATHelp() == FALSE )
		{
			DPFX(DPFPREP, 0, "Failed to load NAT Help, continuing." );
		}
		else
		{
			m_fNATHelpLoaded = TRUE;
		}
	}
	else
	{
		DPFX(DPFPREP, 0, "Not loading NAT Help." );
	}


	//
	// OS-specific initialization
	//
#ifdef WINNT
	//
	// WinNT
	//
	hr = WinNTInit();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}
#else // WIN95
	//
	// Windows 9x
	//
	hr = Win9xInit();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}
#endif
	
Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem with CreateWorkThreads" );
		DisplayDNError( 0, hr );
	}

	return	hr;

Failure:
	
	if ( IsNATHelpLoaded() != FALSE )
	{
		UnloadNATHelp();
		m_fNATHelpLoaded = FALSE;
	}
	
	StopAllThreads();
	Deinitialize();

	goto Exit;
}
//**********************************************************************

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::WinNTInit - initialize WinNT components
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WinNTInit"

HRESULT	CThreadPool::WinNTInit( void )
{
	HRESULT		hr;


	//
	// initialize
	//
	hr = DPN_OK;

	DNASSERT( m_hIOCompletionPort == NULL );
	m_hIOCompletionPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE,		// don't associate a file handle yet
												  NULL,						// handle of existing completion port (none)
												  NULL,						// completion key for callback (none)
												  0							// number of concurent threads (0 = use number of processors)
												  );
	if ( m_hIOCompletionPort == NULL )
	{
		DWORD	dwError;
		
		
		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Could not create NT IOCompletionPort!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}


	DPFX(DPFPREP, 7, "SetIntendedThreadCount %i", g_iThreadCount);
	SetIntendedThreadCount( g_iThreadCount );

Exit:
	return	hr;

Failure:
	DPFX(DPFPREP, 0, "Failed WinNT initialization!" );
	DisplayDNError( 0, hr );

	goto Exit;
}
//**********************************************************************
#endif // WINNT


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::Win9xInit - initialize Win9x components
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::Win9xInit"

HRESULT	CThreadPool::Win9xInit( void )
{
	HRESULT		hr;


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// Win9x requires completion events for Winsock2.  Always allocate the
	// events even though the they might not be used.
	//
	DNASSERT( m_hWinsock2SendComplete == NULL );
	m_hWinsock2SendComplete = CreateEvent( NULL,	// pointer to security (none)
										   TRUE,	// manual reset
										   FALSE,	// start unsignalled
										   NULL		// pointer to name (none)
										   );
	if ( m_hWinsock2SendComplete == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to create event for Winsock2Send!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DNASSERT( m_hWinsock2ReceiveComplete == NULL );
	m_hWinsock2ReceiveComplete = CreateEvent( NULL,		// pointer to security (none)
											  TRUE,		// manual reset
											  FALSE,	// start unsignalled
											  NULL		// pointer to name (none)
											  );
	if ( m_hWinsock2ReceiveComplete == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to create event for Winsock2Receive!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Event gets created whether we use NAT Help or not.  This simplifies code.
	//
	DNASSERT( m_hNATHelpUpdateEvent == NULL );
	m_hNATHelpUpdateEvent = CreateEvent( NULL,		// pointer to security (none)
										  TRUE,		// manual reset
										  FALSE,	// start unsignalled
										  NULL		// pointer to name (none)
										  );
	if ( m_hNATHelpUpdateEvent == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to create event for NAT Help update!" );
		DisplayErrorCode( 0, dwError );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "Created NAT Help update event 0x%p.", m_hNATHelpUpdateEvent);


	DPFX(DPFPREP, 7, "SetIntendedThreadCount %i", g_iThreadCount);
	SetIntendedThreadCount( g_iThreadCount );


Exit:

	return	hr;

Failure:
	DPFX(DPFPREP, 0, "Failed Win9x Initialization!" );
	DisplayDNError( 0, hr );

	goto Exit;
}
//**********************************************************************
#endif // WIN95

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::StartNTCompletionThread - start a WinNT completion thread
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StartNTCompletionThread"

void	CThreadPool::StartNTCompletionThread( void )
{
	HANDLE	hThread;
	DWORD	dwThreadID;
	IOCOMPLETION_THREAD_DATA	*pIOCompletionThreadData;

	
	pIOCompletionThreadData = static_cast<IOCOMPLETION_THREAD_DATA*>( DNMalloc( sizeof( *pIOCompletionThreadData ) ) );
	if ( pIOCompletionThreadData != NULL )
	{
		//
		// assume that a thread will be created
		//
		IncrementActiveNTCompletionThreadCount();

		pIOCompletionThreadData->pThisThreadPool = this;
		hThread = NULL;
		hThread = CreateThread( NULL,						// pointer to security attributes (none)
								0,							// stack size (default)
								WinNTIOCompletionThread,	// thread function
								pIOCompletionThreadData,	// thread parameter
								0,							// start thread immediately
								&dwThreadID					// pointer to thread ID destination
								);
		if ( hThread != NULL )
		{
			//
			// close thread handle because it's no longer needed
			//
			DPFX(DPFPREP, 8, "Creating I/O completion thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, ThreadCount(), NTCompletionThreadCount() );
			if ( CloseHandle( hThread ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Problem creating thread for I/O completion port" );
				DisplayErrorCode( 0, dwError );
			}
		}
		else
		{
			DWORD	dwError;


			//
			// failed to create thread, decrement active thread counts and
			// report error
			//
			DecrementActiveNTCompletionThreadCount();

			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Failed to create I/O completion thread!" );
			DisplayErrorCode( 0, dwError );

			DNFree( pIOCompletionThreadData );
		}
	}
}
//**********************************************************************
#endif // WINNT

#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::StartPrimaryWin9xIOThread - start the primary Win9x thread
//
// Entry:		Nothing
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StartPrimaryWin9xIOThread"

void	CThreadPool::StartPrimaryWin9xIOThread( void )
{
	HANDLE				hPrimaryThread;
	DWORD				dwPrimaryThreadID;
	WIN9X_THREAD_DATA	*pPrimaryThreadInput;


	//
	// initialize
	//
	hPrimaryThread = NULL;
	pPrimaryThreadInput = NULL;


	//
	// create parameters to worker threads
	//
	pPrimaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pPrimaryThreadInput ) ) );
	if ( pPrimaryThreadInput == NULL )
	{
		DPFX(DPFPREP, 0, "Problem allocating memory for primary Win9x thread!" );
		goto Failure;
	}

	memset( pPrimaryThreadInput, 0x00, sizeof( *pPrimaryThreadInput ) );
	pPrimaryThreadInput->pThisThreadPool = this;
	
	//
	// assume that the thread will be created
	//
	IncrementActiveThreadCount();
	
	//
	// Create one worker thread and boost its priority.  If the primary thread
	// can be created and boosted, create a secondary thread.  Do not create a
	// secondary thread if the primary could not be boosted because the system
	// is probably low on resources.
	//
	hPrimaryThread = CreateThread( NULL,					// pointer to security attributes (none)
								   0,						// stack size (default)
								   PrimaryWin9xThread,		// pointer to thread function
								   pPrimaryThreadInput,		// pointer to input parameter
								   0,						// let it run
								   &dwPrimaryThreadID		// pointer to destination of thread ID
								   );
	if ( hPrimaryThread == NULL )
	{
		DWORD	dwError;


		//
		// Failed to create thread, decrement active thread count and report
		// error.
		//
		DecrementActiveThreadCount();

		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Problem creating primary Win9x thread!" );
		DisplayErrorCode( 0, dwError );

		goto Failure;
	}
	pPrimaryThreadInput = NULL;


	DPFX(DPFPREP, 8, "Created primary Win9x thread: 0x%x\tTotal Thread Count: %d", dwPrimaryThreadID, ThreadCount() );
	DNASSERT( hPrimaryThread != NULL );

#ifdef ADJUST_THREAD_PRIORITY
	if ( SetThreadPriority( hPrimaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to boost priority of primary Win9x thread!  Ignoring." );
		DisplayErrorCode( 0, dwError );

		//
		// Not fatal, just continue.
		//
	}
#endif // ADJUST_THREAD_PRIORITY

	
Exit:
	if ( pPrimaryThreadInput != NULL )
	{
		DNFree( pPrimaryThreadInput );
		pPrimaryThreadInput = NULL;
	}

	if ( hPrimaryThread != NULL )
	{
		if ( CloseHandle( hPrimaryThread ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Problem closing Win9x thread handle!" );
			DisplayErrorCode( 0, dwError );
		}

		hPrimaryThread = NULL;
	}

	return;

Failure:

	goto Exit;
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::StartSecondaryWin9xIOThread - start a secondary Win9x thread
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StartSecondaryWin9xIOThread"

void	CThreadPool::StartSecondaryWin9xIOThread( void )
{
	WIN9X_THREAD_DATA	*pSecondaryThreadInput;


	pSecondaryThreadInput = static_cast<WIN9X_THREAD_DATA*>( DNMalloc( sizeof( *pSecondaryThreadInput ) ) );
	if ( pSecondaryThreadInput != NULL )
	{
		HANDLE	hSecondaryThread;
		DWORD	dwSecondaryThreadID;


		memset( pSecondaryThreadInput, 0x00, sizeof( *pSecondaryThreadInput ) );
		pSecondaryThreadInput->pThisThreadPool = this;

		IncrementActiveThreadCount();
		hSecondaryThread = CreateThread( NULL,						// pointer to security attributes (none)
										 0,							// stack size (default)
										 SecondaryWin9xThread,		// pointer to thread function
										 pSecondaryThreadInput,		// pointer to input parameter
										 0,							// let it run
										 &dwSecondaryThreadID		// pointer to destination of thread ID
										 );
		if ( hSecondaryThread != NULL )
		{
			DPFX(DPFPREP, 8, "Created secondary Win9x thread: 0x%x\tTotal Thread Count: %d", dwSecondaryThreadID, ThreadCount() );

			pSecondaryThreadInput = NULL;
			DNASSERT( hSecondaryThread != NULL );

#ifdef ADJUST_THREAD_PRIORITY
			if ( SetThreadPriority( hSecondaryThread, THREAD_PRIORITY_ABOVE_NORMAL ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Failed to boost priority of secondary Win9x thread!" );
				DisplayErrorCode( 0, dwError );

				//
				// Not fatal, just continue.
				//
			}
#endif // ADJUST_THREAD_PRIORITY

			if ( CloseHandle( hSecondaryThread ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Failed to close handle when starting secondary Win9x thread!" );
				DisplayErrorCode( 0, dwError );
			}

			hSecondaryThread = NULL;
		}
		else
		{
			//
			// thread startup failed, decrement active thread count
			//
			DecrementActiveThreadCount();
		}

		if ( pSecondaryThreadInput != NULL )
		{
			DNFree( pSecondaryThreadInput );
			pSecondaryThreadInput = NULL;
		}
	}
}
//**********************************************************************
#endif // WIN95

//**********************************************************************
// ------------------------------
// CThreadPool::StopAllThreads - stop all work threads
//
// Entry:		Nothing
//
// Exit:		Nothing
//
// Note:		This function blocks until all threads complete!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StopAllThreads"

void	CThreadPool::StopAllThreads( void )
{
	//
	// stop all non-I/O completion threads
	//
	if ( m_hStopAllThreads != NULL )
	{
		if ( SetEvent( m_hStopAllThreads ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Failed to set event to stop all threads!" );
			DisplayErrorCode( 0, dwError );
		}
	}

	//
	// If we're running on NT submit enough jobs to stop all threads.
	//
#ifdef WINNT
	UINT_PTR	uIndex;

	uIndex = NTCompletionThreadCount();
	while ( uIndex > 0 )
	{
		uIndex--;
		if ( PostQueuedCompletionStatus( m_hIOCompletionPort,			// handle of completion port
										 0,								// number of bytes transferred
										 IO_COMPLETION_KEY_SP_CLOSE,	// completion key
										 NULL							// pointer to overlapped structure (none)
										 ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Problem submitting Stop job to IO completion port!" );
			DisplayErrorCode( 0, dwError );
		}
	}
#endif

	//
	// check for outstanding threads (no need to lock thread pool count)
	//
	DPFX(DPFPREP, 8, "Number of outstanding threads: %d", ThreadCount() );
	while ( ThreadCount() != 0 )
	{
		DPFX(DPFPREP, 8, "Waiting for %d threads to quit.", ThreadCount() );
		SleepEx( WORK_THREAD_CLOSE_SLEEP_TIME, TRUE );
	}

	DNASSERT( ThreadCount() == 0 );
	m_iTotalThreadCount = 0;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CancelOutstandingJobs - cancel outstanding jobs
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CancelOutstandingJobs"

void	CThreadPool::CancelOutstandingJobs( void )
{
	DNASSERT( ThreadCount() == 0 );

	m_JobQueue.Lock();

	while ( m_JobQueue.IsEmpty() == FALSE )
	{
		THREAD_POOL_JOB	*pJob;


		pJob = m_JobQueue.DequeueJob();
		DNASSERT( pJob != NULL );
		DNASSERT( pJob->pCancelFunction != NULL );
		pJob->pCancelFunction( pJob );
		pJob->JobType = JOB_UNINITIALIZED;
		m_JobPool.Release( &m_JobPool, pJob );
	};

	m_JobQueue.Unlock();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CancelOutstandingIO - cancel outstanding IO
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CancelOutstandingIO"

void	CThreadPool::CancelOutstandingIO( void )
{
	CBilink	*pTemp;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);
	
	DNASSERT( ThreadCount() == 0 );

	//
	// stop any receives with the notification that Winsock is shutting down.
	//
	pTemp = m_OutstandingReadList.GetNext();
	while ( pTemp != &m_OutstandingReadList )
	{
		CReadIOData	*pReadData;


		pReadData = CReadIOData::ReadDataFromBilink( pTemp );
		pTemp = pTemp->GetNext();
		pReadData->m_OutstandingReadListLinkage.RemoveFromList();
		
		DEBUG_ONLY( if ( pReadData->m_fRetainedByHigherLayer != FALSE )
					{
						DNASSERT( FALSE );
					}
				  );		
#ifdef WIN95
		DNASSERT( pReadData->Win9xOperationPending() != FALSE );
		pReadData->SetWin9xOperationPending( FALSE );
#endif
		pReadData->m_ReceiveWSAReturn = WSAESHUTDOWN;
		pReadData->m_dwOverlappedBytesReceived = 0;
		pReadData->SocketPort()->CancelReceive( pReadData );
	}

	//
	// stop any pending writes with the notification that the user cancelled it.
	//
	pTemp = m_OutstandingWriteList.GetNext();
	while ( pTemp != &m_OutstandingWriteList )
	{
		CWriteIOData	*pWriteData;
		CSocketPort		*pSocketPort;


		pWriteData = CWriteIOData::WriteDataFromBilink( pTemp );
		pTemp = pTemp->GetNext();
		pWriteData->m_OutstandingWriteListLinkage.RemoveFromList();

#ifdef WIN95
		DNASSERT( pWriteData->Win9xOperationPending() != FALSE );
		pWriteData->SetWin9xOperationPending( FALSE );
#endif
		pSocketPort = pWriteData->SocketPort();
		pSocketPort->SendComplete( pWriteData, DPNERR_USERCANCEL );
		pSocketPort->DecRef();
	}

	while ( m_JobQueue.IsEmpty() == FALSE )
	{
		THREAD_POOL_JOB	*pJob;


		pJob = m_JobQueue.DequeueJob();
		DNASSERT( pJob != NULL );
		DNASSERT( pJob->pCancelFunction != NULL );
		pJob->pCancelFunction( pJob );
		pJob->JobType = JOB_UNINITIALIZED;
		m_JobPool.Release( &m_JobPool, pJob );
	};
	
	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ReturnSelfToPool - return this object to the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ReturnSelfToPool"

void	CThreadPool::ReturnSelfToPool( void )
{
	Deinitialize();
	ReturnThreadPool( this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::Deinitialize - destroy work threads
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::Deinitialize"

void	CThreadPool::Deinitialize( void )
{
	DNASSERT( m_JobQueue.IsEmpty() != FALSE );

	
	if ( IsNATHelpLoaded() )
	{
		if ( IsNATHelpTimerJobSubmitted() )
		{
			StopTimerJob( this, DPNERR_USERCANCEL );
			m_fNATHelpTimerJobSubmitted = FALSE;
		}

		UnloadNATHelp();
		m_fNATHelpLoaded = FALSE;
	}


#ifdef WINNT
	if ( m_hIOCompletionPort != NULL )
	{
		if ( CloseHandle( m_hIOCompletionPort ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Problem closing handle to I/O completion port!" );
			DisplayErrorCode( 0, dwError );
		}
		m_hIOCompletionPort = NULL;
	}
#endif

	//
	// close StopAllThreads handle
	//
	if ( m_hStopAllThreads != NULL )
	{
		if ( CloseHandle( m_hStopAllThreads ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Failed to close StopAllThreads handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hStopAllThreads = NULL;
	}

#ifdef WIN95
	//
	// close handles for I/O events
	//
	if ( m_hWinsock2SendComplete != NULL )
	{
		if ( CloseHandle( m_hWinsock2SendComplete ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Problem closing Winsock2SendComplete handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hWinsock2SendComplete = NULL;
	}

	if ( m_hWinsock2ReceiveComplete != NULL )
	{
		if ( CloseHandle( m_hWinsock2ReceiveComplete ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Problem closing Winsock2ReceiveComplete handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hWinsock2ReceiveComplete = NULL;
	}

	if ( m_hNATHelpUpdateEvent != NULL )
	{
		if ( CloseHandle( m_hNATHelpUpdateEvent ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Problem closing NAT HelpUpdate handle!" );
			DisplayErrorCode( 0, dwError );
		}

		m_hNATHelpUpdateEvent = NULL;
	}
#endif // WIN95

	//
	// deinitialize pools
	//

	// timer entry pool
	FPM_Deinitialize( &m_TimerEntryPool );

	// job pool
	FPM_Deinitialize( &m_JobPool );

	// write data pool
	DNASSERT( m_OutstandingWriteList.IsEmpty() != FALSE );
#ifndef USE_THREADLOCALPOOLS
	m_WriteIODataPool.Deinitialize();
#endif // ! USE_THREADLOCALPOOLS

	// read data pool
	DNASSERT( m_OutstandingReadList.IsEmpty() != FALSE );
#ifndef USE_THREADLOCALPOOLS
	m_IPReadIODataPool.Deinitialize();
	m_IPXReadIODataPool.Deinitialize();
#endif // ! USE_THREADLOCALPOOLS

	//
	// deinitialize job queue
	//
	m_JobQueue.Deinitialize();

	DNDeleteCriticalSection( &m_TimerDataLock );
	DNDeleteCriticalSection( &m_JobDataLock );
	DNDeleteCriticalSection( &m_WriteDataLock );
	DNDeleteCriticalSection( &m_ReadDataLock );
	DNDeleteCriticalSection( &m_Lock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::StopAllIO - stop all IO from the thread pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StopAllIO"

void	CThreadPool::StopAllIO( void )
{

	//
	// request that all threads stop and then cycle our timeslice to
	// allow the threads a chance for cleanup
	//
	m_fAllowThreadCountReduction = FALSE;
	DPFX(DPFPREP, 7, "SetIntendedThreadCount 0");
	SetIntendedThreadCount( 0 );
	StopAllThreads();

	while ( m_JobQueue.IsEmpty() == FALSE )
	{
		THREAD_POOL_JOB	*pThreadPoolJob;


		pThreadPoolJob = GetWorkItem();
		DNASSERT( pThreadPoolJob != NULL );
		pThreadPoolJob->pCancelFunction( pThreadPoolJob );
		pThreadPoolJob->JobType = JOB_UNINITIALIZED;

		m_JobPool.Release( &m_JobPool, pThreadPoolJob );
	}

	//
	// Now that all of the threads are stopped, clean up any outstanding I/O.
	// this can be done without taking any locks
	//
	CancelOutstandingIO();	
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CThreadPool::GetNewReadIOData - get new read request from pool
//
// Entry:		Pointer to context
//
// Exit:		Pointer to new read request
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::GetNewReadIOData"

CReadIOData	*CThreadPool::GetNewReadIOData( READ_IO_DATA_POOL_CONTEXT *const pContext )
{
#ifdef USE_THREADLOCALPOOLS
	CContextFixedTLPool<CReadIOData, READ_IO_DATA_POOL_CONTEXT> *	pPool;
	BOOL															fResult;
	CReadIOData *													pTempReadData;


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	pContext->pThreadPool = this;


	//
	// Get the pool pointer.
	//
	switch ( pContext->SPType )
	{
		//
		// IP
		//
		case TYPE_IP:
		{
			GET_THREADLOCALPTR( WSockThreadLocalPools,
								pIPReadIODataPool,
								&pPool );
			break;
		}

		//
		// IPX
		//
		case TYPE_IPX:
		{
			GET_THREADLOCALPTR( WSockThreadLocalPools,
								pIPXReadIODataPool,
								&pPool );
			break;
		}

		//
		// unknown SP type (should never be here!)
		//
		default:
		{
			DNASSERT( FALSE );
			goto Exit;
			break;
		}
	}


	//
	// Create the pool if it didn't exist.
	//
	if ( pPool == NULL )
	{
		pPool = new CContextFixedTLPool<CReadIOData, READ_IO_DATA_POOL_CONTEXT>;
		if ( pPool == NULL )
		{
			pTempReadData = NULL;
			goto Exit;
		}


		//
		// Try to initialize the pool.
		//
		if ( pContext->SPType == TYPE_IP )
		{
			fResult = pPool->Initialize( g_pGlobalIPReadIODataPool,
										CReadIOData::ReadIOData_Alloc,
										CReadIOData::ReadIOData_Get,
										CReadIOData::ReadIOData_Release,
										CReadIOData::ReadIOData_Dealloc
									   );
		}
		else
		{
			fResult = pPool->Initialize( g_pGlobalIPXReadIODataPool,
										CReadIOData::ReadIOData_Alloc,
										CReadIOData::ReadIOData_Get,
										CReadIOData::ReadIOData_Release,
										CReadIOData::ReadIOData_Dealloc
									   );
		}

		if (! fResult)
		{
			//
			// Initializing pool failed, delete it and abort.
			//
			delete pPool;
			pTempReadData = NULL;
			goto Exit;
		}


		//
		// Associate the pool with this thread.
		//
		if ( pContext->SPType == TYPE_IP )
		{
			SET_THREADLOCALPTR( WSockThreadLocalPools,
								pIPReadIODataPool,
								pPool,
								&fResult );
		}
		else
		{
			SET_THREADLOCALPTR( WSockThreadLocalPools,
								pIPXReadIODataPool,
								pPool,
								&fResult );
		}

		if (! fResult)
		{
			//
			// Associating pool with thread failed, de-initialize it, delete it,
			// and abort.
			//
			pPool->Deinitialize();
			delete pPool;
			pTempReadData = NULL;
			goto Exit;
		}
	}


	//
	// Get an item out of the pool.
	//
	pTempReadData = pPool->Get( pContext );
	if ( pTempReadData == NULL )
	{
		DPFX(DPFPREP, 0, "Failed to get new ReadIOData from pool!" );
		goto Exit;
	}


	//
	// we have data, immediately add a reference to it
	//
	pTempReadData->AddRef();

	DNASSERT( pTempReadData->m_pSourceSocketAddress != NULL );



	//
	// now that the read data is initialized, add it to the
	// unbound list
	//
	
	LockReadData();
	pTempReadData->m_OutstandingReadListLinkage.InsertBefore( &m_OutstandingReadList );
	UnlockReadData();

Exit:

	return pTempReadData;
#else // ! USE_THREADLOCALPOOLS
	CReadIOData		*pTempReadData;


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	pTempReadData = NULL;
	pContext->pThreadPool = this;

	LockReadData();

	switch ( pContext->SPType )
	{
		//
		// IP
		//
		case TYPE_IP:
		{
			pTempReadData = m_IPReadIODataPool.Get( pContext );
			break;
		}

		//
		// IPX
		//
		case TYPE_IPX:
		{
			pTempReadData = m_IPXReadIODataPool.Get( pContext );
			break;
		}

		//
		// unknown SP type (should never be here!)
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	
	if ( pTempReadData == NULL )
	{
		DPFX(DPFPREP, 0, "Failed to get new ReadIOData from pool!" );
		goto Failure;
	}

	//
	// we have data, immediately add a reference to it
	//
	pTempReadData->AddRef();

	DNASSERT( pTempReadData->m_pSourceSocketAddress != NULL );

	//
	// now that the read data is initialized, add it to the
	// unbound list
	//
	pTempReadData->m_OutstandingReadListLinkage.InsertBefore( &m_OutstandingReadList );

Exit:
	UnlockReadData();

	return pTempReadData;

Failure:
	if ( pTempReadData != NULL )
	{
		pTempReadData->DecRef();
		pTempReadData = NULL;
	}

	goto Exit;
#endif // ! USE_THREADLOCALPOOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ReturnReadIOData - return read data item to pool
//
// Entry:		Pointer to read data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ReturnReadIOData"

void	CThreadPool::ReturnReadIOData( CReadIOData *const pReadData )
{
#ifdef USE_THREADLOCALPOOLS
	CContextFixedTLPool<CReadIOData, READ_IO_DATA_POOL_CONTEXT> *	pPool;
	BOOL															fResult;

	
	DNASSERT( pReadData != NULL );
	DNASSERT( pReadData->m_pSourceSocketAddress != NULL );

	//
	// remove this item from the unbound list
	//
	LockReadData();
	pReadData->m_OutstandingReadListLinkage.RemoveFromList();
	UnlockReadData();
	
	DNASSERT( pReadData->m_OutstandingReadListLinkage.IsEmpty() != FALSE );

	//
	// Get the pool pointer.
	//
	switch ( pReadData->m_pSourceSocketAddress->GetFamily() )
	{
		//
		// IP
		//
		case AF_INET:
		{
			GET_THREADLOCALPTR( WSockThreadLocalPools,
								pIPReadIODataPool,
								&pPool );
			break;
		}

		//
		// IPX
		//
		case AF_IPX:
		{
			GET_THREADLOCALPTR( WSockThreadLocalPools,
								pIPXReadIODataPool,
								&pPool );
			break;
		}

		//
		// unknown type (shouldn't be here!)
		//
		default:
		{
			DNASSERT( FALSE );
			//goto Exit;
			break;
		}
	}


	//
	// Create the pool if it didn't exist.
	//
	if ( pPool == NULL )
	{
		pPool = new CContextFixedTLPool<CReadIOData, READ_IO_DATA_POOL_CONTEXT>;
		if ( pPool == NULL )
		{
			//
			// Couldn't create this thread's pool, just release the item
			// without the pool.
			//
			CContextFixedTLPool<CReadIOData, READ_IO_DATA_POOL_CONTEXT>::ReleaseWithoutPool( pReadData, CReadIOData::ReadIOData_Release, CReadIOData::ReadIOData_Dealloc );

			return;
		}

		//
		// Try to initialize the pool.
		//
		if ( pReadData->m_pSourceSocketAddress->GetFamily() == AF_INET )
		{
			fResult = pPool->Initialize( g_pGlobalIPReadIODataPool,
										CReadIOData::ReadIOData_Alloc,
										CReadIOData::ReadIOData_Get,
										CReadIOData::ReadIOData_Release,
										CReadIOData::ReadIOData_Dealloc
									   );
		}
		else
		{
			fResult = pPool->Initialize( g_pGlobalIPXReadIODataPool,
										CReadIOData::ReadIOData_Alloc,
										CReadIOData::ReadIOData_Get,
										CReadIOData::ReadIOData_Release,
										CReadIOData::ReadIOData_Dealloc
									   );
		}

		if (! fResult)
		{
			//
			// Initializing this thread's pool failed, just release the
			// item without the pool, and destroy the pool object that
			// couldn't be used.
			//
			CContextFixedTLPool<CReadIOData, READ_IO_DATA_POOL_CONTEXT>::ReleaseWithoutPool( pReadData, CReadIOData::ReadIOData_Release, CReadIOData::ReadIOData_Dealloc );
			delete pPool;

			return;
		}


		//
		// Associate the pool with this thread.
		//
		if ( pReadData->m_pSourceSocketAddress->GetFamily() == AF_INET )
		{
			SET_THREADLOCALPTR( WSockThreadLocalPools,
								pIPReadIODataPool,
								pPool,
								&fResult );
		}
		else
		{
			SET_THREADLOCALPTR( WSockThreadLocalPools,
								pIPXReadIODataPool,
								pPool,
								&fResult );
		}

		if ( ! fResult )
		{
			//
			// Couldn't store this thread's pool, just release the item
			// without the pool, plus de-initialize and destroy the pool
			// object that couldn't be used.
			//
			CContextFixedTLPool<CReadIOData, READ_IO_DATA_POOL_CONTEXT>::ReleaseWithoutPool( pReadData, CReadIOData::ReadIOData_Release, CReadIOData::ReadIOData_Dealloc );
			pPool->Deinitialize();
			delete pPool;

			return;
		}
	}
	
	pPool->Release( pReadData );
#else // ! USE_THREADLOCALPOOLS
	DNASSERT( pReadData != NULL );
	DNASSERT( pReadData->m_pSourceSocketAddress != NULL );

	//
	// remove this item from the unbound list and return it to the pool
	//
	LockReadData();

	pReadData->m_OutstandingReadListLinkage.RemoveFromList();
	DNASSERT( pReadData->m_OutstandingReadListLinkage.IsEmpty() != FALSE );
	
	switch ( pReadData->m_pSourceSocketAddress->GetFamily() )
	{
		//
		// IP
		//
		case AF_INET:
		{
			m_IPReadIODataPool.Release( pReadData );
			break;
		}

		//
		// IPX
		//
		case AF_IPX:
		{
			m_IPXReadIODataPool.Release( pReadData );
			break;
		}

		//
		// unknown type (shouldn't be here!)
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	UnlockReadData();
#endif // ! USE_THREADLOCALPOOLS
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ProcessTimerJobs - process timed jobs
//
// Entry:		Pointer to job list
//				Pointer to destination for time of next job
//
// Exit:		Boolean indicating active timer jobs exist
//				TRUE = there are active jobs
//				FALSE = there are no active jobs
//
// Notes:	The input job queue is expected to be locked for the duration
//			of this function call!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ProcessTimerJobs"

BOOL	CThreadPool::ProcessTimerJobs( const CBilink *const pJobList, DN_TIME *const pNextJobTime )
{
	BOOL		fReturn;
	CBilink		*pWorkingEntry;
	INT_PTR		iActiveTimerJobCount;
	DN_TIME		CurrentTime;


	DNASSERT( pJobList != NULL );
	DNASSERT( pNextJobTime != NULL );

	//
	// Initialize.  Set the next job time to be infinitely far in the future
	// so this thread will wake up for any jobs that need to completed before
	// then.
	//
	fReturn = FALSE;
	DBG_CASSERT( OFFSETOF( TIMER_OPERATION_ENTRY, Linkage ) == 0 );
	pWorkingEntry = pJobList->GetNext();
	iActiveTimerJobCount = 0;
	memset( pNextJobTime, 0xFF, sizeof( *pNextJobTime ) );
	DNTimeGet( &CurrentTime );

	DPFX(DPFPREP, 8, "Threadpool 0x%p processing timer jobs, current offset time = %u.",
		this, CurrentTime.Time32.TimeLow);

	//
	// loop through all timer items
	//
	while ( pWorkingEntry != pJobList )
	{
		TIMER_OPERATION_ENTRY	*pTimerEntry;
		BOOL	fJobActive;


		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pWorkingEntry );
		pWorkingEntry = pWorkingEntry->GetNext();
		
		fJobActive = ProcessTimedOperation( pTimerEntry, &CurrentTime, pNextJobTime );
		DNASSERT( ( fJobActive == FALSE ) || ( fJobActive == TRUE ) );
		
		fReturn |= fJobActive;

		if ( fJobActive == FALSE )
		{
			RemoveTimerOperationEntry( pTimerEntry, DPN_OK );
		}
	}

	DNASSERT( ( fReturn == FALSE ) || ( fReturn == TRUE ) );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ProcessTimedOperation - process a timed operation
//
// Entry:		Pointer to job information
//				Pointer to current time
//				Pointer to time to be updated
//
// Exit:		Boolean indicating that the job is still active
//				TRUE = operation active
//				FALSE = operation not active
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ProcessTimedOperation"

BOOL	CThreadPool::ProcessTimedOperation( TIMER_OPERATION_ENTRY *const pTimedJob,
											const DN_TIME *const pCurrentTime,
											DN_TIME *const pNextJobTime )
{
	BOOL	fEnumActive;


	DNASSERT( pTimedJob != NULL );
	DNASSERT( pCurrentTime != NULL );
	DNASSERT( pNextJobTime != NULL );


	DPFX(DPFPREP, 8, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p)",
		this, pTimedJob, pCurrentTime, pNextJobTime);

	//
	// Assume that this enum will remain active.  If we retire this enum, this
	// value will be reset.
	//
	fEnumActive = TRUE;

	//
	// If this enum has completed sending enums and is waiting only
	// for responses, decrement the wait time (assuming it's not infinite)
	// and remove the enum if the we've exceeded its wait time.
	//
	if ( pTimedJob->uRetryCount == 0 )
	{
		if ( DNTimeCompare( &pTimedJob->IdleTimeout, pCurrentTime ) <= 0 )
		{
			fEnumActive = FALSE;
		}
		else
		{
			//
			// This enum isn't complete, check to see if it's the next enum
			// to need service.
			//
			if ( DNTimeCompare( &pTimedJob->IdleTimeout, pNextJobTime ) < 0 )
			{
				DBG_CASSERT( sizeof( *pNextJobTime ) == sizeof( pTimedJob->IdleTimeout ) );
				memcpy( pNextJobTime, &pTimedJob->IdleTimeout, sizeof( *pNextJobTime ) );
			}
		}
	}
	else
	{
		//
		// This enum is still sending.  Determine if it's time to perform the job
		// and adjust the wakeup time if appropriate.
		//
		if ( DNTimeCompare( &pTimedJob->NextRetryTime, pCurrentTime ) <= 0 )
		{
			//
			// If the job should be performed immediately do so.  Otherwise, just
			// sit tight until the retry interval elapses.
			//
			if ( pTimedJob->fPerformImmediately )
			{
#ifdef DEBUG
				DN_TIME		Delay;


				DNTimeSubtract( pCurrentTime, &pTimedJob->NextRetryTime, &Delay );

				DPFX(DPFPREP, 7, "Threadpool 0x%p performing timed job 0x%p at time offset %u, approximately %u ms after intended time offset of %u.",
					this, pTimedJob, pCurrentTime->Time32.TimeLow,
					Delay.Time32.TimeLow, pTimedJob->NextRetryTime.Time32.TimeLow);
#endif // DEBUG
				
				//
				// Timeout, execute this timed item
				//
				pTimedJob->pTimerCallback( pTimedJob->pContext, &pTimedJob->RetryInterval );

				//
				// If this job isn't running forever, decrement the retry count.
				// If there are no more retries, set up wait time.  If the job
				// is waiting forever, set max wait timeout.
				//
				if ( pTimedJob->fRetryForever == FALSE )
				{
					pTimedJob->uRetryCount--;
					if ( pTimedJob->uRetryCount == 0 )
					{
						if ( pTimedJob->fIdleWaitForever == FALSE )
						{
							//
							// Compute stopping time for this job's 'Timeout' phase and
							// see if this will be the next job to need service.  ASSERT
							// if the math wraps.
							//
							DNTimeAdd( &pTimedJob->IdleTimeout, pCurrentTime, &pTimedJob->IdleTimeout );
							DNASSERT( pTimedJob->IdleTimeout.Time32.TimeHigh >= pCurrentTime->Time32.TimeHigh );
							if ( DNTimeCompare( &pTimedJob->IdleTimeout, pNextJobTime ) < 0 )
							{
								DBG_CASSERT( sizeof( *pNextJobTime ) == sizeof( pTimedJob->IdleTimeout ) );
								memcpy( pNextJobTime, &pTimedJob->IdleTimeout, sizeof( *pNextJobTime ) );
							}
						}
						else
						{
							//
							// We're waiting forever for enum returns.  ASSERT that we
							// have the maximum timeout and don't bother checking to see
							// if this will be the next enum to need service (it'll never
							// need service).  The following code needs to be revisited for
							// 64-bits.
							//
							DNASSERT( pTimedJob->IdleTimeout.Time32.TimeLow == -1 );
							DNASSERT( pTimedJob->IdleTimeout.Time32.TimeHigh == -1 );
						}

						goto SkipNextRetryTimeComputation;
					}
				} // end if (don't retry forever)
			}
			else
			{
				DPFX(DPFPREP, 8, "Job 0x%p not performed immediately, waiting until retry time (%u ms).",
					pTimedJob, pTimedJob->RetryInterval.Time32.TimeLow);

				pTimedJob->fPerformImmediately = TRUE;
			}

			DNTimeAdd( pCurrentTime, &pTimedJob->RetryInterval, &pTimedJob->NextRetryTime );
		}

		//
		// is this the next timed job to fire?
		//
		if ( DNTimeCompare( &pTimedJob->NextRetryTime, pNextJobTime ) < 0 )
		{
			DBG_CASSERT( sizeof( *pNextJobTime ) == sizeof( pTimedJob->NextRetryTime ) );
			memcpy( pNextJobTime, &pTimedJob->NextRetryTime, sizeof( *pNextJobTime ) );


			DPFX(DPFPREP, 8, "Job 0x%p is the next job to fire (at offset time %u).",
				pTimedJob, pTimedJob->NextRetryTime.Time32.TimeLow);
		}
		else
		{
			//
			// Not next job to fire.
			//
		}

SkipNextRetryTimeComputation:
		//
		// the following blank line is there to shut up the compiler
		//
		;
	}


	DPFX(DPFPREP, 8, "(0x%p) Returning [%i]",
		this, fEnumActive);

	return	fEnumActive;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitWorkItem - submit a work item for processing and inform
//		work thread that another job is available
//
// Entry:		Pointer to job information
//
// Exit:		Error code
//
// Note:	This function assumes that the job data is locked.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SubmitWorkItem"

HRESULT	CThreadPool::SubmitWorkItem( THREAD_POOL_JOB *const pJobInfo )
{
	HRESULT	hr;


	DPFX(DPFPREP, 8, "(0x%p) Parameters: (0x%p)", this, pJobInfo);

	DNASSERT( pJobInfo != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_JobDataLock, TRUE );
	DNASSERT( pJobInfo->pCancelFunction != NULL );


	//
	// initialize
	//
	hr = DPN_OK;

	//
	// add job to queue and tell someone that there's a job available
	//
	m_JobQueue.Lock();
	m_JobQueue.EnqueueJob( pJobInfo );
	m_JobQueue.Unlock();

#ifdef WINNT
	//
	// WinNT, submit new I/O completion item
	//
	DNASSERT( m_hIOCompletionPort != NULL );
	if ( PostQueuedCompletionStatus( m_hIOCompletionPort,			// completion port
									 0,								// number of bytes written (unused)
									 IO_COMPLETION_KEY_NEW_JOB,		// completion key
									 NULL							// pointer to overlapped structure (unused)
									 ) == FALSE )
	{
		DWORD	dwError;


		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Problem posting completion item for new job!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}
#else // WIN95
	//
	// Win9x, set event that the work thread will listen for
	//
	DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
	if ( m_JobQueue.SignalPendingJob() == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to signal pending job!" );
		goto Failure;
	}
#endif

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem with SubmitWorkItem!" );
		DisplayDNError( 0, hr );
	}
	
	DPFX(DPFPREP, 8, "(0x%p) Return [0x%lx]", this, hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::GetWorkItem - get a work item from the job queue
//
// Entry:		Nothing
//
// Exit:		Pointer to job information (may be NULL)
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::GetWorkItem"

THREAD_POOL_JOB	*CThreadPool::GetWorkItem( void )
{
	THREAD_POOL_JOB	*pReturn;


	//
	// initialize
	//
	pReturn = NULL;

	m_JobQueue.Lock();
	pReturn = m_JobQueue.DequeueJob();

	//
	// if we're under Win9x (we have a 'pending job' handle),
	// see if the handle needs to be reset
	//
	if ( m_JobQueue.IsEmpty() != FALSE )
	{
		DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );
		if ( ResetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Problem resetting event for pending Win9x jobs!" );
			DisplayErrorCode( 0, dwError );
		}
	}

	m_JobQueue.Unlock();

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitTimerJob - add a timer job to the timer list
//
// Entry:		Whether to perform immediately or not
//				Retry count
//				Boolean indicating that we retry forever
//				Retry interval
//				Boolean indicating that we wait forever
//				Idle wait interval
//				Pointer to callback when event fires
//				Pointer to callback when event complete
//				User context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SubmitTimerJob"

HRESULT	CThreadPool::SubmitTimerJob( const BOOL fPerformImmediately,
									const UINT_PTR uRetryCount,
									const BOOL fRetryForever,
									const DN_TIME RetryInterval,
									const BOOL fIdleWaitForever,
									const DN_TIME IdleTimeout,
									TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
									TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
									void *const pContext )
{
	HRESULT					hr;
	TIMER_OPERATION_ENTRY	*pEntry;
	THREAD_POOL_JOB			*pJob;
	BOOL					fTimerJobListLocked;


	DNASSERT( uRetryCount != 0 );
	DNASSERT( pTimerCallbackFunction != NULL );
	DNASSERT( pTimerCompleteFunction != NULL );
	DNASSERT( pContext != NULL );				// must be non-NULL because it's the lookup key to remove job

	//
	// initialize
	//
	hr = DPN_OK;
	pEntry = NULL;
	pJob = NULL;
	fTimerJobListLocked = FALSE;


	LockJobData();

	//
	// allocate new enum entry
	//
	pEntry = static_cast<TIMER_OPERATION_ENTRY*>( m_TimerEntryPool.Get( &m_TimerEntryPool ) );
	if ( pEntry == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot allocate memory to add to timer list!" );
		goto Failure;
	}
	DNASSERT( pEntry->pContext == NULL );


	DPFX(DPFPREP, 8, "Created timer entry 0x%p (context 0x%p, immed. %i, tries %u, forever %i, interval %u, timeout %u, forever = %i).",
		pEntry, pContext, fPerformImmediately, uRetryCount, fRetryForever, RetryInterval.Time32.TimeLow, IdleTimeout.Time32.TimeLow, fIdleWaitForever);

	//
	// build timer entry block
	//
	pEntry->pContext = pContext;
	pEntry->fPerformImmediately = fPerformImmediately;
	pEntry->uRetryCount = uRetryCount;
	pEntry->fRetryForever = fRetryForever;
	pEntry->RetryInterval = RetryInterval;
	pEntry->IdleTimeout = IdleTimeout;
	pEntry->fIdleWaitForever = fIdleWaitForever;
	pEntry->pTimerCallback = pTimerCallbackFunction;
	pEntry->pTimerComplete = pTimerCompleteFunction;

	//
	// set this enum to fire as soon as it gets a chance
	//
	memset( &pEntry->NextRetryTime, 0x00, sizeof( pEntry->NextRetryTime ) );

	pJob = static_cast<THREAD_POOL_JOB*>( m_JobPool.Get( &m_JobPool ) );
	if ( pJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot allocate memory for enum job!" );
		goto Failure;
	}

	//
	// Create job for work thread.
	//
	pJob->pCancelFunction = CancelRefreshTimerJobs;
	pJob->JobType = JOB_REFRESH_TIMER_JOBS;

	// set our dummy parameter to simulate passing data
	DEBUG_ONLY( pJob->JobData.JobRefreshTimedJobs.uDummy = 0 );

	LockTimerData();
	fTimerJobListLocked = TRUE;


	//
	// we can submit the 'ENUM_REFRESH' job before inserting the enum entry
	// into the active enum list because nobody will be able to pull the
	// 'ENUM_REFRESH' job from the queue since we have the queue locked
	//
	hr = SubmitWorkItem( pJob );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem submitting enum work item" );
		DisplayDNError( 0, hr );
		goto Failure;
	}


	//
	// debug block to check for duplicate contexts
	//
	DEBUG_ONLY(
				{
					CBilink	*pTempLink;


					pTempLink = m_TimerJobList.GetNext();
					while ( pTempLink != &m_TimerJobList )
					{
						TIMER_OPERATION_ENTRY	*pTempTimerEntry;
					
						
						pTempTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempLink );
						DNASSERT( pTempTimerEntry->pContext != pContext );
						pTempLink = pTempLink->GetNext();
					}
				}
			);

	//
	// link to rest of list
	//
	pEntry->Linkage.InsertAfter( &m_TimerJobList );

	UnlockTimerData();
	fTimerJobListLocked = FALSE;


	//
	// If we're on NT, attempt to start the special thread, or kick it
	// if it's already running.
	//
#ifdef WINNT
	hr = StartNTTimerThread();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Cannot spin up NT timer thread!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
#endif


Exit:

	UnlockJobData();

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem with SubmitEnumJob" );
		DisplayDNError( 0, hr );
	}

	return	hr;


Failure:

	if ( pEntry != NULL )
	{
		m_TimerEntryPool.Release( &m_TimerEntryPool, pEntry );
		DEBUG_ONLY( pEntry = NULL );
	}

	if ( pJob != NULL )
	{
		m_JobPool.Release( &m_JobPool, pJob );
		DEBUG_ONLY( pJob = NULL );
	}

	//
	// It's possible that the enum thread has been started for this enum.
	// Since there's no way to stop it without completing the enums or
	// closing the SP, leave it running.
	//

	if ( fTimerJobListLocked != FALSE )
	{
		UnlockTimerData();
		fTimerJobListLocked = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::CancelRefreshTimerJobs - cancel job to refresh timer jobs
//
// Entry:		Job data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CancelRefreshTimerJobs"

void	CThreadPool::CancelRefreshTimerJobs( THREAD_POOL_JOB *const pJob )
{
	DNASSERT( pJob != NULL );

	//
	// this function doesn't need to do anything
	//
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::StopTimerJob - remove timer job from list
//
// Entry:		Pointer to job context (these MUST be unique for jobs)
//				Command result
//
// Exit:		Boolean indicating whether a job was stopped or not
//
// Note:	This function is for the forced removal of a job from the timed job
//			list.  It is assumed that the caller of this function will clean
//			up any messes.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StopTimerJob"

BOOL	CThreadPool::StopTimerJob( void *const pContext, const HRESULT hCommandResult )
{
	BOOL						fComplete = FALSE;
	CBilink *					pTempEntry;
	TIMER_OPERATION_ENTRY *		pTimerEntry;


	DNASSERT( pContext != NULL );

	DPFX(DPFPREP, 8, "Parameters (0x%p, 0x%lx)", pContext, hCommandResult);

	
	//
	// initialize
	//
	LockTimerData();

	pTempEntry = m_TimerJobList.GetNext();
	while ( pTempEntry != &m_TimerJobList )
	{
		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempEntry );
		if ( pTimerEntry->pContext == pContext )
		{
			//
			// remove this link from the list
			//
			pTimerEntry->Linkage.RemoveFromList();

			fComplete = TRUE;

			//
			// terminate loop
			//
			break;
		}

		pTempEntry = pTempEntry->GetNext();
	}

	UnlockTimerData();

	//
 	// tell owner that the job is complete and return the job to the pool
 	// outside of the lock
 	//
	if (fComplete)
	{
		DPFX(DPFPREP, 8, "Found timer entry 0x%p (context 0x%p), completing with result 0x%lx.",
			pTimerEntry, pTimerEntry->pContext, hCommandResult);
		
		pTimerEntry->pTimerComplete( hCommandResult, pTimerEntry->pContext );

		//
		// Relock the timer list so we can safely put items back in the pool,
		//
		LockTimerData();
		
		m_TimerEntryPool.Release( &m_TimerEntryPool, pTimerEntry );
		
		UnlockTimerData();
	}


	DPFX(DPFPREP, 8, "Returning [%i]", fComplete);

	return fComplete;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ModifyTimerJobNextRetryTime - update a timer job's next retry time
//
// Entry:		Pointer to job context (these MUST be unique for jobs)
//				New time for next retry
//
// Exit:		Boolean indicating whether a job was found & updated or not
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ModifyTimerJobNextRetryTime"

BOOL	CThreadPool::ModifyTimerJobNextRetryTime( void *const pContext,
												DN_TIME * const pNextRetryTime)
{
	BOOL						fFound;
	CBilink *					pTempEntry;
	TIMER_OPERATION_ENTRY *		pTimerEntry;
	INT_PTR						iResult;



	DNASSERT( pContext != NULL );

	DPFX(DPFPREP, 8, "Parameters (0x%p, 0x%p)", pContext, pNextRetryTime);

	
	//
	// initialize
	//
	fFound = FALSE;

	
	LockJobData();
	LockTimerData();


	pTempEntry = m_TimerJobList.GetNext();
	while ( pTempEntry != &m_TimerJobList )
	{
		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempEntry );
		if ( pTimerEntry->pContext == pContext )
		{
			iResult = DNTimeCompare(&(pTimerEntry->NextRetryTime), pNextRetryTime);
			if (iResult != 0)
			{
				THREAD_POOL_JOB *	pJob;
				HRESULT				hr;
				DN_TIME				NextRetryTimeDifference;
				DN_TIME				NewRetryInterval;


				if (iResult < 0)
				{
					//
					// Next time to fire is now later.
					//

					DNTimeSubtract(pNextRetryTime, &(pTimerEntry->NextRetryTime), &NextRetryTimeDifference);
					DNTimeAdd(&(pTimerEntry->RetryInterval), &NextRetryTimeDifference, &NewRetryInterval);

					DPFX(DPFPREP, 7, "Timer 0x%p next retry time delayed by %u ms from offset %u to offset %u, modifying interval from %u to %u.",
						pTimerEntry,
						NextRetryTimeDifference.Time32.TimeLow,
						pTimerEntry->NextRetryTime.Time32.TimeLow,
						pNextRetryTime->Time32.TimeLow,
						pTimerEntry->RetryInterval.Time32.TimeLow,
						NewRetryInterval.Time32.TimeLow);
				}
				else
				{
					//
					// Next time to fire is now earlier.
					//

					DNTimeSubtract(&(pTimerEntry->NextRetryTime), pNextRetryTime, &NextRetryTimeDifference);
					DNTimeSubtract(&(pTimerEntry->RetryInterval), &NextRetryTimeDifference, &NewRetryInterval);

					DPFX(DPFPREP, 7, "Timer 0x%p next retry time moved up by %u ms from offset %u to offset %u, modifying interval from %u to %u.",
						pTimerEntry,
						NextRetryTimeDifference.Time32.TimeLow,
						pTimerEntry->NextRetryTime.Time32.TimeLow,
						pNextRetryTime->Time32.TimeLow,
						pTimerEntry->RetryInterval.Time32.TimeLow,
						NewRetryInterval.Time32.TimeLow);
				}

				memcpy(&(pTimerEntry->RetryInterval), &NewRetryInterval, sizeof(DN_TIME));
				memcpy(&(pTimerEntry->NextRetryTime), pNextRetryTime, sizeof(DN_TIME));


				//
				// Submit a refresh job so the threads will notice the new time.
				//
				pJob = static_cast<THREAD_POOL_JOB*>( m_JobPool.Get( &m_JobPool ) );
				if ( pJob == NULL )
				{
					DPFX(DPFPREP, 0, "Cannot allocate memory for enum refresh job!" );
				}
				else
				{
					pJob->pCancelFunction = CancelRefreshTimerJobs;
					pJob->JobType = JOB_REFRESH_TIMER_JOBS;

					// set our dummy parameter to simulate passing data
					DEBUG_ONLY( pJob->JobData.JobRefreshTimedJobs.uDummy = 0 );


					hr = SubmitWorkItem( pJob );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP, 0, "Problem submitting enum work item" );
						DisplayDNError( 0, hr );

						m_JobPool.Release( &m_JobPool, pJob );
						DEBUG_ONLY( pJob = NULL );
					}
				}
			}
			else
			{
				//
				// The intervals are the same, no change necessary.
				//

				DPFX(DPFPREP, 7, "Timer 0x%p next retry time was unchanged (offset %u), not changing interval from %u.",
					pTimerEntry,
					pTimerEntry->NextRetryTime.Time32.TimeLow,
					pTimerEntry->RetryInterval.Time32.TimeLow);
			}

			
			fFound = TRUE;

			
			//
			// Terminate loop
			//
			break;
		}

		pTempEntry = pTempEntry->GetNext();
	}


	UnlockTimerData();
	UnlockJobData();


	DPFX(DPFPREP, 8, "Returning [%i]", fFound);

	return fFound;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SpawnDialogThread - start a secondary thread to display service
//		provider UI.
//
// Entry:		Pointer to dialog function
//				Dialog context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SpawnDialogThread"

HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, void *const pDialogContext )
{
	HRESULT	hr;
	HANDLE	hDialogThread;
	DIALOG_THREAD_PARAM		*pThreadParam;
	DWORD	dwThreadID;


	DNASSERT( pDialogFunction != NULL );
	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??


	//
	// initialize
	//
	hr = DPN_OK;
	pThreadParam = NULL;

	//
	// create and initialize thread param
	//
	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
	if ( pThreadParam == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to allocate memory for dialog thread!" );
		goto Failure;
	}

	pThreadParam->pDialogFunction = pDialogFunction;
	pThreadParam->pContext = pDialogContext;
	pThreadParam->pThisThreadPool = this;

	//
	// assume that a thread will be created
	//
	IncrementActiveThreadCount();

	//
	// create thread
	//
	hDialogThread = CreateThread( NULL,					// pointer to security (none)
								  0,					// stack size (default)
								  DialogThreadProc,		// thread procedure
								  pThreadParam,			// thread param
								  0,					// creation flags (none)
								  &dwThreadID );		// pointer to thread ID
	if ( hDialogThread == NULL )
	{
		DWORD	dwError;


		//
		// decrement active thread count and report error
		//
		DecrementActiveThreadCount();
		
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to start dialog thread!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}
  								
	if ( CloseHandle( hDialogThread ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Problem closing handle from create dialog thread!" );
		DisplayErrorCode( 0, dwError );
	}

Exit:	
	return	hr;

Failure:
	if ( pThreadParam != NULL )
	{
		DNFree( pThreadParam );
		pThreadParam = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::GetIOThreadCount - get I/O thread count
//
// Entry:		Pointer to variable to fill
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::GetIOThreadCount"

HRESULT	CThreadPool::GetIOThreadCount( LONG *const piThreadCount )
{
	HRESULT	hr;


	DNASSERT( piThreadCount != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();

	if ( IsThreadCountReductionAllowed() )
	{
		*piThreadCount = GetIntendedThreadCount();
	}
	else
	{
#ifdef WIN95
		*piThreadCount = ThreadCount();
#else // WINNT
		DNASSERT( NTCompletionThreadCount() != 0 );
		*piThreadCount = NTCompletionThreadCount();
#endif
	}
	
	Unlock();

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SetIOThreadCount - set I/O thread count
//
// Entry:		New thread count
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SetIOThreadCount"

HRESULT	CThreadPool::SetIOThreadCount( const LONG iThreadCount )
{
	HRESULT	hr;


	DNASSERT( iThreadCount > 0 );

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();

	if ( IsThreadCountReductionAllowed() )
	{
		DPFX(DPFPREP, 4, "Thread pool not locked down, setting intended thread count to %i.", iThreadCount );
		SetIntendedThreadCount( iThreadCount );
	}
	else
	{
#ifdef WIN95
		//
		// Win9x can only increase threads once locked down.
		//
		if ( iThreadCount > ThreadCount() )
		{
			INT_PTR	iDeltaThreads;


			iDeltaThreads = iThreadCount - ThreadCount();
			
			DPFX(DPFPREP, 4, "Thread pool locked down, spawning %i new 9x threads (for a total of %i).",
				iDeltaThreads, iThreadCount );
			
			while ( iDeltaThreads > 0 )
			{
				iDeltaThreads--;
				StartSecondaryWin9xIOThread();
			}
		}
		else
		{
			DPFX(DPFPREP, 4, "Thread pool locked down and already has %i 9x threads, not adjusting to %i.",
				ThreadCount(), iThreadCount );
		}
#else // WINNT				
		//
		// WinNT can have many threads.  If the user wants more threads, attempt
		// to boost the thread pool to the requested amount (if we fail to
		// start a new thread, too bad).  If the user wants fewer threads, check
		// to see if the thread pool has been locked out of changes.  If not,
		// start killing off the threads.
		//
		if ( iThreadCount > NTCompletionThreadCount() )
		{
			INT_PTR	iDeltaThreads;


			iDeltaThreads = iThreadCount - NTCompletionThreadCount();

			DPFX(DPFPREP, 4, "Thread pool locked down, spawning %i new NT threads (for a total of %i).",
				iDeltaThreads, iThreadCount );
			
			while ( iDeltaThreads > 0 )
			{
				iDeltaThreads--;
				StartNTCompletionThread();
			}
		}
		else
		{
			DPFX(DPFPREP, 4, "Thread pool locked down and already has %i NT threads, not adjusting to %i.",
				NTCompletionThreadCount(), iThreadCount );
		}
#endif
	}

	Unlock();

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::PreventThreadPoolReduction - prevents the thread pool size from being reduced
//
// Entry:		None
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::PreventThreadPoolReduction"

HRESULT CThreadPool::PreventThreadPoolReduction( void )
{
	HRESULT		hr = DPN_OK;
	LONG		iDesiredThreads;
	DWORD		dwTemp;
	DPNHCAPS	dpnhcaps;
	DN_TIME		NATHelpRetryTime;
	DN_TIME		NATHelpTimeoutTime;
#ifdef DEBUG
	DWORD		dwStartTime;
	DWORD		dwCurrentTime;
#endif // DEBUG


	Lock();

	//
	// If we haven't already clamped down, do so, and spin up the threads.
	//
	if ( IsThreadCountReductionAllowed() )
	{
		m_fAllowThreadCountReduction = FALSE;

		DNASSERT( GetIntendedThreadCount() > 0 );
		DNASSERT( ThreadCount() == 0 );

		iDesiredThreads = GetIntendedThreadCount();
		SetIntendedThreadCount( 0 );
		

		DPFX(DPFPREP, 3, "Locking down thread count at %i.", iDesiredThreads );

#ifdef DEBUG
		dwStartTime = GETTIMESTAMP();
#endif // DEBUG
		

		//
		// OS-specific thread starting.
		//
#ifdef WINNT
		//
		// WinNT
		//
		DNASSERT( NTCompletionThreadCount() == 0 );
		
		while ( iDesiredThreads > 0 )
		{
			iDesiredThreads--;
			StartNTCompletionThread();
		}

		//
		// If at least one thread was created, the SP will perform in a
		// non-optimal fashion, but we will still function.  If no threads
		// were created, fail.
		//
		if ( ThreadCount() == 0 )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP, 0, "Unable to create any threads to service NT I/O completion port!" );
			goto Failure;
		}
#else // WIN95
		//
		// Windows 9x
		//

		//
		// Spin up the 9x threads.  Start with the primary thread.
		//
	
		StartPrimaryWin9xIOThread();

		if ( ThreadCount() == 0 )
		{
			DPFX(DPFPREP, 0, "Failed to start primary Win9x I/O thread!" );
			goto Failure;
		}

		iDesiredThreads--;


		//
		// Spin up the requested number of secondary threads.
		//
		while ( iDesiredThreads > 0 )
		{
			iDesiredThreads--;
			StartSecondaryWin9xIOThread();
		}
#endif
		
#ifdef DEBUG
		dwCurrentTime = GETTIMESTAMP();
		DPFX(DPFPREP, 8, "Spent %u ms starting %i threads.", (dwCurrentTime - dwStartTime), ThreadCount());
#endif // DEBUG


		if (IsNATHelpLoaded())
		{
#ifdef DEBUG
			dwStartTime = dwCurrentTime;		
#endif // DEBUG

			//
			// Initialize the timer values.
			//
			NATHelpRetryTime.Time32.TimeHigh	= 0;
			NATHelpRetryTime.Time32.TimeLow		= -1;

			NATHelpTimeoutTime.Time32.TimeHigh	= 0;
			NATHelpTimeoutTime.Time32.TimeLow	= 0;


			//
			// Loop through each NAT help object.
			//
			for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
			{
				if (g_papNATHelpObjects[dwTemp] != NULL)
				{
					if (g_fUseNATHelpAlert)
					{
						//
						// Install the NAT Help alert mechanism.
						//
#ifdef WINNT
						hr = IDirectPlayNATHelp_SetAlertIOCompletionPort(g_papNATHelpObjects[dwTemp],
																		m_hIOCompletionPort,
																		IO_COMPLETION_KEY_NATHELP_UPDATE,
																		0,	// doesn't matter how many concurrent threads
																		0);
						if (hr != DPNH_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't set NAT Help alert I/O completion port for object %u (error = 0x%lx), continuing.",
								dwTemp, hr);

							//
							// It's not fatal, we still have some level of functionality.
							//
						}
#else // WIN95
						DNASSERT(m_hNATHelpUpdateEvent != NULL);
						
						hr = IDirectPlayNATHelp_SetAlertEvent(g_papNATHelpObjects[dwTemp],
															m_hNATHelpUpdateEvent,
															0);
						if (hr != DPNH_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't set NAT Help alert event for object %u (error = 0x%lx), continuing.",
								dwTemp, hr);

							//
							// It's not fatal, we still have some level of functionality.
							//
						}
#endif
					}
					else
					{
						DPFX(DPFPREP, 1, "Not installing NAT Help alert event/IO completion port.");
					}
					
					//
					// Determine how often to refresh the NAT help caps in the future.
					//
					// We're going to force server detection now.  This will increase the time
					// it takes to startup up this Enum/Connect/Listen operation, but is
					// necessary since the IDirectPlayNATHelp::GetRegisteredAddresses call in
					// CSocketPort::BindToInternetGateway and possibly the
 					// IDirectPlayNATHelp::QueryAddress call in CSocketPort::MungePublicAddress
 					// could occur before the first NATHelp GetCaps timer fires.
 					// In the vast majority of NAT cases, the gateway is already available.
 					// If we hadn't detected that yet (because we hadn't called
 					// IDirectPlayNATHelp::GetCaps with DPNHGETCAPS_UPDATESERVERSTATUS)
 					// then we would get an incorrect result from GetRegisteredAddresses or
 					// QueryAddress.
					//
					ZeroMemory(&dpnhcaps, sizeof(dpnhcaps));
					dpnhcaps.dwSize = sizeof(dpnhcaps);

	 				hr = IDirectPlayNATHelp_GetCaps(g_papNATHelpObjects[dwTemp],
	 												&dpnhcaps,
	 												DPNHGETCAPS_UPDATESERVERSTATUS);
					if (FAILED(hr))
					{
						DPFX(DPFPREP, 0, "Failed getting NAT Help capabilities (error = 0x%lx), continuing.",
							hr);

						//
						// NAT Help will probably not work correctly, but that won't prevent
						// local connections from working.  Consider it non-fatal.
						//
						hr = DPN_OK;
					}
					else
					{
						//
						// See if this is the shortest interval.
						//
						if (dpnhcaps.dwRecommendedGetCapsInterval < NATHelpRetryTime.Time32.TimeLow)
						{
							NATHelpRetryTime.Time32.TimeLow = dpnhcaps.dwRecommendedGetCapsInterval;
						}
					}
				}
				else
				{
					//
					// No object loaded in this slot.
					//
				}
			}
		
			
			//
			// If there's a retry interval, submit a timer job.
			//
			if (NATHelpRetryTime.Time32.TimeLow != -1)
			{
				//
				// Attempt to add timer job that will refresh the lease and server
				// status.
				// Although we're submitting it as a periodic timer, it's actually
				// not going to be called at regular intervals.
				// There is a race condition where the alert event/IOCP may have
				// been fired already, and another thread tried to cancel this timer
				// which hasn't been submitted yet.  The logic to handle this race
				// is placed there (HandleNATHelpUpdate); here we can assume we
				// are the first person to submit the refresh timer.
				//


				DPFX(DPFPREP, 7, "Submitting NAT Help refresh timer (for every %u ms) for thread pool 0x%p.",
					NATHelpRetryTime.Time32.TimeLow, this);

				DNASSERT(! this->m_fNATHelpTimerJobSubmitted );
				this->m_fNATHelpTimerJobSubmitted = TRUE;

				hr = SubmitTimerJob(FALSE,								// don't perform immediately
									1,									// retry count
									TRUE,								// retry forever
									NATHelpRetryTime,					// retry timeout
									TRUE,								// wait forever
									NATHelpTimeoutTime,					// idle timeout
									CThreadPool::NATHelpTimerFunction,	// periodic callback function
									CThreadPool::NATHelpTimerComplete,	// completion function
									this);								// context
				if (hr != DPN_OK)
				{
					m_fNATHelpTimerJobSubmitted = FALSE;
					DPFX(DPFPREP, 0, "Failed to submit timer job to watch over NAT Help!" );
					
					//
					// NAT Help will probably not work correctly, but that won't
					// prevent local connections from working.  Consider it
					// non-fatal.
					//
				}
			}
			
#ifdef DEBUG
			dwCurrentTime = GETTIMESTAMP();
			DPFX(DPFPREP, 8, "Spent %u ms preparing DPNATHLP.", (dwCurrentTime - dwStartTime));
#endif // DEBUG
		}
	}
	else
	{
		DPFX(DPFPREP, 3, "Thread count already locked down (at %i).", ThreadCount() );
	}

Exit:
	
	Unlock();

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************




//**********************************************************************
// ------------------------------
// CThreadPool::NATHelpTimerComplete - NAT Help timer job has completed
//
// Entry:		Timer result code
//				Context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CThreadPool::NATHelpTimerComplete"

void	CThreadPool::NATHelpTimerComplete( const HRESULT hResult, void * const pContext )
{
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::NATHelpTimerFunction - NAT Help timer job needs service
//
// Entry:		Pointer to context
//				Pointer to current timer retry interval
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CThreadPool::NATHelpTimerFunction"

void	CThreadPool::NATHelpTimerFunction( void * const pContext, DN_TIME * const pRetryInterval )
{
	CThreadPool *	pThisThreadPool;
	DWORD			dwError;


	DNASSERT( pContext != NULL );
	pThisThreadPool = (CThreadPool*) pContext;


	//
	// The NAT Help GetCaps function may block for a non-trivial amount of time.
	// It would really best if we didn't perform it in the timer thread, and thus hold
	// up all the other timers.  There's only 1 timer thread, but we can survive
	// without 1 I/O thread for a little while.
	// We could submit a delayed job to update, but that's a little bit of over-
	// engineering in my opinion.  We can already have an alert mechanism in
	// place, so let's just ping that and let our I/O threads do their job.
	// Don't request the update if a thread is already handling the update, though.
	//

	pThisThreadPool->Lock();

	if (pThisThreadPool->m_dwNATHelpUpdateThreadID == 0)
	{
#ifdef DEBUG
		//
		// Reset the not-scheduled counter since we're now scheduling an update.
		//
		if (pThisThreadPool->m_dwNumNATHelpUpdatesNotScheduled > 0)
		{
			DPFX(DPFPREP, 1, "Thread pool 0x%p scheduling NAT Help update after %u attempts.",
				pThisThreadPool, pThisThreadPool->m_dwNumNATHelpUpdatesNotScheduled);
			
			pThisThreadPool->m_dwNumNATHelpUpdatesNotScheduled = 0;
		}
		else
		{
			DPFX(DPFPREP, 9, "Thread pool 0x%p scheduling NAT Help update.", pThisThreadPool);
		}
#endif // DEBUG

		pThisThreadPool->Unlock();


#ifdef WINNT
		//
		// Submit an I/O completion packet.
		//
		if (! PostQueuedCompletionStatus(pThisThreadPool->GetIOCompletionPort(),	// handle of completion port
										 0,											// number of bytes transferred
										 IO_COMPLETION_KEY_NATHELP_UPDATE,			// completion key
										 NULL))										// pointer to overlapped structure (none)
		{
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Couldn't submit NAT Help update I/O complet packet (err = %u)!", dwError );
			DisplayErrorCode(0, dwError);
		}
#else // ! WINNT
		//
		// WinSock 1 doesn't support the alert event, so we have no choice but to
		// handle it here.
		//
		if (GetWinsockVersion() == 1)
		{
			pThisThreadPool->HandleNATHelpUpdate(pRetryInterval);
		}
		else
		{
			//
			// This is a huge hack, but kick the receive thread, since it appears
			// that occasionally we're not getting the event set when the I/O
			// completes.  We do it in the NAT timer simply because it's in
			// existence.
			// Setting the event when there's nothing to receive is harmless.
			//
			if (! SetEvent(pThisThreadPool->GetWinsock2ReceiveCompleteEvent()))
			{
				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Couldn't set WinSock 2 receive event (err = %u)!", dwError);
				DisplayErrorCode(0, dwError);
			}

			
			//
			// Note that we also don't submit a delayed job because we don't want
			// to eat up our only job processing thread (the primary Win9x thread)
			// with the lengthy update process.  Setting the event ensures only the
			// secondary thread to pick it up.
			//
			if (! SetEvent(pThisThreadPool->GetNATHelpUpdateEvent()))
			{
				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Couldn't set NAT Help update event (err = %u)!", dwError);
				DisplayErrorCode(0, dwError);
			}
		}
#endif // ! WINNT
	}
	else
	{
#ifdef DEBUG
		pThisThreadPool->m_dwNumNATHelpUpdatesNotScheduled++;
		
		DPFX(DPFPREP, 1, "Thread %u/0x%x already handling NAT Help update, not requesting another update (thread pool = 0x%p, timer = 0x%p, not-scheduled count = %u).",
			pThisThreadPool->m_dwNATHelpUpdateThreadID,
			pThisThreadPool->m_dwNATHelpUpdateThreadID,
			pThisThreadPool,
			pRetryInterval,
			pThisThreadPool->m_dwNumNATHelpUpdatesNotScheduled);

		//
		// This count shouldn't get very large.  We're usually only refreshing
		// every 25 seconds or thereabouts, so even in a 12 hour stress run
		// where the GetCaps call blocked for the entire duration, we should
		// see fewer than 2000 timer expirations (~1728).  We'll use 500, or
		// over 3 hours of 25 second intervals.  If this assert fires, it means
		// something is wrong with the thread pool or NAT Help.
		//
		DNASSERT(pThisThreadPool->m_dwNumNATHelpUpdatesNotScheduled < 500);
#endif // DEBUG

		//
		// Increase the interval to a really long time so that we don't attempt
		// to fire this timer again (on our own).  The thread that is currently
		// refreshing NAT Help will set this back to something appropriate when
		// it finally comes back to the land of the living.
		//
		pRetryInterval->Time32.TimeLow = INFINITE;
		
		pThisThreadPool->Unlock();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitDelayedCommand - submit request to enum query to remote session
//
// Entry:		Pointer to callback function
//				Pointer to cancel function
//				Pointer to callback context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SubmitDelayedCommand"

HRESULT	CThreadPool::SubmitDelayedCommand( JOB_FUNCTION *const pFunction, JOB_FUNCTION *const pCancelFunction, void *const pContext )
{
	HRESULT			hr;
	THREAD_POOL_JOB	*pJob;
	BOOL			fJobDataLocked;


	DPFX(DPFPREP, 6, "Parameters (0x%p, 0x%p, 0x%p)", pFunction, pCancelFunction, pContext);
	
	DNASSERT( pFunction != NULL );
	DNASSERT( pCancelFunction != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pJob = NULL;
	fJobDataLocked = FALSE;

	pJob = static_cast<THREAD_POOL_JOB*>( m_JobPool.Get( &m_JobPool ) );
	if ( pJob == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot allocate job for DelayedCommand!" );
		goto Failure;
	}

	pJob->JobType = JOB_DELAYED_COMMAND;
	pJob->pCancelFunction = pCancelFunction;
	pJob->JobData.JobDelayedCommand.pCommandFunction = pFunction;
	pJob->JobData.JobDelayedCommand.pContext = pContext;

	LockJobData();
	fJobDataLocked = TRUE;

	hr = SubmitWorkItem( pJob );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem submitting DelayedCommand job!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

Exit:
	if ( fJobDataLocked != FALSE )
	{
		UnlockJobData();
		fJobDataLocked = FALSE;
	}
	
	DPFX(DPFPREP, 6, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	if ( pJob != NULL )
	{
		m_JobPool.Release( &m_JobPool, pJob );
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::AddSocketPort - add a socket to the Win9x watch list
//
// Entry:		Pointer to SocketPort
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::AddSocketPort"

HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
{
	HRESULT	hr;
	BOOL	fSocketAdded;

	
	DNASSERT( pSocketPort != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	fSocketAdded = FALSE;

	Lock();

	//
	// We're capped by the number of sockets we can use for Winsock1.  Make
	// sure we don't allocate too many sockets.
	//
	if ( m_uReservedSocketCount == FD_SETSIZE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "There are too many sockets allocated on Winsock1!" );
		goto Failure;
	}

	m_uReservedSocketCount++;
	
	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
	m_SocketSet.fd_count++;
	fSocketAdded = TRUE;

	//
	// add a reference to note that this socket port is being used by the thread
	// pool
	//
	pSocketPort->AddRef();

	if ( m_JobQueue.SignalPendingJob() == FALSE )
	{
		DPFX(DPFPREP, 0, "Failed to signal pending job when adding socket port to active list!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

Exit:
	Unlock();
	
	return	hr;

Failure:
	if ( fSocketAdded != FALSE )
	{
		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
		m_SocketSet.fd_count--;
		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
		fSocketAdded = FALSE;
	}

	m_uReservedSocketCount--;

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
//
// Entry:		Pointer to socket port to remove
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::RemoveSocketPort"

void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
{
	UINT_PTR	uIndex;


	DNASSERT( pSocketPort != NULL );
	
	Lock();

	uIndex = m_SocketSet.fd_count;
	DNASSERT( uIndex != 0 );
	while ( uIndex != 0 )
	{
		uIndex--;

		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
		{
			m_uReservedSocketCount--;
			m_SocketSet.fd_count--;

			memmove( &m_pSocketPorts[ uIndex ],
					 &m_pSocketPorts[ uIndex + 1 ],
					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );

			memmove( &m_SocketSet.fd_array[ uIndex ],
					 &m_SocketSet.fd_array[ uIndex + 1 ],
					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );

			//
			// clear last entry which is now unused
			//
			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );

			//
			// end the loop
			//
			uIndex = 0;
		}
	}

	Unlock();
	
	pSocketPort->DecRef();

	//
	// It's really not necessary to signal a new job here because there were
	// active sockets on the last iteration of the Win9x thread.  That means the
	// Win9x thread was in a polling mode to check for sockets and the next time
	// through it will notice that there is a missing socket.  By signalling the
	// job event we reduce the time needed for the thread to figure out that the
	// socket is gone.
	//
	if ( m_JobQueue.SignalPendingJob() == FALSE )
	{
		DPFX(DPFPREP, 0, "Failed to signal pending job when removeing socket port to active list!" );
	}
}
//**********************************************************************

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::StartNTTimerThread - start the timer thread for NT
//
// Entry:		Nothing
//
// Exit:		Error code
//
// Note:	This function assumes that the enum data is locked.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StartNTTimerThread"

HRESULT	CThreadPool::StartNTTimerThread( void )
{
	HRESULT	hr;
	HANDLE	hThread;
	DWORD	dwThreadID;


	//
	// initialize
	//
	hr = DPN_OK;
	DNASSERT( m_JobQueue.GetPendingJobHandle() != NULL );

	if ( m_fNTTimerThreadRunning != FALSE )
	{
		//
		// the enum thread is already running, poke it to note new enums
		//
		if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
		{
			DWORD	dwError;


			hr = DPNERR_OUTOFMEMORY;
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Problem setting event to wake NTTimerThread!" );
			DisplayErrorCode( 0, dwError );
			goto Failure;
		}

		goto Exit;
	}

	IncrementActiveThreadCount();
	hThread = CreateThread( NULL,				// pointer to security attributes (none)
							0,					// stack size (default)
							WinNTTimerThread,	// thread function
							this,				// thread parameter
							0,					// creation flags (none, start running now)
							&dwThreadID			// pointer to thread ID
							);
	if ( hThread == NULL )
	{
		DWORD	dwError;


		hr = DPNERR_OUTOFMEMORY;
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to create NT timer thread!" );
		DisplayErrorCode( 0, dwError );
		DecrementActiveThreadCount();

		goto Failure;
	}

	//
	// note that the thread is running and close the handle to the thread
	//
	m_fNTTimerThreadRunning = TRUE;
	DPFX(DPFPREP, 8, "Creating NT-Timer thread: 0x%x\tTotal Thread Count: %d\tNT Completion Thread Count: %d", dwThreadID, ThreadCount(), NTCompletionThreadCount() );

	if ( CloseHandle( hThread ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Problem closing handle after starting NTTimerThread!" );
		DisplayErrorCode( 0, dwError );
	}

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************
#endif // WINNT

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::WakeNTTimerThread - wake the timer thread because a timed event
//		has been added
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WakeNTTimerThread"

void	CThreadPool::WakeNTTimerThread( void )
{
	LockJobData();
	DNASSERT( m_JobQueue.GetPendingJobHandle() != FALSE );
	if ( SetEvent( m_JobQueue.GetPendingJobHandle() ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Problem setting event to wake up NT timer thread!" );
		DisplayErrorCode( 0, dwError );
	}
	UnlockJobData();
}
//**********************************************************************
#endif // WINNT

//**********************************************************************
// ------------------------------
// CThreadPool::RemoveTimerOperationEntry - remove timer operation job	from list
//
// Entry:		Pointer to timer operation
//				Result code to return
//
// Exit:		Nothing
//
// Note:	This function assumes that the list is appropriately locked
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::RemoveTimerOperationEntry"

void	CThreadPool::RemoveTimerOperationEntry( TIMER_OPERATION_ENTRY *const pTimerEntry, const HRESULT hJobResult )
{
	DNASSERT( pTimerEntry != NULL );
	AssertCriticalSectionIsTakenByThisThread( &m_TimerDataLock, TRUE );

	//
	// remove this link from the list, tell owner that the job is complete and
	// return the job to the pool
	//
	pTimerEntry->Linkage.RemoveFromList();
	pTimerEntry->pTimerComplete( hJobResult, pTimerEntry->pContext );
	m_TimerEntryPool.Release( &m_TimerEntryPool, pTimerEntry );
}
//**********************************************************************


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::CompleteOutstandingSends - check for completed sends and
//		indicate send completion for them.
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CompleteOutstandingSends"

void	CThreadPool::CompleteOutstandingSends( void )
{
	CBilink		*pCurrentOutstandingWrite;
	CBilink		WritesToBeProcessed;


	WritesToBeProcessed.Initialize();
	LockWriteData();

	//
	// Loop through the list out outstanding sends.  Any completed sends are
	// removed from the list and processed after we release the write data lock.
	//
	pCurrentOutstandingWrite = m_OutstandingWriteList.GetNext();
	while ( pCurrentOutstandingWrite != &m_OutstandingWriteList )
	{
		CWriteIOData	*pWriteIOData;
		DWORD			dwFlags;


		//
		// note this send and advance pointer to the next pending send
		//
		pWriteIOData = CWriteIOData::WriteDataFromBilink( pCurrentOutstandingWrite );
		pCurrentOutstandingWrite = pCurrentOutstandingWrite->GetNext();

		if ( pWriteIOData->Win9xOperationPending() != FALSE )
		{
			if ( p_WSAGetOverlappedResult( pWriteIOData->SocketPort()->GetSocket(),
										   pWriteIOData->Overlap(),
										   &pWriteIOData->m_dwOverlappedBytesSent,
										   FALSE,
										   &dwFlags
										   ) != FALSE )
			{
				//
				// Overlapped results will complete with success and zero bytes
				// transferred when the overlapped structure is checked BEFORE
				// the operation has really been submitted.  This is a possibility
				// with the current code.  To combat this, check the sent bytes
				// for zero (we'll never send zero bytes).
				//
				if ( pWriteIOData->m_dwOverlappedBytesSent == 0 )
				{
					goto SkipSendCompletion;
				}

				pWriteIOData->m_Win9xSendHResult = DPN_OK;
				pWriteIOData->m_dwOverlappedBytesSent = 0;
			}
			else
			{
				DWORD	dwWSAError;


				dwWSAError = p_WSAGetLastError();
				switch( dwWSAError )
				{
					//
					// this I/O operation is incomplete, don't send notification to the user
					//
					case ERROR_IO_PENDING:
					case WSA_IO_INCOMPLETE:
					{
						goto SkipSendCompletion;
						break;
					}

					//
					// WSAENOTSOCK = the socket has been closed, most likely
					// as a result of a command completing or being cancelled.
					//
					case WSAENOTSOCK:
					{
						pWriteIOData->m_Win9xSendHResult = DPNERR_USERCANCEL;
						break;
					}

					//
					// other error, stop and look
					//
					default:
					{
						DNASSERT( FALSE );
						pWriteIOData->m_Win9xSendHResult = DPNERR_GENERIC;
						DisplayWinsockError( 0, dwWSAError );

						break;
					}
				}
			}

			DNASSERT( pWriteIOData->Win9xOperationPending() != FALSE );
			pWriteIOData->SetWin9xOperationPending( FALSE );

			pWriteIOData->m_OutstandingWriteListLinkage.RemoveFromList();
			pWriteIOData->m_OutstandingWriteListLinkage.InsertBefore( &WritesToBeProcessed );
		}

SkipSendCompletion:
		//
		// the following line is present to prevent the compiler from whining
		// about a blank line
		//
		;
	}

	UnlockWriteData();

	//
	// process all writes that have been pulled to the side.
	//
	while (  WritesToBeProcessed.GetNext() != &WritesToBeProcessed )
	{
		BOOL			fIOServiced;
		CWriteIOData	*pTempWrite;
		CSocketPort		*pSocketPort;


		pTempWrite = CWriteIOData::WriteDataFromBilink( WritesToBeProcessed.GetNext() );
		pTempWrite->m_OutstandingWriteListLinkage.RemoveFromList();
		pSocketPort = pTempWrite->SocketPort();
		DNASSERT( pSocketPort != NULL );

		fIOServiced = pSocketPort->SendFromWriteQueue();
		pSocketPort->SendComplete( pTempWrite, pTempWrite->m_Win9xSendHResult );
		pSocketPort->DecRef();
	}
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::CompleteOutstandingReceives - check for completed receives and
//		indicate completion for them.
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CompleteOutstandingReceives"

void	CThreadPool::CompleteOutstandingReceives( void )
{
	CBilink		*pCurrentOutstandingRead;
	CBilink		ReadsToBeProcessed;
#ifdef DEBUG
	DWORD		dwNumReads = 0;
	DWORD		dwNumReadsCompleteSuccess = 0;
	DWORD		dwNumReadsCompleteFailure = 0;
#endif // DEBUG


	ReadsToBeProcessed.Initialize();
	LockReadData();

	//
	// Loop through the list of outstanding reads and pull out the ones that need
	// to be serviced.  We don't want to service them while the read data lock
	// is taken.
	//
	pCurrentOutstandingRead = m_OutstandingReadList.GetNext();
	while ( pCurrentOutstandingRead != &m_OutstandingReadList )
	{
		CReadIOData		*pReadIOData;
		DWORD			dwFlags;


		pReadIOData = CReadIOData::ReadDataFromBilink( pCurrentOutstandingRead );
		pCurrentOutstandingRead = pCurrentOutstandingRead->GetNext();

#ifdef DEBUG
		dwNumReads++;
#endif // DEBUG

		//
		// Make sure this operation is really pending before attempting to check
		// for completion.  It's possible that the read was added to the list, but
		// we haven't actually called Winsock yet.
		//
		if ( pReadIOData->Win9xOperationPending() != FALSE )
		{
			if ( p_WSAGetOverlappedResult( pReadIOData->SocketPort()->GetSocket(),
										   pReadIOData->Overlap(),
										   &pReadIOData->m_dwOverlappedBytesReceived,
										   FALSE,
										   &dwFlags
										   ) != FALSE )
			{
				//
				// Overlapped results will complete with success and zero bytes
				// transferred when the overlapped structure is checked BEFORE
				// the operation has really been submitted.  This is a possibility
				// with the current code.  To combat this, check the received bytes
				// for zero (the return when the overlapped request was checked before
				// it was sent) and check the return address (it's possible that someone
				// really sent zero bytes).
				//
				DBG_CASSERT( ERROR_SUCCESS == 0 );
				if ( ( pReadIOData->m_dwOverlappedBytesReceived != 0 ) &&
					 ( pReadIOData->m_pSourceSocketAddress->IsUndefinedHostAddress() == FALSE ) )
				{
#ifdef DEBUG
					dwNumReadsCompleteSuccess++;
#endif // DEBUG
					pReadIOData->m_ReceiveWSAReturn = ERROR_SUCCESS;
				}
				else
				{
					DPFX(DPFPREP, 8, "Read data 0x%p overlapped bytes received == 0 or source address is undefined host address, ignoring completion.",
						pReadIOData);
					goto SkipReceiveCompletion;
				}
			}
			else
			{
				pReadIOData->m_ReceiveWSAReturn = p_WSAGetLastError();
				switch( pReadIOData->m_ReceiveWSAReturn )
				{
					//
					// If this I/O operation is incomplete, don't send notification to the user.
					//
					case WSA_IO_INCOMPLETE:
					{
						DPFX(DPFPREP, 10, "Read data 0x%p still incomplete (0x%lx, macro result = %i).",
							pReadIOData, (pReadIOData->Overlap()->Internal),
							HasOverlappedIoCompleted(pReadIOData->Overlap()));
						goto SkipReceiveCompletion;
						break;
					}

					//
					// socket was closed with an outstanding read, no problem
					// Win9x reports 'WSAENOTSOCK'
					// WinNT reports 'ERROR_OPERATION_ABORTED'
					//
					// If this is an indication that the connection was reset,
					// pass it on to the socket port so it can issue another
					// read
					//
					case ERROR_OPERATION_ABORTED:
					case WSAENOTSOCK:
					case WSAECONNRESET:
					{
						DPFX(DPFPREP, 1, "Read data 0x%p failed with closing err %u/0x%lx.",
							pReadIOData, pReadIOData->m_ReceiveWSAReturn,
							pReadIOData->m_ReceiveWSAReturn);
						break;
					}

					default:
					{
						DPFX(DPFPREP, 0, "Read data 0x%p failed, err %u/0x%lx!",
							pReadIOData, pReadIOData->m_ReceiveWSAReturn,
							pReadIOData->m_ReceiveWSAReturn);
						DisplayWinsockError( 0, pReadIOData->m_ReceiveWSAReturn );

						// debug me!
						DNASSERT( FALSE );

						break;
					}
				}

#ifdef DEBUG
				dwNumReadsCompleteFailure++;
#endif // DEBUG
			}

			DNASSERT( pReadIOData->Win9xOperationPending() != FALSE );
			pReadIOData->SetWin9xOperationPending( FALSE );

			pReadIOData->m_OutstandingReadListLinkage.RemoveFromList();
			pReadIOData->m_OutstandingReadListLinkage.InsertBefore( &ReadsToBeProcessed );
		}
		else
		{
			DPFX(DPFPREP, 7, "Read data 0x%p is not marked as pending, so not checking for completion.",
				pReadIOData);
		}

SkipReceiveCompletion:
		//
		// the following line is present to prevent the compiler from whining
		// about a blank line
		//
		;
	}

	UnlockReadData();


#ifdef DEBUG
	DPFX(DPFPREP, 9, "(0x%p) %u reads, %u completed successfully, %u completed with failure.",
		this, dwNumReads, dwNumReadsCompleteSuccess, dwNumReadsCompleteFailure);

	dwNumReads = dwNumReadsCompleteSuccess + dwNumReadsCompleteFailure;
#endif // DEBUG

	//
	// loop through the list of reads that have completed and dispatch them
	//
	while ( ReadsToBeProcessed.GetNext() != &ReadsToBeProcessed )
	{
		CReadIOData		*pTempRead;
		CSocketPort		*pSocketPort;


		pTempRead = CReadIOData::ReadDataFromBilink( ReadsToBeProcessed.GetNext() );
		pTempRead->m_OutstandingReadListLinkage.RemoveFromList();
		
#ifdef DEBUG
		DNASSERT(dwNumReads > 0);
		dwNumReads--;
#endif // DEBUG

		pSocketPort = pTempRead->SocketPort();
		DNASSERT( pSocketPort != NULL );
		pSocketPort->Winsock2ReceiveComplete( pTempRead );
	}

	DNASSERT(dwNumReads == 0);
}
//**********************************************************************
#endif // WIN95


//**********************************************************************
// ------------------------------
// CThreadPool::HandleNATHelpUpdate - handle a NAT Help update event
//
// Entry:		Timer interval if update is occurring periodically, or
//				NULL if a triggered event.
//				This function may take a while, because updating NAT Help
//				can block.
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::HandleNATHelpUpdate"

void	CThreadPool::HandleNATHelpUpdate( DN_TIME * const pTimerInterval )
{
	HRESULT		hr;
	DWORD		dwTemp;
	DPNHCAPS	dpnhcaps;
	DN_TIME		NATHelpRetryTime;
	BOOL		fModifiedRetryInterval;
	DN_TIME		FirstUpdateTime;
	DN_TIME		CurrentTime;
	DN_TIME		Temp;
	DWORD		dwNumGetCaps = 0;


	DNASSERT(IsNATHelpLoaded());


	Lock();

	//
	// Prevent multiple threads from trying to update NAT Help status at the same
	// time.  If we're a duplicate, just bail.
	//

	if (m_dwNATHelpUpdateThreadID != 0)
	{
		DPFX(DPFPREP, 1, "Thread %u/0x%x already handling NAT Help update, not processing again (thread pool = 0x%p, timer = 0x%p).",
			m_dwNATHelpUpdateThreadID, m_dwNATHelpUpdateThreadID, this, pTimerInterval);
		
		Unlock();
		
		return;
	}

	m_dwNATHelpUpdateThreadID = GetCurrentThreadId();
	
	if (! m_fNATHelpTimerJobSubmitted)
	{
		DPFX(DPFPREP, 1, "Handling NAT Help update without a NAT refresh timer job submitted (thread pool = 0x%p).",
			this);
		DNASSERT(pTimerInterval == NULL);
	}
	
	Unlock();


	DPFX(DPFPREP, 6, "Beginning thread pool 0x%p NAT Help update.", this);

	
	//
	// Initialize the timer values.
	//
	NATHelpRetryTime.Time32.TimeHigh	= 0;
	NATHelpRetryTime.Time32.TimeLow		= -1;

	FirstUpdateTime.Time32.TimeHigh		= 0;
	FirstUpdateTime.Time32.TimeLow		= 0;


	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		if (g_papNATHelpObjects[dwTemp] != NULL)
		{
			ZeroMemory(&dpnhcaps, sizeof(dpnhcaps));
			dpnhcaps.dwSize = sizeof(dpnhcaps);

			hr = IDirectPlayNATHelp_GetCaps(g_papNATHelpObjects[dwTemp],
											&dpnhcaps,
											DPNHGETCAPS_UPDATESERVERSTATUS);
			switch (hr)
			{
				case DPNH_OK:
				{
					//
					// See if this is the shortest interval.
					//
					if (dpnhcaps.dwRecommendedGetCapsInterval < NATHelpRetryTime.Time32.TimeLow)
					{
						NATHelpRetryTime.Time32.TimeLow = dpnhcaps.dwRecommendedGetCapsInterval;
					}
					break;
				}

				case DPNHSUCCESS_ADDRESSESCHANGED:
				{
					DPFX(DPFPREP, 1, "NAT Help index %u indicated public addresses changed.",
						dwTemp);

					//
					// We don't actually store any public address information,
					// we query it each time.  Therefore we don't need to
					// actually do anything with the change notification.
					//


					//
					// See if this is the shortest interval.
					//
					if (dpnhcaps.dwRecommendedGetCapsInterval < NATHelpRetryTime.Time32.TimeLow)
					{
						NATHelpRetryTime.Time32.TimeLow = dpnhcaps.dwRecommendedGetCapsInterval;
					}
					break;
				}

				case DPNHERR_OUTOFMEMORY:
				{
					//
					// This should generally only happen in stress.  We'll
					// continue on to other NAT help objects, and hope we
					// aren't totally hosed.
					//

					DPFX(DPFPREP, 0, "NAT Help index %u returned out-of-memory error!  Continuing.",
						dwTemp);
					break;
				}
				
				default:
				{
					//
					// Some other unknown error occurred.
					//
					DNASSERT(! "Unknown error returned from IDirectPlayNATHelp_GetCaps!");
					break;
				}
			}


			//
			// Save the current time, if this is the first GetCaps.
			//
			if (dwNumGetCaps == 0)
			{
				DNTimeGet(&FirstUpdateTime);
			}

			dwNumGetCaps++;
		}
		else
		{
			//
			// No DPNATHelp object in that slot.
			//
		}
	}


	//
	// Assert that at least one NAT Help object is loaded.
	//
	DNASSERT(dwNumGetCaps > 0);



	DNTimeGet(&CurrentTime);

	//
	// If we don't have an infinite timer, we may need to make some adjustments.
	//
	if (NATHelpRetryTime.Time32.TimeLow != -1)
	{
		DN_TIME		TimeElapsed;


		//
		// Find out how much time has elapsed since the first GetCaps completed.
		//
		DNTimeSubtract(&CurrentTime, &FirstUpdateTime, &TimeElapsed);

		//
		// Remove it from the retry interval.
		//
		DNTimeSubtract(&NATHelpRetryTime, &TimeElapsed, &Temp);
		memcpy(&NATHelpRetryTime, &Temp, sizeof(NATHelpRetryTime));
	}
	else
	{
		DPFX(DPFPREP, 3, "NAT Help refresh timer for thread pool 0x%p is set to INFINITE.",
			this);

		//
		// Make sure the high DWORD is -1 as well.
		//
		NATHelpRetryTime.Time32.TimeHigh = -1;
	}



	//
	// Modify the next time when we should refresh the NAT Help information based
 	// on the reported recommendation.
	//
	if (pTimerInterval != NULL)
	{
		DPFX(DPFPREP, 6, "Modifying NAT Help refresh timer for thread pool 0x%p in place (was %u ms, changing to %u).",
			this, pTimerInterval->Time32.TimeLow, NATHelpRetryTime.Time32.TimeLow);

		pTimerInterval->Time32.TimeLow = NATHelpRetryTime.Time32.TimeLow;
	}
	else
	{
		//
		// Add the interval to the current time to find the new retry time.
		//
		DNTimeAdd(&CurrentTime, &NATHelpRetryTime, &Temp);


		DPFX(DPFPREP, 6, "Modifying NAT Help refresh timer for thread pool 0x%p to run at offset %u (in %u ms).",
			this, Temp.Time32.TimeLow, NATHelpRetryTime.Time32.TimeLow);


		//
		// Try to modify the existing timer job.  There is a race where the
		// first one may not have even been submitted yet.  In that case,
		// don't try to resubmit it here.  Let the other thread submit it,
		// since it assumes that no one else has already.
		//
		fModifiedRetryInterval = ModifyTimerJobNextRetryTime(this, &Temp);
		if (! fModifiedRetryInterval)
		{
			DPFX(DPFPREP, 0, "Unable to modify NAT Help refresh timer (thread pool 0x%p)!",
				this);
		}
	}


	//
	// Now that we're done handling the update, let other threads do what they
	// want.
	//
	Lock();
	DNASSERT(m_dwNATHelpUpdateThreadID == GetCurrentThreadId());
	m_dwNATHelpUpdateThreadID = 0;
	Unlock();

}
//**********************************************************************




#ifdef DEBUG

//**********************************************************************
// ------------------------------
// CThreadPool::DebugPrintOutstandingReads - print all current outstanding reads
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::DebugPrintOutstandingReads"

void	CThreadPool::DebugPrintOutstandingReads( void )
{
	CBilink *		pBilink;
	CReadIOData *	pReadData;
	CSocketPort *	pSocketPort;

	
	DPFX(DPFPREP, 4, "Thread pool 0x%p outstanding reads:", this);


	this->LockReadData();

	pBilink = this->m_OutstandingReadList.GetNext();
	while (pBilink != &this->m_OutstandingReadList)
	{
		pReadData = CReadIOData::ReadDataFromBilink(pBilink);
		pBilink = pBilink->GetNext();

		pSocketPort = pReadData->SocketPort();
		if (pSocketPort != NULL)
		{
			DPFX(DPFPREP, 4, "     Read data 0x%p, socketport = 0x%p, SPData = 0x%p, internal = 0x%lx, complete = %i",
				pReadData, pSocketPort, pSocketPort->GetSPData(),
				(pReadData->Overlap()->Internal),
				HasOverlappedIoCompleted(pReadData->Overlap()));
		}
		else
		{
			DPFX(DPFPREP, 4, "     Read data 0x%p, NULL socketport, internal = 0x%lx, complete = %i",
 				pReadData, (pReadData->Overlap()->Internal),
 				HasOverlappedIoCompleted(pReadData->Overlap()));
		}
	}
	
	this->UnlockReadData();
}
//**********************************************************************




//**********************************************************************
// ------------------------------
// CThreadPool::DebugPrintOutstandingWrites - print all current outstanding writes
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::DebugPrintOutstandingWrites"

void	CThreadPool::DebugPrintOutstandingWrites( void )
{
	CBilink *		pBilink;
	CWriteIOData *	pWriteData;
	CSocketPort *	pSocketPort;

	
	DPFX(DPFPREP, 4, "Thread pool 0x%p outstanding writes:", this);


	this->LockWriteData();

	pBilink = this->m_OutstandingWriteList.GetNext();
	while (pBilink != &this->m_OutstandingWriteList)
	{
		pWriteData = CWriteIOData::WriteDataFromBilink(pBilink);
		pBilink = pBilink->GetNext();

		pSocketPort = pWriteData->SocketPort();
		if (pSocketPort != NULL)
		{
			DPFX(DPFPREP, 4, "     Write data 0x%p, socketport = 0x%p, SPData = 0x%p, internal = 0x%lx, complete = %i",
				pWriteData, pSocketPort, pSocketPort->GetSPData(),
				(pWriteData->Overlap()->Internal),
				HasOverlappedIoCompleted(pWriteData->Overlap()));
		}
		else
		{
			DPFX(DPFPREP, 4, "     Write data 0x%p, NULL socketport, internal = 0x%lx, complete = %i",
				pWriteData, (pWriteData->Overlap()->Internal),
				HasOverlappedIoCompleted(pWriteData->Overlap()));
		}
	}
	
	this->UnlockWriteData();
}
//**********************************************************************

#endif // DEBUG



#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::PrimaryWin9xThread - main thread to do everything that the SP is
//		supposed to do under Win9x.
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is allocated for this thread and must be
//			deallocated by this thread when it exits
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::PrimaryWin9xThread"

DWORD	WINAPI	CThreadPool::PrimaryWin9xThread( void *pParam )
{
	WIN9X_CORE_DATA		CoreData;
	DN_TIME				CurrentTime;
	DWORD				dwMaxWaitTime;
	DN_TIME				DeltaT;
	BOOL				fComInitialized;

	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;
	FD_SET 			*const pSocketSet = &pThisThreadPool->m_SocketSet;

	
	DNASSERT( pParam != NULL );
	DNASSERT( pThisThreadPool != NULL );
	DNASSERT( pSocketSet != NULL );

	DPFX(DPFPREP, 4, "Entering [0x%p]", pParam);

	//
	// initialize
	//
	memset( &CoreData, 0x00, sizeof CoreData );
	fComInitialized = FALSE;

	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			fComInitialized = TRUE;
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DPFX(DPFPREP, 0, "Primary Win9x thread failed to initialize COM!" );
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// Clear socket data.  Since we need to correlate a CSocketPort with a SOCKET,
	// we're going to manage the FD_SET ourselves.  See Winsock.h for the FD_SET
	// structure definition.
	//
	DBG_CASSERT( OFFSETOF( FD_SET, fd_count ) == 0 );
	DNASSERT( CoreData.fTimerJobsActive == FALSE );

	//
	// set enums to happen infinitely in the future
	//
	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );

	//
	// set wait handles
	//
	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
	CoreData.hWaitHandles[ EVENT_INDEX_NATHELP_UPDATE ] = INVALID_HANDLE_VALUE;
	
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
	
	//
	// go until we're told to stop
	//
	CoreData.fLooping = TRUE;
	while ( CoreData.fLooping != FALSE )
	{
		DWORD	dwWaitReturn;

		
		//
		// Update the job time so we know how long to wait.  We can
		// only get here if a socket was just added to the socket list, or
		// we've been servicing sockets.
		//
		DNTimeGet( &CurrentTime );
		if ( DNTimeCompare( &CurrentTime, &CoreData.NextTimerJobTime ) >= 0 )
		{
			pThisThreadPool->LockTimerData();
			CoreData.fTimerJobsActive = pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList,
																		   &CoreData.NextTimerJobTime );
			if ( CoreData.fTimerJobsActive != FALSE )
			{
				DPFX(DPFPREP, 9, "There are active jobs left with Winsock1 sockets active." );
			}
			pThisThreadPool->UnlockTimerData();
		}

		DNTimeSubtract( &CoreData.NextTimerJobTime, &CurrentTime, &DeltaT );

		//
		// Note that data is lost on 64 bit machines.
		//
		dwMaxWaitTime = static_cast<DWORD>( SaturatedWaitTime( DeltaT ) );


		//
		// Check for Winsock1 sockets.  If there are some around, do a quick poll
		// of them to check of I/O before entering the main Winsock2 loop for
		// the real timing.
		//
		pThisThreadPool->Lock();
		if ( pSocketSet->fd_count != 0 )
		{
			pThisThreadPool->Unlock();
			
			//
			// if there is Winsock1 I/O that gets serviced, loop immediately.  If
			// there were no Winsock1 sockets serviced, pause before polling again.
			//
			if ( pThisThreadPool->CheckWinsock1IO( pSocketSet ) != FALSE )
			{
				dwMaxWaitTime = 0;
			}
			else
			{
				if ( g_dwSelectTimeSlice < dwMaxWaitTime )
				{
					dwMaxWaitTime = g_dwSelectTimeSlice;
				}
			}
		}
		else
		{
			pThisThreadPool->Unlock();
		}


		//
		// Check Winsock2 sockets.
		//
		dwWaitReturn = WaitForMultipleObjectsEx( (LENGTHOF( CoreData.hWaitHandles ) - 1),	// count of handles except the NATHelp event
												 CoreData.hWaitHandles,						// handles to wait on
												 FALSE,										// don't wait for all to be signalled
												 dwMaxWaitTime,								// wait timeout
												 TRUE										// we're alertable for APCs
												 );
		switch ( dwWaitReturn )
		{
			//
			// timeout, don't do anything, we'll probably process timer jobs on
			// the next loop
			//
			case WAIT_TIMEOUT:
			{
				break;
			}
			
			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
			{
				pThisThreadPool->ProcessWin9xEvents( &CoreData, THREAD_TYPE_PRIMARY_WIN9X );
				break;
			}

			//
			// There are I/O completion routines scheduled on this thread.
			// This is not a good thing!
			//
			case WAIT_IO_COMPLETION:
			{
				DPFX(DPFPREP, 1, "WARNING: APC was serviced on the primary Win9x IO service thread!  What is the application doing??" );
				break;
			}

			//
			// wait failed
			//
			case WAIT_FAILED:
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Primary Win9x thread wait failed!" );
				DisplayDNError( 0, dwError );
				break;
			}

			//
			// problem
			//
			default:
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Primary Win9x thread unknown problem in wait!" );
				DisplayDNError( 0, dwError );
				DNASSERT( FALSE );
				break;
			}
		}
	}

	pThisThreadPool->DecrementActiveThreadCount();

	DNFree( pParam );

	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}


	DPFX(DPFPREP, 4, "Exiting.");

	return	0;
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::SecondaryWin9xThread - secondary thread to handle only Win9x
//		I/O so developers get bit faster with multithreading issues if they're
//		developing on Win9x.  This thread will only handle Winsock2 based TCP
//		I/O.  Winsock 1 is not deemed important enough to hack the rest of the
//		code to work with two threads.
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is allocated for this thread and must be
//			deallocated by this thread when it exits
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SecondaryWin9xThread"

DWORD	WINAPI	CThreadPool::SecondaryWin9xThread( void *pParam )
{
	WIN9X_CORE_DATA		CoreData;
	BOOL				fComInitialized;
	CThreadPool		*const pThisThreadPool = static_cast<WIN9X_THREAD_DATA *>( pParam )->pThisThreadPool;


	DPFX(DPFPREP, 4, "Entering [0x%p]", pParam);

	
	DNASSERT( pParam != NULL );
	DNASSERT( pThisThreadPool != NULL );

	//
	// initialize
	//
	memset( &CoreData, 0x00, sizeof CoreData );
	fComInitialized = FALSE;

	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			fComInitialized = TRUE;
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DPFX(DPFPREP, 0, "Secondary Win9x thread failed to initialize COM!");
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// set enums to happen infinitely in the future
	//
	DNASSERT( CoreData.fTimerJobsActive == FALSE );
	memset( &CoreData.NextTimerJobTime, 0xFF, sizeof( CoreData.NextTimerJobTime ) );

	//
	// set wait handles
	//
	CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
	CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();
	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] = pThisThreadPool->GetWinsock2SendCompleteEvent();
	CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] = pThisThreadPool->GetWinsock2ReceiveCompleteEvent();
	CoreData.hWaitHandles[ EVENT_INDEX_NATHELP_UPDATE ] = pThisThreadPool->GetNATHelpUpdateEvent();
	
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_PENDING_JOB ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] != NULL );
	DNASSERT( CoreData.hWaitHandles[ EVENT_INDEX_NATHELP_UPDATE ] != NULL );
	
	//
	// go until we're told to stop
	//
	CoreData.fLooping = TRUE;
	while ( CoreData.fLooping != FALSE )
	{
		DWORD	dwWaitReturn;

		
		//
		// Check Winsock2 sockets.
		//
		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( CoreData.hWaitHandles ),		// count of handles
												 CoreData.hWaitHandles,					// handles to wait on
												 FALSE,									// don't wait for all to be signalled
												 INFINITE,								// wait timeout (forever)
												 TRUE									// we're alertable for APCs
												 );
		switch ( dwWaitReturn )
		{
			//
			// timeout, shouldn't ever be here!!
			//
			case WAIT_TIMEOUT:
			{
				DNASSERT( FALSE );
				break;
			}

			case ( WAIT_OBJECT_0 + EVENT_INDEX_PENDING_JOB ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ):
			case ( WAIT_OBJECT_0 + EVENT_INDEX_NATHELP_UPDATE ):
			{
				pThisThreadPool->ProcessWin9xEvents( &CoreData, THREAD_TYPE_SECONDARY_WIN9X );
				break;
			}

			//
			// There are I/O completion routines scheduled on this thread.
			// This is not a good thing!
			//
			case WAIT_IO_COMPLETION:
			{
				DPFX(DPFPREP, 1, "WARNING: APC was serviced on the secondary Win9x IO service thread!  What is the application doing??" );
				break;
			}

			//
			// wait failed
			//
			case WAIT_FAILED:
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Secondary Win9x thread wait failed!" );
				DisplayDNError( 0, dwError );
				break;
			}

			//
			// problem
			//
			default:
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Secondary Win9x thread unknown problem in wait!" );
				DisplayDNError( 0, dwError );
				DNASSERT( FALSE );
				break;
			}
		}
	}

	pThisThreadPool->DecrementActiveThreadCount();

	DNFree( pParam );

	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}


	DPFX(DPFPREP, 4, "Exiting.");

	return	0;
}
//**********************************************************************
#endif // WIN95


#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::WinNTIOCompletionThread - thread to service I/O completion port
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is allocated for this thread and must be
//			deallocated by this thread when it exits
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WinNTIOCompletionThread"

DWORD	WINAPI	CThreadPool::WinNTIOCompletionThread( void *pParam )
{
	IOCOMPLETION_THREAD_DATA	*pInput;
	BOOL	fLooping;
	HANDLE	hIOCompletionPort;
	BOOL	fComInitialized;


	DPFX(DPFPREP, 4, "Entering [0x%p]", pParam);
	

	DNASSERT( pParam != NULL );

	//
	// initialize
	//
	pInput = static_cast<IOCOMPLETION_THREAD_DATA*>( pParam );
	DNASSERT( pInput->pThisThreadPool != NULL );
	fLooping = TRUE;
	hIOCompletionPort = pInput->pThisThreadPool->m_hIOCompletionPort;
	DNASSERT( hIOCompletionPort != NULL );
	fComInitialized = FALSE;

	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			fComInitialized = TRUE;
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DNASSERT( FALSE );
			DPFX(DPFPREP, 0, "Failed to initialize COM!" );
			break;
		}
	}

	//
	// go until we're told to stop
	//
	while ( fLooping != FALSE )
	{
		BOOL		fStatusReturn;
		DWORD		dwBytesRead;
		ULONG_PTR	uCompletionKey;
		OVERLAPPED	*pOverlapped;


		// get data from completion port
		DNASSERT( hIOCompletionPort != NULL );
		fStatusReturn = GetQueuedCompletionStatus( hIOCompletionPort,	// handle of completion port
												   &dwBytesRead,		// pointer to number of bytes read
												   &uCompletionKey,		// pointer to completion key
												   &pOverlapped,		// pointer to overlapped structure
												   INFINITE				// wait forever
												   );
		// did we fail miserably?
		if ( ( fStatusReturn == FALSE ) && ( pOverlapped == FALSE ) )
		{
			DWORD	dwError;


			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Problem getting item from completion port!" );
			DisplayErrorCode( 0, dwError );
		}
		else
		{
			// what happened?
			switch ( uCompletionKey )
			{
				// ReadFile or WriteFile completed
				case IO_COMPLETION_KEY_IO_COMPLETE:
				{
					CIOData		*pIOData;


					DNASSERT( pOverlapped != NULL );
					pIOData = CIOData::IODataFromOverlap( pOverlapped );
						
					if ( pIOData->IsWriteOperation() != FALSE )
					{
						HRESULT			hSendResult;
						BOOL			fDataSent;
						CWriteIOData	*pWriteData;
						CSocketPort		*pSocketPort;


						if ( fStatusReturn == FALSE )
						{
							hSendResult = DPNERR_GENERIC;
						}
						else
						{
							hSendResult = DPN_OK;
						}

						pWriteData = static_cast<CWriteIOData*>( pIOData );
						fDataSent = pWriteData->SocketPort()->SendFromWriteQueue();
						pSocketPort = pWriteData->SocketPort();
						pSocketPort->SendComplete( pWriteData, hSendResult );
						pSocketPort->DecRef();
					}
					else
					{
						DWORD		dwError;
						CReadIOData	*pReadData;

						
						if ( fStatusReturn == FALSE )
						{
							dwError = GetLastError();
						}
						else
						{
							dwError = ERROR_SUCCESS;
						}

						pReadData = static_cast<CReadIOData*>( pIOData );
						pReadData->m_ReceiveWSAReturn = dwError;
						pReadData->m_dwOverlappedBytesReceived = dwBytesRead;
						pReadData->SocketPort()->Winsock2ReceiveComplete( pReadData );
					}

					break;
				}

				//
				// This thread is quitting, it's possible that the SP is closing,
				// or that the thread pool is being trimmed.
				//
				case IO_COMPLETION_KEY_SP_CLOSE:
				{
				    DPFX(DPFPREP, 8, "IOCompletion SP_CLOSE" );
					fLooping = FALSE;
					break;
				}

				//
				// a new job was submitted to the job queue, or the SP is closing from above
				//
				case IO_COMPLETION_KEY_NEW_JOB:
				{
					THREAD_POOL_JOB	*pJobInfo;

					//
					// SP is still running, process our job
					//
					pJobInfo = pInput->pThisThreadPool->GetWorkItem();
					if ( pJobInfo != NULL )
					{
						switch ( pJobInfo->JobType )
						{
							//
							// enum refresh
							//
							case JOB_REFRESH_TIMER_JOBS:
							{
							    DPFX(DPFPREP, 8, "IOCompletion job REFRESH_TIMER_JOBS" );
							    DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );

							    pInput->pThisThreadPool->WakeNTTimerThread();

							    break;
							}

							//
							// issue callback for this job
							//
							case JOB_DELAYED_COMMAND:
							{
							    DPFX(DPFPREP, 8, "IOCompletion job DELAYED_COMMAND" );
							    DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );

							    pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
							    break;
							}

							//
							// other job
							//
							default:
							{
								DPFX(DPFPREP, 0, "IOCompletion job unknown!" );
								DNASSERT( FALSE );
								break;
							}
						}

						pJobInfo->JobType = JOB_UNINITIALIZED;
						pInput->pThisThreadPool->m_JobPool.Release( &pInput->pThisThreadPool->m_JobPool, pJobInfo );
					}

					break;
				}

				//
				// NAT Help needs servicing
				//
				case IO_COMPLETION_KEY_NATHELP_UPDATE:
				{
				    DPFX(DPFPREP, 8, "IOCompletion NATHELP_UPDATE" );
					pInput->pThisThreadPool->HandleNATHelpUpdate( NULL );
					break;
				}

				//
				// unknown I/O completion message type
				//
				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}
		}
	}

	pInput->pThisThreadPool->DecrementActiveNTCompletionThreadCount();
	DNFree( pInput );

	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}


	DPFX(DPFPREP, 4, "Exiting.");

	return	0;
}
//**********************************************************************
#endif // WINNT

#ifdef WINNT
//**********************************************************************
// ------------------------------
// CThreadPool::WinNTTimerThread - timer thread for NT
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
//
// Note:	The startup parameter is a static memory chunk and cannot be freed.
//			Cleanup of this memory is the responsibility of this thread.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WinNTTimerThread"

DWORD	WINAPI	CThreadPool::WinNTTimerThread( void *pParam )
{
	CThreadPool	*pThisThreadPool;
	BOOL	fLooping;
	DWORD	dwWaitReturn;
	DN_TIME	NextEnumTime;
	HANDLE	hEvents[ 2 ];
	BOOL	fComInitialized;


	DPFX(DPFPREP, 4, "Entering [0x%p]", pParam);
	
	DNASSERT( pParam != NULL );

	//
	// initialize
	//
	pThisThreadPool = static_cast<CThreadPool*>( pParam );
	DNASSERT( pThisThreadPool->m_JobQueue.GetPendingJobHandle() != NULL );

	memset( &NextEnumTime, 0, sizeof( NextEnumTime ) );

	hEvents[ EVENT_INDEX_STOP_ALL_THREADS ] = pThisThreadPool->m_hStopAllThreads;
	hEvents[ EVENT_INDEX_WAKE_NT_TIMER_THREAD ] = pThisThreadPool->m_JobQueue.GetPendingJobHandle();

	fComInitialized = FALSE;


	//
	// before we do anything we need to make sure COM is happy
	//
	switch ( COM_CoInitialize( NULL ) )
	{
		//
		// no problem
		//
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		//
		// COM already initialized, huh?
		//
		case S_FALSE:
		{
			DNASSERT( FALSE );
			fComInitialized = TRUE;
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DNASSERT( FALSE );
			DPFX(DPFPREP, 0, "Failed to initialize COM!" );
			break;
		}
	}



	//
	// there were no active enums so we want to wait forever for something to
	// happen
	//
	fLooping = TRUE;

	//
	// go until we're told to stop
	//
	while ( fLooping != FALSE )
	{
		DN_TIME		CurrentTime;
		DN_TIME		DeltaT;
		DWORD		dwMaxWaitTime;


		DNTimeGet( &CurrentTime );

		if ( DNTimeCompare( &NextEnumTime, &CurrentTime ) <= 0 )
		{

			//
			// acknowledge that we've handled this event and then process the
			// enums
			//
			pThisThreadPool->LockTimerData();

			if ( ResetEvent( hEvents[ EVENT_INDEX_WAKE_NT_TIMER_THREAD ] ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Problem resetting event to wake NT timer thread!" );
				DisplayErrorCode( 0, dwError );
			}

			pThisThreadPool->ProcessTimerJobs( &pThisThreadPool->m_TimerJobList, &NextEnumTime );
			pThisThreadPool->UnlockTimerData();
		}
		else
		{
			DPFX(DPFPREP, 7, "Not time for next enum (next = %u, current = %u)",
				NextEnumTime.Time32.TimeLow, CurrentTime.Time32.TimeLow);
		}

		DNTimeSubtract( &NextEnumTime, &CurrentTime, &DeltaT );

		//
		// Note that data is lost on 64 bit machines.
		//
		dwMaxWaitTime = static_cast<DWORD>( pThisThreadPool->SaturatedWaitTime( DeltaT ) );

		if (dwMaxWaitTime == INFINITE)
		{
			DPFX(DPFPREP, 9, "Waiting forever for next timed job.");
		}
		else
		{
			DPFX(DPFPREP, 9, "Waiting %u ms until next timed job.", dwMaxWaitTime);
		}

		dwWaitReturn = WaitForMultipleObjectsEx( LENGTHOF( hEvents ),	// number of events
												 hEvents,				// event list
												 FALSE,					// wait for any one event to be signalled
												 dwMaxWaitTime,			// timeout
												 TRUE					// be nice and allow APCs
												 );
		switch ( dwWaitReturn )
		{
			//
			// SP closing
			//
			case ( WAIT_OBJECT_0 + EVENT_INDEX_STOP_ALL_THREADS ):
			{
				DPFX(DPFPREP, 8, "NT timer thread thread detected SPClose!" );
				fLooping = FALSE;
				break;
			}

			//
			// Enum wakeup event, someone added an enum to the list.  Clear
			// our enum time and go back to the top of the loop where we
			// will process enums.
			//
			case ( WAIT_OBJECT_0 + EVENT_INDEX_WAKE_NT_TIMER_THREAD ):
			{
				memset( &NextEnumTime, 0x00, sizeof( NextEnumTime ) );
				break;
			}

			//
			// Wait timeout.  We're probably going to process enums, go back
			// to the top of the loop.
			//
			case WAIT_TIMEOUT:
			{
				break;
			}

			//
			// wait failed
			//
			case WAIT_FAILED:
			{
				DPFX(DPFPREP, 0, "NT timer thread WaitForMultipleObjects failed: 0x%x", dwWaitReturn );
				DNASSERT( FALSE );
				break;
			}

			//
			// problem
			//
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}

	DPFX(DPFPREP, 8, "NT timer thread is exiting!" );
	pThisThreadPool->LockTimerData();

	pThisThreadPool->m_fNTTimerThreadRunning = FALSE;
	pThisThreadPool->DecrementActiveThreadCount();

	pThisThreadPool->UnlockTimerData();


	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}


	DPFX(DPFPREP, 4, "Exiting.");

	return	0;
}
//**********************************************************************
#endif // WINNT

//**********************************************************************
// ------------------------------
// CThreadPool::DialogThreadProc - thread proc for spawning dialogs
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::DialogThreadProc"

DWORD WINAPI	CThreadPool::DialogThreadProc( void *pParam )
{
	const DIALOG_THREAD_PARAM	*pThreadParam;
	BOOL	fComInitialized;


	//
	// Initialize COM.  If this fails, we'll have problems later.
	//
	fComInitialized = FALSE;
	switch ( COM_CoInitialize( NULL ) )
	{
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		case S_FALSE:
		{
			DNASSERT( FALSE );
			fComInitialized = TRUE;
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DPFX(DPFPREP, 0, "Failed to initialize COM!" );
			DNASSERT( FALSE );
			break;
		}
	}
	
	DNASSERT( pParam != NULL );
	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );
	
	pThreadParam->pDialogFunction( pThreadParam->pContext );

	pThreadParam->pThisThreadPool->DecrementActiveThreadCount();
	DNFree( pParam );
	
	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
//**********************************************************************


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::ProcessWin9xEvents - process Win9x events
//
// Entry:		Pointer to core data
//				Thread type
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ProcessWin9xEvents"

void	CThreadPool::ProcessWin9xEvents( WIN9X_CORE_DATA *const pCoreData, const THREAD_TYPE ThreadType )
{
	DNASSERT( pCoreData != NULL );

	//
	// If delayed jobs are to be processed, process one.  Otherwise sleep and
	// let another thread pick up the jobs.
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_PENDING_JOB ], 0 ) )
	{
		case WAIT_TIMEOUT:
		{
			break;
		}

		case WAIT_OBJECT_0:
		{
			switch ( ThreadType )
			{
				case THREAD_TYPE_PRIMARY_WIN9X:
				{
					DPFX(DPFPREP, 8, "Primary Win9x thread has a pending job." );
					ProcessWin9xJob( pCoreData );
					
					break;
				}

				case THREAD_TYPE_SECONDARY_WIN9X:
				{
					//
					// Secondary threads are not allowed to process jobs (it messes
					// up enum timing), sleep and let someone else handle the job
					//
					DPFX(DPFPREP, 10, "Secondary Win9x thread ignoring pending job." );
					SleepEx( 0, TRUE );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	//
	// send complete
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			//
			// reset the event so it will be signalled again if anything
			// completes while we're scanning the pending write list
			//
			if ( ResetEvent( pCoreData->hWaitHandles[ EVENT_INDEX_WINSOCK_2_SEND_COMPLETE ] ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Failed to reset Winsock2 send event!" );
				DisplayErrorCode( 0, dwError );
			}

			DPFX(DPFPREP, 10, "(0x%p) Reset send event 0x%p.",
				this, pCoreData->hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ]);

			CompleteOutstandingSends();
			
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

		
	//
	// receive complete
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			//
			// reset the event so it will be signalled again if anything
			// completes while we're scanning the pending read list
			//
			if ( ResetEvent( pCoreData->hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ] ) == FALSE )
			{
				DWORD	dwError;


				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Failed to reset Winsock2 receive event!" );
				DisplayErrorCode( 0, dwError );
			}

			DPFX(DPFPREP, 10, "(0x%p) Reset receive event 0x%p.",
				this, pCoreData->hWaitHandles[ EVENT_INDEX_WINSOCK_2_RECEIVE_COMPLETE ]);
			
			CompleteOutstandingReceives();
			
			break;
		}

		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}


	//
	// The primary thread is not allowed to handle NAT Help updates since
	// they take a long time and thus interfere with processing jobs.  Only
	// attempt to handle it if this is a secondary thread.
	//
	if (ThreadType == THREAD_TYPE_SECONDARY_WIN9X)
	{
		switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_NATHELP_UPDATE ], 0 ) )
		{
			case WAIT_OBJECT_0:
			{
				DPFX(DPFPREP, 8, "Secondary Win9x thread handling NAT Help update event." );

				//
				// Reset the event so it will be signalled again if another update
				// is necessary while we're handling this one.
				//
				if ( ResetEvent( pCoreData->hWaitHandles[ EVENT_INDEX_NATHELP_UPDATE ] ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPFX(DPFPREP, 0, "Failed to reset NAT Help update event!" );
					DisplayErrorCode( 0, dwError );
				}

				DPFX(DPFPREP, 10, "(0x%p) Reset NAT Help event 0x%p.",
					this, pCoreData->hWaitHandles[ EVENT_INDEX_NATHELP_UPDATE ]);

				HandleNATHelpUpdate( NULL );

				break;
			}

			case WAIT_TIMEOUT:
			{
				break;
			}

			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}
	else
	{
		DNASSERT( ThreadType == THREAD_TYPE_PRIMARY_WIN9X );
	}


	//
	// stop all threads
	//
	switch ( WaitForSingleObject( pCoreData->hWaitHandles[ EVENT_INDEX_STOP_ALL_THREADS ], 0 ) )
	{
		case WAIT_OBJECT_0:
		{
			DPFX(DPFPREP, 8, "Win9x thread exit because SP closing." );
			pCoreData->fLooping = FALSE;
			break;
		}
	
		case WAIT_TIMEOUT:
		{
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::ProcessWin9xJob - process a Win9x job
//
// Entry:		Pointer core data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ProcessWin9xJob"

void	CThreadPool::ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData )
{
	THREAD_POOL_JOB	*pJobInfo;


	//
	// Remove and process a single job from the list.  If there is no job, skip
	// to the end of the function.
	//
	pJobInfo = GetWorkItem();

	if ( pJobInfo == NULL )
	{
		goto Exit;
	}

	switch ( pJobInfo->JobType )
	{
		//
		// enum refresh
		//
		case JOB_REFRESH_TIMER_JOBS:
		{
			DPFX(DPFPREP, 8, "WorkThread job REFRESH_TIMER_JOBS" );
			DNASSERT( pJobInfo->JobData.JobRefreshTimedJobs.uDummy == 0 );
			LockTimerData();
			pCoreData->fTimerJobsActive = ProcessTimerJobs( &m_TimerJobList, &pCoreData->NextTimerJobTime );
			UnlockTimerData();

			if ( pCoreData->fTimerJobsActive != FALSE )
			{
				DPFX(DPFPREP, 9, "There are active timer jobs left after processing a Win9x REFRESH_TIMER_JOBS." );
			}

			break;
		}

		//
		// issue callback for this job
		//
		case JOB_DELAYED_COMMAND:
		{
			DPFX(DPFPREP, 8, "WorkThread job DELAYED_COMMAND" );
			DNASSERT( pJobInfo->JobData.JobDelayedCommand.pCommandFunction != NULL );
			pJobInfo->JobData.JobDelayedCommand.pCommandFunction( pJobInfo );
			break;
		}

		//
		// other job
		//
		default:
		{
			DPFX(DPFPREP, 0, "WorkThread Win9x job unknown!" );
			DNASSERT( FALSE );
			break;
		}
	}

	DEBUG_ONLY( pJobInfo->JobType = JOB_UNINITIALIZED );
	m_JobPool.Release( &m_JobPool, pJobInfo );

Exit:
	return;
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
//
// Entry:		Pointer to sockets to watch
//
// Exit:		Boolean indicating whether I/O was serviced
//				TRUE = I/O serviced
//				FALSE = I/O not serviced
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CheckWinsock1IO"

BOOL	CThreadPool::CheckWinsock1IO( FD_SET *const pWinsock1Sockets )
{
static	const TIMEVAL	SelectNoTime = { 0 };
	BOOL		fIOServiced;
	INT			iSelectReturn;
	FD_SET		ReadSocketSet;
	FD_SET		WriteSocketSet;
	FD_SET		ErrorSocketSet;


	//
	// Make a local copy of all of the sockets.  This isn't totally
	// efficient, but it works.  Multiplying by active socket count will
	// spend half the time in the integer multiply.
	//
	fIOServiced = FALSE;
	Lock();
	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
	memcpy( &WriteSocketSet, pWinsock1Sockets, sizeof( WriteSocketSet ) );
	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
	Unlock();

	//
	// Don't check write sockets here because it's very likely that they're ready
	// for service but have no outgoing data and will thrash
	//
	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
							  &ReadSocketSet,	// sockets to check for read
							  NULL,				// sockets to check for write (none)
							  &ErrorSocketSet,	// sockets to check for error
							  &SelectNoTime		// wait timeout (zero, do an instant check)
							  );
	switch ( iSelectReturn )
	{
		//
		// timeout
		//
		case 0:
		{
			break;
		}

		//
		// select got pissed
		//
		case SOCKET_ERROR:
		{
			DWORD	dwWSAError;


			dwWSAError = p_WSAGetLastError();
			switch ( dwWSAError )
			{
				//
				// WSAENOTSOCK = This socket was probably closed
				//
				case WSAENOTSOCK:
				{
					DPFX(DPFPREP, 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
					break;
				}

				//
				// WSAEINTR = this operation was interrupted
				//
				case WSAEINTR:
				{
					DPFX(DPFPREP, 1, "Winsock1 reporting interrupted operation when selecting read or error sockets!" );
					break;
				}

				//
				// other
				//
				default:
				{
					DPFX(DPFPREP, 0, "Problem selecting read or error sockets for service!" );
					DisplayWinsockError( 0, dwWSAError );
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// Check for sockets needing read service and error service.
		//
		default:
		{
			fIOServiced |= ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
			fIOServiced |= ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
			break;
		}
	}

	//
	// Since writes are likely to be ready, check for them separately
	//
	iSelectReturn = p_select( 0,				// compatibility parameter (ignored)
							  NULL,				// sockets to check for read (don't check reads)
							  &WriteSocketSet,	// sockets to check for write
							  NULL,				// sockets to check for error (don't check errors)
							  &SelectNoTime		// wait timeout (zero, do an instant check)
							  );
	switch ( iSelectReturn )
	{
		//
		// timeout, no write sockets are ready for service
		//
		case 0:
		{
			break;
		}

		//
		// select failed
		//
		case SOCKET_ERROR:
		{
			DWORD	dwWSAError;


			dwWSAError = p_WSAGetLastError();
			switch ( dwWSAError )
			{
				//
				// this socket was probably closed
				//
				case WSAENOTSOCK:
				{
					DPFX(DPFPREP, 1, "Winsock1 reporting 'Not a socket' when selecting write sockets!" );
					break;
				}

				//
				// other
				//
				default:
				{
					DPFX(DPFPREP, 0, "Problem selecting write sockets for service!" );
					DisplayWinsockError( 0, dwWSAError );
					DNASSERT( FALSE );

					break;
				}
			}

			break;
		}

		//
		// Check for sockets needing write service
		//
		default:
		{
			fIOServiced |= ServiceWinsock1Sockets( &WriteSocketSet, CSocketPort::Winsock1WriteService );
			break;
		}
	}

	return	fIOServiced;
}
//**********************************************************************
#endif // WIN95


#ifdef WIN95
//**********************************************************************
// ------------------------------
// CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
//
// Entry:		Pointer to set of sockets
//				Pointer to service function
//
// Exit:		Boolean indicating whether I/O was serviced
//				TRUE = I/O serviced
//				FALSE = I/O not serviced
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ServiceWinsock1Sockets"

BOOL	CThreadPool::ServiceWinsock1Sockets( FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
{
	BOOL		fReturn;
	UINT_PTR	uWaitingSocketCount;
	UINT_PTR	uSocketPortCount;
	CSocketPort	*pSocketPorts[ FD_SETSIZE ];


	//
	// initialize
	//
	fReturn = FALSE;
	uSocketPortCount = 0;
	uWaitingSocketCount = pSocketSet->fd_count;
	
	Lock();
	while ( uWaitingSocketCount > 0 )
	{
		UINT_PTR	uIdx;


		uWaitingSocketCount--;
		uIdx = m_SocketSet.fd_count;
		while ( uIdx != 0 )
		{
			uIdx--;
			if ( p___WSAFDIsSet( m_SocketSet.fd_array[ uIdx ], pSocketSet ) != FALSE )
			{
				//
				// this socket is still available, add a reference to the socket
				// port and keep it around to be processed outside of the lock
				//
				pSocketPorts[ uSocketPortCount ] = m_pSocketPorts[ uIdx ];
				pSocketPorts[ uSocketPortCount ]->AddRef();
				uSocketPortCount++;
				uIdx = 0;
			}
		}
	}
	Unlock();

	while ( uSocketPortCount != 0 )
	{
		uSocketPortCount--;
		
		//
		// call the service function and remove the reference
		//
		fReturn |= (pSocketPorts[ uSocketPortCount ]->*pServiceFunction)();
		pSocketPorts[ uSocketPortCount ]->DecRef();
	}

	return	fReturn;
}
//**********************************************************************
#endif // WIN95


//**********************************************************************
// ------------------------------
// CThreadPool::WorkThreadJob_Alloc - allocate a new job
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WorkThreadJob_Alloc"

BOOL	CThreadPool::WorkThreadJob_Alloc( void *pItem )
{
	BOOL			fReturn;
	THREAD_POOL_JOB	*pJob;


	//
	// initialize
	//
	fReturn = TRUE;
	pJob = static_cast<THREAD_POOL_JOB*>( pItem );

	DEBUG_ONLY( memset( pJob, 0x00, sizeof( *pJob ) ) );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::WorkThreadJob_Get - a job is being removed from the pool
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WorkThreadJob_Get"

void	CThreadPool::WorkThreadJob_Get( void *pItem )
{
	THREAD_POOL_JOB	*pJob;


	//
	// initialize
	//
	pJob = static_cast<THREAD_POOL_JOB*>( pItem );
	DNASSERT( pJob->JobType == JOB_UNINITIALIZED );

	//
	// cannot ASSERT the the following because the pool manager uses that memory
	//
//	DNASSERT( pJob->pNext == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::WorkThreadJob_Release - a job is being returned to the pool
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WorkThreadJob_Release"

void	CThreadPool::WorkThreadJob_Release( void *pItem )
{
	THREAD_POOL_JOB	*pJob;


	DNASSERT( pItem != NULL );
	pJob = static_cast<THREAD_POOL_JOB*>( pItem );

	DNASSERT( pJob->JobType == JOB_UNINITIALIZED );
	pJob->pNext = NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::WorkThreadJob_Dealloc - return job to memory manager
//
// Entry:		Pointer to job
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::WorkThreadJob_Dealloc"

void	CThreadPool::WorkThreadJob_Dealloc( void *pItem )
{
	// don't do anything
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Alloc - allocate a new timer job entry
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::TimerEntry_Alloc"

BOOL	CThreadPool::TimerEntry_Alloc( void *pItem )
{
	BOOL					fReturn;
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	//
	// initialize
	//
	fReturn = TRUE;
	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );
	DEBUG_ONLY( memset( pTimerEntry, 0x00, sizeof( *pTimerEntry ) ) );
	pTimerEntry->pContext = NULL;
	pTimerEntry->Linkage.Initialize();

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Get - get new timer job entry from pool
//
// Entry:		Pointer to new entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::TimerEntry_Get"

void	CThreadPool::TimerEntry_Get( void *pItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );

	pTimerEntry->Linkage.Initialize();
	DNASSERT( pTimerEntry->pContext == NULL );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Release - return timer job entry to pool
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::TimerEntry_Release"

void	CThreadPool::TimerEntry_Release( void *pItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );
	pTimerEntry->pContext= NULL;

	DNASSERT( pTimerEntry->Linkage.IsEmpty() != FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::TimerEntry_Dealloc - deallocate a timer job entry
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::TimerEntry_Dealloc"

void	CThreadPool::TimerEntry_Dealloc( void *pItem )
{
	TIMER_OPERATION_ENTRY	*pTimerEntry;


	DNASSERT( pItem != NULL );

	//
	// initialize
	//
	pTimerEntry = static_cast<TIMER_OPERATION_ENTRY*>( pItem );

	//
	// return associated poiner to write data
	//
// can't DNASSERT on Linkage because pool manager stomped on it
//	DNASSERT( pEnumEntry->Linkage.IsEmpty() != FALSE );
	DNASSERT( pTimerEntry->pContext == NULL );
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\socketport.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		CSocketPort.h
 *  Content:	Winsock socket port that manages data flow on a given adapter,
 *				address and port.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/99	jtk		Created
 *	05/11/99	jtk		Split out to make a base class
 *  03/22/2000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __SOCKET_PORT_H__
#define __SOCKET_PORT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// states of socket port
//
typedef	enum
{
	SOCKET_PORT_STATE_UNKNOWN = 0,
	SOCKET_PORT_STATE_INITIALIZED,
	SOCKET_PORT_STATE_UNBOUND,
} SOCKET_PORT_STATE;

//
// enumeration of socket types
//
typedef	enum	_GATEWAY_BIND_TYPE
{
	GATEWAY_BIND_TYPE_UNKNOWN = 0,		// uninitialized
	GATEWAY_BIND_TYPE_DEFAULT,			// map the local port to any random port on the server
	GATEWAY_BIND_TYPE_SPECIFIC,			// map the local port to the same port on the server
	GATEWAY_BIND_TYPE_SPECIFIC_SHARED,	// map the local port to the same port on the server and share it (DPNSVR listen socket port)
	GATEWAY_BIND_TYPE_NONE				// don't map the local port on the server
} GATEWAY_BIND_TYPE;

//
// value used to designate an invalid enum key
//
#define	INVALID_ENUM_KEY	0

//
// enumerated type to indicate how a send completed
//
typedef enum
{
	SEND_UNKNOWN,					// unknown state
	SEND_FAILED,					// send failed
	SEND_IN_PROGRESS,				// send is pending in Winsock
	SEND_WINSOCK_BUSY,				// send couldn't be queued (we'll need to buffer ourselves)
	SEND_COMPLETED_IMMEDIATELY_WS1	// send completed immediately (Winsock1 only)

} SEND_COMPLETION_CODE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CSocketPort;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// send function pointer
//
typedef	SEND_COMPLETION_CODE	(CSocketPort::*PSEND_FUNCTION)( CWriteIOData *const pWriteData );
typedef	BOOL	(CSocketPort::*PSOCKET_SERVICE_FUNCTION)( void );

//**********************************************************************
// Class definition
//**********************************************************************

//
// reference to other classes and structures
//
class	CAdapterEntry;
class	CEndpoint;
class	CEndpointEnumKey;
class	CSPData;
typedef	struct	_THREAD_POOL_JOB	THREAD_POOL_JOB;

//
// main class definition
//
class	CSocketPort
{
	public:
		CSocketPort();
		~CSocketPort();

		HRESULT	Initialize( CSPData *const pSPData, CSocketAddress *const pAddress );
		HRESULT	Deinitialize( void );
		HRESULT	BindToNetwork( const HANDLE hIOCompletionPort, const GATEWAY_BIND_TYPE GatewayBindType );
		HRESULT	UnbindFromNetwork( void );

		const CSocketAddress *const	GetNetworkAddress( void ) const { return m_pNetworkSocketAddress; }
		const SOCKET	GetSocket( void ) const { return m_Socket; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::AddRef"
		void	AddRef( void )
		{
			LONG	lResult;

			
			lResult = DNInterlockedIncrement( &m_iRefCount );

			//
			// NOTE: This generates a lot of spew, especially when running WinSock1 code
			//		path, so it is at secret level 10!
			//
			DPFX(DPFPREP, 10, "Socket port 0x%p refcount = %i.", this, lResult );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::DecRef"
		void	DecRef( void )
		{
			LONG	lResult;

			
			DNASSERT( m_State != SOCKET_PORT_STATE_UNKNOWN );

			//
			// Decrement the reference counts and return this item to the pool if nobody
			// is referencing it anymore.
			//
			lResult = DNInterlockedDecrement( &m_iRefCount );
			if ( lResult == 0 )
			{
				HRESULT	hr;


				DNASSERT( m_iEndpointRefCount == 0 );

				//
				// There's no need to lock this socket port because this is the last
				// reference to it, nobody else will access it.
				//
				hr = Deinitialize();
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Problem deinitializing socket port 0x%p in DecRef!", this );
					DisplayDNError( 0, hr );
				}

				ReturnSelfToPool();
			}
			else
			{
				//
				// NOTE: This generates a lot of spew, especially when running WinSock1 code
				//		path, so it is at secret level 10!
				//
				DPFX(DPFPREP, 10, "Not deinitializing socket port 0x%p, refcount = %i.", this, lResult );
			}
		}
		
		void	EndpointAddRef( void );
		DWORD	EndpointDecRef( void );
		
		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		HRESULT	BindEndpoint( CEndpoint *const pEndpoint, GATEWAY_BIND_TYPE GatewayBindType );
		void	UnbindEndpoint( CEndpoint *const pEndpoint );
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::GetEnumKey"
		const DWORD	GetEnumKey( void )
		{
			DWORD	dwReturn;


			DBG_CASSERT( ENUM_RTT_MASK == 0x0F );
			Lock();
			m_iEnumKey++;
			dwReturn = m_iEnumKey << 4;
			Unlock();

			return	dwReturn;
		}

		DWORD	GetSocketPortID( void ) const { return m_dwSocketPortID; }
		BOOL	IsUsingProxyWinSockLSP( void ) const { return m_fUsingProxyWinSockLSP; }

		void	ReturnSelfToPool( void );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::SendUserData"
		void	SendUserData( CWriteIOData *const pWriteData )
		{
			//
			// check for need to escape user data
			//
			switch ( pWriteData->m_pBuffers[ 0 ].pBufferData[ 0 ] )
			{
				case SP_HEADER_LEAD_BYTE:
				{
					//
					// possible token interpretation problem, escape user data by prepending a buffer
					//
					pWriteData->m_pBuffers = &pWriteData->m_pBuffers[ -1 ];
					pWriteData->m_uBufferCount++;
					DBG_CASSERT( sizeof( &pWriteData->m_PrependBuffer.EscapedUserDataHeader ) == sizeof( BYTE* ) ) ;
					pWriteData->m_pBuffers[ 0 ].pBufferData = reinterpret_cast<BYTE*>( &pWriteData->m_PrependBuffer.EscapedUserDataHeader );
					pWriteData->m_pBuffers[ 0 ].dwBufferSize = sizeof( pWriteData->m_PrependBuffer.EscapedUserDataHeader );
					
					DNASSERT( pWriteData->m_PrependBuffer.EscapedUserDataHeader.bSPLeadByte == SP_HEADER_LEAD_BYTE );
					pWriteData->m_PrependBuffer.EscapedUserDataHeader.bSPCommandByte = ESCAPED_USER_DATA_KIND;
					pWriteData->m_PrependBuffer.EscapedUserDataHeader.wPad = ESCAPED_USER_DATA_PAD_VALUE;

					break;
				}

				default:
				{
					//
					// Assume user data.  There's no need to prepend a buffer because the
					// receiving machine will reailze that it's not a 'special' message and
					// will default the contents to 'user data'.
					//
					break;
				}
			}

			SendData( pWriteData );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::SendEnumResponseData"
		void	SendEnumResponseData( CWriteIOData *const pWriteData, const UINT_PTR uEnumResponseKey )
		{
			//
			// inlined to keep servers fast
			//
			pWriteData->m_pBuffers = &pWriteData->m_pBuffers[ -1 ];
			pWriteData->m_uBufferCount++;
			DBG_CASSERT( sizeof( &pWriteData->m_PrependBuffer.EnumResponseDataHeader ) == sizeof( BYTE* ) );
			pWriteData->m_pBuffers[ 0 ].pBufferData = reinterpret_cast<BYTE*>( &pWriteData->m_PrependBuffer.EnumResponseDataHeader );
			pWriteData->m_pBuffers[ 0 ].dwBufferSize = sizeof( pWriteData->m_PrependBuffer.EnumResponseDataHeader );
			
			DNASSERT( pWriteData->m_PrependBuffer.EnumResponseDataHeader.bSPLeadByte == SP_HEADER_LEAD_BYTE );
			pWriteData->m_PrependBuffer.EnumResponseDataHeader.bSPCommandByte = ENUM_RESPONSE_DATA_KIND;

			DNASSERT( uEnumResponseKey <= WORD_MAX );
			pWriteData->m_PrependBuffer.EnumResponseDataHeader.wEnumResponsePayload = static_cast<WORD>( uEnumResponseKey );

			SendData( pWriteData );
		}

		void	SendEnumQueryData( CWriteIOData *const pWriteData, const UINT_PTR uEnumKey );
		void	SendProxiedEnumData( CWriteIOData *const pWriteData, const CSocketAddress *const pReturnAddress, const UINT_PTR uOldEnumKey );

		CSocketAddress	*GetBoundNetworkAddress( const SP_ADDRESS_TYPE AddressType ) const;
		IDirectPlay8Address	*GetDP8BoundNetworkAddress( const SP_ADDRESS_TYPE AddressType,
															const GATEWAY_BIND_TYPE GatewayBindType ) const;

		CAdapterEntry	*GetAdapterEntry( void ) const { return m_pAdapterEntry; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::SetAdapterEntry"
		void	SetAdapterEntry( CAdapterEntry *const pAdapterEntry )
		{
			DNASSERT( ( m_pAdapterEntry == NULL ) || ( pAdapterEntry == NULL ) );
			m_pAdapterEntry = pAdapterEntry;
		}

		void	Winsock2ReceiveComplete( CReadIOData *const pReadData );

		void	CancelReceive( CReadIOData *const pRead );

		//
		// Public service functions for Winsock1 since we can't get asynchronous
		// notification.
		//
#ifdef WIN95
		BOOL	Winsock1ReadService( void );
		BOOL	Winsock1WriteService( void );
		BOOL	Winsock1ErrorService( void );
#endif
		BOOL	SendFromWriteQueue( void );
		void	SendComplete( CWriteIOData *const pWriteData, const HRESULT hResult );

		//
		// functions for active list
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::AddToActiveList"
		void	AddToActiveList( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			m_ActiveListLinkage.InsertBefore( pBilink );
		}

		void	RemoveFromActiveList( void ) { m_ActiveListLinkage.RemoveFromList(); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::SocketPortFromBilink"
		static CSocketPort	*SocketPortFromBilink( CBilink *const pBilink )
		{
			DNASSERT( pBilink != NULL );
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pBilink ) );
			DBG_CASSERT( sizeof( CSocketPort* ) == sizeof( BYTE* ) );
			return	reinterpret_cast<CSocketPort*>( &reinterpret_cast<BYTE*>( pBilink )[ -OFFSETOF( CSocketPort, m_ActiveListLinkage ) ] );
		}

		void	SetWinsockBufferSize( const INT iBufferSize ) const;
		void	IncreaseOutstandingReceives( const DWORD dwDelta );

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketPort::GetNATHelpPort"
		DPNHHANDLE	GetNATHelpPort( const DWORD dwPortIndex )
		{
			DNASSERT( dwPortIndex < MAX_NUM_DIRECTPLAYNATHELPERS );
			return m_ahNATHelpPorts[dwPortIndex];
		}

#ifdef DEBUG
		CSPData	*GetSPData( void )		{ return m_pSPData; }
#endif // DEBUG


	protected:

	private:
		BYTE						m_Sig[4];					// debugging signature ('SOKP')
		
		CSPData						*m_pSPData;					// pointer to SPData
		CThreadPool					*m_pThreadPool;				// pointer to thread pool
		DNCRITICAL_SECTION			m_Lock;						// thread lock
		volatile LONG				m_iRefCount;				// count of all outstanding references (endpoint and I/O)
		volatile LONG				m_iEndpointRefCount;		// count of outstanding endpoint references
		volatile SOCKET_PORT_STATE	m_State;					// state of socket port
		
		volatile SOCKET				m_Socket;					// communications socket
		CSocketAddress				*m_pNetworkSocketAddress;	// network address this socket is bound to
																// this may be the same as the m_NetworkSocketAddress

		volatile LONG				m_iThreadsInReceive;		// Number of threads currently in the process of calling WSARecvFrom
		
		CAdapterEntry	*m_pAdapterEntry;								// pointer to adapter entry to use
		DPNHHANDLE		m_ahNATHelpPorts[MAX_NUM_DIRECTPLAYNATHELPERS];	// array NAT Help registered port handles associated with this socket
		CBilink			m_ActiveListLinkage;							// linkage to list of active socket ports

		DNCRITICAL_SECTION								m_EndpointDataLock;			// lock for endpoint data
		CClassHash< HANDLE, const CSocketAddress* >		m_ConnectEndpointHash;		// hash table of connect endpoints
		CBilink											m_blConnectEndpointList;	// list of connect endpoints
		CClassHash< HANDLE, const CEndpointEnumKey* >	m_EnumEndpointHash;			// hash table of enum endpoints
		HANDLE											m_hListenEndpoint;			// associated listen endpoint (there can only be one!)

		volatile LONG	m_iEnumKey;						// current 'key' to be assigned to an enum
		DWORD			m_dwSocketPortID;				// unique identifier for this socketport
		BOOL			m_fUsingProxyWinSockLSP;		// whether the socket is bound to a proxy client WinSock layered service provider
		CSendQueue		m_SendQueue;					// outgoing send queue
		THREAD_POOL_JOB	*m_pRemoveSocketPortData;		// pointer to preallocated job for removing socket port
		PSEND_FUNCTION	m_pSendFunction;				// pointer to appropriate send function

		DEBUG_ONLY(	BOOL	m_fInitialized );


		void	LockEndpointData( void ) { DNEnterCriticalSection( &m_EndpointDataLock ); }
		void	UnlockEndpointData( void ) { DNLeaveCriticalSection( &m_EndpointDataLock ); }

		HRESULT	BindToNextAvailablePort( const CSocketAddress *const pNetworkSocketAddress,
											const WORD wBasePort ) const;
		
		HRESULT	CheckForOverridingMapping( const CSocketAddress *const pBoundSocketAddress);
		HRESULT	BindToInternetGateway( const CSocketAddress *const pBoundSocketAddress,
									  const GATEWAY_BIND_TYPE GatewayBindType );
		
		HRESULT	StartReceiving( const HANDLE hIOCompletionPort );

		SEND_COMPLETION_CODE	Winsock1Send( CWriteIOData *const pWriteData );
		SEND_COMPLETION_CODE	Winsock2Send( CWriteIOData *const pWriteData );
		HRESULT					Winsock2Receive( void );

		void	SendData( CWriteIOData *const pWriteData );
		void	ProcessReceivedData( CReadIOData *const pReadData );

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CSocketPort( const CSocketPort & );
		CSocketPort& operator=( const CSocketPort & );
};

#undef DPF_MODNAME

#endif	// __SOCKET_PORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\threadpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ThreadPool.h
 *  Content:	Functions to manage a thread pool
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/01/99	jtk		Derived from Utils.h
 ***************************************************************************/

#ifndef __THREAD_POOL_H__
#define __THREAD_POOL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// max handles that can be waited on for Win9x
//
#define	MAX_WIN9X_HANDLE_COUNT	64

//
// job definitions
//
typedef enum	_JOB_TYPE
{
	JOB_UNINITIALIZED,			// uninitialized value
	JOB_DELAYED_COMMAND,		// callback provided
	JOB_REFRESH_TIMER_JOBS		// revisit timer jobs
} JOB_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
class	CSocketPort;
class	CThreadPool;
typedef	enum	_THREAD_TYPE			THREAD_TYPE;
typedef struct	_THREAD_POOL_JOB		THREAD_POOL_JOB;
typedef	struct	_TIMER_OPERATION_ENTRY	TIMER_OPERATION_ENTRY;
typedef	struct	_WIN9X_CORE_DATA		WIN9X_CORE_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	BOOL	(CSocketPort::*PSOCKET_SERVICE_FUNCTION)( void );
typedef	void	JOB_FUNCTION( THREAD_POOL_JOB *const pJobInfo );
typedef	void	TIMER_EVENT_CALLBACK( void *const pContext, DN_TIME * const pRetryInterval );
typedef	void	TIMER_EVENT_COMPLETE( const HRESULT hCompletionCode, void *const pContext );
typedef	void	DIALOG_FUNCTION( void *const pDialogContext );

//**********************************************************************
// Class prototypes
//**********************************************************************

//
// class for thread pool
//
class	CThreadPool
{
	public:
		CThreadPool();
		~CThreadPool();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }
		void	LockReadData( void ) { DNEnterCriticalSection( &m_ReadDataLock ); }
		void	UnlockReadData( void ) { DNLeaveCriticalSection( &m_ReadDataLock ); }
		void	LockWriteData( void ) { DNEnterCriticalSection( &m_WriteDataLock ); }
		void	UnlockWriteData( void ) { DNLeaveCriticalSection( &m_WriteDataLock ); }


		void	AddRef( void ) { DNInterlockedIncrement( &m_iRefCount ); }
		void	DecRef( void )
		{
			if ( DNInterlockedDecrement( &m_iRefCount ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		HRESULT	Initialize( void );
		void	Deinitialize( void );
		void	StopAllIO( void );

#ifdef WINNT
		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetIOCompletionPort"
		HANDLE	GetIOCompletionPort( void ) const
		{
			DNASSERT( m_hIOCompletionPort != NULL );
			return	m_hIOCompletionPort;
		}
#endif

		CReadIOData	*GetNewReadIOData( READ_IO_DATA_POOL_CONTEXT *const pContext );
		void	ReturnReadIOData( CReadIOData *const pReadIOData );

#ifdef USE_THREADLOCALPOOLS
		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetNewWriteIOData"
		CWriteIOData	*GetNewWriteIOData( WRITE_IO_DATA_POOL_CONTEXT *const pContext )
		{
			CContextFixedTLPool<CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT> *		pPool;
			BOOL																fResult;
			CWriteIOData *														pTemp;


			DNASSERT( pContext != NULL );
#ifdef WIN95
			pContext->hOverlapEvent = GetWinsock2SendCompleteEvent();
#endif


			//
			// get the pool pointer
			//
			GET_THREADLOCALPTR( WSockThreadLocalPools,
								pWriteIODataPool,
								&pPool );

			//
			// create the pool if it didn't exist
			//
			if ( pPool == NULL )
			{
				pPool = new CContextFixedTLPool<CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT>;
				if ( pPool == NULL )
				{
					pTemp = NULL;
					goto Exit;
				}

				//
				// try to initialize the pool
				//
				fResult = pPool->Initialize( g_pGlobalWriteIODataPool,
											CWriteIOData::WriteIOData_Alloc,
											CWriteIOData::WriteIOData_Get,
											CWriteIOData::WriteIOData_Release,
											CWriteIOData::WriteIOData_Dealloc
										   );
				if (! fResult)
				{
					//
					// initializing pool failed, delete it and abort
					//
					delete pPool;
					pTemp = NULL;
					goto Exit;
				}


				//
				// associate the pool with this thread
				//
				SET_THREADLOCALPTR( WSockThreadLocalPools,
									pWriteIODataPool,
									pPool,
									&fResult );

				if (! fResult)
				{
					//
					// associating pool with thread failed, de-initialize it,
					// delete it, and abort.
					//
					pPool->Deinitialize();
					delete pPool;
					pTemp = NULL;
					goto Exit;
				}
			}


			//
			// attempt to get an entry from the pool, if one is gotten, put into
			// the pending write list
			//
			pTemp = pPool->Get( pContext );
			if ( pTemp != NULL )
			{
				LockWriteData();
				pTemp->m_OutstandingWriteListLinkage.InsertBefore( &m_OutstandingWriteList );
				UnlockWriteData();
			}

		Exit:

			return pTemp;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::ReturnWriteIOData"
		void	ReturnWriteIOData( CWriteIOData *const pWriteData )
		{
			CContextFixedTLPool<CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT> *		pPool;
			BOOL																fResult;

			
			DNASSERT( pWriteData != NULL );

			//
			// remove this item from the outstanding list
			//
			LockWriteData();
			pWriteData->m_OutstandingWriteListLinkage.RemoveFromList();
			UnlockWriteData();
			
			DNASSERT( pWriteData->m_OutstandingWriteListLinkage.IsEmpty() != FALSE );

			//
			// Get the pool pointer.
			//
			GET_THREADLOCALPTR( WSockThreadLocalPools,
								pWriteIODataPool,
								&pPool );

			//
			// Create the pool if it didn't exist.
			//
			if ( pPool == NULL )
			{
				pPool = new CContextFixedTLPool<CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT>;
				if ( pPool == NULL )
				{
					//
					// Couldn't create this thread's pool, just release the item
					// without the pool.
					//
					CContextFixedTLPool<CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT>::ReleaseWithoutPool( pWriteData, CWriteIOData::WriteIOData_Release, CWriteIOData::WriteIOData_Dealloc );

					return;
				}

				//
				// Try to initialize the pool.
				//
				fResult = pPool->Initialize( g_pGlobalWriteIODataPool,
											CWriteIOData::WriteIOData_Alloc,
											CWriteIOData::WriteIOData_Get,
											CWriteIOData::WriteIOData_Release,
											CWriteIOData::WriteIOData_Dealloc
										   );
				if (! fResult)
				{
					//
					// Initializing this thread's pool failed, just release the
					// item without the pool, and destroy the pool object that
					// couldn't be used.
					//
					CContextFixedTLPool<CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT>::ReleaseWithoutPool( pWriteData, CWriteIOData::WriteIOData_Release, CWriteIOData::WriteIOData_Dealloc );
					delete pPool;

					return;
				}


				//
				// Associate the pool with this thread.
				//
				SET_THREADLOCALPTR( WSockThreadLocalPools,
									pWriteIODataPool,
									pPool,
									&fResult );
				if ( ! fResult )
				{
					//
					// Couldn't store this thread's pool, just release the item
					// without the pool, plus de-initialize and destroy the pool
					// object that couldn't be used.
					//
					CContextFixedTLPool<CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT>::ReleaseWithoutPool( pWriteData, CWriteIOData::WriteIOData_Release, CWriteIOData::WriteIOData_Dealloc );
					pPool->Deinitialize();
					delete pPool;

					return;
				}
			}
			
			pPool->Release( pWriteData );
		}
#else
		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetNewWriteIOData"
		CWriteIOData	*GetNewWriteIOData( WRITE_IO_DATA_POOL_CONTEXT *const pContext )
		{
			CWriteIOData   *pTemp;


			DNASSERT( pContext != NULL );
#ifdef WIN95
			pContext->hOverlapEvent = GetWinsock2SendCompleteEvent();
#endif

			LockWriteData();

			//
			// attempt to get an entry from the pool, if one is gotten, put into
			// the pending write list
			//
			pTemp = m_WriteIODataPool.Get( pContext );
			if ( pTemp != NULL )
			{
				pTemp->m_OutstandingWriteListLinkage.InsertBefore( &m_OutstandingWriteList );
			}

			UnlockWriteData();

			return pTemp;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::ReturnWriteIOData"
		void	ReturnWriteIOData( CWriteIOData *const pWriteData )
		{
			DNASSERT( pWriteData != NULL );

			LockWriteData();

			pWriteData->m_OutstandingWriteListLinkage.RemoveFromList();
			DNASSERT( pWriteData->m_OutstandingWriteListLinkage.IsEmpty() != FALSE );
			m_WriteIODataPool.Release( pWriteData );

			UnlockWriteData();
		}
#endif // ! USE_THREADLOCALPOOLS

#ifdef WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetWinsock2SendCompleteEvent"
		HANDLE	GetWinsock2SendCompleteEvent( void ) const
		{
			DNASSERT( m_hWinsock2SendComplete != NULL );
			return m_hWinsock2SendComplete;
		}
#endif

#ifdef WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetWinsock2ReceiveCompleteEvent"
		HANDLE	GetWinsock2ReceiveCompleteEvent( void ) const
		{
			DNASSERT( m_hWinsock2ReceiveComplete != NULL );
			return m_hWinsock2ReceiveComplete;
		}
#endif

#ifdef WIN95
		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::GetNATHelpUpdateEvent"
		HANDLE	GetNATHelpUpdateEvent( void ) const
		{
			DNASSERT( m_hNATHelpUpdateEvent != NULL );
			return m_hNATHelpUpdateEvent;
		}
#endif

		HRESULT	SubmitDelayedCommand( JOB_FUNCTION *const pFunction,
									  JOB_FUNCTION *const pCancelFunction,
									  void *const pContext );

		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );
		void	RemoveSocketPort( CSocketPort *const pSocketPort );

		HRESULT	SubmitTimerJob( const BOOL fPerformImmediately,
								const UINT_PTR uRetryCount,
								const BOOL fRetryForever,
								const DN_TIME RetryInterval,
								const BOOL fIdleWaitForever,
								const DN_TIME IdleTimeout,
								TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
								TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
								void *const pContext );
		
		BOOL	StopTimerJob( void *const pContext, const HRESULT hCommandResult );
		BOOL	ModifyTimerJobNextRetryTime( void *const pContext,
											DN_TIME * const pNextRetryTime );


		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction,
								   void *const pDialogContext );

		
		//
		// thread management
		//
		LONG	GetIntendedThreadCount( void ) const { return m_iIntendedThreadCount; }
		void	SetIntendedThreadCount( const LONG iIntendedThreadCount ) { m_iIntendedThreadCount = iIntendedThreadCount; }
		
		LONG	ThreadCount( void ) const { return m_iTotalThreadCount; }
#ifdef WINNT
		LONG	NTCompletionThreadCount( void ) const { return m_iNTCompletionThreadCount; }
#endif
		
		void	IncrementActiveThreadCount( void ) { DNInterlockedIncrement( &m_iTotalThreadCount ); }
		void	DecrementActiveThreadCount( void ) { DNInterlockedDecrement( &m_iTotalThreadCount ); }

#ifdef WINNT
		void	IncrementActiveNTCompletionThreadCount( void )
		{
			IncrementActiveThreadCount();
			DNInterlockedIncrement( &m_iNTCompletionThreadCount );
		}

		void	DecrementActiveNTCompletionThreadCount( void )
		{
			DNInterlockedDecrement( &m_iNTCompletionThreadCount );
			DecrementActiveThreadCount();
		}
#endif
		
		HRESULT	GetIOThreadCount( LONG *const piThreadCount );
		HRESULT	SetIOThreadCount( const LONG iMaxThreadCount );
		BOOL IsThreadCountReductionAllowed( void ) const { return m_fAllowThreadCountReduction; }
		HRESULT PreventThreadPoolReduction( void );


		
		BOOL	IsNATHelpLoaded( void ) const { return m_fNATHelpLoaded; }
		BOOL	IsNATHelpTimerJobSubmitted( void ) const { return m_fNATHelpTimerJobSubmitted; }

		void	HandleNATHelpUpdate( DN_TIME * const pTimerInterval );


#ifdef DEBUG
		void	DebugPrintOutstandingReads( void );
		void	DebugPrintOutstandingWrites( void );
#endif // DEBUG


		
		//
		// Static timer functions
		//
		static void		NATHelpTimerComplete( const HRESULT hResult, void * const pContext );
		static void		NATHelpTimerFunction( void * const pContext, DN_TIME * const pRetryInterval );

	protected:

	private:
		BYTE				m_Sig[4];	// debugging signature ('THPL')
		
		DNCRITICAL_SECTION	m_Lock;		// local lock

		volatile LONG	m_iRefCount;					// reference count
		volatile LONG	m_iTotalThreadCount;			// number of active threads
#ifdef WINNT
		volatile LONG	m_iNTCompletionThreadCount;		// count of NT I/O completion threads
		HANDLE	m_hIOCompletionPort;			// I/O completion port for NT
#endif

		BOOL	m_fAllowThreadCountReduction;	// boolean indicating that the thread count is locked from being reduced
		LONG	m_iIntendedThreadCount;			// how many threads will be started

		BOOL	m_fNATHelpLoaded;				// boolean indicating whether the NAT Help interface has been loaded
		BOOL	m_fNATHelpTimerJobSubmitted;	// whether the NAT Help refresh timer has been submitted or not
		DWORD	m_dwNATHelpUpdateThreadID;		// ID of current thread updating NAT Help status, or 0 if none

		HANDLE	m_hStopAllThreads;				// handle used to stop all non-I/O completion threads

#ifdef WIN95
		HANDLE	m_hWinsock2SendComplete;		// send complete on Winsock2
		HANDLE	m_hWinsock2ReceiveComplete;		// receive complete on Winsock2
		HANDLE	m_hNATHelpUpdateEvent;			// NAT Help update event on Winsock2
#endif

		//
		// list of pending network operations, it doesn't really matter if they're
		// reads or writes, they're just pending.
		//
		DNCRITICAL_SECTION	m_ReadDataLock;		// lock for all read data
#ifndef USE_THREADLOCALPOOLS
		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPReadIODataPool;		// pool for IP read data
		CContextFixedPool< CReadIOData, READ_IO_DATA_POOL_CONTEXT >	m_IPXReadIODataPool;	// pool for IPX read data
#endif // ! USE_THREADLOCALPOOLS
		CBilink		m_OutstandingReadList;		// list of outstanding reads

		DNCRITICAL_SECTION	m_WriteDataLock;	// lock for all write data
#ifndef USE_THREADLOCALPOOLS
		CContextFixedPool< CWriteIOData, WRITE_IO_DATA_POOL_CONTEXT >	m_WriteIODataPool;	// pool for write data
#endif // ! USE_THREADLOCALPOOLS
		CBilink		m_OutstandingWriteList;		// list of outstanding writes

		//
		// The Job data lock covers all items through and including m_pSocketPorts
		//
		DNCRITICAL_SECTION	m_JobDataLock;		// lock for job queue/pool

		FPOOL		m_TimerEntryPool;			// pool for timed entries
		FPOOL		m_JobPool;					// pool of jobs for work threads

		CJobQueue	m_JobQueue;					// job queue

		//
		// Data used by the the timer thread.  This data is protected by m_TimerDataLock.
		// This data is cleaned by the timer thread.  Since only one timer thread
		// is allowed to run at any given time, the status of the NT timer thread
		// can be determined by m_fNTEnumThreadRunning.  Win9x doesn't have a timer
		// thread, the main thread loop is timed.
		//
		DNCRITICAL_SECTION	m_TimerDataLock;
		CBilink				m_TimerJobList;
#ifdef WINNT
		BOOL				m_fNTTimerThreadRunning;
#endif

		UINT_PTR		m_uReservedSocketCount;			// count of sockets that are 'reserved' for use
		FD_SET			m_SocketSet;					// set of all sockets in use
		CSocketPort 	*m_pSocketPorts[ FD_SETSIZE ];	// set of corresponding socket ports

#ifdef DEBUG
		DWORD			m_dwNumNATHelpUpdatesNotScheduled; // debug only counter of how many times the NAT Help timer fired but had to be skipped
#endif // DEBUG

		void	LockJobData( void ) { DNEnterCriticalSection( &m_JobDataLock ); }
		void	UnlockJobData( void ) { DNLeaveCriticalSection( &m_JobDataLock ); }

		void	LockTimerData( void ) { DNEnterCriticalSection( &m_TimerDataLock ); }
		void	UnlockTimerData( void ) { DNLeaveCriticalSection( &m_TimerDataLock ); }

		static	UINT_PTR	SaturatedWaitTime( const DN_TIME &Time )
		{
				UINT_PTR	uReturn;

				if ( Time.Time32.TimeHigh != 0 )
				{
					uReturn = -1;
				}
				else
				{
					uReturn = Time.Time32.TimeLow;
				}

				return	uReturn;
		}

#ifdef WINNT
		HRESULT	WinNTInit( void );
#else
		HRESULT	Win9xInit( void );
#endif

		BOOL	ProcessTimerJobs( const CBilink *const pJobList, DN_TIME *const pNextJobTime);

		BOOL	ProcessTimedOperation( TIMER_OPERATION_ENTRY *const pJob,
									   const DN_TIME *const pCurrentTime,
									   DN_TIME *const pNextJobTime );

#ifdef WINNT
		HRESULT	StartNTTimerThread( void );
		void	WakeNTTimerThread( void );
#endif

		void	RemoveTimerOperationEntry( TIMER_OPERATION_ENTRY *const pTimerOperationData, const HRESULT hReturnCode );

#ifdef WIN95
		void	CompleteOutstandingSends( void );
		void	CompleteOutstandingReceives( void );

		static	DWORD WINAPI	PrimaryWin9xThread( void *pParam );
		static	DWORD WINAPI	SecondaryWin9xThread( void *pParam );
#endif

#ifdef WINNT
		static	DWORD WINAPI	WinNTIOCompletionThread( void *pParam );
		static	DWORD WINAPI	WinNTTimerThread( void *pParam );
#endif
		static	DWORD WINAPI	DialogThreadProc( void *pParam );

		HRESULT	SubmitWorkItem( THREAD_POOL_JOB *const pJob );
		THREAD_POOL_JOB	*GetWorkItem( void );

		static	void	CancelRefreshTimerJobs( THREAD_POOL_JOB *const pJobData );
#ifdef WIN95
		void	ProcessWin9xEvents( WIN9X_CORE_DATA *const pCoreData, const THREAD_TYPE ThreadType );
		void	ProcessWin9xJob( WIN9X_CORE_DATA *const pCoreData );

		BOOL	CheckWinsock1IO( FD_SET *const pWinsock1Sockets );
		BOOL	ServiceWinsock1Sockets( FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );
#endif

#ifdef WINNT
		void	StartNTCompletionThread( void );
#endif

#ifdef WIN95
		void	StartPrimaryWin9xIOThread( void );
		void	StartSecondaryWin9xIOThread( void );
#endif
		void	StopAllThreads( void );
		void	CancelOutstandingJobs( void );
		void	CancelOutstandingIO( void );
		void	ReturnSelfToPool( void );

		//
		// functions for managing the job pool
		//
		static	BOOL	WorkThreadJob_Alloc( void *pItem );
		static	void	WorkThreadJob_Get( void *pItem );
		static	void	WorkThreadJob_Release( void *pItem );
		static	void	WorkThreadJob_Dealloc( void *pItem );

		//
		// functions for managing the timer data pool
		//
		static	BOOL	TimerEntry_Alloc( void *pItem );
		static	void	TimerEntry_Get( void *pItem );
		static	void	TimerEntry_Release( void *pItem );
		static	void	TimerEntry_Dealloc( void *pItem );

		//
		// prevent unwarranted copies
		//
		CThreadPool( const CThreadPool & );
		CThreadPool& operator=( const CThreadPool & );
};

#undef DPF_MODNAME

#endif	// __THREAD_POOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\utils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Utils.cpp
 *  Content:	Serial service provider utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DEFAULT_WIN9X_THREADS	2

#define REGSUBKEY_DPNATHELP_DIRECTPLAY8PRIORITY		L"DirectPlay8Priority"
#define REGSUBKEY_DPNATHELP_DIRECTPLAY8INITFLAGS	L"DirectPlay8InitFlags"
#define REGSUBKEY_DPNATHELP_GUID					L"Guid"


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// global variables that are unique for the process
//
static	DNCRITICAL_SECTION		g_InterfaceGlobalsLock;

static volatile	LONG			g_iThreadPoolRefCount = 0;
static	CThreadPool *			g_pThreadPool = NULL;


static	DWSSTATE				g_dwsState;		// state info for the WS1/2 glue lib
static volatile LONG			g_iWinsockRefCount = 0;


static volatile LONG			g_iNATHelpRefCount = 0;





//**********************************************************************
// Function prototypes
//**********************************************************************
static void			ReadSettingsFromRegistry( void );



//**********************************************************************
// Function definitions
//**********************************************************************






//**********************************************************************
// ------------------------------
// ReadSettingsFromRegistry - read custom registry keys
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReadSettingsFromRegistry"

static void	ReadSettingsFromRegistry( void )
{
	CRegistry	RegObject;
	CRegistry	RegObjectTemp;
	CRegistry	RegObjectAppEntry;
	DWORD		dwRegValue;
	BOOL		fGotPath;
	WCHAR		wszExePath[_MAX_PATH];
#ifndef WINNT
	char		szExePath[_MAX_PATH];
#endif // ! WINNT


	if ( RegObject.Open( HKEY_LOCAL_MACHINE, g_RegistryBase ) != FALSE )
	{

		//
		// read receive buffer size
		//
		if ( RegObject.ReadDWORD( g_RegistryKeyReceiveBufferSize, dwRegValue ) != FALSE )
		{
			g_fWinsockReceiveBufferSizeOverridden = TRUE;
			g_iWinsockReceiveBufferSize = dwRegValue;
		}
	
		//
		// read buffer multiplier, make sure this does note get set to zero
		//
		if ( RegObject.ReadDWORD( g_RegistryKeyReceiveBufferMultiplier, dwRegValue ) != FALSE )
		{
			if ( dwRegValue != 0 )
			{
				g_dwWinsockReceiveBufferMultiplier = dwRegValue;
				DPFX(DPFPREP,  3, "Setting Winsock receive buffer multiplier to: %d", dwRegValue );
			}
		}

		//
		// read default threads
		//
		if ( RegObject.ReadDWORD( g_RegistryKeyThreadCount, dwRegValue ) != FALSE )
		{
			g_iThreadCount = dwRegValue;	
		}
	
		//
		// if thread count is zero, use the 'default' for the system
		//
		if ( g_iThreadCount == 0 )
		{
#ifdef WIN95
			g_iThreadCount = DEFAULT_WIN9X_THREADS;
#else // WINNT
			SYSTEM_INFO		SystemInfo;
			

			//
			// as suggested by 'Multithreading Applications in Win32' book:
			// dwNTThreadCount = ( ( processors * 2 ) + 2 )
			//
			memset( &SystemInfo, 0x00, sizeof( SystemInfo ) );
			GetSystemInfo( &SystemInfo );
			
			g_iThreadCount = ( ( 2 * SystemInfo.dwNumberOfProcessors ) + 2 );
#endif
		}


		//
		// get global NAT traversal disablers, ignore registry reading error
		//
		RegObject.ReadBOOL( g_RegistryKeyDisableDPNHGatewaySupport, g_fDisableDPNHGatewaySupport );
		RegObject.ReadBOOL( g_RegistryKeyDisableDPNHFirewallSupport, g_fDisableDPNHFirewallSupport );

		//
		// get NAT Help alert mechanism disabler, ignore registry reading error
		//
		RegObject.ReadBOOL( g_RegistryKeyUseNATHelpAlert, g_fUseNATHelpAlert );


		//
		// Find out the current process name and see if enums are disabled.
		//
#ifdef WINNT
		if (GetModuleFileNameW(NULL, wszExePath, _MAX_PATH) > 0)
		{
			DPFX(DPFPREP, 3, "Loading DLL in process: %S", wszExePath);
			_wsplitpath( wszExePath, NULL, NULL, wszExePath, NULL );
			fGotPath = TRUE;
		}
#else // ! WINNT
		if (GetModuleFileNameA(NULL, szExePath, _MAX_PATH) > 0)
		{
			HRESULT		hr;

			
			DPFX(DPFPREP, 3, "Loading DLL in process: %s", szExePath);
			_splitpath( szExePath, NULL, NULL, szExePath, NULL );

			dwRegValue = _MAX_PATH;
			hr = STR_AnsiToWide(szExePath, -1, wszExePath, &dwRegValue );
			if ( hr == DPN_OK )
			{
				//
				// Successfully converted ANSI path to Wide characters.
				//
				fGotPath = TRUE;
			}
			else
			{
				//
				// Couldn't convert ANSI path to Wide characters
				//
				fGotPath = FALSE;
			}
		}
#endif // ! WINNT
		else
		{
			//
			// Couldn't get current process path.
			//
			fGotPath = FALSE;
		}


		//
		// If we have an app name, try opening the subkey and looking up the app
		// to see if enums are disabled or there are IP addresses to ban.
		//
		if ( fGotPath )
		{
			if ( RegObjectTemp.Open( RegObject.GetHandle(), g_RegistryKeyAppsToIgnoreEnums, TRUE, FALSE ) )
			{
				RegObjectTemp.ReadBOOL( wszExePath, g_fIgnoreEnums );
				RegObjectTemp.Close();

				if ( g_fIgnoreEnums )
				{
					DPFX(DPFPREP, 0, "Ignoring all enumerations (app = %S).", wszExePath);
				}
				else
				{
					DPFX(DPFPREP, 2, "Not ignoring all enumerations (app = %S).", wszExePath);
				}
			}

#ifdef IPBANNING
			if ( RegObjectTemp.Open( RegObject.GetHandle(), g_RegistryKeyAppsToBanIPs, TRUE, FALSE ) )
			{
				if ( RegObjectAppEntry.Open( RegObjectTemp.GetHandle(), wszExePath, TRUE, FALSE ) )
				{
					RegObjectTemp.Close();

					RegObjectAppEntry.EnumValues( wszExePath, g_fIgnoreEnums );

					//
					// Read in IP addresses to ban from registry.
					//
					/*
					if ( ? )
					{
					}
					else
					{
					}
					*/

					RegObjectAppEntry.Close();
				}
				else
				{
					RegObjectTemp.Close();
				}
			}
#endif // IPBANNING
		}
	

		//
		// Get the proxy support options, ignore registry reading error.
		//
		RegObject.ReadBOOL( g_RegistryKeyDontAutoDetectProxyLSP, g_fDontAutoDetectProxyLSP );
		RegObject.ReadBOOL( g_RegistryKeyTreatAllResponsesAsProxied, g_fTreatAllResponsesAsProxied );


		RegObject.Close();
	}
}
//**********************************************************************





//**********************************************************************
// ------------------------------
// InitProcessGlobals - initialize the global items needed for the SP to operate
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "InitProcessGlobals"

BOOL	InitProcessGlobals( void )
{
	BOOL		fReturn;
	BOOL		fCriticalSectionInitialized;


	//
	// initialize
	//
	fReturn = TRUE;
	fCriticalSectionInitialized = FALSE;

	ReadSettingsFromRegistry();

	if ( DNInitializeCriticalSection( &g_InterfaceGlobalsLock ) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}

	fCriticalSectionInitialized = TRUE;
	

	if ( InitializePools() == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}


	DNASSERT( g_pThreadPool == NULL );


Exit:
	return	fReturn;

Failure:

	if ( fCriticalSectionInitialized != FALSE )
	{
		DNDeleteCriticalSection( &g_InterfaceGlobalsLock );
		fCriticalSectionInitialized = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitProcessGlobals - deinitialize the global items
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DeinitProcessGlobals"

void	DeinitProcessGlobals( void )
{
	DNASSERT( g_pThreadPool == NULL );
	DNASSERT( g_iThreadPoolRefCount == 0 );

	DeinitializePools();
	DNDeleteCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// LoadWinsock - load Winsock module into memory
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "LoadWinsock"

BOOL	LoadWinsock( void )
{
	BOOL	fReturn = TRUE;
	INT_PTR	iVersion;

	
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	if ( g_iWinsockRefCount == 0 )
	{
		//
		// initialize the bindings to Winsock
		//
		iVersion = DWSInitWinSock( &g_dwsState );
		if ( iVersion == 0 )	// failure
		{
			DPFX(DPFPREP, 0, "Problem binding dynamic winsock functions!" );
			fReturn = FALSE;
			goto Failure;
		}
		
		DPFX(DPFPREP, 8, "Detected WinSock version %d.%d", LOBYTE( iVersion ), HIBYTE( iVersion ) );	
	}

	DNInterlockedIncrement( &g_iWinsockRefCount );

Exit:
	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
	return	fReturn;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// UnloadWinsock - unload Winsock module
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "UnloadWinsock"

void	UnloadWinsock( void )
{
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	if ( DNInterlockedDecrement( &g_iWinsockRefCount ) == 0 )
	{
		BOOL	fFreeReturn;


		fFreeReturn = DWSFreeWinSock( &g_dwsState );
		if ( fFreeReturn == FALSE )
		{
			DPFX(DPFPREP,  0, "Problem unbinding dynamic WinSock functions!" );
		}
		else
		{
			DPFX(DPFPREP,  6, "Successfully unbound dynamic WinSock functions." );
		}
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************


#ifdef WIN95
//**********************************************************************
// ------------------------------
// GetWinsockVersion - get the version of Winsock
//
// Entry:		Nothing
//
// Exit:		Winsock version
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "GetWinsockVersion"

INT	GetWinsockVersion( void )
{
	return	g_dwsState.nVersion;
}
//**********************************************************************
#endif


//**********************************************************************
// ------------------------------
// LoadNATHelp - create and initialize NAT Help object(s)
//
// Entry:		Nothing
//
// Exit:		TRUE if some objects were successfully loaded, FALSE otherwise
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "LoadNATHelp"

BOOL LoadNATHelp(void)
{
	BOOL		fReturn;
	HRESULT		hr;
	CRegistry	RegEntry;
	CRegistry	RegSubentry;
	DWORD		dwMaxKeyLen;
	WCHAR *		pwszKeyName = NULL;
	DWORD		dwEnumIndex;
	DWORD		dwKeyLen;
	DWORD		dwDirectPlay8Priority;
	DWORD		dwDirectPlay8InitFlags;
	DWORD		dwNumLoaded;
	GUID		guid;

	
	DNEnterCriticalSection(&g_InterfaceGlobalsLock);

	if ( g_iNATHelpRefCount == 0 )
	{
		//
		// Enumerate all the DirectPlayNAT Helpers.
		//
		if (! RegEntry.Open(HKEY_LOCAL_MACHINE, DIRECTPLAYNATHELP_REGKEY, TRUE, FALSE))
		{
			DPFX(DPFPREP,  0, "Couldn't open DirectPlayNATHelp registry key!");
			goto Failure;
		}


		//
		// Find length of largest subkey.
		//
		if (!RegEntry.GetMaxKeyLen(dwMaxKeyLen))
		{
			DPFERR("RegistryEntry.GetMaxKeyLen() failed!");
			goto Failure;
		}
		
		dwMaxKeyLen++;	// Null terminator
		DPFX(DPFPREP, 9, "dwMaxKeyLen = %ld", dwMaxKeyLen);

		pwszKeyName = (WCHAR*) DNMalloc(dwMaxKeyLen * sizeof(WCHAR));
		if (pwszKeyName == NULL)
		{
			DPFERR("DNMalloc() failed");
			goto Failure;
		}


		//
		// Allocate an array to hold the helper objects.
		//
		g_papNATHelpObjects = (IDirectPlayNATHelp**) DNMalloc(MAX_NUM_DIRECTPLAYNATHELPERS * sizeof(IDirectPlayNATHelp*));
		if (g_papNATHelpObjects == NULL)
		{
			DPFERR("DNMalloc() failed");
			goto Failure;
		}
		ZeroMemory(g_papNATHelpObjects,
					(MAX_NUM_DIRECTPLAYNATHELPERS * sizeof(IDirectPlayNATHelp*)));

		
		dwEnumIndex = 0;
		dwNumLoaded = 0;

		//
		// Enumerate the DirectPlay NAT helpers.
		//
		do
		{
			dwKeyLen = dwMaxKeyLen;
			if (! RegEntry.EnumKeys(pwszKeyName, &dwKeyLen, dwEnumIndex))
			{
				break;
			}
			dwEnumIndex++;
			
	
			DPFX(DPFPREP, 8, "%ld - %S (%ld)", dwEnumIndex, pwszKeyName, dwKeyLen);
			
			if (!RegSubentry.Open(RegEntry, pwszKeyName, TRUE, FALSE))
			{
				DPFX(DPFPREP, 0, "Couldn't open subentry \"%S\"! Skipping.", pwszKeyName);
				continue;
			}


			//
			// Read the DirectPlay8 priority
			//
			if (!RegSubentry.ReadDWORD(REGSUBKEY_DPNATHELP_DIRECTPLAY8PRIORITY, dwDirectPlay8Priority))
			{
				DPFX(DPFPREP, 0, "RegSubentry.ReadDWORD \"%S\\%S\" failed!  Skipping.",
					pwszKeyName, REGSUBKEY_DPNATHELP_DIRECTPLAY8PRIORITY);
				RegSubentry.Close();
				continue;
			}


			//
			// Read the DirectPlay8 initialization flags
			//
			if (!RegSubentry.ReadDWORD(REGSUBKEY_DPNATHELP_DIRECTPLAY8INITFLAGS, dwDirectPlay8InitFlags))
			{
				DPFX(DPFPREP, 0, "RegSubentry.ReadDWORD \"%S\\%S\" failed!  Defaulting to 0.",
					pwszKeyName, REGSUBKEY_DPNATHELP_DIRECTPLAY8INITFLAGS);
				dwDirectPlay8InitFlags = 0;
			}

			
			//
			// Read the object's CLSID.
			//
			if (!RegSubentry.ReadGUID(REGSUBKEY_DPNATHELP_GUID, guid))
			{
				DPFX(DPFPREP, 0,"RegSubentry.ReadGUID \"%S\\%S\" failed!  Skipping.",
					pwszKeyName, REGSUBKEY_DPNATHELP_GUID);
				RegSubentry.Close();
				continue;
			}


			//
			// Close the subkey.
			//
			RegSubentry.Close();


			//
			// If this helper should be loaded, do so.
			//
			if (dwDirectPlay8Priority != 0)
			{
				//
				// Make sure this priority is valid.
				//
				if (dwDirectPlay8Priority > MAX_NUM_DIRECTPLAYNATHELPERS)
				{
					DPFX(DPFPREP, 0, "Ignoring DirectPlay NAT helper \"%S\" with invalid priority level set too high (%u > %u).",
						pwszKeyName, dwDirectPlay8Priority, MAX_NUM_DIRECTPLAYNATHELPERS);
					continue;
				}


				//
				// Make sure this priority hasn't already been taken.
				//
				if (g_papNATHelpObjects[dwDirectPlay8Priority - 1] != NULL)
				{
					DPFX(DPFPREP, 0, "Ignoring DirectPlay NAT helper \"%S\" with duplicate priority level %u (existing object = 0x%p).",
						pwszKeyName, dwDirectPlay8Priority,
						g_papNATHelpObjects[dwDirectPlay8Priority - 1]);
					continue;
				}
				

				//
				// Try to create the NAT Help object.  COM should have been
 				// initialized by now by someone else.
				//
				hr = COM_CoCreateInstance(guid,
										NULL,
										CLSCTX_INPROC_SERVER,
										IID_IDirectPlayNATHelp,
										(LPVOID*) (&g_papNATHelpObjects[dwDirectPlay8Priority - 1]));
				if ( hr != S_OK )
				{
					DNASSERT( g_papNATHelpObjects[dwDirectPlay8Priority - 1] == NULL );
					DPFX(DPFPREP,  0, "Failed to create \"%S\" IDirectPlayNATHelp interface (error = 0x%lx)!  Skipping.",
						pwszKeyName, hr);
					continue;
				}

				
				//
				// Initialize NAT Help.
				//

				DNASSERT((! g_fDisableDPNHGatewaySupport) || (! g_fDisableDPNHFirewallSupport));

				if (g_fDisableDPNHGatewaySupport)
				{
					dwDirectPlay8InitFlags |= DPNHINITIALIZE_DISABLEGATEWAYSUPPORT;
				}

				if (g_fDisableDPNHFirewallSupport)
				{
					dwDirectPlay8InitFlags |= DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT;
				}


				//
				// Make sure the flags we're passing are valid.
				//
				if ((dwDirectPlay8InitFlags & (DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)) == (DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT))
				{
					DPFX(DPFPREP, 1, "Not loading NAT Help \"%S\" because both DISABLEGATEWAYSUPPORT and DISABLELOCALFIREWALLSUPPORT would have been specified (priority = %u, flags = 0x%lx).", 
						pwszKeyName, dwDirectPlay8Priority, dwDirectPlay8InitFlags);
						
					IDirectPlayNATHelp_Release(g_papNATHelpObjects[dwDirectPlay8Priority - 1]);
					g_papNATHelpObjects[dwDirectPlay8Priority - 1] = NULL;
					
					continue;
				}

				
				hr = IDirectPlayNATHelp_Initialize(g_papNATHelpObjects[dwDirectPlay8Priority - 1], dwDirectPlay8InitFlags);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't initialize NAT Help \"%S\" (error = 0x%lx)!  Skipping.",
						pwszKeyName, hr);
					
					IDirectPlayNATHelp_Release(g_papNATHelpObjects[dwDirectPlay8Priority - 1]);
					g_papNATHelpObjects[dwDirectPlay8Priority - 1] = NULL;
					
					continue;
				}
			
			
				DPFX(DPFPREP, 8, "Initialized NAT Help \"%S\" (priority = %u, flags = 0x%lx, object = 0x%p).", 
					pwszKeyName, dwDirectPlay8Priority, dwDirectPlay8InitFlags, g_papNATHelpObjects[dwDirectPlay8Priority - 1]);

				dwNumLoaded++;
			}
			else
			{
				DPFX(DPFPREP, 1, "DirectPlay NAT Helper \"%S\" is not enabled for DirectPlay8.", pwszKeyName);
			}
		}
		while (TRUE);
			
		
		//
		// If we didn't load any NAT helper objects, free up the memory.
		//
		if (dwNumLoaded == 0)
		{
			DNFree(g_papNATHelpObjects);
			g_papNATHelpObjects = NULL;
	
			//
			// We never got anything.  Fail.
			//
			goto Failure;
		}

		
		DPFX(DPFPREP, 8, "Loaded %u DirectPlay NAT Helper objects.", dwNumLoaded);
	}
	else
	{
		DPFX(DPFPREP, 8, "Already loaded NAT Help objects.");	
	}

	//
	// We have the interface globals lock, don't need InterlockedIncrement.
	//
	g_iNATHelpRefCount++;

	//
	// We succeeded.
	//
	fReturn = TRUE;

Exit:
	
	DNLeaveCriticalSection(&g_InterfaceGlobalsLock);

	if (pwszKeyName != NULL)
	{
		DNFree(pwszKeyName);
		pwszKeyName = NULL;
	}

	return	fReturn;

Failure:

	//
	// We can only fail during the first initialize, so therefore we will never be freeing
	// g_papNATHelpObjects when we didn't allocate it in this function.
	//
	if (g_papNATHelpObjects != NULL)
	{
		DNFree(g_papNATHelpObjects);
		g_papNATHelpObjects = NULL;
	}

	fReturn = FALSE;
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// UnloadNATHelp - release the NAT Help object
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "UnloadNATHelp"

void UnloadNATHelp(void)
{
	DWORD	dwTemp;
	

	DNEnterCriticalSection(&g_InterfaceGlobalsLock);

	//
	// We have the interface globals lock, don't need InterlockedDecrement.
	//
	DNASSERT(g_iNATHelpRefCount > 0);
	g_iNATHelpRefCount--;
	if (g_iNATHelpRefCount == 0 )
	{
		HRESULT		hr;


		DNASSERT(g_papNATHelpObjects != NULL);
		for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
		{
			if (g_papNATHelpObjects[dwTemp] != NULL)
			{
				DPFX(DPFPREP, 8, "Closing NAT Help object priority %u (0x%p).",
					dwTemp, g_papNATHelpObjects[dwTemp]);

				hr = IDirectPlayNATHelp_Close(g_papNATHelpObjects[dwTemp], 0);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP,  0, "Problem closing NAT Help object %u (error = 0x%lx), continuing.",
						dwTemp, hr);
				}

				IDirectPlayNATHelp_Release(g_papNATHelpObjects[dwTemp]);
				g_papNATHelpObjects[dwTemp] = NULL;
			}
		}

		DNFree(g_papNATHelpObjects);
		g_papNATHelpObjects = NULL;
	}
	else
	{
		DPFX(DPFPREP, 8, "NAT Help object(s) still have %i references.",
			g_iNATHelpRefCount);
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateSPData - create instance data for SP
//
// Entry:		Pointer to pointer to SPData
//				Pointer to class GUID
//				Interface type
//				Pointer to COM interface vtable
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateSPData"

HRESULT	CreateSPData( CSPData **const ppSPData,
					  const CLSID *const pClassID,
					  const SP_TYPE SPType,
					  IDP8ServiceProviderVtbl *const pVtbl )
{
	HRESULT		hr;
	CSPData		*pSPData;


	DNASSERT( ppSPData != NULL );
	DNASSERT( pClassID != NULL );
	DNASSERT( pVtbl != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	*ppSPData = NULL;
	pSPData = NULL;

	//
	// create data
	//
	pSPData = new CSPData;
	if ( pSPData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot create data for Winsock interface!" );
		goto Failure;
	}
	pSPData->AddRef();

	hr = pSPData->Initialize( pClassID, SPType, pVtbl );
	if ( hr != DPN_OK  )
	{
		DPFX(DPFPREP,  0, "Failed to intialize SP data!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	DPFX(DPFPREP, 6, "Created SP Data object 0x%p.", pSPData);

Exit:
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP,  0, "Problem with CreateSPData!" );
		DisplayDNError( 0, hr );
	}

	*ppSPData = pSPData;

	return	hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;	
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitializeInterfaceGlobals - perform global initialization for an interface.
//
// Entry:		Pointer to SPData
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "InitializeInterfaceGlobals"

HRESULT	InitializeInterfaceGlobals( CSPData *const pSPData )
{
	HRESULT	hr;
	CThreadPool	*pThreadPool;
	CRsip		*pRsip;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThreadPool = NULL;
	pRsip = NULL;

	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	if ( g_pThreadPool == NULL )
	{
		DNASSERT( g_iThreadPoolRefCount == 0 );
		g_pThreadPool = CreateThreadPool();
		if ( g_pThreadPool != NULL )
		{
			hr = g_pThreadPool->Initialize();
			if ( hr != DPN_OK )
			{
				g_pThreadPool->DecRef();
				g_pThreadPool = NULL;
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}
			else
			{
				g_iThreadPoolRefCount++;
				pThreadPool = g_pThreadPool;
			}
		}
	}
	else
	{
		DNASSERT( g_iThreadPoolRefCount != 0 );
		g_iThreadPoolRefCount++;
		g_pThreadPool->AddRef();
		pThreadPool = g_pThreadPool;
	}

Exit:
	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );

	pSPData->SetThreadPool( g_pThreadPool );

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitializeInterfaceGlobals - deinitialize thread pool and Rsip
//
// Entry:		Pointer to service provider
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DeinitializeInterfaceGlobals"

void	DeinitializeInterfaceGlobals( CSPData *const pSPData )
{
	CThreadPool		*pThreadPool;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	pThreadPool = NULL;

	//
	// Process as little as possible inside the lock.  If any of the items
	// need to be released, pointers to them will be set.
	//
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	DNASSERT( g_pThreadPool != NULL );
	DNASSERT( g_iThreadPoolRefCount != 0 );
	DNASSERT( g_pThreadPool == pSPData->GetThreadPool() );

	pThreadPool = pSPData->GetThreadPool();

	//
	// remove thread pool reference
	//
	DNASSERT( pThreadPool != NULL );
	g_iThreadPoolRefCount--;
	if ( g_iThreadPoolRefCount == 0 )
	{
		g_pThreadPool = NULL;
	}
	else
	{
		pThreadPool = NULL;
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );

	//
	// Now that we're outside of the lock, clean up any pointers we have.
	// The thread pool will be cleaned up when all of the outstanding interfaces
	// close.
	//
	if ( pThreadPool != NULL )
	{
		pThreadPool->StopAllIO();
		pThreadPool = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// AddNetworkAdapterToBuffer - add a network address to a packed buffer
//
// Entry:		Pointer to packed buffer
//				Pointer to adapter name
//				Pointer to adapter guid
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "AddNetworkAdapterToBuffer"

HRESULT	AddNetworkAdapterToBuffer( CPackedBuffer *const pPackedBuffer,
								   const char *const pAdapterName,
								   const GUID *const pAdapterGUID )
{
	HRESULT	hr;
	DPN_SERVICE_PROVIDER_INFO	AdapterInfo;


	DNASSERT( pPackedBuffer != NULL );
	DNASSERT( pAdapterName != NULL );
	DNASSERT( pAdapterGUID != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	memset( &AdapterInfo, 0x00, sizeof( AdapterInfo ) );
	DNASSERT( AdapterInfo.dwFlags == 0 );
	DNASSERT( AdapterInfo.pvReserved == NULL );
	DNASSERT( AdapterInfo.dwReserved == NULL );

	AdapterInfo.guid = *pAdapterGUID;

	hr = pPackedBuffer->AddStringToBack( pAdapterName );
	if ( ( hr != DPNERR_BUFFERTOOSMALL ) && ( hr != DPN_OK ) )
	{
		DPFX(DPFPREP,  0, "Failed to add adapter name to buffer!" );
		goto Failure;
	}
	AdapterInfo.pwszName = static_cast<WCHAR*>( pPackedBuffer->GetTailAddress() );

	hr = pPackedBuffer->AddToFront( &AdapterInfo, sizeof( AdapterInfo ) );

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************



#if 0

//**********************************************************************
// ------------------------------
// ConvertURLDataToBinaryW - convert a Unicode string with URL escaped characters into a binary buffer
//
// Entry:		String to convert
//				Destination buffer pointer
//				Pointer to size of buffer.  If too small, size required will be stored here.  Otherwise bytes written will be stored here.
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ConvertURLDataToBinaryW"

HRESULT	ConvertURLDataToBinaryW( const WCHAR * const wszURLData,
								void * const pvBuffer,
								DWORD * const pdwBufferSize )
{
	HRESULT					hr;
	WCHAR *					pwszTemp = NULL;
	IDirectPlay8Address *	pDP8AddressTemp = NULL;


	DNASSERT(wszURLData != NULL);
	DNASSERT(pdwBufferSize != NULL);


	//
	// Create a DirectPlay8Address object.
	//
	hr = COM_CoCreateInstance(CLSID_DirectPlay8Address,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IDirectPlay8Address,
							(PVOID*) (&pDP8AddressTemp));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't create temporary DirectPlay8Address object (err = 0x%lx)!", hr);
		goto Exit;
	}

	//
	// Allocate a buffer and stick "x-directplay:/#" in front of the
	// data (i.e. make the string passed in user data for a bogus URL).
	//

	pwszTemp = (WCHAR*) DNMalloc((wcslen(DPNA_HEADER) + 1 + wcslen(wszURLData) + 1) * sizeof(WCHAR));
	if (pwszTemp == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Exit;
	}

	wcscpy(pwszTemp, DPNA_HEADER);
	pwszTemp[wcslen(DPNA_HEADER)] = DPNA_SEPARATOR_USERDATA;
	wcscpy((pwszTemp + wcslen(DPNA_HEADER) + 1), wszURLData);


	//
	// Let the addressing library's parsing routine handle the grunt
	// work of converting the string to binary data.
	//
	hr = IDirectPlay8Address_BuildFromURLW(pDP8AddressTemp, pwszTemp);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't build URL from string \"%S\"!", pwszTemp);
		goto Exit;
	}

	hr = IDirectPlay8Address_GetUserData(pDP8AddressTemp, pvBuffer, pdwBufferSize);
	if (hr != DPN_OK)
	{
		if (hr != DPNERR_BUFFERTOOSMALL)
		{
			DPFX(DPFPREP, 0, "Couldn't get user data from temporary DirectPlay8Address object!");
		}
		goto Exit;
	}


Exit:

	if (pwszTemp != NULL)
	{
		DNFree(pwszTemp);
		pwszTemp = NULL;
	}

	if (pDP8AddressTemp != NULL)
	{
		IDirectPlay8Address_Release(pDP8AddressTemp);
		pDP8AddressTemp = NULL;
	}

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ConvertURLDataToBinaryA - convert an ANSI string with URL escaped characters into a binary buffer
//
// Entry:		String to convert
//				Destination buffer pointer
//				Pointer to size of buffer.  If too small, size required will be stored here.  Otherwise bytes written will be stored here.
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ConvertURLDataToBinaryA"

HRESULT	ConvertURLDataToBinaryA( const char * const szURLData,
								void * const pvBuffer,
								DWORD * const pdwBufferSize )
{
	HRESULT					hr;
	char *					pszTemp = NULL;
	IDirectPlay8Address *	pDP8AddressTemp = NULL;


	DNASSERT(szURLData != NULL);
	DNASSERT(pdwBufferSize != NULL);


	//
	// Create a DirectPlay8Address object.
	//
	hr = COM_CoCreateInstance(CLSID_DirectPlay8Address,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IDirectPlay8Address,
							(PVOID*) (&pDP8AddressTemp));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't create temporary DirectPlay8Address object (err = 0x%lx)!", hr);
		goto Exit;
	}

	//
	// Allocate a buffer and stick "x-directplay:/#" in front of the
	// data (i.e. make the string passed in user data for a bogus URL).
	//

	pszTemp = (char*) DNMalloc((strlen(DPNA_HEADER_A) + 1 + strlen(szURLData) + 1) * sizeof(char));
	if (pszTemp == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Exit;
	}

	strcpy(pszTemp, DPNA_HEADER_A);
	pszTemp[strlen(DPNA_HEADER_A)] = DPNA_SEPARATOR_USERDATA_A;
	strcpy((pszTemp + strlen(DPNA_HEADER_A) + 1), szURLData);


	//
	// Let the addressing library's parsing routine handle the grunt
	// work of converting the string to binary data.
	//
	hr = IDirectPlay8Address_BuildFromURLA(pDP8AddressTemp, pszTemp);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't build URL from string \"%s\"!", pszTemp);
		goto Exit;
	}

	hr = IDirectPlay8Address_GetUserData(pDP8AddressTemp, pvBuffer, pdwBufferSize);
	if (hr != DPN_OK)
	{
		if (hr != DPNERR_BUFFERTOOSMALL)
		{
			DPFX(DPFPREP, 0, "Couldn't get user data from temporary DirectPlay8Address object!");
		}
		goto Exit;
	}


Exit:

	if (pszTemp != NULL)
	{
		DNFree(pszTemp);
		pszTemp = NULL;
	}

	if (pDP8AddressTemp != NULL)
	{
		IDirectPlay8Address_Release(pDP8AddressTemp);
		pDP8AddressTemp = NULL;
	}

	return hr;
}
//**********************************************************************


#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\unk.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Unk.cpp
 *  Content:	IUnknown implementation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  08/06/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif

#define DPN_REG_LOCAL_WSOCK_IPX_ROOT			L"\\DPNSPWinsockIPX"
#define DPN_REG_LOCAL_WSOCK_TCPIP_ROOT		L"\\DPNSPWinsockTCP"

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

static	STDMETHODIMP DNSP_QueryInterface( IDP8ServiceProvider *lpDNSP, REFIID riid, LPVOID * ppvObj);

#define NOTSUPPORTED(parm)	(HRESULT (__stdcall *) (struct IDP8ServiceProvider *, parm)) DNSP_NotSupported


//**********************************************************************
// Function definitions
//**********************************************************************

// these are the vtables for IPX and IP.  One or the other is used depending on
// what is passed to DoCreateInstance.  The interfaces are presently the same,
// but are different structures to facilitate potential future changes.
static IDP8ServiceProviderVtbl	ipxInterface =
{
	DNSP_QueryInterface,
	DNSP_AddRef,
	DNSP_Release,
	DNSP_Initialize,
	DNSP_Close,
	DNSP_Connect,
	DNSP_Disconnect,
	DNSP_Listen,
	DNSP_SendData,
	DNSP_EnumQuery,
	DNSP_EnumRespond,
	DNSP_CancelCommand,
	NOTSUPPORTED(PSPCREATEGROUPDATA),		// CreateGroup
	NOTSUPPORTED(PSPDELETEGROUPDATA),		// DeleteGroup
	NOTSUPPORTED(PSPADDTOGROUPDATA),		// AddToGroup
	NOTSUPPORTED(PSPREMOVEFROMGROUPDATA),	// RemoveFromGroup
	DNSP_GetCaps,
	DNSP_SetCaps,
	DNSP_ReturnReceiveBuffers,
	DNSP_GetAddressInfo,
	DNSP_IsApplicationSupported,
	DNSP_EnumAdapters,
	DNSP_ProxyEnumQuery
};

static IDP8ServiceProviderVtbl	ipInterface =
{
	DNSP_QueryInterface,
	DNSP_AddRef,
	DNSP_Release,
	DNSP_Initialize,
	DNSP_Close,
	DNSP_Connect,
	DNSP_Disconnect,
	DNSP_Listen,
	DNSP_SendData,
	DNSP_EnumQuery,
	DNSP_EnumRespond,
	DNSP_CancelCommand,
	NOTSUPPORTED(PSPCREATEGROUPDATA),		// CreateGroup
	NOTSUPPORTED(PSPDELETEGROUPDATA),		// DeleteGroup
	NOTSUPPORTED(PSPADDTOGROUPDATA),		// AddToGroup
	NOTSUPPORTED(PSPREMOVEFROMGROUPDATA),	// RemoveFromGroup
	DNSP_GetCaps,
	DNSP_SetCaps,
	DNSP_ReturnReceiveBuffers,
	DNSP_GetAddressInfo,
	DNSP_IsApplicationSupported,
	DNSP_EnumAdapters,
	DNSP_ProxyEnumQuery
};

//**********************************************************************
// ------------------------------
// DNSP_QueryInterface - query for interface
//
// Entry:		Pointer to current interface
//				GUID of desired interface
//				Pointer to pointer to new interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_QueryInterface"

static	STDMETHODIMP DNSP_QueryInterface( IDP8ServiceProvider *lpDNSP, REFIID riid, LPVOID * ppvObj)
{
	HRESULT hr = S_OK;
	 *ppvObj=NULL;

	// hmmm, switch would be cleaner...
	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IDP8ServiceProvider) )
	{
		*ppvObj = lpDNSP;
		DNSP_AddRef(lpDNSP);
	}
	else
	{
		hr =  E_NOINTERFACE;		
	}

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateIPXInterface - create an IPX interface
//
// Entry:		Pointer to pointer to SP interface
//				Pointer to pointer to associated SP data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateIPXInterface"

static	HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDNSP, CSPData **const ppSPData )
{
	HRESULT 	hr;
	CSPData		*pSPData;


	DNASSERT( ppiDNSP != NULL );
	DNASSERT( ppSPData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = NULL;
	*ppiDNSP = NULL;
	*ppSPData = NULL;

	//
	// create main data class
	//
	hr = CreateSPData( &pSPData, &CLSID_DP8SP_IPX, TYPE_IPX, &ipxInterface );
	if ( hr != DPN_OK )
	{
		DNASSERT( pSPData == NULL );
		DPFX(DPFPREP, 0, "Problem creating SPData!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	DNASSERT( pSPData != NULL );
	*ppiDNSP = pSPData->COMInterface();
	*ppSPData = pSPData;

Exit:
	return hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CreateIPInterface - create an IP interface
//
// Entry:		Pointer to pointer to SP interface
//				Pointer to associated SP data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateIPInterface"

static	HRESULT CreateIPInterface( IDP8ServiceProvider **const ppiDNSP, CSPData **const ppSPData )
{
	HRESULT 	hr;
	CSPData		*pSPData;

	
	DNASSERT( ppiDNSP != NULL );
	DNASSERT( ppSPData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = NULL;
	*ppiDNSP = NULL;
	*ppSPData = NULL;

	//
	// create main data class
	//
	hr = CreateSPData( &pSPData, &CLSID_DP8SP_TCPIP, TYPE_IP, &ipInterface );
	if ( hr != DPN_OK )
	{
		DNASSERT( pSPData == NULL );
		DPFX(DPFPREP, 0, "Problem creating SPData!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	DNASSERT( pSPData != NULL );
	*ppiDNSP = pSPData->COMInterface();
	*ppSPData = pSPData;

Exit:
	return hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DoCreateInstance - create an instance of an interface
//
// Entry:		Pointer to class factory
//				Pointer to unknown interface
//				Refernce of GUID of desired interface
//				Reference to another GUID?
//				Pointer to pointer to interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateInstance"

HRESULT DoCreateInstance( LPCLASSFACTORY This,
						  LPUNKNOWN pUnkOuter,
						  REFCLSID rclsid,
						  REFIID riid,
						  LPVOID *ppvObj )
{
	HRESULT			 	hr;
	IDP8ServiceProvider	**ppIDNSP;
	CSPData				*pSPData;


	DNASSERT( ppvObj != NULL );

	//
	// initialize
	//
	*ppvObj = NULL;
	ppIDNSP = NULL;
	pSPData = NULL;

	//
	// we can either create an IPX instance or an IP instance
	//
	DBG_CASSERT( sizeof( ppvObj ) == sizeof( ppIDNSP ) );
	ppIDNSP = reinterpret_cast<IDP8ServiceProvider**>( ppvObj );
	if (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP))
	{
		hr = CreateIPInterface( ppIDNSP, &pSPData );
	}
	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
	{
		hr = CreateIPXInterface( ppIDNSP, &pSPData );
	}
	else
	{
//		this shouldn't happen if they called IClassFactory::CreateObject correctly
		hr = E_UNEXPECTED;
		DNASSERT( FALSE );
	}

	if (hr == S_OK)
	{
		// get the right interface and bump the refcount
		hr = IDP8ServiceProvider_QueryInterface( *ppIDNSP, riid, ppvObj );
	}

	//
	// release any outstanding reference on the SP data
	//
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// IsClassImplemented - determine if a class is implemented in this .DLL
//
// Entry:		Reference to class GUID
//
// Exit:		Boolean indicating whether this .DLL implements the class
//				TRUE = this .DLL implements the class
//				FALSE = this .DLL doesn't implement the class
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "IsClassImplemented"

BOOL IsClassImplemented(REFCLSID rclsid)
{
	return ( IsEqualCLSID( rclsid, CLSID_DP8SP_TCPIP ) || IsEqualCLSID( rclsid, CLSID_DP8SP_IPX ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DllMain - main .DLL function
//
// Entry:		DLL instance handle
//				Reason why this function is being called
//				Pointer to something
//
// Exit:		Boolean return
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

EXP BOOL WINAPI DllMain( HINSTANCE hDllInst,
						 DWORD fdwReason,
						 LPVOID lpvReserved
						 )
{
	BOOL bResult = TRUE;
	switch( fdwReason )
	{
		case DLL_PROCESS_ATTACH:
		{
			DPFX(DPFPREP, 2, "====> ENTER: DLLMAIN(%p): Process Attach: %08lx, tid=%08lx",
				DllMain, GetCurrentProcessId(), GetCurrentThreadId() );

			DNASSERT( g_hDLLInstance == NULL );
			g_hDLLInstance = hDllInst;

			//
			// attempt to initialize the OS abstraction layer
			//
			if ( DNOSIndirectionInit() != FALSE )
			{
#ifdef UNICODE
				// Make sure no one is trying to run the UNICODE version on Win9x
				DNASSERT(IsUnicodePlatform);
#endif
				if (SUCCEEDED(COM_Init()))
				{
					//
					// attempt to initialize process-global items
					//
					if ( InitProcessGlobals() == FALSE )
					{
						COM_Free();
						DNOSIndirectionDeinit();

						DPFX(DPFPREP, 0, "Failed to initialize globals!" );
						bResult = FALSE;
					}
				}
				else
				{
					DPFX(DPFPREP, 0, "Failed to initialize COM indirection layer!" );
					bResult = FALSE;

					DNOSIndirectionDeinit();
				}
			}
			else
			{
				DPFX(DPFPREP, 0, "Failed to initialize OS indirection layer!" );
				bResult = FALSE;
			}

			break;
		}

		case DLL_THREAD_ATTACH:
		{
			//
			// Nothing to do.
			//
			break;
		}

		case DLL_THREAD_DETACH:
		{
#ifdef USE_THREADLOCALPOOLS
			//
			// Clear thread local storage for this thread, if any.
			//
			RELEASE_CURRENTTHREAD_LOCALPTRS(WSockThreadLocalPools, CleanupThreadLocalPools);
#endif // USE_THREADLOCALPOOLS
			break;
		}

		case DLL_PROCESS_DETACH:
		{
			DPFX(DPFPREP, 2, "====> EXIT: DLLMAIN(%p): Process Detach %08lx, tid=%08lx",
				DllMain, GetCurrentProcessId(), GetCurrentThreadId() );

			DNASSERT( g_hDLLInstance != NULL );
			g_hDLLInstance = NULL;

			DeinitProcessGlobals();

			COM_Free();

			DNOSIndirectionDeinit();

			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return bResult;
}
//**********************************************************************

#define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH

#undef DPF_MODNAME
#define DPF_MODNAME "LoadAndAllocString"

HRESULT LoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString )
{
	int length;
	HRESULT hr;

#ifdef WINNT
	wchar_t wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
		
	length = LoadStringW( g_hDLLInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );

	if( length == 0 )
	{
		hr = GetLastError();		
		
		DPFX(DPFPREP, 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
		*lpswzString = NULL;

		return hr;
	}
	else
	{
		*lpswzString = new wchar_t[length+1];

		if( *lpswzString == NULL )
		{
			DPFX(DPFPREP, 0, "Alloc failure" );
			return DPNERR_OUTOFMEMORY;
		}

		wcscpy( *lpswzString, wszTmpBuffer );

		return DPN_OK;
	}
#else // WIN95
	char szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
	
	length = LoadStringA( g_hDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );

	if( length == 0 )
	{
		hr = GetLastError();		
		
		DPFX(DPFPREP, 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
		*lpswzString = NULL;

		return hr;
	}
	else
	{
		*lpswzString = new wchar_t[length+1];

		if( *lpswzString == NULL )
		{
			DPFX(DPFPREP, 0, "Alloc failure" );
			return DPNERR_OUTOFMEMORY;
		}

		if( STR_jkAnsiToWide( *lpswzString, szTmpBuffer, length+1 ) == DPN_OK )
		{
			hr = GetLastError();
			
			DPFX(DPFPREP, 0, "Unable to upconvert from ansi to unicode hr=0x%x", hr );
			return hr;
		}

		return DPN_OK;
	}
#endif
}

#undef DPF_MODNAME
#define DPF_MODNAME "RegisterDefaultSettings"
//
// RegisterDefaultSettings
//
// This function registers the default settings for this module.
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT RegisterDefaultSettings()
{
	CRegistry creg;

	WCHAR *wszFriendlyName = NULL;
	HRESULT hr;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY DPN_REG_LOCAL_WSOCK_IPX_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot create IPX sub-area!" );
		return DPNERR_GENERIC;
	}

	hr = LoadAndAllocString( IDS_FRIENDLYNAME_IPX, &wszFriendlyName );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP, 0, "Could not load IPX name!  hr=0x%x", hr );
		return hr;
	}

	// Load from resource file
	creg.WriteString( DPN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );

	delete [] wszFriendlyName;

	creg.WriteGUID( DPN_REG_KEYNAME_GUID, CLSID_DP8SP_IPX );

	creg.Close();

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY DPN_REG_LOCAL_WSOCK_TCPIP_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot create TCPIP sub-area!" );
		return DPNERR_GENERIC;
	}

	hr = LoadAndAllocString( IDS_FRIENDLYNAME_TCPIP, &wszFriendlyName );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP, 0, "Could not load IPX name!  hr=0x%x", hr );
		return hr;
	}

	// Load from resource file
	creg.WriteString( DPN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );

	delete [] wszFriendlyName;

	creg.WriteGUID( DPN_REG_KEYNAME_GUID, CLSID_DP8SP_TCPIP );

	creg.Close();


	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "UnRegisterDefaultSettings"
//
// UnRegisterDefaultSettings
//
// This function registers the default settings for this module.
//
HRESULT UnRegisterDefaultSettings()
{
	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY, FALSE, TRUE ) )
	{
		DPFERR( "Cannot remove app, does not exist" );
	}
	else
	{
		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_WSOCK_IPX_ROOT)[1] ) )
		{
			DPFERR( "Cannot remove IPX sub-key, could have elements" );
		}

		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_WSOCK_TCPIP_ROOT)[1] ) )
		{
			DPFERR( "Cannot remove TCPIP sub-key, could have elements" );
		}

	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
HRESULT WINAPI DllRegisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::Register( L"DirectPlay8SPWSock.IPX.1", L"DirectPlay8 WSock IPX Provider Object",
							  L"dpnwsock.dll", CLSID_DP8SP_IPX, L"DirectPlay8SPWSock.IPX") )
	{
		DPFERR( "Could not register dp8 IPX object" );
		fFailed = TRUE;
	}

	if( !CRegistry::Register( L"DirectPlay8SPWSock.TCPIP.1", L"DirectPlay8 WSock TCPIP Provider Object",
							  L"dpnwsock.dll", CLSID_DP8SP_TCPIP, L"DirectPlay8SPWSock.TCPIP") )
	{
		DPFERR( "Could not register dp8 IP object" );
		fFailed = TRUE;
	}

	if( FAILED( hr = RegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP, 0, "Could not register default settings hr = 0x%x", hr );
		fFailed = TRUE;
	}
	
	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
STDAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::UnRegister(CLSID_DP8SP_IPX) )
	{
		DPFX(DPFPREP, 0, "Failed to unregister IPX object" );
		fFailed = TRUE;
	}

	if( !CRegistry::UnRegister(CLSID_DP8SP_TCPIP) )
	{
		DPFX(DPFPREP, 0, "Failed to unregister IP object" );
		fFailed = TRUE;
	}

	if( FAILED( hr = UnRegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP, 0, "Failed to remove default settings hr=0x%x", hr );
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\wsocksp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   WSockSP.h
 *  Content:	declaration of DN Winsock SP functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/26/98	jwo		Created it.
 ***************************************************************************/

#ifndef __WSOCKSP_H__
#define __WSOCKSP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumeration of types of SP
//
typedef enum	_SP_TYPE
{
	TYPE_UNKNOWN,		// unknown type
	TYPE_IP,			// IP type
	TYPE_IPX			// IPX type

} SP_TYPE;




//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
STDMETHODIMP DNSP_Initialize( IDP8ServiceProvider*, SPINITIALIZEDATA* );
STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8ServiceProvider* pDNSP );
STDMETHODIMP_(ULONG) DNSP_Release( IDP8ServiceProvider* pDNSP );
STDMETHODIMP DNSP_Connect( IDP8ServiceProvider*, SPCONNECTDATA* );
STDMETHODIMP DNSP_Disconnect( IDP8ServiceProvider*, SPDISCONNECTDATA* );
STDMETHODIMP DNSP_Listen( IDP8ServiceProvider*, SPLISTENDATA* );
STDMETHODIMP DNSP_EnumQuery( IDP8ServiceProvider*, SPENUMQUERYDATA* );
STDMETHODIMP DNSP_EnumRespond( IDP8ServiceProvider*, SPENUMRESPONDDATA* );
STDMETHODIMP DNSP_SendData( IDP8ServiceProvider*, SPSENDDATA* );
STDMETHODIMP DNSP_CancelCommand( IDP8ServiceProvider*, HANDLE, DWORD );
STDMETHODIMP DNSP_Close( IDP8ServiceProvider* );
STDMETHODIMP DNSP_GetCaps( IDP8ServiceProvider*, SPGETCAPSDATA* );
STDMETHODIMP DNSP_SetCaps( IDP8ServiceProvider*, SPSETCAPSDATA* );
STDMETHODIMP DNSP_ReturnReceiveBuffers( IDP8ServiceProvider*, SPRECEIVEDBUFFER* );
STDMETHODIMP DNSP_GetAddressInfo( IDP8ServiceProvider*, SPGETADDRESSINFODATA* );
STDMETHODIMP DNSP_IsApplicationSupported( IDP8ServiceProvider*, SPISAPPLICATIONSUPPORTEDDATA* );
STDMETHODIMP DNSP_EnumAdapters( IDP8ServiceProvider*, SPENUMADAPTERSDATA* );
STDMETHODIMP DNSP_ProxyEnumQuery( IDP8ServiceProvider*, SPPROXYENUMQUERYDATA* );

STDMETHODIMP DNSP_NotSupported( IDP8ServiceProvider*, PVOID );

#endif	// __WSOCKSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\wsocksp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       WSockSP.cpp
 *  Content:	Protocol-independent APIs for the DN Winsock SP
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/26/98	jwo		Created it.
 *	11/1/98		jwo		Un-subclassed everything (moved it to this generic
 *						file from IP and IPX specific ones
 *  03/22/20000	jtk		Updated with changes to interface names
 *	04/22/00	mjn		Allow all flags in DNSP_GetAddressInfo()
 *  08/06/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	03/12/01	mjn		Prevent enum responses from being indicated up after completion
 ***************************************************************************/

#include "dnwsocki.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_WSOCK

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// maximum bandwidth in bits per second
//
#define	UNKNOWN_BANDWIDTH	0

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Initialize initializes the instance of the SP.  It must be called
 *		at least once before using any other functions.  Further attempts
 *		to initialize the SP are ignored.
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Initialize"

STDMETHODIMP DNSP_Initialize( IDP8ServiceProvider *pThis, SPINITIALIZEDATA *pData )
{
	HRESULT			hr;
	CSPData			*pSPData;
	SOCKET			TestSocket;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pData);

	DNASSERT( pThis != NULL );
	DNASSERT( pData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	TestSocket = INVALID_SOCKET;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// prevent anyone else from messing with this interface
	//
	pSPData->Lock();

	//
	// check interface state
	//
	switch ( pSPData->GetState() )
	{
		//
		// uninitialized interface, we can initialize it
		//
		case SPSTATE_UNINITIALIZED:
		{
			break;
		}

		//
		// other state
		//
		case SPSTATE_INITIALIZED:
		case SPSTATE_CLOSING:
		default:
		{
			pSPData->Unlock();

			hr = DPNERR_ALREADYINITIALIZED;
			DPFX(DPFPREP, 0, "Attempted to reinitialize interface!" );
			DNASSERT( FALSE );

			goto Exit;
		}
	}


	//
	// Before we get too far, check for the existance of this protocol by
	// attempting to create a socket.
	//
 	switch ( pSPData->GetType() )
	{
		case TYPE_IP:
		{
			TestSocket = p_socket( AF_INET, SOCK_DGRAM, IPPROTO_IP );
			break;
		}

		case TYPE_IPX:
		{
			TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	
	if ( TestSocket == INVALID_SOCKET )
	{
		DPFX(DPFPREP, 1, "Creating %s socket failed, is that transport protocol installed?",
			(( pSPData->GetType() == TYPE_IP ) ? "IP" : "IPX"));
		hr = DPNERR_UNSUPPORTED;
		goto Failure;
	}
	
	//
	// remember our init data
	//
	pSPData->SetCallbackData( pData );

	//
	// Success from here on in
	//
	IDP8SPCallback_AddRef( pSPData->DP8SPCallbackInterface() );
	pSPData->SetState( SPSTATE_INITIALIZED );

	pSPData->Unlock();

	IDP8ServiceProvider_AddRef( pThis );

Exit:
	if ( TestSocket != INVALID_SOCKET )
	{
		p_closesocket( TestSocket );
		TestSocket = INVALID_SOCKET;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);
	
	return hr;

Failure:
	pSPData->Unlock();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Close is the opposite of Initialize.  Call it when you're done
 *		using the SP
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Close"

STDMETHODIMP DNSP_Close( IDP8ServiceProvider *pThis )
{
	HRESULT		hr;
	CSPData		*pSPData;
	
	
	DPFX(DPFPREP, 2, "Parameters: (0x%p)", pThis);

	DNASSERT( pThis != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	switch ( pSPData->GetType() )
	{
		case TYPE_IP:
		case TYPE_IPX:
		{
			pSPData->Shutdown();
			IDP8ServiceProvider_Release( pThis );
			
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}
	
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_AddRef - increment reference count
//
// Entry:		Pointer to interface
//
// Exit:		New reference count
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_AddRef"

STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8ServiceProvider *pThis )
{	
	CSPData *	pSPData;
	ULONG		ulResult;


	DPFX(DPFPREP, 2, "Parameters: (0x%p)", pThis);

	DNASSERT( pThis != NULL );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	
	ulResult = pSPData->AddRef();

	
	DPFX(DPFPREP, 2, "Returning: [0x%u]", ulResult);

	return ulResult;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_Release - decrement reference count
//
// Entry:		Pointer to interface
//
// Exit:		New reference count
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Release"

STDMETHODIMP_(ULONG) DNSP_Release( IDP8ServiceProvider *pThis )
{
	CSPData *	pSPData;
	ULONG		ulResult;

	
	DPFX(DPFPREP, 2, "Parameters: (0x%p)", pThis);

	DNASSERT( pThis != NULL );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	
	ulResult = pSPData->DecRef();

	
	DPFX(DPFPREP, 2, "Returning: [0x%u]", ulResult);

	return ulResult;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_EnumQuery  sends out the
 *		specified data to the specified address.  If the SP is unable to
 *		determine the address based on the input params, it checks to see
 *		if it's allowed to put up a dialog querying the user for address
 *		info.  If it is, it queries the user for address info.
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_EnumQuery"

STDMETHODIMP DNSP_EnumQuery( IDP8ServiceProvider *pThis, SPENUMQUERYDATA *pEnumQueryData)
{
	HRESULT					hr;
	HRESULT					hTempResult;
	CEndpoint				*pEndpoint;
	CCommandData			*pCommand;
	BOOL					fInterfaceReferenceAdded;
	BOOL					fEndpointOpen;
	CSPData					*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumQueryData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumQueryData != NULL );
	DNASSERT( ( pEnumQueryData->dwFlags & ~( DPNSPF_OKTOQUERY | DPNSPF_NOBROADCASTFALLBACK | DPNSPF_ADDITIONALMULTIPLEXADAPTERS ) ) == 0 );

	DBG_CASSERT( sizeof( pEnumQueryData->dwRetryInterval ) == sizeof( DWORD ) );


	//
	// Make sure someone isn't getting silly.
	//
	if ( g_fIgnoreEnums )
	{
		DPFX(DPFPREP, 0, "Trying to initiate an enumeration when registry option to ignore all enums/response is set!");
		DNASSERT( ! "Trying to initiate an enumeration when registry option to ignore all enums/response is set!" );
	}
	

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pCommand = NULL;
	fInterfaceReferenceAdded = FALSE;
	fEndpointOpen = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	DNASSERT( pSPData != NULL );

	pEnumQueryData->hCommand = NULL;
	pEnumQueryData->dwCommandDescriptor = NULL_DESCRIPTOR;

	DumpAddress( 8, "Enum destination:", pEnumQueryData->pAddressHost );
	DumpAddress( 8, "Enuming on device:", pEnumQueryData->pAddressDeviceInfo );


	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.
	//
	hTempResult = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}


	DNASSERT( pEnumQueryData->pAddressHost != NULL );
	DNASSERT( pEnumQueryData->pAddressDeviceInfo != NULL );
		

	//
	// check SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		// provider is initialized
		case SPSTATE_INITIALIZED:
		{
			//
			// no problem
			//
			DNASSERT( hr == DPNERR_PENDING );
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;

			break;
		}

		// provider is uninitialized
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "EnumQuery called on uninitialized SP!" );
			break;
		}

		// provider is closing
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "EnumQuery called while SP closing!" );
			break;
		}

		// unknown
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		goto Failure;
	}


	//
	// create a new endpoint
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot create new endpoint in DNSP_EnumQuery!" );
		goto Failure;
	}

	//
	// get new command and initialize it
	//
	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot get command handle for DNSP_EnumQuery!" );
		goto Failure;
	}
	
	DPFX(DPFPREP, 7, "(0x%p) Enum query command 0x%p created.",
		pSPData, pCommand);

	pEnumQueryData->hCommand = pCommand;
	pEnumQueryData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_ENUM_QUERY );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open endpoint with outgoing address
	//
	fEndpointOpen = TRUE;
	hr = pEndpoint->Open( ENDPOINT_TYPE_ENUM, pEnumQueryData->pAddressHost, NULL );
	switch ( hr )
	{
		//
		// Incomplete address passed in, query user for more information if
		// we're allowed.  If we're on IPX (no dialog available), don't attempt
		// to display the dialog, skip to checking for broadcast fallback.
		// Since we don't have a complete address at this time,
		// don't bind this endpoint to the socket port!
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
			if ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 ) &&
				 ( pSPData->GetType() == TYPE_IP ) )
			{
				//
				// Copy the connect data locally and start the dialog.  When the
				// dialog completes, the connection will attempt to complete.
				// Since the dialog is being popped, this command is in progress,
				// not pending.
				//
				DNASSERT( pSPData != NULL );

				pCommand->SetState( COMMAND_STATE_INPROGRESS );
				
				hr = pEndpoint->CopyEnumQueryData( pEnumQueryData );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Failed to copy enum query data before settings dialog!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}


				//
				// Initialize the bind type.  It will get changed to DEFAULT or SPECIFIC
				//
				pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Problem showing settings dialog for enum query!" );
					DisplayDNError( 0, hr );

					goto Failure;
				}

				//
				// this endpoint has been handed off, remove our reference to it
				//
				pEndpoint = NULL;
				hr = DPNERR_PENDING;

				goto Exit;
			}
			else
			{
				if ( ( pEnumQueryData->dwFlags & DPNSPF_NOBROADCASTFALLBACK ) == 0 )
				{
					//
					// we're OK, reset the destination address and reset the
					// function return to 'pending'
					//
					pEndpoint->ReinitializeWithBroadcast();
					hr = DPNERR_PENDING;
					goto SubmitDelayedCommand;
				}
				else
				{
					goto Failure;
				}
			}

			break;
		}

		//
		// address conversion was fine, copy connect data and finish connection
		// on background thread.
		//
		case DPN_OK:
		{
SubmitDelayedCommand:
			//
			// Copy enum data and submit job to finish off enum.
			//
			DNASSERT( pSPData != NULL );
			hr = pEndpoint->CopyEnumQueryData( pEnumQueryData );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Failed to copy enum query data before delayed command!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}


			//
			// Initialize the bind type.  It will get changed to DEFAULT or SPECIFIC
			//
			pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


			pEndpoint->AddRef();

			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->EnumQueryJobCallback,
																 pEndpoint->CancelEnumQueryJobCallback,
																 pEndpoint );
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPFX(DPFPREP, 0, "Failed to set delayed enum query!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;
			goto Exit;

			break;
		}

		default:
		{
			//
			// this endpoint is screwed
			//
			DPFX(DPFPREP, 0, "Problem initializing endpoint in DNSP_EnumQuery!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

Exit:

	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPFX(DPFPREP, 0, "Problem with DNSP_EnumQuery()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	//
	// if there's an allocated command, clean up and then
	// return the command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pEnumQueryData->hCommand = NULL;
		pEnumQueryData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	//
	// is there an endpoint to free?
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}
		
		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		DNASSERT( pSPData != NULL );
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_EnumRespond  sends a response to an enum request by
 *		sending the specified data to the address provided (on
 *		unreliable transport).
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_EnumRespond"

STDMETHODIMP DNSP_EnumRespond( IDP8ServiceProvider *pThis, SPENUMRESPONDDATA *pEnumRespondData )
{
	HRESULT			hr;
	CEndpoint		*pEndpoint;
	WRITE_IO_DATA_POOL_CONTEXT	PoolContext;
	CWriteIOData	*pWriteData;
	CSPData			*pSPData;
	const ENDPOINT_ENUM_QUERY_CONTEXT	*pEnumQueryContext;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumRespondData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumRespondData != NULL );
	DNASSERT( pEnumRespondData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	DBG_CASSERT( OFFSETOF( ENDPOINT_ENUM_QUERY_CONTEXT, EnumQueryData ) == 0 );
	pEnumQueryContext = reinterpret_cast<ENDPOINT_ENUM_QUERY_CONTEXT*>( pEnumRespondData->pQuery );
	pEndpoint = NULL;
	pWriteData = NULL;
	pEnumRespondData->hCommand = NULL;
	pEnumRespondData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );
	IDP8ServiceProvider_AddRef( pThis );
	
	//
	// check for valid endpoint
	//
	pEndpoint = pSPData->EndpointFromHandle( pEnumQueryContext->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDENDPOINT;
		DPFX(DPFPREP, 8, "Invalid endpoint handle in DNSP_EnumRespond" );
		goto Failure;
	}

	//
	// no need to poke at the thread pool here to lock down threads because we
	// can only really be here if there's an enum and that enum locked down the
	// thread pool.
	//

	PoolContext.SPType = pSPData->GetType();
	pWriteData = pSPData->GetThreadPool()->GetNewWriteIOData( &PoolContext );
	if ( pWriteData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot get new WRITE_IO_DATA for enum response!" );
		goto Failure;
	}

	pWriteData->m_pCommand->SetType( COMMAND_TYPE_SEND );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );
	pWriteData->m_pCommand->SetEndpoint( pEndpoint );
	pWriteData->m_pCommand->SetUserContext( pEnumRespondData->pvContext );
	DNASSERT( pWriteData->m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_COMPLETE_COMMAND;

	pWriteData->m_uBufferCount = pEnumRespondData->dwBufferCount;
	pWriteData->m_pBuffers = pEnumRespondData->pBuffers;
	pWriteData->m_pDestinationSocketAddress = pEnumQueryContext->pReturnAddress;

	pEnumRespondData->hCommand = pWriteData->m_pCommand;
	pEnumRespondData->dwCommandDescriptor = pWriteData->m_pCommand->GetDescriptor();

	//
	// send data
	//
	pEndpoint->SendEnumResponseData( pWriteData, pEnumQueryContext->dwEnumKey );

Exit:
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}

	IDP8ServiceProvider_Release( pThis );

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	if ( pWriteData != NULL )
	{
		DNASSERT( pSPData != NULL );
		pSPData->GetThreadPool()->ReturnWriteIOData( pWriteData );

		pEnumRespondData->hCommand = NULL;
		pEnumRespondData->dwCommandDescriptor = NULL_DESCRIPTOR;

		pWriteData = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Connect "connects" to the specified address.  This doesn't
 *		necessarily mean a real (TCP) connection is made.  It could
 *		just be a virtual UDP connection
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Connect"

STDMETHODIMP DNSP_Connect( IDP8ServiceProvider *pThis, SPCONNECTDATA *pConnectData )
{
	HRESULT					hr;
	HRESULT					hTempResult;
	CEndpoint				*pEndpoint;
	CCommandData			*pCommand;
	BOOL					fInterfaceReferenceAdded;
	BOOL					fEndpointOpen;
	CSPData					*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pConnectData);

	DNASSERT( pThis != NULL );
	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->pAddressHost != NULL );
	DNASSERT( ( pConnectData->dwFlags & ~( DPNSPF_OKTOQUERY | DPNSPF_ADDITIONALMULTIPLEXADAPTERS ) ) == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pCommand = NULL;
	fInterfaceReferenceAdded = FALSE;
	fEndpointOpen = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	pConnectData->hCommand = NULL;
	pConnectData->dwCommandDescriptor = NULL_DESCRIPTOR;

	DumpAddress( 8, "Connect destination:", pConnectData->pAddressHost );
	DumpAddress( 8, "Connecting on device:", pConnectData->pAddressDeviceInfo );
	
	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.
	//
	hTempResult = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}


	DNASSERT( pConnectData->pAddressHost != NULL );
	DNASSERT( pConnectData->pAddressDeviceInfo != NULL );
	

	//
	// check SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		// provider is initialized
		case SPSTATE_INITIALIZED:
		{
			//
			// no problem, add a reference and proceed
			//
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		// provider is uninitialized
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "Connect called on uninitialized SP!" );

			break;
		}

		// provider is closing
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "Connect called while SP closing!" );

			break;
		}

		// unknown
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		DNASSERT( hr != DPN_OK );
		goto Failure;
	}


	//
	// create a new endpoint
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot create new endpoint in DNSP_Connect!" );
		goto Failure;
	}

	//
	// get new command and initialize it
	//
	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot get command handle for DNSP_Connect!" );
		goto Failure;
	}
	
	DPFX(DPFPREP, 7, "(0x%p) Connect command 0x%p created.",
		pSPData, pCommand);

	pConnectData->hCommand = pCommand;
	pConnectData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_CONNECT );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open endpoint with outgoing address
	//
	fEndpointOpen = TRUE;
	hr = pEndpoint->Open( ENDPOINT_TYPE_CONNECT,
						  pConnectData->pAddressHost,
						  NULL );
	switch ( hr )
	{
		//
		// address conversion was fine, copy connect data and finish connection
		// on background thread.
		//
		case DPN_OK:
		{
			//
			// Copy connection data and submit job to finish off connection.
			// Since we're going to hand off this endpoint, add it to the
			// unbound list so we don't lose track of it.
			//
			DNASSERT( pSPData != NULL );

			hr = pEndpoint->CopyConnectData( pConnectData );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Failed to copy connect data before delayed command!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}


			//
			// Initialize the bind type.  It will get changed to DEFAULT or SPECIFIC
			//
			pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


			pEndpoint->AddRef();

			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->ConnectJobCallback,
																 pEndpoint->CancelConnectJobCallback,
																 pEndpoint );
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPFX(DPFPREP, 0, "Failed to set delayed connect!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;
			goto Exit;

			break;
		}

		//
		// Incomplete address passed in, query user for more information if
		// we're allowed.  Since we don't have a complete address at this time,
		// don't bind this endpoint to the socket port!
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
			{
				//
				// Copy the connect data locally and start the dialog.  When the
				// dialog completes, the connection will attempt to complete.
				// Since a dialog is being displayed, the command is in-progress,
				// not pending.  However, you can't cancel the dialog once it's
				// displayed (the UI would suddenly disappear).
				//
				pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
				
				hr = pEndpoint->CopyConnectData( pConnectData );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Failed to copy connect data before dialog!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}

				//
				// Initialize the bind type.  It will get changed to DEFAULT or SPECIFIC
				//
				pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Problem showing settings dialog for connect!" );
					DisplayDNError( 0, hr );

					goto Failure;
				}

				//
				// this endpoint has been handed off, remove our reference to it
				//
				pEndpoint = NULL;
				hr = DPNERR_PENDING;

				goto Exit;
			}
			else
			{
				goto Failure;
			}

			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Problem initializing endpoint in DNSP_Connect!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

Exit:
	
	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPFX(DPFPREP, 0, "Problem with DNSP_Connect()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	//
	// if there's an allocated command, clean up and then
	// return the command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pConnectData->hCommand = NULL;
		pConnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	//
	// is there an endpoint to free?
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Disconnect disconnects an active connection
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Disconnect"

STDMETHODIMP DNSP_Disconnect( IDP8ServiceProvider *pThis, SPDISCONNECTDATA *pDisconnectData )
{
	HRESULT		hr;
	HRESULT		hTempResult;
	CEndpoint	*pEndpoint;
	CSPData		*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pDisconnectData);

	DNASSERT( pThis != NULL );
	DNASSERT( pDisconnectData != NULL );
	DNASSERT( pDisconnectData->dwFlags == 0 );
	DNASSERT( pDisconnectData->hEndpoint != INVALID_HANDLE_VALUE );
	DNASSERT( pDisconnectData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	pEndpoint = NULL;
	pDisconnectData->hCommand = NULL;
	pDisconnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to poke at the thread pool here because there was already a connect
	// issued and that connect should have locked down the thread pool.
	//

	//
	// check service provider state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "Disconnect called on uninitialized SP!" );
			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "Disconnect called on closing SP!" );
			break;
		}

		//
		// unknown
		//
		default:
		{
			hr = DPNERR_GENERIC;
			DNASSERT( FALSE );
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// look up the endpoint and if it's found, close its handle
	//
	pEndpoint = pSPData->GetEndpointAndCloseHandle( pDisconnectData->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDENDPOINT;
		goto Failure;
	}
	
	hTempResult = pEndpoint->Disconnect( pDisconnectData->hEndpoint );
	switch ( hTempResult )
	{
		//
		// endpoint disconnected immediately
		//
		case DPNERR_PENDING:
		case DPN_OK:
		{
			break;
		}

		//
		// Other return.  Since the disconnect didn't complete, we need
		// to unlock the endpoint.
		//
		default:
		{
			DPFX(DPFPREP, 0, "Error reported when attempting to disconnect endpoint in DNSP_Disconnect!" );
			DisplayDNError( 0, hTempResult );
			DNASSERT( FALSE );

			break;
		}
	}

Exit:
	//
	// remove outstanding reference from GetEndpointHandleAndClose()
	//
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecRef();
		pEndpoint = NULL;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Listen "listens" on the specified address/port.  This doesn't
 *		necessarily mean that a true TCP socket is used.  It could just
 *		be a UDP port that's opened for receiving packets
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Listen"

STDMETHODIMP DNSP_Listen( IDP8ServiceProvider *pThis, SPLISTENDATA *pListenData)
{
	HRESULT					hr;
	HRESULT					hTempResult;
	CEndpoint				*pEndpoint;
	CCommandData			*pCommand;
	IDirectPlay8Address		*pDeviceAddress;
	BOOL					fInterfaceReferenceAdded;
	BOOL					fEndpointOpen;
	CSPData					*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pListenData);

	DNASSERT( pThis != NULL );
	DNASSERT( pListenData != NULL );
	DNASSERT( ( pListenData->dwFlags & ~( DPNSPF_OKTOQUERY | DPNSPF_BINDLISTENTOGATEWAY ) ) == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pCommand = NULL;
//	pLocalAddress = NULL;
//	pSocketPort = NULL;
	pDeviceAddress = NULL;
	fInterfaceReferenceAdded = FALSE;
	fEndpointOpen = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	pListenData->hCommand = NULL;
	pListenData->dwCommandDescriptor = NULL_DESCRIPTOR;

	DumpAddress( 8, "Listening on device:", pListenData->pAddressDeviceInfo );


	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.
	//
	hTempResult = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hTempResult != DPN_OK )
	{
		hr = hTempResult;
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}


	//
	// AddRef the device address.
	//
	IDirectPlay8Address_AddRef(pListenData->pAddressDeviceInfo);
	pDeviceAddress = pListenData->pAddressDeviceInfo;
	

	//
	// check service provider state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPNERR_PENDING );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "Listen called on uninitialized SP!" );
			DNASSERT( FALSE );
			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "Listen called on closing SP!" );
			DNASSERT( FALSE );
			break;
		}

		//
		// unknown
		//
		default:
		{
			hr = DPNERR_GENERIC;
			DNASSERT( FALSE );
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPNERR_PENDING )
	{
		goto Failure;
	}

	//
	// create a new endpoint
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot create new endpoint in DNSP_Listen!" );
		goto Failure;
	}

	//
	// get new command and initialize it
	//
	pCommand = CreateCommand();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot get command handle for DNSP_Listen!" );
		goto Failure;
	}
	
	DPFX(DPFPREP, 7, "(0x%p) Listen command 0x%p created.",
		pSPData, pCommand);

	pListenData->hCommand = pCommand;
	pListenData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_LISTEN );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open endpoint with outgoing address
	//
	fEndpointOpen = TRUE;
	hr = pEndpoint->Open( ENDPOINT_TYPE_LISTEN, NULL, NULL );
	switch ( hr )
	{
		//
		// address conversion was fine, copy connect data and finish connection
		// on background thread.
		//
		case DPN_OK:
		{
			//
			// Copy listen data and submit job to finish off listen.
			//
			DNASSERT( pSPData != NULL );

			hr = pEndpoint->CopyListenData( pListenData, pDeviceAddress );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Failed to copy listen data before delayed command!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}


			//
			// Initialize the bind type.
			//
			if ((pListenData->dwFlags & DPNSPF_BINDLISTENTOGATEWAY))
			{
				//
				// This must always stay SPECIFIC_SHARED.
				//
				pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_SPECIFIC_SHARED);
			}
			else
			{
				//
				// This will get changed to DEFAULT or SPECIFIC.
				//
				pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);
			}



			pEndpoint->AddRef();

			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( pEndpoint->ListenJobCallback,
																 pEndpoint->CancelListenJobCallback,
																 pEndpoint );
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPFX(DPFPREP, 0, "Failed to set delayed listen!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;

			break;
		}

		//
		// Incomplete address passed in, query user for more information if
		// we're allowed.  Since we don't have a complete address at this time,
		// don't bind this endpoint to the socket port!
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
			{
				//
				// Copy the listen data locally and start the dialog.  When the
				// dialog completes, the connection will attempt to complete.
				// Since this endpoint is being handed off to another thread,
				// make sure it's in the unbound list.  Since a dialog is being
				// displayed, the command state is in progress, not pending.
				//
				DNASSERT( pSPData != NULL );

				hr = pEndpoint->CopyListenData( pListenData, pDeviceAddress );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Failed to copy listen data before dialog!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}


				//
				// Initialize the bind type.
				//
				if ((pListenData->dwFlags & DPNSPF_BINDLISTENTOGATEWAY))
				{
					//
					// This must always stay SPECIFIC_SHARED.
					//
					pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_SPECIFIC_SHARED);
				}
				else
				{
					//
					// This will get changed to DEFAULT or SPECIFIC.
					//
					pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);
				}


				pCommand->SetState( COMMAND_STATE_INPROGRESS );
				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Problem showing settings dialog for listen!" );
					DisplayDNError( 0, hr );

					goto Failure;
				}

				//
				// this endpoint has been handed off, remove our reference to it
				//
				pEndpoint = NULL;
				hr = DPNERR_PENDING;

				goto Exit;
			}
			else
			{
				goto Failure;
			}

			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Problem initializing endpoint in DNSP_Listen!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

Exit:
	if ( pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( pDeviceAddress );
		pDeviceAddress = NULL;
	}

	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPFX(DPFPREP, 0, "Problem with DNSP_Listen()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	//
	// if there's an allocated command, clean up and then
	// return the command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pListenData->hCommand = NULL;
		pListenData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	//
	// is there an endpoint to free?
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	//
	// clean up any outstanding references
	//

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_SendData sends data to the specified "player"
 *
 *	This call MUST BE HIGHLY OPTIMIZED
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_SendData"

STDMETHODIMP DNSP_SendData( IDP8ServiceProvider *pThis, SPSENDDATA *pSendData )
{
	HRESULT			hr;
	CEndpoint		*pEndpoint;
	WRITE_IO_DATA_POOL_CONTEXT	PoolContext;
	CWriteIOData	*pWriteData;
	CSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pSendData);

	DNASSERT( pThis != NULL );
	DNASSERT( pSendData != NULL );
	DNASSERT( pSendData->pBuffers != NULL );
	DNASSERT( pSendData->dwBufferCount != 0 );
	DNASSERT( pSendData->hEndpoint != INVALID_HANDLE_VALUE );
	DNASSERT( pSendData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pSendData->hCommand = NULL;
	pSendData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pWriteData = NULL;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// No need to lock down the thread counts here because the user already has
	// a connect or something running or they wouldn't be calling this function.
	// That outstanding connect would have locked down the thread pool.
	//

	//
	// Attempt to grab the endpoint from the handle.  If this succeeds, the
	// endpoint can send.
	//
	pEndpoint = pSPData->EndpointFromHandle( pSendData->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDHANDLE;
		DPFX(DPFPREP, 0, "Invalid endpoint handle on send!" );
		goto Failure;
	}
	
	//
	// send data from pool
	//
	PoolContext.SPType = pSPData->GetType();
	pWriteData = pSPData->GetThreadPool()->GetNewWriteIOData( &PoolContext );
	if ( pWriteData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot get new write data from pool in SendData!" );
		goto Failure;
	}
	DNASSERT( pWriteData->m_pCommand != NULL );
	DNASSERT( pWriteData->SocketPort() == NULL );

	//
	// set the command state and fill in the message information
	//
	pWriteData->m_pCommand->SetType( COMMAND_TYPE_SEND );
	pWriteData->m_pCommand->SetState( COMMAND_STATE_PENDING );
	pWriteData->m_pCommand->SetEndpoint( pEndpoint );
	pWriteData->m_pCommand->SetUserContext( pSendData->pvContext );
	DNASSERT( pWriteData->m_SendCompleteAction == SEND_COMPLETE_ACTION_UNKNOWN );
	pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_COMPLETE_COMMAND;

	DNASSERT( pSendData->dwBufferCount != 0 );
	pWriteData->m_uBufferCount = pSendData->dwBufferCount;
	pWriteData->m_pBuffers = pSendData->pBuffers;
	pWriteData->m_pDestinationSocketAddress = pEndpoint->GetRemoteAddressPointer();

	pSendData->hCommand = pWriteData->m_pCommand;
	pSendData->dwCommandDescriptor = pWriteData->m_pCommand->GetDescriptor();

	//
	// send data through the endpoint
	//
	pEndpoint->SendUserData( pWriteData );

Exit:
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	if ( pWriteData != NULL )
	{
		pSPData->GetThreadPool()->ReturnWriteIOData( pWriteData );
		DEBUG_ONLY( pWriteData = NULL );
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_CancelCommand cancels a command in progress
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_CancelCommand"

STDMETHODIMP DNSP_CancelCommand( IDP8ServiceProvider *pThis, HANDLE hCommand, DWORD dwCommandDescriptor )
{
	HRESULT hr;
	CCommandData	*pCommandData;
	BOOL			fCommandLocked;
	BOOL			fReferenceAdded;
	CSPData			*pSPData;
	CEndpoint		*pEndpoint;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p, %ld)", pThis, hCommand, dwCommandDescriptor);

	DNASSERT( pThis != NULL );
	DNASSERT( hCommand != NULL );
	DNASSERT( dwCommandDescriptor != NULL_DESCRIPTOR );

	//
	// initialize
	//
	hr = DPN_OK;
	fCommandLocked = FALSE;
	fReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// No need to lock the thread pool counts because there's already some outstanding
	// enum, connect or listen running that has done so.
	//

	//
	// check SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fReferenceAdded = TRUE;
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "CancelCommand called on uninitialized SP!" );
			DNASSERT( FALSE );
			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "CancelCommand called on closing SP!" );
			DNASSERT( FALSE );
			break;
		}

		//
		// unknown
		//
		default:
		{
			hr = DPNERR_GENERIC;
			DNASSERT( FALSE );
			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Exit;
	}
	

	pCommandData = static_cast<CCommandData*>( hCommand );

	pCommandData->Lock();
	fCommandLocked = TRUE;

	//
	// make sure the right command is being cancelled
	//
	if ( dwCommandDescriptor != pCommandData->GetDescriptor() )
	{
		hr = DPNERR_INVALIDCOMMAND;
		DPFX(DPFPREP, 0, "Attempt to cancel command (0x%p) with mismatched command descriptor (%u != %u)!",
			hCommand, dwCommandDescriptor, pCommandData->GetDescriptor() );
		goto Exit;
	}

	switch ( pCommandData->GetState() )
	{
		//
		// unknown command state
		//
		case COMMAND_STATE_UNKNOWN:
		{
			hr = DPNERR_INVALIDCOMMAND;
			DNASSERT( FALSE );
			break;
		}

		//
		// command is waiting to be processed, set command state to be cancelling
		// and wait for someone to pick it up
		//
		case COMMAND_STATE_PENDING:
		{
			DPFX(DPFPREP, 5, "Marking command 0x%p as cancelling.", pCommandData);
			pCommandData->SetState( COMMAND_STATE_CANCELLING );
			break;
		}

		//
		// command in progress, and can't be cancelled
		//
		case COMMAND_STATE_INPROGRESS_CANNOT_CANCEL:
		{
			DPFX(DPFPREP, 1, "Cannot cancel command 0x%p.", pCommandData);
			hr = DPNERR_CANNOTCANCEL;
			break;
		}

		//
		// Command is already being cancelled.  This is not a problem, but shouldn't
		// be happening for any endpoints other than connects.
		//
		case COMMAND_STATE_CANCELLING:
		{
			DNASSERT( pCommandData->GetEndpoint()->GetType() == ENDPOINT_TYPE_CONNECT );
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// command is in progress, find out what type of command it is
		//
		case COMMAND_STATE_INPROGRESS:
		{
			switch ( pCommandData->GetType() )
			{
				case COMMAND_TYPE_UNKNOWN:
				{
					// we should never be here
					DNASSERT( FALSE );
					break;
				}

				case COMMAND_TYPE_CONNECT:
				case COMMAND_TYPE_LISTEN:
				{
					//
					// Set this command to the cancel state before we shut down
					// this endpoint.  Make sure a reference is added to the
					// endpoint so it stays around for the cancel.
					//
					pCommandData->SetState( COMMAND_STATE_CANCELLING );
					pEndpoint = pCommandData->GetEndpoint();
					pEndpoint->AddRef();

					DPFX(DPFPREP, 3, "Cancelling %s command 0x%p (endpoint 0x%p).",
						((pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT) ? "connect" : "listen"),
						pCommandData, pEndpoint);

					pCommandData->Unlock();
					fCommandLocked = FALSE;

					pEndpoint->Lock();
					switch ( pEndpoint->GetState() )
					{
						//
						// endpoint is already disconnecting, no action needs to be taken
						//
						case ENDPOINT_STATE_DISCONNECTING:
						{
							pEndpoint->Unlock();
							pEndpoint->DecRef();
							goto Exit;
							break;
						}

						//
						// Endpoint is connecting.  Flag it as disconnecting and
						// add a reference so it doesn't disappear on us.
						//
						case ENDPOINT_STATE_ATTEMPTING_CONNECT:
						{
							DNASSERT(pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT);
							pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
							break;
						}

						//
						// Endpoint has finished connecting.  Report that the
						// command is uncancellable.  Sorry Charlie, we missed
						// the window.
						//
						case ENDPOINT_STATE_CONNECT_CONNECTED:
						{
							DNASSERT(pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT);
							DPFX(DPFPREP, 1, "Cannot cancel connect command 0x%p (endpoint 0x%p) that's already (or is about to) complete.",
								pCommandData, pEndpoint);
							pEndpoint->Unlock();
							pEndpoint->DecRef();
							hr = DPNERR_CANNOTCANCEL;
							goto Exit;
							break;
						}

						//
						// Endpoint is listening.  Flag it as disconnecting and
						// add a reference so it doesn't disappear on us
						//
						case ENDPOINT_STATE_LISTEN:
						{
							DNASSERT(pEndpoint->GetType() == ENDPOINT_TYPE_LISTEN);
							pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
							break;
						}

						//
						// other state
						//
						default:
						{
							DNASSERT( FALSE );
							break;
						}
					}

					pEndpoint->Unlock();

					pEndpoint->Close( DPNERR_USERCANCEL );
					pSPData->CloseEndpointHandle( pEndpoint );
					pEndpoint->DecRef();

					break;
				}

				case COMMAND_TYPE_ENUM_QUERY:
				{
					pEndpoint = pCommandData->GetEndpoint();
					DNASSERT( pEndpoint != NULL );

					DPFX(DPFPREP, 3, "Cancelling enum query command 0x%p (endpoint 0x%p).",
						pCommandData, pEndpoint);
					
					pEndpoint->AddRef();

					pCommandData->SetState( COMMAND_STATE_CANCELLING );
					pCommandData->Unlock();
					fCommandLocked = FALSE;
						
					pEndpoint->StopEnumCommand( DPNERR_USERCANCEL );
					pEndpoint->DecRef();

					break;
				}

				case COMMAND_TYPE_SEND:
				{
					// we should never be here
					DNASSERT( FALSE );
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// other command state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}


Exit:
	if ( fCommandLocked != FALSE  )
	{
		DNASSERT( pCommandData != NULL );
		pCommandData->Unlock();
		fCommandLocked = FALSE;
	}

	if ( fReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_GetCaps - get SP capabilities
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_GetCaps"

STDMETHODIMP	DNSP_GetCaps( IDP8ServiceProvider *pThis, SPGETCAPSDATA *pCapsData )
{
	HRESULT		hr;
	BOOL		fInterfaceReferenceAdded;
	CSPData		*pSPData;
	LONG		iIOThreadCount;
	

	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pCapsData);

	DNASSERT( pThis != NULL );
	DNASSERT( pCapsData != NULL );
	DNASSERT( pCapsData->dwSize == sizeof( *pCapsData ) );

	//
	// initialize
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "AddToGroup called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "AddToGroup called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// set flags
	//
	pCapsData->dwFlags = 0;
	pCapsData->dwFlags |= ( DPNSPCAPS_SUPPORTSDPNSRV |
							DPNSPCAPS_SUPPORTSBROADCAST |
							DPNSPCAPS_SUPPORTSALLADAPTERS );

	//
	// set frame sizes
	//
	pCapsData->dwUserFrameSize = MAX_USER_PAYLOAD;
	pCapsData->dwEnumFrameSize = 1000;

	//
	// Set link speed, no need to check for endpoint because
	// the link speed cannot be determined.
	//
	pCapsData->dwLocalLinkSpeed = UNKNOWN_BANDWIDTH;

	hr = pSPData->GetThreadPool()->GetIOThreadCount( &iIOThreadCount );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "DNSP_GetCaps: Failed to get thread pool count!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	pCapsData->dwIOThreadCount = iIOThreadCount;

	//
	// set enumeration defaults
	//
	pCapsData->dwDefaultEnumRetryCount = DEFAULT_ENUM_RETRY_COUNT;
	pCapsData->dwDefaultEnumRetryInterval = DEFAULT_ENUM_RETRY_INTERVAL;
	pCapsData->dwDefaultEnumTimeout = DEFAULT_ENUM_TIMEOUT;

	//
	// set buffering information
	//
	DNASSERT( g_dwWinsockReceiveBufferMultiplier <= UINT32_MAX );
	pCapsData->dwBuffersPerThread = static_cast<DWORD>( g_dwWinsockReceiveBufferMultiplier );
	pCapsData->dwSystemBufferSize = 8192;

	if ( g_fWinsockReceiveBufferSizeOverridden == FALSE )
	{
		SOCKET		TestSocket;
	
		
		TestSocket = INVALID_SOCKET;
		switch ( pSPData->GetType() )
		{
			case TYPE_IP:
			{
				TestSocket = p_socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
				break;
			}

			case TYPE_IPX:
			{
				TestSocket = p_socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
				break;
			}

			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}

		if ( TestSocket != INVALID_SOCKET )
		{
			INT		iBufferSize;
			INT		iBufferSizeSize;
			INT		iWSAReturn;


			iBufferSizeSize = sizeof( iBufferSize );
			iWSAReturn = p_getsockopt( TestSocket,									// socket
									   SOL_SOCKET,									// socket level option
									   SO_RCVBUF,									// socket option
									   reinterpret_cast<char*>( &iBufferSize ),		// pointer to destination
									   &iBufferSizeSize								// pointer to destination size
									   );
			if ( iWSAReturn != SOCKET_ERROR )
			{
				pCapsData->dwSystemBufferSize = iBufferSize;
			}
			else
			{
				DPFX(DPFPREP, 0, "Failed to get socket receive buffer options!" );
				DisplayWinsockError( 0, iWSAReturn );
			}

			p_closesocket( TestSocket );
			TestSocket = INVALID_SOCKET;
		}
	}
	else
	{
		pCapsData->dwSystemBufferSize = g_iWinsockReceiveBufferSize;
	}

Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_SetCaps - set SP capabilities
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_SetCaps"

STDMETHODIMP	DNSP_SetCaps( IDP8ServiceProvider *pThis, SPSETCAPSDATA *pCapsData )
{
	HRESULT			hr;
	BOOL			fInterfaceReferenceAdded;
	CSPData			*pSPData;
	CRegistry		RegObject;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pCapsData);

	DNASSERT( pThis != NULL );
	DNASSERT( pCapsData != NULL );
	DNASSERT( pCapsData->dwSize == sizeof( *pCapsData ) );


	//
	// initialize
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "AddToGroup called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "AddToGroup called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// validate caps
	//
	if ( pCapsData->dwBuffersPerThread == 0 )
	{
		DPFX(DPFPREP, 0, "Failing SetCaps because dwBuffersPerThread == 0" );
		hr = DPNERR_INVALIDPARAM;
		goto Failure;
	}

	//
	// change thread count
	//
	DNASSERT( pCapsData->dwIOThreadCount != 0 );
	hr = pSPData->GetThreadPool()->SetIOThreadCount( pCapsData->dwIOThreadCount );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "DNSP_SetCaps: Failed to set thread pool count!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	//
	// Only update the thread multiplier if there is a difference.  Give precedence
	// to any values in the registry.
	//
	if ( pCapsData->dwBuffersPerThread > g_dwWinsockReceiveBufferMultiplier )
	{
		BOOL	fSetBufferMultiplier;
		DWORD	dwDelta;


		fSetBufferMultiplier = FALSE;
		dwDelta = 0;
		if ( RegObject.Open( HKEY_LOCAL_MACHINE, g_RegistryBase ) != FALSE )
		{
			DWORD	dwRegBufferMultiplier;


			if ( RegObject.ReadDWORD( g_RegistryKeyReceiveBufferMultiplier, dwRegBufferMultiplier ) != FALSE )
			{
				if ( dwRegBufferMultiplier > g_dwWinsockReceiveBufferMultiplier )
				{
					fSetBufferMultiplier = TRUE;
					DNASSERT( g_dwWinsockReceiveBufferMultiplier <= UINT32_MAX );
					dwDelta = dwRegBufferMultiplier - static_cast<DWORD>( g_dwWinsockReceiveBufferMultiplier );
					g_dwWinsockReceiveBufferMultiplier = dwRegBufferMultiplier;
				}
			}
			else
			{
				fSetBufferMultiplier = TRUE;
				DNASSERT( g_dwWinsockReceiveBufferMultiplier <= UINT32_MAX );
				dwDelta = pCapsData->dwBuffersPerThread - static_cast<DWORD>( g_dwWinsockReceiveBufferMultiplier );
				g_dwWinsockReceiveBufferMultiplier = pCapsData->dwBuffersPerThread;
			}
		}
		else
		{
			fSetBufferMultiplier = TRUE;
			DNASSERT( g_dwWinsockReceiveBufferMultiplier <= UINT32_MAX );
			dwDelta = pCapsData->dwBuffersPerThread - static_cast<DWORD>( g_dwWinsockReceiveBufferMultiplier );
			g_dwWinsockReceiveBufferMultiplier = pCapsData->dwBuffersPerThread;
		}
	
		if ( fSetBufferMultiplier != FALSE )
		{
			pSPData->IncreaseOutstandingReceivesOnAllSockets( dwDelta );
		}
	}


	//
	// Set the receive buffer size.
	//
	DBG_CASSERT( sizeof( pCapsData->dwSystemBufferSize ) == sizeof( g_iWinsockReceiveBufferSize ) );
	g_fWinsockReceiveBufferSizeOverridden = TRUE;
	g_iWinsockReceiveBufferSize = pCapsData->dwSystemBufferSize;
	pSPData->SetWinsockBufferSizeOnAllSockets( g_iWinsockReceiveBufferSize );


Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_ReturnReceiveBuffers - return receive buffers to pool
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_ReturnReceiveBuffers"

STDMETHODIMP	DNSP_ReturnReceiveBuffers( IDP8ServiceProvider *pThis, SPRECEIVEDBUFFER *pReceivedBuffers )
{
	SPRECEIVEDBUFFER	*pBuffers;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pReceivedBuffers);

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	DNASSERT( pThis != NULL );
	DNASSERT( pReceivedBuffers != NULL );

	pBuffers = pReceivedBuffers;
	while ( pBuffers != NULL )
	{
		SPRECEIVEDBUFFER	*pTemp;
		CReadIOData			*pReadData;


		pTemp = pBuffers;
		pBuffers = pBuffers->pNext;
		pReadData = CReadIOData::ReadDataFromSPReceivedBuffer( pTemp );
		DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
		pReadData->DecRef();
	}

	//DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);
	DPFX(DPFPREP, 2, "Returning: DPN_OK");

	return DPN_OK;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_GetAddressInfo - get address information for an endpoint
//
// Entry:		Pointer to DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_GetAddressInfo"

STDMETHODIMP	DNSP_GetAddressInfo( IDP8ServiceProvider *pThis, SPGETADDRESSINFODATA *pGetAddressInfoData )
{
	HRESULT		hr;
	CEndpoint	*pEndpoint;
	CSPData		*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pGetAddressInfoData);

	DNASSERT( pThis != NULL );
	DNASSERT( pGetAddressInfoData != NULL );
	DNASSERT( pGetAddressInfoData->hEndpoint != INVALID_HANDLE_VALUE );
	DNASSERT( ( pGetAddressInfoData->Flags & ~( SP_GET_ADDRESS_INFO_LOCAL_ADAPTER |
												SP_GET_ADDRESS_INFO_REMOTE_HOST |
												SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES |
												SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS ) ) == 0 );


	//
	// initialize
	//
	hr = DPN_OK;
	DBG_CASSERT( sizeof( pEndpoint ) == sizeof( pGetAddressInfoData->hEndpoint ) );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//
	pEndpoint = pSPData->EndpointFromHandle( pGetAddressInfoData->hEndpoint );
	if ( pEndpoint != NULL )
	{
		switch ( pGetAddressInfoData->Flags )
		{
			case SP_GET_ADDRESS_INFO_REMOTE_HOST:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetRemoteHostDP8Address();
				break;
			}

			case SP_GET_ADDRESS_INFO_LOCAL_ADAPTER:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT );
				break;
			}

			case SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( SP_ADDRESS_TYPE_HOST );
				break;
			}

			case SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS );
				break;
			}

			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}
	else
	{
		hr = DPNERR_INVALIDENDPOINT;
	}

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem getting DNAddress from endpoint!" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_IsApplicationSupported - determine if this application is supported by this
//		SP.
//
// Entry:		Pointer to DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_IsApplicationSupported"

STDMETHODIMP	DNSP_IsApplicationSupported( IDP8ServiceProvider *pThis, SPISAPPLICATIONSUPPORTEDDATA *pIsApplicationSupportedData )
{
	HRESULT			hr;
	BOOL			fInterfaceReferenceAdded;
	CSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pIsApplicationSupportedData);

	DNASSERT( pThis != NULL );
	DNASSERT( pIsApplicationSupportedData != NULL );
	DNASSERT( pIsApplicationSupportedData->pApplicationGuid != NULL );
	DNASSERT( pIsApplicationSupportedData->dwFlags == 0 );

	//
	// initialize, we support all applications with this SP
	//
	hr = DPN_OK;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "AddToGroup called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "AddToGroup called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

Exit:
	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_EnumAdapters - get a list of adapters for this SP
//
// Entry:		Pointer DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_EnumAdapters"

STDMETHODIMP	DNSP_EnumAdapters( IDP8ServiceProvider *pThis, SPENUMADAPTERSDATA *pEnumAdaptersData )
{
	HRESULT			hr;
	CSocketAddress	*pSPAddress;
	BOOL			fInterfaceReferenceAdded;
	CSPData			*pSPData;	


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumAdaptersData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumAdaptersData != NULL );
	DNASSERT( ( pEnumAdaptersData->pAdapterData != NULL ) ||
			  ( pEnumAdaptersData->dwAdapterDataSize == 0 ) );
	DNASSERT( pEnumAdaptersData->dwFlags == 0 );


	//
	// initialize
	//
	hr = DPN_OK;
	pEnumAdaptersData->dwAdapterCount = 0;
	pSPAddress = NULL;
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "EnumAdapters called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "EnumAdapters called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// get an SP address from the pool to perform conversions to GUIDs
	//
	pSPAddress = pSPData->GetNewAddress();
	if ( pSPAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to get address for GUID conversions in DNSP_EnumAdapters!" );
		goto Failure;
	}

	//
	// enumerate adapters
	//
	hr = pSPAddress->EnumAdapters( pEnumAdaptersData );
	if ( hr != DPN_OK )
	{
		if (hr == DPNERR_BUFFERTOOSMALL)
		{
			DPFX(DPFPREP, 1, "Buffer too small for enumerating adapters.");
		}
		else
		{
			DPFX(DPFPREP, 0, "Problem enumerating adapters (err = 0x%lx)!", hr);
			DisplayDNError( 0, hr );
		}

		goto Failure;
	}

Exit:
	if ( pSPAddress != NULL )
	{
		pSPData->ReturnAddress( pSPAddress );
		pSPAddress = NULL;
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_ProxyEnumQuery - proxy an enum query
//
// Entry:		Pointer DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_ProxyEnumQuery"

STDMETHODIMP	DNSP_ProxyEnumQuery( IDP8ServiceProvider *pThis, SPPROXYENUMQUERYDATA *pProxyEnumQueryData )
{
	HRESULT			hr;
	BOOL			fInterfaceReferenceAdded;
	CSPData			*pSPData;
	WRITE_IO_DATA_POOL_CONTEXT	PoolContext;
	CSocketAddress	*pDestinationAddress;
	CSocketAddress	*pReturnAddress;
	CWriteIOData	*pWriteData;
	CEndpoint		*pEndpoint;
	const ENDPOINT_ENUM_QUERY_CONTEXT	*pEndpointEnumContext;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pProxyEnumQueryData);

	DNASSERT( pThis != NULL );
	DNASSERT( pProxyEnumQueryData != NULL );
	DNASSERT( pProxyEnumQueryData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	DBG_CASSERT( OFFSETOF( ENDPOINT_ENUM_QUERY_CONTEXT, EnumQueryData ) == 0 );
	pEndpointEnumContext = reinterpret_cast<ENDPOINT_ENUM_QUERY_CONTEXT*>( pProxyEnumQueryData->pIncomingQueryData );
	fInterfaceReferenceAdded = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	pDestinationAddress = NULL;
	pReturnAddress = NULL;
	pWriteData = NULL;
	pEndpoint = NULL;

	//
	// No need to tell thread pool to lock the thread count for this function
	// because there's already an outstanding enum that did.
	//

	//
	// validate SP state
	//
	pSPData->Lock();
	switch ( pSPData->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pThis );
			fInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "ProxyEnumQuery called on uninitialized SP!" );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
			DPFX(DPFPREP, 0, "ProxyEnumQuery called while SP closing!" );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPData->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

	//
	// preallocate addresses
	//
	pDestinationAddress = pSPData->GetNewAddress();
	if ( pDestinationAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	pReturnAddress = pSPData->GetNewAddress();
	if ( pReturnAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// set the endpoint and send it along
	//
	pEndpoint = pSPData->EndpointFromHandle( pEndpointEnumContext->hEndpoint );
	if ( pEndpoint != NULL )
	{
		//
		// set destination address from the supplied data
		//
		hr = pDestinationAddress->SocketAddressFromDP8Address( pProxyEnumQueryData->pDestinationAdapter,
															   SP_ADDRESS_TYPE_DEVICE_PROXIED_ENUM_TARGET );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "ProxyEnumQuery: Failed to convert target adapter address" );
			goto Failure;
		}
	
		//
		// set return address from incoming enum query
		//
		DBG_CASSERT( sizeof( *pReturnAddress->GetWritableAddress() ) == sizeof( *( pEndpointEnumContext->pReturnAddress->GetAddress() ) ) );
		memcpy( pReturnAddress->GetWritableAddress(),
				pEndpointEnumContext->pReturnAddress->GetAddress(),
				sizeof( *pReturnAddress->GetWritableAddress() ) );
	
		//
		// get write data from pool
		//
		PoolContext.SPType = pSPData->GetType();
		pWriteData = pSPData->GetThreadPool()->GetNewWriteIOData( &PoolContext );
		if ( pWriteData == NULL )
		{
			DPFX(DPFPREP, 0, "ProxyEnumQuery: Failed to get write data!" );
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
	
		//
		// a new address is allocated here and will be returned in the send complete
		// code
		//
		pWriteData->m_pDestinationSocketAddress = pDestinationAddress;
	
		//
		// Copy the input BUFFERDESC into the local buffers for sending proxied enum data.
		// The second local buffer is reserved for the SP to prepend data
		//
		pWriteData->m_pBuffers = &pWriteData->m_ProxyEnumSendBuffers[ 1 ];
		DBG_CASSERT( sizeof( pWriteData->m_ProxyEnumSendBuffers[ 1 ] ) == sizeof( pProxyEnumQueryData->pIncomingQueryData->pReceivedData->BufferDesc ) );
		memcpy( &pWriteData->m_ProxyEnumSendBuffers[ 1 ],
				&pProxyEnumQueryData->pIncomingQueryData->pReceivedData->BufferDesc,
				sizeof( pWriteData->m_ProxyEnumSendBuffers[ 1 ] ) );
		pWriteData->m_uBufferCount = 1;
		
		//
		// add a reference to the original receive buffer to prevent it from going
		// away while the enum response send is pending
		//
		pWriteData->m_pProxiedEnumReceiveBuffer = CReadIOData::ReadDataFromSPReceivedBuffer( pProxyEnumQueryData->pIncomingQueryData->pReceivedData );
		DNASSERT( pWriteData->m_pProxiedEnumReceiveBuffer != NULL );
		pWriteData->m_pProxiedEnumReceiveBuffer->AddRef();
	
		pWriteData->m_SendCompleteAction = SEND_COMPLETE_ACTION_PROXIED_ENUM_CLEANUP;
	
		pEndpoint->SendProxiedEnumData( pWriteData, pReturnAddress, pEndpointEnumContext->dwEnumKey );
		pEndpoint->DecCommandRef();
	}

Exit:
	if ( pReturnAddress != NULL )
	{
	    pSPData->ReturnAddress( pReturnAddress );
	    pReturnAddress = NULL;
	}

	if ( fInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fInterfaceReferenceAdded = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_NotSupported is used for methods required to implement the
 *  interface but that are not supported by this SP.
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_NotSupported"

STDMETHODIMP DNSP_NotSupported( IDP8ServiceProvider *pThis, PVOID pvParam )
{
	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pvParam);
	DPFX(DPFPREP, 2, "Returning: [DPNERR_UNSUPPORTED]");
	return DPNERR_UNSUPPORTED;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\common\dputils.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dputils.c
 *  Content:	common support routines
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *  3/17/97	kipo	created it
 ***************************************************************************/

#include <windows.h>

#include "dpf.h"
#include "dputils.h"

/*
 ** WideToAnsi
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpStr - destination string
 *				lpWStr - string to convert
 *				cchStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to ansi lpStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr)
{
	int rval;
	BOOL bDefault;


	bDefault = FALSE;
	if (!lpWStr && cchStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DDASSERT(FALSE);
		return 0;
	}
	
	// use the default code page (CP_ACP)
	// -1 indicates WStr must be null terminated
	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
			DPLAY_DEFAULT_CHAR,&bDefault);

	if (bDefault)
	{
		DPF(0,"!!! WARNING - used default string in WideToAnsi conversion.!!!");
		DPF(0,"!!! Possible bad unicode string - (you're not hiding ansi in there are you?) !!! ");
	}
	
	return rval;

} // WideToAnsi

/*
 ** AnsiToWide
 *
 *  CALLED BY: everywhere
 *
 *  PARAMETERS: lpWStr - dest string
 *				lpStr  - string to convert
 *				cchWstr - size of dest buffer
 *
 *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr
 *
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr)
{
	int rval;

	if (!lpStr && cchWStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DDASSERT(FALSE);
		return 0;
	}

	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);

	return rval;
}  // AnsiToWide
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\common\dputils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dputils.h
 *  Content:	common upport routines
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *  3/17/97	kipo	created it
 ***************************************************************************/

#include <windows.h>

// char used when we can't convert from unicode to ansi
#define DPLAY_DEFAULT_CHAR "-"

extern int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr);
extern int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dnet\sp\wsock\utils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Utils.h
 *  Content:	Utilitiy functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __UTILS_H__
#define __UTILS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CPackedBuffer;
class	CSPData;
class	CThreadPool;
typedef	enum	_SP_TYPE	SP_TYPE;



//**********************************************************************
// Variable definitions
//**********************************************************************


//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	InitProcessGlobals( void );
void	DeinitProcessGlobals( void );

BOOL	LoadWinsock( void );
void	UnloadWinsock( void );

#ifdef WIN95
INT		GetWinsockVersion( void );
#endif


BOOL	LoadNATHelp( void );
void	UnloadNATHelp( void );

HRESULT	CreateSPData( CSPData **const ppSPData,
					  const CLSID *const pClassID,
					  const SP_TYPE SPType,
					  IDP8ServiceProviderVtbl *const pVtbl );

HRESULT	InitializeInterfaceGlobals( CSPData *const pSPData );
void	DeinitializeInterfaceGlobals( CSPData *const pSPData );

HRESULT	AddNetworkAdapterToBuffer( CPackedBuffer *const pPackedBuffer,
								   const char *const pAdapterName,
								   const GUID *const pAdapterGUID );

#endif	// __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\common\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *   22-dec-00  aarono  use process heap in retail (whistler b#190380)
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "newdpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;
static LONG             lBytesAlloc;

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = _ReturnAddress(); \
	pmt->dwPid = GetCurrentProcessId(); \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
	lBytesAlloc+=pmt->dwSize;\
		{	\
			IN_WRITESTATS InWS;	\
			memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));	\
		 	InWS.stat_USER3=lBytesAlloc;	\
			DbgWriteStats(&InWS);	\
		} \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif


#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );

    return lptr;

} /* MemAlloc */

/*
 * MemSize - return size of object
 */
UINT_PTR __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return HeapSize(hHeap, 0, lptr);

} /* MemSize */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
		DEBUG_BREAK();
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
		DEBUG_BREAK();
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

#ifdef DEBUG
	    lBytesAlloc -= pmt->dwSize;
		{	
			IN_WRITESTATS InWS;	
			memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));	
		 	InWS.stat_USER3=lBytesAlloc;	
			DbgWriteStats(&InWS);	
		}
#endif

		#ifdef FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

	HeapFree( hHeap, 0, lptr );

    }

} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx", pmt, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	lBytesAlloc -= pmt->dwSize;

	pmt->dwSize = size - sizeof( MEMTRACK );

	lBytesAlloc += pmt->dwSize;

	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER3=lBytesAlloc;
		DbgWriteStats(&InWS);
	}

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;

} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    if( hHeap == NULL )
    {
    #ifdef DEBUG
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
    #else
    hHeap = GetProcessHeap();
    #endif
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
    #ifdef DEBUG
	lAllocCount = 0;
	lBytesAlloc = 0;
	lpHead = NULL;
	lpTail = NULL;
    #endif
    return TRUE;

} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 2, "MemState" );
    if( lAllocCount != 0 )
    {
	DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 1, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 1, "%08lx: dwSize=%08lx, lpAddr=%08lx (pid=%08lx)", pmt, pmt->dwSize, pmt->lpAddr, pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 1, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
    #ifdef DEBUG
	HeapDestroy( hHeap );
    #endif
	hHeap = NULL;
    }
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\common\memlog.h ===
#include <windows.h>
#include <mmsystem.h>

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

#define BASE_LOG_FILENAME  "DPLAYLOG-0"
#define BASE_LOG_MUTEXNAME "DPLAYLOGMUTEX-0"

#define DPLOG_NUMENTRIES	5000
#define DPLOG_ENTRYSIZE		120
#define DPLOG_SIZE (sizeof(SHARED_LOG_FILE)+((sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)*DPLOG_NUMENTRIES))

//
// Globals for shared memory based logging
//
typedef struct _SHARED_LOG_FILE{
	CHAR	szAppName[16];
	DWORD   nEntries;
	DWORD	cbLine;
	DWORD 	iWrite;
	DWORD	cInUse;
	// followed by an array of LOGENTRIES.
}SHARED_LOG_FILE, *PSHARED_LOG_FILE;

typedef struct _LOG_ENTRY {
	DWORD	hThread;
	DWORD	tLogged;
	DWORD	DebugLevel;
	CHAR	str[0];
} LOG_ENTRY, *PLOG_ENTRY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\common\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT_PTR __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\common\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *   6/10/98   a-peterz Check CreateFile() result against INVALID_HANDLE_VALUE
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "newdpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static 
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef DPF_MODULE_NAME
    #define DPF_MODULE_NAME ""
#endif

static DWORD bDetailOn = 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

static BOOL bLogging=FALSE; // whether to use the logging VxD instead of dumping.


DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
	extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
        while (n && (*(to++) = *(from++)))    /* copy string */
                n--;
        
        *to = '\0';
}
char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;
 
int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

/*
BOOL DeviceIoControl( 
HANDLE hDevice, 			// handle to device of interest 
DWORD dwIoControlCode, 		// control code of operation to perform 
LPVOID lpInBuffer, 			// pointer to buffer to supply input data 
DWORD nInBufferSize, 		// size of input buffer 
LPVOID lpOutBuffer, 		// pointer to buffer to receive output data 
DWORD nOutBufferSize, 		// size of output buffer 
LPDWORD lpBytesReturned, 	// pointer to variable to receive output byte count 
LPOVERLAPPED lpOverlapped 	// pointer to overlapped structure for asynchronous operation 
); 
*/

#define MAX_STRING       240
#define LOG_SIZE         2000
#define FIRST_DEBUG_PROC 100

#define OPEN_DEBUGLOG 	(FIRST_DEBUG_PROC)
#define WRITE_DEBUGLOG 	(FIRST_DEBUG_PROC+1)
#define WRITE_STATS     (FIRST_DEBUG_PROC+2)

HANDLE hDPLAY_VxD=0;
HANDLE hLogMutex=0;
HANDLE hLogFile=0;
PSHARED_LOG_FILE pLogFile=0;

typedef struct _LOGENTRY {
	CHAR	debuglevel;
	CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

typedef struct {
	UINT	nLogEntries;
	UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
	UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
	CHAR	debuglevel;
	CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
	UINT	hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;

void DbgWriteStats(PIN_WRITESTATS pIn)
{
	UINT rc;
	UINT cbRet;

	if(hDPLAY_VxD){
		DeviceIoControl(hDPLAY_VxD,WRITE_STATS,pIn,sizeof(IN_WRITESTATS), &rc, sizeof(rc), &cbRet, NULL);
	}
}

static BOOL InitMemLogString(VOID)
{
	DWORD dwLastError;

	hLogFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
	dwLastError=GetLastError();
	hLogMutex=CreateMutexA(NULL,FALSE,BASE_LOG_MUTEXNAME);
	pLogFile=(PSHARED_LOG_FILE)MapViewOfFile(hLogFile, FILE_MAP_ALL_ACCESS,0,0,0);

	if(!hLogFile || !hLogMutex || !pLogFile){
		if(hLogFile){
			CloseHandle(hLogFile);
			hLogFile=0;
		}
		if(hLogMutex){
			CloseHandle(hLogMutex);
			hLogMutex=0;
		}
		if(pLogFile){
			UnmapViewOfFile(pLogFile);
			pLogFile=NULL;
		}
		return FALSE;
	} else {
		WaitForSingleObject(hLogMutex,INFINITE);
			if((dwLastError!=ERROR_ALREADY_EXISTS) || 
				(pLogFile->nEntries > DPLOG_NUMENTRIES) || (pLogFile->nEntries == 0) ||
				(pLogFile->cbLine   > DPLOG_ENTRYSIZE)  || (pLogFile->cbLine   == 0) ||
				(pLogFile->iWrite   > DPLOG_NUMENTRIES) ||
				(pLogFile->cInUse   > DPLOG_NUMENTRIES)
			){
				pLogFile->nEntries = DPLOG_NUMENTRIES;
				pLogFile->cbLine   = DPLOG_ENTRYSIZE;
				pLogFile->iWrite   = 0;
				pLogFile->cInUse   = 0;
			}	
		ReleaseMutex(hLogMutex);
	}
	return TRUE;
}

static void MemLogString(LPSTR str)
{
	PLOG_ENTRY pEntry;
	DWORD cbCopy;
	
	if(!hLogFile){
		if(!InitMemLogString()){
			return;
		}
	}

	WaitForSingleObject(hLogMutex,INFINITE);

	pEntry=(PLOG_ENTRY)(((PUCHAR)(pLogFile+1))+(pLogFile->iWrite*(sizeof(LOG_ENTRY)+DPLOG_ENTRYSIZE)));
	pEntry->hThread=GetCurrentThreadId();
	pEntry->tLogged=timeGetTime();
	pEntry->DebugLevel=0;

	cbCopy=strlen(str)+1;
	if(cbCopy > DPLOG_ENTRYSIZE){
		str[DPLOG_ENTRYSIZE]=0;
		cbCopy=DPLOG_ENTRYSIZE;
	}
	memcpy(pEntry->str, str, cbCopy);

	if(pLogFile->iWrite+1 > pLogFile->cInUse){
		pLogFile->cInUse=pLogFile->iWrite+1;
	}

	pLogFile->iWrite = (pLogFile->iWrite+1) % pLogFile->nEntries;
	ReleaseMutex(hLogMutex);

}

static void LogString( LPSTR str )
{
	char logstring[MAX_STRING+sizeof(LOGENTRY)];
	int  i=0;
	PLOGENTRY pLogEntry=(PLOGENTRY)&logstring;
	UINT rc;
	UINT cbRet;
	int maxlen = MAX_STRING+sizeof(LOGENTRY);

	if(hDPLAY_VxD && str){
		while(str[i] && i < maxlen)
			i++;
		pLogEntry->debuglevel=0;
		memcpy(pLogEntry->str,str,i+1);
		DeviceIoControl(hDPLAY_VxD,WRITE_DEBUGLOG,pLogEntry,i+sizeof(LOGENTRY), &rc, sizeof(rc), &cbRet, NULL);
	}

	if(bLogging & 2){
		MemLogString(str);
	}
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
	if(!bLogging || bLogging & 1)
	{            
	    OUTPUTDEBUGSTRING( str );
	    OUTPUTDEBUGSTRING("\n");
    }
    if(bLogging)
    {
	    LogString(str);
	}    
    
}
    
void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

#ifndef PROF_SECT
    #define PROF_SECT	"DirectDraw"
#endif
    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        bLogging    = (signed int) GETPROFILEINT( PROF_SECT, "log" , 0);

        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }

        if(bLogging){
        	hDPLAY_VxD = CreateFileA("\\\\.\\DPLAY",0,0,0,0,0,0);
        	if(hDPLAY_VxD != INVALID_HANDLE_VALUE){
        		IN_LOGINIT In;
        		OUT_LOGINIT Out;
        		UINT cbRet;
        		In.nCharsPerLine=MAX_STRING;
        		In.nLogEntries=5000;
				DeviceIoControl(hDPLAY_VxD,OPEN_DEBUGLOG,&In,sizeof(In), &Out, sizeof(Out), &cbRet, NULL);
        	}
        }
    }
    else
    {
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
int DebugPrintf(volatile DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE 1000
    char cMsg[MSGBUFFERSIZE];
    char cTopics[20];
    DWORD_PTR arg;
    LPSTR szFormat;
    BOOL bAllowed=FALSE;
    BOOL bMiscMessage=TRUE;
    int i;

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

    //error checking:
    if (dwDetail >= 10)
        return 1;

    if ( (bDetailOn & (1<<dwDetail)) == 0 )
        return 1;

    if (bMute)
        return 1;

    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    while ( (arg = va_arg(ap,DWORD_PTR)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }
    if (bMiscMessage)
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;

    if ( bPrintAllTopics )
        bAllowed=TRUE;

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) arg;

    cMsg[0]=0;
    
    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME ":" );
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;
    
}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    // 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers and handles.
	DebugPrintf(2,A,"%p->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}


#ifdef cplusplus
}
#endif

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\api.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       api.c
 *  Content:	DirectPlay api's
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *    1/96		andyco	   	created it
 *	2/15/96 	andyco	   	hardwired  to load dpwsock sp, return fake enum
 *	3/16/96 	andyco	   	spinit - new structure
 *	3/23/96		andyco	   	use registry
 *	4/10/96		andyco	   	added verifyspcallbacks
 *	4/23/96		andyco	   	added check for mw2 on enum. only return dp1.0 service
 *						   	providers if the .exe is mw2.
 *	5/6/96		andyco	   	moved os functionality to dpos.c
 *	5/29/96		andyco	   	new vtbls
 *	6/19/96		kipo	   	Bug #2052 in api.c: changed MW2Enum() to use the TAPI
 *						   	service provider GUID from DirectPlay 1.0 instead of the
 *						   	new serial service provider GUID. This will let
 *						   	MechWarrior work over TAPI; changed time bomb date to 8/31/96.
 *	6/20/96		andyco	   	added WSTRLEN_BYTES
 *	6/21/96 	kipo	   	Bug #2078. Changed modem service provider GUID so it's not the
 *						   	same as the DPlay 1.0 GUID, so games that are checking won't
 *						   	put up their loopy modem-specific UI.
 *	6/22/96		kipo	   	added EnumConnectionData() method.
 *	6/23/96		kipo	   	updated for latest service provider interfaces.
 *  6/26/96		andyco	   	take service lock b4 dplay lock on DirectPlayConnect
 *	6/26/96		kipo	   	changed guidGame to guidApplication; added support for DPADDRESS.
 *						   	changed GetFlags to GetPlayerFlags.
 *  6/26/96		kipo	   	check version returned by service provider
 *	6/28/96		andyco	   	check for DPLERR_BUFFERTOOSMALL on getconnectionsettings
 *	6/28/96		kipo	   	added support for CreateAddress() method.
 *  7/8/96  	AjayJ      	Adjusted vtable for IDirectPlay2 and IDirectPlay2A to match
 *          	           	dplay.h (remove EnableNewPlayers, SaveSession, alphabetize)
 *          	           	DummyEnumSessionsCallBack - fixed prototype to match dplay.h
 *  7/10/96		kipo	   	turned stack frame generation on around calls to DirectPlayEnumerateA
 *						   	so that poor apps that use _cdecl callbacks will continue
 *						   	to work. Fixes bug #2260 that was crashing "Space Hulk".
 * 	7/13/96		andyco	   	added DirectPlayEnumerate entry for compat. set MW2 global
 *						   	bool.
 *	7/23/96		andyco	   	added get max message size after sp init
 *	8/10/96		kipo	   	updated time bomb date
 *  8/ 9/96 	sohailm    	Bug #2376: added logic to free sp module if an error occurs in LoadSP.
 *	8/15/96		andyco		call sp_shutdown if sp_init succeeds but we don't like the
 *							version
 *	8/23/96		kipo		removed time bomb
 *  10/3/96 	sohailm     renamed VALID_UUID_PTR() call to VALID_GUID_PTR()
 *	10/31/96	andyco		added idirectplay3
 *	1/24/97		andyco		call freelibrary on the sp
 *	2/30/97		andyco		added enumconnections, initializeconnection to dp3 vtbl
 *	3/04/97		kipo		updated gdwDPlaySPRefCount definition
 *	3/12/97		myronth		added Lobby object creation code
 *  3/12/97     sohailm     added SecureOpen(), SecureOpenA() to DIRECTPLAYCALLBACKS3 and 
 *                          DIRECTPLAYCALLBACKS3A respectively, updated existing code to reflect 
 *                          changes in function parameters (InternalOpenSession, FreeSessionList)
 *	3/17/97		kipo		added support for CreateCompoundAddress()
 *	4/1/97		andyco		put in app hack for ms-golf.  don't load guid_local_tcp.
 *							use guid_tcp instead.  this is because guid_local_tcp 
 *							points to a sp that uses ddhelp.exe.  but, dplay is no longer
 *							using ddhelp.exe (see dplaysvr), so they're broken.
 *	3/31/97		myronth		Fixed DPF spew level for checking if a game was lobbied.
 *	4/20/97		andyco		added group in group stuff
 *	5/8/97		myronth		added Get/SetGroupConnectionSettings, StartSession
 *	5/12/97		kipo		fixed bugs #5506 and 5507
 *	5/17/97		myronth		Added SendChatMessage to IDirectPlay3
 *	5/27/97		kipo		Changed time bomb data to 10/15/97
 *	5/29/97		andyco		made ConnectFindSession() async
 *	5/30/97		myronth		Added GetGroupParent
 *  5/30/97     sohailm     Added GetPlayerAccount to vtable.
 *	5/30/97		kipo		Added GetPlayerFlags() and GetGroupFlags()
 *	6/16/97		andyco		don't take service lock on connect, so dpthread
 *							can run.
 *	6/25/97		kipo		remove time bomb for DX5
 *	7/30/97		myronth		Fixed wrong validation macro for guid
 *	8/5/97		andyco		async addforward. init this->dwMinVersion.
 *	8/19/97		myronth		Save the lobby object that lobbied us
 *	8/19/97		myronth		Change that to saving a copy of the lobby interface
 *	8/14/97		sohailm		Not verifying sp callback ptrs correctly (#10929)
 *	8/22/97		myronth		Added registry support for Description and Private values
 *	10/21/97	myronth		Added IDirectPlay4 callback tables
 *	10/29/97	myronth		Changed Get/SetGroupOwner callback pointers
 *	11/13/97	myronth		Added functions for asynchronous Connect (#12541)
 *	11/19/97	myronth		Changed Connect timeout to max at a minute (#13216)
 *	11/20/97	myronth		Made EnumConnections & DirectPlayEnumerate 
 *							drop the lock before calling the callback (#15208)
 *	11/24/97	kipo		Added time bomb for DX6
 *	12/3/97		myronth		Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	12/5/97		andyco		voice entries
 *  12/18/97    aarono      added pool allocation
 *	01/20/97	sohailm		don't free sp list after DirectPlayEnumerate (#17006)
 *	1/20/98		myronth		Changed PRV_SendStandardSystemMessage
 *	1/20/98		myronth		#ifdef'd out voice support
 *  2/18/98		aarono      unpatched protocol from table, moved InitProtocol
 *  4/30/98     aarono      fix connect when talking to secure server
 *  6/18/98     aarono      fix group SendEx ASYNC to use unique Header
 *  6/25/98     a-peterz    fix incorrect sizeof() in ConnectMe
 *  8/02/99		rodtoll		added voice v-table
 *  8/04/99		aarono		modified voice v-table, added IsValidEntity
 *  9/09/99     aarono      added vances fix for client/server pw validation
 * 10/04/99     aarono      added patching for loopback SP
 * 01/20/00		rodtoll		Added DV_IsValidGroup / DV_IsValidPlayer to conform to new transport interface 
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set
 * 07/22/00		rodtoll		Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  		Now for a thread to make an indication into voice they addref the interface
 *							so that the voice core can tell when all indications have returned.   
 ***************************************************************************/
		
					
// todo - do we need to check the version on mw2?

#include "dplaypr.h"
#include "dplobby.h"
#include "dpprot.h"
#include "fpm.h"
#include "..\protocol\mytimer.h"
#include "loopbksp.h"
#include "verinfo.h"

#include <initguid.h>
#include "..\..\bldcfg\dpvcfg.h"

#ifdef VOICE_BUILD_CUSTOM
SPNODE ASPNode;
#endif

// gdwDPLaySPRefCount is here so SP's can statically link to dplay
// this can keep some apps from unloading dplayx before the SP (no
// release) and crashing. Disable the warning so that we can include the
// extern declaration in dplaysp.h
#define DllExport	__declspec( dllexport )
#pragma warning( disable : 4273 )

DllExport DWORD gdwDPlaySPRefCount = 0;

// list of all sp info gotten from the registry
LPSPNODE gSPNodes;

// set if we're running mech
BOOL gbMech;

// set if we have a dx3 SP loaded. once we load a dx3 SP, 
// we do not allow any more directplay objects to be created
// (since in dx3 you could only have one directplay, we don't 
// want to risk crashing the SP)
BOOL gbDX3SP;											

// gpObjectList is the list of all dplay objects that exist in
// this dll.  used in dllmain and classfactory->canunloadnow
LPDPLAYI_DPLAY gpObjectList;
UINT gnObjects; // the # of dplay objects in the gpObjectList

//
// DP_1_xxx is a dplay 10 function.  see iplay1.c
// DP_A_xxx is a dplay 20 ansi function.  see iplaya.c
// DP_xxx is a dplay 20 function.  see iplay.c and enum.c
// DP_SP_xxx is a service provider callback.  see sphelp.c and handler.c
//

DIRECTPLAYVOICETRANSPORTCALLBACKS dvtCallbacks =
{
	(LPVOID)DP_QueryInterface,
	(LPVOID)DP_AddRef,
	(LPVOID)DP_Release,
	(LPVOID)DV_Advise,
	(LPVOID)DV_UnAdvise,
	(LPVOID)DV_IsGroupMember,
	(LPVOID)DV_SendSpeech,
	(LPVOID)DV_GetSessionInfo,
	(LPVOID)DV_IsValidEntity,
	(LPVOID)DV_SendSpeechEx,
	(LPVOID)DV_IsValidGroup,
	(LPVOID)DV_IsValidPlayer
};

/*
 * the one copy of the direct play 1.0 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS dpCallbacks =
{
    DP_QueryInterface,
    DP_AddRef,
    DP_Release,
    DP_AddPlayerToGroup,
    DP_Close,
    DP_1_CreatePlayer,
    DP_1_CreateGroup,
    DP_DeletePlayerFromGroup,
    DP_DestroyPlayer,
    DP_DestroyGroup,
    DP_EnableNewPlayers,
    DP_1_EnumGroupPlayers,
    DP_1_EnumGroups,
    DP_1_EnumPlayers,
    DP_1_EnumSessions,
    DP_1_GetCaps,
    DP_GetMessageCount,
    DP_1_GetPlayerCaps,
    DP_1_GetPlayerName,
    DP_Initialize,
    DP_1_Open,
    DP_1_Receive,
    DP_1_SaveSession,
    DP_Send,
    DP_1_SetPlayerName      	
};  				

/*
 *  the direct play 2 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS2 dpCallbacks2 =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_CreateGroup,          
	(LPVOID)DP_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_EnumGroupPlayers,     
	(LPVOID)DP_EnumGroups,           
	(LPVOID)DP_EnumPlayers,          
	(LPVOID)DP_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,
	(LPVOID)DP_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_GetPlayerName,
	(LPVOID)DP_GetSessionDesc,
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_Open,           
	(LPVOID)DP_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData, 
	(LPVOID)DP_SetGroupName,	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_SetPlayerName,	  
	(LPVOID)DP_SetSessionDesc
};  				

/*
 *  the direct play 2A callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS2A dpCallbacks2A =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_A_CreateGroup,          
	(LPVOID)DP_A_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_A_EnumGroupPlayers,     
	(LPVOID)DP_A_EnumGroups,           
	(LPVOID)DP_A_EnumPlayers,          
	(LPVOID)DP_A_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,   
	(LPVOID)DP_A_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_A_GetPlayerName,
	(LPVOID)DP_A_GetSessionDesc,	  
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_A_Open,           
	(LPVOID)DP_A_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData,   
	(LPVOID)DP_A_SetGroupName,	  	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_A_SetPlayerName,	  	  
	(LPVOID)DP_A_SetSessionDesc
};  				

// Protocol needs to wrap SendComplete since unlike HandleMessage, the values to complete
// will change from an SP code to a Protocol code, so there is no propogation
// method other than wrapping the SendComplete.

DIRECTPLAYCALLBACKSSP dpCallbacksSP =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_SP_AddMRUEntry,
	(LPVOID)DP_SP_CreateAddress,
	(LPVOID)DP_SP_EnumAddress,
	(LPVOID)DP_SP_EnumMRUEntries,
	(LPVOID)DP_SP_GetPlayerFlags,
	(LPVOID)DP_SP_GetSPPlayerData,
	(LPVOID)DP_SP_HandleMessage, 
	(LPVOID)DP_SP_SetSPPlayerData,
    /*** IDirectPlaySP methods added for DX 5***/
    (LPVOID)DP_SP_CreateCompoundAddress,
	(LPVOID)DP_SP_GetSPData,
	(LPVOID)DP_SP_SetSPData,
#ifdef BIGMESSAGEDEFENSE
	(LPVOID)DP_SP_ProtocolSendComplete,   // Goes through protocol.lib to DP_SP_ProtocolSendComplete
	(LPVOID)DP_SP_HandleSPWarning
#else
	(LPVOID)DP_SP_ProtocolSendComplete   // Goes through protocol.lib to DP_SP_ProtocolSendComplete
#endif
};    
	 

/*
 *  the direct play 3 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS3 dpCallbacks3 =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_CreateGroup,          
	(LPVOID)DP_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_EnumGroupPlayers,     
	(LPVOID)DP_EnumGroups,           
	(LPVOID)DP_EnumPlayers,          
	(LPVOID)DP_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,
	(LPVOID)DP_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_GetPlayerName,
	(LPVOID)DP_GetSessionDesc,
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_Open,           
	(LPVOID)DP_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData, 
	(LPVOID)DP_SetGroupName,	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_SetPlayerName,	  
	(LPVOID)DP_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_EnumConnections,
	(LPVOID)DP_EnumGroupsInGroup,
	(LPVOID)DPL_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_SecureOpen,
	(LPVOID)DP_SendChatMessage,
	(LPVOID)DPL_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags
};  				


/*
 *  the direct play 3A callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS3A dpCallbacks3A =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_A_CreateGroup,          
	(LPVOID)DP_A_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_A_EnumGroupPlayers,     
	(LPVOID)DP_A_EnumGroups,           
	(LPVOID)DP_A_EnumPlayers,          
	(LPVOID)DP_A_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,   
	(LPVOID)DP_A_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_A_GetPlayerName,
	(LPVOID)DP_A_GetSessionDesc,	  
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_A_Open,           
	(LPVOID)DP_A_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData,   
	(LPVOID)DP_A_SetGroupName,	  	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_A_SetPlayerName,	  	  
	(LPVOID)DP_A_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_A_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_A_EnumConnectionsPreDP4,
	(LPVOID)DP_A_EnumGroupsInGroup,
	(LPVOID)DPL_A_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_A_SecureOpen,
	(LPVOID)DP_A_SendChatMessage,
	(LPVOID)DPL_A_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_A_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags
};  				
	 
/*
 *  the direct play 4 callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS4 dpCallbacks4 =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_CreateGroup,          
	(LPVOID)DP_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_EnumGroupPlayers,     
	(LPVOID)DP_EnumGroups,           
	(LPVOID)DP_EnumPlayers,          
	(LPVOID)DP_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,
	(LPVOID)DP_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_GetPlayerName,
	(LPVOID)DP_GetSessionDesc,
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_Open,           
	(LPVOID)DP_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData, 
	(LPVOID)DP_SetGroupName,	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_SetPlayerName,	  
	(LPVOID)DP_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_EnumConnections,
	(LPVOID)DP_EnumGroupsInGroup,
	(LPVOID)DPL_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_SecureOpen,
	(LPVOID)DP_SendChatMessage,
	(LPVOID)DPL_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags,
    /*** IDirectPlay4 methods ***/
	(LPVOID)DPL_GetGroupOwner,
	(LPVOID)DPL_SetGroupOwner,
	(LPVOID)DP_SendEx,
	(LPVOID)DP_GetMessageQueue,
	(LPVOID)DP_CancelMessage,
	(LPVOID)DP_CancelPriority,
};  				


/*
 *  the direct play 4A callbacks (this is the vtbl!)
 */
DIRECTPLAYCALLBACKS4A dpCallbacks4A =
{
    (LPVOID)DP_QueryInterface,
    (LPVOID)DP_AddRef,
    (LPVOID)DP_Release,
	(LPVOID)DP_AddPlayerToGroup,     
	(LPVOID)DP_Close,                
	(LPVOID)DP_A_CreateGroup,          
	(LPVOID)DP_A_CreatePlayer,         
	(LPVOID)DP_DeletePlayerFromGroup,
	(LPVOID)DP_DestroyGroup,         
	(LPVOID)DP_DestroyPlayer,        
	(LPVOID)DP_A_EnumGroupPlayers,     
	(LPVOID)DP_A_EnumGroups,           
	(LPVOID)DP_A_EnumPlayers,          
	(LPVOID)DP_A_EnumSessions,         
	(LPVOID)DP_GetCaps,              
	(LPVOID)DP_GetGroupData,   
	(LPVOID)DP_A_GetGroupName,
	(LPVOID)DP_GetMessageCount,
	(LPVOID)DP_GetPlayerAddress,
	(LPVOID)DP_GetPlayerCaps,  
	(LPVOID)DP_GetPlayerData,
	(LPVOID)DP_A_GetPlayerName,
	(LPVOID)DP_A_GetSessionDesc,	  
	(LPVOID)DP_Initialize,	
	(LPVOID)DP_A_Open,           
	(LPVOID)DP_A_Receive,        
	(LPVOID)DP_Send,           
	(LPVOID)DP_SetGroupData,   
	(LPVOID)DP_A_SetGroupName,	  	  
	(LPVOID)DP_SetPlayerData,
	(LPVOID)DP_A_SetPlayerName,	  	  
	(LPVOID)DP_A_SetSessionDesc,
    /*** IDirectPlay3 methods ***/
	(LPVOID)DP_AddGroupToGroup, 
	(LPVOID)DP_A_CreateGroupInGroup,	
	(LPVOID)DP_DeleteGroupFromGroup,
	(LPVOID)DP_A_EnumConnections,
	(LPVOID)DP_A_EnumGroupsInGroup,
	(LPVOID)DPL_A_GetGroupConnectionSettings,
	(LPVOID)DP_InitializeConnection,
    (LPVOID)DP_A_SecureOpen,
	(LPVOID)DP_A_SendChatMessage,
	(LPVOID)DPL_A_SetGroupConnectionSettings,
	(LPVOID)DPL_StartSession,
	(LPVOID)DP_GetGroupFlags,
	(LPVOID)DP_GetGroupParent,
    (LPVOID)DP_A_GetPlayerAccount,
	(LPVOID)DP_GetPlayerFlags,
    /*** IDirectPlay4 methods ***/
	(LPVOID)DPL_GetGroupOwner,
	(LPVOID)DPL_SetGroupOwner,
	(LPVOID)DP_SendEx,
	(LPVOID)DP_GetMessageQueue,
	(LPVOID)DP_CancelMessage,
	(LPVOID)DP_CancelPriority,
};  				

// todo - Add DP_A_GetAccountDesc() to vtable

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayCreate"

#ifndef DX_FINAL_RELEASE

// shut 'em down if they try to use the beta bits too long
HRESULT TimeBomb() 
{
    #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
    SYSTEMTIME st;
    GetSystemTime(&st);

    if ( st.wYear > DX_EXPIRE_YEAR ||
         ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH)))
    ) {
        MessageBox(0, DX_EXPIRE_TEXT,
                      TEXT("Microsoft DirectPlay"), MB_OK);
        return DP_OK;// let it work anyway.
    }
     return DP_OK;   
} // TimeBomb

#endif

#define NUM_CALLBACKS( ptr ) ((ptr->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID ))
// called by loadsp to make sure we didn't get bogus call back ptrs
HRESULT VerifySPCallbacks(LPDPLAYI_DPLAY this) 
{
	PDWORD_PTR lpCallback;
	int nCallbacks = NUM_CALLBACKS(this->pcbSPCallbacks);
	int i;

	DPF(1,"verifying %d callbacks\n",nCallbacks);
	lpCallback = (PDWORD_PTR)((DWORD_PTR)this->pcbSPCallbacks + (sizeof(DWORD) * 2)); // + 1 for dwSize, + 1 for dwFlags

	for (i=0;i<nCallbacks ;i++ )
	{
		if ((*lpCallback) && !VALIDEX_CODE_PTR(*lpCallback)) 
		{
			DPF_ERR("sp provided bad callback pointer!");
			return E_FAIL;
		}
		lpCallback++;
	}

	return DP_OK;	
} // VerifySPCallbacks


// get the max message sizes for this xport
HRESULT GetMaxMessageSize(LPDPLAYI_DPLAY this)
{
	HRESULT hr;
	DPCAPS caps;

	memset(&caps,0,sizeof(DPCAPS));
	caps.dwSize = sizeof(DPCAPS);

	hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,0);
	if (FAILED(hr))
	{
		ASSERT(FALSE); // sp should at least support unreliable!
		return hr;
	}
	
	this->dwSPMaxMessage = caps.dwMaxBufferSize+sizeof(MSG_PLAYERMESSAGE);

	hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,DPGETCAPS_GUARANTEED);
	if (FAILED(hr))
	{
		// use unreliable
		this->dwSPMaxMessageGuaranteed = this->dwSPMaxMessage;
	}
	else 
	{
		this->dwSPMaxMessageGuaranteed = caps.dwMaxBufferSize;		
	}

	return DP_OK;

} // GetMaxMessageSize

// find the sp correspoding to lpGUID, and load it. call SPInit.
HRESULT LoadSP(LPDPLAYI_DPLAY this,LPGUID lpGUID,LPDPADDRESS lpAddress,DWORD dwAddressSize)
{
	SPINITDATA sd;
	LPSPNODE pspNode;
	BOOL bFound=FALSE;
	BOOL bLoopBack=FALSE;
	LPDPSP_SPINIT spinit;	
	HRESULT hr;
	LPDPLAYI_DPLAY_INT pInt=NULL;
	DWORD	dwError;

#ifdef DEBUG
	CHAR szGuid[GUID_STRING_SIZE];
	hr = AnsiStringFromGUID(lpGUID, szGuid, GUID_STRING_SIZE);
	if (!FAILED(hr))
	{
		DPF(5, "LoadSP called for GUID = %s, address = 0x%08x",szGuid, lpGUID);		
	}
#endif

	// Build the list
	hr = InternalEnumerate();
	if (FAILED(hr))
	{
		// rut ro!
		ASSERT(FALSE);
		return hr;
	}

	// find the right spnode
	pspNode = gSPNodes;
	while (pspNode && !(bFound))
	{
		if (IsEqualGUID(&(pspNode->guid),lpGUID)) bFound=TRUE;
		else pspNode=pspNode->pNextSPNode;
	}

	// loopback SP check
	if(IsEqualGUID(&GUID_DPLAY_LOOPBACKSP,lpGUID)){
		bFound=TRUE;
		bLoopBack=TRUE;
	}
	
	if (!bFound) 
	{
		DPF_ERR("could not find specified service provider!!");
		return DPERR_UNAVAILABLE;
	}
	
	if(bLoopBack){
		DPF(0,"Using Loopback SP");
		memset(&LBSPNode, 0, sizeof(LBSPNode));
		pspNode=&LBSPNode;
		this->pspNode = &LBSPNode;
		LBSPNode.guid = GUID_DPLAY_LOOPBACKSP;
		LBSPNode.lpszName = L"Loopback Service Provider";
		spinit=LBSPInit;
#if defined(VOICE_BUILD_CUSTOM)
    } else {
        DPF(0,"Auto-Loading " DPLAY_FILENAME_DPWSOCKX_A " provider");
/*        memset(&ASPNode, 0, sizeof(LBSPNode));
        pspNode=&ASPNode;
        this->pspNode = &ASPNode;
        ASPNode.guid = DPSPGUID_TCPIP;
        ASPNode.lpszName = NULL;  */
        this->hSPModule = OS_LoadLibrary(DPLAY_FILENAME_DPWSOCKX);
		if (!this->hSPModule) 
		{
			DPF(0,"Could not load service provider - %ls\n",DPLAY_FILENAME_DPWSOCKX_A);
			return DPERR_UNAVAILABLE;
		}

	    spinit= (LPDPSP_SPINIT) OS_GetProcAddress(this->hSPModule,"SPInit");
		if (!spinit) 
		{
			DPF(0,"Could not find service provider entry point");
			hr = DPERR_UNAVAILABLE;
	        goto CLEANUP_AND_EXIT;
		}
    }
#else		
	} else {
		DPF(0,"loading sp = %ls\n",pspNode->lpszPath);	
		// store the pspnode
		this->pspNode = pspNode;
	 	// try to load the specified sp
	    this->hSPModule = OS_LoadLibrary(pspNode->lpszPath);
		if (!this->hSPModule) 
		{
			DPF(0,"Could not load service provider - %ls\n",pspNode->lpszPath);
			return DPERR_UNAVAILABLE;
		}

	    spinit= (LPDPSP_SPINIT) OS_GetProcAddress(this->hSPModule,"SPInit");
		if (!spinit) 
		{
			DPF(0,"Could not find service provider entry point");
			hr = DPERR_UNAVAILABLE;
	        goto CLEANUP_AND_EXIT;
		}

	}	
#endif

	// get an IDirectPlaySP to pass it
	hr = GetInterface(this,&pInt,&dpCallbacksSP);
	if (FAILED(hr)) 
	{
		DPF(0,"could not get interface to directplaysp object. hr = 0x%08lx\n",hr);
        goto CLEANUP_AND_EXIT;
	}

	// set up the init data struct
	memset(&sd,0,sizeof(sd));
	sd.lpCB = this->pcbSPCallbacks;
    sd.lpCB->dwSize = sizeof(DPSP_SPCALLBACKS);
    if(!bLoopBack){
		sd.dwReserved1 = pspNode->dwReserved1;
		sd.dwReserved2 = pspNode->dwReserved2;
	}	
 	sd.lpszName = pspNode->lpszName;
	sd.lpGuid = &(pspNode->guid);
	sd.lpISP = (IDirectPlaySP *) pInt;
	
	sd.lpAddress = lpAddress;
	sd.dwAddressSize = dwAddressSize;

	hr = spinit(&sd);
    if (FAILED(hr))
    {
    	DPF_ERR("could not start up service provider!");
        goto CLEANUP_AND_EXIT;
    }

	// reset size of callback structure in case SP changed it
	this->pcbSPCallbacks->dwSize = sizeof(DPSP_SPCALLBACKS);

	hr = VerifySPCallbacks(this);
    if (FAILED(hr))
    {
    	DPF_ERR("invalid callbacks from service provider!");
        goto CLEANUP_AND_EXIT;
    }

	// check that SP version makes sense
	if ((sd.dwSPVersion & DPSP_MAJORVERSIONMASK) < DPSP_DX3VERSION)
	{
    	DPF_ERR("incompatible version returned from service provider!");
		// the init did succeed, try to call shutdown
	    if (sd.lpCB->Shutdown)  
	    {
			// dx3 and earlier sp's had a VOID arg list for shutdown
	    	hr = CALLSPVOID( sd.lpCB->Shutdown );
	    }
		else 
		{
			// shutdown not required...
		}
	    
		if (FAILED(hr)) 
		{
			DPF_ERR("could not invoke shutdown");
		}

		hr = DPERR_UNAVAILABLE;
        goto CLEANUP_AND_EXIT;
	}
	else if ((sd.dwSPVersion & DPSP_MAJORVERSIONMASK) == DPSP_DX3VERSION) 
	{
		DPF(0,"loading DX3 service provider");
		this->dwFlags |= DPLAYI_DPLAY_DX3SP;
		gbDX3SP = TRUE; // set a .dll var indicating it's not safe to allow any more directplay objects
						// to be created
	}

	// a-josbor: remember the version number in case we need it later
	this->dwSPVersion = sd.dwSPVersion;
	
	// set the blob size
	this->dwSPHeaderSize = sd.dwSPHeaderSize;
	DPF(1,"setting sp's message data size to %d\n",this->dwSPHeaderSize);

	// store a pointer to our IDirectPlaySP
	this->pISP = (IDirectPlaySP *)pInt;

	hr = GetMaxMessageSize(this);
    if (FAILED(hr))
    {
        ASSERT(FALSE);
        goto CLEANUP_AND_EXIT;
    }


    // success
    return DP_OK;

CLEANUP_AND_EXIT:
    if (this->hSPModule)
    {
        if (!FreeLibrary(this->hSPModule))
        {
            ASSERT(FALSE);
			dwError = GetLastError();
			DPF_ERR("could not free sp module");
			DPF(0, "dwError = %d", dwError);
        }
		this->hSPModule = NULL;
    }
	
	if (pInt)
	{
		// release the idirectplaysp interface we alloc'ed above...	
		this->dwRefCnt++;	 // since sp is not really loaded, make sure we don't nuke this object
		ASSERT(this->dwRefCnt >= 3);
		DP_Release((LPDIRECTPLAY)pInt);
		this->dwRefCnt--;
	}
	
	// make sure we reset this flag if we failed.  we never would have gotten here if it had
	// been true b4 the call, so if it changed, it was on the failed load
	gbDX3SP = FALSE;
	
    return hr;
} // LoadSP


// called by our MS Golf app hack
// builds a tcp/ip broadcast address
HRESULT  GetTCPBroadcastAddress(IDirectPlay * piplay,LPDPADDRESS * ppAddress,LPDWORD pdwAddressSize)
{
	HRESULT hr;
	char * pszBroadcast="";
	DWORD dwBroadcastSize = sizeof(char);

	ASSERT(ppAddress);
	ASSERT(NULL == *ppAddress);
	ASSERT(pdwAddressSize);
	ASSERT(0 == *pdwAddressSize);
	
	// call once to get the size - note - it's ok to cast ipiplay here,
	// since create address only checks for valid this ptr...
	hr =  DP_SP_CreateAddress((IDirectPlaySP *) piplay,&GUID_TCP,&DPAID_INet,
		pszBroadcast,dwBroadcastSize,*ppAddress,pdwAddressSize);
	ASSERT(DPERR_BUFFERTOOSMALL == hr);
	
	// alloc the size needed
	*ppAddress = DPMEM_ALLOC(*pdwAddressSize);
	if (!*ppAddress) return DPERR_OUTOFMEMORY;

	// call it again - this time we should get the real show!	
	hr =  DP_SP_CreateAddress((IDirectPlaySP *) piplay,&GUID_TCP,&DPAID_INet,
		pszBroadcast,dwBroadcastSize,*ppAddress,pdwAddressSize);
	if (FAILED(hr))	ASSERT(FALSE);
	
	return hr;
	
} // GetTCPBroadcastAddress

// called by InternalCreate
HRESULT AllocMemoryPools(LPDPLAYI_DPLAY this)
{
	InitTablePool(this);
	this->lpPlayerMsgPool=NULL;
	this->lpSendParmsPool=NULL;
	this->lpMsgNodePool=NULL;
	if(InitContextTable(this)!=DP_OK){
		return DPERR_NOMEMORY;
	}
	this->lpPlayerMsgPool=FPM_Init(sizeof(GROUPHEADER),NULL,NULL,NULL);
	if(!this->lpPlayerMsgPool){
		return DPERR_NOMEMORY;
	}
	this->lpSendParmsPool=FPM_Init(sizeof(SENDPARMS),SendInitAlloc,SendInit,SendFini);
	if(!this->lpSendParmsPool){
		return DPERR_NOMEMORY;
	}
	this->lpMsgNodePool=FPM_Init(sizeof(MESSAGENODE),NULL,NULL,NULL);
	if(!this->lpMsgNodePool){
		return DPERR_NOMEMORY;
	}
	return DP_OK;
}

VOID FreeMemoryPools(LPDPLAYI_DPLAY this)
{
	if(this->lpPlayerMsgPool){
		this->lpPlayerMsgPool->Fini(this->lpPlayerMsgPool,FALSE);
	}
	if(this->lpSendParmsPool){
		this->lpSendParmsPool->Fini(this->lpSendParmsPool,FALSE);
	}
	if(this->lpMsgNodePool){
		this->lpMsgNodePool->Fini(this->lpMsgNodePool,FALSE);
	}
	FiniTablePool(this);
	FiniContextTable(this);
}

HRESULT InitReply(LPDPLAYI_DPLAY this)
{
	if(!(this->hReply = CreateEventA(NULL,FALSE,FALSE,NULL))){	// Auto-Reset, unsignalled event.
		return DPERR_OUTOFMEMORY;
	}
	
	InitializeCriticalSection(&this->ReplyCS);
	this->dwReplyCommand = 0;
	this->pReplyBuffer   = NULL;
	this->pvReplySPHeader= NULL;
	return DP_OK;	
}

VOID FiniReply(LPDPLAYI_DPLAY this)
{
	if(this->hReply){
		CloseHandle(this->hReply);
		this->hReply=0;
		DeleteCriticalSection(&this->ReplyCS);
	}
}

VOID SetupForReply(LPDPLAYI_DPLAY this, DWORD dwReplyCommand)
{
	EnterCriticalSection(&this->ReplyCS);
	ASSERT(this->dwReplyCommand==0);
	this->dwReplyCommand=dwReplyCommand;
	ResetEvent(this->hReply);
	this->pReplyBuffer=NULL;
	this->pvReplySPHeader=NULL;
	LeaveCriticalSection(&this->ReplyCS);
}

VOID UnSetupForReply(LPDPLAYI_DPLAY this)
{
	EnterCriticalSection(&this->ReplyCS);
	this->dwReplyCommand=0;
	if(this->pReplyBuffer){
		FreeReplyBuffer(this->pReplyBuffer);
	}
	this->pReplyBuffer=NULL;
	this->pvReplySPHeader=NULL;
	LeaveCriticalSection(&this->ReplyCS);
}

HRESULT WaitForReply(LPDPLAYI_DPLAY this, PCHAR *ppReply, LPVOID *ppvSPHeader, DWORD dwTimeout)
{
	HRESULT hr;
	DWORD dwRet;

	EnterCriticalSection(&this->ReplyCS);
	if(!this->dwReplyCommand){
		// its just gonna timeout anyway, may as well be now.
		// this can happen because some error paths after calling 
		// SendCreateMessage don't bail properly.
		DPF(0,"ERROR: Called WaitForReply with NO REPLY TYPE SPECIFIED!\n");
		hr=DPERR_TIMEOUT;
		goto exit;
	}
	DPF(0,"WAITFORREPLY, Waiting for a x%x\n",this->dwReplyCommand);
	LeaveCriticalSection(&this->ReplyCS);

	dwRet=WaitForSingleObject(this->hReply, dwTimeout);
	
	EnterCriticalSection(&this->ReplyCS);
	
		if(this->pReplyBuffer){
			*ppReply=this->pReplyBuffer;
			if(ppvSPHeader){
				*ppvSPHeader=this->pvReplySPHeader;
			}
			// got a reply
			hr=DP_OK;
			this->pReplyBuffer=NULL;
			this->pvReplySPHeader=NULL;
		} else {
			// didn't get a reply (timed out) or no memory for buffer
			DPF(0, "WaitForReply: timed out waiting for reply!\n");
			hr=DPERR_TIMEOUT;
			*ppReply=NULL;
		}
		this->dwReplyCommand=0;

exit:
	LeaveCriticalSection(&this->ReplyCS);
	
	return hr;
}

VOID FreeReplyBuffer(PCHAR pReplyBuffer)
{
	DPMEM_FREE(pReplyBuffer);
}

HRESULT HandleReply(LPDPLAYI_DPLAY this, PCHAR pReplyBuffer, DWORD cbReplyBuffer, DWORD dwReplyCommand, PVOID pvSPHeader)
{
	HRESULT hr;
	EnterCriticalSection(&this->ReplyCS);

	// Normally we only allow one expected response, the only exception is we might get an
	// ADDFORWARDREPLY with error when waiting for a SUPERENUMPLAYERSREPLY, if there are more exceptions,
	// we can change the dwReplyCommand to a pointer to an array of things we are waiting for.
	// added another exception, when waiting for a SUPERENUMPLAYERREPLY x29, allow x3 (ENUMPLAYERSREPLY)
	// added another exception, when waiting for a ENUMPLAYERSREPLY x3, allow x24 (ADDFORWARDREPLY)
	if(
	   (dwReplyCommand==this->dwReplyCommand) || 
	   ((this->dwReplyCommand==DPSP_MSG_SUPERENUMPLAYERSREPLY) && 
	    ((dwReplyCommand==DPSP_MSG_ENUMPLAYERSREPLY)||(dwReplyCommand==DPSP_MSG_ADDFORWARDREPLY))
	   ) ||
	   ((this->dwReplyCommand==DPSP_MSG_ENUMPLAYERSREPLY) &&
	   (dwReplyCommand==DPSP_MSG_ADDFORWARDREPLY)
	   )
	  )
	{
		// winner
		ASSERT(!this->pReplyBuffer);
		DPF(5,"HANDLEREPLY: Got reply we wanted x%x\n",dwReplyCommand);
		this->pReplyBuffer=DPMEM_ALLOC(cbReplyBuffer+this->dwSPHeaderSize);
		if(this->pReplyBuffer){
			memcpy(this->pReplyBuffer,pReplyBuffer,cbReplyBuffer);
			if(pvSPHeader){
				this->pvReplySPHeader=this->pReplyBuffer+cbReplyBuffer;
				memcpy(this->pvReplySPHeader, pvSPHeader, this->dwSPHeaderSize);
			} else {
				this->pvReplySPHeader=NULL;
			}
		} else {
			DPF(0,"HandleReply couldn't allocate reply buffer, WaitForReply will think it timed out\n");
		}
		SetEvent(this->hReply);
		hr=DP_OK;
	} else {
		// bogus, don't want this reply
		DPF(0,"Rejecting Reply Command x%x I'm waiting for a x%x\n",dwReplyCommand,this->dwReplyCommand);
		hr=DPERR_NOTHANDLED;
	}
	LeaveCriticalSection(&this->ReplyCS);
	return hr;
}

// called by DirectPlayCreate,DirectPlayConnect
// pCallbacks is the vtbl we want to create w/
HRESULT InternalCreate(LPGUID lpGUID, LPDIRECTPLAY FAR *lplpDP, IUnknown FAR *pUnkOuter,
	LPDPLCONNECTION lpConnect,LPVOID pCallbacks) 
{
    LPDPLAYI_DPLAY this=NULL;
	LPDPLAYI_DPLAY_INT pInt=NULL;
	HRESULT hr;
						
    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }
   
    TRY
    {
    	if (lplpDP == NULL)
    	{
        	DPF_ERR("NULL pointer for receiving LPDIRECTPLAY!");
			return DPERR_INVALIDPARAMS;
    	}
    	
        *lplpDP = NULL;
        if (!VALID_READ_GUID_PTR(lpGUID))
        {
        	DPF_ERR("invalid guid!");
			return DPERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	if (gbDX3SP)
	{
		DPF_ERR("DX3 Service Provider loaded - unable to create another DirectPlay object");
		return DPERR_ALREADYINITIALIZED;
	}

#ifndef DX_FINAL_RELEASE

	hr = TimeBomb();
	if (FAILED(hr)) 
	{
		return E_FAIL;
	}

#endif

    this = DPMEM_ALLOC(sizeof(DPLAYI_DPLAY));
    if (!this) 
    {
    	DPF_ERR("out of memory");
        return E_OUTOFMEMORY;
    }

	this->dwSize = sizeof(DPLAYI_DPLAY);

	// set AppHack flags.
	hr=GetAppHacks(this);
	
	// allocate cached memory pools
	if(DP_OK != AllocMemoryPools(this)){
		hr=DPERR_OUTOFMEMORY;
		goto ERROR_INTERNALCREATE;
	}

	// allocate support for handling replies.
	if(DP_OK != InitReply(this)){
		hr=DPERR_OUTOFMEMORY;
		goto ERROR_INTERNALCREATE;
	}

    // alloc the callbacks
    this->pcbSPCallbacks = DPMEM_ALLOC(sizeof(DPSP_SPCALLBACKS));
    if (!this->pcbSPCallbacks) 
    {
		DPF_ERR("could not create direct play - out of memory");
		hr = DPERR_OUTOFMEMORY;
		goto ERROR_INTERNALCREATE;
    }
	// stick our version in the table, so SP knows who they're dealing with
	this->pcbSPCallbacks->dwVersion = DPSP_MAJORVERSION;
	
	// get our aggregated lobby object
	hr = PRV_AllocateLobbyObject(this, &this->lpLobbyObject);
	if(FAILED(hr))
	{
		DPF(0,"could not create directplaylobby object. hr = 0x%08lx\n",hr);
		goto ERROR_INTERNALCREATE;
	}

	// get an idirectplay
	hr = GetInterface(this,&pInt,pCallbacks);
	if (FAILED(hr)) 
	{
		DPF(0,"could not get interface to directplay object. hr = 0x%08lx\n",hr);
		goto ERROR_INTERNALCREATE;
	}

	// are we loading a real SP, or were we called by our classfactory
	// in response to CoCreateInstance?
	if (IsEqualGUID(lpGUID,&GUID_NULL))
	{
		DPF(2,"InternalCreate - using class factory guid");
		this->dwFlags |= DPLAYI_DPLAY_UNINITIALIZED;
	}
	else 
	{
		// did they ask for the local_tcp sp?  ms golf shipped a private version of this, and, it's
		// broken. instead, use our winsock sp w/ a broadcast address - this works the same way (only
		// it's not broken:-)
		if (IsEqualGUID(lpGUID,&GUID_LOCAL_TCP))
		{
			LPDPADDRESS pAddress=NULL;
			DWORD dwAddressSize=0;

			// APP HACK for MSGOLF!
			DPF(0,"detected unsupported tcp/ip service provider - forcing to dpwsockx");
			if (lpConnect)
			{
				// they gave us an address - use it
				hr = LoadSP(this,(LPGUID)&GUID_TCP,lpConnect->lpAddress,lpConnect->dwAddressSize);						
			}
			else 
			{
				// they didn't pass a connection struct, go build a broadcast address
				hr = GetTCPBroadcastAddress((IDirectPlay *)pInt,&pAddress,&dwAddressSize);
				if (FAILED(hr))	ASSERT(FALSE);

				// if it failed, pvAddress is still NULL - winsock will pop a dialog. oh well.
				hr = LoadSP(this,(LPGUID)&GUID_TCP,pAddress,dwAddressSize);
				
				if (pAddress) DPMEM_FREE(pAddress);
			}
		}
		// go get the sp they asked for
		else if (lpConnect)
		{
			hr = LoadSP(this,lpGUID,lpConnect->lpAddress,lpConnect->dwAddressSize);			
		}
		else 
		{
			hr = LoadSP(this,lpGUID,NULL,0);			
		}

		if (FAILED(hr)) 
		{
			DPF(0,"could not create direct play - load sp failed! hr = 0x%08lx\n",hr);
			goto ERROR_INTERNALCREATE;
		}
	}

	if(!(this->dwAppHacks & DPLAY_APPHACK_NOTIMER)){

		hr=InitTimerWorkaround();
		
		if(FAILED(hr)){
			DPF(0,"Could not initialize DirectPlay timer package, hr =0x%08lx\n",hr);
			goto ERROR_INTERNALCREATE;
		}

	}
	
	if(FAILED(hr)){
		DPF(0,"Could not initialize DirectPlay timer package, hr =0x%08lx\n",hr);
		goto ERROR_INTERNALCREATE;
	}

	InitializeCriticalSection( &this->csNotify );

	// add this to the front of our dll object list
	this->pNextObject = gpObjectList;
	gpObjectList = this;
	gnObjects++;
	
	// init the min version for this object
	this->dwMinVersion = DPSP_MSG_VERSION;
		
	DPF(3,"InternalCreate :: created new dplay object.  %d objects outstanding",gnObjects);
	
    *lplpDP = (LPDIRECTPLAY)pInt;

    return DP_OK;

ERROR_INTERNALCREATE:

	if(this)
	{
		FiniReply(this);
		FreeMemoryPools(this);
		if(this->lpLobbyObject)
			PRV_DestroyDPLobby(this->lpLobbyObject);
		if(this->pcbSPCallbacks)
			DPMEM_FREE(this->pcbSPCallbacks);
		DPMEM_FREE(this);
	}

	if(pInt)
		DPMEM_FREE(pInt);

	return hr;

} // InternalCreate

HRESULT WINAPI DirectPlayCreate( LPGUID lpGUID, LPDIRECTPLAY FAR *lplpDP, IUnknown FAR *pUnkOuter) 
{
	HRESULT hr;

#ifdef DPLAY_LOADANDCHECKTRUE
    if( ghRedirect != NULL )
    {
        return (*pfnDirectPlayCreate)(lpGUID,lplpDP,pUnkOuter);
    }
#endif


	ENTER_DPLAY();
	
	hr = InternalCreate(lpGUID,lplpDP,pUnkOuter,NULL,&dpCallbacks);

	LEAVE_DPLAY();
	
	return hr;

}// DirectPlayCreate

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayEnumerate"

// See if a duplicate node exists
BOOL DoesDuplicateSPNodeWithDescriptionExist(LPGUID lpguid)
{
	LPSPNODE	pspNode = gSPNodes;

	while(pspNode)
	{
		// If the GUID's are equal and it had a description, return TRUE
		if(IsEqualGUID(&pspNode->guid, lpguid) &&
			(pspNode->dwNodeFlags & SPNODE_DESCRIPTION))
			return TRUE;
		   
		// Move to the next node
		pspNode = pspNode->pNextSPNode;
	}

	return FALSE;
}

void FreeSPNode(LPSPNODE pspNode)
{
	if(!pspNode)
		return;

	if(pspNode->lpszName)
		DPMEM_FREE(pspNode->lpszName);
	if(pspNode->lpszPath)
		DPMEM_FREE(pspNode->lpszPath);
	if(pspNode->lpszDescA)
		DPMEM_FREE(pspNode->lpszDescA);
	if(pspNode->lpszDescW)
		DPMEM_FREE(pspNode->lpszDescW);
	DPMEM_FREE(pspNode);
}

// Remove any duplicate SP Nodes from the list if they don't use a description
// string (workaround for pre-DX5.1 localization bug)
void RemoveDuplicateSPWithoutDescription(LPSPNODE pspNode)
{
	LPSPNODE	pspCurrent;
	LPSPNODE	pspPrev;
	LPSPNODE	pspNext;
	GUID		guid = pspNode->guid;
	

	// Move to the next node
	pspPrev = pspNode;
	pspCurrent = pspNode->pNextSPNode;

	// Walk the list
	while(pspCurrent)
	{
		// If the guids are equal and this node doesn't use a description string
		// then remove it from the list
		if((IsEqualGUID(&pspCurrent->guid, &guid)) &&
			(!(pspCurrent->dwNodeFlags & SPNODE_DESCRIPTION)))
		{
			// Remove it from the list and save the next pointer
			pspPrev->pNextSPNode = pspNext = pspCurrent->pNextSPNode;

			// free the current node
			FreeSPNode(pspCurrent);

			// Move to the next node
			pspCurrent = pspNext;
		}
		else
		{
			// Move to the next node
			pspPrev = pspCurrent;
			pspCurrent = pspCurrent->pNextSPNode;
		}
	}
}


// add a new node to the sp list
// called by GetKeyValues
HRESULT AddSPNode(LPWSTR lpszName,LPWSTR lpszGuid,LPWSTR lpszPath,DWORD dwReserved1,
			DWORD dwReserved2, DWORD dwSPFlags, LPSTR lpszDescA, LPWSTR lpszDescW)
{
	LPSPNODE pspNode=NULL;
	int iStrLen; // string length, in bytes
	HRESULT hr=DP_OK;
	GUID guid;

	// First convert the guid
	hr = GUIDFromString(lpszGuid,&guid);
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		DPF_ERR("could not parse guid");
		return hr;
	}

	// If we aren't using the description, make sure an SP Node with the same
	// guid AND a valid description doesn't already in the list.  If it does,
	// we need to skip this node and not add it
	if(!(dwSPFlags & SPNODE_DESCRIPTION))
	{
		if(DoesDuplicateSPNodeWithDescriptionExist(&guid))
		{
			DPF(8, "Duplicate SP with a description exists, skipping node");
			return DP_OK;
		}
	}

	// alloc the spnode	
	pspNode = DPMEM_ALLOC(sizeof(SPNODE));
	if (!pspNode)
	{
		DPF_ERR("could not alloc enum node - out of memory");
		return E_OUTOFMEMORY;
	}

	// alloc the strings
	iStrLen = WSTRLEN_BYTES(lpszName);
	pspNode->lpszName = DPMEM_ALLOC(iStrLen);
	if (!pspNode->lpszName)
	{
		DPF_ERR("could not alloc enum node - out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}
	memcpy(pspNode->lpszName,lpszName,iStrLen);

	iStrLen = WSTRLEN_BYTES(lpszPath);
	pspNode->lpszPath = DPMEM_ALLOC(iStrLen);
	if (!pspNode->lpszPath)
	{
		DPF_ERR("could not alloc enum node - out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}
	memcpy(pspNode->lpszPath,lpszPath,iStrLen);

	iStrLen = (lpszDescA ? lstrlenA(lpszDescA) : 0);
	if(iStrLen)
	{
		// Count the null terminator since lstrlen didn't
		iStrLen++;
		pspNode->lpszDescA = DPMEM_ALLOC(iStrLen);
		if (!pspNode->lpszDescA)
		{
			DPF_ERR("could not alloc enum node - out of memory");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pspNode->lpszDescA,lpszDescA,iStrLen);

		iStrLen = WSTRLEN_BYTES(lpszDescW);
		pspNode->lpszDescW = DPMEM_ALLOC(iStrLen);
		if (!pspNode->lpszDescW)
		{
			DPF_ERR("could not alloc enum node - out of memory");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pspNode->lpszDescW,lpszDescW,iStrLen);
	}

	pspNode->dwReserved1 = dwReserved1;
	pspNode->dwReserved2 = dwReserved2;

	// Save the guid
	memcpy(&(pspNode->guid),&guid,sizeof(guid));

	// Save the SP Node flags (internal flags)
	pspNode->dwNodeFlags = dwSPFlags;

	// add it to the (front of the) list
	pspNode->pNextSPNode = gSPNodes;
	gSPNodes= pspNode;

	// If this SP Node has a description, we need to walk the list and remove
	// any other SP nodes with the same GUID that DO NOT have a description.
	// This will get around our pre-DX5.1 problem of enumerating SP's twice
	// on localized versions of Win95 with US versions of games installed
	// NOTE: This function assumes the first node in the list is the one
	// we just added!!!!!
	if(dwSPFlags & SPNODE_DESCRIPTION)
		RemoveDuplicateSPWithoutDescription(pspNode);
	
	return DP_OK;

ERROR_EXIT:
	FreeSPNode(pspNode);
	return hr;

} // AddSPNode

/*
 ** GetKeyValue
 *
 *  CALLED BY: RegEnumerate
 *
 *  PARAMETERS:
 *		hKey - key above service provider
 *		lpszName - name of service provider key
 *
 *  DESCRIPTION: opens the service provider key, and reads
 *		sp data
 *
 *  RETURNS:  DP_OK or E_FAIL
 *
 */

HRESULT GetKeyValues(HKEY hKey,LPWSTR lpszName) 
{
	HKEY hKeySP;	
	LONG lErr;
	DWORD dwType;
	CHAR szDescA[DPLAY_REGISTRY_NAMELEN];
	WCHAR szDescW[DPLAY_REGISTRY_NAMELEN];
	WCHAR szPath[DPLAY_REGISTRY_NAMELEN];
	DWORD cchData = 0;
	WCHAR szGuid[GUID_STRING_SIZE]; // space for guid + {,-,-,}
	HRESULT hr;
	DWORD dwReserved1=0,dwReserved2=0; // for reading dwReserved1+2
	DWORD dwSPFlags = 0;

	// open the base key  
	lErr = OS_RegOpenKeyEx(hKey,lpszName,0,KEY_READ,&hKeySP);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d\n",lErr);
		return E_FAIL;
	}

	// first see if the "Private" key exists.  If it does, then skip this SP
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("Private"),NULL,&dwType,NULL,&cchData);
	if (ERROR_SUCCESS == lErr) 
	{
		// The key exists, so set the flag so we don't enumerate it
		dwSPFlags |= SPNODE_PRIVATE;
	}

	// path
	cchData = DPLAY_REGISTRY_NAMELEN * sizeof(WCHAR);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("Path"),NULL,&dwType,(LPBYTE)szPath,&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read path err = %d\n",lErr);
		hr = E_FAIL;
		goto ERROR_EXIT;
	}
	DPF(5,"got path = %ls\n",szPath);

	// guid
	cchData = GUID_STRING_SIZE * sizeof(WCHAR);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("Guid"),NULL,&dwType,(LPBYTE)szGuid,&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read guid err = %d\n",lErr);
		hr = E_FAIL;
		goto ERROR_EXIT;
	}
	DPF(5,"got guid = %ls\n",szGuid);

	// description A
	// NOTE: This value is always assumed to be an ANSI string, regardless of
	// which platform we are on.  On Win95, this is an ANSI (possibly multi-byte),
	// and on NT, although it is stored as Unicode, we always want to treat it
	// as an ANSI string
	cchData = sizeof(szDescA);
	lErr = RegQueryValueExA(hKeySP,"DescriptionA",NULL,&dwType,(LPBYTE)szDescA,&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(5,"Could not read description err = %d\n",lErr);
		// it's ok if sp doesn't have one of these...
	}
	else
	{
		DPF(5,"got descriptionA = %s\n",szDescA);
		
		// Set our description flag
		dwSPFlags |= SPNODE_DESCRIPTION;

		// Now try to get the DescriptionW string if one exists.  If for some
		// reason a DescriptionW string exists, but the DescriptionA does not,
		// we pretend the DescriptionW string doesn't exist either.
		// NOTE: We always assume the DescriptionW string is a Unicode string,
		// even on Win95.  On Win95, this will be of the type REG_BINARY, but
		// it is really just a Unicode string.
		cchData = sizeof(szDescW);
		lErr = OS_RegQueryValueEx(hKeySP,TEXT("DescriptionW"),NULL,&dwType,(LPBYTE)szDescW,&cchData);
		if (ERROR_SUCCESS != lErr) 
		{
			DPF(5,"Could not get descriptionW, converting descriptionA");

			// We couldn't get descriptionW, so convert descriptionA...
			AnsiToWide(szDescW,szDescA,(lstrlenA(szDescA)+1));
		}
		else
		{
			DPF(5,"got descriptionW = %ls\n",szDescW);
		}

	}

	// reserved1
	cchData = sizeof(DWORD);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("dwReserved1"),NULL,&dwType,(LPBYTE)&dwReserved1,
		&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read dwReserved1 err = %d\n",lErr);
		// it's ok if sp doesn't have one of these...
	}
	DPF(5,"got dwReserved1 = %d\n",dwReserved1);

	// reserved2
	cchData = sizeof(DWORD);
	lErr = OS_RegQueryValueEx(hKeySP,TEXT("dwReserved2"),NULL,&dwType,(LPBYTE)&dwReserved2,
		&cchData);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not read dwReserved2 err = %d\n",lErr);
		// it's ok if sp doesn't have one of these...
	}
	DPF(5,"got dwReserved2 = %d\n",dwReserved2);

	// If we have a description string, use it.  If not, use the key name
	hr = AddSPNode(lpszName,szGuid,szPath,dwReserved1,dwReserved2, dwSPFlags,
					szDescA, szDescW);

ERROR_EXIT:
	RegCloseKey(hKeySP);

	return hr;

} // GetKeyValues

// enumerate through the service providers stored under directplay in the
// registry
// read the data stored in the registry, and add it to our list of spnodes
HRESULT RegEnumerate() 
{
	LONG lErr;
	HKEY hKey;
	DWORD dwSubkey=0;
	WCHAR lpszName[DPLAY_REGISTRY_NAMELEN];
	DWORD cchName;
	HRESULT hr;

	// open the base key - 
	// "HKEY_LOCAL_MACHINE\Software\Microsoft\DirectPlay\Service Providers"
	lErr = OS_RegOpenKeyEx(HKEY_LOCAL_MACHINE,DPLAY_REGISTRY_PATH,0,KEY_READ,
				&hKey);
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d\n",lErr);
		return E_FAIL;
	}

	// enumerate subkeys
	do
	{
		// find an sp
		cchName= DPLAY_REGISTRY_NAMELEN;
		lErr = OS_RegEnumKeyEx(hKey,dwSubkey,lpszName,&cchName,
				NULL,NULL,0,NULL);
		
		if (ERROR_SUCCESS == lErr)
		{
			hr = GetKeyValues(hKey,lpszName);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				// keep trying the rest of the sp's
			}
		}
		dwSubkey++;
	} while(ERROR_NO_MORE_ITEMS != lErr );

	RegCloseKey(hKey);

	return DP_OK;

} // RegEnumerate

#define FILE_NAME_SIZE 256

// used b4 we compare module name to "mech2.exe".  it's ok to hard code for english,
// since we're just special casing this one app.
void LowerCase(char * lpsz) 
{
	while (*lpsz)
	{
	    if (*lpsz >= 'A' && *lpsz <= 'Z') *lpsz = (*lpsz - 'A' + 'a');
		lpsz++;
	}
} // LowerCase


HRESULT InternalEnumerate()
{

	HRESULT hr=DP_OK;

	if (!gSPNodes)
	{
		// enum from the registry
		hr = RegEnumerate();		
	}
	
	return hr;	
} // InternalEnumerate

HRESULT WINAPI DirectPlayEnumerateW( LPDPENUMDPCALLBACK pCallback, LPVOID pContext)
{
	HRESULT hr;
	LPSPNODE pspNode, pspHead;
	BOOL bContinue=TRUE;

#ifdef DPLAY_LOADANDCHECKTRUE
    if( ghRedirect != NULL )
    {
        return (*pfnDirectPlayEnumW)(pCallback,pContext);
    }
#endif	

    ENTER_DPLAY();

	if( !VALIDEX_CODE_PTR( pCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DPLAY();
	    return DPERR_INVALIDPARAMS;
	}

	hr = InternalEnumerate();
	if (FAILED(hr)) 
	{
		DPF(0,"could not enumerate reg entries - hr = 0x%08lx\n",hr);
		LEAVE_DPLAY();
		return hr;
	}

	// Store our head pointer, and get a temporary pointer
	pspHead = gSPNodes;
	pspNode = gSPNodes;

	// drop the lock
	LEAVE_DPLAY();

	while ((pspNode) && (bContinue))
	{
		DWORD dwMajorVersion,dwMinorVersion;
		LPWSTR	lpwszName;

		// Use the description string if one exists
		if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
			lpwszName = pspNode->lpszDescW;
		else
			lpwszName = pspNode->lpszName;
		
		// Make sure it's not a private one
		if(!(pspNode->dwNodeFlags & SPNODE_PRIVATE))
		{
			dwMajorVersion = HIWORD(DPSP_MAJORVERSION);
			dwMinorVersion = LOWORD(DPSP_MAJORVERSION);

			// call the app
			bContinue= pCallback(&(pspNode->guid),lpwszName,dwMajorVersion,
				dwMinorVersion,pContext);
		}

		pspNode = pspNode->pNextSPNode;
	}

    return DP_OK;	
} // DirectPlayEnumerateW

// Some DP 1.0 apps were declaring their callbacks to be _cdecl instead
// of _stdcall and relying on DPlay to generate stack frames to clean up after
// them. To keep them running we just turn on stack frame generation for this
// one call so that they keep running. Yuck.

// turn on stack frame generation (yes, I know the word "off" is in there - thank you VC)
#pragma optimize ("y", off)

HRESULT WINAPI DirectPlayEnumerateA( LPDPENUMDPCALLBACKA pCallback, LPVOID pContext)
{
	HRESULT hr;
	LPSPNODE pspNode, pspHead;
	BOOL bContinue=TRUE;
	char lpszName[DPLAY_REGISTRY_NAMELEN];

#ifdef DPLAY_LOADANDCHECKTRUE
    if( ghRedirect != NULL )
    {
        return (*pfnDirectPlayEnumA)(pCallback,pContext);
    }
#endif		

    ENTER_DPLAY();

	if( !VALIDEX_CODE_PTR( pCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DPLAY();
	    return DPERR_INVALIDPARAMS;
	}

	hr = InternalEnumerate();
	if (FAILED(hr)) 
	{
		DPF(0,"could not enumerate reg entries - hr = 0x%08lx\n",hr);
		LEAVE_DPLAY();
		return hr;
	}

	// Store our head pointer, and get a temporary pointer
	pspHead = gSPNodes;
	pspNode = gSPNodes;

	// drop the lock
	LEAVE_DPLAY();
	
	while ((pspNode) && (bContinue))
	{
		DWORD dwMajorVersion,dwMinorVersion;

		// Use the description string if one exists
		if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
		//	for backwards compat, we ANSIfy the Unicode string
			WideToAnsi(lpszName, pspNode->lpszDescW, DPLAY_REGISTRY_NAMELEN);
		else
			WideToAnsi(lpszName ,pspNode->lpszName,DPLAY_REGISTRY_NAMELEN);

		// Make sure it's not a private one
		if(!(pspNode->dwNodeFlags & SPNODE_PRIVATE))
		{
			dwMajorVersion = HIWORD(DPSP_MAJORVERSION);
			dwMinorVersion = LOWORD(DPSP_MAJORVERSION);

			// call the app
			bContinue= pCallback(&(pspNode->guid),lpszName,dwMajorVersion,
				dwMinorVersion,pContext);
		}

		pspNode = pspNode->pNextSPNode;
	}

    return DP_OK;	

} // DirectPlayEnumerateA

// hack for compat.
// apps that linked to dp1 by name will come through this entry
#undef DirectPlayEnumerate
HRESULT WINAPI DirectPlayEnumerate( LPDPENUMDPCALLBACKA pCallback, LPVOID pContext)
{
	return DirectPlayEnumerateA(  pCallback,  pContext);
} 

// restore default optimizations
#pragma optimize ("", on)

BOOL PASCAL DummyEnumSessionsCallBack(
    LPCDPSESSIONDESC2 lpDPSGameDesc,
    LPDWORD		lpdwTimeOut,
    DWORD		dwFlags,
    LPVOID		lpContext)
{
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FindSessionInSessionList"

//
// called by ConnectFindSession
LPSESSIONLIST FindSessionInSessionList(LPDPLAYI_DPLAY this,GUID const *pGuid)
{
	LPSESSIONLIST pSession = this->pSessionList;
	BOOL bFoundIt = FALSE;
	HRESULT hr=DP_OK;

	while ((pSession) && !bFoundIt)
	{
		if (IsEqualGUID((&pSession->dpDesc.guidInstance),pGuid))
		{
			bFoundIt=TRUE;
		} 
		else pSession = pSession->pNextSession;
	}
	if (!bFoundIt) 
	{
		DPF_ERR("could not find matching session");
		return NULL;
	}
	
	return pSession;
} // FindSessionInSessionList

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayConnectW"

// how long we wait between checking local session list
// for session we're searching for.  
#define ENUM_TIME 100

//
// called by ConnectMe
HRESULT AsyncConnectFindSession(LPDIRECTPLAYLOBBY pIDL,
		LPDPLAYI_DPLAY this,LPDPLCONNECTION lpConnect)
{
	HRESULT hr;
	

	// we leave dplay here, since when we get to internal enum , the lock 
	// count has to be at one...
	LEAVE_DPLAY();
	
	hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,
		lpConnect->lpSessionDesc,0,DummyEnumSessionsCallBack,
		NULL,(DPENUMSESSIONS_ASYNC | DPENUMSESSIONS_RETURNSTATUS));

	ENTER_DPLAY();
	
	if(SUCCEEDED(hr) || (hr == DPERR_CONNECTING))
	{
		// Turn the async flag on to say that we are processing
		PRV_TurnAsyncConnectOn(pIDL);
	}

	if (FindSessionInSessionList(this,&(lpConnect->lpSessionDesc->guidInstance) ) )
	{
		return DP_OK;
	}

	// If things are okay, we need to return DPERR_CONNECTING to say that
	// we're still working (this gets around SP's like the winsock SP which
	// returns DP_OK during an async EnumSessions)
	if(SUCCEEDED(hr))
		return DPERR_CONNECTING;
	else
		return hr;
	
}  // AsyncConnectFindSession
		

HRESULT StopAsyncConnect(LPDIRECTPLAYLOBBY pIDL, LPDPLAYI_DPLAY this,
		LPDPLCONNECTION lpConnect)
{
	HRESULT hr;

	// we leave dplay here, since when we get to internal enum , the lock 
	// count has to be at one...
	LEAVE_DPLAY();
	
	hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,lpConnect->lpSessionDesc,
		0,DummyEnumSessionsCallBack,NULL,DPENUMSESSIONS_STOPASYNC);

	ENTER_DPLAY();
	
	if (FAILED(hr))
	{
		DPF_ERRVAL("Failed stopping async enum - hr = 0x%08x\n", hr);
		return hr;
	}

	return DP_OK;

} // StopAsyncConnect


// enum 'till we find the right session, or run out of time
HRESULT ConnectFindSession(LPDPLAYI_DPLAY this,LPDPLCONNECTION lpConnect)
{
	// the total amount of time we'll wait to join
	DWORD dwTotalTimeout,dwTimeStarted;
    BOOL bFoundIt=FALSE;
	HRESULT hr;
	
	dwTotalTimeout = GetDefaultTimeout( this, TRUE) * DP_NAMETABLE_SCALE;

	// Now, if the value is over a minute, max it out at a minute
	if(dwTotalTimeout > DP_MAX_CONNECT_TIME)
		dwTotalTimeout = DP_MAX_CONNECT_TIME;
	DPF(3,"ConnectFindSession - total time out = %d\n",dwTotalTimeout);

	//
	// call enum once, just to kick start (e.g. get any dialogs out of 
	// the way
	 
	// we leave dplay here, since when we get to internal enum , the lock 
	// count has to be at one...
	LEAVE_DPLAY();
	
	hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,lpConnect->lpSessionDesc,
		0,DummyEnumSessionsCallBack,NULL,DPENUMSESSIONS_ASYNC);

	ENTER_DPLAY();
	
	if (FAILED(hr))
	{
		DPF_ERRVAL("ConnectFindSession enum failed - hr = 0x%08lx\n", hr);
		return hr;
	}

	dwTimeStarted = GetTickCount();		

	while (dwTotalTimeout > (GetTickCount() - dwTimeStarted))
	{
		if (FindSessionInSessionList(this,&(lpConnect->lpSessionDesc->guidInstance) ) )
		{
			bFoundIt = TRUE;
			break;
		}

		// we leave dplay here, since when we get to internal enum , the lock 
		// count has to be at one...
		LEAVE_DPLAY();
		
		// wait a bit, so replies can filter in...
		Sleep(ENUM_TIME);

		hr = DP_EnumSessions((LPDIRECTPLAY)this->pInterfaces,lpConnect->lpSessionDesc,
			0,DummyEnumSessionsCallBack,NULL,DPENUMSESSIONS_ASYNC);

		ENTER_DPLAY();
		
		if (FAILED(hr))
		{
			DPF(0,"ConnectFindSession enum failed - hr = 0x%08lx\n");
			return hr;
		}
	} 

	if (!bFoundIt)
	{
		DPF_ERR(" !@!@!@ !@!@!@ NO SESSION WAS FOUND! TIMEOUT !@!@!@ !@!@!@ ");
		return DPERR_NOSESSIONS;
	}
	
	return DP_OK; // found it!
	
}  // ConnectFindSession
		

// B#35348, take ALL, not just DPLAY in this fn.  Otherwise crashes in fail case of InternalOpenSession
HRESULT ConnectMe(LPDIRECTPLAYLOBBY pIDL, LPDIRECTPLAY2 FAR *lplpDP,
		IUnknown FAR *pUnkOuter, DWORD dwFlags) 
{
	HRESULT hr=DP_OK;
	IDirectPlay2 * pIDP2 = NULL;
	LPDPLAYI_DPLAY this = NULL;
	DWORD dwConnectSize;
	LPDPLCONNECTION lpConnect = NULL;

	ENTER_ALL();

	// First, see if we were already called with the async flag, and
	// see if our DPlay2 and DPLCONNECTION pointers already exist
	if(dwFlags & DPCONNECT_RETURNSTATUS)
	{
		// If our pointers exist, then just get them
		PRV_GetConnectPointers(pIDL, &pIDP2, &lpConnect);
	}
	else
	{
		// Make sure we're not already in an async mode
		if(PRV_IsAsyncConnectOn(pIDL))
		{
			// Since we're in the middle of an async Connect, we don't want
			// to blow away our pointers, so we'll just exit from here.
			DPF_ERR("Connect called without the async flag with an asynchronous Connect in progress!");
			goto JUST_EXIT;
		}
	}

	// Now, if our pointers exist, we can skip this part (aka we're already
	// in the middle of an asynchronous Connect, so we have the pointers)
	if(!(pIDP2 && lpConnect))
	{
		// find out how big for connect buffer + alloc it
		hr = pIDL->lpVtbl->GetConnectionSettings(pIDL,0,NULL,&dwConnectSize);
		if (DPERR_BUFFERTOOSMALL != hr) 
		{
			// we passed NULL buffer.  If something other than too small 
			// is returned, we're hosed.
			DPF(2,"Could not get connect settings from lobby  - hr = 0x%08lx\n",hr);
			DPF(2,"Game may not have been lobbied");
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}
		// alloc it
		lpConnect = DPMEM_ALLOC(dwConnectSize);
		if (!lpConnect)
		{
			DPF_ERR("could not get connect struct - out of memory");
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}
		
		// set up the connect
		memset(lpConnect,0,dwConnectSize);
		lpConnect->dwSize = sizeof(DPLCONNECTION);

		// go get the connect buffer
		hr = pIDL->lpVtbl->GetConnectionSettings(pIDL,0,lpConnect,&dwConnectSize);
		if (FAILED(hr))
		{
			DPF(2,"Could not get connect settings from lobby  - hr = 0x%08lx\n",hr);
			DPF(2,"Game may not have been lobbied");
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}

		ASSERT(lpConnect);

		// Send a system message to the lobby client about our status
		PRV_SendStandardSystemMessage(pIDL, DPLSYS_CONNECTIONSETTINGSREAD,
			DPLOBBYPR_GAMEID);

		hr =InternalCreate(&(lpConnect->guidSP),(LPDIRECTPLAY *)&pIDP2,NULL,lpConnect,&dpCallbacks2);
		if (FAILED(hr))
		{
			DPF(0,"internal create failed - hr = 0x%08lx\n",hr);
			// Send a system message to the lobby client about our status
			PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
				DPLOBBYPR_GAMEID);
			goto CLEANUP_EXIT;
		}

		// If we're async, save off the DPlay2 and DPLCONNECTION pointers
		if(dwFlags & DPCONNECT_RETURNSTATUS)
			PRV_SaveConnectPointers(pIDL, pIDP2, lpConnect);
	}

	this = DPLAY_FROM_INT(pIDP2);
#ifdef DEBUG	
	hr = VALID_DPLAY_PTR( this );
	ASSERT( SUCCEEDED(hr) );
#endif 

	// if we're going to join, enum 1st. this is  so dplay will have an internal
	// list of sessions that we can then open.
	if (lpConnect->dwFlags & DPOPEN_JOIN)
	{
		// If the async flag was set, call our async version
		if(dwFlags & DPCONNECT_RETURNSTATUS)
		{
			// Call the non-asynchronous version			
			hr = AsyncConnectFindSession(pIDL,this,lpConnect);
			if (FAILED(hr))
			{
				// An error here is valid (i.e. DPERR_CONNECTING) if
				// we are doing an async Connect.  We don't want to
				// blow away any of our pointers, so just exit here.
				goto JUST_EXIT;
			}

			// Turn off the async stuff in the lobby object
			PRV_SaveConnectPointers(pIDL, NULL, NULL);
			PRV_TurnAsyncConnectOff(pIDL);
		}
		else
		{
			// Call the non-asynchronous version			
			hr = ConnectFindSession(this,lpConnect);
			if (FAILED(hr))
			{
				DPF_ERR("could not find matching session");
				// Send a system message to the lobby client about our status
				PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
					DPLOBBYPR_GAMEID);
				goto CLEANUP_EXIT;
			}
		}
	}

	// now, create or join
	hr = InternalOpenSession(this,lpConnect->lpSessionDesc,FALSE,lpConnect->dwFlags,
        TRUE,NULL,NULL);
	if (FAILED(hr))
	{
		DPF(0,"could not open session  - hr = 0x%08lx\n",hr);
		// Send a system message to the lobby client about our status
		PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTFAILED,
			DPLOBBYPR_GAMEID);
		goto CLEANUP_EXIT;
	}

	// Send a system message to the lobby client about our status
	PRV_SendStandardSystemMessage(pIDL, DPLSYS_DPLAYCONNECTSUCCEEDED,
		DPLOBBYPR_GAMEID);

	// Save a copy of the lobby interface so that we can send
	// messages back to the server from inside dplay
	hr = IDirectPlayLobby_QueryInterface(pIDL, &IID_IDirectPlayLobby,
			&(this->lpLaunchingLobbyObject));
	if(FAILED(hr))
	{
		DPF(2, "Unable to QueryInterface for internal IDirectPlayLobby --");
		DPF(2, "Lobby Server will not be notified of session events");
	}

	// normal exit
	*lplpDP = pIDP2;

	// fall through

CLEANUP_EXIT:

	// If we were async, make sure our pointers are cleared
	if((dwFlags & DPCONNECT_RETURNSTATUS) && (PRV_IsAsyncConnectOn(pIDL)))
	{
		StopAsyncConnect(pIDL, this, lpConnect);
		PRV_SaveConnectPointers(pIDL, NULL, NULL);
		PRV_TurnAsyncConnectOff(pIDL);
	}

	if (lpConnect)
		DPMEM_FREE(lpConnect);

	LEAVE_ALL();

	if(FAILED(hr))
	{
		if (pIDP2)
			pIDP2->lpVtbl->Release(pIDP2);
	}

	return hr;

JUST_EXIT:
	
	// This lable is here to avoid doing an of the cleanup, but
	// still drop the lock in only one place.  There are several
	// exit paths (namely during an async Connect) where we
	// don't want to free our Connection Settings or our
	// IDirectPlay2 pointer.
	LEAVE_ALL();
	return hr;

} // ConnectMe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\common\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>
#include <memlog.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
    typedef struct {
    	UINT stat_ThrottleRate;
		UINT stat_BytesSent;
		UINT stat_BackLog;
	 	UINT stat_BytesLost;
	 	UINT stat_RemBytesReceived;
		UINT stat_Latency; 
		UINT stat_MinLatency;
		UINT stat_AvgLatency;
		UINT stat_AvgDevLatency;
		UINT stat_USER1;
		UINT stat_USER2;
		UINT stat_USER3;
		UINT stat_USER4;
		UINT stat_USER5;	// remote tDelta
		UINT stat_USER6;	// Remote tDelta sign (0=+ve, 1=-ve)
	} IN_WRITESTATS, *PIN_WRITESTATS;

	typedef struct {
		UINT	hr;
	} OUT_WRITESTATS, *POUT_WRITESTATS;

   extern void DbgWriteStats(PIN_WRITESTATS pIn);
  
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(volatile DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define DbgWriteStats()
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD myclockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD myclock()	 {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= myclock(), t ## N ++
    #define TIMESTOP(t)   t ## T += myclock()
    #define TIMEFMT(t)	  ((DWORD)(t) / myclockrate()), (((DWORD)(t) * 1000 / myclockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPlay"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\apphack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       apphack.c
 *
 *  Content:	Hacks to make broken apps work
 *
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *  12/03/98  aarono        original
 *  12/03/98  aarono        Formula1 J crashes when MMTIMER starts
 *  08/18/99  rodtoll		Extended apphacks to allow ID=0 that will match
 *                          any version of the specified EXE.  Also, made
 *							the name comparison case-insensitive.  (For Win98)
 *
 ***************************************************************************/
 
#include "dplaypr.h"
//#include "winnt.h"

#define DPLAY_REGISTRY_APPHACKS "Software\\Microsoft\\DirectPlay\\Compatibility"
#define REGSTR_VAL_NAME		    "Name"
#define REGSTR_VAL_APPID	    "ID"
#define REGSTR_VAL_FLAGS	    "Flags"

__inline static BOOL fileRead( HANDLE hFile, void *data, int len )
{
    DWORD	len_read;

    if( !ReadFile( hFile,  data, (DWORD) len, &len_read, NULL ) ||
    	len_read != (DWORD) len )
    {
		return FALSE;
    }
    return TRUE;

} /* fileRead */

__inline static BOOL fileSeek( HANDLE hFile, DWORD offset )
{
    if( SetFilePointer( hFile, offset, NULL, FILE_BEGIN ) != offset )
    {
		return FALSE;
    }
    return TRUE;

} /* fileSeek */


HRESULT GetAppHacks(LPDPLAYI_DPLAY this)
{
	CHAR name[_MAX_PATH];  // general purpose
	CHAR name_last[_MAX_PATH]; // stores last component of name
	LONG lErr;
	HKEY hKey;
	HANDLE hFile;
	IMAGE_NT_HEADERS nth;
	IMAGE_DOS_HEADER dh;
	DWORD appid;

	DWORD index;
	INT i;

	name[0]=0;
	name_last[0]=0;

	// open the base key - 
	// "HKEY_LOCAL_MACHINE\Software\Microsoft\DirectPlay\Service Providers"
	lErr = RegOpenKeyExA(HKEY_LOCAL_MACHINE,DPLAY_REGISTRY_APPHACKS,0,KEY_READ,&hKey);
	
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d, guess there are no apphacks\n",lErr);
		return DP_OK;	// ok, no app hacks to apply.
	}

	// ok, we now know there are some overrides to apply - so get info about this application.
    hFile =  GetModuleHandleA( NULL );
	
	GetModuleFileNameA( hFile, name, sizeof(name));

	DPF(3,"full name = %s",name);

    i = strlen( name )-1;
    while( i >=0 && name[i] != '\\' )
    {
	i--;
    }
    i++;
    strcpy( name_last, &name[i] );

    /*
     * go find the timestamp in the file
     */
    appid = 0;
    do
    {
        hFile = CreateFileA( name, GENERIC_READ, FILE_SHARE_READ,
	        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( hFile == INVALID_HANDLE_VALUE )
        {
	    DPF( 0, "Could not open file %s", name );
	    break;
        }
        if( !fileRead( hFile, &dh, sizeof( dh ) ) )
        {
	    DPF( 0, "Could not read DOS header for file %s", name );
	    break;
        }
        if( dh.e_magic != IMAGE_DOS_SIGNATURE )
        {
	    DPF( 0, "Invalid DOS header for file %s", name );
	    break;
        }
        if( !fileSeek( hFile, dh.e_lfanew ) )
        {
	    DPF( 0, "Could not seek to PE header in file %s", name );
	    break;
        }
        if( !fileRead( hFile, &nth, sizeof( nth ) ) )
        {
	    DPF( 0, "Could not read PE header for file %s", name );
	    break;
        }
        if( nth.Signature != IMAGE_NT_SIGNATURE )
        {
	    DPF( 0, "Bogus PE header for file %s", name );
	    break;
        }
        appid = nth.FileHeader.TimeDateStamp;
        if( appid == 0 )
        {
	    DPF( 0, "TimeDataStamp is 0 for file %s", name );
	    break;
        }
        DPF( 1, "Obtained appid: 0x%08lx", appid );
    } while(0); //fake try-except

    if(hFile != INVALID_HANDLE_VALUE){
    	CloseHandle( hFile );
    }
   	hFile=NULL;

	// now have a valid appid (timestamp) and filename, also hKey point to the apphack list.
	// apphack keys are stored as follows
    //
	// ProgramName -+-- Flags (BINARY-LO BYTE FIRST)
	//              |
	//              +-- ID (BINARY - TIMESTAMP (ID))
	//              |
	//              +-- NAME (STRING - EXE NAME)
	//
	// We will now run through looking for a matching ID and then if that matches check the name
	// if both match, we will add the flags to this->dwAppHacks 

	index = 0;
    /*
     * run through all keys
     */
    while( !RegEnumKeyA( hKey, index, name, sizeof( name ) ) )
    {
		HKEY	hsubkey;
	    DWORD	type;
	    DWORD	cb;
	    DWORD	id;
	    DWORD	flags;

		if(!RegOpenKeyA(hKey,name,&hsubkey)){

		    cb = sizeof( name );
		    if( !RegQueryValueExA( hsubkey, REGSTR_VAL_NAME, NULL, &type, name, &cb ) )
		    {
				if( type == REG_SZ )
				{
				    cb = sizeof( flags );
				    if( !RegQueryValueExA( hsubkey, REGSTR_VAL_FLAGS, NULL, &type, (LPSTR) &flags, &cb ) )
				    {
				    
						if( (type == REG_DWORD) || (type == REG_BINARY && cb == sizeof( flags )) )
						{
							cb = 4;
							if( !RegQueryValueExA( hsubkey, REGSTR_VAL_APPID, NULL, &type, (LPSTR) &id, &cb ) )
							{
							    if( (type == REG_DWORD) ||
								(type == REG_BINARY && cb == sizeof( flags )) )
							    {
									/*
									 * finally!  we have all the data. check if its the same as this one.
									 */
									 if((id==appid || id==0) && !_memicmp(name,name_last,cb))
									 {
									 	this->dwAppHacks |= flags;
									 	DPF(0,"Setting dwAppHacks to %x\n", this->dwAppHacks);
									 	RegCloseKey(hsubkey);
									 	break; // punt outta here.
									 }
							    } else {
									DPF( 0, "    AppID not a DWORD for app %s", name );
							    }
						    } else {
						    	DPF(0, "    AppID not Found");
						    }
					    } else {
					    	DPF( 0, "    Not BINARY DWORD flags\n");
					    }
					} else {
						DPF( 0, "    No flags found for app %s", name );
				    }
				} else	{
				    DPF( 0, "    Executable name not a string!!!" );
				}
		    } else {
				DPF( 0, "    Executable name not found!!!" );
		    }
		} else {
		    DPF( 0, "  RegOpenKey for %ld FAILED!" );
		} 
		if(hsubkey)RegCloseKey(hsubkey);
		hsubkey=NULL;
		index++;
	}

	RegCloseKey(hKey);

	return DP_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\connect.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       connect.c
 *  Content:	DirectPlay connection related methods
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *    3/1/96	andyco	   	created it
 *	3/10/97		myronth		Added lobby support for EnumConnections and
 *							InitializeConnection, fixed uninit'd struct
 *	3/25/97		kipo		EnumConnections takes a const *GUID
 *	5/10/97		kipo		added GUID to EnumConnections callback
 *	5/12/97		kipo		fixed bugs #7516, 6411, 6888
 *	5/13/97		myronth		Set DPLAYI_DPLAY_SPSECURITY flag so that dplay
 *							lets the LP do all the security for a secure session
 *  7/28/97		sohailm		FindGuidCallback() was assuming pointers were valid after
 *                          duration of call.
 *	8/22/97		myronth		Added registry support for Description and Private values
 *	11/20/97	myronth		Made EnumConnections & DirectPlayEnumerate 
 *							drop the lock before calling the callback (#15208)
 *	01/20/97	sohailm		don't free sp list after EnumConnections (#17006)
 ***************************************************************************/
						
#include "dplaypr.h"
#include "dplobby.h"


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_EnumConnections"
  

// list of all sp info gotten from the registry
extern LPSPNODE gSPNodes;
// call internalenumearte to build a list of sp's / connections
// wrap the sp's in a dpaddress
// call 'em back
HRESULT InternalEnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK pCallback,LPVOID pvContext,DWORD dwFlags,
	BOOL fAnsi, BOOL bPreDP4)
{
	HRESULT hr = DP_OK;
	LPSPNODE pspNode, pspHead;
	BOOL bContinue=TRUE;
	ADDRESSHEADER header;
	DPNAME name;
	LPWSTR lpwszName;
		
	TRY
    {
		if( !VALIDEX_CODE_PTR( pCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		if ( pGuid && !VALID_READ_GUID_PTR( pGuid) )
		{
		    DPF_ERR( "Invalid guid" );
		    return DPERR_INVALIDPARAMS;
		}
		if (dwFlags & (~(DPCONNECTION_DIRECTPLAY |
						DPCONNECTION_DIRECTPLAYLOBBY)))
		{
		    DPF_ERR( "Invalid dwFlags" );
		    return DPERR_INVALIDFLAGS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	// A zero dwFlags value means enumerate all of them, so let's
	// make the code below a little easier
	if(!dwFlags)
		dwFlags = DPCONNECTION_DIRECTPLAY;

	// Enumerate lobby providers if the flags say so
	if(DPCONNECTION_DIRECTPLAYLOBBY & dwFlags)
	{
		hr = PRV_EnumConnections(pGuid, pCallback, pvContext, dwFlags, fAnsi);
		if(FAILED(hr))
		{
			ASSERT(FALSE);
			DPF(0, "Unable to enumerate Lobby Providers, hr = 0x%08x", hr);
		}

		// If enumerating lobby providers is the only things the user
		// requested, then bail
		if(!(dwFlags & ~(DPCONNECTION_DIRECTPLAYLOBBY)))
			return hr;
	}

	// Enumerate DirectPlay Service Providers
	hr = InternalEnumerate();
	if (FAILED(hr)) 
	{
		DPF_ERRVAL("could not enumerate reg entries - hr = 0x%08lx\n",hr);
		return hr;
	}
	
	// set up the non-changing fields in addr
	// 1st, size
	memset(&header, 0, sizeof(ADDRESSHEADER));
	header.dpaSizeChunk.guidDataType = DPAID_TotalSize;
	header.dpaSizeChunk.dwDataSize = sizeof(DWORD);		
	header.dwTotalSize = sizeof(header);

	// next, SP guid
	header.dpaSPChunk.guidDataType = DPAID_ServiceProvider;
	header.dpaSPChunk.dwDataSize = sizeof(GUID);

	memset(&name,0,sizeof(name));
	name.dwSize = sizeof(name);
	
	// now, we have a list of SP's.  walk the list, and call the app back
	// run through what we found...
	pspHead = gSPNodes;
	pspNode = gSPNodes;

	// drop the locks
	LEAVE_ALL();

	while ((pspNode) && (bContinue))
	{
		header.guidSP = pspNode->guid;
		
		if(!(pspNode->dwNodeFlags & SPNODE_PRIVATE))
		{
			if (fAnsi)
			{
				// Use the description if one exists, and we already
				// have an ANSI version of it, so we don't need to
				// convert it...
				if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
				{
					// a-josbor: on a PRE-DPLAY4 interface, we need to simulate the old MBCS
					//	strings, so grab the UNICODE and convert it to MBCS
					if (bPreDP4)
					{
						name.lpszShortNameA = NULL; // 0 it out!
						GetAnsiString(&(name.lpszShortNameA), pspNode->lpszDescW);
					}
					else
					{
						name.lpszShortNameA = pspNode->lpszDescA;
					}
					
					// call the app
					bContinue= pCallback(&header.guidSP,&header,sizeof(header),&name,dwFlags,pvContext);

					if (bPreDP4)
					{
						DPMEM_FREE(name.lpszShortNameA);
					}
				}
				else
				{
					name.lpszShortNameA = NULL; // 0 it out!
					if (SUCCEEDED(GetAnsiString(&(name.lpszShortNameA),pspNode->lpszName)))
					{
						// call the app
						bContinue= pCallback(&header.guidSP,&header,sizeof(header),&name,dwFlags,pvContext);

						DPMEM_FREE(name.lpszShortNameA);
					}
				}
			}
			else 
			{
				// Use the description if one exists
				if(pspNode->dwNodeFlags & SPNODE_DESCRIPTION)
					lpwszName = pspNode->lpszDescW;
				else
					lpwszName = pspNode->lpszName;

				name.lpszShortName = lpwszName;

				// call the app
				bContinue= pCallback(&header.guidSP,&header,sizeof(header),&name,dwFlags,pvContext);
			}
		}

		pspNode = pspNode->pNextSPNode;

	} // while

	// take the locks back
	ENTER_ALL();
	
	return DP_OK;	
		
} // InternalEnumConnections

HRESULT DPAPI DP_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
	HRESULT hr;
	DPF(7,"Entering DP_EnumConnections");

	ENTER_ALL();
	
	hr = InternalEnumConnections(lpDP,pGuid,lpEnumCallback,pvContext,dwFlags,FALSE, FALSE);
	
	LEAVE_ALL();
		
	return hr;
	
} // DP_EnumConnections

   
HRESULT DPAPI DP_A_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
	HRESULT hr;

	DPF(7,"Entering DP_A_EnumConnections");
	
	ENTER_ALL();
	
	hr = InternalEnumConnections(lpDP,pGuid,lpEnumCallback,pvContext,dwFlags,TRUE, FALSE);
	
	LEAVE_ALL();
	
	return hr;
	
} // DP_A_EnumConnections   

HRESULT DPAPI DP_A_EnumConnectionsPreDP4(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
	HRESULT hr;

	DPF(7,"Entering DP_A_EnumConnections");
	
	ENTER_ALL();
	
	hr = InternalEnumConnections(lpDP,pGuid,lpEnumCallback,pvContext,dwFlags,TRUE, TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
} // DP_A_EnumConnectionsPreDP4   


// called by enumaddress - we're looking for DPAID_ServiceProvider
BOOL FAR PASCAL FindGuidCallback(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	// is this a sp chunk
	if (IsEqualGUID(lpguidDataType, &DPAID_ServiceProvider))
	{
		// copy the guid
		*((LPGUID)lpContext) = *((LPGUID)lpData);
		// all done!
		return FALSE;
	}
	// keep trying	
	return TRUE;

} // EnumConnectionData

// fake struct used only for pvAdress size validation - pvAddress must be at least this big
// dpaddress must have at least this must data in it to be valid for initializeconnection
typedef struct 
{
	DPADDRESS	dpaSizeChunk; // the size header
	DWORD		dwTotalSize; // the size
} MINIMALADDRESS,*LPMINIMALADDRESS;

// get our tihs ptr, and call loadsp on it
HRESULT DPAPI DP_InitializeConnection(LPDIRECTPLAY lpDP,LPVOID pvAddress,
	DWORD dwFlags)
{
	HRESULT hr = DP_OK;
	LPDPLAYI_DPLAY this;
	GUID guidSP = GUID_NULL; // the SP's guid
	LPDPADDRESS paddr;
	DWORD dwAddressSize;
				
	DPF(7,"Entering DP_InitializeConnection");

	ENTER_DPLAY();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (DPERR_UNINITIALIZED != hr)
		{
			DPF_ERR("bad or already initialized dplay ptr!");
			LEAVE_DPLAY();
			return DPERR_ALREADYINITIALIZED;
		}
		
		ASSERT(this->dwFlags & DPLAYI_DPLAY_UNINITIALIZED);
		
		// validate this address like it has never been validated before
		paddr = (LPDPADDRESS)pvAddress;
    	
		if (!VALID_READ_STRING_PTR(paddr,sizeof(MINIMALADDRESS)))
    	{
    		DPF_ERR("bad address - too small");
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
    	}
		// the size needs to be the 1st chunk
		if (!IsEqualGUID(&paddr->guidDataType, &DPAID_TotalSize))
		{
			DPF_ERR(" could not extract size from pvAdress - bad pvAddress");
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
		}

		// address size follows paddr
		dwAddressSize = ((MINIMALADDRESS *)paddr)->dwTotalSize;

		if (!VALID_READ_STRING_PTR(paddr,dwAddressSize))
    	{
    		DPF_ERR("bad address - too small");
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
    	}
		
        if (dwFlags)
        {
        	DPF_ERR("invalid flags");
			LEAVE_DPLAY();
			return DPERR_INVALIDFLAGS;
        }
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_DPLAY();
        return DPERR_EXCEPTION;
    }


	// First see if the DPADDRESS contains the LobbyProvider guid.  If it
	// does, load it.  If it doesn't then try looking for a DPlay SP.
 	hr = InternalEnumAddress((IDirectPlaySP *)this->pInterfaces,
			PRV_FindLPGUIDInAddressCallback,pvAddress,dwAddressSize,&guidSP);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Trying to find lobby provider guid - couldn't enum the address - hr = 0x%08lx\n",hr);
	}

	// If we found a lobby provider, try loading it
	if(!IsEqualGUID(&guidSP,&GUID_NULL))
	{
		hr = PRV_LoadSP(this->lpLobbyObject, &guidSP, pvAddress, dwAddressSize);
		if (FAILED(hr))
		{
			DPF_ERRVAL("Unable to load lobby provider - hr = 0x%08lx",hr);
			LEAVE_DPLAY();
			return hr;
		}

		// Mark the dplay object as lobby owned and consider it initialized
		// Also set the DPLAY_SPSECURITY flag so that dplay lets the LP do
		// all of the security.
		this->dwFlags |= (DPLAYI_DPLAY_LOBBYOWNS | DPLAYI_DPLAY_SPSECURITY);
		this->dwFlags &= ~DPLAYI_DPLAY_UNINITIALIZED;

		// Increment the ref cnt on the dplay object (the release code expects
		// an extra ref cnt if the object has been initialized.  This is usually
		// for the IDirectPlaySP interface, but it works just fine in our case
		// for the lobby object's lobby SP).
		this->dwRefCnt++;

		LEAVE_DPLAY();
		return hr;
	}


	// We didn't find a Lobby Provider guid, so look for the SP guid
 	hr = InternalEnumAddress((IDirectPlaySP *)this->pInterfaces,FindGuidCallback,
		pvAddress,dwAddressSize,&guidSP);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Trying to find sp guid - couldn't enum the address - hr = 0x%08lx\n",hr);
	}


	// we found the SP, so load it
	if(!IsEqualGUID(&guidSP, &GUID_NULL))
	{
		// mark dplay as init'ed, since SP may need to make some calls...	
		this->dwFlags &= ~DPLAYI_DPLAY_UNINITIALIZED;
		
		hr = LoadSP(this,&guidSP,(LPDPADDRESS)pvAddress,dwAddressSize);
		if (FAILED(hr))
		{
			DPF_ERRVAL("could not load sp - hr = 0x%08lx",hr);
			this->dwFlags |= DPLAYI_DPLAY_UNINITIALIZED;
			LEAVE_DPLAY();
			return hr;
		}

		// At this point, DirectPlay is finished loading the SP, only
		// code related to the lobby exists beyond this point, so we'll
		// just exit from here.
		LEAVE_DPLAY();
		return hr;
	}


	// We must not have found a provider we can load...
	DPF_ERR("could not find a provider in address");
	LEAVE_DPLAY();
	return DPERR_INVALIDPARAMS;
	
} // DP_InitializeConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dblbuf.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       dblbuf.c
*  Content:	   memory manager for double buffer memory for messages.
*  History:
*   Date		By		Reason
*   ====		==		======
*  12/29/97   aarono    Original
*
* Synopsis:
*
***************************************************************************/

PVOID GetDoubleBuffer(UINT size)
{
}

VOID FreeDoubleBuffer(PVOID pBuffer)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\classfac.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       classfac.c
 *  Content:	directplay class factory code
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	17-jan-97	andyco	created it from ddraw\classfac.c
 *	4/11/97		myronth	Added support for DirectPlayLobby objects
 *  12/01/99    aarono  Change ENTER_DPLAY/LEAVE_DPLAY to ENTER_ALL/LEAVE_ALL
 *                       manbug#28440
 *  02/18/2000	rodtoll	Updated to handle alternative gamevoice build. 
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set 
 ***************************************************************************/
#include "dplaypr.h"
#include <initguid.h>
#include "..\..\bldcfg\dpvcfg.h"

static IClassFactoryVtbl	directPlayClassFactoryVtbl;
static IClassFactoryVtbl	directPlayLobbyClassFactoryVtbl;

typedef struct DPLAYCLASSFACTORY
{
   IClassFactoryVtbl 		*lpVtbl;
   DWORD					dwRefCnt;
} DPLAYCLASSFACTORY, *LPDPLAYCLASSFACTORY;

#define VALIDEX_DIRECTPLAYCF_PTR( ptr ) \
        ((!IsBadWritePtr( ptr, sizeof( DPLAYCLASSFACTORY ))) && \
        ((ptr->lpVtbl == &directPlayClassFactoryVtbl) || \
		(ptr->lpVtbl == &directPlayLobbyClassFactoryVtbl)))
		
#define DPF_MODNAME "DPCF_QueryInterface"

/*
 * DPCF_QueryInterface
 */
STDMETHODIMP DPCF_QueryInterface(
                LPCLASSFACTORY this,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPDPLAYCLASSFACTORY	pcf;
	HRESULT hr;
	
    DPF( 2, "ClassFactory::QueryInterface" );
	
	ENTER_DPLAY();

    TRY
    {
        pcf = (LPDPLAYCLASSFACTORY)this;
        if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
        {
            DPF_ERR(  "Invalid this ptr" );
			LEAVE_DPLAY();
            return E_FAIL;
        }

        if( !VALID_DWORD_PTR( ppvObj ) )
        {
            DPF_ERR( "Invalid object ptr" );
			LEAVE_DPLAY();
            return E_INVALIDARG;
        }
        *ppvObj = NULL;

        if( !VALID_READ_GUID_PTR( riid ) )
        {
            DPF_ERR( "Invalid iid ptr" );
            LEAVE_DPLAY();
            return E_INVALIDARG;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_DPLAY();
        return E_FAIL;
    }

    if( IsEqualIID(riid, &IID_IClassFactory) ||
                    IsEqualIID(riid, &IID_IUnknown))
    {
        pcf->dwRefCnt++; 
        *ppvObj = this;
		hr = S_OK;
    }
    else
    { 
        DPF_ERR("E_NOINTERFACE" );
		hr = E_NOINTERFACE;
    }

	LEAVE_DPLAY();
	
	return hr;
	
} /* DPCF_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DPCF_AddRef"

/*
 * DPCF_AddRef
 */
STDMETHODIMP_(ULONG) DPCF_AddRef( LPCLASSFACTORY this )
{
    LPDPLAYCLASSFACTORY pcf;

	ENTER_DPLAY();
	
    TRY
    {
        pcf = (LPDPLAYCLASSFACTORY)this;
        if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
        {
            DPF_ERR(  "Invalid this ptr" );
            LEAVE_DPLAY();
            return 0;
        }
        pcf->dwRefCnt++;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return 0;
    }

    DPF( 2, "ClassFactory::AddRef, dwRefCnt=%ld", pcf->dwRefCnt );
    LEAVE_DPLAY();
    return pcf->dwRefCnt;

} /* DPCF_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "DPCF_Release"

/*
 * DPCF_Release
 */
STDMETHODIMP_(ULONG) DPCF_Release( LPCLASSFACTORY this )
{
    LPDPLAYCLASSFACTORY	pcf;

    ENTER_DPLAY();
    TRY
    {
        pcf = (LPDPLAYCLASSFACTORY)this;
        if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
        {
            DPF_ERR(  "Invalid this ptr" );
            LEAVE_DPLAY();
            return 0;
        }
        pcf->dwRefCnt--;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return 0;
    }
    DPF( 2, "ClassFactory::Release, dwRefCnt=%ld", pcf->dwRefCnt );

    if( pcf->dwRefCnt != 0 )
    {
        LEAVE_DPLAY();
        return pcf->dwRefCnt;
    }

    DPMEM_FREE( pcf );
    LEAVE_DPLAY();
    return 0;

} /* DPCF_Release */

#undef DPF_MODNAME
#define DPF_MODNAME "DPCF::CreateInstance"

/*
 * DPCF_CreateInstance
 *
 * Creates an instance of a DirectPlay object
 */
STDMETHODIMP DPCF_CreateInstance(
                LPCLASSFACTORY this,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT			hr;
    LPDPLAYCLASSFACTORY		pcf;
	IDirectPlay * pidp;
	GUID GuidCF = GUID_NULL; 	// pass this to DirectPlayCreate
								// to indicate no load sp
	
	
    DPF( 2, "ClassFactory::CreateInstance" );

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	ENTER_ALL();
	
    TRY
    {
	    pcf = (LPDPLAYCLASSFACTORY) this;
	    if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
	    {
	        DPF_ERR( "Invalid this ptr" );
			LEAVE_ALL();
	        return E_INVALIDARG;
	    }

	    if( !VALID_READ_GUID_PTR( riid ) )
	    {
	        DPF_ERR( "Invalid iid ptr" );
	        LEAVE_ALL();
	        return E_INVALIDARG;
	    }

	    if( !VALID_WRITE_PTR( ppvObj,sizeof(LPVOID) ) )
	    {
	        DPF_ERR( "Invalid object ptr" );
	        LEAVE_ALL();
	        return E_INVALIDARG;
	    }

		*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_ALL();
        return E_INVALIDARG;
    }


    /*
     * go get a DirectPlay object
     *
     */
    hr = DirectPlayCreate(&GuidCF,&pidp,NULL);
	if (FAILED(hr))
	{
		LEAVE_ALL();	
		DPF_ERR("could not create DirectPlay object");
		return hr;
	}
		
    if ( !IsEqualIID(riid, &IID_IDirectPlay) )
    {
		IDirectPlay2 * pidp2;

		hr = DP_QueryInterface(pidp,riid,&pidp2);
		if (FAILED(hr))
		{
			// this will destroy our object
			pidp->lpVtbl->Release(pidp);		
			LEAVE_ALL();	
			DPF_ERR("could not get requested DirectPlay interface");
			return hr;
		}

		// release the idp we used to get the pidp2
		pidp->lpVtbl->Release(pidp);

		*ppvObj= (LPVOID)pidp2;
    }
	else 
	{
		*ppvObj = (LPVOID)pidp;
	}

    LEAVE_ALL();
    return DP_OK;

} /* DPCF_CreateInstance */


/*
 * DPCF_LobbyCreateInstance
 *
 * Creates an instance of a DirectPlay object
 */
STDMETHODIMP DPCF_LobbyCreateInstance(
                LPCLASSFACTORY this,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT			hr;
    LPDPLAYCLASSFACTORY		pcf;
	IDirectPlayLobby * pidpl;
	
	
    DPF( 2, "ClassFactory::CreateInstance" );

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	ENTER_DPLAY();
	
    TRY
    {
	    pcf = (LPDPLAYCLASSFACTORY) this;
	    if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
	    {
	        DPF_ERR( "Invalid this ptr" );
			LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

	    if( !VALID_READ_GUID_PTR( riid ) )
	    {
	        DPF_ERR( "Invalid iid ptr" );
	        LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

	    if( !VALID_WRITE_PTR( ppvObj,sizeof(LPVOID) ) )
	    {
	        DPF_ERR( "Invalid object ptr" );
	        LEAVE_DPLAY();
	        return E_INVALIDARG;
	    }

		*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return E_INVALIDARG;
    }


    /*
     * go get a DirectPlayLobby object
     *
     */
    hr = DirectPlayLobbyCreate(NULL,&pidpl,NULL, NULL, 0);
	if (FAILED(hr))
	{
		LEAVE_DPLAY();	
		DPF_ERR("could not create DirectPlayLobby object");
		return hr;
	}
		
    if ( !IsEqualIID(riid, &IID_IDirectPlayLobby) )
    {
		IDirectPlayLobby2 * pidpl2;

		hr = pidpl->lpVtbl->QueryInterface(pidpl,riid,&pidpl2);
		if (FAILED(hr))
		{
			// this will destroy our object
			pidpl->lpVtbl->Release(pidpl);		
			LEAVE_DPLAY();	
			DPF_ERR("could not get requested DirectPlayLobby interface");
			return hr;
		}

		// release the idpl we used to get the pidpl2
		pidpl->lpVtbl->Release(pidpl);

		*ppvObj= (LPVOID)pidpl2;
    }
	else 
	{
		*ppvObj = (LPVOID)pidpl;
	}

    LEAVE_DPLAY();
    return DP_OK;

} /* DPCF_LobbyCreateInstance */


#undef DPF_MODNAME
#define DPF_MODNAME "DPCF::LockServer"

/*
 * DPCF_LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP DPCF_LockServer(
                LPCLASSFACTORY this,
                BOOL fLock
				)
{
    HRESULT		hr;
    HANDLE		hdll;
    LPDPLAYCLASSFACTORY	pcf;

	ENTER_DPLAY();
	
    pcf = (LPDPLAYCLASSFACTORY) this;
    if( !VALIDEX_DIRECTPLAYCF_PTR( pcf ) )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Invalid this ptr" );
        return E_INVALIDARG;
    }

    /*
     * call CoLockObjectExternal
     */
    DPF( 2, "ClassFactory::LockServer" );
    hr = E_UNEXPECTED;
    hdll = LoadLibraryA( "OLE32.DLL" );
    if( hdll != NULL )
    {
        HRESULT (WINAPI * lpCoLockObjectExternal)(LPUNKNOWN, BOOL, BOOL );
        lpCoLockObjectExternal = (LPVOID) GetProcAddress( hdll, "CoLockObjectExternal" );
        if( lpCoLockObjectExternal != NULL )
        {
            hr = lpCoLockObjectExternal( (LPUNKNOWN) this, fLock, TRUE );
        }
        else
        {
            DPF_ERR( "Error! Could not get procaddr for CoLockObjectExternal" );
        }
    }
    else
    {
        DPF_ERR( "Error! Could not load OLE32.DLL" );
    }

	LEAVE_DPLAY();
	return hr;

} /* DPCF_LockServer */

#undef DPF_MODNAME
#define DPF_MODNAME "DllGetClassObject"

static IClassFactoryVtbl directPlayClassFactoryVtbl =
{
        DPCF_QueryInterface,
        DPCF_AddRef,
        DPCF_Release,
        DPCF_CreateInstance,
        DPCF_LockServer
};

static IClassFactoryVtbl directPlayLobbyClassFactoryVtbl =
{
        DPCF_QueryInterface,
        DPCF_AddRef,
        DPCF_Release,
        DPCF_LobbyCreateInstance,
        DPCF_LockServer
};

/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
HRESULT WINAPI DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPDPLAYCLASSFACTORY	pcf;
    HRESULT		hr;
	GUID		guidCLSID;

#ifdef DPLAY_LOADANDCHECKTRUE
	if( ghRedirect != NULL )
	{
		if( IsEqualCLSID( rclsid, &DPLAY_CLSID_DPLAY ) )
		{
			memcpy( &guidCLSID, &CLSID_DirectPlay, sizeof(GUID) );
		}
		else if( IsEqualCLSID( rclsid, &DPLAY_CLSID_DPLOBBY ) )
		{
			memcpy( &guidCLSID, &CLSID_DirectPlayLobby, sizeof(GUID) );
		}
		else
		{
			memcpy( &guidCLSID, rclsid, sizeof(GUID) );
		}

		return (*pfnGetClassObject)(&guidCLSID,riid,ppvObj);
	}
#endif

	ENTER_DPLAY();
	
    TRY
    {
	    if( !VALID_WRITE_PTR( ppvObj,sizeof(LPVOID) ) )
	    {
	        DPF_ERR( "Invalid object ptr" );
	        LEAVE_DPLAY();			
	        return E_INVALIDARG;
	    }
	    *ppvObj = NULL;
	    if( !VALID_READ_GUID_PTR( rclsid ) )
	    {
	        DPF_ERR( "Invalid clsid ptr" );
	        LEAVE_DPLAY();						
	        return E_INVALIDARG;
	    }
	    if( !VALID_READ_GUID_PTR( riid ) )
	    {
	        DPF_ERR( "Invalid iid ptr" );
	        LEAVE_DPLAY();						
	        return E_INVALIDARG;
	    }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return E_INVALIDARG;
    }

    /*
     * is this one of our class ids?
     */
    if( !IsEqualCLSID( rclsid, &DPLAY_CLSID_DPLAY ) && 
	   !IsEqualCLSID( rclsid, &DPLAY_CLSID_DPLOBBY ) )
    {
		DPF_ERR("requested invalid class object");
        LEAVE_DPLAY();			
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, &IID_IUnknown ) &&
       !IsEqualIID( riid, &IID_IClassFactory ) )
    {
        LEAVE_DPLAY();				
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = DPMEM_ALLOC( sizeof( DPLAYCLASSFACTORY ) );
    if( NULL == pcf)
    {
        LEAVE_DPLAY();
        return E_OUTOFMEMORY;
    }

    /* check the CLSID and set the appropriate vtbl
	 */
	if(IsEqualCLSID(rclsid, &DPLAY_CLSID_DPLOBBY))
		pcf->lpVtbl = &directPlayLobbyClassFactoryVtbl;
	else
		pcf->lpVtbl = &directPlayClassFactoryVtbl;

    pcf->dwRefCnt = 0;

    hr = DPCF_QueryInterface( (LPCLASSFACTORY) pcf, riid, ppvObj );
    if( FAILED( hr ) )
    {
        DPMEM_FREE( pcf );
        *ppvObj = NULL;
        DPF( 0, "QueryInterface failed, rc=%08lx", hr );
    }
    else
    {
        DPF( 2, "DllGetClassObject succeeded, pcf=%08lx", pcf );
    }
	
    LEAVE_DPLAY();
    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
HRESULT WINAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

#ifdef DPLAY_LOADANDCHECKTRUE
	if( ghRedirect != NULL )
	{
		return (*pfnDllCanUnLoadNow)();
	}
#endif

    DPF( 2, "DllCanUnloadNow called" );
   
	if (0 == gnObjects)
	{
		// no dplay objects, it's ok to go
		DPF(2,"OK to unload dll");
		hr = S_OK;
	}
	
    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\do.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       do.c
*  Content:	helper functions for iplay.c
*  History:
*   Date		By		Reason
*   ====		==		======
*	6/29/96		andyco	created it to keep clutter down in iplay.c
***************************************************************************/

#include "dplaypr.h"
  
#undef DPF_MODNAME
#define DPF_MODNAME	"DoXXX"

// called by GetPlayer, GetGroup, InternalSetData to set up the player data
// flags can be DPSET_LOCAL or DPSET_REMOTE
// NOTE - can be called on a player, or on a group cast to a player!
HRESULT DoPlayerData(LPDPLAYI_PLAYER lpPlayer,LPVOID pvSource,DWORD dwSourceSize,
	DWORD dwFlags)
{
	LPVOID pvDest; // we set these two based on which flags 
	DWORD dwDestSize; // to dplayi_player->(local)data

	// figure out which dest they want
	if (dwFlags & DPSET_LOCAL)
	{
		pvDest = lpPlayer->pvPlayerLocalData;
		dwDestSize = lpPlayer->dwPlayerLocalDataSize;
	}
	else 
	{
		pvDest = lpPlayer->pvPlayerData;
		dwDestSize = lpPlayer->dwPlayerDataSize;
	}

	// are we copying anything
	if (dwSourceSize)
	{
		// see if we need to alloc dest
		if (0 == dwDestSize)
		{
			ASSERT(!pvDest);
			pvDest = DPMEM_ALLOC(dwSourceSize);
			if (!pvDest)
			{
				DPF_ERR("could not alloc player blob!");
				return E_OUTOFMEMORY;
			}
		} // !pvDest
		// do we need to realloc?
		else if (dwSourceSize != dwDestSize)
		{
			LPVOID	pvTempPlayerData;

			ASSERT(pvDest);
			pvTempPlayerData = DPMEM_REALLOC(pvDest,dwSourceSize);
			if (!pvTempPlayerData)
			{
				DPF_ERR("could not re-alloc player blob!");
				return E_OUTOFMEMORY;
			}
		   	pvDest = pvTempPlayerData;
		}
		// copy the data over
		memcpy(pvDest,pvSource,dwSourceSize);
		dwDestSize = dwSourceSize;

	} // dwDataSize
	else 
	{
		// set it to NULL
		if (dwDestSize)
		{
			ASSERT(pvDest);
			DPMEM_FREE(pvDest);
			pvDest = NULL;
			dwDestSize = 0;
		}
	} // !dwSourceSize

	// update the appropriate pointer
	if (dwFlags & DPSET_LOCAL)
	{
		lpPlayer->pvPlayerLocalData = pvDest;
		lpPlayer->dwPlayerLocalDataSize = dwDestSize;
	}
	else 
	{
		//
		// set the remote data
		lpPlayer->pvPlayerData = pvDest;
		lpPlayer->dwPlayerDataSize = dwDestSize;
	}

	return DP_OK;

} // DoPlayerData

// NOTE - can be called on a player, or on a group cast to a player!
// called by GetPlayer, GetGroup, InternalSetName to set the player name
HRESULT DoPlayerName(LPDPLAYI_PLAYER pPlayer,LPDPNAME pName)
{
    HRESULT hr=DP_OK;

	if (pName)
	{
		// free the old ones, copy over the new ones
		if (pPlayer->lpszShortName) DPMEM_FREE(pPlayer->lpszShortName);
		hr = GetString(&(pPlayer->lpszShortName),pName->lpszShortName);
		if (FAILED(hr))
		{
			return hr;
		}

		if (pPlayer->lpszLongName) DPMEM_FREE(pPlayer->lpszLongName); 
		hr = GetString(&(pPlayer->lpszLongName),pName->lpszLongName);
		if (FAILED(hr))
		{
			return hr;
		} 
	}
	else	// no names given, so free old ones
	{
		if (pPlayer->lpszShortName)
		{
			DPMEM_FREE(pPlayer->lpszShortName);
			pPlayer->lpszShortName = NULL;
		}

		if (pPlayer->lpszLongName)
		{
			DPMEM_FREE(pPlayer->lpszLongName);
			pPlayer->lpszLongName = NULL;
		}
	}


    return hr;   	
} // DoPlayerName

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dplayi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplayi.h
 *  Content:    DirectPlay internal include file for DPlay functions included
 *				by the lobby (not used in any of the DPlay files).
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date		By		Reason
 *	===========	=======	==========
 *	3/9/97		myronth	Created it
 *	3/17/97		myronth	Added player & group structs (only what we need)
 *	3/25/97		myronth	Fixed GetPlayer prototype (1 new parameter)
 *@@END_MSINTERNAL
 ***************************************************************************/
#ifndef __DPLAYI_INCLUDED__
#define __DPLAYI_INCLUDED__


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


//--------------------------------------------------------------------------
//
//	Definitions
//
//--------------------------------------------------------------------------

// Mimick the first part of the player/group struct.  This is really
// the only part we need.
typedef struct DPLAYI_GROUP
{
    DWORD                       dwSize;
	DWORD						dwFlags;
    DPID                        dwID; // DPID for this group
    LPWSTR						lpszShortName;
    LPWSTR						lpszLongName;
	LPVOID						pvPlayerData;
	DWORD						dwPlayerDataSize;
	LPVOID						pvPlayerLocalData;
	DWORD						dwPlayerLocalDataSize;
} DPLAYI_GROUP, * LPDPLAYI_GROUP;

typedef DPLAYI_GROUP DPLAYI_PLAYER;
typedef DPLAYI_PLAYER * LPDPLAYI_PLAYER;

typedef struct DPLAYI_DPLAY * LPDPLAYI_DPLAY;

// REVIEW!!!! -- Should we just include dplaysp.h to get this.  I really
// don't like having it defined in two places.
#define DPLAYI_PLAYER_PLAYERLOCAL       0x00000008

// DPlay Critical Section stuff
extern LPCRITICAL_SECTION gpcsDPlayCritSection;	// defined in dllmain.c
#ifdef DEBUG
extern int gnDPCSCount; // count of dplay lock
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection),gnDPCSCount++;
#define LEAVE_DPLAY() LeaveCriticalSection(gpcsDPlayCritSection),gnDPCSCount--;ASSERT(gnDPCSCount>=0);
#else 
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection);
#define LEAVE_DPLAY() LeaveCriticalSection(gpcsDPlayCritSection);
#endif
// End DPlay Critical Section stuff

//--------------------------------------------------------------------------
//
//	Prototypes
//
//--------------------------------------------------------------------------

// handler.c
extern HRESULT HandleEnumSessionsReply(LPDPLAYI_DPLAY, LPBYTE, LPVOID);

// iplay.c
extern HRESULT GetGroup(LPDPLAYI_DPLAY, LPDPLAYI_GROUP *,LPDPNAME,
						LPVOID, DWORD, DWORD);
extern HRESULT GetPlayer(LPDPLAYI_DPLAY, LPDPLAYI_PLAYER *,	LPDPNAME,
						HANDLE, LPVOID, DWORD, DWORD, LPWSTR);

// namesrv.c
extern HRESULT WINAPI NS_AllocNameTableEntry(LPDPLAYI_DPLAY, LPDWORD);


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#endif // __DPLAYI_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpdvtran.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpdvtran.c
 *  Content:	implements the IDirectXVoiceTransport interface.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  08/02/99	aarono	created it
 *  08/03/99	rodtoll	Modified notification table compaction algorithm
 *  08/04/99	aarono  Added IsValidEntity
 *  08/05/99    aarono  Moved voice over to DPMSG_VOICE
 *  08/10/99	rodtoll	Modified Notify so it does not notify new clients
 *                      who were created as a result of the notification.
 *	08/25/99	rodtoll	Implemented group membership check
 *	08/26/99	rodtoll	Added lock release to group membership check
 *  09/01/99	rodtoll	Added error checks in GetSession
 *  09/09/99	rodtoll	Updated to use new host migrating retrofit.for retrofit
 *				rodtoll	Added retrofit monitor thread
 *	09/10/99	rodtoll	Adjusted GetSessionInfo to call new DV_GetIDS func
 *  09/20/99	rodtoll	Updated to check for Protocol flag & ensure nopreserveorder is not specified
 *  10/05/99	rodtoll	Fixed check for dplay protocol, was missing a LEAVE_ALL()
 *  10/19/99	rodtoll	Fix: Bug #113904 - Lockup if StartSession fails in voice and
 *                      then Release is called on dplay object.
 * 	10/25/99	rodtoll	Fix: Bug #114223 - Debug messages being printed at error level when inappropriate 
 *  11/02/99	rodtoll	Fixes to support Bug #116677 - Can't use lobby clients that don't hang around
 *  11/17/99	rodtoll	Fix: Bug #119585 - Connect failure cases return incorrect error codes
 *  11/23/99	rodtoll	Updated case where dplay not init to return DPVERR_TRANSPORTNOTINIT
 *  12/16/99	rodtoll Fix: Bug #122629 Fixed lockup exposed by new host migration
 *  01/14/00	rodtoll	Updated to return DV_OK when DVERR_PENDING is the error.
 *  01/20/00	rodtoll	Added DV_IsValidGroup / DV_IsValidPlayer to conform to new transport interface
 * 04/06/00     rodtoll Updated to match new approach to having only 1 voice server and 1 client attached to object
 *  04/06/00    rodtoll Updated code to return voice messages to layer immediately.  
 *  04/07/00    rodtoll Fixed Bug #32179 - Registering > 1 interface
 *              rodtoll Added support for nocopy sends (for voice)
 *  04/21/00    rodtoll Fixed crash when migrating because buffer was returned which wasn't from pool
 *  07/22/00	rodtoll	Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  	Now for a thread to make an indication into voice they addref the interface
 *						so that the voice core can tell when all indications have returned.   
 *  07/31/00	rodtoll	Bug #41135 - Shutdown lockup -- now does not addref if notification
 *						is a session lost.  Added AddRefs() for VoiceReceive
 *
 ***************************************************************************/

#include "dplaypr.h"
#include "newdpf.h"
#include "dvretro.h"

VOID ClearTargetList(LPDPLAYI_DPLAY this);
HRESULT DV_InternalSend( LPDPLAYI_DPLAY this, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvUserContext, DWORD dwFlags );

#undef DPF_MODNAME
#define DPF_MODNAME "DVoice"

// Notify all registered voice clients of an event.
VOID DVoiceNotify(LPDPLAYI_DPLAY this, DWORD dw1, DWORD_PTR dw2, DWORD_PTR dw3, DWORD dwObjectType )
{
	DWORD i;
	HRESULT hr;
	DVPROTOCOLMSG_IAMVOICEHOST dvMsg;
	DVTRANSPORT_BUFFERDESC dvBufferDesc;

	PDIRECTPLAYVOICENOTIFY pServer;
	PDIRECTPLAYVOICENOTIFY pClient;

	// Ensure that voice objects created as a result of this notification
	// do not receive the notification

	DPF(3,"DVoiceNotify this %x, dw1=%x, dw2=%x, dw3=%x\n",this,dw1,dw2,dw3);
	DPF(3,"gnDPCScount=%x\n",gnDPCSCount);

	// Grab a reference so we don't destroy voice end before all of these notifies have returned  
   	EnterCriticalSection( &this->csNotify );
	pClient = this->lpDxVoiceNotifyClient;
	pServer = this->lpDxVoiceNotifyServer;

	if( dw1 != DVEVENT_STOPSESSION )
	{
		if( pClient )
			pClient->lpVtbl->AddRef( pClient );

		if( pServer )
			pServer->lpVtbl->AddRef( pServer );
	}	
	
	LeaveCriticalSection( &this->csNotify );
	

	if( pClient != NULL && dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
	    this->lpDxVoiceNotifyClient->lpVtbl->NotifyEvent( this->lpDxVoiceNotifyClient, dw1, dw2, dw3 );
    }

    if( pServer != NULL && dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
    {
        this->lpDxVoiceNotifyServer->lpVtbl->NotifyEvent( this->lpDxVoiceNotifyServer, dw1, dw2, dw3 );
    }	
	
	// Handle addplayer events if I'm the host
	if( dw1 == DVEVENT_ADDPLAYER && this->bHost )
	{
		DPF( 1, "DVoiceNotify: A player was added and I'm the host.  Inform their dplay to launch connection" );

		dvMsg.bType = DVMSGID_IAMVOICEHOST;
		dvMsg.dpidHostID = this->dpidVoiceHost;

		ENTER_ALL();

        memset( &dvBufferDesc, 0x00, sizeof( DVTRANSPORT_BUFFERDESC ) );
		dvBufferDesc.dwBufferSize = sizeof( dvMsg );
		dvBufferDesc.pBufferData = (PBYTE) &dvMsg;
		dvBufferDesc.dwObjectType = 0;
		dvBufferDesc.lRefCount = 1;
		
		hr = DV_InternalSend( this, this->dpidVoiceHost , (DVID)dw2,&dvBufferDesc, NULL, DVTRANSPORT_SEND_GUARANTEED );

		if( hr != DVERR_PENDING && FAILED( hr ) )
		{
			DPF( 0, "DV_InternalSend Failed on I am host voice message hr=0x%x", hr );
		}

		LEAVE_ALL();
	}

	if(dw1 == DVEVENT_ADDPLAYERTOGROUP || dw1 == DVEVENT_REMOVEPLAYERFROMGROUP)
	{
		ENTER_ALL();
		ClearTargetList(this);
		LEAVE_ALL();
	}		

	if( dw1 != DVEVENT_STOPSESSION )
	{
		if( pClient )
			pClient->lpVtbl->Release( pClient );

		if( pServer )
			pServer->lpVtbl->Release( pServer );
	}
}

// Notify all registered voice clients of an event.
VOID DVoiceReceiveSpeechMessage(LPDPLAYI_DPLAY this, DVID dvidFrom, DVID dvidTo, LPVOID lpvBuffer, DWORD cbBuffer)
{
	UINT i;
	LPDVPROTOCOLMSG_IAMVOICEHOST lpdvmVoiceHost;
	HRESULT hr;

	PDIRECTPLAYVOICENOTIFY pServer;
	PDIRECTPLAYVOICENOTIFY pClient;

   	EnterCriticalSection( &this->csNotify );
	pClient = this->lpDxVoiceNotifyClient;
	pServer = this->lpDxVoiceNotifyServer;

	if( pClient )
		pClient->lpVtbl->AddRef(pClient);

	if( pServer )
		pServer->lpVtbl->AddRef(pServer);
	
   	LeaveCriticalSection( &this->csNotify );

	if( pClient != NULL )
	{
	    this->lpDxVoiceNotifyClient->lpVtbl->ReceiveSpeechMessage( this->lpDxVoiceNotifyClient, dvidFrom, dvidTo, lpvBuffer, cbBuffer );
    }

    if( pServer != NULL )
    {
        this->lpDxVoiceNotifyServer->lpVtbl->ReceiveSpeechMessage( this->lpDxVoiceNotifyServer, dvidFrom, dvidTo, lpvBuffer, cbBuffer );
    }
    
	lpdvmVoiceHost = (LPDVPROTOCOLMSG_IAMVOICEHOST) lpvBuffer;

	// If the message we received was i am voice server, then
	// launch the hack..
	if( lpdvmVoiceHost->bType == DVMSGID_IAMVOICEHOST )
	{
		// Check to ensure hack is enabled on this PC
		if( this->fLoadRetrofit )
		{
			this->dpidVoiceHost = lpdvmVoiceHost->dpidHostID;
			
			hr = DV_RunHelper( this, lpdvmVoiceHost->dpidHostID, FALSE );

			if( FAILED( hr ) )
			{
				DPF( 0, "DV_RunHelper Failed hr=0x%x", hr );
			}
		}
	}

	if( pClient )
		pClient->lpVtbl->Release(pClient);

	if( pServer )
		pServer->lpVtbl->Release(pServer);
	
}

HRESULT DV_Advise(LPDIRECTPLAY lpDP, LPUNKNOWN lpUnk, DWORD dwObjectType)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
    DPCAPS dpCaps;

    hr = DV_OK;

	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	if( this->lpsdDesc == NULL )
	{
		DPF_ERR( "No session has been started" );
		LEAVE_ALL();

		return DVERR_TRANSPORTNOSESSION;
	}

    if( this->lpsdDesc->dwFlags & DPSESSION_NOPRESERVEORDER )
    {
    	DPF_ERR( "Cannot run with nopreserveorder flag" );
    	LEAVE_ALL();
    	return DVERR_NOTSUPPORTED;
    }

    if( !(this->lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL) &&
        !(this->dwSPFlags & DPCAPS_ASYNCSUPPORTED ) )
    {
    	DPF_ERR( "No async sends available" );
    	LEAVE_ALL();
    	return DVERR_NOTSUPPORTED;
    }
        
	// Make sure we're not running with the order not important flag
	if( !(this->lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL) ||
	    (this->lpsdDesc->dwFlags & DPSESSION_NOPRESERVEORDER) )
	{
		DPF_ERR("Cannot run without protocol or with no preserve order flag" );
		LEAVE_ALL();
		return DVERR_NOTSUPPORTED;
	}

	if( dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
	{
	    if( this->lpDxVoiceNotifyServer != NULL )
	    {
	        DPF( 0, "There is already a server interface registered on this object" );
	        hr = DVERR_GENERIC;
	    }
	    else
	    {
	    	EnterCriticalSection( &this->csNotify );
	        hr = lpUnk->lpVtbl->QueryInterface( lpUnk, &IID_IDirectPlayVoiceNotify, (void **) &this->lpDxVoiceNotifyServer );

	        if( FAILED( hr ) )
	        {
	            DPF( 0, "QueryInterface failed! hr=0x%x", hr );
	        }
	        else
	        {
            	hr = this->lpDxVoiceNotifyServer->lpVtbl->Initialize(this->lpDxVoiceNotifyServer);

            	if( FAILED( hr ) )
            	{
            	    DPF( 0, "Failed to perform initialize on notify interface hr=0x%x", hr );
            	    this->lpDxVoiceNotifyServer->lpVtbl->Release( this->lpDxVoiceNotifyServer );
            	    this->lpDxVoiceNotifyServer = NULL;
            	}
	        }
	    	LeaveCriticalSection( &this->csNotify );	        
	    }
	    
	}
	else if( dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
    	EnterCriticalSection( &this->csNotify );	
	    if( this->lpDxVoiceNotifyClient != NULL )
	    {
	        DPF( 0, "There is already a client interface registered on this object" );
	        hr = DVERR_GENERIC;
	    }
	    else
	    {
	        hr = lpUnk->lpVtbl->QueryInterface( lpUnk, &IID_IDirectPlayVoiceNotify, (void **) &this->lpDxVoiceNotifyClient );

	        if( FAILED( hr ) )
	        {
	            DPF( 0, "QueryInterface failed! hr=0x%x", hr );
	        }
	        else
	        {
            	hr = this->lpDxVoiceNotifyClient->lpVtbl->Initialize(this->lpDxVoiceNotifyClient);

            	if( FAILED( hr ) )
            	{
            	    DPF( 0, "Failed to perform initialize on notify interface hr=0x%x", hr );
            	    this->lpDxVoiceNotifyClient->lpVtbl->Release( this->lpDxVoiceNotifyClient );
            	    this->lpDxVoiceNotifyClient = NULL;
            	}
	        }
	    }	    
    	LeaveCriticalSection( &this->csNotify );	        
	}
	else
	{
	    DPF( 0, "Error: Invalid object type specified in advise" );
	    ASSERT( FALSE );
	    hr = DVERR_GENERIC;
	}	

    LEAVE_ALL();
    
	return hr;
}

HRESULT DV_UnAdvise(LPDIRECTPLAY lpDP, DWORD dwObjectType)
{
	DWORD dwIndex;
    LPDPLAYI_DPLAY this;
	HRESULT hr;
    
//	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
	//		LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		//LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			 

   	EnterCriticalSection( &this->csNotify );
    
	if( dwObjectType & DVTRANSPORT_OBJECTTYPE_SERVER )
	{
        if( this->lpDxVoiceNotifyServer != NULL )
	    {
    	    this->lpDxVoiceNotifyServer->lpVtbl->Release( this->lpDxVoiceNotifyServer );
    	    this->lpDxVoiceNotifyServer = NULL;	    
	    }
	    else
	    {
	        DPF( 0, "No server currently registered" );
	        hr = DVERR_GENERIC;
	    }
	}
	else if( dwObjectType & DVTRANSPORT_OBJECTTYPE_CLIENT )
	{
	    if( this->lpDxVoiceNotifyClient != NULL )
	    {
    	    this->lpDxVoiceNotifyClient->lpVtbl->Release( this->lpDxVoiceNotifyClient );
    	    this->lpDxVoiceNotifyClient = NULL;	    
	    }
	    else
	    {
	        DPF( 0, "No client currently registered" );
	        hr = DVERR_GENERIC;
	    }
	}
	else
	{
	    DPF( 0, "Could not find interface to unadvise" );
	    hr = DVERR_GENERIC;
	}

   	LeaveCriticalSection( &this->csNotify );
	
//    LEAVE_ALL();
    
	return DP_OK;
}

HRESULT DV_IsGroupMember(LPDIRECTPLAY lpDP, DVID dvidGroup, DVID dvidPlayer)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
	LPDPLAYI_GROUP pGroup;
	LPDPLAYI_GROUPNODE pGroupnode;
	DWORD nPlayers;	
	DWORD i;

	// Shortcut for when target is all
	if( dvidGroup == DPID_ALLPLAYERS )
		return DP_OK;

   	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

		pGroup = GroupFromID(this,dvidGroup);
		if (!VALID_DPLAY_GROUP(pGroup)) 
		{
			DPF_ERR( "Invalid group ID" );
			LEAVE_ALL();
			return DPERR_INVALIDGROUP;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			

    // any players to enumerate ?
    if (!pGroup->pGroupnodes || (0 == pGroup->nPlayers))
    {
    	LEAVE_ALL();
    	return E_FAIL;
    }

    pGroupnode = pGroup->pGroupnodes;
	nPlayers = pGroup->nPlayers;
	
    for (i=0; i < nPlayers; i++)
    {
        ASSERT(pGroupnode);
        
        if( pGroupnode->pPlayer->dwID == dvidPlayer )
        {
        	LEAVE_ALL();
        	return DP_OK;
        }

        pGroupnode=pGroupnode->pNextGroupnode;
    }

    LEAVE_ALL();    
    
	return E_FAIL;

}

// ASSUMES: ENTER_ALL() lock
HRESULT DV_InternalSend( LPDPLAYI_DPLAY this, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvUserContext, DWORD dwFlags )
{
    HRESULT hr;

	LPDPLAYI_PLAYER pPlayerFrom,pPlayerTo;
	LPDPLAYI_GROUP pGroupTo;
	CHAR SendBuffer[2048];
	LPMSG_VOICE pMsgVoice;
	PCHAR pVoiceData;
	DWORD dwSendSize;
	DWORD dwDirectPlayFlags;
    // Send immediate completion of voice send.
	DVEVENTMSG_SENDCOMPLETE dvSendComplete;	

	dwSendSize = *((DWORD *) pBufferDesc->pBufferData);

	TRY
	{
		// check src player        
		pPlayerFrom = PlayerFromID(this,dvidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF_ERR("bad voice player from");
    		return DPERR_INVALIDPLAYER;
		}
		
		if(pPlayerFrom->dwFlags&DPLAYI_PLAYER_SYSPLAYER){
			DPF(0,"Sendint From System Player pPlayerFrom %x?\n",pPlayerFrom);
    		return DPERR_INVALIDPLAYER;
		}

		// see if it's a player or group
		pPlayerTo = PlayerFromID(this,dvidTo);
		if (VALID_DPLAY_PLAYER(pPlayerTo)) 
		{		  
			pGroupTo = NULL;
		}
		else 
		{
			pGroupTo = GroupFromID(this,dvidTo);
			if (VALID_DPLAY_GROUP(pGroupTo)) 
			{
				pPlayerTo = NULL;
			}
			else 
			{
				// bogus id! - player may have been deleted...
				DPF_ERRVAL("bad voice player to %x\n",dvidTo);
				return DPERR_INVALIDPLAYER;
			}// not player or group
		} // group
	
	}
	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
	{
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;	
	}

	pMsgVoice=(LPMSG_VOICE)(SendBuffer+this->dwSPHeaderSize);
	pVoiceData=(PCHAR)(pMsgVoice+1);
	dwSendSize=pBufferDesc->dwBufferSize+sizeof(MSG_VOICE)+this->dwSPHeaderSize;

	SET_MESSAGE_HDR(pMsgVoice);
	SET_MESSAGE_COMMAND(pMsgVoice,DPSP_MSG_VOICE);
	pMsgVoice->dwIDTo=dvidTo;
	pMsgVoice->dwIDFrom=dvidFrom;
	memcpy(pVoiceData,pBufferDesc->pBufferData,pBufferDesc->dwBufferSize);

	dwDirectPlayFlags = 0;

	if( dwFlags & DVTRANSPORT_SEND_GUARANTEED )
	{
		dwDirectPlayFlags |= DPSEND_GUARANTEED;
	}

	dwDirectPlayFlags |= DPSEND_ASYNC;

	// Loopback for client in same process as server case
    if( dvidFrom == dvidTo )
    {
    	hr = DV_OK;
		DVoiceReceiveSpeechMessage(this, dvidFrom, dvidTo, pBufferDesc->pBufferData, pBufferDesc->dwBufferSize);
    } else {
	    if(pPlayerTo){
			hr=SendDPMessage(this,pPlayerFrom,pPlayerTo,SendBuffer,dwSendSize,dwDirectPlayFlags,FALSE);		
		} else {
			// must be a group message
			ASSERT(pGroupTo);
			hr=SendGroupMessage(this,pPlayerFrom,pGroupTo,dwDirectPlayFlags,SendBuffer,dwSendSize,FALSE);
		}
	}

	// Sync messages don't generate callbacks
	if( !(dwFlags & DVTRANSPORT_SEND_SYNC) )
	{
		if( InterlockedDecrement( &pBufferDesc->lRefCount ) == 0 )
		{
    		dvSendComplete.pvUserContext = pvUserContext;
    		dvSendComplete.hrSendResult = DV_OK;

    		DVoiceNotify( this, DVEVENT_SENDCOMPLETE, (DWORD_PTR) &dvSendComplete, 0, pBufferDesc->dwObjectType );
		}
	}

	return hr;
	
}

HRESULT DV_SendSpeech(LPDIRECTPLAY lpDP, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvContext, DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;

	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }	

    pBufferDesc->lRefCount = 1;

    hr = DV_InternalSend( this, dvidFrom, dvidTo, pBufferDesc, pvContext, dwFlags );

    if( hr == DPERR_PENDING )
    	hr = DV_OK;

    LEAVE_ALL();

    return hr;
}

/////////////////////////////////////////
// Support Routinesfor DV_SendSpeechEx //
/////////////////////////////////////////

VOID ClearTargetList(LPDPLAYI_DPLAY this)
{
	this->nTargets=0;
}

VOID ClearExpandedTargetList(LPDPLAYI_DPLAY this)
{
	this->nExpandedTargets=0;
}

HRESULT AddExpandedTargetListEntry(LPDPLAYI_DPLAY this, DPID dpid)
{
	#define GROW_SIZE 16
	
	LPDPID pdpid;
	
	if(this->nExpandedTargets == this->nExpandedTargetListLen){
		// Need more room, allocate another 16 entries

		pdpid=DPMEM_ALLOC((this->nExpandedTargetListLen+GROW_SIZE)*sizeof(DPID));

		if(!pdpid){
			return DPERR_NOMEMORY;
		}
		
		if(this->pExpandedTargetList){
			memcpy(pdpid, this->pExpandedTargetList, this->nExpandedTargetListLen*sizeof(DPID));
			DPMEM_FREE(this->pExpandedTargetList);
		}
		this->pExpandedTargetList = pdpid;
		this->nExpandedTargetListLen += GROW_SIZE;
	}

	this->pExpandedTargetList[this->nExpandedTargets++]=dpid;

	return DP_OK;

	#undef GROW_SIZE
}

void AddIfNotAlreadyFound( LPDPLAYI_DPLAY this, DPID dpidID )
{
	DWORD j;
	
	for(j=0;j<this->nExpandedTargets;j++)
	{
		if( this->pExpandedTargetList[j] == dpidID )
		{
			break;
		}
	}

	// It was not found, add him to the list
	if( j == this->nExpandedTargets )
	{
		AddExpandedTargetListEntry(this, dpidID);							
	}
}

HRESULT ExpandTargetList(LPDPLAYI_DPLAY this, DWORD nTargets, PDVID pdvidTo)
{
	HRESULT hr=DP_OK;
	UINT i, j;

	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	LPDPLAYI_GROUPNODE pGroupnode;	

	// See if we need to change the expanded target list or we have it cached.
	
	if(nTargets != this->nTargets || memcmp(pdvidTo, this->pTargetList, nTargets * sizeof(DVID))){

		DPF(9, "ExpandTargetList, new list re-building cached list\n");
		
		// the target list is wrong, rebuild it.
		// First copy the new target list...
		if(nTargets > this->nTargetListLen){
			// Current list is too small, possibly non-existant, allocate one to cache the list.
			if(this->pTargetList){
				DPMEM_FREE(this->pTargetList);
			}
			this->pTargetList=(PDVID)DPMEM_ALLOC(nTargets * sizeof(DVID));
			if(this->pTargetList){
				this->nTargetListLen=nTargets;
			} else {
				this->nTargetListLen=0;
				this->nTargets=0;
				hr=DPERR_NOMEMORY;
				DPF(0,"Ran out of memory trying to cache target list!\n");
				goto exit;
			}
		}
		this->nTargets = nTargets;
		memcpy(this->pTargetList, pdvidTo, nTargets*sizeof(DPID));

		// OK we have the target list cached, now build the list we are going to send to.
		ClearExpandedTargetList(this);
		for(i=0;i<this->nTargets;i++)
		{
			// Multicast Code
			// MANBUG 31013 Revisit when we have a group optimized provider
			if( this->dwSPFlags & DPCAPS_GROUPOPTIMIZED )
			{
				ASSERT( FALSE );				
			}
			
			pPlayer = (LPDPLAYI_PLAYER)NameFromID(this,this->pTargetList[i]);

			// We only want valid player/groups
			if( pPlayer )
			{
				if( pPlayer->dwSize == sizeof( DPLAYI_PLAYER ) )
				{
					AddIfNotAlreadyFound( this, this->pTargetList[i] );
				}
				else
				{
					DWORD nPlayers;	

					pGroup = (LPDPLAYI_GROUP) pPlayer;

				    // any players to enumerate ?
				    if (pGroup->pGroupnodes && pGroup->nPlayers )
				    {
					    pGroupnode = pGroup->pGroupnodes;
						nPlayers = pGroup->nPlayers;
						
					    for (j=0; j < nPlayers; j++)
					    {
					        ASSERT(pGroupnode);
					        AddIfNotAlreadyFound( this, pGroupnode->pPlayer->dwID );
					        pGroupnode=pGroupnode->pNextGroupnode;
					    }
					 }
				}
			}
			
		}

	} else {
		DPF(9,"ExpandTargetList, using cached list\n");
	}

exit:
	return hr;
}

// DV_SendSpeechEx

HRESULT DV_SendSpeechEx(LPDIRECTPLAY lpDP, DVID dvidFrom, DWORD nTargets, PDVID pdvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvContext, DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
	UINT i;

	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }	


	hr=ExpandTargetList(this, nTargets, pdvidTo);

	if(hr != DP_OK){
		goto exit;
	}

	pBufferDesc->lRefCount = this->nExpandedTargets;

	// Send to our expanded and duplicate removed list.
	for(i=0; i < this->nExpandedTargets; i++){

	    hr = DV_InternalSend( this, dvidFrom, this->pExpandedTargetList[i], pBufferDesc, pvContext, dwFlags );

	}    

exit:

    if( hr == DPERR_PENDING )
    	hr = DV_OK;

    LEAVE_ALL();

    return hr;
}

HRESULT DV_GetSessionInfo(LPDIRECTPLAY lpDP, LPDVTRANSPORTINFO lpdvTransportInfo )
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
    BOOL fLocalHost;

	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

        if( this->pPlayers == NULL )
        {
        	DPF_ERR( "Not connected yet\n" );
        	LEAVE_ALL();
        	return DVERR_TRANSPORTNOSESSION;
        }

        if( lpdvTransportInfo->dwSize < sizeof( DVTRANSPORTINFO ) )
        {
        	DPF_ERR( "Bad size of struct\n" );
        	LEAVE_ALL();
        	return DPERR_INVALIDPARAM;
        }

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	lpdvTransportInfo->dwFlags = 0;

	if( this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER )
	{
		lpdvTransportInfo->dwSessionType = DVTRANSPORT_SESSION_CLIENTSERVER;
	}
	else
	{
		lpdvTransportInfo->dwSessionType = DVTRANSPORT_SESSION_PEERTOPEER;
	}

	if( this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER )
	{
		lpdvTransportInfo->dwFlags |= DVTRANSPORT_MULTICAST;
	}

	if( this->lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST )
	{
		lpdvTransportInfo->dwFlags |= DVTRANSPORT_MIGRATEHOST;		
	}

	lpdvTransportInfo->dvidLocalID = DPID_UNKNOWN;
	lpdvTransportInfo->dwMaxPlayers = 0;

	lpdvTransportInfo->dvidLocalID = DPID_UNKNOWN;
	lpdvTransportInfo->dvidSessionHost = DPID_UNKNOWN;

	// Needed, otherwise compiler is messing up this on the next call!
	fLocalHost = FALSE;

	hr = DV_GetIDS( this, &lpdvTransportInfo->dvidSessionHost, &lpdvTransportInfo->dvidLocalID, &fLocalHost  );

	if( FAILED( hr ) )
	{
		DPF( 0, "DV_GetIDS Failed: hr=0x%x", hr );
		LEAVE_ALL();
		return hr;
	}

	if( fLocalHost )
	{
		lpdvTransportInfo->dwFlags |= DVTRANSPORT_LOCALHOST;
	}

    LEAVE_ALL();

	return DP_OK;

}

HRESULT DV_IsValidEntity (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
	LPDPLAYI_PLAYER pPlayer;
	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

        if( this->pPlayers == NULL )
        {
        	DPF_ERR( "Not connected yet\n" );
        	LEAVE_ALL();
        	return DPERR_INVALIDPARAM;
        }

		if(!VALID_WRITE_PTR(lpb, sizeof(LPBOOL))){
			DPF_ERR( "Invalid BOOL pointer\n");
			LEAVE_ALL();
			return DPERR_INVALIDPARAM;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	*lpb=FALSE;

    // Players and groups have flags in the same location on their structure
    // so we don't need to check if its a player or a group to validate.
	if(pPlayer=(LPDPLAYI_PLAYER)NameFromID(this,dpid)){
		if(!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)){
			*lpb=TRUE;
		}
	}
	
	LEAVE_ALL();
	return hr;
}

HRESULT DV_IsValidPlayer (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
	LPDPLAYI_PLAYER pPlayer;
	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

        if( this->pPlayers == NULL )
        {
        	DPF_ERR( "Not connected yet\n" );
        	LEAVE_ALL();
        	return DPERR_INVALIDPARAM;
        }

		if(!VALID_WRITE_PTR(lpb, sizeof(LPBOOL))){
			DPF_ERR( "Invalid BOOL pointer\n");
			LEAVE_ALL();
			return DPERR_INVALIDPARAM;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	*lpb=FALSE;

	if(pPlayer=(LPDPLAYI_PLAYER)NameFromID(this,dpid)){
		if(!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
		     pPlayer->dwSize == sizeof( DPLAYI_PLAYER ) ){
			*lpb=TRUE;
		}
	}
	
	LEAVE_ALL();
	return hr;
}

HRESULT DV_IsValidGroup (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr;
	LPDPLAYI_PLAYER pPlayer;
	ENTER_ALL();
	
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return DVERR_TRANSPORTNOTINIT;
        }

        if( this->pPlayers == NULL )
        {
        	DPF_ERR( "Not connected yet\n" );
        	LEAVE_ALL();
        	return DPERR_INVALIDPARAM;
        }

		if(!VALID_WRITE_PTR(lpb, sizeof(LPBOOL))){
			DPF_ERR( "Invalid BOOL pointer\n");
			LEAVE_ALL();
			return DPERR_INVALIDPARAM;
		}

    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	*lpb=FALSE;

	if(pPlayer=(LPDPLAYI_PLAYER)NameFromID(this,dpid)){
		if(!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
  			 pPlayer->dwSize == sizeof( DPLAYI_GROUP ) ){
			*lpb=TRUE;
		}
	}
	
	LEAVE_ALL();
	return hr;
}



#undef DPF_MODNAME
#define DPF_MODNMAE "HandleVoiceMessage"

HRESULT HandleVoiceMessage(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize, DWORD dwSendFlags) 
{
	LPMSG_VOICE pmsg; // message cast from received buffer
	HRESULT hr=DP_OK;
	
	pmsg = (LPMSG_VOICE)pReceiveBuffer;

	LEAVE_DPLAY();
	ENTER_ALL();
	
	TRY 
	{
	
		hr = VALID_DPLAY_PTR( this );
		
		if (FAILED(hr))	{
			LEAVE_SERVICE();
			return DVERR_TRANSPORTNOTINIT;
	    }
	    
	} 
	EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_SERVICE();
        return DPERR_INVALIDPARAMS;
	}

	DVoiceReceiveSpeechMessage(this, pmsg->dwIDFrom, pmsg->dwIDTo, (LPVOID)(pmsg+1), dwMessageSize-sizeof(MSG_VOICE));

	LEAVE_SERVICE();

	return DP_OK;
} // HandleVoiceMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dplay.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplay.h
 *  Content:    DirectPlay include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *	Date   By  Reason
 *	============
 *	04-apr-95  ericeng  DirectPlay header file COM version
 *	07-jul-95  johnhall Making Program Management Dreams a Reality.
 *	19-jul-95  ericeng  Header file rationalization
 *	2/96		AndyCo	New dplay (dp2)
 *	4/8/96		AndyCo	added DPSESSION_PLAYERS_ENABLED
 *	4/18/96		AndyCo	dpcaps2
 *	5/3/96		andyco	idirectplay2
 *	5/6/96		andyco	unions for wchar and char
 *	5/23/96		andyco	added DPSESSION_MIGRATENAMESERVER, moved data to last
 *						element in addxxx messages to make packing easier
 *	5/31/96		andyco	added DPNAME,DPLAY_SETDATA_REMOTE,
 *						DPSET_GUARANTEED
 *
 *	6/9/95		andyco	DPLAY_SETDATA_REMOTE -> DPLAY_SETDATA_LOCAL for consistancy
 *						PLAYERNAME -> DPNAME, DPOPEN_xxx -> DPSESSION_CREATE
 *						/ DPSESSION_JOIN
 *	6/20/96		andyco	cleaned up flags, etc.
 *	6/22/96		andyco	added dwFlags to Open,GetCaps
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *  6/27/96     ajayj   defined flags DPSEND_OPENSTREAM and DPSEND_CLOSESTREAM
 *  6/29/96     ajayj   defined flag DPSESSION_PRIVATE and modified comment for
 *                      DPSESSION_PLAYERSDISABLED
 *	6/30/96		andyco	added DP(G)SET_REMOTE,_LOCAL
 *  7/5/96      ajayj   change DPSESSION_PRIVATE to DPSESSION_JOINDISABLED
 *                      added DPSESSION_NEWPLAYERSDISABLED and defined
 *                      old flag DPSESSION_PLAYERSDISABLED to be the same thing
 *  7/8/96      ajayj   Added loads of comments.
 *                      Alphabetized IDirectPlay2 vtable
 *                      Removed SaveSession and EnableNewPlayers from vtable
 *                      Removed structure DPSAVEDATA
 *                      Change terminology "Name Server" is now a session "Host"
 *                      DPCAPS_GROUP                -> DPCAPS_GROUPOPTIMIZED
 *                      DPCAPS_NAMESERVER           -> DPCAPS_ISHOST
 *                      DPSESSION_MIGRATENAMESERVER -> DPSESSION_MIGRATEHOST
 *                      DPSYS_NAMESERVER            -> DPSYS_HOST
 *                      LPDPENUMSESSIONCALLBACK2 - lpContext at end of param list
 *                      LPDPENUMPLAYERSCALLBACK2 - dwPlayerType after dpId
 *                      Changed numbering of DPSYS_HOST, DPSYS_DATACHANGED, and
 *                          DPSYS_NAMECHANGED system messages
 *                      DPMSG_NAMECHANGED, DPMSG_ADDPLAYER2 - changed name of
 *                          data member 'PlayerName' to 'dpnName'.
 *	7/09/96		kipo	changed DPSYS_ADDPLAYER to DPSYS_CREATEPLAYERORGROUP and
 *						DPSYS_DELETEPLAYER/GROUP to DPSYS_DESTROYPLAYERORGROUP;
 *						changed player data/name messages to
 *						DPSYS_SETPLAYERORGROUPDATA and DPMSG_SETPLAYERORGROUPNAME;
 *						made the old system messages obsolete.
 *  7/11/96     ajayj   Deleted some flags which weren't use at all in Dplay1 or DPlay3
 *  7/14/96     ajayj   Added constants DPID_SYSMSG, DPID_ALLPLAYERS
 *                      Added structures DPMSG_HOST, DPMSG_SESSIONLOST, DPMSG_CONNECT all
 *                          are typedefs of DPMSG_GENERIC
 *                      Made system message comments more consistent.
 *  7/20/96     kipo	The GetPlayerName interface declartion in IDirectPlay2 had an
 *						extra DWORD parameter at the end. #2523
 *  7/23/96     ajayj	Moved DPSYS_CONNECT to the obsolete DPlay1 constants section
 *  7/27/96     kipo    Added GUID to EnumGroupPlayers(); changed CreatePlayer()
 *                      to take an event handle instead of an event pointer.
 *  7/31/96     kipo    CreatePlayer() still had a LPHANDLE instead of a HANDLE parameter.
 *  8/1/96		andyco	added DPSESSION_KEEPALIVE, DPCAPS_OPTIMIZEKEEPALIVE flags
 *  8/1/96      sohailm Added IDirectPlay2 and IDirectPlay interface macros
 *  8/8/96      ajayj   typedef LPDIRECTPLAY to be struct IUnknown when the
 *                      symbol IDIRECTPLAY2_OR_GREATER is defined so app can
 *                      still QI on IDirectPlay to obtain IDirectPlay2.
 *  8/8/96      ajayj   added definitions for DPCAPS_GUARANTEEDOPTIMIZED and
 *                      DPCAPS_GUARANTEEDSUPPORTED
 *  8/10/96		andyco	added DPSESSION_DATACHANGEENABLED and player data to 
 *						destroy player message
 *  8/10/96     sohailm Bug# 2224: declared pointers in callbacks as const.
 *	8/13/96		myronth	Added DPERR_NOTLOBBIED
 *  8/16/96             andyco  backed out the constant changes.
 *  8/20/96     ajayj   fixed TABS. Remove DPENUMPLAYERS_ALL. MSINTERNAL
 *                      around DPSESSION_NOPLAYERMGMT.
 *	8/22/96		andyco	added DPENUMPLAYERS_ALL again.
 *  8/25/96		kipo	DPERR_NOINTERFACE was defined twice for some reason
 *  10/11/96    sohailm added struct DPMSG_SETSESSIONDESC and constant DPSYS_SETSESSIONDESC 
 *	11/11/96	andyco	added idirectplay3, DPID_SERVERPLAYER, DPPLAYER_SERVERPLAYER
 *	 2/10/97	kipo	commented out DPSEND_HIGHPRIORITY flag since its obsolete
 *	 2/11/97	kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
 *	 2/14/97	aarono	added DPERR_PENDING
 *	2/29/97		andyco	added clsid_directplay
 *	2/30/97		andyco	enumconnections, initializeconnection
 *	3/12/97		myronth	DPCONNECTION_* flags
 *  3/12/97     sohailm added SecureOpen() to IDirectPlay3 and 3A interfaces, corresponding macros,
 *                      DPCREDENTIALS and DPSECURITYDESC structures, DPSESSION_SECURESERVER flag,
 *                      and Security related errors.
 *	3/17/97		kipo	added support for DPADDRESSTYPEDESC structure
 *	3/24/97		kipo	IDirectPlay3 now inherits from IDirectPlay2
 *  3/24/97     sohailm added flags DPSESSION_PRIVATE, DPENUMSESSIONS_PASSWORDREQUIRED and 
 *                      errors DPERR_INVALIDPASSWORD,DPERR_JOINDISABLED,DPERR_PLAYERSMAXEDOUT
 *	3/25/97		kipo	EnumConnections takes a const *GUID now
 *	4/5/97		andyco	DPSESSION_MULTICASTSERVER
 *  4/09/97     sohailm Added error DPERR_CANTLOADSECURITYPACKAGE.
 *  4/23/97     sohialm Added flags DPCAPS_SIGNINGSUPPORTED, DPCAPS_ENCRYPTIONSUPPORTED, 
 *                      DPSEND_SIGNED and DPSEND_ENCRYTPED.
 *                      Added error DPERR_ENCRYPTIONNOTSUPPORTED.
 *  4/24/97     sohailm Added DPSYS_SECUREMESSAGE and DPMSG_SECUREMESSAGE.
 *	4/30/97		andyco	added groupingroup support
 *  5/7/97		ajayj	added back DPSEND_HIGHPRIORITY
 *	5/8/97		andyco	exposed server_player, client_server and removed update list
 *	5/8/97		myronth	moved DPLCONNECTION from dplobby.h, added StartSession,
 *						Get/SetGroupConnectionSettings, StartSession message
 *	5/10/97		kipo	added GUID to EnumConnections callback
 *  5/12/97     sohailm renamed lpszSecurityPackageName field of DPSECURITYDESC to lpszSSPIProvider
 *                      added fields lpszCAPIProvider, dwCAPIProviderType, and dwEncryptionAlgorithm 
 *                       to DPSECURITYDESC.
 *                      added DPERR_CANTLOADCAPI and DPERR_NOTLOGGEDIN (not exposed).
 *	5/17/97		myronth	Added SendChatMessage, DPCHAT, and it's flags, Moved
 *						DPLCONNECTION flags below other definitions they reference
 *	5/18/97		kipo	added new DPENUM_PLAYERS and DPENUM_GROUP flags
 *  5/18/97     sohailm removed ms internal around DPERR_NOTLOGGEDIN.
 *  5/21/97     sohailm removed DPSECURE_SIGNED and DPSECURE_ENCRYPTED flags. We are going
 *                      to use DPSEND_SIGNED and DPSEND_ENCRYPTED instead.
 *	5/21/97		myronth	Changed DPMSG_CHAT structure to correct format (#8642)
 *  5/22/97		ajayj	Added typedefs for DPENUMGROUPS_ flags
 *	5/22/97		myronth	Added dwFlags member to DPMSG_CHAT (#8868)
 *  5/22/97		ajayj	Removed new DPLCONNECTION flags for lobby messaging
 *	5/23/97		kipo	Added support for return status codes
 *	5/25/97		kipo	Added DPERR_CONNECTING error
 *	5/27/97		kipo	Add player flags to CreateGroup/Player and DestroyGroup/Player
 *  5/30/97		ajayj	Added DPENUMGROUPS_ALL
 *	5/30/97		myronth	Added GetGroupParent
 *  5/30/97     sohailm Added domain name member to DPCREDENTIALS.
 *                      Added GetPlayerAccount() to IDirectPlay3, related macros, and DPACCOUNTDESC.
 *	5/30/97		kipo	Added GetPlayerFlags() and GetGroupFlags()
 *  5/30/97		ajayj	Added service provider GUIDs.
 *  6/09/97     sohailm Added DPERR_LOGONDENIED and removed DPERR_INVALIDCREDENTIALS.
 *  6/16/97     sohailm Removed DPCAPS_ENCRYPTIONOPTIZED and DPCAPS_SIGNINGOPTIMIZED.
 *	7/30/97		myronth	Added DPSEND_LOBBYSYSTEMMESSAGE for standard lobby messaging
 *  8/4/97		andyco	added DPSEND_ASYNC so we can make addforward async
 *	10/21/97	myronth	Added IDirectPlay4 interface definitions, also added
 *						hidden group flags and owner player flags
 *	10/21/97	andyco	added openvoice
 *	10/29/97	myronth	Fixed owner player flag, added SetGroupOwner message
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97	myronth	Added DPCONNECT_ASYNC & STOPASYNC flags
 *	12/3/97		myronth	Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/28/98		sohaiml	added DPSESSON_OPTIMIZELATENCY and DPSESSION_OPTIMIZEBANDWIDTH.
 *  2/2/98      aarono  added DPERR_INVALIDPRIORITY
 *  2/5/98      aarono  changed SGBUFFER item order to lineup with WSABUF
 *  2/18/98     aarono  added new CAPS bits for info on new APIs behaviour
 *	2/18/98	   a-peterz	removed DPSESSION_OPTIMIZEBANDWIDTH.
 *	3/19/98	   a-peterz	DP[SYS/MSG]_SENDCOMPLETE were in the obsolete section.
 *	4/14/98	   a-peterz	#18340 DPSEND_NOCOPY made MSINTERNAL
 *  8/02/99		aarono  removed old voice support
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPLAY_INCLUDED__
#define __DPLAY_INCLUDED__

#include <ole2.h>       // for DECLARE_INTERFACE and HRESULT

/* avoid warnings in MSVC at Level4 */
#pragma warning(disable:4201)


/*
 * Some types
 */

#ifndef _WIN64
#define DWORD_PTR DWORD
#endif

typedef LPVOID (*LPRGLPVOID)[];
typedef LPRGLPVOID PRGPVOID, LPRGPVOID, PRGLPVOID, PAPVOID, LPAPVOID, PALPVOID, LPALPVOID;

#define VOL volatile
typedef VOID *VOL LPVOIDV;


#define _FACDP  0x877
#define MAKE_DPHRESULT( code )    MAKE_HRESULT( 1, _FACDP, code )

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectPlay objects
 */
DEFINE_GUID(IID_IDirectPlay2, 0x2b74f7c0, 0x9154, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);
DEFINE_GUID(IID_IDirectPlay2A,0x9d460580, 0xa822, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

DEFINE_GUID(IID_IDirectPlay3, 0x133efe40, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);
DEFINE_GUID(IID_IDirectPlay3A,0x133efe41, 0x32dc, 0x11d0, 0x9c, 0xfb, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

DEFINE_GUID(IID_IDirectPlay4, 0xab1c530, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);
DEFINE_GUID(IID_IDirectPlay4A,0xab1c531, 0x4745, 0x11d1, 0xa7, 0xa1, 0x0, 0x0, 0xf8, 0x3, 0xab, 0xfc);

// {D1EB6D20-8923-11d0-9D97-00A0C90A43CB}
DEFINE_GUID(CLSID_DirectPlay,0xd1eb6d20, 0x8923, 0x11d0, 0x9d, 0x97, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);

/*
 * GUIDS used by Service Providers shipped with DirectPlay
 * Use these to identify Service Provider returned by EnumConnections
 */

// GUID for IPX service provider
// {685BC400-9D2C-11cf-A9CD-00AA006886E3}
DEFINE_GUID(DPSPGUID_IPX, 
0x685bc400, 0x9d2c, 0x11cf, 0xa9, 0xcd, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

// GUID for TCP/IP service provider
// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(DPSPGUID_TCPIP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// GUID for Serial service provider
// {0F1D6860-88D9-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSPGUID_SERIAL,						
0xf1d6860, 0x88d9, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// GUID for Modem service provider
// {44EAA760-CB68-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSPGUID_MODEM,
0x44eaa760, 0xcb68, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

/****************************************************************************
 *
 * DirectPlay Structures
 *
 * Various structures used to invoke DirectPlay.
 *
 ****************************************************************************/

#ifndef IDIRECTPLAY2_OR_GREATER
typedef struct IDirectPlay        FAR *LPDIRECTPLAY;
#else
typedef struct IUnknown           FAR *LPDIRECTPLAY;
#endif

typedef struct IDirectPlay2       FAR *LPDIRECTPLAY2;
typedef struct IDirectPlay2       FAR *LPDIRECTPLAY2A;
typedef struct IDirectPlay2       IDirectPlay2A;

typedef struct IDirectPlay3       FAR *LPDIRECTPLAY3;
typedef struct IDirectPlay3       FAR *LPDIRECTPLAY3A;
typedef struct IDirectPlay3       IDirectPlay3A;

typedef struct IDirectPlay4       FAR *LPDIRECTPLAY4;
typedef struct IDirectPlay4       FAR *LPDIRECTPLAY4A;
typedef struct IDirectPlay4       IDirectPlay4A;

/*
 * DPID
 * DirectPlay player and group ID
 */
typedef DWORD DPID, FAR *LPDPID;

/*
 * DPID that system messages come from
 */
#define DPID_SYSMSG         0

/*
 * DPID representing all players in the session
 */
#define DPID_ALLPLAYERS     0

/*
 * DPID representing the server player
 */
#define DPID_SERVERPLAYER	1

//@@BEGIN_MSINTERNAL
/*
 * DPID representing the lobby's system player (only used internally
 * and only used in lobby sessions)
 */
#define DPID_LOBBYSYSTEMPLAYER    2

/*
 * DPID representing the lobby's system group (only used internally
 * and only used in lobby sessions)
 */
#define DPID_LOBBYSYSTEMGROUP     3

/*
 * DPID representing the lobby's system player for all remote
 * players and groups (only used internally and only used in lobby sessions)
 */
#define DPID_LOBBYREMOTESYSTEMPLAYER     4
//@@END_MSINTERNAL

/*
 * DPID representing the maxiumum ID in the range of DPID's reserved for
 * use by DirectPlay.
 */
#define DPID_RESERVEDRANGE     100

/*
 * The player ID is unknown (used with e.g. DPSESSION_NOMESSAGEID)
 */
#define DPID_UNKNOWN		0xFFFFFFFF

/*
 * DPCAPS
 * Used to obtain the capabilities of a DirectPlay object
 */
typedef struct
{
    DWORD dwSize;               // Size of structure, in bytes
    DWORD dwFlags;              // DPCAPS_xxx flags
    DWORD dwMaxBufferSize;      // Maximum message size, in bytes,  for this service provider
    DWORD dwMaxQueueSize;       // Obsolete. 
    DWORD dwMaxPlayers;         // Maximum players/groups (local + remote)
    DWORD dwHundredBaud;        // Bandwidth in 100 bits per second units; 
                                // i.e. 24 is 2400, 96 is 9600, etc.
    DWORD dwLatency;            // Estimated latency; 0 = unknown
    DWORD dwMaxLocalPlayers;    // Maximum # of locally created players allowed
    DWORD dwHeaderLength;       // Maximum header length, in bytes, on messages
                                // added by the service provider
    DWORD dwTimeout;            // Service provider's suggested timeout value
                                // This is how long DirectPlay will wait for 
                                // responses to system messages
} DPCAPS, FAR *LPDPCAPS;

/*
 * This DirectPlay object is the session host.  If the host exits the
 * session, another application will become the host and receive a
 * DPSYS_HOST system message.
 */
#define DPCAPS_ISHOST               0x00000002

/*
 * The service provider bound to this DirectPlay object can optimize
 * group messaging.
 */
#define DPCAPS_GROUPOPTIMIZED       0x00000008

/*
 * The service provider bound to this DirectPlay object can optimize
 * keep alives (see DPSESSION_KEEPALIVE)
 */
#define DPCAPS_KEEPALIVEOPTIMIZED   0x00000010

/*
 * The service provider bound to this DirectPlay object can optimize
 * guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDOPTIMIZED  0x00000020

/*
 * This DirectPlay object supports guaranteed message delivery.
 */
#define DPCAPS_GUARANTEEDSUPPORTED  0x00000040

/*
 * This DirectPlay object supports digital signing of messages.
 */
#define DPCAPS_SIGNINGSUPPORTED     0x00000080

/*
 * This DirectPlay object supports encryption of messages.
 */
#define DPCAPS_ENCRYPTIONSUPPORTED  0x00000100

/*
 * This DirectPlay player was created on this machine
 */
#define DPPLAYERCAPS_LOCAL			0x00000800

/*
 * Current Open settings supports all forms of Cancel
 */
#define DPCAPS_ASYNCCANCELSUPPORTED    0x00001000

/*
 * Current Open settings supports CancelAll, but not Cancel
 */
#define DPCAPS_ASYNCCANCELALLSUPPORTED 0x00002000

/*
 *  Current Open settings supports Send Timeouts for sends
 */
#define DPCAPS_SENDTIMEOUTSUPPORTED   0x00004000

/*
 *  Current Open settings supports send priority
 */
#define DPCAPS_SENDPRIORITYSUPPORTED   0x00008000

/*
 *  Current Open settings supports DPSEND_ASYNC flag
 */
#define DPCAPS_ASYNCSUPPORTED 		   0x00010000

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 * Defined in DPlay 1 header file but appear to have no effect
 * in the code.
 *
 * #define DPCAPS_NAMESERVICE          0x00000001
 * #define DPCAPS_NAMESERVER           DPCAPS_ISHOST
 * #define DPCAPS_GUARANTEED           0x00000004
 */
//@@END_MSINTERNAL

/*
 * DPSESSIONDESC2
 * Used to describe the properties of a DirectPlay
 * session instance
 */
typedef struct
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // DPSESSION_xxx flags
    GUID    guidInstance;       // ID for the session instance
    GUID    guidApplication;    // GUID of the DirectPlay application.
                                // GUID_NULL for all applications.
    DWORD   dwMaxPlayers;       // Maximum # players allowed in session
    DWORD   dwCurrentPlayers;   // Current # players in session (read only)
    union
    {                           // Name of the session
        LPWSTR  lpszSessionName;    // Unicode
        LPSTR   lpszSessionNameA;   // ANSI
    };
    union
    {                           // Password of the session (optional)
        LPWSTR  lpszPassword;       // Unicode
        LPSTR   lpszPasswordA;      // ANSI
    };
    DWORD_PTR   dwReserved1;        // Reserved for future MS use.
    DWORD_PTR   dwReserved2;
    DWORD_PTR   dwUser1;            // For use by the application
    DWORD_PTR   dwUser2;
    DWORD_PTR   dwUser3;
    DWORD_PTR   dwUser4;
} DPSESSIONDESC2, FAR *LPDPSESSIONDESC2;

typedef DPSESSIONDESC2 * VOL LPDPSESSIONDESC2_V;

/*
 * LPCDPSESSIONDESC2
 * A constant pointer to DPSESSIONDESC2
 */
typedef const DPSESSIONDESC2 FAR *LPCDPSESSIONDESC2;
 
/*
 * Applications cannot create new players in this session.
 */
#define DPSESSION_NEWPLAYERSDISABLED    0x00000001 

/*
 * If the DirectPlay object that created the session, the host,
 * quits, then the host will attempt to migrate to another
 * DirectPlay object so that new players can continue to be created
 * and new applications can join the session.
 */
#define DPSESSION_MIGRATEHOST           0x00000004

/*
 * This flag tells DirectPlay not to set the idPlayerTo and idPlayerFrom 
 * fields in player messages.  This cuts two DWORD's off the message 
 * overhead.
 */
#define DPSESSION_NOMESSAGEID           0x00000008

//@@BEGIN_MSINTERNAL
/*
 * This flag tells DirectPlay not to generate player management messages 
 * (DPSYS_CREATEPLAYERORGROUP, DPSYS_DESTROYPLAYERORGROUP,
 * DPSYS_ADDPLAYERTOGROUP, DPSYS_DELETEPLAYERFROMGROUP,
 * DPSYS_SETPLAYERORGROUPDATA, DPSYS_SETPLAYERORGROUPNAME). 
 */
#define DPSESSION_NOPLAYERMGMT          0x00000010
//@@END_MSINTERNAL

/*
 * This flag tells DirectPlay to not allow any new applications to
 * join the session.  Applications already in the session can still
 * create new players.
 */
#define DPSESSION_JOINDISABLED          0x00000020

/*
 * This flag tells DirectPlay to detect when remote players 
 * exit abnormally (e.g. their computer or modem gets unplugged)
 */
#define DPSESSION_KEEPALIVE             0x00000040

/*
 * This flag tells DirectPlay not to send a message to all players
 * when a players remote data changes
 */
#define DPSESSION_NODATAMESSAGES        0x00000080

/*
 * This flag indicates that the session belongs to a secure server
 * and needs user authentication
 */
#define DPSESSION_SECURESERVER          0x00000100

/*
 * This flag indicates that the session is private and requirs a password
 * for EnumSessions as well as Open.
 */
#define DPSESSION_PRIVATE               0x00000200

/*
 * This flag indicates that the session requires a password for joining.
 */
#define DPSESSION_PASSWORDREQUIRED      0x00000400

/*
 * This flag tells DirectPlay to route all messages through the server
 */
#define DPSESSION_MULTICASTSERVER		0x00000800

/*
 * This flag tells DirectPlay to only download information about the
 * DPPLAYER_SERVERPLAYER.  
 */
#define DPSESSION_CLIENTSERVER			0x00001000

/*
 * This flag tells DirectPlay to use the protocol built into dplay
 * for reliability and statistics all the time.  When this bit is
 * set, only other sessions with this bit set can join or be joined.
 */
#define DPSESSION_DIRECTPLAYPROTOCOL	0x00002000

/*
 * This flag tells DirectPlay that preserving order of received
 * packets is not important, when using reliable delivery.  This
 * will allow messages to be indicated out of order if preceding
 * messages have not yet arrived.  Otherwise DPLAY will wait for
 * earlier messages before delivering later reliable messages.
 */
#define DPSESSION_NOPRESERVEORDER		0x00004000


/*
 * This flag tells DirectPlay to optimize communication for latency
 */
#define DPSESSION_OPTIMIZELATENCY		0x00008000

/*
 * This flag allows lobby launched games that aren't voice enabled
 * to get voice capabilities.
 */
#define DPSESSION_ALLOWVOICERETRO		0x00010000

/*
 * This flag supresses transmission of session desc changes.
 * DPSESSION_NODATAMESSAGES was supposed to do that, but SetSessionDesc
 * was ignoring the flag and some apps depended on the broken behavior, this
@@BEGIN_MSINTERNAL
 *	i.e. Jedi Knight
@@END_MSINTERNAL
 * flag allows applications to get the right behaviour without breaking apps depending
 * on old broken behavior.
 */
#define DPSESSION_NOSESSIONDESCMESSAGES		0x00020000
 
/*
 * DPNAME
 * Used to hold the name of a DirectPlay entity
 * like a player or a group
 */
typedef struct 
{
    DWORD   dwSize;             // Size of structure
    DWORD   dwFlags;            // Not used. Must be zero.
    union
    {                           // The short or friendly name
        LPWSTR  lpszShortName;  // Unicode
        LPSTR   lpszShortNameA; // ANSI
    };
    union
    {                           // The long or formal name
        LPWSTR  lpszLongName;   // Unicode
        LPSTR   lpszLongNameA;  // ANSI
    };

} DPNAME, FAR *LPDPNAME;

/*
 * LPCDPNAME
 * A constant pointer to DPNAME
 */
typedef const DPNAME FAR *LPCDPNAME;

/*
 * DPCREDENTIALS
 * Used to hold the user name and password of a DirectPlay user
 */
typedef struct 
{
    DWORD dwSize;               // Size of structure
    DWORD dwFlags;              // Not used. Must be zero.
    union
    {                           // User name of the account
        LPWSTR  lpszUsername;   // Unicode
        LPSTR   lpszUsernameA;  // ANSI
    };    
    union
    {                           // Password of the account
        LPWSTR  lpszPassword;   // Unicode
        LPSTR   lpszPasswordA;  // ANSI
    };    
    union
    {                           // Domain name of the account
        LPWSTR  lpszDomain;     // Unicode
        LPSTR   lpszDomainA;    // ANSI
    };    
} DPCREDENTIALS, FAR *LPDPCREDENTIALS;

typedef const DPCREDENTIALS FAR *LPCDPCREDENTIALS;

/*
 * DPSECURITYDESC
 * Used to describe the security properties of a DirectPlay
 * session instance
 */
typedef struct 
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
    union
    {                               // SSPI provider name
        LPWSTR  lpszSSPIProvider;   // Unicode
        LPSTR   lpszSSPIProviderA;  // ANSI
    };
    union
    {                               // CAPI provider name
        LPWSTR lpszCAPIProvider;    // Unicode
        LPSTR  lpszCAPIProviderA;   // ANSI
    };
    DWORD dwCAPIProviderType;       // Crypto Service Provider type
    DWORD dwEncryptionAlgorithm;    // Encryption Algorithm type
} DPSECURITYDESC, FAR *LPDPSECURITYDESC;

typedef const DPSECURITYDESC FAR *LPCDPSECURITYDESC;

/*
 * DPACCOUNTDESC
 * Used to describe a user membership account
 */
typedef struct 
{
    DWORD dwSize;                   // Size of structure
    DWORD dwFlags;                  // Not used. Must be zero.
    union
    {                               // Account identifier
        LPWSTR  lpszAccountID;      // Unicode
        LPSTR   lpszAccountIDA;     // ANSI
    };
} DPACCOUNTDESC, FAR *LPDPACCOUNTDESC;

typedef const DPACCOUNTDESC FAR *LPCDPACCOUNTDESC;

/*
 * LPCGUID
 * A constant pointer to a guid
 */
typedef const GUID FAR *LPCGUID;

/*
 * DPLCONNECTION
 * Used to hold all in the informaion needed to connect
 * an application to a session or create a session
 */
typedef struct
{
    DWORD               dwSize;             // Size of this structure
    DWORD               dwFlags;            // Flags specific to this structure
    LPDPSESSIONDESC2    lpSessionDesc;      // Pointer to session desc to use on connect
    LPDPNAME            lpPlayerName;       // Pointer to Player name structure
    GUID                guidSP;             // GUID of the DPlay SP to use
    LPVOID              lpAddress;          // Address for service provider
    DWORD               dwAddressSize;      // Size of address data
} DPLCONNECTION, FAR *LPDPLCONNECTION;

/*
 * LPCDPLCONNECTION
 * A constant pointer to DPLCONNECTION
 */
typedef const DPLCONNECTION FAR *LPCDPLCONNECTION;

/*
 * DPCHAT
 * Used to hold the a DirectPlay chat message
 */
typedef struct
{
    DWORD               dwSize;
    DWORD               dwFlags;
    union
    {                          // Message string
        LPWSTR  lpszMessage;   // Unicode
        LPSTR   lpszMessageA;  // ANSI
    };    
} DPCHAT, FAR * LPDPCHAT;

/*
 * SGBUFFER
 * Scatter Gather Buffer used for SendEx
 */
typedef struct 
{
	UINT         len;       // length of buffer data
	PUCHAR	     pData;		// pointer to buffer data
} SGBUFFER, *PSGBUFFER, FAR *LPSGBUFFER;


/****************************************************************************
 *
 * Prototypes for DirectPlay callback functions
 *
 ****************************************************************************/

/*
 * Callback for IDirectPlay2::EnumSessions
 */
typedef BOOL (FAR PASCAL * LPDPENUMSESSIONSCALLBACK2)(
    LPCDPSESSIONDESC2   lpThisSD,
    LPDWORD             lpdwTimeOut,
    DWORD               dwFlags,
    LPVOID              lpContext );

/*
 * This flag is set on the EnumSessions callback dwFlags parameter when
 * the time out has occurred. There will be no session data for this 
 * callback. If *lpdwTimeOut is set to a non-zero value and the 
 * EnumSessionsCallback function returns TRUE then EnumSessions will 
 * continue waiting until the next timeout occurs. Timeouts are in 
 * milliseconds.
 */
#define DPESC_TIMEDOUT          0x00000001


/*
 * Callback for IDirectPlay2::EnumPlayers
 *              IDirectPlay2::EnumGroups
 *              IDirectPlay2::EnumGroupPlayers
 */
typedef BOOL (FAR PASCAL *LPDPENUMPLAYERSCALLBACK2)(
    DPID            dpId,
    DWORD           dwPlayerType,
    LPCDPNAME       lpName,
    DWORD           dwFlags,
    LPVOID          lpContext );


/*
 * Unicode callback for DirectPlayEnumerate
 * This callback prototype will be used if compiling
 * for Unicode strings
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACK)(
    LPGUID      lpguidSP,
    LPWSTR      lpSPName,
    DWORD       dwMajorVersion,
    DWORD       dwMinorVersion,
    LPVOID      lpContext);

/*
 * ANSI callback for DirectPlayEnumerate
 * This callback prototype will be used if compiling
 * for ANSI strings
 */
typedef BOOL (FAR PASCAL * LPDPENUMDPCALLBACKA)(
    LPGUID      lpguidSP,
    LPSTR       lpSPName,
    DWORD       dwMajorVersion,     
    DWORD       dwMinorVersion,
    LPVOID      lpContext);

/*
 * Callback for IDirectPlay3(A)::EnumConnections
 */
typedef BOOL (FAR PASCAL * LPDPENUMCONNECTIONSCALLBACK)(
    LPCGUID     lpguidSP,
	LPVOID		lpConnection,
	DWORD		dwConnectionSize,
    LPCDPNAME   lpName,
	DWORD 		dwFlags,
	LPVOID 		lpContext);


/*
 * API's
 */

#ifdef UNICODE
#define DirectPlayEnumerate     DirectPlayEnumerateW
#else
#define DirectPlayEnumerate     DirectPlayEnumerateA
#endif // UNICODE

extern HRESULT WINAPI DirectPlayEnumerateA( LPDPENUMDPCALLBACKA, LPVOID );
extern HRESULT WINAPI DirectPlayEnumerateW( LPDPENUMDPCALLBACK, LPVOID );
extern HRESULT WINAPI DirectPlayCreate( LPGUID lpGUID, LPDIRECTPLAY *lplpDP, IUnknown *pUnk);

/****************************************************************************
 *
 * IDirectPlay2 (and IDirectPlay2A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay2
DECLARE_INTERFACE_( IDirectPlay2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlay2 interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay2_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay2_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlay2_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlay2_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay2_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlay2_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay2_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlay2_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay2_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay2_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay2_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlay2_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay2_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay2_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay2_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay2_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay2_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlay2_GetGroupNa